1
00:00:16,660 --> 00:00:18,000
科尔顿·奥格登：大家好 
COLTON OGDEN: Hi, everybody.

2
00:00:18,000 --> 00:00:21,740
我的名字是科尔顿·奥格登 这是GD50第一课 
My name is Colton Ogden, and this is GD50 lecture one,

3
00:00:21,740 --> 00:00:24,480
今天我们将报道Flappy Bird 
and today we'll be covering Flappy Bird.

4
00:00:24,480 --> 00:00:27,810
所以去年或上周 抱歉 我们报道了乒乓球 
So last year or last week, sorry, we covered Pong,

5
00:00:27,810 --> 00:00:30,730
这只是基本的形状和颜色 
which was just basic shapes and colors.

6
00:00:30,730 --> 00:00:32,640
今天 我们将真正潜入精灵之中 
Today we'll actually be diving into sprites.

7
00:00:32,640 --> 00:00:35,010
正如我们在这里看到的 我们有一些管子和一只鸟 
As we can see here, we've got some pipes, and a bird,

8
00:00:35,010 --> 00:00:39,540
我们还讨论了其他一些概念 如重力等 
and we're covering a few other concepts such as gravity, and more.

9
00:00:39,540 --> 00:00:43,140
今天 我们将涵盖的主题简而言之就是图像和精灵 
Today, the topics that we'll be covering are in a nutshell, images and sprites,

10
00:00:43,140 --> 00:00:43,860
就像我刚才说的 
as I just said.

11
00:00:43,860 --> 00:00:46,530
因此 从我们的硬盘中加载内存中的图像 
So loading images from memory from our hard drive,

12
00:00:46,530 --> 00:00:50,040
并将它们绘制到屏幕上 而不仅仅是矩形 
and actually drawing them to the screen instead of just rectangles,

13
00:00:50,040 --> 00:00:50,825
诸如此类的 
and whatnot.

14
00:00:50,825 --> 00:00:52,560
我们将覆盖无限滚动 
We'll be covering infinite scrolling.

15
00:00:52,560 --> 00:00:55,170
所以 如果你玩过这个游戏 
So seeing things like-- and if you've played the game,

16
00:00:55,170 --> 00:00:57,690
管道无限地从右向左延伸 
pipes are infinitely going from right to left.

17
00:00:57,690 --> 00:01:00,240
如何真正让它无限地进行 这样我们就不会
How to actually get that going infinitely so that we're not

18
00:01:00,240 --> 00:01:02,910
也会耗尽无限的内存 
using up also infinite memory.

19
00:01:02,910 --> 00:01:05,489
我们将以类似的方式讨论游戏是如何
We'll be discussing how games, and in the similar vein,

20
00:01:05,489 --> 00:01:10,710
是幻觉 从某种意义上说 许多感知到的浩瀚和感知
are illusions in the sense that a lot of the perceived vastness and perceived

21
00:01:10,710 --> 00:01:14,520
游戏的复杂性往往只是由于相机的诡计 
complexity of games is often just due to camera trickery,

22
00:01:14,520 --> 00:01:17,650
更多的原因是有限的硬件 
and more because of limited hardware.

23
00:01:17,650 --> 00:01:19,860
我们将介绍程序生成 它
We'll be covering procedural generation, which

24
00:01:19,860 --> 00:01:21,854
纽带还可以无限滚动 
ties also into infinite scrolling.

25
00:01:21,854 --> 00:01:24,770
程序生成其实是我非常感兴趣的一个话题 
Procedure generation is a topic that I am actually very interested in,

26
00:01:24,770 --> 00:01:27,720
并将在整个课程中在几个地点涉及到它 
and will be touching on it throughout the course in several locations.

27
00:01:27,720 --> 00:01:32,190
但在今天的演讲中 我们将用它来制作管道
But in the context of today's lecture, we'll be using it for the pipes

28
00:01:32,190 --> 00:01:34,966
因为管子 它们在Flappy Bird中从右到左繁殖
because the pipes, they spawn from right to left in Flappy Bird

29
00:01:34,966 --> 00:01:36,840
当你无限地通过关卡的时候 
as you're infinitely going through the level,

30
00:01:36,840 --> 00:01:39,900
但它们可以在不同的高度产卵 
but they can spawn at various heights, and the gaps

31
00:01:39,900 --> 00:01:44,640
正因为如此而移动 因此创造了这个无限的水平 
are shifting as a result of that, therefore creating this infinite level.

32
00:01:44,640 --> 00:01:46,744
我们将更详细地讨论状态机 
We'll be talking more in detail on state machines.

33
00:01:46,744 --> 00:01:49,410
因此 上周我们以非常抽象的方式介绍了状态机 
So last week we covered state machines in a very abstract sense.

34
00:01:49,410 --> 00:01:53,040
我们基本上只使用一个字符串作为变量 然后使用if条件 
We used just basically a string as a variable, and then used if conditions.

35
00:01:53,040 --> 00:01:55,170
今天我们将实际使用状态机
Today we'll be actually using a state machine

36
00:01:55,170 --> 00:01:57,870
用各种方法填充的类 这些方法允许
class replete with various methods that allow

37
00:01:57,870 --> 00:02:00,210
美国在这些州的进进出出
us to transition in and out of these states very

38
00:02:00,210 --> 00:02:02,700
干净利落地 让我们打破所有这些逻辑
cleanly, and allow us to break out all of this logic

39
00:02:02,700 --> 00:02:05,700
我们以前在更新和渲染函数中拥有的 
that we previously had in our update and render functions,

40
00:02:05,700 --> 00:02:09,600
然后把它们分别放在各自的州立班级中 
and then put them separately into their own state classes.

41
00:02:09,600 --> 00:02:12,060
最后 我们还将讨论鼠标输入 
And then lastly, we'll also be touching on mouse input.

42
00:02:12,060 --> 00:02:15,010
还有一点是我忘了在这里提的 
And a point that I forgot to mention here,

43
00:02:15,010 --> 00:02:20,070
哎呀 我们还会讨论音乐 这基本上就是
whoops, is also we'll be talking about music, which is just basically

44
00:02:20,070 --> 00:02:21,960
听起来像我们上周做的那样 
sound, which we did last week.

45
00:02:21,960 --> 00:02:24,369
但我们将添加这一点作为润色 
But we'll add that as a polishing touch.

46
00:02:24,369 --> 00:02:26,160
如果你们想下载演示代码的话 
If you guys want to download the demo code.

47
00:02:26,160 --> 00:02:31,410
我们现在在GitHub/Games50/五十鸟上有回购 
We have a repo up right now on GitHub/games50/fiftybirds.

48
00:02:31,410 --> 00:02:34,440
这是我们对Flappy Bird的看法 
It's our take on Flappy Bird.

49
00:02:34,440 --> 00:02:36,700
有几件事 我被问了几次
A couple of things, I've been asked a couple of times

50
00:02:36,700 --> 00:02:39,170
我们是否有这门课程的阅读材料 
whether we have reading materials for the course.

51
00:02:39,170 --> 00:02:40,920
而且没有正式的阅读材料 
And there are no formal reading materials,

52
00:02:40,920 --> 00:02:42,961
但有几个资源我真的
but there are a couple of resources that I really

53
00:02:42,961 --> 00:02:46,890
我喜欢阅读 尤其是在我对Lua和Love2D有了更多了解的时候 
enjoyed reading, especially as I was getting more into Lua and Love2D.

54
00:02:46,890 --> 00:02:48,720
这是两本书 
They are two books.

55
00:02:48,720 --> 00:02:49,800
一种是在线图书 
One is an online book.

56
00:02:49,800 --> 00:02:52,470
事实上 它们都是在线书籍 但后者
Actually, they're both online books, but the latter of which

57
00:02:52,470 --> 00:02:54,180
也有一种物质形式 
has a physical form as well.

58
00:02:54,180 --> 00:02:57,360
第一个是丹·肖勒所著的如何制作RPG 它
The first of these is How to Make an RPG by Dan Schoeller, which

59
00:02:57,360 --> 00:02:59,820
实际上完全是用Lua编写的 
is actually completely written in Lua.

60
00:02:59,820 --> 00:03:03,330
他使用的定制游戏引擎非常类似于Love2D 
He uses a custom game engine very similar to Love2D,

61
00:03:03,330 --> 00:03:04,910
但这是他亲笔写的 
but it's handwritten by him.

62
00:03:04,910 --> 00:03:07,629
但很多相同的想法都适用 这是一个很好的机会 
But a lot of the same ideas apply, and it's a great opportunity.

63
00:03:07,629 --> 00:03:09,420
这就是我对Lua咬牙的方式 我会
It's how I cut my teeth on Lua, and I would

64
00:03:09,420 --> 00:03:12,669
如果你对此感兴趣 鼓励你去看一看 
encourage you to take a look at that if that's something you're interested in,

65
00:03:12,669 --> 00:03:14,310
或者如果你喜欢RPG的话 
or if you like RPGs.

66
00:03:14,310 --> 00:03:17,070
然后是Robert Nystrom的游戏编程模式
And then also Game Programming Patterns by Robert Nystrom

67
00:03:17,070 --> 00:03:20,220
是一款非常棒的通用游戏开发
is a very great general purpose game development

68
00:03:20,220 --> 00:03:23,820
这本书谈到了许多更抽象的高级概念
book that talks about a lot of the sort of more abstract high level concepts

69
00:03:23,820 --> 00:03:25,440
伴随着大规模的游戏开发 
with large scale game development.

70
00:03:25,440 --> 00:03:27,006
但除此之外 没有正式的阅读 
But beyond that, no formal reading.

71
00:03:27,006 --> 00:03:28,380
这些也不是从阅读中获得的 
Those aren't from reading either.

72
00:03:28,380 --> 00:03:29,730
这些只是如果你好奇的话 你
Those are just if you're curious, and you

73
00:03:29,730 --> 00:03:32,146
我想读一些我觉得很有趣的资源 
want to read some resources that I found very interesting.

74
00:03:32,146 --> 00:03:33,300
请随意这样做 
Feel free to do so.

75
00:03:33,300 --> 00:03:36,660
今天的目标是实现看起来像这样的东西 
Today's goal is to implement what looks like this.

76
00:03:36,660 --> 00:03:39,150
这是我们的飞鸟版本 
This is our version of Flappy Bird.

77
00:03:39,150 --> 00:03:41,790
出于版权目的 我们并没有使用完全相同的精灵 
We didn't use the same exact sprites for copyright purposes,

78
00:03:41,790 --> 00:03:45,640
但我们注意到 屏幕中央有一只鸟 
but we note that we have a bird in the middle of the screen.

79
00:03:45,640 --> 00:03:49,410
这只鸟 点击一下 或者在空格键上 会跳上跳下 
This bird, on click, or on spacebar, will jump up and down,

80
00:03:49,410 --> 00:03:51,660
你的目标是防止这只鸟碰到
and your goal is to prevent the bird from touching

81
00:03:51,660 --> 00:03:55,380
要么是管道 要么是地面本身 
either the pipes or the ground itself.

82
00:03:55,380 --> 00:03:58,920
每次你通过一对管子 你就得一分 
Every time you make it past a pair of pipes, you will score a point.

83
00:03:58,920 --> 00:04:01,590
你一碰烟斗或落地 游戏就结束了 
As soon as you touch a pipe or hit the ground, the game is over,

84
00:04:01,590 --> 00:04:03,700
就是这样 
and that's that.

85
00:04:03,700 --> 00:04:05,907
所以今天我们将会报道--
So today we'll be covering--

86
00:04:05,907 --> 00:04:07,740
我将进行更多的实时编码 
I'll be doing a little bit more live coding.

87
00:04:07,740 --> 00:04:09,750
所以我想要介绍的第一个例子
So the very first example that I want to cover

88
00:04:09,750 --> 00:04:12,660
是Flappy Bird的零日更新 
is the day zero update for Flappy Bird.

89
00:04:12,660 --> 00:04:15,540
一个重要的功能可能是
And a important function that is going to be probably

90
00:04:15,540 --> 00:04:18,149
最引人注目 最明显的功能 我们将
the most noticeable, the most visibly obvious function we'll

91
00:04:18,149 --> 00:04:23,010
在整个演讲中使用的是love.graph ics.newImage 
be using throughout this lecture, is love.graphics.newImage,

92
00:04:23,010 --> 00:04:24,360
它走的是一条路 
which takes a path.

93
00:04:24,360 --> 00:04:28,320
这个功能 它所做的就是从你的磁盘上加载一个图像文件 
This function, all it does is load a image file from your disk.

94
00:04:28,320 --> 00:04:32,640
您将其指定为字符串 然后可以将其用作对象 
You specify it as a string, and you can then use it as an object,

95
00:04:32,640 --> 00:04:35,250
并在XY坐标下绘制任意位置 
and draw anywhere you want at an xy coordinate,

96
00:04:35,250 --> 00:04:37,210
我们将在这里的实践中看到这一点 
and we'll see this in practice here.

97
00:04:37,210 --> 00:04:38,550
所以我要继续了 
So I'm going to go ahead.

98
00:04:38,550 --> 00:04:42,280
如果你在回购中查看 所有这些例子都有涵盖--
If you're looking in the repo, all of these examples are covered--

99
00:04:42,280 --> 00:04:44,640
0到12 
0 through 12.

100
00:04:44,640 --> 00:04:48,210
我将在我创建的新文件夹中从头开始 
I'm going to start from scratch in a new folder that I've created.

101
00:04:48,210 --> 00:04:53,250
我要创造一个全新的Main Lua 完全新鲜 
I'm going to create a brand new main.lua, completely fresh.

102
00:04:53,250 --> 00:04:57,000
我想做的第一件事是因为我们
And the first thing I want to do is because we

103
00:04:57,000 --> 00:04:59,970
就像我们上周做的那样 使用虚拟分辨率 
are going to use a virtual resolution just like we did last week,

104
00:04:59,970 --> 00:05:01,860
为了让我们有更多的修辞 我要走了
so that we have a more rhetoric, I'm going

105
00:05:01,860 --> 00:05:03,568
继续执行并需要推送库 
to go ahead and require the push library.

106
00:05:03,568 --> 00:05:05,570
因此 推动平等是必要的 
So push equals require.

107
00:05:05,570 --> 00:05:06,720
就像这样推 
Push just like that.

108
00:05:06,720 --> 00:05:09,780
我已将pres.lua预先放入此目录中 
I've pre put push.lua into this directory.

109
00:05:09,780 --> 00:05:12,240
默认情况下 它将加载到相同的目录中--
It'll just load by default in the same directory--

110
00:05:12,240 --> 00:05:15,724
运行Love时脚本的当前工作目录 
the current working directory of your script when you run Love.

111
00:05:15,724 --> 00:05:18,515
接下来我要做的是 定义一些常量 
The next thing I'm going to do, I'm going to define some constants.

112
00:05:18,515 --> 00:05:23,910
所以窗宽应该是1280 然后窗高是720 
So window with should be 1280, and then window height is going to be 720.

113
00:05:23,910 --> 00:05:26,100
这些是我们的物理窗户尺寸 
Those are our physical window dimensions,

114
00:05:26,100 --> 00:05:30,960
但我们还需要一个虚拟宽度 我们将使用512乘以288 
but then we also need a virtual width, and we're going to use 512 by 288.

115
00:05:30,960 --> 00:05:35,040
我发现这一解决方案对我们的资产非常有效
This is a resolution that I found worked pretty well for the assets we'll

116
00:05:35,040 --> 00:05:38,970
现在就用 但你可以把它做成任何你想要的东西
be using today, but you can make this most anything you want to as long

117
00:05:38,970 --> 00:05:40,570
因为它在这个范围内的某个地方 
as it's somewhere in that range.

118
00:05:40,570 --> 00:05:43,260
它的分辨率也是16x9 所以很舒服
It is a 16 by 9 resolution as well, so that it fits comfortably

119
00:05:43,260 --> 00:05:48,362
在现代宽屏16x9显示器上 
on modern wide screen 16 by 9 monitors.

120
00:05:48,362 --> 00:05:51,390
我们要做的是我们今天的第一个目标
What we're going to do is the first goal that we have today

121
00:05:51,390 --> 00:05:55,530
就是在屏幕上绘制两个图像 
is to draw two images to the screen.

122
00:05:55,530 --> 00:05:58,020
我们想要前景和背景 因为注意到 
We want a foreground and a background because notice,

123
00:05:58,020 --> 00:06:01,540
如果我们回到幻灯片上 我们可以在背景中看到
if we go back to the slides, we can see in the very background

124
00:06:01,540 --> 00:06:08,700
我们有一个山丘景观 然后在底部我们有一个地面 
we have a hill landscape, and then on the bottom we have a ground.

125
00:06:08,700 --> 00:06:12,150
这两家公司最终将以不同的速度滚动 
The two of those are going to eventually scroll at different rates.

126
00:06:12,150 --> 00:06:14,396
它将被称为视差滚动 但只是
It's going to be called parallax scrolling, but just

127
00:06:14,396 --> 00:06:16,770
对于我们的第一个例子 我们想要一些非常基本的东西 
for our very first example, we want something very basic.

128
00:06:16,770 --> 00:06:18,760
我只想在屏幕上画两个图像 
I just want to draw two images to the screen.

129
00:06:18,760 --> 00:06:22,500
所以我们将在这里通过设置一个局部变量来实现这一点 
So we're going to go ahead and do that here by setting a local variable.

130
00:06:22,500 --> 00:06:25,560
记住 LOCAL意味着它只是被定义到
Remember, local means that it's just defined to the scope that

131
00:06:25,560 --> 00:06:29,310
它是在 而不是全局的 这意味着我们不能访问这个变量
it's in, rather than being global, which means we cannot access this variable

132
00:06:29,310 --> 00:06:31,590
在这份文件之外 
outside of this file.

133
00:06:31,590 --> 00:06:34,895
本地背景获取love.graph ics.newImage 
Local background gets love.graphics.newImage,

134
00:06:34,895 --> 00:06:36,520
我们刚才谈到的功能 
the function that we just talked about.

135
00:06:36,520 --> 00:06:40,821
让我继续把这个检查员藏在这里 这样我们就可以有更多的房间代码了 
Let me go ahead and hide this inspector here so we can have more room code.

136
00:06:40,821 --> 00:06:42,570
然后它只需要一根绳子 
And then it's just going to take a string.

137
00:06:42,570 --> 00:06:44,536
所以背景.png 
So background.png.

138
00:06:44,536 --> 00:06:47,410
我意识到我实际上并没有将这些文件包括在目录中 
And I realize I actually didn't include those files in the directory.

139
00:06:47,410 --> 00:06:50,080
所以我也需要这么做 
So I'm going to need to do that as well.

140
00:06:50,080 --> 00:06:52,225
地面也是一样 功能也完全一样 
Same thing for the ground, exact same function,

141
00:06:52,225 --> 00:06:55,590
Love.graph ics.newImage 除了round.png 
love.graphics.newImage except ground.png.

142
00:06:55,590 --> 00:06:59,280
趁我还没忘记 让我们现在就去做吧 
And before I forget, let's go ahead, and do that right now.

143
00:06:59,280 --> 00:07:02,055
我这里有文件 
I have the files here.

144
00:07:02,055 --> 00:07:03,660
所以背景和背景 
So ground and background.

145
00:07:03,660 --> 00:07:09,150
我们将把这些文件从发行版repo复制到我的Bird0目录中
We're going to copy those from the distro repo into my bird0 directory

146
00:07:09,150 --> 00:07:11,589
我现在正在开发的 
that I'm currently developing in right now.

147
00:07:11,589 --> 00:07:14,130
一旦我们做完了 我们就会继续下去 
And as soon as we're done with that, we're going to go ahead,

148
00:07:14,130 --> 00:07:16,230
我们将定义love.Load 它
and we're going to define love.load, which

149
00:07:16,230 --> 00:07:20,500
是在程序执行开始时调用的Love2D函数 
is the function Love2D calls at the beginning of your program execution.

150
00:07:20,500 --> 00:07:25,560
在那里 因为我们不想让这些图像看起来模糊
In there, because we don't want these images to look blurry

151
00:07:25,560 --> 00:07:27,510
当他们被加载和升级时 我们希望
when they get loaded and upscaled, we want

152
00:07:27,510 --> 00:07:31,030
要继续并在min和mag上将默认筛选器设置为最近 
to go ahead and set our default filter to nearest on min and mag,

153
00:07:31,030 --> 00:07:34,950
这意味着在高端和低端 应用最近邻居过滤 这
which means on upscale and downscale, apply nearest neighbor filtering, which

154
00:07:34,950 --> 00:07:41,100
表示没有模糊 没有像素内插 
means no blurriness, no interpolation of the pixels.

155
00:07:41,100 --> 00:07:47,120
然后有一件事只是一个小小的触摸 
And then one thing that is just a small little touch,

156
00:07:47,120 --> 00:07:51,390
Love.window.settile五十只鸟因为它是GD50 
love.window.setTitle fifty bird because it's GD50,

157
00:07:51,390 --> 00:07:54,960
然后我们继续在这里设置我们的屏幕
and then we're going to go ahead and set up our screen here

158
00:07:54,960 --> 00:08:01,670
用我们的虚拟宽度、虚拟高度、窗口宽度、窗口高度 
with our virtual width, virtual height, window width, window height.

159
00:08:01,670 --> 00:08:05,730
它变得有点长了 然后它就占据了桌子 
It's getting a bit long, and then it takes in the table.

160
00:08:05,730 --> 00:08:09,180
调用表格 只需像这样接受关键字 
Recall tables, just take in keys like so.

161
00:08:09,180 --> 00:08:14,750
与在Python中使用冒号不同 我们在Love中使用等号 
Unlike in Python where you might use a colon, we use an equal sign in Love,

162
00:08:14,750 --> 00:08:16,820
或者在卢阿岛 我应该说 
or in Lua, I should say.

163
00:08:16,820 --> 00:08:23,740
可调整为True 这就是我们的Load函数的末尾 
Resizable to true, and that is the end of our load function.

164
00:08:23,740 --> 00:08:27,600
现在 有没有人记得如果我们想要调整尺寸--
Now, does anybody recall how if we want to resize--

165
00:08:27,600 --> 00:08:29,120
因此请注意 我将Resizable设置为True 
so notice I set resizable to true.

166
00:08:29,120 --> 00:08:34,169
我们知道如何发送消息来推动我们调整屏幕大小吗？
Do we know how we can send a message to push to resize our screen for us?

167
00:08:37,240 --> 00:08:41,110
因此 Love2D定义了一个名为love.resize的函数 
So Love2D to defines a function called love.resize,

168
00:08:41,110 --> 00:08:43,510
它包含宽度和高度 
which takes in a width and a height.

169
00:08:43,510 --> 00:08:48,005
在那里 我们要做的就是推迟推动 
And in there, all we're going to do is defer that call to push.

170
00:08:48,005 --> 00:08:49,630
在推送时调用完全相同的函数 
Recall the exact same function on push.

171
00:08:49,630 --> 00:08:51,463
它需要一个宽度和高度 这将是
It takes a width and a height, and that will

172
00:08:51,463 --> 00:08:55,390
注意动态调整其内部使用的画布的比例 
take care of dynamically rescaling the canvas it uses internally.

173
00:08:55,390 --> 00:08:58,157
它渲染到一个纹理 然后再渲染到这个纹理
It renders to a texture, and it's going to render to the texture

174
00:08:58,157 --> 00:09:00,490
我们设置为虚拟宽度和虚拟高度 
that we set as the virtual width and the virtual height,

175
00:09:00,490 --> 00:09:02,890
它将对其进行缩放以适应我们的屏幕 
and it's going to scale it to fit our screen.

176
00:09:02,890 --> 00:09:05,320
它需要知道我们的物理屏幕尺寸
And it needs to know our physical screen dimensions

177
00:09:05,320 --> 00:09:11,007
以便它实际上可以适当地适当地缩放内部画布 
so that it can actually properly scale that internal canvas appropriately.

178
00:09:11,007 --> 00:09:14,090
有人记得我们用来从用户那里获取输入的函数吗？
Does anybody remember the function that we use to get input from the user?

179
00:09:17,380 --> 00:09:23,370
因此 函数.love.keyPressed recall 接受一个键 
So function.love.keyPressed, recall, takes in a key.

180
00:09:23,370 --> 00:09:26,310
每次我们按下一个键 爱就会自动呼唤 
Love is going to call this automatically every time we press a key,

181
00:09:26,310 --> 00:09:27,555
这将是--
and that's going to be--

182
00:09:27,555 --> 00:09:31,170
我们将可以访问该密钥 我们可以进行任何类型的逻辑运算
and we're going to have access to that key, and we can do any sort of logic

183
00:09:31,170 --> 00:09:36,180
我们想要那把钥匙 用那把钥匙 
that we want on that key, using that key,

184
00:09:36,180 --> 00:09:38,550
我们只需要给Love打个电话 退出
and we're just going to call love.event.quit

185
00:09:38,550 --> 00:09:41,100
因为我不喜欢按命令Q或点击红色的x 
because I don't like to press Command Q or click the red x.

186
00:09:41,100 --> 00:09:44,380
我只想逃走 结束这一切 
I just want to hit escape, be done with it.

187
00:09:44,380 --> 00:09:47,130
然后我们的渲染是什么--Love的渲染函数叫什么？
And then what's our render-- what's Love's render function called?

188
00:09:49,810 --> 00:09:52,630
这叫爱 画画 
it's called love.draw.

189
00:09:52,630 --> 00:09:55,300
所以给love.draw打电话吧 
So call love.draw.

190
00:09:55,300 --> 00:09:58,210
然后因为我们使用推送 有没有人
And then because we're using push, does anybody

191
00:09:58,210 --> 00:10:01,180
请记住 我们需要实际执行哪些操作才能使推送渲染
remember what we need to actually do to get push to render

192
00:10:01,180 --> 00:10:03,321
把我们的屏幕调到虚拟分辨率？
our screen to a virtual resolution?

193
00:10:06,030 --> 00:10:11,200
回想一下 我们实际上有两种方法可以做到这一点 
So recall that there's actually two ways we can do it.

194
00:10:11,200 --> 00:10:16,950
我们可以调用Push Start和Push Finish 我们上周没有讨论这一点 
We can call push start and push finish, which we didn't cover last week.

195
00:10:16,950 --> 00:10:22,150
或者我们可以打电话--这实际上是一种新的事实上的方式 
Or we can call-- and that's actually the new de facto way to do it.

196
00:10:22,150 --> 00:10:27,660
或者我们可以使用PUSH APPLY START 这是不推荐使用的方法 
Or we can do push apply start, which is the deprecated way to do it.

197
00:10:27,660 --> 00:10:31,790
但从现在开始 我们将称之为Push Start
But starting from here on out, we're going to call push start

198
00:10:31,790 --> 00:10:34,740
然后按下Finish 
and push finish.

199
00:10:34,740 --> 00:10:37,110
最后 我们有自己的图像 
And then last, we have our images.

200
00:10:37,110 --> 00:10:40,680
我们已经把它们作为物品分配到这里了 
We've allocated them as objects up here.

201
00:10:40,680 --> 00:10:44,190
我们有一个背景和一个背景 
We have a background and a ground.

202
00:10:44,190 --> 00:10:47,230
我们现在需要做的就是把它们吸引到屏幕上 
All we need to do now is just draw them to the screen.

203
00:10:47,230 --> 00:10:49,470
所以这是一个新函数 
So this is a new function.

204
00:10:49,470 --> 00:10:52,650
或者它实际上不是一个新功能 
Or it's actually not a new function.

205
00:10:52,650 --> 00:10:55,080
实际上 这是一个新功能 
It is a new function, actually.

206
00:10:55,080 --> 00:10:59,320
矩形是我们上周在所有绘制调用中使用的内容 
Love.graphics.rectangle is what we used last week for all of the draw calls.

207
00:10:59,320 --> 00:11:02,640
在本例中 我们希望绘制一个图像对象 
In this case, we want to draw an image object,

208
00:11:02,640 --> 00:11:04,660
我们在内存中拥有的纹理对象 
a texture object that we have in memory.

209
00:11:04,660 --> 00:11:06,810
所以我们将把它命名为love.graph ics.Drag 
So we're going to call love.graphics.draw,

210
00:11:06,810 --> 00:11:09,240
它需要一个可抽屉 这意味着
and it takes a drawable, which means anything

211
00:11:09,240 --> 00:11:11,760
爱的定义是可以画出来的东西 
that Love has defined as something that can be drawn.

212
00:11:11,760 --> 00:11:13,860
在这种情况下 图像是可绘制的 
In this case, images are drawables.

213
00:11:13,860 --> 00:11:18,396
可以绘制它们 也可以在您指定的任何给定位置绘制它们 
They can be drawn, and they can be drawn at any given position that you specify.

214
00:11:18,396 --> 00:11:20,520
如果你想把它画在左上角 
So if you wanted to draw it at the top left corner,

215
00:11:20,520 --> 00:11:24,400
我们只会在0 0处说love.raphics.draBackground 
we would just say love.graphics.drawBackground at 0,0,

216
00:11:24,400 --> 00:11:25,670
而且它也有这种效果 
and it has that effect.

217
00:11:25,670 --> 00:11:30,437
我们要用我们的土地做同样的事情 
And we're going to the exact same thing with our ground.

218
00:11:30,437 --> 00:11:32,520
唯一的区别是 很明显 我们不会
The only difference being that obviously, we don't

219
00:11:32,520 --> 00:11:34,100
想在角落的顶端画画 
want to draw at the top of corner.

220
00:11:34,100 --> 00:11:35,980
我们想在屏幕的底部画画 
We want to draw at the bottom of the screen.

221
00:11:35,980 --> 00:11:41,447
所以我们称之为虚拟身高减16 这是
So we just call virtual height minus 16, which

222
00:11:41,447 --> 00:11:43,030
恰好是我们图像的高度 
happens to be the height of our image.

223
00:11:43,030 --> 00:11:43,990
所以如果你运行这个--
So if you run this--

224
00:11:43,990 --> 00:11:48,690
我将继续 并确保我在正确的目录中 
I'm going to go ahead, and make sure I'm in the right directory.

225
00:11:48,690 --> 00:11:52,500
我不在正确的目录中 所以我将进入我编写的目录 
I'm not in the right directory, so I'm going to go into a directory I wrote,

226
00:11:52,500 --> 00:11:55,020
五十只鸟抓伤 
fifty bird scratch.

227
00:11:55,020 --> 00:11:56,830
进入小鸟0号 
Go into bird0.

228
00:11:56,830 --> 00:12:00,630
如果我运行这个 理论上我应该只有两个图像
And if I run this, I should theoretically have just two images

229
00:12:00,630 --> 00:12:03,150
层叠在一起 但我不会 
layered on top of each other, which I do not.

230
00:12:06,570 --> 00:12:11,070
所以我们只需要确保它被保存下来 
So we just make sure that it gets saved.

231
00:12:11,070 --> 00:12:15,150
记住要始终保存您的工作 这样就可以了 
Remember to always save your work, and there you go.

232
00:12:15,150 --> 00:12:18,900
所以我们现在所做的 看起来比上周好多了
So all we're doing now, it looks infinitely better than last week

233
00:12:18,900 --> 00:12:21,242
已经有了 但它非常简单 只有很少的代码行 
already, but it's very simple, very few lines of code.

234
00:12:21,242 --> 00:12:22,950
我们为此付出的所有努力
All the effort that we've put into it has

235
00:12:22,950 --> 00:12:25,470
一直是我们精灵编辑的首选 而你
been in our sprite editor of choice, and you

236
00:12:25,470 --> 00:12:28,140
几乎可以使用任何你想做这类事情的应用程序 
can use most any application you want to do this sort of stuff.

237
00:12:28,140 --> 00:12:30,480
我用一个叫Aseprite的程序 我很喜欢 
I use a program called Aseprite, I like a lot,

238
00:12:30,480 --> 00:12:33,090
但你可以用免费的Gimp做这件事 你可以用Photoshop做这件事 
but you could do this in Gimp, which is free, you could do it in Photoshop,

239
00:12:33,090 --> 00:12:35,256
如果你愿意 你可以用微软的画笔来完成 
you could do it in Microsoft Paint if you wanted to.

240
00:12:37,660 --> 00:12:40,790
如果你这么做的话祝你好运 
Godspeed if you do.

241
00:12:40,790 --> 00:12:43,900
但是 是的 这就像把图像画到屏幕上一样简单 
But yeah, so that's as simple as it is just to draw images to the screen.

242
00:12:43,900 --> 00:12:48,000
所以我们已经在很短的时间内取得了相当大的进展
So we've already made quite a lot of progress in a very short period of time

243
00:12:48,000 --> 00:12:50,280
在我们游戏的视觉方面 
in terms of the visual aspect of our game.

244
00:12:50,280 --> 00:12:53,889
但是 除了最初的那种蜜月之外 看起来并不有趣
But it's not interesting to look at beyond the initial sort of honeymoon

245
00:12:53,889 --> 00:12:55,680
到目前为止 我们在屏幕上有了颜色 
period of now we have colors on the screen.

246
00:12:55,680 --> 00:13:01,320
我们想要真正开始滚动 因为这个游戏 Recall 是
We want to actually get scrolling because the game, recall, is

247
00:13:01,320 --> 00:13:02,130
滚动游戏 
a scrolling game.

248
00:13:02,130 --> 00:13:05,490
实际上 有谁愿意自愿
And actually, would anybody be willing to volunteer

249
00:13:05,490 --> 00:13:09,360
上台演奏《飞翔的小鸟》 这样我们就可以在舞台上看到现场表演了？
to come up, and play Flappy Bird just so we can see it live on the stage?

250
00:13:13,830 --> 00:13:15,390
大卫 你想上来玩吗？
David, you want to come up and play?

251
00:13:15,390 --> 00:13:19,110
有志愿者吗？
Does someone volunteer?

252
00:13:19,110 --> 00:13:20,880
史蒂芬 你想上来玩吗？
Stephen, you want to come up and play?

253
00:13:20,880 --> 00:13:23,360
史蒂芬：当然可以 
STEPHEN: Sure.

254
00:13:23,360 --> 00:13:25,068
科尔顿·奥格登：谢谢你的志愿服务 
COLTON OGDEN: Thank you for volunteering.

255
00:13:30,690 --> 00:13:34,410
我保证你比我更擅长这个游戏
I guarantee you're better at this game than I am.

256
00:13:34,410 --> 00:13:41,670
我将继续并cd进入目录中的Bird12 即
I'm going to go ahead and cd into bird12 in the directory, which is

257
00:13:41,670 --> 00:13:43,735
游戏的最终版本完成 
the final version of the game complete.

258
00:13:43,735 --> 00:13:45,360
所以我要继续按Enter键 
So I'm going to go ahead and hit Enter.

259
00:13:45,360 --> 00:13:47,220
[电子游戏音乐播放]
[VIDEO GAME MUSIC PLAYING]

260
00:13:47,220 --> 00:13:52,200
因此 我们已经可以看到视差滚动
So already, we can see the parallax scrolling

261
00:13:52,200 --> 00:13:54,504
我之前提到的 就是楼层
that I referred to before, which is the floor

262
00:13:54,504 --> 00:13:56,670
背景以不同的速度滚动 
and the background are scrolling at different rates,

263
00:13:56,670 --> 00:13:59,412
我们很快就会在下一个例子中看到这一点 
and we'll see this very shortly in the next example.

264
00:13:59,412 --> 00:14:00,120
我们有一个提示符 
We have a prompt.

265
00:14:00,120 --> 00:14:00,661
我们收到短信了 
We have text.

266
00:14:00,661 --> 00:14:02,660
我们以前已经在字体中使用过这一点 
We've already used this before with the font.

267
00:14:02,660 --> 00:14:05,740
所以继续 如果你按Enter 你就会倒计时 
So go ahead, if you press Enter, you're going to get a count down.

268
00:14:05,740 --> 00:14:06,720
所以太空就是跳跃 
So space is to jump.

269
00:14:06,720 --> 00:14:08,507
[嘟嘟声]
[BEEPING]

270
00:14:08,507 --> 00:14:10,840
所以我们让我们的鸟在屏幕中央跳跃 
So we have our bird jumping in the middle of the screen.

271
00:14:10,840 --> 00:14:12,255
我们得了第一名的分数 
We have a score at the top.

272
00:14:12,255 --> 00:14:15,101
这样做的目的是避免撞到管道 
The goal is to avoid hitting the pipes.

273
00:14:15,101 --> 00:14:16,412
[撞车]
[CRASH]

274
00:14:16,412 --> 00:14:17,470
好的 得一分 
OK, a score of one.

275
00:14:17,470 --> 00:14:18,386
你想再试一次吗？
You want to try again?

276
00:14:18,386 --> 00:14:20,012
您先请 
Go ahead.

277
00:14:20,012 --> 00:14:21,988
[嘟嘟声]
[BEEPING]

278
00:14:23,470 --> 00:14:25,990
所以它会记录他的位置 每次
So it keeps track of his position, and every time

279
00:14:25,990 --> 00:14:29,380
他穿过了一对管子的右边 如你所见 
he gets past the right edge of a pair of pipes, as you can see,

280
00:14:29,380 --> 00:14:32,710
这就是他得到一分的时候 
that's when he gets a point.

281
00:14:32,710 --> 00:14:37,149
那么如果你回想起上周 我们认为是什么--
So if you recall from last week, what do we think is--

282
00:14:37,149 --> 00:14:38,440
是什么在检测碰撞？
what's detecting the collision?

283
00:14:38,440 --> 00:14:40,430
如果我们记得上个星期 这个词叫什么？
If we remember last week, what's the term?

284
00:14:40,430 --> 00:14:42,580
有人记得吗？
Anybody remember?

285
00:14:42,580 --> 00:14:46,654
轴对齐边界AABB碰撞检测 轴对齐边界框 
Axis aligned bound aabb collision detection, axis-aligned bounding box.

286
00:14:46,654 --> 00:14:49,570
这和我们对Pong做的事情是一样的 只是现在我们正在做--
It's the same thing that we did with Pong, except now we're doing it--

287
00:14:49,570 --> 00:14:52,240
我们有图形 但它的概念是一样的 
we have graphics, but it's the same exact concept.

288
00:14:52,240 --> 00:14:54,000
我们只是使用矩形 
We're just using rectangles.

289
00:14:54,000 --> 00:14:58,690
当一个矩形与另一个矩形重叠时 我们就会触发死亡 
And when one rectangle overlaps with another rectangle, we trigger death.

290
00:15:02,155 --> 00:15:04,585
所以我想是最后一次迭代 然后我们将 
So one last iteration I think, and then we'll.

291
00:15:04,585 --> 00:15:06,590
[撞车]
[CRASH]

292
00:15:06,590 --> 00:15:09,110
我们会让你再试一次 
We'll let you try one more time.

293
00:15:09,110 --> 00:15:09,980
您先请 
Go ahead.

294
00:15:09,980 --> 00:15:11,410
我会试一试 
I'll give it a shot.

295
00:15:11,410 --> 00:15:12,720
我要故意输掉比赛 
I'm going to lose on purpose.

296
00:15:12,720 --> 00:15:15,230
好了 我们开始吧 
OK, here we go.

297
00:15:15,230 --> 00:15:18,440
说句公道话 我在开发这个的时候有过很多练习 
To be unfair, I got plenty of practice when I was developing this,

298
00:15:18,440 --> 00:15:20,830
但我们将拭目以待 看看这是否真的适用于这里 
but we'll see if that actually holds true here.

299
00:15:23,455 --> 00:15:25,730
所以还要注意 这些管子--
So notice also, the pipes--

300
00:15:25,730 --> 00:15:27,870
我--哦 我失去了程序世代 
the procedure generation that I-- oh, I lost.

301
00:15:27,870 --> 00:15:29,050
三分 
Three points.

302
00:15:29,050 --> 00:15:31,820
当我再做一次迭代时 让我再解释一下 
Let me explain a little bit more, while I do one more iteration.

303
00:15:31,820 --> 00:15:34,362
但是管子本身 每次我们开始的时候 
But the pipes themselves, every time we start,

304
00:15:34,362 --> 00:15:36,070
它们在不同的地点产卵 
they're spawning at a different location.

305
00:15:36,070 --> 00:15:39,700
这几乎是在最简单的情况下进行的
This is proceeded generation in pretty much the most simplest

306
00:15:39,700 --> 00:15:45,160
可能的方法 并注意到管道正在逐渐移动 
way possible, and notice that the pipes are shifting gradually.

307
00:15:45,160 --> 00:15:48,370
所以这在某种程度上是我们水平的构成 
So this is sort of the make up of our level,

308
00:15:48,370 --> 00:15:51,910
它只是对一些简单的算法一点一点地生成DO
and it's just generating bit by bit do to some simple algorithm

309
00:15:51,910 --> 00:15:54,670
我们只会说 嘿 在这里再生产一根烟斗 把它移开
that we have that just says hey, spawn another pipe here, shift it

310
00:15:54,670 --> 00:15:55,840
在一定程度上 
by some amount.

311
00:15:55,840 --> 00:16:00,340
这种非常简单的方法允许我们一遍又一遍地拥有无限的水平
And this very simple approach allows us to have an infinite level over and over

312
00:16:00,340 --> 00:16:01,760
再说一次 这是非常有效的 
again, and it's very efficient.

313
00:16:01,760 --> 00:16:05,665
我们的屏幕上只有那么多的管子 我们很快就会看到--
We only ever have as many pipes on the screen, and as we'll see soon--

314
00:16:05,665 --> 00:16:09,362
内存中的管道数量只能与屏幕上看到的一样多
we'll only have as many pipes in memory as we can see on the screen

315
00:16:09,362 --> 00:16:12,070
有一段时间 尽管这一水平理论上可以
at one time, despite the fact that this level could theoretically

316
00:16:12,070 --> 00:16:16,460
无限地进行 所以这是非常划算的 
go on infinitely, and so it's very cost efficient.

317
00:16:16,460 --> 00:16:18,250
因此 Bird1就是一个例子 
So bird1 is the example.

318
00:16:18,250 --> 00:16:19,420
这是视差更新 
It's the parallax update.

319
00:16:19,420 --> 00:16:23,410
因此 视差滚动是2D中的一个重要概念
So parallax scrolling is an important concept in 2D

320
00:16:23,410 --> 00:16:26,160
还有3D 但2D游戏开发 
and also 3D, but 2D game development.

321
00:16:26,160 --> 00:16:31,750
它指的是在两个参照系的情况下运动的错觉
It refers to the illusion of movement given two frames of reference

322
00:16:31,750 --> 00:16:33,680
以不同的速度移动 
that are moving at different rates.

323
00:16:33,680 --> 00:16:37,120
所以如果你在高速公路上开车 你看到你旁边有一道栅栏 
So if you're driving on the highway, and you see a fence next to you,

324
00:16:37,120 --> 00:16:39,160
你看到远处的群山 你就是
and you see mountains in the distance, you're

325
00:16:39,160 --> 00:16:41,857
通过观察栅栏移动的速度来观察视差滚动
observing parallax scroll by seeing how fast the fence moves

326
00:16:41,857 --> 00:16:42,940
相对于山脉而言 
relative to the mountains.

327
00:16:42,940 --> 00:16:46,330
山脉的移动速度会比栅栏慢得多
The mountains are going to move a lot more slowly than the fences right

328
00:16:46,330 --> 00:16:47,170
就在你旁边 
next to you.

329
00:16:47,170 --> 00:16:50,140
我们在我们的游戏中完成了同样的幻觉
And we accomplish the same exact illusion in our game

330
00:16:50,140 --> 00:16:54,310
通过使用这种图形错觉 
by using this sort of graphical illusion.

331
00:16:54,310 --> 00:16:56,860
所以我将在我的目录中继续
And so I'm going to go ahead in my directory

332
00:16:56,860 --> 00:17:02,380
在这里 在鸟1号 这是一种无人居住的--
here, in bird1, which is an unpopulated--

333
00:17:02,380 --> 00:17:07,329
它填充了Bird0的内容 即Bird0的完整内容 
it's populated with the contents of bird0, the complete contents of bird0.

334
00:17:07,329 --> 00:17:10,490
您将看到的版本将包含所有代码 
The version that you'll see will have all of the code,

335
00:17:10,490 --> 00:17:16,700
但我将继续 如果我们在该目录中运行Bird0 
but I'm going to go ahead, and if we run bird0 in that directory.

336
00:17:16,700 --> 00:17:19,900
所以我想现在我还在完整的发行版中 
So I think right now I'm still in the full distro.

337
00:17:19,900 --> 00:17:23,355
所以让我继续 再一次进入五十鸟抓 
So let me go ahead, go into fifty bird scratch again.

338
00:17:26,609 --> 00:17:27,400
哎呀 我在哪里？
Whoops, where am I?

339
00:17:31,970 --> 00:17:34,562
然后我将进入Bird1 并运行它 
And then I'm going to go into bird1, and run it,

340
00:17:34,562 --> 00:17:36,770
我得到了和上次一模一样的图像 
and I get the exact same image that we had last time.

341
00:17:36,770 --> 00:17:40,030
所以一切都是从以前开始的 只有两张图片 没有任何移动 
So everything is there from before, just two images, nothing moving,

342
00:17:40,030 --> 00:17:41,980
我们观察不到视差 
no parallax that we can observe.

343
00:17:41,980 --> 00:17:44,140
我将继续进行 并开始实施
I'm going to go ahead, and start implementing

344
00:17:44,140 --> 00:17:47,540
这种视差的基本原理 
the basics of this parallax.

345
00:17:47,540 --> 00:17:51,040
所以如果我继续我的主修课程 
So if I go ahead in my main.

346
00:17:51,040 --> 00:17:55,810
因此 我将在这里介绍一下我们的背景 
So I'm going to go down here to where we have our background.

347
00:17:55,810 --> 00:17:58,580
所以我们需要一些新的东西 
So we need a couple of new things.

348
00:17:58,580 --> 00:18:00,400
因此 与我们的背景图像一起 我们需要
So along with our background image, we need

349
00:18:00,400 --> 00:18:02,890
来跟踪它的滚动量 因为我们
to keep track of how much it's scrolled because we're

350
00:18:02,890 --> 00:18:04,780
需要开始将此图像绘制到屏幕上 
going to need to start drawing this image to the screen,

351
00:18:04,780 --> 00:18:06,580
但如果我们要滚动它 那就意味着
but if we're going to scroll it, that means

352
00:18:06,580 --> 00:18:08,891
我们需要移动它的x偏移量 
that we need to shift its x offset.

353
00:18:08,891 --> 00:18:11,140
如果我们想让它滚动 而不是在0 0处绘制 
Instead of drawing it at 0,0, if we want it to scroll,

354
00:18:11,140 --> 00:18:15,190
相反 我们不得不把它画在某个负值上 
we have to draw it at some negative value instead.

355
00:18:15,190 --> 00:18:18,680
随着时间的推移 这将产生它从右向左移动的效果 
Over time, this will have the effect of it moving right to left.

356
00:18:18,680 --> 00:18:20,680
所以我要继续下去 并跟踪--
So I'm going to go ahead, and keep track--

357
00:18:20,680 --> 00:18:22,570
我将使用一个变量来跟踪卷轴
I'm going to use a variable to keep track of the scroll

358
00:18:22,570 --> 00:18:24,550
现在 对于这两张图片 我们只是
now, for both of these images, and we're just

359
00:18:24,550 --> 00:18:27,549
我要将它们命名为BackdowScroll和Ground Scroll 并将它们设置为0 
going to call them backgroundScroll and groundScroll, and set them to 0.

360
00:18:27,549 --> 00:18:30,370
所以这会产生NOX偏移量的影响 
So this is going to have the effect of no x offset.

361
00:18:30,370 --> 00:18:34,780
所以我现在可以使用这个变量 在下面的这个绘图调用中 
So I could use this variable right now in this draw call down here,

362
00:18:34,780 --> 00:18:36,110
我真的要这么做 
which I'm actually going to do.

363
00:18:36,110 --> 00:18:38,180
我要继续下去 去--
I'm going to go ahead, and go to--

364
00:18:38,180 --> 00:18:40,460
我要去看看那是不是对的 
I'm just going to find out if that is correct.

365
00:18:40,460 --> 00:18:46,681
我将继续将其设置为负背景滚动 
I'm going to go ahead and set that to negative backgroundScroll.

366
00:18:49,330 --> 00:18:53,170
在这里 我将把它设置为负值 
And here, I'm going to set this to negative groundScroll.

367
00:18:53,170 --> 00:18:55,160
因此 这还不会改变任何事情 
So this is not going to change anything yet.

368
00:18:55,160 --> 00:18:57,701
这将是完全相同的事情 因为它们都是0 
It's going to be the exact same thing because they're both 0.

369
00:18:57,701 --> 00:19:02,870
它们以前是0 但随着时间的推移 我们会改变它们 
They were 0 before, but we're going to change them over time.

370
00:19:02,870 --> 00:19:14,110
为了做到这一点 我将继续下去 进入到这里 
And in order to do this, I'm going to go ahead, and go into up here.

371
00:19:14,110 --> 00:19:17,600
实际上 在我们做这件事之前 我们需要设定一个速度 
One thing before we do that actually, we need to set a speed for this.

372
00:19:17,600 --> 00:19:19,660
这将随着时间的推移而发生 但由于他们
This is going to happen over time, but since they

373
00:19:19,660 --> 00:19:21,580
需要以不同的速度发生 背景
need to occur at different rates, the background

374
00:19:21,580 --> 00:19:23,580
需要以比前景更慢的速度运行
needs to go at a slower rate than the foreground

375
00:19:23,580 --> 00:19:28,300
为了得到视差效应 我们需要分离速度变量 
so that we do get this parallax effect, we need to separate speed variables.

376
00:19:28,300 --> 00:19:32,500
一般来说 不会改变的东西的标准是
Generally, the norm for something that is not going to change

377
00:19:32,500 --> 00:19:34,690
就是用大写字母加下划线 
is to write it in caps with underscores.

378
00:19:34,690 --> 00:19:35,900
这是常量记法 
This is constant notation.

379
00:19:35,900 --> 00:19:38,350
这在大多数编程语言中都很常见 
This is frequently seen in most programming languages.

380
00:19:38,350 --> 00:19:39,102
我们将在这里使用它 
We'll use it here.

381
00:19:39,102 --> 00:19:41,560
我将设置一个名为BACKGROUND_SCROLL_SPEED的变量 
I'm going to set a variable called BACKGROUND_SCROLL_SPEED,

382
00:19:41,560 --> 00:19:44,130
我要把它设为30 
and I'm just going to set that to 30.

383
00:19:44,130 --> 00:19:48,580
我也要做同样的事情 GROUND_SCROLL_SPEED 
I'm going to do the same thing, GROUND_SCROLL_SPEED.

384
00:19:48,580 --> 00:19:54,520
这是否需要高于或低于BACKGROUND_SCROLL_SPEED？
Does this need to be higher or lower than the BACKGROUND_SCROLL_SPEED?

385
00:19:54,520 --> 00:19:56,280
地面将会移动--
The ground is going to move--

386
00:19:56,280 --> 00:19:59,341
因此 背景的移动速度需要比地面慢 
so the background needs to move slower than the ground does.

387
00:19:59,341 --> 00:20:00,590
所以这个数字会更高 
So this is going to be higher.

388
00:20:00,590 --> 00:20:01,930
所以我们只需将其设置为60 
So we're just going to set it to 60.

389
00:20:01,930 --> 00:20:03,850
您可以将其设置为任何您想要获得的效果 
You can set it to whatever you want to get the effect that you want,

390
00:20:03,850 --> 00:20:05,680
但这一点已经相当明显了 
but this will already be quite noticeable.

391
00:20:05,680 --> 00:20:09,670
地面的移动速度将是背景的两倍 
The ground is going to move twice as fast as the background.

392
00:20:09,670 --> 00:20:14,590
所以我们要做的也是如果我们
And so what we're going to do also is if we

393
00:20:14,590 --> 00:20:19,180
如果我们让我们的图像无限滚动 会发生什么呢？
just-- so what's going to happen if we just let our image scroll infinitely?

394
00:20:19,180 --> 00:20:21,147
在某个时间点上会发生什么？
What's going to happen at a certain point?

395
00:20:21,147 --> 00:20:22,460
观众：形象消失了？
AUDIENCE: Run out of image?

396
00:20:22,460 --> 00:20:24,168
科尔顿·奥格登：它将以一种形象运行 
COLTON OGDEN: It's going run at an image.

397
00:20:24,168 --> 00:20:26,621
那么 我们如何解决这个问题呢？
So how do we fix this problem?

398
00:20:26,621 --> 00:20:27,370
观众：循环播放 
AUDIENCE: Loop it.

399
00:20:27,370 --> 00:20:28,894
科尔顿·奥格登：准确地说 是循环 
COLTON OGDEN: Loop it, exactly.

400
00:20:28,894 --> 00:20:31,060
所以我们要继续下去 设置一个循环点 
So we're going to go ahead, and set a looping point.

401
00:20:31,060 --> 00:20:35,230
因此 另一个恒定的背景循环点 
So another constant background looping point,

402
00:20:35,230 --> 00:20:39,340
我们要将其设置为413 这有点像
and we're going to set this to 413, which you kind of have

403
00:20:39,340 --> 00:20:43,330
为了查看你的图像 并确定--你必须设置你的图像 
to look at your image, and determine-- you sort of have to set your images up,

404
00:20:43,330 --> 00:20:47,050
如果你想达到这个效果 就让它们成为一个循环的图像 
if you want to achieve this effect, by having them be a looping image.

405
00:20:47,050 --> 00:20:51,040
所以有两个拷贝完全相同的东西 也就是你的屏幕宽度 
So have either two copies of the exact same thing that's your screen width,

406
00:20:51,040 --> 00:20:53,226
或者只是复制相同的块 一遍又一遍 
or just copy the same chunk over, and over again.

407
00:20:53,226 --> 00:20:54,350
有很多方法可以做到这一点 
There's many ways to do it.

408
00:20:54,350 --> 00:20:57,520
在本例中 我们的背景图像的循环点
In this case, the looping point of the image of our background

409
00:20:57,520 --> 00:20:59,100
在x轴上是413
is 413 on the x-axis.

410
00:20:59,100 --> 00:21:02,307
所以我们把它设为413 
So we're going to set that to 413.

411
00:21:02,307 --> 00:21:05,140
然后我们继续--下一步我们实际上有
And then we're going to go ahead-- the next step is we actually have

412
00:21:05,140 --> 00:21:07,130
开始改变价值观 
to start changing the value values.

413
00:21:07,130 --> 00:21:09,820
所以在我们的更新函数中 
So in our update function, which is where

414
00:21:09,820 --> 00:21:12,820
这是会发生的 我会继续
this is going to happen, I'm going to go ahead,

415
00:21:12,820 --> 00:21:16,270
爱的定义 更新 回忆起来 Love 2D将为你打电话 
and define love.update, which recall, Love2D will call for you,

416
00:21:16,270 --> 00:21:19,240
但你必须自己定义
but you must define it yourself.

417
00:21:19,240 --> 00:21:22,325
我要继续 并设置backgroundScroll 
I'm going to go ahead, and set backgroundScroll too.

418
00:21:32,366 --> 00:21:34,240
所以这是要做什么 背景滚动
So what this is going to do, backgroundScroll

419
00:21:34,240 --> 00:21:40,140
获取backgroundScroll到自身加上我们设置的速度before times delta time 
gets backgroundScroll to itself plus the speed we set before times delta time.

420
00:21:40,140 --> 00:21:42,035
所以它保持帧速率独立 
So it stays frame rate independent.

421
00:21:45,020 --> 00:21:48,400
这会给我们的图像增加速度 
That will have the effect of adding the speed to our image,

422
00:21:48,400 --> 00:21:49,420
但我们得重新设置
but we need to reset it.

423
00:21:49,420 --> 00:21:51,070
我们需要真正执行重置 
We need to actually perform the reset.

424
00:21:51,070 --> 00:21:54,730
为了做到这一点 我们只需要使用模 
And to do that, we'll just be using Modulus, which recall

425
00:21:54,730 --> 00:21:59,860
从像C这样的语言 简单地划分--
from languages like C, simply divides--

426
00:21:59,860 --> 00:22:04,700
基本上 将该值设置为该除法的余数 
basically, sets that value to the remainder of that division.

427
00:22:04,700 --> 00:22:10,990
在这种情况下10模5等于0
So in this case-- so 10 modulo 5 would be 0,

428
00:22:10,990 --> 00:22:18,040
但10模9实际上等于1 因为我们有0
but 10 modulo 9 would be 1, effectively, because we have 0

429
00:22:18,040 --> 00:22:20,050
剩下的部分 
left over once we divide 10 by 5.

430
00:22:20,050 --> 00:22:22,690
我们用10除以9就剩下1 
We have 1 left over once we divide 10 by 9.

431
00:22:26,240 --> 00:22:30,950
所以我很抱歉 如果这个概念不是新的 
So I apologize if that concept is not new.

432
00:22:30,950 --> 00:22:40,930
但我们也要为我们的土地做同样的事情 
But we're going to do the same exact thing for our ground,

433
00:22:40,930 --> 00:22:47,500
只不过我们要对虚拟宽度取模 
only we're going to modulo by our virtual width in this case.

434
00:22:47,500 --> 00:22:48,880
我没有设置循环点 
I did not set a looping point.

435
00:22:48,880 --> 00:22:52,250
在后面的例子中是这样的 但是我们的地面图像非常--
I do in later examples, but our ground image is very--

436
00:22:52,250 --> 00:22:54,280
它的一致性足以让你
it's consistent enough such that you don't even

437
00:22:54,280 --> 00:22:57,984
注意它在循环时没有使用虚拟with 
notice it when it loops without just using the virtual with.

438
00:22:57,984 --> 00:23:00,400
所以在这种情况下 我们只使用虚拟宽度 
So we're just going to use the virtual width in that case.

439
00:23:00,400 --> 00:23:05,260
它很有图案 而且很小 
It's very patterned, and very small.

440
00:23:05,260 --> 00:23:09,550
除此之外 我们已经有了背景卷轴
And aside from that, we already have the background scrolls here

441
00:23:09,550 --> 00:23:11,840
在我们的绘图功能中 
in our draw functions.

442
00:23:11,840 --> 00:23:13,990
所以当我们运行这段代码时 理论上我们应该
So when we run this code, we should theoretically

443
00:23:13,990 --> 00:23:17,010
有滚动的背景 
have scrolling background.

444
00:23:17,010 --> 00:23:20,440
观众：那么它的宽度是不是要两倍呢
AUDIENCE: So does it even just have to be twice the width

445
00:23:20,440 --> 00:23:21,910
这样就不会卖完了
or something so they don't run out?

446
00:23:21,910 --> 00:23:24,118
科尔顿·奥格登：是的 至少是宽度的两倍 
COLTON OGDEN: They do, at least twice the width, yes.

447
00:23:24,118 --> 00:23:27,280
有几种方法可以有效地平铺你的形象 
There's ways you could effectively tile your image,

448
00:23:27,280 --> 00:23:30,180
这样做可以节省纹理大小的内存 
and do it that way to save memory on texture size.

449
00:23:30,180 --> 00:23:32,942
如果你有屏幕大小的四分之一的东西
If you have maybe something that's a quarter of the screen size

450
00:23:32,942 --> 00:23:34,900
你想要循环 一遍又一遍 你
that you want to loop over, and over again, you

451
00:23:34,900 --> 00:23:36,775
我不想把它当做一个大画面 
don't want to have that as one big image,

452
00:23:36,775 --> 00:23:39,400
您只需绘制该图像的四个副本来填充您的屏幕 
you'll just draw four copies of that image to fill your screen,

453
00:23:39,400 --> 00:23:40,694
然后把它们全部移走 
and then to shift all of them.

454
00:23:40,694 --> 00:23:42,610
可能有五个 实际上 所以你有一点
Maybe five, actually, so you have a little bit

455
00:23:42,610 --> 00:23:48,272
超出屏幕边缘 然后将它们全部放回0 
beyond the edge of the screen, and then just put all of them back to 0.

456
00:23:48,272 --> 00:23:51,218
观众：所以最下面的那个 地面是--
AUDIENCE: So the bottom one, the ground is--

457
00:23:51,218 --> 00:23:56,610
如果您只是重新开始显示带有较大图像的图像 您不会知道
you wouldn't know if you just restarted showing the image with the larger

458
00:23:56,610 --> 00:23:57,110
背景资料 
background.

459
00:23:57,110 --> 00:24:00,547
你就不用担心山被切成两半了
You wouldn't have to worry about the mountain getting cut in half

460
00:24:00,547 --> 00:24:02,040
当你换掉右翼时--
when you replaced the right--

461
00:24:02,040 --> 00:24:03,370
科尔顿·奥格登：没错 
COLTON OGDEN: Exactly.

462
00:24:03,370 --> 00:24:05,144
所以我们实际上可以--
So we could actually--

463
00:24:05,144 --> 00:24:07,310
我现在就可以向你展示那会是什么样子 
I could show you right now what that will look like.

464
00:24:07,310 --> 00:24:10,330
所以如果我们把这里的循环点去掉 
So if we just take out the looping point here,

465
00:24:10,330 --> 00:24:15,390
或者我们将其设置为完全不准确的值 比如270 
or we set it to some value that's completely inaccurate like 270,

466
00:24:15,390 --> 00:24:24,670
然后我们运行它 一段时间后它应该会停下来 
and then we run it, after a while it should just cut.

467
00:24:24,670 --> 00:24:26,480
是的 就在那里 
Yeah, right there.

468
00:24:26,480 --> 00:24:28,686
观众：那么你真的要画两次吗？
AUDIENCE: So are you drawing it twice, really?

469
00:24:28,686 --> 00:24:31,060
就像用完的时候一个接一个什么的？
Like one after another one when it runs out or something?

470
00:24:31,060 --> 00:24:34,420
科尔顿·奥格登：不 图像太宽了 总是会填满屏幕 
COLTON OGDEN: No, the image is so wide that it always will fill the screen,

471
00:24:34,420 --> 00:24:38,940
即使在它被设置回--即使在它超过了循环点之后 
even after it's been set back to-- even after it's gone past the looping point.

472
00:24:38,940 --> 00:24:41,080
我忘了纹理有多大了 
I forget how large the texture is.

473
00:24:41,080 --> 00:24:44,102
它有1157个像素宽 
It is 1157 pixels wide.

474
00:24:44,102 --> 00:24:45,810
所以它是屏幕宽度的两倍多 
So it's more than twice the screen width.

475
00:24:45,810 --> 00:24:48,257
实际上 我认为它正好是屏幕宽度的两倍 
Actually, I think it is exactly twice the screen width.

476
00:24:48,257 --> 00:24:50,090
不 它不是屏幕宽度的两倍 
No, it's not exactly twice the screen width,

477
00:24:50,090 --> 00:24:51,820
但它是屏幕宽度的两倍多
but it's more than twice the screen width

478
00:24:51,820 --> 00:24:54,820
所以当413个像素已经过去的时候 
so that when the amount-- the 413 pixels has elapsed,

479
00:24:54,820 --> 00:24:59,410
它仍然远远超过了屏幕的右边缘和循环部分 
it's still plenty past the right edge of the screen, and the looping part,

480
00:24:59,410 --> 00:25:02,420
它将与纹理上的外观完全相同 
it'll be the exact same appearance on the texture,

481
00:25:02,420 --> 00:25:06,190
但它完全被移回了右翼 
but it's completely been shifted back to the right.

482
00:25:06,190 --> 00:25:10,150
我们图像的0 0现在位于屏幕空间中的0 0 
The 0,0 of our image is now at 0,0 in our screen space.

483
00:25:10,150 --> 00:25:13,690
观众：所以循环只是重新加载[INAUDIBLE]？？
AUDIENCE: So the looping is just reloading [INAUDIBLE]??

484
00:25:13,690 --> 00:25:16,660
科尔顿·奥格登：你的形象在这里 在移动 然后就在瞬间
COLTON OGDEN: Your image is here, moving, and then just instantly

485
00:25:16,660 --> 00:25:20,340
回到开始 然后回到--
back to the beginning, and then moving back to--

486
00:25:20,340 --> 00:25:23,470
将其设置回0 或者从技术上讲 多少
the setting it back to 0 or technically, how many

487
00:25:23,470 --> 00:25:28,190
像素它已经超过了屏幕的边缘 因为使用了模数 
pixels it's gone past the edge of the screen because using modulo.

488
00:25:28,190 --> 00:25:29,606
观众：所以这只是一张图片 
AUDIENCE: So it's just one image.

489
00:25:29,606 --> 00:25:32,147
这就像你只需在正确的时间瞬间翻转它 
It's like you just instantaneously flip it at the right time.

490
00:25:32,147 --> 00:25:33,130
科尔顿·奥格登：是的 
COLTON OGDEN: Yeah.

491
00:25:33,130 --> 00:25:33,940
这是一种翻译 
It's a translation.

492
00:25:33,940 --> 00:25:34,900
这是一种即时翻译 
It's an instant translation.

493
00:25:34,900 --> 00:25:36,010
它发生在一帧上 
It takes place over one frame.

494
00:25:36,010 --> 00:25:36,968
所以你没有注意到它 
So you don't notice it.

495
00:25:36,968 --> 00:25:40,370
你的肉眼看不到它 因为它实际上发生在一帧中 
Your human eye can't see it because it literally happens in one frame.

496
00:25:40,370 --> 00:25:43,780
这两个点的图像数据是完全相同的
The image data is the exact same at those two points

497
00:25:43,780 --> 00:25:45,010
因为我们有质感 
because we have a texture.

498
00:25:45,010 --> 00:25:48,122
我们已经预先创建了一个具有完全相同数据的纹理
We've pre-created a texture that has the exact same data

499
00:25:48,122 --> 00:25:49,330
这样你就有了这样的效果 
so that you have that effect.

500
00:25:49,330 --> 00:25:53,560
你必须有一个纹理 让你能做到这一点 或者聪明
You have to have a texture that allows you to do this, or smartly

501
00:25:53,560 --> 00:25:55,390
画出四幅相同的图像 
draw four of the same images.

502
00:25:55,390 --> 00:25:57,100
跟踪他们所有四个人--
Keep track of all four of them--

503
00:25:57,100 --> 00:26:00,130
或者实际上 有八个--所以你可以把它们移到左边 
or actually, eight of them-- so you can move them to the left,

504
00:26:00,130 --> 00:26:03,020
然后把它们全部移回右边 
and then shift them all back to the right.

505
00:26:03,020 --> 00:26:05,445
观众：我想我们拍《超级马里奥兄弟》的时候 
AUDIENCE: I assume when we do Super Mario Bros.,

506
00:26:05,445 --> 00:26:11,032
我们将有多个图像一个接一个地堆叠在一起 
we're going to have multiple images that get stacked one after another.

507
00:26:11,032 --> 00:26:12,990
科尔顿·奥格登：当我们谈到超级马里奥兄弟时 
COLTON OGDEN: When we get to Super Mario Bros.,

508
00:26:12,990 --> 00:26:15,750
我们将讨论一个称为平铺映射的概念 它
we'll be talking about a concept called tile mapping, which

509
00:26:15,750 --> 00:26:19,830
就是我们拿一个雪碧纸 然后你基本上把它切碎
is where we take a sprite sheet, and then you basically chop it up

510
00:26:19,830 --> 00:26:25,740
有一张地图 基本上是数字的 所以一块砖是
into pieces, have a map that is basically numerical so that a brick is

511
00:26:25,740 --> 00:26:28,950
值为1 然后你可以看到这个巨大的二维数组
value one, and then you look through this giant two dimensional array

512
00:26:28,950 --> 00:26:31,740
然后遍历它 迭代它 
that you have, and then go over it, iterate over it,

513
00:26:31,740 --> 00:26:35,945
然后根据地图上的索引在一定的偏移量上绘制一块瓷砖 
and then draw a tile at an offset based on your index into that map.

514
00:26:35,945 --> 00:26:38,820
所以它稍微复杂一点 而且实际上内存要大得多
So it's a little bit more complicated, and actually a lot more memory

515
00:26:38,820 --> 00:26:43,316
高效 但实现略有不同 
efficient, but slightly different implementation.

516
00:26:48,740 --> 00:26:53,740
好的 现在我们有视差滚动了 
OK, so we have parallax scrolling now.

517
00:26:53,740 --> 00:26:55,420
我想花点时间--
I want to take a moment to--

518
00:26:55,420 --> 00:26:58,510
因为我们已经谈到了--
because we've touched on--

519
00:26:58,510 --> 00:27:01,930
这是一种非常入门的方式来证明游戏是错觉 
this is a very introductory way of demonstrating that games are illusions,

520
00:27:01,930 --> 00:27:03,160
通过使用视差滚动 
by using parallax scrolling.

521
00:27:03,160 --> 00:27:07,084
实际上 我们所做的只是设置了两种不同的滚动速度 
All we've done, really, is just set two things to scroll at different rates,

522
00:27:07,084 --> 00:27:09,500
这让我们觉得我们在场景中有深度 
and this has made us feel like we have depth in our scene,

523
00:27:09,500 --> 00:27:11,416
但我们所做的一切 我们有两个图像 我们是
but all we're doing, we have two images, we're

524
00:27:11,416 --> 00:27:13,780
以不同的速度滚动它们 
scrolling them at different rates.

525
00:27:13,780 --> 00:27:15,790
但这是游戏开发中的一个共同主题 
But this is a common theme in game development,

526
00:27:15,790 --> 00:27:20,530
正在试图设计一个可能非常精致的场景 
is trying to devise a scene that maybe is very elaborate,

527
00:27:20,530 --> 00:27:24,790
但在像iPhone这样的资源密集型设备上做到这一点 
but doing it on very resource intensive devices like your iPhone,

528
00:27:24,790 --> 00:27:27,520
或者像任天堂64这样的老式游戏机 
or like an old console like the Nintendo 64.

529
00:27:27,520 --> 00:27:34,672
这些错觉随处可见 一个YouTube频道
These illusions are all over the place, and a YouTube channel

530
00:27:34,672 --> 00:27:37,830
我最近发现我真正喜欢的是
that I recently found that I really like is

531
00:27:37,830 --> 00:27:41,320
这叫--频道的名字是她说的 但实际上他们的节目
it's called-- the name of the channel is She Says, but the actual show that they

532
00:27:41,320 --> 00:27:42,910
HAVE被称为边界突破 
have is called Boundary Break.

533
00:27:42,910 --> 00:27:46,670
他们所做的就是拿起一台摄像机
And what they do is they take a camera that

534
00:27:46,670 --> 00:27:49,060
超越了游戏开发商允许它做的事情 
goes beyond what the game developers allowed it to do,

535
00:27:49,060 --> 00:27:52,729
他们基本上侵入了游戏摄像头 这样你就可以在
which they basically hack the game camera so you can see in places where

536
00:27:52,729 --> 00:27:54,520
你以前不应该看到的 而你
you weren't supposed to see before, and you

537
00:27:54,520 --> 00:27:57,314
可以看到很多非常酷的诡计 
can see a lot of really cool trickery.

538
00:27:57,314 --> 00:27:59,230
我要给你们看几个视频片段 
I'm about to show you a couple of video clips,

539
00:27:59,230 --> 00:28:02,480
不过 如果你对视频感兴趣的话 这里有YouTube的网址 
but here's the YouTube URL if you're curious to see the exact video.

540
00:28:02,480 --> 00:28:04,940
这是一个大约33分钟的视频 
It's about a 33 minute video.

541
00:28:04,940 --> 00:28:08,440
这是在塞尔达 奥卡里纳的时间为N64 
It's on Zelda, Ocarina of Time for the N64.

542
00:28:08,440 --> 00:28:12,040
我提取了几个特别值得注意的片段
And I extracted a couple of particularly noteworthy clips

543
00:28:12,040 --> 00:28:15,127
我觉得很有趣 也很幽默 
that I thought were kind of interesting, and also humorous.

544
00:28:15,127 --> 00:28:16,960
我现在要继续播放这段视频 
I'm going to go ahead and show the clip now.

545
00:28:16,960 --> 00:28:21,160
所以如果我们可以把灯光调暗 我就开始了 
So if we could dim the lights, I'll go ahead and start.

546
00:28:21,160 --> 00:28:23,802
这是第一个例子 
This is the first example.

547
00:28:23,802 --> 00:28:26,260
演讲者1：好的 关于这家商店有很多可谈的
SPEAKER 1: OK, so there's a lot to talk about with the shop

548
00:28:26,260 --> 00:28:27,627
《时代的奥卡里纳》中的主人 
owners in the Ocarina of Time.

549
00:28:27,627 --> 00:28:30,210
所以我要把它浓缩成最有趣的 
So I'm going to just condense it down to the most interesting,

550
00:28:30,210 --> 00:28:32,001
我们要谈论的第一个问题是
and the first one we're going to talk about

551
00:28:32,001 --> 00:28:34,090
是海鲁尔的那个怪异的店主 
is the bizarre shop owner in Hyrule.

552
00:28:34,090 --> 00:28:38,980
现在 在马约拉的面具中 同样的角色实际上是有腿的 
Now, in Majora's Mask, the very same character is actually shown with legs,

553
00:28:38,980 --> 00:28:42,430
但在《时代的奥卡莉娜》中 他没有这些 
but in Ocarina of Time, he did not have those.

554
00:28:42,430 --> 00:28:46,950
事实上 他没有腿看起来非常滑稽 
In fact, he looks extremely hilarious without his legs.

555
00:28:50,530 --> 00:28:52,445
科尔顿·奥格登：所以这是一个--
COLTON OGDEN: So this is a--

556
00:28:52,445 --> 00:28:55,570
有没有人知道他们为什么要这么做？
does anybody have an instinct as to why they might have done this this way?

557
00:28:55,570 --> 00:28:57,670
观众：反正你不会看到的 
AUDIENCE: You're not going to see it anyway.

558
00:28:57,670 --> 00:29:01,685
科尔顿·奥格登：没错 除此之外 还节省了内存 
COLTON OGDEN: Exactly, and beyond that, also just saving on memory.

559
00:29:01,685 --> 00:29:04,810
无需加载角色模型--相关的顶点和纹理
Not having to load a character model-- the vertices and textures associated

560
00:29:04,810 --> 00:29:05,680
用它--
with it--

561
00:29:05,680 --> 00:29:08,830
像N64这样内存受限的设备 
on such a memory constrained device like the N64.

562
00:29:08,830 --> 00:29:10,510
我忘了它有多少内存 
I forget how much memory it had.

563
00:29:10,510 --> 00:29:13,790
比如4兆字节的内存 我想还不到 
Like four megabytes of memory, I think less than that.

564
00:29:13,790 --> 00:29:16,540
因此 他们显然正在削减他们可以削减多少角落 
And so they are obviously cutting however many corners they could.

565
00:29:16,540 --> 00:29:19,690
在这种情况下 通过字面上使用的错觉 
In this case, by literally using the illusion

566
00:29:19,690 --> 00:29:23,470
不是幻觉 而是你只能看到
of looking-- not the illusion, but just the fact that you only could see over

567
00:29:23,470 --> 00:29:26,890
柜台 给你一个错觉 有一个完整的生活 
the counter, and giving you the illusion that there's a fully living,

568
00:29:26,890 --> 00:29:30,000
会说话的店主但它只是半个模型
talking shop keeper there, but it's just half a model.

569
00:29:30,000 --> 00:29:35,260
这里的另一个例子更多的是展示时间陶笛
And other example here is more to show how Ocarina of Time

570
00:29:35,260 --> 00:29:39,550
利用N64有限的内存 
used the N64's limited memory to give you

571
00:29:39,550 --> 00:29:43,250
一种感觉 在一个非常大的水平 而你可能实际上并没有 
the sense of being in a very large level when you might not actually have been.

572
00:29:43,250 --> 00:29:46,400
所以如果我们能把灯光调暗一次 我们将继续展示这个 
So if we could dim the lights one time, we'll go ahead and show this.

573
00:29:46,400 --> 00:29:48,850
演讲者1：这显然是一个热门的建议 
SPEAKER 1: So this one was apparently a hot suggestion,

574
00:29:48,850 --> 00:29:50,570
[笑]
[CHUCKLES]

575
00:29:51,860 --> 00:29:56,340
这是死亡山的免费摄像机 包括我们的朋友 大戈兰
which is free camera on Death Mountain, including our friend, Big Goran.

576
00:29:56,340 --> 00:29:59,920
在黑色天空的映衬下 烟圈看起来有点奇怪 
The smoke halo looks sort of weird against the black sky,

577
00:29:59,920 --> 00:30:02,440
这里你可以看到任天堂愚弄了我们
and here you can see Nintendo fooled us.

578
00:30:02,440 --> 00:30:05,430
它不是整座山 只有悬崖的表面被渲染 
It's not full mountain, only the cliff face is actually rendered,

579
00:30:05,430 --> 00:30:09,000
那是通往烈火圣殿的路
and that's the path leading towards the Fire Temple.

580
00:30:09,000 --> 00:30:13,060
如果我们缩小 我们可以看到整个拖把的规模 
And if we zoom out, we can see the scale of the whole mop.

581
00:30:13,060 --> 00:30:15,240
比我想象的要大 
Bigger than I thought it would be actually.

582
00:30:15,240 --> 00:30:19,990
不过 战斗音乐不太适合史诗般的平移镜头 
The battle music's not quite fitting for an epic panning shot, though.

583
00:30:19,990 --> 00:30:23,090
科尔顿·奥格登：同样的想法 真的 只是有限的内存空间 
COLTON OGDEN: Same idea here, really, just limited memory space.

584
00:30:23,090 --> 00:30:25,840
所以让我们尽可能多地了解你
So let's load you know as much as we could possibly ever

585
00:30:25,840 --> 00:30:29,550
从林克摄影机的角度来看 
see from the perspective of the camera of Link,

586
00:30:29,550 --> 00:30:32,560
我想这其实和人们
and it's actually very similar to how, I guess, people

587
00:30:32,560 --> 00:30:36,230
在现实生活中创造一些场景让你觉得你是在一个
create stages in real life to make you feel as if you're in a--

588
00:30:36,230 --> 00:30:38,920
当你去看戏的时候 感觉你真的在一个场景里 
when you go to a play, feel like you're actually in a scene.

589
00:30:38,920 --> 00:30:43,090
但他们显然已经尽可能多的削减角落 但它的工作 
But they've clearly cut as many corners as possible, but it works.

590
00:30:43,090 --> 00:30:47,520
在游戏中 你无法分辨 这在游戏开发中很常见 
In the game, you can't tell, and that's very common in game development.

591
00:30:47,520 --> 00:30:50,260
如果你想达到一个特别宏伟的效果 
If you're trying to achieve a particularly grand effect,

592
00:30:50,260 --> 00:30:52,090
这是一个需要思考的问题
it's something to think about is how can I

593
00:30:52,090 --> 00:30:55,300
让我看起来像是在做什么但实际上我没有
make it seem like I'm doing something, but I'm actually not.

594
00:30:55,300 --> 00:30:58,540
我怎样才能让它看起来像我是一只鸟飞过一个无限系列
How can I make it seem like I'm a bird flying through an infinite series

595
00:30:58,540 --> 00:31:01,540
但实际上我不是
of levels, but I'm actually not.

596
00:31:01,540 --> 00:31:07,020
我们还有更多精彩节目即将播出 
We have a lot of more of that to show coming up soon.

597
00:31:07,020 --> 00:31:10,750
到目前为止 我们有我们的背景 但我们没有
So far we have our background, but we don't

598
00:31:10,750 --> 00:31:16,870
有我们游戏的标题人物 在这种情况下 五十鸟 
have the title character of our game, and in this case, fifty bird.

599
00:31:16,870 --> 00:31:20,980
所以我将继续 并说明我们如何得到一只鸟 
So I'm going to go ahead, and illustrate how we can get a bird actually

600
00:31:20,980 --> 00:31:23,390
渲染在屏幕上 
rendering on the screen.

601
00:31:23,390 --> 00:31:27,800
所以我将进入我创建的bird 2目录 
So I'm going to go ahead into my bird2 directory here, that I've created.

602
00:31:27,800 --> 00:31:31,000
再次注意 如果你已经加载了代码 
And note again, bird2 in your directory if you've loaded the code,

603
00:31:31,000 --> 00:31:34,210
将会有完整的实施 
is going to have the complete implementation.

604
00:31:34,210 --> 00:31:38,096
但总的来说 我会做几件事 
But in main, I'm going to do a couple of things.

605
00:31:38,096 --> 00:31:39,970
实际上 我要做的第一件事 
So actually, the first thing I'm going to do,

606
00:31:39,970 --> 00:31:42,310
我们要注意到我已经包括了
we're going to-- notice that I've included--

607
00:31:42,310 --> 00:31:48,010
实际上 我没有包括类文件 
actually, I haven't included the class file.

608
00:31:48,010 --> 00:31:49,580
所以我现在就去做 
So I'm going to do that right now.

609
00:31:49,580 --> 00:31:53,770
所以在bird 1中--对不起 我将从bird 3中获取类lua 
So in bird1-- sorry, I'm going to take from bird3, the class.lua.

610
00:31:53,770 --> 00:31:56,590
我将把它输入bird 2 因为我们
I'm going to go ahead, and put it into bird2 because we're

611
00:31:56,590 --> 00:31:57,746
我们要做一个鸟类课 
going to make a bird class.

612
00:31:57,746 --> 00:31:59,620
回想一下 从上周开始 
Recall, from last week, a class is just a way

613
00:31:59,620 --> 00:32:03,010
把我们曾经认为是完全不同的变量
of taking several variables that we might once have had disparate from one

614
00:32:03,010 --> 00:32:04,989
另一个是把它们放在一个包里 
another, putting them together in a package,

615
00:32:04,989 --> 00:32:07,030
把与这些变量相关的函数
putting functions associated with those variables

616
00:32:07,030 --> 00:32:09,160
这样我们就能打电话
together so that we can call--

617
00:32:09,160 --> 00:32:13,660
我们可以把游戏世界想得更抽象 
we can sort of think of our game world more abstractly, and more

618
00:32:13,660 --> 00:32:16,060
分隔开的 更干净的 
compartmentalized, and cleaner.

619
00:32:16,060 --> 00:32:19,000
所以我要继续--现在我有bird 2 类lua 
So I'm going to go ahead-- and now I have in bird2, the class.lua.

620
00:32:19,000 --> 00:32:23,394
这只是我们在Lua中使用Love 2D获取类的库 
That's just the library we're using to get classes in Love2D in Lua.

621
00:32:23,394 --> 00:32:25,810
我要继续 我要创建一个新文件 
I'm going to go ahead, and I'm going to create a new file.

622
00:32:25,810 --> 00:32:27,490
这只叫Bird.Lua 
This one's called bird.lua.

623
00:32:27,490 --> 00:32:31,660
所以请记住 趋势是类 将它们大写以区分它们
So remember, the trend is for classes, capitalize them to differentiate them

624
00:32:31,660 --> 00:32:35,920
从函数和变量 
from functions and variables.

625
00:32:35,920 --> 00:32:41,020
这一次 我将继续 只需继续使用我的小抄 
This one I'm going to go ahead, and just go ahead and use my cheat sheet here.

626
00:32:51,636 --> 00:32:53,940
我的床单粘在一起了 
My sheets are sticking together.

627
00:32:53,940 --> 00:32:58,232
好的 这个鸟类课实际上相当简单 
OK, so this bird class is actually fairly simple.

628
00:32:58,232 --> 00:33:00,190
回想一下 我们要做的就是创建一个类
Recall that all we have to do to create a class

629
00:33:00,190 --> 00:33:03,220
就是使用类库 大写的C加上括号
is just use the class library, the capital C with the brackets

630
00:33:03,220 --> 00:33:05,332
在那里初始化它 
there to initialize it.

631
00:33:05,332 --> 00:33:07,540
我们将继续定义我们的init函数 
We're going to go ahead and define our init function.

632
00:33:07,540 --> 00:33:13,120
因此 每个类都有一个初始化对象的init函数
So every class has an init function, which initializes the object

633
00:33:13,120 --> 00:33:16,420
它将在后面提到 
that it's going to refer to later.

634
00:33:16,420 --> 00:33:18,800
在这种情况下 我们需要一些东西 
In this case, we're going to need a few things.

635
00:33:18,800 --> 00:33:20,932
所以我们需要一张这只鸟的照片
So we're going to need an image for our bird

636
00:33:20,932 --> 00:33:22,640
因为我们希望它能被吸引到屏幕上 
because we want it to draw to the screen,

637
00:33:22,640 --> 00:33:25,056
所以我们需要做的 和我们之前做的一样--
and so what we need to do, same thing that we did before--

638
00:33:25,056 --> 00:33:26,140
Love.graph ics.newImage 
love.graphics.newImage.

639
00:33:26,140 --> 00:33:28,480
我要继续下去 很快地把它藏起来 
I'm going to go ahead, and hide this really fast.

640
00:33:28,480 --> 00:33:31,270
然后是Bird.png 
And then bird.png.

641
00:33:31,270 --> 00:33:33,280
简单 简单 
Simple, easy.

642
00:33:33,280 --> 00:33:37,600
我们想要我们的鸟的高度的宽度 
We want the width in the height of our bird.

643
00:33:37,600 --> 00:33:40,640
所以我要继续 把它也设置好 
So I'm going to go ahead, and set that too.

644
00:33:40,640 --> 00:33:45,130
因此 每个图像都有一组关联的函数
So every image has a set of functions associated

645
00:33:45,130 --> 00:33:46,930
有了它 爱为我们实现了 
with it that Love implements for us.

646
00:33:46,930 --> 00:33:49,665
我们从love.graph ics.newImage上得到的图像
The image that we get back from love.graphics.newImage

647
00:33:49,665 --> 00:33:54,400
本身就是一个类 它有一个名为getWidth的函数 
is itself, sort of a class, which has a function called getwidth.

648
00:33:54,400 --> 00:33:58,600
因此 这将允许我们动态地实现任何
So this will allow us to achieve the with, dynamically, of whatever

649
00:33:58,600 --> 00:34:00,250
班级我们--
class we--

650
00:34:00,250 --> 00:34:04,917
我们碰巧分配的任何图像文件 并从中创建对象 
whatever image file we happen to allocate, and create an object from.

651
00:34:04,917 --> 00:34:07,750
然后我们继续设置x和y 因为回想一下 
And then we're going to go ahead and set our x and y because recall,

652
00:34:07,750 --> 00:34:09,310
我们必须把它画在某个地方 
we have to draw it somewhere.

653
00:34:09,310 --> 00:34:11,690
我们想把我们的鸟画在屏幕中央 
We want to draw our bird in the middle of the screen.

654
00:34:11,690 --> 00:34:14,126
所以我们要继续 计算一下这个
So we're going to go ahead, and just calculate this

655
00:34:14,126 --> 00:34:15,250
根据我们的虚拟宽度 
based on our virtual width.

656
00:34:15,250 --> 00:34:17,250
所以我们要做的是用虚拟宽度除以2 
So we're going to do VIRTUAL_WIDTH divided by 2.

657
00:34:17,250 --> 00:34:19,083
所以它在屏幕的中间 
So it's halfway in the middle of the screen,

658
00:34:19,083 --> 00:34:21,007
但由于它是从左上角画出来的 
but since it draws from the top left corner,

659
00:34:21,007 --> 00:34:22,340
我们想把它移到左边 
we want to shift it to the left.

660
00:34:22,340 --> 00:34:25,060
所以我们要用我们的宽度--
So we're going to use our width that we just--

661
00:34:27,719 --> 00:34:30,730
即时错误--我们刚刚根据图像数据进行了初始化 
instant error-- we just initialized from the image data,

662
00:34:30,730 --> 00:34:34,060
然后我们要做的是自宽除以2 
and then we're going to do a self.width divided by 2.

663
00:34:34,060 --> 00:34:38,469
所以我们要把宽度除以2 在x轴上向左移动 
So we're going to divide the width by 2, shift that to the left on our x-axis.

664
00:34:38,469 --> 00:34:41,650
这将把我们放在水平方向的中间 
That's going to put us in the middle, horizontally.

665
00:34:41,650 --> 00:34:46,210
在垂直方向上 它是完全相同的 只是重复使用了高度而不是宽度 
Vertically, it's the exact same thing, except reusing height instead of width.

666
00:34:46,210 --> 00:34:51,670
差不多就是这样 除了这里的最后一点 
And that's pretty much it, except for one the last bit here.

667
00:34:51,670 --> 00:34:54,050
我们希望能够让我们的鸟变得非常重要 
We want to be able to render our bird, pretty important.

668
00:34:54,050 --> 00:35:03,580
所以我们要做love.graph 绘制我们的图像 然后在self.x self.y 
So we're going to do love.graphics.draw our image, and then at self.x, self.y.

669
00:35:03,580 --> 00:35:05,920
所以这就是我们真正需要的
And so this is all we really need just to get

670
00:35:05,920 --> 00:35:08,140
一个非常简单的精灵出现在屏幕上 
a very simple sprite onto the screen.

671
00:35:08,140 --> 00:35:10,930
现在 它什么也做不了 因为这种人生活在
Now, it's not going to do anything because this sort of lives

672
00:35:10,930 --> 00:35:12,580
目前还处于真空状态 
in a vacuum at the moment.

673
00:35:12,580 --> 00:35:15,640
我们需要做的是在我们的主文件中 我们
What we need to do is in our main file, we're

674
00:35:15,640 --> 00:35:19,150
这将需要鸟 这实际上将把它放入我们的--
going to require bird, which is going to actually put it into our--

675
00:35:19,150 --> 00:35:20,560
允许我们在代码中使用它 
allow us to use it in our code.

676
00:35:23,180 --> 00:35:32,790
我们将创建一个本地鸟类变量 
We're going to create a local bird variable.

677
00:35:32,790 --> 00:35:35,180
我们就叫它小鸟吧 
We're just going to call it bird.

678
00:35:35,180 --> 00:35:47,270
在那之后 我们将简单地渲染到屏幕上 
We're going to, after that, simply render to the screen like that,

679
00:35:47,270 --> 00:35:51,560
如果一切都做好了 如果我在正确的目录中--
and if all is done and well, and if I'm in the right directory--

680
00:35:55,210 --> 00:35:56,270
但这并没有奏效 
it did not work.

681
00:35:59,810 --> 00:36:02,950
再次确保保存您的工作 
Make sure you save your work, again.

682
00:36:02,950 --> 00:36:07,291
哦 我不需要上课 
Oh, I did not require class.

683
00:36:07,291 --> 00:36:07,790
我的错 
My bad.

684
00:36:07,790 --> 00:36:15,280
同样 我们需要这样做 因为我们已将其添加到我们的目录中 
So also, we need to do this since we added that to our directory.

685
00:36:15,280 --> 00:36:17,762
我也没有把Bird.png也包括在内 
And I did not include the bird.png as well.

686
00:36:17,762 --> 00:36:19,345
所以我要继续下去 并做到这一点 
So I'm going to go ahead, and do that.

687
00:36:19,345 --> 00:36:22,100
我要从下一本目录中借用一下 
I'm going to borrow that from the next directory.

688
00:36:22,100 --> 00:36:27,740
这应该是我们需要做的全部工作 并尝试调用方法 
That should be all we need to do, and attempt to call method.

689
00:36:27,740 --> 00:36:29,990
呈现空值 
Render a null value.

690
00:36:29,990 --> 00:36:32,720
有意思的 
Interesting.

691
00:36:32,720 --> 00:36:33,710
我不是救了小鸟吗？
Did I not save bird?

692
00:36:33,710 --> 00:36:36,350
我没有救小鸟 
I did not save bird.

693
00:36:36,350 --> 00:36:37,180
我们走吧 
There we go.

694
00:36:37,180 --> 00:36:38,240
我们做到了 
We did it.

695
00:36:38,240 --> 00:36:42,440
所以并不是特别有趣 但我们正在采取措施 
So not particularly interesting, but we're making steps.

696
00:36:42,440 --> 00:36:44,300
记住保存您的工作 
Remember to save your work.

697
00:36:44,300 --> 00:36:47,960
正如我们所看到的 我不这样认为 
As we can see, I do not.

698
00:36:47,960 --> 00:36:49,400
但我们正在取得进展 
But we're making progress.

699
00:36:49,400 --> 00:36:51,500
我们有我们要控制的实体 
We have our entity that we will control.

700
00:36:54,110 --> 00:36:59,540
从视觉上看 我们正在非常接近 但许多重要的细节都缺失了 
Visually, we're getting very close, but a lot of important details are missing.

701
00:36:59,540 --> 00:37:03,170
我们认为下一步应该是什么？
What should be the next step, do we think?

702
00:37:08,127 --> 00:37:09,960
观众：让我们让他跳跃和摔倒 
AUDIENCE: Let's get him jumping and falling.

703
00:37:09,960 --> 00:37:12,210
科尔顿·奥格登：没错 我们会在他们的帮助下做到这一点
COLTON OGDEN: Exactly, and we'll do that with the help

704
00:37:12,210 --> 00:37:14,970
这一概念在平台游戏和许多游戏中都很常见 
of a notion that's common in platformers, and a lot of games,

705
00:37:14,970 --> 00:37:16,680
事实上 但重力 
actually, but gravity.

706
00:37:16,680 --> 00:37:21,858
我们认为如何在2D游戏开发的背景下模拟重力？
How do we think we can simulate gravity in the context of 2D game development?

707
00:37:21,858 --> 00:37:25,200
观众：只是默认的 以恒定的速度下降 
AUDIENCE: Just by default, falling at a constant rate.

708
00:37:25,200 --> 00:37:27,180
科尔顿·奥格登：我们当然可以这么做 
COLTON OGDEN: We could do that, certainly,

709
00:37:27,180 --> 00:37:29,220
这实际上就是我们将要做的事情 
and that's effectively what we will be doing.

710
00:37:29,220 --> 00:37:32,820
我们将使用我们上周使用过的东西 即
We'll be using something that we used last week, which

711
00:37:32,820 --> 00:37:42,150
是速度 增量y 并将这个速度应用于我们的鸟类y 
was velocity, delta y, and applying that velocity to our birds y,

712
00:37:42,150 --> 00:37:46,740
一帧接一帧 这会给人一种坠落的错觉 
frame by frame, and that will give it the illusion of falling.

713
00:37:46,740 --> 00:37:51,120
现在 以恒定的速度下落并不能准确地反映重力的实际作用 
Now, falling at a constant rate isn't accurate to what gravity actually does.

714
00:37:51,120 --> 00:37:55,420
我们想要做的 可能是一次又一次的引力 
What we want to do, probably, is some gravity over and over again.

715
00:37:55,420 --> 00:37:58,330
以某种恒定值增加我们的重力
Increment our gravity by some sort of constant value

716
00:37:58,330 --> 00:38:02,320
因此 就像在现实生活中一样 事情下降得越来越快 
so that just like in real life, things fall faster, and faster,

717
00:38:02,320 --> 00:38:05,470
然后我们想把它加到我们的y值上 
and then we want to add that to our y value.

718
00:38:05,470 --> 00:38:08,630
所以我将继续下去 现在开始在Bird3中实现它 
So I'm going to go ahead, and start implementing that now in bird3.

719
00:38:08,630 --> 00:38:09,610
回购错误 
Wrong repo.

720
00:38:09,610 --> 00:38:16,670
所以小鸟3号 我们拥有我们以前拥有的一切 
So bird3, we have everything that we had from before,

721
00:38:16,670 --> 00:38:33,721
除了现在 我将继续 在main.lua中 在我们的更新函数中 
except now, I'm going to go ahead, and in main.lua, in our update function,

722
00:38:33,721 --> 00:38:35,470
这才是我们真正想要的
this is where we're actually going to want

723
00:38:35,470 --> 00:38:44,230
执行更新逻辑以使速度应用于鸟 
to perform the update logic for making the velocity apply to the bird.

724
00:38:44,230 --> 00:38:46,120
我们将把它推迟到鸟类课 
We're going to defer that to the bird class.

725
00:38:46,120 --> 00:38:49,286
我们将假设在我们的BIRD类中有一个名为UPDATE的方法 
We're going to assume that we have a method called update in our bird class,

726
00:38:49,286 --> 00:38:54,430
我们很快就会实施 这实际上是
which we're going to implement shortly, and that's actually

727
00:38:54,430 --> 00:38:57,210
我们在主课上所要做的就是 
all we need to do in our main class.

728
00:38:57,210 --> 00:39:01,150
而拥有可以委托所有这些工作的课程的好处是
And the beauty of having classes that you can delegate all this work

729
00:39:01,150 --> 00:39:06,300
TO 您的主文件 尽管它仍然变得相当大--它有108行--
to, your main file, though it's still getting quite large-- it's 108 lines--

730
00:39:06,300 --> 00:39:11,470
它不是200、300、400、数千行代码 因为我们能够
it's not 200 , 300, 400, thousands of lines of code because we're able

731
00:39:11,470 --> 00:39:16,660
破解这段代码 并将其封装到其他地方 
to break out this code, and encapsulate it elsewhere.

732
00:39:16,660 --> 00:39:18,580
所以这一次我要记住保存它 
So I'm going to remember to save it this time,

733
00:39:18,580 --> 00:39:23,500
然后我将进入Bird.Lua文件
and then I'm going to go into the bird.lua file

734
00:39:23,500 --> 00:39:26,890
在该目录中 这与评论相同
in that directory, which is the same with comments

735
00:39:26,890 --> 00:39:31,390
因为我是从官方回购上下载的 同样的鸟码
because I loaded it from the official repo, the same bird code

736
00:39:31,390 --> 00:39:33,310
我们之前写过的 
that we wrote before.

737
00:39:33,310 --> 00:39:35,390
我要继续下去 做几件事 
I'm going to go ahead, and do a couple of things.

738
00:39:35,390 --> 00:39:38,440
所以我要做的第一件事是定义一个常量 
So the first thing that I'm going to do is define a constant.

739
00:39:38,440 --> 00:39:42,760
所以我以前提到过重力 
So I mentioned gravity before.

740
00:39:42,760 --> 00:39:47,800
重力将是一个恒定值 就像它在现实生活中一样 
Gravity is going to be a constant value just like it is in real life.

741
00:39:47,800 --> 00:39:49,040
我要把它定义为20 
I'm going to define it to 20.

742
00:39:49,040 --> 00:39:50,331
它只是一个任意值 
It's just some arbitrary value.

743
00:39:50,331 --> 00:39:52,656
这是一种我觉得正确的价值观 
This is a value that I decided felt right,

744
00:39:52,656 --> 00:39:54,280
但您可以随心所欲地调整它 
but you can tune this however you want.

745
00:39:54,280 --> 00:39:56,060
做这件事没有对错之分 
There's no right or wrong way to do it.

746
00:39:56,060 --> 00:39:58,794
重力越小 它下落的速度就越慢 
The less the gravity is, the slower it'll fall,

747
00:39:58,794 --> 00:40:01,960
你越觉得自己在外太空 或者在月球上 
and the more you'll feel like you're sort of in outer space, or on the moon,

748
00:40:01,960 --> 00:40:02,460
或者诸如此类的 
or whatnot.

749
00:40:05,230 --> 00:40:10,030
我们还将继续 并定义--
We're going to also go ahead, and define--

750
00:40:10,030 --> 00:40:11,950
回想一下 我们需要一些方法来跟踪
recall that we need some way to keep track

751
00:40:11,950 --> 00:40:16,010
我们的鸟是如何坠落的 
of how our how our bird is falling.

752
00:40:16,010 --> 00:40:17,800
我们需要一个速度 一个y速度 
We want a velocity, a y velocity.

753
00:40:17,800 --> 00:40:19,870
这将更新我们每一帧的位置 
This is going to update our position each frame,

754
00:40:19,870 --> 00:40:22,000
它会让人感觉我们在坠落 
and it's going to make it feel like we're falling.

755
00:40:22,000 --> 00:40:24,000
所以我们要把初始速度设为0 
So we're going to set our initial velocity to 0.

756
00:40:24,000 --> 00:40:25,749
这只鸟只会在中间 
The bird's just going to be in the middle.

757
00:40:25,749 --> 00:40:27,130
它还不会掉下来 
It's not going be falling yet.

758
00:40:27,130 --> 00:40:31,300
我们不想做的是应用这个速度 
What we don't want to do is apply this velocity.

759
00:40:31,300 --> 00:40:35,650
记住 在我们的主文件中 我们假设我们有一个更新函数 
So remember, in our main file we assumed that we had an update function,

760
00:40:35,650 --> 00:40:37,480
但我们还没有真正实施它 
but we haven't actually implemented it yet.

761
00:40:37,480 --> 00:40:38,980
所以我们现在就要这么做了 
So we're going to do that right now.

762
00:40:38,980 --> 00:40:42,490
我们要说的是鸟食DT 
We're going to say birdupdate dt.

763
00:40:42,490 --> 00:40:47,530
我们将在主文件中使用的同一dt中传递它 
We're going to pass it in the same dt that we use in our main file,

764
00:40:47,530 --> 00:40:51,370
接下来我们要说的是 我们的速度
and we're going to go ahead, and just say our velocity

765
00:40:51,370 --> 00:40:59,630
等于我们当前的速度加上重力乘以增量时间 
is equal to our current velocity plus gravity times delta time.

766
00:40:59,630 --> 00:41:01,720
我们只需要用增量时间来衡量重力 
We're just going to scale gravity by delta time.

767
00:41:01,720 --> 00:41:04,210
所以它将移动相同的量 无论
So it will move the same amount no matter

768
00:41:04,210 --> 00:41:07,960
无论我们以每秒10帧还是每秒60帧的速度运行 
whether we're running at 10 frames per second or 60 frames per second.

769
00:41:07,960 --> 00:41:09,716
然后我们将继续--
And then we're going to go ahead--

770
00:41:09,716 --> 00:41:12,340
我们有一个速度 但它实际上并没有改变我们的y值 
we have a velocity, but it's not actually changing our y value.

771
00:41:12,340 --> 00:41:14,590
Y值是最终在屏幕上移动我们的东西 
The y value is what ultimately moves us on the screen.

772
00:41:14,590 --> 00:41:18,130
所以我们需要将新的增量y应用到y上 
So we need to apply our new delta y to our y.

773
00:41:18,130 --> 00:41:21,190
所以我们要继续下去 就这么做 
So we're going to go ahead, and just do that.

774
00:41:21,190 --> 00:41:26,310
得到了 加上自己的点 
Self.y gets self.y way plus self dot delta y, dy.

775
00:41:26,310 --> 00:41:32,540
所以如果我回到Bird3 假设我保存了一切 
And so if I go back into bird3, assuming I saved everything,

776
00:41:32,540 --> 00:41:34,900
我们应该直接跳到屏幕上 我们就是这么做的 
we should just fall straight to the screen, which we do.

777
00:41:34,900 --> 00:41:40,840
不是特别有用 但请注意 它可能有点难说 
Not terribly useful, but notice it's slightly hard to tell, maybe,

778
00:41:40,840 --> 00:41:44,470
但它确实一帧一帧地移动得越来越快 因为
but it does move faster, and faster, frame by frame because that delta

779
00:41:44,470 --> 00:41:48,190
和我们的y一样增加 这个增量y也在增加 
y is increasing as well as our y, and that delta y is getting

780
00:41:48,190 --> 00:41:49,939
适用于我们的y 一帧接一帧 
applied to our y, frame by frame.

781
00:41:49,939 --> 00:41:50,980
我会再做一次 
I'll do it one more time.

782
00:41:50,980 --> 00:41:52,150
只是看起来很有趣 
It's just funny to look at.

783
00:41:52,150 --> 00:41:55,210
好了 我们有了基本的重力 
All right, so we have basic gravity.

784
00:41:55,210 --> 00:41:56,620
超基本计算 
Super basic computation.

785
00:41:56,620 --> 00:42:01,120
只需跟踪某个重力常数 
Just keep track of some gravity constant, delta y,

786
00:42:01,120 --> 00:42:05,740
增加它 并将它应用于y 这就给了你重力 
increase that, and apply that to your y, and that gives you gravity.

787
00:42:05,740 --> 00:42:07,670
但是Flappy Bird会跳 
But Flappy Bird can jump.

788
00:42:07,670 --> 00:42:09,970
所以我们需要找到一种方法来对抗地心引力 
So we need to find a way to defy gravity.

789
00:42:09,970 --> 00:42:12,280
所以我们要做的是--在鸟4中 我们
So we're going to do the-- in bird4, we're

790
00:42:12,280 --> 00:42:14,440
我们把这叫做反重力更新 
going to call this the anti-gravity update,

791
00:42:14,440 --> 00:42:19,690
我们将讨论如何才能真正做到这一点 
and we're going to talk about how we can actually get that going.

792
00:42:19,690 --> 00:42:22,540
所以我找到了这张图 我觉得很合适 
So I found this diagram, which I felt was pretty apt,

793
00:42:22,540 --> 00:42:25,581
它还涵盖了我们今天讨论的其他一些概念 
and it also covers a few of the other concepts we're talking about today.

794
00:42:25,581 --> 00:42:29,290
但是看这里 这个重力 这是我们之前定义的常量 
But see here, this gravity, that's the constant we had just defined before,

795
00:42:29,290 --> 00:42:31,780
20美元或更多 这就适用于
the 20 or whatever, and this gets applied

796
00:42:31,780 --> 00:42:33,340
你想让它值多少就值多少 
at whatever value you want it to be.

797
00:42:33,340 --> 00:42:36,670
这将逐帧应用于您的y 
This gets applied frame by frame to your y.

798
00:42:36,670 --> 00:42:37,810
我们想要的是这个 
What we want is this.

799
00:42:37,810 --> 00:42:40,360
这里的矢量是跳跃速度 
This vector here is jump velocity.

800
00:42:40,360 --> 00:42:46,420
我们想要一些价值来抵消我们一直在积累的重力 
We want some value to counteract this gravity that we've been accumulating.

801
00:42:46,420 --> 00:42:48,400
那么 我们认为我们可以如何着手做这件事呢？
So how do we think we can go about doing this?

802
00:42:51,640 --> 00:42:57,070
我们可以将重力设置为某个负值 或许是一个高值 
We can set gravity to some, perhaps, negative value, a high value.

803
00:42:57,070 --> 00:42:59,740
这将产生一帧一帧的效果 
And that will have the effect of frame by frame,

804
00:42:59,740 --> 00:43:04,270
如果我们从某个正值开始 这会使我们在y轴上下降 
if we go from some positive value, which is taking us down on the y-axis,

805
00:43:04,270 --> 00:43:07,330
然后我们一帧接一帧地取负值 
and we go to a negative value, frame by frame,

806
00:43:07,330 --> 00:43:09,770
它会说 假设我们从负5开始 
it's going to say-- let's say that we start at negative 5.

807
00:43:09,770 --> 00:43:12,970
我们把它的速度设为负5
We set it's velocity to negative 5 it's going

808
00:43:12,970 --> 00:43:17,590
要将y设置为负--它将设置为+负5像素
to set y to negative-- it's going to set it to plus negative 5 pixels

809
00:43:17,590 --> 00:43:20,350
加上负4.9像素 4.8像素 
plus negative 4.9 pixels, 4.8 pixels.

810
00:43:20,350 --> 00:43:22,930
它将以相当快的速度以一系列像素拍摄我们 
It's going to shoot us up pretty fast in a series of pixels,

811
00:43:22,930 --> 00:43:26,700
但由于我们是一帧一帧地应用重力 这个值
but since we're applying gravity frame by frame, this value

812
00:43:26,700 --> 00:43:30,210
我们之前设定的 20 它将会产生这样的效果--
that we set before, 20, it's going to have the effect--

813
00:43:30,210 --> 00:43:31,160
是三角洲时间的20倍 
20 times delta time.

814
00:43:31,160 --> 00:43:33,570
因此 实际上 它被除以60 
So it gets, effectively, divided by 60.

815
00:43:33,570 --> 00:43:36,060
它将再次抵消这一点 
It's going to counteract this again.

816
00:43:36,060 --> 00:43:39,371
所以我们会以相当快的速度上升 但重力
So we're going to shoot up pretty fast, but gravity

817
00:43:39,371 --> 00:43:41,370
将立即开始站稳脚跟 
is going to start taking hold immediately after,

818
00:43:41,370 --> 00:43:45,570
我们将开始获得鸟类跳跃的效果 
and we're going to start getting the effect of our bird jumping,

819
00:43:45,570 --> 00:43:47,429
然后摔倒在地上 
and then falling down to the ground.

820
00:43:47,429 --> 00:43:49,470
这张图还显示了其他几件事 
A couple of other things that this diagram shows,

821
00:43:49,470 --> 00:43:54,032
我认为这很酷 这个管子缺口
which I thought were pretty cool, this pipe gap

822
00:43:54,032 --> 00:43:56,490
距离 这是我们将要讨论的很好的东西
distance here, something that we'll be talking about pretty

823
00:43:56,490 --> 00:43:59,972
不久 因为需要定义这一点 以便我们可以抵消我们的管道 
shortly because this needs to be defined so that we can offset our pipes.

824
00:43:59,972 --> 00:44:02,430
管道分离 这是我们将讨论的另一件事 
Pipe separation, it's another thing we'll be talking about.

825
00:44:02,430 --> 00:44:05,100
还有管道宽度 这只是一个内在值
And also pipe width, which is just an intrinsic value

826
00:44:05,100 --> 00:44:07,400
我们将使用的管状精灵的特征 
characteristic of the pipe sprite we'll be using,

827
00:44:07,400 --> 00:44:09,290
但我认为这是非常恰当的 
but I thought it was very apt.

828
00:44:09,290 --> 00:44:11,970
纽约大学做了一篇不错的文章 如果你想看的话
NYU did a nice article, if you want to look

829
00:44:11,970 --> 00:44:13,470
在这里 关于探索游戏空间 
at this, about exploring game space.

830
00:44:13,470 --> 00:44:17,190
他们通过计算确定了什么才是一只会飞的鸟
They computationally determined what would make a Flappy Bird

831
00:44:17,190 --> 00:44:20,340
难度或非难度级别 并对Flappy Bird级别进行动态评级
level difficult or not, and rated Flappy Bird levels that were dynamically

832
00:44:20,340 --> 00:44:22,562
是基于某种规模生成的 
generated based on some sort of scale.

833
00:44:22,562 --> 00:44:24,270
所以如果你好奇的话 可以在幻灯片中找到 
So if you're curious, it's in the slides,

834
00:44:24,270 --> 00:44:28,510
但我认为这是一个很酷的发现 因为我正在组织这次演讲 
but I thought it was a cool find as I was putting together this lecture.

835
00:44:28,510 --> 00:44:34,200
所以我们需要做的就是 简单地给重力增加一些负值 
So what we need to do is then, simply, add some negative value to gravity.

836
00:44:34,200 --> 00:44:35,922
负反重力 
Negative sort of anti-gravity.

837
00:44:35,922 --> 00:44:37,380
所以我们要继续这样做 
So we're going to go ahead do that.

838
00:44:37,380 --> 00:44:46,590
所以在我这里的迷你回购的第四只鸟中 
So in bird4 of the little mini repo that I have here,

839
00:44:46,590 --> 00:44:48,715
我们将首先在主干道上继续前进 
we're going to go ahead in main, first.

840
00:44:55,540 --> 00:45:01,120
我们想要做的一件事是因为这件事的另一部分
One thing that we want to do is because another part of this

841
00:45:01,120 --> 00:45:04,390
就是接受用户的输入 能够跳跃 
is taking input from the user, being able to jump,

842
00:45:04,390 --> 00:45:08,050
我们希望能够检测到他们是否按下了空格键 
we want to be able to detect whether they've pressed space.

843
00:45:08,050 --> 00:45:15,260
但如果我们想要检测我们曾经的每一个实体的输入 
But if we want to detect input for every single entity that we ever--

844
00:45:15,260 --> 00:45:19,070
在这样的情况下 这并不是特别重要 
in an instance like this, it's not terribly important,

845
00:45:19,070 --> 00:45:22,840
但假设我们有20或30种不同的实体 
but let's say we have 20 or 30 different kinds of entities,

846
00:45:22,840 --> 00:45:25,180
它们都有自己的输入处理 
and they all have their own input handling,

847
00:45:25,180 --> 00:45:27,670
我们不想让它堵塞我们的主管道 这是必然的 
we don't want to clog our main with that, necessarily.

848
00:45:27,670 --> 00:45:30,760
所以我们可以把它献给--
So we can dedicate that--

849
00:45:30,760 --> 00:45:34,700
我应该说 把它委托给代码的另一个部分 
delegate that, I should say, to another section of the code.

850
00:45:34,700 --> 00:45:37,120
在这种情况下 我们可以把我们的鸟儿输入
In this case, we can sort of put our birds input

851
00:45:37,120 --> 00:45:40,080
和我们的鸟类班一起来处理 对 
handling together with our bird class, right,

852
00:45:40,080 --> 00:45:45,940
并阐述了类的模型 对代码和数据的控制
and expound upon the model of the class, taking control of the code and data

853
00:45:45,940 --> 00:45:49,850
对于我们场景中的特定对象 
for that particular object in our scene.

854
00:45:49,850 --> 00:46:01,420
所以我们要做的就是在我们的爱中 
So what we're going to do is in our love.load,

855
00:46:01,420 --> 00:46:05,190
我要继续下去 在这里做一些事情 
I'm going to go ahead, and do something here.

856
00:46:05,190 --> 00:46:09,130
我将继续设置love.keyboard.keysPressed
I'm going to go ahead and set love.keyboard.keysPressed

857
00:46:09,130 --> 00:46:10,130
等于一张桌子 
equals a table.

858
00:46:10,130 --> 00:46:15,385
而我所做的只是在一张由Love定义的桌子上添加内容 
And what I'm doing is just adding onto a table that Love defined.

859
00:46:15,385 --> 00:46:16,810
这叫爱情键盘 
It's called love.keyboard.

860
00:46:16,810 --> 00:46:20,890
我将自己的值添加到它中 称为KeysPressed 
I'm adding my own value into it called keysPressed,

861
00:46:20,890 --> 00:46:23,060
我要把它分配给一张空桌子 
and I'm assigning it to an empty table.

862
00:46:23,060 --> 00:46:24,520
所以我们要做的是--
So what we're going to do--

863
00:46:24,520 --> 00:46:29,230
这是爱作为它的SDK的一部分给我们的一部分 
this is now part of what Love gives us as part of its SDK,

864
00:46:29,230 --> 00:46:32,050
但这是我们自己创造的东西 
but it's something that we've created ourselves,

865
00:46:32,050 --> 00:46:36,190
你可以这样做 因为在Lua 基本上所有的东西
and you can do this because in Lua, basically everything

866
00:46:36,190 --> 00:46:39,440
在基本变量之外 只有表 并且您可以操作表
beyond basic variables are just tables, and you can manipulate tables

867
00:46:39,440 --> 00:46:40,360
随心所欲 
however you want.

868
00:46:40,360 --> 00:46:42,150
在本例中 love.key是一张表 
In this case, love.keyboard is a table.

869
00:46:42,150 --> 00:46:43,720
我只是添加了一个名为keysPressed的新键 
I'm just adding a new key called keysPressed,

870
00:46:43,720 --> 00:46:45,835
我把它分配给我自己的一张空桌子 
and I'm assigning it to an empty table of my own.

871
00:46:45,835 --> 00:46:50,120
稍后我们将看看它是如何实际使用的 
And we're going to see how this is actually used in just a moment.

872
00:46:50,120 --> 00:46:55,060
所以我将在这里继续我们的按键功能--
So I'm going to go ahead in our keyPressed function here--

873
00:46:58,540 --> 00:47:03,190
该函数在用户每次按下游戏中的键时被调用 
this function is called every time a user presses a key in the game,

874
00:47:03,190 --> 00:47:06,850
但我会用它的 
but I'm going to use it.

875
00:47:06,850 --> 00:47:11,320
因为它做到了这一点 我可以继续下去 只做这样的事情 
Because it does that, I can go ahead, and just do something like this.

876
00:47:11,320 --> 00:47:19,540
Love.keyboard.keysPressed Key为True 其含义在此表中
Love.keyboard.keysPressed key gets true, and what that means is in this table

877
00:47:19,540 --> 00:47:23,500
我们刚刚定义的 我们自己创建的 任何时候用户
that we've just defined, we've created ourselves, anytime the user

878
00:47:23,500 --> 00:47:27,220
按任何键 因为会为您调用love.keyPressed 
presses any key, because love.keyPressed gets called for you,

879
00:47:27,220 --> 00:47:30,220
我们可以放心 无论如何 这里都会有人居住
we can safely rest assured that this is going to get populated no matter

880
00:47:30,220 --> 00:47:32,290
他们按下什么键 因为这只是一种
what key they press because it's just something

881
00:47:32,290 --> 00:47:33,850
Love2D会照顾你的 
that Love2D takes care for you.

882
00:47:33,850 --> 00:47:35,810
但它直到现在才被储存起来 
But it's not getting stored until now.

883
00:47:35,810 --> 00:47:38,440
现在我们实际上要跟踪它
Now we're actually going to keep track of it

884
00:47:38,440 --> 00:47:44,180
原因很快就会显现出来 
in our own table for reasons that will become apparent very shortly.

885
00:47:44,180 --> 00:47:49,900
这段代码的下一部分是定义一个定制函数 
The next part of this code is defining a custom function.

886
00:47:49,900 --> 00:47:55,420
因此 这其中的推动力是爱定义了几个功能 
So the impetus for this is Love defines a couple of functions.

887
00:47:55,420 --> 00:48:00,190
它定义了一个名为love.keyboard.isdown的函数 
It defines a function called love.keyboard.isdown,

888
00:48:00,190 --> 00:48:02,020
它接受一些关键的值 并且您可以
which takes in some key value, and you can

889
00:48:02,020 --> 00:48:06,700
使用它来测试连续输入 就像我们在上一节课中所做的那样 
use it to test for continuous input, which we did in the last lecture.

890
00:48:06,700 --> 00:48:10,600
我们在说 如果UP现在是DOWN 或者DOWN是DOWN 
We were saying hey, if up is down right now, or down is down,

891
00:48:10,600 --> 00:48:13,820
然后我们需要相应地更新y速度 
then we need to update our y velocity accordingly.

892
00:48:13,820 --> 00:48:16,540
但它没有这样的机制 比如说 
But it doesn't have a mechanism like this for let's say,

893
00:48:16,540 --> 00:48:18,850
我们想要在主文件之外的某个文件中检查
we want in some file other than main, to check

894
00:48:18,850 --> 00:48:22,090
因为如果一个键只按了一次 
for if a key was just pressed one time.

895
00:48:22,090 --> 00:48:24,880
它有这个函数love.keyPressed 它接受一个密钥 
It has this function, love.keyPressed, which takes a key,

896
00:48:24,880 --> 00:48:28,820
这将触发它 但我们不能在此函数之外访问它
and that will trigger it, but we can't access this outside of this function

897
00:48:28,820 --> 00:48:31,870
因为如果我们在Bird.Lua中定义这个函数 
because if we define this function in bird.lua,

898
00:48:31,870 --> 00:48:34,660
它将覆盖此实现 
it's going to overwrite this implementation.

899
00:48:34,660 --> 00:48:37,900
我们不一定要担心其他文件
And we don't necessarily want to have to worry about other files

900
00:48:37,900 --> 00:48:40,000
覆盖这些函数 因为谁知道呢--
overwriting these functions because who knows--

901
00:48:40,000 --> 00:48:41,380
尤其是如果你在一个团队里 谁知道呢
if you're on a team, especially, who knows

902
00:48:41,380 --> 00:48:43,780
谁被覆盖了love.key按下了 以及在哪个模块中 
who's overwritten love.keyPressed, and what module in,

903
00:48:43,780 --> 00:48:47,620
以及它被加载的顺序 以及实际有效的函数 
and what order does it get loaded in, and what functions actually valid.

904
00:48:47,620 --> 00:48:51,220
我们将通过赋予自己能力来解决这个问题
We're going to take care of this problem by giving ourselves the ability

905
00:48:51,220 --> 00:48:54,520
测试是否已在最后一帧上按下键
to test for whether a key has been pressed on the last frame

906
00:48:54,520 --> 00:49:00,040
通过实现我们也添加到键盘命名空间的函数 
by implementing a function that we are also adding to the keyboard namespace,

907
00:49:00,040 --> 00:49:04,420
我们自己的键盘桌 叫做wasPressed 
the keyboard table ourselves, called wasPressed.

908
00:49:04,420 --> 00:49:09,100
它需要一把钥匙 它要做的就是
And it's going to take a key, and all it's going to do

909
00:49:09,100 --> 00:49:11,040
就是检查我们之前创建表 
is check that table that we created before.

910
00:49:11,040 --> 00:49:18,250
它会说如果love.keyboard.keysPressed键 那么
It's going to say if love.keyboard.keysPressed key, then

911
00:49:18,250 --> 00:49:23,140
返回True 否则返回False 
return true, else return false.

912
00:49:23,140 --> 00:49:27,220
实际上 您可以只返回love.keyboard.keysPressed键 
And you could actually just return love.keyboard.keysPressed key,

913
00:49:27,220 --> 00:49:29,689
这将是一模一样的事情 
and it will be the exact same thing.

914
00:49:29,689 --> 00:49:31,480
因此 这样做的效果是
And so what this has the effect of doing is

915
00:49:31,480 --> 00:49:35,860
说 好的 因为在我们即将看到的更新上--
saying, OK, because on the update, which we're about to see--

916
00:49:35,860 --> 00:49:39,055
事实上 我可能应该在此之前这样做 这样所有这些都被捆绑在一起 
actually, I should probably do that before so this all gets tied together.

917
00:49:42,600 --> 00:49:45,100
在Love的最后 我们要做最后一件事 
At the end of love.update, we're going to do one last thing,

918
00:49:45,100 --> 00:49:50,960
这就是重置表格 因为我们只想逐帧检查 
and that's reset that table because we want to just check frame by frame.

919
00:49:50,960 --> 00:49:55,470
我们有一个表 一个全局表 我们已经创建
So we have a table, a global table, that we've created

920
00:49:55,470 --> 00:49:57,330
以检查是否按下了某个键 
to check for whether a key is pressed.

921
00:49:57,330 --> 00:50:00,615
我们有一个Love2D提供的回调函数 允许我们这样做 
We have a callback function that Love2D gives us that allows us to do that.

922
00:50:00,615 --> 00:50:02,490
所以每次按下一个键 我们就会
So every time a key gets pressed, we're going

923
00:50:02,490 --> 00:50:07,230
只需将该键添加到该表 并将其设置为True 
to just add that key to that table, and set it to true.

924
00:50:07,230 --> 00:50:10,740
现在 我们可以使用此函数随时简单地查询该表
Now, we can just simply query that table anytime we want to with this function

925
00:50:10,740 --> 00:50:14,160
我们已经创建了一个名为love.keyboard.wasPressed的键 它
that we've created called love.keyboard.wasPressed key, which

926
00:50:14,160 --> 00:50:18,210
最后一帧的意思是 那个键按下了吗？
means on the last frame, was that key pressed?

927
00:50:18,210 --> 00:50:20,152
基本上返回的是真还是假 
Basically return whether it's true or false.

928
00:50:20,152 --> 00:50:22,110
现在 唯一的问题是我们没有冲洗它 
Now, the only problem is we're not flushing it.

929
00:50:22,110 --> 00:50:24,550
我们永远不会将其设置为假 
We're not ever setting that to false.

930
00:50:24,550 --> 00:50:27,540
如果我们只需按下键盘上的所有键 
That's has the effect of if we just press all the keys on our keyboard,

931
00:50:27,540 --> 00:50:32,370
在我们重新初始化表之前 这些都是正确的
those will always be true until we re-initialize the table

932
00:50:32,370 --> 00:50:35,040
到某个空值 这就是我们在这里所做的 
to some empty value, which is what we do here.

933
00:50:35,040 --> 00:50:39,930
在检测到所有输入之后进行的更新上 
On the update, which takes place after all inputs been detected,

934
00:50:39,930 --> 00:50:44,580
我们要把那张桌子又放到一张空桌子上 
we're going to just set that table to an empty table again.

935
00:50:44,580 --> 00:50:48,880
在下一帧 它将--无论我们按下什么键 那些
And on the next frame, it's going to-- whatever keys we pressed, those

936
00:50:48,880 --> 00:50:52,620
将被设置为True 然后我们可以根据需要在此处查询该表 
will get set to true, and then we can just query that table here as needed,

937
00:50:52,620 --> 00:50:55,320
以及今后的任何更新 
and any update henceforth.

938
00:50:55,320 --> 00:51:00,262
那么 有没有人对这是如何运作的有任何疑问？
So does anybody have any questions as to how this is operating?

939
00:51:02,940 --> 00:51:06,542
因此 我们的最终驱动因素
And so the ultimate driving factor for us

940
00:51:06,542 --> 00:51:08,250
至于我们为什么要这样做 为什么我们想要
as to why we want to do this, why we want

941
00:51:08,250 --> 00:51:13,320
为了进行跟踪该全局输入表的工作 
to put in the work to keep track of this global input table,

942
00:51:13,320 --> 00:51:23,550
这样我们就可以真正地查询输入 即基于其他文件的单键输入
is so that we can actually query input, single key input based in other files

943
00:51:23,550 --> 00:51:25,560
在Main.Lua之外 因为目前 所有
outside of main.lua because currently, all

944
00:51:25,560 --> 00:51:29,010
我们能做的检查单键按下是在主线上 Lua 
we can do to check for single key presses is look in main.lua,

945
00:51:29,010 --> 00:51:31,020
但这不是我们想要做的 
but that's not what we want to do.

946
00:51:31,020 --> 00:51:38,790
我们将继续访问我们的Bird.lua 在我们的更新函数中 
We're going to go ahead and go to our bird.lua, and in our update function,

947
00:51:38,790 --> 00:51:42,690
这才是我们真正需要付出努力的地方 
this is where we actually get to use our efforts,

948
00:51:42,690 --> 00:51:49,800
并假设如果love.keyboard.wa按下空格 
and say if love.keyboard.wasPressed space,

949
00:51:49,800 --> 00:51:54,190
这是我们实际上想要允许我们跳跃的关键 
which is the key that we want to actually allow us to jump,

950
00:51:54,190 --> 00:51:56,510
去吧 把自己的生命设定为--
go ahead and set self dy to--

951
00:51:56,510 --> 00:51:59,040
当我们按空格键时 应该将self.dy设置为什么？
what should we set self.dy to when we press spacebar?

952
00:52:01,990 --> 00:52:04,379
它应该是正值还是负值？
Should it be a positive or a negative value?

953
00:52:04,379 --> 00:52:05,170
观众：没有 
AUDIENCE: Negative.

954
00:52:05,170 --> 00:52:06,910
科尔顿·奥格登：负值 
COLTON OGDEN: A negative value.

955
00:52:06,910 --> 00:52:09,380
我们会将其设置为负5 我们可能应该
We'll set it to negative 5, and we should probably

956
00:52:09,380 --> 00:52:12,230
把它定义为一个反重力常数 
define this as an anti-gravity constant up here.

957
00:52:12,230 --> 00:52:16,010
但为了速度起见 我们就说self.dy得到负5 
But just for the sake of speed, we'll say self.dy gets negative 5.

958
00:52:19,567 --> 00:52:20,650
我确实这么说过 对吧？
And I did say that, right?

959
00:52:20,650 --> 00:52:21,750
我确实这么说过 
I did say that.

960
00:52:21,750 --> 00:52:25,210
我要继续往前走 走进鸟巢 
I'm going to go ahead, and go into bird4.

961
00:52:25,210 --> 00:52:28,472
继续运行此示例 
Go ahead and run this example.

962
00:52:28,472 --> 00:52:32,950
看看这个 我们在跳 
And look at that, we're jumping.

963
00:52:32,950 --> 00:52:34,870
但我们仍然可以掉到地面上 
But we can still fall through the ground,

964
00:52:34,870 --> 00:52:36,866
而且我们没有任何真正的游戏可玩 
and we don't have any real game play.

965
00:52:36,866 --> 00:52:37,990
但我们已经走了很长一段路 
But we've come a long ways.

966
00:52:37,990 --> 00:52:41,410
现在我们已经接受了单键输入 否则
Now we've taken single key input that we otherwise

967
00:52:41,410 --> 00:52:43,750
没有能力在Love2D中做到这一点 而我们已经
didn't have the ability to do in Love2D, and we've

968
00:52:43,750 --> 00:52:46,570
仅仅通过跟踪我们的全局输入状态就可以实现 
made it possible by just keeping track of our global input state,

969
00:52:46,570 --> 00:52:49,780
每次更新都会刷新 
and flushing it every update.

970
00:52:49,780 --> 00:52:54,050
那么 有没有人对它的工作原理有任何疑问？
So does anybody have any questions as to how that works?

971
00:52:54,050 --> 00:52:55,660
好的 
OK.

972
00:52:55,660 --> 00:53:00,552
所以Flappy Bird的另一个主要视觉组件
So the other big major visual component of Flappy Bird

973
00:53:00,552 --> 00:53:02,510
就是我们在屏幕上看到的这些管子 
are these pipes that we see here on the screen.

974
00:53:02,510 --> 00:53:07,930
我们在那里有两个管道 但屏幕上充满了无限的管道 
We have two pipes there, but the screen is filled with infinite pipes.

975
00:53:07,930 --> 00:53:12,460
那么 有没有人对我们如何实现这一点有什么直觉呢？
So does anybody have any instinct as to how we can implement this?

976
00:53:16,036 --> 00:53:22,580
嗯 我们很快就会知道了 但我只想说我们需要一个新的雪碧 
Well, we'll see before long, but suffice to say we'll need a new sprite.

977
00:53:22,580 --> 00:53:25,710
我们需要某种方法来跟踪
We'll need some sort of way of keeping track

978
00:53:25,710 --> 00:53:32,520
何时产卵 因为它们会在一段时间后产卵 
of when to spawn them because they'd sort of spawn after a period of time,

979
00:53:32,520 --> 00:53:34,320
这将是我们的差距 
and that will be our gap.

980
00:53:34,320 --> 00:53:40,354
如果我们让它永远地生下去 会发生什么呢？
And then what will happen if we just let it spawn forever and ever?

981
00:53:40,354 --> 00:53:42,270
观众：你必须在他们离开的时候摧毁他们？
AUDIENCE: You have to destroy them as they go?

982
00:53:42,270 --> 00:53:43,500
科尔顿·奥格登：我们这样做是因为如果我们不这样做
COLTON OGDEN: We do because if we don't do

983
00:53:43,500 --> 00:53:45,780
在一段时间后 我们会分配内存
that, after a certain period of time, we're allocating memory

984
00:53:45,780 --> 00:53:46,950
对于这些管道中的每一个 
for each of these pipes.

985
00:53:46,950 --> 00:53:52,200
不是一吨的内存 只是本质上 x y 一个宽度和一个高度 
Not a ton of memory, just essentially, an x, a y, a width, and a height.

986
00:53:52,200 --> 00:53:54,480
而是因为它们引用的都是相同的--
But because they all reference the same--

987
00:53:54,480 --> 00:53:57,639
他们将引用相同的精灵图像 但如果有足够的时间 
they will reference the same sprite image, but given enough time,

988
00:53:57,639 --> 00:54:00,180
最终 您将分配一定数量的字节
eventually you're going to allocate a certain number of bytes

989
00:54:00,180 --> 00:54:03,900
这将超过您的计算机内存或分配的内存量 
that will exceed your computer's memory, or the amount of allocated memory,

990
00:54:03,900 --> 00:54:06,810
你要么无限地挂着 要么崩溃 
and you'll either hang infinitely, or crash.

991
00:54:06,810 --> 00:54:11,950
因此 我们想要在他们离开的同时摧毁他们 
And so we want to destroy them as they go as well.

992
00:54:11,950 --> 00:54:16,650
因此 我们将继续 并查看最终的实时编码示例
So we're going to go ahead, and look at the final live coded example

993
00:54:16,650 --> 00:54:20,120
只是因为从现在开始 这会有点太多了 
just because from here on out, it's going to be a little bit much.

994
00:54:20,120 --> 00:54:25,785
我要走了 先去Main Lua 
I'm going to go ahead, and go to main.lua first.

995
00:54:30,300 --> 00:54:35,730
所以把我的笔记整理好 
So just get my notes in order.

996
00:54:35,730 --> 00:54:37,365
我们想做的第一件事是--
The first thing that we want to do--

997
00:54:37,365 --> 00:54:38,990
哦 其实我也买错了 
oh, I'm actually in the wrong repo too.

998
00:54:38,990 --> 00:54:39,850
我向你道歉 
I apologize.

999
00:54:39,850 --> 00:54:40,920
我在发行回购中 
I was in the distro repo.

1000
00:54:40,920 --> 00:54:43,260
我想成为划痕回收员 
I want to be in the scratch repo.

1001
00:54:43,260 --> 00:54:52,510
所以我要继续 进入Main 我将需要管道 
So I'm going to go ahead, go into main, and I'm going to require pipe.

1002
00:54:52,510 --> 00:54:56,200
现在 我们还没有管道 但这是一个完美的例子
Now, we don't have a pipe yet, but this is a perfect example of how

1003
00:54:56,200 --> 00:54:58,990
我们可以继续抽象我们的游戏 
we can keep abstracting our game.

1004
00:54:58,990 --> 00:55:02,110
我们有一节鸟类课 但我们也应该
We have a bird class, but we should also probably

1005
00:55:02,110 --> 00:55:05,810
我有一个管道类 因为管道在我们的游戏中是一种不同类型的实体
have a pipe class because a pipe is a distinct type of entity in our game

1006
00:55:05,810 --> 00:55:06,310
世界 
world.

1007
00:55:06,310 --> 00:55:09,310
我们可以将它建模为一个单元 我们可以赋予它功能 
We can model it as a unit, we can give it functions,

1008
00:55:09,310 --> 00:55:13,280
我们可以给它数据 把它想象成一根管道 
we can give it data, and think about it in terms of it being a pipe,

1009
00:55:13,280 --> 00:55:17,770
不是XY、宽度、高度等的集合 
not being a set of xy, width, height, et cetera.

1010
00:55:17,770 --> 00:55:20,530
无论您想要将什么数据归因于它 我们
Whatever data you want to ascribe to it, we

1011
00:55:20,530 --> 00:55:24,130
可以把它抽象出来 用更抽象的术语思考 这将
can abstract that out, and think in more abstract terms, which will

1012
00:55:24,130 --> 00:55:25,812
让我们能够更好地扩大规模 
allow us to scale a little bit better.

1013
00:55:25,812 --> 00:55:28,520
所以我们将继续 并假设我们有一个管道类 
So we're going to go ahead, and assume that we have a pipe class.

1014
00:55:28,520 --> 00:55:32,320
我将继续 并立即将其添加到我们的文件夹中 
I'm going to go ahead, and add it to our folder here right now.

1015
00:55:32,320 --> 00:55:39,460
所以创建一个新文件 pipe.lua 我要
So do a new file, pipe.lua, and I'm going

1016
00:55:39,460 --> 00:55:42,370
继续 并在这里引用一下音符 
to go ahead, and reference to notes here for just a second.

1017
00:55:52,650 --> 00:55:56,900
所以管道类实际上非常简单 
So the pipe class is actually quite simple,

1018
00:55:56,900 --> 00:55:59,115
就像最初的鸟类课一样 
just like the bird class was initially.

1019
00:55:59,115 --> 00:56:00,990
我们不需要跟踪大量的数据 
We don't need to keep track of a lot of data,

1020
00:56:00,990 --> 00:56:03,770
但我们确实想要跟踪一些事情 
but we do want to keep track of a few things.

1021
00:56:03,770 --> 00:56:08,510
所以这只鸟--只会有一只鸟出来
So the bird-- there's only ever going to be one bird out

1022
00:56:08,510 --> 00:56:11,900
一次 但是有了管子 我们就会把它们生出来 
at once, but with the pipes, we're going to be spawning them over,

1023
00:56:11,900 --> 00:56:13,170
一遍又一遍 
and over again.

1024
00:56:13,170 --> 00:56:15,680
所以如果我们分配给他们--
And so if we allocate them--

1025
00:56:15,680 --> 00:56:20,030
对于我们实例化的每个管道 如果我们分配一个新的映像 
for each pipe that we instantiate, if we allocate a new image,

1026
00:56:20,030 --> 00:56:22,550
这可能不是很有效率 对吧？
this is probably not super efficient, right?

1027
00:56:22,550 --> 00:56:23,930
我们使用的是相同的数据 
We're using the same exact data.

1028
00:56:23,930 --> 00:56:25,550
我们有一堆管子 
We have a bunch of pipes.

1029
00:56:25,550 --> 00:56:28,040
我们真的只需要一个精灵 
We only really need one sprite.

1030
00:56:28,040 --> 00:56:32,180
所以在init函数之外--就在哪里
So outside of the init function-- so just below where

1031
00:56:32,180 --> 00:56:34,882
我们声明管道是一个类 我们是
we're declaring that pipe is a class, we're

1032
00:56:34,882 --> 00:56:37,340
接下来我们将创建一个局部变量 该变量仍然
going to go ahead and create a local variable that is still

1033
00:56:37,340 --> 00:56:40,100
作用域为此文件 但只有
scoped to this file, but there's only ever going

1034
00:56:40,100 --> 00:56:44,280
是这个物体的一个副本 
to be one copy of this object.

1035
00:56:44,280 --> 00:56:46,750
我们将把它命名为--
We're going to go ahead and call it--

1036
00:56:46,750 --> 00:56:50,120
假设我们在此文件夹中有pipe.png 
say that we have pipe.png in this folder,

1037
00:56:50,120 --> 00:56:52,290
这是从功能中分离出来的
and this is separated out from the functions

1038
00:56:52,290 --> 00:56:54,331
我们将在这里定义 但这
that we're going to be defining in here, but this

1039
00:56:54,331 --> 00:56:59,180
具有创建半全局图形对象的效果 
has the effect of creating a semi global graphics object,

1040
00:56:59,180 --> 00:57:02,124
即使它包含在这个类文件中 
even though it's contained within this class file.

1041
00:57:02,124 --> 00:57:04,040
它不能在这个类文件之外访问
It's not accessible outside of this class file

1042
00:57:04,040 --> 00:57:05,390
因为我们不需要这样 
because we don't need it to be.

1043
00:57:05,390 --> 00:57:09,290
但它也不是每次都被实例化 因为回想一下 
But it's also not being instantiated every single time because recall,

1044
00:57:09,290 --> 00:57:16,430
如果我们看一下Bird.Lua 我们只是在设置它
if we look at bird.lua here, we're just setting it

1045
00:57:16,430 --> 00:57:20,600
As self.Image获得love.graph ics.newImage Bird.png 
as self.image gets love.graphics.newImage bird.png.

1046
00:57:20,600 --> 00:57:24,440
这将产生每次都分配一个新图像的效果
This will have the effect of allocating a new image every time

1047
00:57:24,440 --> 00:57:25,880
我们创建了一个鸟对象 
we create a bird object.

1048
00:57:25,880 --> 00:57:29,570
但我们只创建了一个鸟对象 所以它并不是一个真正重要的设计
But we only ever create one bird object, so it's not really an important design

1049
00:57:29,570 --> 00:57:36,080
考虑到我们会说 也许我们应该创造一个半全球化的形象
consideration for us to say, maybe we should create a semi global image up

1050
00:57:36,080 --> 00:57:37,250
这里 
here.

1051
00:57:37,250 --> 00:57:39,050
在这种情况下 这并不重要 
It's not important in this context.

1052
00:57:39,050 --> 00:57:43,670
对于更大的项目来说 这样做可能是一种不错的风格 但只是
Probably good style to do so anyway for larger projects, but just

1053
00:57:43,670 --> 00:57:44,837
这是这里的一个考虑因素 
a consideration for here.

1054
00:57:44,837 --> 00:57:46,670
这不是我们需要担心的事 
Not really something we need to worry about.

1055
00:57:46,670 --> 00:57:51,020
但是的 一定要试着拿到一笔资产 
But yes, definitely try to take an asset,

1056
00:57:51,020 --> 00:57:56,045
并引用它 而不是尽可能多次地分配它 
and reference it rather than allocate it as many times as possible.

1057
00:57:59,090 --> 00:58:00,950
我们希望我们的烟斗可以滚动 
We want our pipes to scroll.

1058
00:58:00,950 --> 00:58:02,330
因此 我们需要某种价值 
So we need some sort of value.

1059
00:58:02,330 --> 00:58:04,039
就像我们处理背景一样 我们
Just like we did with the backgrounds, we

1060
00:58:04,039 --> 00:58:06,954
需要一些值来跟踪这些管道是否正在滚动 
need some value that keeps track of whether these pipes are scrolling,

1061
00:58:06,954 --> 00:58:08,390
它可以是一个常量值 
and it can be a constant value.

1062
00:58:08,390 --> 00:58:11,510
这一次我们直接把它称为负60 
We're going to directly call it negative 60 this time,

1063
00:58:11,510 --> 00:58:18,360
而不是在我们稍后将其添加到我们的立场时予以否定 
and not negate it when we add it to our position later on.

1064
00:58:18,360 --> 00:58:24,590
所以PIPE_SCROLL负60 我们可以直接加到我们的x上 或者加到我们的--
So PIPE_SCROLL negative 60, we can just add it directly to our x, or to our--

1065
00:58:24,590 --> 00:58:26,455
是的 在这种情况下 只给我们的x 而且它
yeah, in this case, just to our x, and it

1066
00:58:26,455 --> 00:58:28,730
当然 会有-增量时间 
will have the-- times delta time, of course,

1067
00:58:28,730 --> 00:58:30,890
这将产生转移的效果
and that will have the effect of shifting

1068
00:58:30,890 --> 00:58:33,990
它离开是因为它是负数 
it left because it's a negative number.

1069
00:58:33,990 --> 00:58:35,490
我们将在这里定义init函数 
We'll define the init function here.

1070
00:58:35,490 --> 00:58:37,760
所以 通过管道初始化 
So pipe init.

1071
00:58:37,760 --> 00:58:40,460
在init函数中 我们要做几件事 
Within the init function, we're going to do a couple of things.

1072
00:58:40,460 --> 00:58:43,130
所以是x 
So it's x.

1073
00:58:43,130 --> 00:58:45,360
X应该在哪里？
Where should the x be?

1074
00:58:45,360 --> 00:58:49,340
比方说 如果我们希望管道产生 x应该设置为多少
What should the x be set to, let's say, if we want the pipe to spawn

1075
00:58:49,340 --> 00:58:51,702
超出屏幕右边缘？
beyond the right edge of the screen?

1076
00:58:51,702 --> 00:58:55,630
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1077
00:58:55,630 --> 00:58:58,540
科尔顿·奥格登：虚拟宽度 你还可以
COLTON OGDEN: Virtual width, and you could also

1078
00:58:58,540 --> 00:59:01,420
假设虚拟宽度加上一些数字 如果你想的话 
say virtual width plus some number if you wanted to.

1079
00:59:01,420 --> 00:59:04,600
因为它被设置为0 0 所以它将有
Because it's set to 0,0, it's going to have

1080
00:59:04,600 --> 00:59:07,660
你不会在实例化的画面上看到它 
the-- you won't see it on the frame that it gets instantiated,

1081
00:59:07,660 --> 00:59:12,310
但是的 虚拟宽度或虚拟宽度加上某个常量值 或一些
but yes, virtual width or virtual width plus some constant value, or some

1082
00:59:12,310 --> 00:59:14,260
您已提前分配的值 
value that you've allocated ahead of time.

1083
00:59:14,260 --> 00:59:15,847
我们只需将其设置为虚拟宽度 
We'll just set it to virtual width.

1084
00:59:15,847 --> 00:59:18,430
所以一旦管道被初始化 它就是不可见的 
So as soon as the pipe gets initialized, it will be invisible,

1085
00:59:18,430 --> 00:59:22,390
但它会出现在屏幕的右边 
but it's going to be right on the right edge of the screen.

1086
00:59:22,390 --> 00:59:25,150
我们的y值呢？
What about our y value?

1087
00:59:25,150 --> 00:59:29,260
首先 让我们看看图像是什么样子的 这样我们就可以看到了 
First of all, let's take a look at what the image looks like so we can see.

1088
00:59:29,260 --> 00:59:31,210
它将出现在我们的.
It's going to be in our--

1089
00:59:31,210 --> 00:59:33,775
我不认为我在那个目录中有实际的图像 
I don't think I have the actual image in that directory.

1090
00:59:33,775 --> 00:59:34,960
所以我要来这里 
So I'm going to come here.

1091
00:59:34,960 --> 00:59:36,520
我去拿烟斗 
I'm going to grab the pipe.

1092
00:59:36,520 --> 00:59:38,390
这就是管子的样子 
This is what the pipe looks like.

1093
00:59:38,390 --> 00:59:40,446
让我们看看我能不能把它扩大一点 
Let's see if I can expand it a little bit.

1094
00:59:44,795 --> 00:59:45,670
所以它有点高 
So it's kind of tall.

1095
00:59:45,670 --> 00:59:48,680
如果我们想要 我们应该把它放在哪里
Where should we probably place it if we wanted

1096
00:59:48,680 --> 00:59:54,420
它看起来像飞鸟吗？
it to look similar to Flappy Bird?

1097
00:59:54,420 --> 00:59:58,050
很可能是在屏幕的下端 
Probably towards the lower end of the screen.

1098
00:59:58,050 --> 01:00:00,420
我们也可以幻想它 我们甚至可以
We can get fancy with it too, and we can even maybe

1099
01:00:00,420 --> 01:00:02,919
让它像Flappy Bird那样随机化 
make it randomized just like Flappy Bird.

1100
01:00:02,919 --> 01:00:04,210
因此 我们将继续 并做到这一点 
So we'll go ahead, and do that.

1101
01:00:04,210 --> 01:00:07,290
我将继续复制 并将其放入我们的临时文件夹中
I'm going to go ahead, and copy this, and put it into our scratch folder

1102
01:00:07,290 --> 01:00:10,170
这里 
here.

1103
01:00:10,170 --> 01:00:14,190
回到init函数 我将继续 并设置self.y 
Back in the init function, I'm going to go ahead, and set self.y too.

1104
01:00:14,190 --> 01:00:17,100
因为我们想谈的是程序生成 
Because we want to talk about procedural generation,

1105
01:00:17,100 --> 01:00:19,850
这将是我们第一次尝试如何随机化这一点 
this will be sort of our first foray into how we randomize this.

1106
01:00:19,850 --> 01:00:23,394
我们将使用上周使用的函数 
We'll be using the function that we used last week,

1107
01:00:23,394 --> 01:00:24,810
这是一个无处不在的函数 
and this is a ubiquitous function.

1108
01:00:24,810 --> 01:00:29,440
你会在你使用的任何框架或游戏引擎中随处可见--
You'll see this everywhere in any framework or game engine you use--

1109
01:00:29,440 --> 01:00:31,900
数学 随机的 
math.random.

1110
01:00:31,900 --> 01:00:34,690
我们希望它是屏幕的下半部分 
We want it to be the lower half of the screen.

1111
01:00:34,690 --> 01:00:38,700
假设虚拟高度除以4是上限 也许
So let's say virtual height divided by 4 is the upper bound, and maybe

1112
01:00:38,700 --> 01:00:44,950
虚拟高度减去10作为上限 
virtual height minus 10 as the upper bound.

1113
01:00:44,950 --> 01:00:49,110
因此 这将产生将其设置为大约四分之一屏幕的效果 
So that will have the effect of setting it to roughly a quarter of the screen.

1114
01:00:49,110 --> 01:00:52,694
抱歉 虚拟高度除以4是屏幕的最高端 
Sorry, virtual height divided by 4 is towards the top end of the screen,

1115
01:00:52,694 --> 01:00:55,360
然后虚拟高度减去10就是屏幕的下端 
and then virtual height minus 10 is the lower end of the screen.

1116
01:00:55,360 --> 01:00:59,220
因此 它实际上将覆盖从低于这一水平的第一季度开始的任何地方
So it's actually going to cover anywhere from the first quarter below that, down

1117
01:00:59,220 --> 01:01:00,780
从底部到大约10个像素 
to about 10 pixels from the bottom.

1118
01:01:00,780 --> 01:01:03,902
观众：你一定要在这里面设置随机种子吗？
AUDIENCE: Do you have to set the random seed in this [INAUDIBLE]

1119
01:01:03,902 --> 01:01:04,800
或者你主要做这件事？
or do you do it main?

1120
01:01:04,800 --> 01:01:06,050
科尔顿·奥格登：我在美因河畔做 
COLTON OGDEN: I do it in main.

1121
01:01:06,050 --> 01:01:11,430
因此 在这个文件中 我不确定我这样做是否是为了这个演示 
So in this file, I am not sure if I did it for this demonstration.

1122
01:01:11,430 --> 01:01:13,395
这肯定是在回购中设定的 
It is definitely set in the repo.

1123
01:01:16,245 --> 01:01:18,750
我不认为我在这个例子中设置了它 但是 是的 您
I don't think I set it in this example, but yes, you

1124
01:01:18,750 --> 01:01:21,570
如果您想让它每次都运行 就会在这里设置随机种子 
would set the random seed here if you wanted it to run every time.

1125
01:01:21,570 --> 01:01:22,080
抱歉的 
Sorry.

1126
01:01:22,080 --> 01:01:26,850
问题是 我们是否应该在BIRD文件中设置随机种子 
And the question was should we set the random seed in the bird file,

1127
01:01:26,850 --> 01:01:29,130
或者我们应该把它设在主星上？
or should we set it in main.lua?

1128
01:01:29,130 --> 01:01:32,590
通常 您希望在应用程序的顶级设置它 
Typically, you want to set it at the top level of your application.

1129
01:01:32,590 --> 01:01:36,210
所以我们要把它放进去--
So we're going to set it in--

1130
01:01:36,210 --> 01:01:41,610
我们将继续 并将其设置为Main 
we're going to go ahead, and set it in main.

1131
01:01:41,610 --> 01:01:54,880
函数本身就在这里 我认为它是从Bird6开始的 从6开始 
And the function itself is here, and I think it's starting in bird6, onwards.

1132
01:01:54,880 --> 01:01:55,610
所以它将会是--
So it will be--

1133
01:02:00,030 --> 01:02:01,300
我没设好吗？
did I not set it?

1134
01:02:01,300 --> 01:02:04,254
我可能要到回购的晚些时候才会设置随机种子 
I may not have set the random seed until later in the repo.

1135
01:02:04,254 --> 01:02:05,045
让我们检查一下Bird12 
Let's check bird12.

1136
01:02:09,810 --> 01:02:13,170
所以 是的 数学 随机种子 然后是os.time的种子 
So yes, math.randomseed, and then seed by os.time,

1137
01:02:13,170 --> 01:02:15,300
就像我们上周在课堂上用到的一样 
as we used last week in class.

1138
01:02:18,160 --> 01:02:20,850
我把它放在这里 
I'll set it here.

1139
01:02:20,850 --> 01:02:23,370
也许 我们只会运行一次 但它会产生效果 
Probably, we'll only run it once, but it'll have the effect.

1140
01:02:23,370 --> 01:02:27,780
现在我们可以运行几次 看看管道中的不同之处 
Now we can run it several times just to see the difference in the pipes.

1141
01:02:27,780 --> 01:02:37,200
让我们回到我们的管道 Lua在这里 我们有x y 
Let's go back to our pipe.lua here, and we have the x, we have the y.

1142
01:02:37,200 --> 01:02:39,700
因此 这些都是相应地设置的 
So those are set accordingly.

1143
01:02:39,700 --> 01:02:41,340
我们还想设置宽度 
We also want to set the width.

1144
01:02:41,340 --> 01:02:50,210
有人记得获取图形对象宽度的函数是什么吗
Does anybody recall what the function is to get a width of a graphics object

1145
01:02:50,210 --> 01:02:53,370
它的语法是什么？
and the syntax for that?

1146
01:02:53,370 --> 01:02:56,420
所以我们在这里有我们的图像 管道图像 
So we have our image up here, pipe image.

1147
01:02:56,420 --> 01:02:58,700
它是love.graph ic.newImage pipe.png 
It's love.graphic.newImage pipe.png.

1148
01:03:01,480 --> 01:03:02,944
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1149
01:03:02,944 --> 01:03:03,920
科尔顿·奥格登：没错 
COLTON OGDEN: Exactly.

1150
01:03:03,920 --> 01:03:08,700
因此 我们将继续 并将其设置为PIPE_IMAGE冒号getWidth 
So we're going to go ahead, and set this to PIPE_IMAGE colon getWidth,

1151
01:03:08,700 --> 01:03:13,785
这将成为我们的新--这将使我们能够存储我们的宽度以备
and that will become our new-- that will allow us to store our width for when

1152
01:03:13,785 --> 01:03:14,940
我们稍后将使用它 
we will use it later.

1153
01:03:18,430 --> 01:03:20,770
然后我们还需要一些其他函数 
And then we need a few other functions.

1154
01:03:20,770 --> 01:03:24,000
所以烟斗会产生 但它不会移动 因为我们还没有
So the pipe will spawn, but it won't move because we haven't

1155
01:03:24,000 --> 01:03:26,700
对它进行了任何形式的滚动 
applied any sort of scrolling to it.

1156
01:03:26,700 --> 01:03:29,520
我们在第五行有滚动的变量 
We have the scrolling variable up on line five,

1157
01:03:29,520 --> 01:03:31,680
但我们需要将其实际应用到我们的管道中 
but we need to actually apply it to our pipe.

1158
01:03:31,680 --> 01:03:35,650
所以我们将继续 并创建一个更新函数 
So we're going to go ahead, and create an update function.

1159
01:03:35,650 --> 01:03:38,580
然后在更新函数中 非常类似于
And then in that update function, very similar to what

1160
01:03:38,580 --> 01:03:43,690
我们以前已经见过 pio_scroll乘以增量时间 
we've seen before already, PIPE_SCROLL times delta time.

1161
01:03:43,690 --> 01:03:46,560
最后 我们想要渲染我们的烟斗 
And then lastly, we want to render our pipe.

1162
01:03:46,560 --> 01:03:50,640
所以我们将继续 调用我们今天已经看到的函数 
So we're going to go ahead, and call a function that we've seen already today,

1163
01:03:50,640 --> 01:03:57,060
我们将使用上面的管子图像 
love.graphics.draw We're going to use the pipe image up above,

1164
01:03:57,060 --> 01:04:02,040
然后我们将继续使用self.x 
and then we're going to go ahead, and use self.x,

1165
01:04:02,040 --> 01:04:07,080
和自己 这就是我们的烟斗所需要的 
and self.y, and that's all we need for our pipe.

1166
01:04:07,080 --> 01:04:09,949
让我确保这就是我们真正需要的 
And let me make sure that that's all we really need.

1167
01:04:09,949 --> 01:04:12,990
所以在主流星中--我们也必须回到主流星 因为我们实际上
So in main.lua-- we've got to go back to main.lua too because we actually

1168
01:04:12,990 --> 01:04:14,198
必须开始产卵了 
have to start spawning pipes.

1169
01:04:17,790 --> 01:04:20,990
所以让我们继续 去--
So let's go ahead, and go to--

1170
01:04:20,990 --> 01:04:23,790
让我在这里再次调出我的代码 
let me pull up my code here one more time.

1171
01:04:26,540 --> 01:04:30,510
在主线上--所以在第59行--
In main-- so on line 59--

1172
01:04:30,510 --> 01:04:31,910
抱歉 你看不到的 
sorry, you won't see it.

1173
01:04:31,910 --> 01:04:34,200
您将在实际发行版代码的第59行中看到它 
You'll see it in line 59 in the actual distro code,

1174
01:04:34,200 --> 01:04:38,460
但对我来说 情况会略有不同 
but for me, it's going to be slightly different.

1175
01:04:38,460 --> 01:04:41,210
我们将继续 并创建一个新表
We're going to go ahead, and create a new table

1176
01:04:41,210 --> 01:04:44,060
来跟踪我们想要产生的所有管道 因为我们
to keep track of all the pipes that we want to spawn because we

1177
01:04:44,060 --> 01:04:45,518
需要一种方法将它们存储在内存中 
need a way to store them in memory.

1178
01:04:45,518 --> 01:04:48,080
我们不能只设置一个变量来--
We can't just set one variable to--

1179
01:04:48,080 --> 01:04:53,690
基本上 在这种情况下几乎像一个动态数组 或者更确切地说是一个链表 
basically, almost like a dynamic array in this case, or a linked list rather.

1180
01:04:53,690 --> 01:04:55,844
我们要用这张桌子来容纳他们 
We're going to use this table just to hold them.

1181
01:04:55,844 --> 01:04:57,260
我们不会给他们钥匙的 
We're not going to give them keys.

1182
01:04:57,260 --> 01:04:59,270
我们只需像我们所做的那样插入它们
We're just going to insert them like we would

1183
01:04:59,270 --> 01:05:03,830
例如 只需像在Python中那样使用链接列表即可 
do with just a linked list like in Python, for example.

1184
01:05:03,830 --> 01:05:07,880
我们要继续前进 我们需要什么
We're going to go ahead, and what do we need

1185
01:05:07,880 --> 01:05:13,295
如果我们想让它们在一段时间后产卵怎么办？
to do if we want to have them spawn after a certain period of time?

1186
01:05:17,030 --> 01:05:19,000
可能想要一个计时器 
Probably want to have some sort of timer.

1187
01:05:19,000 --> 01:05:21,410
我们想要记录已经过去了多少时间 
We want to keep track of how much time has passed,

1188
01:05:21,410 --> 01:05:23,720
也许会有一些时间
and maybe have some sort of amount of time

1189
01:05:23,720 --> 01:05:26,340
那是我们产生烟斗的触发点 
that's our trigger to spawn of a pipe.

1190
01:05:26,340 --> 01:05:28,290
比方说大概两秒钟 
Let's say maybe 2 seconds.

1191
01:05:28,290 --> 01:05:32,700
所以如果我们将计时器设置为0 它就从0开始 
So if we set a timer to 0, it's just start just at 0,

1192
01:05:32,700 --> 01:05:35,390
但我们可以一帧一帧地添加 
but we can add to this frame by frame.

1193
01:05:35,390 --> 01:05:40,370
我们可以将计时器增加增量时间 无论是什么 逐帧增加 
We can just increase this timer by delta time, whatever that is, frame by frame.

1194
01:05:40,370 --> 01:05:42,560
大概是1/60秒 
It'll be about 1/60 of a second.

1195
01:05:42,560 --> 01:05:47,600
因此 在60帧之后 我们将有一秒钟的时间 
So after 60 frames have passed, we'll get one second.

1196
01:05:47,600 --> 01:05:50,480
在120帧之后 我们将有两秒钟的时间 
After 120 frames have passed, we'll have two seconds.

1197
01:05:50,480 --> 01:05:54,180
在这一点上 我们可以决定好了 现在是时候产生一个新的管道了 
At that point, we can then decide OK, now it's time to spawn a new pipe.

1198
01:05:54,180 --> 01:05:56,100
让我们继续做这件事吧 
Let's go ahead and do that.

1199
01:05:56,100 --> 01:06:06,780
因此 我将继续 在我们的更新功能中 
So I'm going to go ahead, and in our update function,

1200
01:06:06,780 --> 01:06:12,900
我们希望处理此计时器的实际增加 
we want to handle the actual increasing of this timer.

1201
01:06:12,900 --> 01:06:16,290
所以这很简单--
So it's as simple as--

1202
01:06:16,290 --> 01:06:18,915
我确定我把它叫做spawnTimer 
and I make sure that I called it spawnTimer.

1203
01:06:18,915 --> 01:06:20,130
不 我只是叫它定时器 
No, I just called it timer.

1204
01:06:20,130 --> 01:06:21,755
让我们继续 并将其命名为spawnTimer 
Let's go ahead, and call it spawnTimer.

1205
01:06:21,755 --> 01:06:24,670
更具体一点 我们想要什么 
Be a little more specific about what we want here.

1206
01:06:24,670 --> 01:06:25,702
所以我们的spawnTimer 
So our spawnTimer.

1207
01:06:25,702 --> 01:06:27,660
然后我们将继续更新 
And then we're going to go ahead in our update,

1208
01:06:27,660 --> 01:06:34,740
并将spawnTimer设置为等于spawnTimer加上增量时间 
and set spawnTimer equal to spawnTimer plus delta time.

1209
01:06:34,740 --> 01:06:39,390
然后我们需要做的就是检查
And then what we need to do is then check

1210
01:06:39,390 --> 01:06:42,277
我们的产卵计时器是否大于--因为它
is our spawn timer greater than-- because it

1211
01:06:42,277 --> 01:06:44,610
以秒为单位跟踪时间 增量时间将为您提供
keeps track of time in seconds, delta time will give you

1212
01:06:44,610 --> 01:06:45,990
以秒为单位的分数 
a fractional amount in seconds.

1213
01:06:45,990 --> 01:06:49,510
所以它将在0.013 或类似的地方 
So it will be at 0.013, or something like that.

1214
01:06:49,510 --> 01:06:54,120
我们希望跟踪spawnTimer是否已经过了两点 对吗？
We want to keep track of whether spawnTimer has gone past two, right?

1215
01:06:54,120 --> 01:07:02,580
因此 如果spawnTimer大于2 我们希望添加一个新管道 
So if spawnTimer is greater than 2, we want to add a new pipe.

1216
01:07:02,580 --> 01:07:05,840
有人记得Lua中如何添加到表中的函数吗？
Does anybody remember the function for how to add to a table in Lua?

1217
01:07:09,450 --> 01:07:12,520
所以它是桌子 插入 
So it's table.insert.

1218
01:07:12,520 --> 01:07:15,600
因此 Table.Insert将接受一个表 
So table.insert will take in a table.

1219
01:07:15,600 --> 01:07:19,770
因此 在本例中 我们需要前面分配的管道表 
So in this case, we want the pipes table that we allocated before.

1220
01:07:19,770 --> 01:07:23,450
然后我们要放入一个新的管道对象 
And then we're going to put in a new pipe object.

1221
01:07:23,450 --> 01:07:27,040
这就是为调用实例化对象的方式 圆括号 
This is how you instantiate an object for call, parentheses.

1222
01:07:27,040 --> 01:07:29,480
这将对我们现在的管道产生影响
That will have the effect of now our pipes

1223
01:07:29,480 --> 01:07:33,094
表将--每次我们调用它时 它都会得到一个新的索引 
table is going to-- every time we call this, it's going to get a new index.

1224
01:07:33,094 --> 01:07:34,260
所以它将从1开始 
So it's going to start at 1.

1225
01:07:34,260 --> 01:07:37,222
LUA表的索引值为1 
Lua tables are indexed at 1.

1226
01:07:37,222 --> 01:07:39,320
第一次发生这种情况时 index1将
The first time it happens, index1 is going

1227
01:07:39,320 --> 01:07:42,810
等于将要启动的新管道对象
to be equal to a new pipe object, which is going to start

1228
01:07:42,810 --> 01:07:45,530
它的XY在屏幕的边缘 
its xy at the edge of the screen.

1229
01:07:45,530 --> 01:07:49,430
那么index2将是完全相同的东西 一个新的管道
Then index2 will be the exact same thing, a new pipe that's

1230
01:07:49,430 --> 01:07:52,370
在屏幕的边缘 诸如此类 每次我们
at the edge of the screen, and so on, and so forth every time we

1231
01:07:52,370 --> 01:07:53,540
调用表 插入 
call table.insert.

1232
01:07:56,180 --> 01:07:59,750
一旦我们的产卵计时器超过2 如果我们不想这样做
Once our spawn Timer has exceeded 2, if we want this to not

1233
01:07:59,750 --> 01:08:06,020
之后每一帧都会产生一根烟斗 很快就会堵塞我们的世界 
spawn a pipe every frame here after, which would quickly clog up our world,

1234
01:08:06,020 --> 01:08:07,880
我们希望将产卵计时器重置为0 
we want to reset our spawn timer to 0.

1235
01:08:07,880 --> 01:08:11,360
所以这将产生现在的效果 它将再等待2秒 
So this will have the effect of now, it's going to wait another 2 seconds,

1236
01:08:11,360 --> 01:08:13,457
然后这个条件将再次成为真的 
and then this condition will be true again,

1237
01:08:13,457 --> 01:08:15,290
然后我们可以在场景中添加一个新的管道 
and then we can add a new pipe to the scene.

1238
01:08:19,180 --> 01:08:23,654
让我们继续来看看--
Let's go ahead and look at--

1239
01:08:23,654 --> 01:08:29,240
我们需要在这里添加一组新的逻辑 
we're going to need to add a new set of logic here.

1240
01:08:29,240 --> 01:08:39,040
事实上 我会把所有这些放在鸟的上面 更新 
Actually, I'm going to put all of this above the bird.update,

1241
01:08:39,040 --> 01:08:42,119
然后在这下面 我将继续 并做--
and then below that, I'm going to go ahead, and do--

1242
01:08:42,119 --> 01:08:43,910
我不确定我们是否已经谈到这一点 
I'm not sure if we've covered this already.

1243
01:08:43,910 --> 01:08:46,835
我不认为我们有 但如果我们想迭代一个表 
I don't think we have, but if we want to iterate over a table,

1244
01:08:46,835 --> 01:08:48,960
Lua给了你一个叫做Pair的函数 
there's a function that Lua gives you called pairs.

1245
01:08:48,960 --> 01:08:52,750
它将为您提供表的所有键值对
It will give you all the key value pairs of a table

1246
01:08:52,750 --> 01:08:55,149
然后您可以在迭代它时使用它 
that you can then use while you're iterating over it.

1247
01:08:55,149 --> 01:08:57,700
类似于在Python中枚举 如果熟悉 
Similar to enumerate in Python, if familiar,

1248
01:08:57,700 --> 01:09:02,120
不过 这实际上会给你提供关键字 而不仅仅是索引 
except this will actually give you the keys rather than just the indices.

1249
01:09:02,120 --> 01:09:11,890
所以我们可以对k做 成对的管道做一些主体代码 
So we can do for k, pipe in pairs of pipes do some body of code,

1250
01:09:11,890 --> 01:09:14,890
然后我们可以访问密钥和其中的管道 
and then we have access to the key and the pipe within this.

1251
01:09:14,890 --> 01:09:17,510
我们可以只迭代它 并使用它 
We can just iterate over it, and use it.

1252
01:09:17,510 --> 01:09:20,580
因此 我们要做的第一件事是更新管道 
So the first thing we want to do is we want to update our pipe.

1253
01:09:20,580 --> 01:09:22,330
因此 对于每个管道 更新它 
So for each pipe, update it.

1254
01:09:22,330 --> 01:09:26,770
为其指定当前帧的增量时间 
Give it the delta time of the current frame.

1255
01:09:26,770 --> 01:09:28,929
那么另一个重要的特点是什么呢？
And then what was the other important feature?

1256
01:09:28,929 --> 01:09:30,970
因此 这将具有滚动它的效果 
So this will have the effect of scrolling it now.

1257
01:09:30,970 --> 01:09:33,370
它会把它的x移位 但是
It's going to get its x shifted, but what

1258
01:09:33,370 --> 01:09:36,861
我们需要对场景中的每一根烟斗做的另一件重要的事情是吗？
was the other important thing we needed to do with every pipe in our scene?

1259
01:09:36,861 --> 01:09:42,410
观众：当x小于0时 我们必须[INAUDIBLE]
AUDIENCE: When x is less than 0, we have to [INAUDIBLE]

1260
01:09:42,410 --> 01:09:44,090
科尔顿·奥格登：是的 
COLTON OGDEN: Yes.

1261
01:09:44,090 --> 01:09:45,600
这完全是真的 
That is exactly true.

1262
01:09:45,600 --> 01:09:50,680
所以我们要做的是 如果pipe.x小于--
So what we're going to do is if pipe.x is less than--

1263
01:09:50,680 --> 01:09:55,331
如果我们做的小于0 我们认为会发生什么？
so if we did less than 0, what do we think would happen?

1264
01:09:55,331 --> 01:09:58,850
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1265
01:09:58,850 --> 01:10:01,940
科尔顿·奥格登：我们会看到它立即消失 因为他们
COLTON OGDEN: We would see it instantly disappear because they're

1266
01:10:01,940 --> 01:10:03,590
根据左上角的坐标 
based on the top left coordinates.

1267
01:10:03,590 --> 01:10:07,830
所以我们需要做的就是跟踪它的宽度 
So what we need to do is keep track of its width.

1268
01:10:07,830 --> 01:10:09,980
所以我们要做的就是说如果pipe.x
So what we'll do is we'll just say if pipe.x

1269
01:10:09,980 --> 01:10:15,500
小于负数pipe.width 这将允许管道
is less than negative pipe.width, which will allow the pipe

1270
01:10:15,500 --> 01:10:19,860
要一直穿过屏幕的边缘 
to go all the way past the edge of the screen,

1271
01:10:19,860 --> 01:10:23,450
我们将调用一个名为Table.Remove的函数 该函数接受一个表 
we'll call a function called table.remove, which takes a table,

1272
01:10:23,450 --> 01:10:26,600
在这种情况下 管道 然后它需要一把钥匙 
in this case, pipes, and then it takes a key.

1273
01:10:26,600 --> 01:10:29,480
以及我们可以在124号线上获得的密钥 
And the key we have access to up above on line 124.

1274
01:10:29,480 --> 01:10:32,090
我们可以只说k 这会产生这样的效果
We can just say k, and that will have the effect

1275
01:10:32,090 --> 01:10:36,560
把那根烟斗从现场移走 
of removing that pipe from the scene.

1276
01:10:36,560 --> 01:10:40,370
一旦做完了 我们就可以走了 
And then as soon as that's done, we're good to go.

1277
01:10:40,370 --> 01:10:42,817
我们现在最不需要做的就是 
The last thing that we need to do is currently,

1278
01:10:42,817 --> 01:10:44,900
我们实际上并没有将管道绘制到屏幕上 
we're not actually drawing the pipe to the screen.

1279
01:10:44,900 --> 01:10:50,750
所以在下面的渲染函数中 我们将继续 并在上面--
So down below in our render function, we're going to go ahead, and up above--

1280
01:10:50,750 --> 01:10:55,310
在我们做地面之前 因为如果我们正常地做--
before we do the ground, because if we do it normally--

1281
01:10:55,310 --> 01:10:57,764
如果我们在铺好地面后再做 这些管道
if we do it after we render the ground, the pipes

1282
01:10:57,764 --> 01:11:00,680
看起来就像是层叠在地面上 
are going look like they're just kind of layered on top of the ground.

1283
01:11:00,680 --> 01:11:03,620
我们希望它看起来像是从地面上伸出来的 
We want it to look as if they're sticking out from the ground.

1284
01:11:03,620 --> 01:11:06,830
所以我们想要做的是有一个正确的渲染层 
So what we want to do is have a correct render layer,

1285
01:11:06,830 --> 01:11:08,780
将绘制顺序渲染到屏幕 
a render draw order to the screen.

1286
01:11:08,780 --> 01:11:11,810
我们画背景 画管子 然后画地面 
We draw the background, we draw the pipes, then we draw the ground,

1287
01:11:11,810 --> 01:11:14,120
这将产生管道看起来像是伸出的效果
and this will have the effect of looking as if the pipes are sticking out

1288
01:11:14,120 --> 01:11:15,140
在地面上 
of the ground.

1289
01:11:15,140 --> 01:11:18,170
所以我们要做的就是和刚才做的完全一样
So what we'll do is we'll do the exact same thing we just did up

1290
01:11:18,170 --> 01:11:31,050
上面通过说for k 管道成对地做管道 
above by saying for k, pipe in pairs of pipes do pipe,

1291
01:11:31,050 --> 01:11:33,480
然后是我们在PIPE中定义的呈现函数 
and then the render function that we defined in pipe.

1292
01:11:33,480 --> 01:11:35,230
这将产生迭代的效果
And this will have the effect of iterating

1293
01:11:35,230 --> 01:11:37,530
通过我们场景中所有的管道 每个抽签电话 
through all the pipes in our scene every draw call,

1294
01:11:37,530 --> 01:11:41,160
在它画地面之前画它们 在它画鸟之前 
and drawing them before it draws the ground, and before it draws the bird,

1295
01:11:41,160 --> 01:11:44,534
这应该就是我们所需要的 来说明这个例子 
and that should be all that we need to illustrate this example.

1296
01:11:44,534 --> 01:11:46,075
让我确保所有东西都保存好了 
Let me make sure everything is saved.

1297
01:11:46,075 --> 01:11:50,660
我要继续往前走 走进鸟巢 
I'm going to go ahead, and go into bird5.

1298
01:11:50,660 --> 01:11:56,610
如果我做的每件事都是正确的 那么在一段时间之后 
If I did everything correctly, this should, after a certain period of time,

1299
01:11:56,610 --> 01:11:59,820
将正在滚动的管道放到屏幕上 它们是随机的 
drop pipes to the screen that are scrolling, and they're randomized.

1300
01:11:59,820 --> 01:12:02,760
它们的y值被设置为某个值
Their y value is getting set to some value

1301
01:12:02,760 --> 01:12:05,610
在屏幕顶部的四分之一之间 
between the top quarter of the screen.

1302
01:12:05,610 --> 01:12:09,190
所以从Flappy Bird现在的位置开始 向下
So starting about right where Flappy Bird is right now, down

1303
01:12:09,190 --> 01:12:12,017
大约10个像素以上的屏幕宽度 这实际上 
about 10 pixels above the width of the screen, which actually,

1304
01:12:12,017 --> 01:12:13,350
这看起来像是10个像素以上 
that looks like 10 pixels above.

1305
01:12:13,350 --> 01:12:14,570
所以这是一个小小的漏洞 
So that's a slight bug.

1306
01:12:14,570 --> 01:12:18,030
它可能应该在30或40左右 
It should probably be something along the lines of 30 or 40.

1307
01:12:18,030 --> 01:12:19,890
我们不会在最终发行版中遇到这种情况
We won't encounter that in the final distro

1308
01:12:19,890 --> 01:12:22,980
因为它们不会产卵那么低 
because they're not set to spawn that low,

1309
01:12:22,980 --> 01:12:27,510
但是你可以看到这在某种程度上是我们程序层面的开始
but you can see how this is sort of the beginning of our procedural level

1310
01:12:27,510 --> 01:12:31,480
生成系统 我们拥有场景的几乎所有组件 
generation system, and we have most all the components of our scene.

1311
01:12:31,480 --> 01:12:35,040
现在 在Flappy Bird中 我们通常有两个管子 
Now, normally in Flappy Bird, we have two pipes.

1312
01:12:35,040 --> 01:12:38,730
我们在上面有一根管道 然后在下面有一根管道 
We have a pipe that's above, and then a pipe that's below,

1313
01:12:38,730 --> 01:12:39,666
他们是成对的 
and they're in pairs.

1314
01:12:39,666 --> 01:12:42,540
在下一个例子中 我们实际上将开始说明这一点 
In the next example, we're actually going to start illustrating this.

1315
01:12:42,540 --> 01:12:45,360
我们将有几对连接在一起的管子 
We're going to have pairs of pipes that are joined together,

1316
01:12:45,360 --> 01:12:46,620
它们一起滚动 
which scroll together.

1317
01:12:46,620 --> 01:12:51,240
一旦你飞过它们 你就得了一分 
That once you fly through them, you score a point.

1318
01:12:51,240 --> 01:12:53,130
但就目前而言 我们拥有我们所有的碎片
But for now, we have all the pieces that we

1319
01:12:53,130 --> 01:13:00,310
需要有基本的视觉感才能完成游戏 
need in order to have the basic visual sense of the game completed.

1320
01:13:00,310 --> 01:13:04,450
我们现在休息五分钟 等我们回来后 
We're going to take like a five minute break now, and then once we come back,

1321
01:13:04,450 --> 01:13:07,850
我们将深入研究如何将成对的管道引入我们的场景中 
we'll actually dive into how we can get pairs of pipes into our scene,

1322
01:13:07,850 --> 01:13:10,790
开始打球 做一些其他有趣的事情 比如音乐 
and start getting into scoring, and some other fun things like music.

1323
01:13:14,050 --> 01:13:15,250
好了 欢迎回来 
All right, welcome back.

1324
01:13:15,250 --> 01:13:16,600
所以下一部分--
So the next part--

1325
01:13:16,600 --> 01:13:20,790
所以在我们确定鸟的背景和管子之前 
so before we establish the bird, the background, the pipes,

1326
01:13:20,790 --> 01:13:23,940
我们已经准备好了比赛的所有视觉方面 
we have all the visual aspects of our game ready to go.

1327
01:13:23,940 --> 01:13:26,190
真正要解决的下一个重要问题是
The next important piece of the puzzle to really solve

1328
01:13:26,190 --> 01:13:29,550
我们怎么才能开始得分 我们怎么才能
is how can we start scoring our game, and also how can we

1329
01:13:29,550 --> 01:13:33,330
让管道与它们在实际游戏中实现的方式相匹配？
get the pipes matching the way that they're implemented in the actual game?

1330
01:13:33,330 --> 01:13:38,430
回想一下 它们通常是成对的 如图所示 
Which, recall, they're normally in pairs, as illustrated here.

1331
01:13:38,430 --> 01:13:41,430
我们也看到在右手边 正如我们到目前为止已经介绍过的那样 
And we also see on the right-hand side, as we've covered already so far,

1332
01:13:41,430 --> 01:13:44,130
我们有放烟斗的产卵区 在左边 
we have the spawn zone for our pipes, and on the left,

1333
01:13:44,130 --> 01:13:46,050
我们有我所说的死亡区 在那里
we have what I've labeled the dead zone, where

1334
01:13:46,050 --> 01:13:49,980
管道一旦消失就被取消实例化
pipes are de-instantiated once they've gone

1335
01:13:49,980 --> 01:13:52,410
越过了它们自身的负宽度 
past the negative width of themselves.

1336
01:13:52,410 --> 01:13:55,380
但管子是成对的 他们会被移位 
But pipes come in pairs, they get shifted,

1337
01:13:55,380 --> 01:13:58,941
一旦鸟儿在这些缝隙之间飞翔 
and once the bird flies between these gaps,

1338
01:13:58,941 --> 01:14:00,690
最终是当他们得到一分的时候 
is ultimately when they've scored a point.

1339
01:14:00,690 --> 01:14:07,620
因此 我们需要一种将管道配对在一起的方法 并定义这种逻辑
And so we need a way to pair pipes together, and define this logic for how

1340
01:14:07,620 --> 01:14:11,010
我们能说出这只鸟是否已经越过了缺口 
can we tell whether the bird has gone past the gap,

1341
01:14:11,010 --> 01:14:14,500
以及管道是否已被取消实例化 
and whether or not the pipes have been de-instantiated.

1342
01:14:14,500 --> 01:14:17,760
所以我们要继续下去 我可能会
So we're going to go ahead, and I'm going to probably

1343
01:14:17,760 --> 01:14:20,760
停止对其余演示进行实时编码
stop live coding for the rest of the demonstrations

1344
01:14:20,760 --> 01:14:23,730
因为它们会变得更复杂一些 
because they're going to be a little bit more complex.

1345
01:14:23,730 --> 01:14:28,190
但我相信我的代码编辑器在这里 
But I believe my code editor is over here.

1346
01:14:28,190 --> 01:14:30,690
我要继续 然后打开--
I'm going to go ahead, and open up--

1347
01:14:30,690 --> 01:14:32,680
哦 这是我的另一位编辑 
oh, this is my other editor.

1348
01:14:32,680 --> 01:14:37,030
现在 在基本回购中 我们将继续 并查看完整的示例 
So in the base repo now, we're going to go ahead, and look at the full example.

1349
01:14:37,030 --> 01:14:40,930
所以在Bird6中 这是管子对的更新--
So in bird6, which is the pipe pair update--

1350
01:14:40,930 --> 01:14:44,440
我们现在看到的子文件夹--
our current subfolder that we're looking at--

1351
01:14:44,440 --> 01:14:45,660
我们要从美因河开始 
we're going to start in main.

1352
01:14:45,660 --> 01:14:51,390
所以在Main的第33行 
So on line 33 in main.

1353
01:14:51,390 --> 01:14:53,820
我们可以看到我们正在获取管道对 它
We can see that we're acquiring pipe pair, which

1354
01:14:53,820 --> 01:14:55,440
是我们正在定义的一个新类别 
is a new class we're defining.

1355
01:14:55,440 --> 01:14:58,350
我们要用以前用过的管子 
We're taking the pipe that we had before,

1356
01:14:58,350 --> 01:15:00,500
我们正在创建一个新的复合类 
and we're creating a new composite class.

1357
01:15:00,500 --> 01:15:04,440
所以我们将获取一个将两个管道封装在一起的类 
So we're going to take a class that encapsulates two pipes together,

1358
01:15:04,440 --> 01:15:08,400
一对管道 我们将用它来更多地思考我们的问题
a pair of pipes, and we're going to use this to think about our problem more

1359
01:15:08,400 --> 01:15:10,050
比我们已经拥有的更抽象 
abstractly than we already are.

1360
01:15:10,050 --> 01:15:13,669
这种抽象的分层是一个非常重要的概念
And this layering of abstractions is a very important concept

1361
01:15:13,669 --> 01:15:15,960
在计算机科学中 一般说来 但特别是
in computer science, generally speaking, but especially

1362
01:15:15,960 --> 01:15:19,470
在游戏中 您可能拥有由以下对象组合而成的对象
in games where you might have objects that are composites of objects that

1363
01:15:19,470 --> 01:15:22,350
是对象的组合 而这些抽象层次结构是
are composites of objects, and these abstract hierarchies are

1364
01:15:22,350 --> 01:15:24,600
是什么让程序员在处理事务时保持理智
sort of what keeps programmers sane when dealing

1365
01:15:24,600 --> 01:15:28,800
当你有数千行代码时 有这么多级别的代码 
with such large levels of-- when you have thousands of lines of code,

1366
01:15:28,800 --> 01:15:32,550
这是你真正理解它的唯一方法 
it's sort of the only way you can really make sense of it.

1367
01:15:32,550 --> 01:15:35,430
所以在第65行 如果我们看--
So on line 65, if we look--

1368
01:15:35,430 --> 01:15:39,060
现在 我们将其重命名为管道对 而不是称为管道的表 
now, instead of a table that's called pipes, we've renamed it to pipe pairs.

1369
01:15:39,060 --> 01:15:41,670
我们不再在场景中存储单个管道 
We're no longer going to store individual pipes in our scene.

1370
01:15:41,670 --> 01:15:44,100
我们要把这些管子对 我们
We're going to take these pipe pairs that we're

1371
01:15:44,100 --> 01:15:51,270
我要创建它们 并将它们存储在我们的表中以及单个单元中 
going to create, and store them in our table as well as individual units.

1372
01:15:51,270 --> 01:15:56,390
在第71行 我们需要一个变量来跟踪--
On line 71, we need a variable to keep track of the--

1373
01:15:56,390 --> 01:15:58,500
我们把它叫做最后一年 
we're calling it last y.

1374
01:15:58,500 --> 01:16:00,930
此变量的用途是为了让我们
The purpose of this variable is so that we

1375
01:16:00,930 --> 01:16:04,620
可以跟踪最后一组管道产生缺口的位置 
can keep track of where the last set of pipes spawned their gap.

1376
01:16:04,620 --> 01:16:08,060
因为如果我们让我们的差距完全随机的话 
Because if we made our gaps completely random,

1377
01:16:08,060 --> 01:16:12,840
它将产生一种效果 看起来不像是连续的 
it will have the effect of not looking continuous for one,

1378
01:16:12,840 --> 01:16:15,450
也有可能是无法击败的 
and also potentially being impossible to beat.

1379
01:16:15,450 --> 01:16:19,580
我们想要一些光滑的轮廓来填补我们的缝隙
We want some sort of smooth contour to our gaps

1380
01:16:19,580 --> 01:16:21,640
这样我们才能合理地飞越它们 
so that we can fly through them reasonably,

1381
01:16:21,640 --> 01:16:24,810
而且它看起来几乎是预制的 而且很光滑 
and that it looks as if it was almost pre-made, and smooth.

1382
01:16:24,810 --> 01:16:27,270
所以我们将跟踪一个名为last y的变量 
So we're going to keep track of a variable called last y.

1383
01:16:27,270 --> 01:16:30,180
我们要从负管高开始 
We're going to start it off at negative pipe height.

1384
01:16:30,180 --> 01:16:37,830
超出屏幕顶部 加上介于1和80之间的某个值
So up past the top of the screen, plus some sort of value between 1 and 80

1385
01:16:37,830 --> 01:16:39,030
和20岁 
and 20.

1386
01:16:39,030 --> 01:16:42,340
它将大致位于屏幕的顶部 
It's going to be roughly towards the top of the screen.

1387
01:16:42,340 --> 01:16:45,900
这一点很重要 因为最后一个y是
And this is important because the last y is

1388
01:16:45,900 --> 01:16:49,976
我们将会--我们将会翻转我们的雪碧 
going to be-- we're going to end up flipping our sprite.

1389
01:16:49,976 --> 01:16:55,020
在y轴上翻转的结果是精灵看起来
A flip on the y-axis has the result of the sprite looking

1390
01:16:55,020 --> 01:16:59,580
就好像它的整个高度都超过了实际的y 
as if it's gone its whole height above where its actual y is,

1391
01:16:59,580 --> 01:17:02,400
我们稍后会详细解释为什么
and we'll see in more detail, shortly, why

1392
01:17:02,400 --> 01:17:05,690
这最终会以它的方式工作 
this ends up working the way it does.

1393
01:17:05,690 --> 01:17:15,150
我们要下到132行 在我们的条件下 
We're going to go down to line 132, and in our condition,

1394
01:17:15,150 --> 01:17:20,220
如果我们的spawnTimer大于2 我们要做的是
if our spawnTimer is greater than 2, what we're going to do

1395
01:17:20,220 --> 01:17:22,830
这是我们之前制作管道的地方
is this is where we spawned our pipes before,

1396
01:17:22,830 --> 01:17:26,070
但现在我们正在生产成对的管道 
but now we're spawning pairs of pipes.

1397
01:17:26,070 --> 01:17:29,460
所以我们要设置一个局部变量y 
So we're going to set a local variable y.

1398
01:17:29,460 --> 01:17:31,230
这将是-
It's going to be--

1399
01:17:31,230 --> 01:17:34,050
这是我们上周讲过的夹钳操作
this is the clamp operation that we talked about last week

1400
01:17:34,050 --> 01:17:38,730
使用math.max和math.min来应用某种操作 
using math.max and math.min to apply some sort of operation.

1401
01:17:38,730 --> 01:17:42,060
在本例中 我们将在负20之间添加一个随机值
In this case, we're going to add a random value between negative 20

1402
01:17:42,060 --> 01:17:44,850
20的y值 
and 20 to whatever our last y value was, which

1403
01:17:44,850 --> 01:17:49,690
将有效地将间隙移动负20或20个像素 
is going to shift the gap effectively by negative 20 or 20 pixels.

1404
01:17:49,690 --> 01:17:52,530
我们要把它夹在负管道高度加10之间 
We're going to clamp it between negative pipe height plus 10.

1405
01:17:52,530 --> 01:17:56,100
离屏幕顶部大约10个像素 
So about 10 pixels from the top of the screen,

1406
01:17:56,100 --> 01:18:02,520
然后我们将上限设为虚高减90
and then we're going to set the upper bound to virtual height minus 90

1407
01:18:02,520 --> 01:18:03,420
减去管道高度 
minus pipe height.

1408
01:18:03,420 --> 01:18:07,800
这个负管光只是因为我们在做翻转操作
And this minus pipe light is only because we're doing a flip operation

1409
01:18:07,800 --> 01:18:09,750
在我们的精灵的y轴上 
on our y-axis for our sprite.

1410
01:18:09,750 --> 01:18:11,850
我会更详细地讲
I'll go into it in a little bit more detail

1411
01:18:11,850 --> 01:18:14,880
来解释我们为什么要这么做
to try to make it clear as to why we're doing it,

1412
01:18:14,880 --> 01:18:17,760
也许我会拿出一些代码来说明它的样子
and maybe I'll take out some codes to illustrate what it looks

1413
01:18:17,760 --> 01:18:20,190
就像没有那个操作一样 
like without that operation applied.

1414
01:18:20,190 --> 01:18:23,400
但基本上 它有从底部90像素的效果
But basically, it has the effect of 90 pixels from the bottom

1415
01:18:23,400 --> 01:18:26,550
是鸿沟产生的地方
is where the gap could spawn.

1416
01:18:26,550 --> 01:18:29,540
基本上 就是最底下的管子 
So basically, the pipe at the very bottom.

1417
01:18:29,540 --> 01:18:31,600
回想一下 这个差距就是--
Recall that this gap is where--

1418
01:18:31,600 --> 01:18:35,370
该值是间隙本身开始的位置 不一定
this value is where the gap itself begins, not necessarily

1419
01:18:35,370 --> 01:18:38,680
管道的起点
where the pipe starts.

1420
01:18:38,680 --> 01:18:42,690
它会在负管道高度加10之间 
It'll be between negative pipe height plus 10.

1421
01:18:42,690 --> 01:18:47,820
基本上 有效地 在屏幕顶部的10个像素之间 
Basically, effectively, between 10 pixels from the top of the screen,

1422
01:18:47,820 --> 01:18:50,560
在距离屏幕底部90个像素之间 
between 90 pixels from the bottom of the screen,

1423
01:18:50,560 --> 01:18:55,530
然后我们将应用这个值的随机排列 
and then we're going to apply a random permutation of this value.

1424
01:18:55,530 --> 01:18:58,590
我们要在负20和20之间加上一个值 
We're going to add some value between negative 20 and 20,

1425
01:18:58,590 --> 01:19:03,000
这将给我们一个等高线 这将是一个随机的等高线 
and that will give us a contour, and it'll be a randomized contour.

1426
01:19:06,540 --> 01:19:09,960
136线 我们有一对管子 
Line 136, we have pipe pairs.

1427
01:19:09,960 --> 01:19:14,070
将桌子插入其中 而不是管道 我们只是添加了一个新管道对 
Table insert into that instead of pipes, and we're just adding a new pipe pair,

1428
01:19:14,070 --> 01:19:18,030
我们将它设置为y的值 
and we're setting it to the value y.

1429
01:19:18,030 --> 01:19:21,820
然后管子对接受y值 
And then the pipe pair takes in a y value,

1430
01:19:21,820 --> 01:19:23,930
而这将是差距的起点 
and that will be where the start of the gap is.

1431
01:19:23,930 --> 01:19:25,980
以及这将会产生什么效果
And what this will have the effect of doing

1432
01:19:25,980 --> 01:19:29,790
它是不是要把一个精灵翻转到缺口上方
is it's going to flip a sprite above the gap

1433
01:19:29,790 --> 01:19:32,880
所以我们在缝隙开始处的正上方有一根管道 然后它
so that we have a pipe right above where the gap starts, and then it's

1434
01:19:32,880 --> 01:19:37,380
要绘制另一个管道 在该管道下方约90个像素处未翻转 
going to draw another pipe unflipped about 90 pixels below that,

1435
01:19:37,380 --> 01:19:39,735
这将是它将两者结合在一起的方式 
and that will be how it puts the two together.

1436
01:19:42,850 --> 01:19:49,380
第144行是一个循环 它只更新我们的对 而不是我们的管道 
Line 144 is a loop that just updates our pairs instead of our pipes.

1437
01:19:49,380 --> 01:19:55,110
因此 我们在这里所做的只是将其从管道重命名为对 而不是
So all we've done here is just renamed it from pipe to pair, and instead

1438
01:19:55,110 --> 01:19:57,030
在管道中 我们使用管道对 
of pipes, we're using pipe pairs.

1439
01:19:57,030 --> 01:20:01,390
在第153行 我们正在做同样的事情 
We are doing the same exact thing here on line 153.

1440
01:20:01,390 --> 01:20:05,490
我们已经做了k对成对的管子 
We've done for k pair in pairs of pipe pairs.

1441
01:20:05,490 --> 01:20:08,310
然后是150行--
And then line 150--

1442
01:20:08,310 --> 01:20:12,210
抱歉 175线是我们现在的位置--
sorry, line 175 is where we are--

1443
01:20:12,210 --> 01:20:17,790
抱歉 170是我们渲染每对而不是每个管道的位置 
sorry, 170 is where we are rendering each pair instead of each pipe.

1444
01:20:17,790 --> 01:20:22,980
所以如果我们在这里打开管子对 我们可以看看
And so if we open up pipe pair here, we can take a look

1445
01:20:22,980 --> 01:20:25,060
在这堂课上从头开始 
at this class from scratch.

1446
01:20:25,060 --> 01:20:26,700
所以这是一个新的班级 
So it's a new class.

1447
01:20:26,700 --> 01:20:29,122
我们要将间隙高度设置为90像素 
We're going to set our gap height to 90 pixels,

1448
01:20:29,122 --> 01:20:31,080
所以这只是一个任意值 我
and so this is just some arbitrary value that I

1449
01:20:31,080 --> 01:20:33,879
就大小而言 Feel是一个相当公平的价值 
felt was a pretty fair value in terms of size,

1450
01:20:33,879 --> 01:20:35,670
但你可以把它调到你想要的任何地方 
but you can tune this to whatever you want.

1451
01:20:35,670 --> 01:20:37,570
你可以把这个设置为--
You could set this to--

1452
01:20:37,570 --> 01:20:40,520
如果你真的想变得残酷 你可以把它设定在50左右 
if you want to be really cruel, you could set it to something like 50.

1453
01:20:40,520 --> 01:20:42,420
或者 如果你想对球员非常慷慨 
Or if you wanted to be really generous to the player,

1454
01:20:42,420 --> 01:20:44,430
你可以把它设置在150左右 然后
you could set it to something like 150, and make

1455
01:20:44,430 --> 01:20:46,410
对他们来说 这是相当容易的 
it fairly easy for them to get through.

1456
01:20:46,410 --> 01:20:50,430
或者作为作业的一部分 你可以随机化它
Or as part of the assignment, you could randomize it

1457
01:20:50,430 --> 01:20:54,420
所以它一对一对地变化 你会得到更多
so that it varies pair by pair, and you get more

1458
01:20:54,420 --> 01:20:56,445
看起来像是有机的障碍赛道 
of an organic looking obstacle course.

1459
01:20:56,445 --> 01:20:59,010
它仍然被移动了负20到20个像素 
It's still shifted by negative 20 to 20 pixels,

1460
01:20:59,010 --> 01:21:02,939
但现在你的差距是不同的 你也可以随机化移位量
but now your gap varies, and you can also randomize the shift amount

1461
01:21:02,939 --> 01:21:03,980
如果你也想的话 
if you wanted to as well.

1462
01:21:03,980 --> 01:21:05,460
假设你想要--
Let's say you wanted--

1463
01:21:05,460 --> 01:21:08,970
也许您希望间隔最大为40像素
maybe you want the gaps to be up to 40 pixels

1464
01:21:08,970 --> 01:21:11,190
差异而不是20个像素的差异
difference instead of 20 pixels difference

1465
01:21:11,190 --> 01:21:12,755
论负值和正值 
on negative and positive value.

1466
01:21:12,755 --> 01:21:14,130
你也可以很容易地做到这一点 
You could easily do that as well.

1467
01:21:16,840 --> 01:21:20,760
在第18行 我们只是将x设置为
On line 18 we're just setting our x to just like

1468
01:21:20,760 --> 01:21:23,010
我们以前做过 虚拟宽度加32 
we did before, virtual width plus 32.

1469
01:21:23,010 --> 01:21:24,990
所以我们将其设置为--
So we're setting it to the--

1470
01:21:24,990 --> 01:21:27,090
实际上 在我们将其设置为虚拟宽度之前 
actually, before we just set it to virtual width.

1471
01:21:27,090 --> 01:21:29,880
现在我们将其设置为虚拟宽度加32 
Now we're setting it to virtual width plus 32.

1472
01:21:29,880 --> 01:21:31,474
两者基本持平 
Both are pretty much equal.

1473
01:21:31,474 --> 01:21:33,390
这只会让它有一点延迟
This will just give it a little bit of a delay

1474
01:21:33,390 --> 01:21:36,780
在它最终出现在屏幕上之前 但你可以有效地
before it ends up going onto the screen, but you can effectively just

1475
01:21:36,780 --> 01:21:38,190
这样做 虚拟宽度 
do this, virtual width.

1476
01:21:41,680 --> 01:21:47,130
在下一行 24 这是我们捆绑在一起的地方
On the next line, 24, this is where we sort of bundled together

1477
01:21:47,130 --> 01:21:51,300
我们最终要渲染和更新的管道
the pipes that we're going to end up actually rendering and updating

1478
01:21:51,300 --> 01:21:52,100
传到屏幕上 
to the screen.

1479
01:21:52,100 --> 01:21:55,560
一对管道不是只有一根管道 而是两根管道 
Instead of having just one pipe, a pipe pair is two pipes.

1480
01:21:55,560 --> 01:21:58,090
我们可以很容易地把这些放在一张桌子里 
We can easily put this together in a table.

1481
01:21:58,090 --> 01:21:59,860
因此 我们将只创建self.pires 
So we'll just create self.pipes.

1482
01:21:59,860 --> 01:22:03,420
我们将它设置到一个有两个键的桌子上 上键和下键 
We'll set it to a table that has two keys, upper and lower,

1483
01:22:03,420 --> 01:22:06,390
上面的管子只是一根管子 
and the upper pipe is just a pipe.

1484
01:22:06,390 --> 01:22:08,490
请注意 管道有一点不同 
And notice one thing is different about pipe.

1485
01:22:08,490 --> 01:22:10,890
现在 以前 这是不需要争论的 
Now, before, it took no arguments.

1486
01:22:10,890 --> 01:22:12,180
这只是一根普通的烟斗 
It was just a regular pipe.

1487
01:22:12,180 --> 01:22:13,740
管道有其自身的逻辑 
Pipes had their own logic.

1488
01:22:13,740 --> 01:22:15,600
他们设置自己的x和y 
They set their own x and y.

1489
01:22:15,600 --> 01:22:19,620
除此之外 他们不需要任何形式的参数化 
They didn't need any sort of parametrization beyond that.

1490
01:22:19,620 --> 01:22:22,750
这一切都是随机为他们安排的 
It was all taken care of for them randomly.

1491
01:22:22,750 --> 01:22:24,910
现在 他们拿着一根绳子 
Now, they take a string.

1492
01:22:24,910 --> 01:22:28,140
这根顶线意味着这将是一根顶管 
So this top string means that this would be a top pipe.

1493
01:22:28,140 --> 01:22:30,330
也就是说 如果这根管子是顶层管子 
So that means that if this pipe is a top pipe,

1494
01:22:30,330 --> 01:22:33,840
在管道中可能会有逻辑 现在检查
there's probably going to be logic in pipe that now checks

1495
01:22:33,840 --> 01:22:35,940
看看它是顶部还是底部 
to see whether it's top or bottom.

1496
01:22:35,940 --> 01:22:39,180
如果它是顶部的 那么我们需要把它倒过来 
If it's top, then we need to render it upside down.

1497
01:22:39,180 --> 01:22:44,400
我们需要将其沿y轴翻转 然后将其设置为self.y 
We need to flip it along the y-axis, and then we're going to set it to self.y.

1498
01:22:47,160 --> 01:22:49,740
回想一下我们设置了self.y--
And recall that we set self.y--

1499
01:22:49,740 --> 01:22:52,510
我们在主航道通过了SELFY 
we passed in self.y in main.

1500
01:22:52,510 --> 01:22:54,390
实际上 我不确定我有没有提到这点 
Actually, I'm not sure if I touched on that.

1501
01:22:54,390 --> 01:22:56,770
让我们回到Main这里 
Let's go back to main here.

1502
01:22:56,770 --> 01:22:58,153
所以如果我们去--
So if we go to--

1503
01:23:02,320 --> 01:23:07,580
我需要找出我实际实例化管道的位置 
I need to figure out where I actually instantiate the pipes.

1504
01:23:07,580 --> 01:23:11,090
在第136行 在我们计算出
Here on line 136, after we've calculated where

1505
01:23:11,090 --> 01:23:13,220
我们希望这对管子的间隙是这样的 
we want the gap to be for this pipe pair,

1506
01:23:13,220 --> 01:23:18,170
我们继续往前 把一对管子插入 y处的管子 
we're going to go ahead, and insert into pipe pairs, a pipe pair at y.

1507
01:23:18,170 --> 01:23:24,950
计算的范围是--我们基本上取了最后一个y值 
Y was the calculation between-- we basically took the last y value,

1508
01:23:24,950 --> 01:23:29,570
我们实例化的最后一个间隙 然后将其移位了大约负20
the last gap that we instantiated, and then shifted it by some negative 20

1509
01:23:29,570 --> 01:23:33,500
随机调整到20个像素 并确保它不会超过或超过--
to 20 pixels randomly, and made sure it didn't go above or beyond--

1510
01:23:33,500 --> 01:23:35,150
屏幕边缘上方或下方 
above or below the edges of the screen.

1511
01:23:38,570 --> 01:23:45,770
回到管子对中 我们将继续 看一下第30行 
Back in pipe pair, we're going to go ahead, and look at line 30.

1512
01:23:45,770 --> 01:23:49,250
对不起 实际上让我们更仔细地看看这里
I'm sorry, actually let's take a look a little bit more closely here

1513
01:23:49,250 --> 01:23:50,840
在第26行 
at line 26.

1514
01:23:50,840 --> 01:23:53,360
所以上流社会就会变得自私自利 
So upper gets top and self.y.

1515
01:23:53,360 --> 01:23:59,250
这就是差距所在 而精灵将在这个值上进行翻转 
That's where the gap is, and the sprite is going to be flipped upon that value.

1516
01:23:59,250 --> 01:24:02,990
较低的价值将是这一点的转变 
The lower value is going to be a shift of that.

1517
01:24:02,990 --> 01:24:09,880
因此 较低的精灵需要在顶部管道下方以缝隙的数量繁殖
So the lower sprite needs to spawn below the top pipe by the gap amount

1518
01:24:09,880 --> 01:24:12,492
所以这两个是自上而下的 但在那里
so that the two are top to bottom, but there

1519
01:24:12,492 --> 01:24:14,450
需要是他们两个之间的空间 
needs to be that space between the two of them.

1520
01:24:14,450 --> 01:24:17,840
所以我们需要拿起那根管子 把它往下移 然后画下一根管子 
So we need to take that pipe, shift it down, and then draw the next pipe.

1521
01:24:17,840 --> 01:24:25,760
所以我们取自 Y加上管子高度加上间隙高度 
So we're going to take self.y plus pipe height plus gap height,

1522
01:24:25,760 --> 01:24:29,630
这会产生效果--记住 间隙高度是90像素 
and that'll have the effect-- remember, gap height was 90 pixels.

1523
01:24:29,630 --> 01:24:36,300
管道高度是翻转y轴的结果 
The pipe height is a result of flipping the y-axis,

1524
01:24:36,300 --> 01:24:41,160
不得不把它移到实际位置下 
and having to shift it down the actual position.

1525
01:24:41,160 --> 01:24:48,085
所以如果我们回到第30行 
So if we go back to line 30.

1526
01:24:51,241 --> 01:24:56,890
这是一个有趣的例子 说明了
This is an interesting illustration of what

1527
01:24:56,890 --> 01:25:00,072
当您在对表进行迭代时编辑表时发生 
happens when you edit a table while you're iterating over a table,

1528
01:25:00,072 --> 01:25:01,780
我很快就会向你们详细展示这一点 
and I'll show you this in detail shortly.

1529
01:25:01,780 --> 01:25:05,620
但基本上 在第30行 我们将一个名为Remove的标志设置为FALSE 
But basically, on line 30, we're setting a flag called remove to false.

1530
01:25:05,620 --> 01:25:09,170
我们要做的是在我们摧毁这些物体之前 
And what this is going to do is before we were just destroying the objects.

1531
01:25:09,170 --> 01:25:11,920
只要它越过屏幕的边缘 我们就把它毁了 
Whenever it got past the edge of the screen, we just destroyed it.

1532
01:25:11,920 --> 01:25:15,580
但如果我们迭代一个值表 
But if we're iterating over a table of values,

1533
01:25:15,580 --> 01:25:22,810
当您在大多数编程中执行删除操作时 让我们假设有一个管道对的表
let's say a table of pipe pairs, when you do a removal in most programming

1534
01:25:22,810 --> 01:25:28,870
语言--在Lua中 当您删除表值时 它没有索引 
language-- in Lua, when you do a removal of a table value, and it's not indexed,

1535
01:25:28,870 --> 01:25:33,640
或者它是无键的 这意味着它是通过数字索引进行索引的 
or it's non-keyed, which means that it's indexed by numerical indices,

1536
01:25:33,640 --> 01:25:36,470
这将使其他所有价值下降 
this will shift every other value down.

1537
01:25:36,470 --> 01:25:38,470
所以当你迭代它的时候 你移动
And so when you're iterating it, and you shift

1538
01:25:38,470 --> 01:25:41,530
一切下跌 你目前正在操纵的价值 
everything down, the value you are currently manipulating,

1539
01:25:41,530 --> 01:25:45,970
假设它等于1 如果去掉这个值 
let's say it's equal to 1, if you remove that value,

1540
01:25:45,970 --> 01:25:48,760
将它以外的所有内容都向下移动1 
you shift everything beyond it down by 1.

1541
01:25:48,760 --> 01:25:50,650
但然后你会递增到2 
But then you're going to increment up to 2,

1542
01:25:50,650 --> 01:25:55,510
您跳过了以前只有2个 现在是1个 
and you're skipping over what was previously just 2, and is now 1.

1543
01:25:55,510 --> 01:25:59,160
所以你实际上是跳过了你的一个条目 
So you're effectively skipping over one of your entries,

1544
01:25:59,160 --> 01:26:02,560
而且它在很多情况下都有错误行为 
and it has buggy behavior in a lot of scenarios.

1545
01:26:02,560 --> 01:26:06,070
在这种情况下 它会导致图形出现一点故障
In this case, it causes the graphics to glitch a little bit

1546
01:26:06,070 --> 01:26:10,090
因为它不在一帧上应用像素移位 
because it doesn't apply a pixel shift on one frame,

1547
01:26:10,090 --> 01:26:16,840
因此 每当一根管子被移除--我实际上可以直观地展示这一点 
and so whenever a pipe gets removed-- and I can actually show this visually,

1548
01:26:16,840 --> 01:26:20,292
移除该管道后留下的第一个管道
the first pipe left after that pipe gets removed

1549
01:26:20,292 --> 01:26:22,000
最后稍微向右移动了一点 
ends up moving a little bit to the right,

1550
01:26:22,000 --> 01:26:26,120
所以你会看到奇怪的管子在每一帧中移动到鸟的左边 
and so you get weird pipes shifting to the left of the bird on each frame.

1551
01:26:26,120 --> 01:26:29,380
因此 当您就地编辑表时 请制作
So whenever you edit a table in place, make

1552
01:26:29,380 --> 01:26:32,100
确保在迭代时不要删除它 
sure not to delete while you're iterating over it.

1553
01:26:32,100 --> 01:26:34,870
这将会导致错误的行为 
It's going to cause buggy behavior.

1554
01:26:34,870 --> 01:26:40,030
就像我说的 我很快就会向你们说明这一点 
And like I said, I'll illustrate this for you very shortly.

1555
01:26:40,030 --> 01:26:46,000
在第36行 我们正在执行更新逻辑 
On line 36, we are performing the update logic.

1556
01:26:46,000 --> 01:26:50,740
现在 管道对有两个管道 每个管道都有自己的渲染组件 
Now, a pipe pair has two pipes, each with their own render components,

1557
01:26:50,740 --> 01:26:52,480
以及他们自己的立场 
and their own positions.

1558
01:26:52,480 --> 01:26:55,030
我们使用之前为管道编写的代码 
We're using the code that we wrote before for pipe,

1559
01:26:55,030 --> 01:26:57,370
我们将尝试在此基础上再做一点扩展 
and we're going to try to expand upon it a little bit.

1560
01:26:57,370 --> 01:27:04,200
因此 我们仍然希望将大量代码推迟到管道类 
So we still wanted to defer a lot of that code to the pipe class,

1561
01:27:04,200 --> 01:27:10,060
我们希望根据是否--更新管道--
and we want to update the pipes based on whether--

1562
01:27:10,060 --> 01:27:13,630
我们希望仍然跟踪他们自己的x 以及他们的渲染函数 
We want to still keep track of their own x, and their render functions,

1563
01:27:13,630 --> 01:27:18,310
所以我们要看看 基本上 如果我们的烟斗对
and so we're going to see, basically, if our pipe pair

1564
01:27:18,310 --> 01:27:22,300
X大于负管道宽度 这与我们的逻辑完全相同
x is greater than negative pipe width, which is the same exact logic that we

1565
01:27:22,300 --> 01:27:24,670
以前用过的 
were using before.

1566
01:27:24,670 --> 01:27:33,160
将我们自己的x设置为减去管道速度时间
Set our own x to that minus pipe speed times

1567
01:27:33,160 --> 01:27:35,800
三角洲时间 这与我们之前所做的操作相同 
delta time, which is the same operation we were doing before.

1568
01:27:35,800 --> 01:27:42,320
但我们也在编辑我们自己的x 管道的下部和上部 
But we are also editing the x of our self.pipes lower and upper,

1569
01:27:42,320 --> 01:27:45,910
这将允许我们--在第46行--
and this will allow us to-- on line 46--

1570
01:27:45,910 --> 01:27:47,920
像我们以前所做的那样渲染管道
render the pipes just as we were doing before

1571
01:27:47,920 --> 01:27:51,440
因为他们正在更新他们的x值 就像以前一样 
because they're getting their x values updated just as they were before.

1572
01:27:51,440 --> 01:27:55,180
因此 我们实际上将渲染阶段推迟到管道 
So we're effectively deferring the render phase to our pipes,

1573
01:27:55,180 --> 01:27:58,820
并且不需要在我们的代码中为此添加任何额外的逻辑 
and not really needing to add any additional logic for that in our code.

1574
01:28:01,360 --> 01:28:04,830
我们也对pipe.lua进行了更改 所以我
We've made changes to pipe.lua as well, so I'm

1575
01:28:04,830 --> 01:28:08,910
往前走 在这里打开管道 
going to go ahead, and open up pipe here.

1576
01:28:14,710 --> 01:28:20,710
我们在这里设置了它的高度和宽度作为内容 
And we've set the height and width of it as contents here.

1577
01:28:20,710 --> 01:28:23,020
所以管道高度为288 然后发生了
So pipe height gets 288, and then happens

1578
01:28:23,020 --> 01:28:24,640
大小和屏幕差不多 
to be about the size of the screen.

1579
01:28:24,640 --> 01:28:25,750
管道宽度达到70 
Pipe width gets 70.

1580
01:28:28,270 --> 01:28:32,230
在31号 我们自己坐着 方向就是方向 
On 31, we're sitting self.orientation gets orientation.

1581
01:28:32,230 --> 01:28:34,420
请注意我们的init函数 它之前刚刚
Notice our init function, which was previously just

1582
01:28:34,420 --> 01:28:38,710
为空 它不带参数 现在采用方向 并采用y值 
empty, it took no parameters, now takes an orientation, and it takes a y value.

1583
01:28:38,710 --> 01:28:44,980
定向将允许我们问 基本上 我们的代码是
The orientation is going to allow us to ask, basically, is our code

1584
01:28:44,980 --> 01:28:46,190
上烟斗还是下烟斗？
a top or a bottom pipe?

1585
01:28:46,190 --> 01:28:50,050
如果它是顶管 我们需要翻转它 画出它 然后移动它 
And if it's top pipe, we need to flip it, draw it, and shift it.

1586
01:28:50,050 --> 01:28:53,800
如果它是底部的管子 我们就把它画成正常的 
If it's a bottom pipe, we're just going to draw it normal,

1587
01:28:53,800 --> 01:28:58,240
而不是表演任何花哨的精灵翻转或类似的东西 
and not perform any sort of fancy sprite flipping or anything like that.

1588
01:28:58,240 --> 01:29:02,060
在渲染函数的下面是实际发生这种情况的地方 
Down here in the render function is where this actually happens.

1589
01:29:02,060 --> 01:29:05,620
因此 在第39行 我们像往常一样绘制管道图像
So on line 39, we're drawing the pipe image as usual

1590
01:29:05,620 --> 01:29:12,490
在x处 但在y处 因为当你翻转一个精灵
at x, but at y, because when you flip a sprite

1591
01:29:12,490 --> 01:29:18,250
它最终完全翻转了y轴--它基本上是在它上面运行一面镜子 
it ends up completely flipping the y-- it basically performs a mirror on it,

1592
01:29:18,250 --> 01:29:20,020
但不是在0 0 
but it not at 0,0.

1593
01:29:20,020 --> 01:29:24,040
它基本上是按管道高度量向上移动 
It basically shifts it up by pipe height amount.

1594
01:29:24,040 --> 01:29:29,910
我们需要跟踪这一点 并将其绘制为self.y加管道高度 
We need to keep track of that, and draw it at self.y plus pipe height.

1595
01:29:29,910 --> 01:29:34,324
因为如果我们只画它自己 因为它是镜像的 
Because if we draw it at just self.y, because it's going to be mirrored,

1596
01:29:34,324 --> 01:29:36,490
它会随着管道高度的变化而移动 
and it's going to get shifted by pipe height amount,

1597
01:29:36,490 --> 01:29:38,760
它将超出屏幕的顶部边缘 
it's going to be beyond the top edge of the screen.

1598
01:29:38,760 --> 01:29:41,470
我们需要解释这一点 解释这个事实
We need to account for that, account for the fact

1599
01:29:41,470 --> 01:29:45,125
我们在y轴上翻转它 然后把它拉下来 
that we're flipping it on the y-axis, and bring it down.

1600
01:29:45,125 --> 01:29:47,222
观众：你翻转它的代码在哪里？
AUDIENCE: Where's the code where you flip it?

1601
01:29:47,222 --> 01:29:49,930
科尔顿·奥格登：问题是代码在哪里 我们把它翻到哪里去 
COLTON OGDEN: The question is where is the code where we flip it.

1602
01:29:49,930 --> 01:29:52,660
这就是这条线上的实际情况 
So that's actually here on this line.

1603
01:29:52,660 --> 01:29:57,250
在这种情况下 我们说如果自身方向等于顶部 
On this condition, we're saying if self.orientation is equal to top,

1604
01:29:57,250 --> 01:29:58,350
那么我们想--
then we want to--

1605
01:29:58,350 --> 01:30:02,722
所以这里的参数 我将对此进行注释 只是为了澄清 
so the parameters here, I'll comment this just for clarification.

1606
01:30:02,722 --> 01:30:05,320
观众：所以画图功能有翻转功能？
AUDIENCE: So the draw function has a flip function?

1607
01:30:05,320 --> 01:30:07,240
科尔顿·奥格登：是的 我在这里带你去看看 
COLTON OGDEN: It does, I'll show you here.

1608
01:30:07,240 --> 01:30:09,610
所以在这个0中 我们添加了一些新参数
So this 0, we've added a few new parameters

1609
01:30:09,610 --> 01:30:11,950
致我们的love.graph ics.DrawFunction 
to our love.graphics.drawfunction.

1610
01:30:11,950 --> 01:30:13,120
零表示旋转 
Zero is rotation.

1611
01:30:13,120 --> 01:30:14,930
我们根本不会旋转它 
We're not going to rotate it at all.

1612
01:30:14,930 --> 01:30:17,560
这是x轴上的比例 
This is the scale on the x-axis.

1613
01:30:17,560 --> 01:30:21,590
所以x刻度 这是y轴上的刻度 
So x scale, and this is the scale on the y-axis.

1614
01:30:21,590 --> 01:30:24,070
因此 如果我们应用1的比例运算 它是
So if we apply a scale operation of one, it's

1615
01:30:24,070 --> 01:30:28,250
这与根本不做规模是一样的 
the same thing as doing no scale at all.

1616
01:30:28,250 --> 01:30:30,230
它会把它画在x轴上 
It's going to draw it on the x-axis.

1617
01:30:30,230 --> 01:30:31,640
它只是会正常地画出来 
It's just going draw it normally.

1618
01:30:31,640 --> 01:30:39,340
但如果是顶部 如果此管道已设置为顶部方向 
But if it's top, if this pipe has been set to an orientation of top,

1619
01:30:39,340 --> 01:30:41,710
我们要将刻度设置为负1 
we're going to set the scale to negative 1.

1620
01:30:41,710 --> 01:30:43,540
当你说精灵--
When you said a sprite--

1621
01:30:43,540 --> 01:30:48,770
将其比例因子设置为负1 则会有效地沿该轴翻转它 
its scale factor to negative 1, it flips it along that axis, effectively.

1622
01:30:48,770 --> 01:30:51,130
这就是你得到镜像的方式 
And so that's how you get mirroring.

1623
01:30:51,130 --> 01:30:56,470
大多数引擎允许您将缩放操作应用于2D纹理或2D
Most engines that allow you to apply scale operations to 2D textures or 2D

1624
01:30:56,470 --> 01:31:01,120
精灵 在轴上的负操作会将其镜像到该轴上 
sprites, a negative operation on an axis will mirror it on that axis,

1625
01:31:01,120 --> 01:31:02,620
这就是我们在这里做的事情 
and so that's what we're doing here.

1626
01:31:02,620 --> 01:31:05,680
因此 如果是顶管 我们会对其进行镜像 
So we're mirroring it if it's a top pipe,

1627
01:31:05,680 --> 01:31:07,660
我们还改变了抽签地点
and we're also shifting its draw location

1628
01:31:07,660 --> 01:31:10,710
还有 因为当我们镜像它的时候 它会--
as well because when we mirror it, it's going to--

1629
01:31:10,710 --> 01:31:12,970
在0 0的时候 它会做同样的事情--它会
at 0,0 it's going to do the same-- it's going

1630
01:31:12,970 --> 01:31:17,112
基本上绘制完全相同的东西 但镜像在y轴上 
to basically draw the same exact thing, but mirrored on the y-axis.

1631
01:31:17,112 --> 01:31:18,070
所以它需要--
So it's going to need--

1632
01:31:18,070 --> 01:31:21,100
如果我们想要在一个给定的位置画 翻转--
if we want to draw at a given location, flipped--

1633
01:31:21,100 --> 01:31:23,410
仍将其绘制为0 0 但将其翻转 
still draw it at 0,0, but have it be flipped,

1634
01:31:23,410 --> 01:31:27,040
我们需要解释这种反转 并在有意义的情况下将其向下调整 
we need to account for that flip, and shift it downwards if that makes sense.

1635
01:31:29,740 --> 01:31:33,970
因此 这基本上就是所有涉及到的事情 
So that's essentially all that's involved there.

1636
01:31:33,970 --> 01:31:38,150
我认为这几乎就是所有的代码 
And I think that's pretty much all of the code.

1637
01:31:38,150 --> 01:31:42,100
因此 我们现在有了正在被翻转的管道 
So we have our pipes now that are being flipped.

1638
01:31:42,100 --> 01:31:44,460
如果它是顶管 它就会被拉移 
If its a top pipe, it's going to get drawn shifted.

1639
01:31:44,460 --> 01:31:48,040
它将把另一根管子向下移动同样的量 
It's going to have its other pipe shifted down by that amount,

1640
01:31:48,040 --> 01:31:54,100
它的y轴将增加间隙高度
and its y-axis is going to be increased by the gap height

1641
01:31:54,100 --> 01:31:56,680
所以它会被绘制成90个像素 无论您使用多少像素
so that it gets drawn 90 pixels, however many pixels you

1642
01:31:56,680 --> 01:31:59,260
想放在那根管子下面 
want to set below that pipe.

1643
01:31:59,260 --> 01:32:02,100
因此 我们将进行演示 
So we're going to go into demonstrate this.

1644
01:32:02,100 --> 01:32:10,360
现在转到50鸟 实际的repo和实际的发行版代码 
Go up to fifty bird, the actual repo now, and the actual distro code.

1645
01:32:10,360 --> 01:32:13,510
我要到Bird6去 我要去跑步 
I'm going to go into bird6, and I'm going to run it.

1646
01:32:16,450 --> 01:32:19,750
现在我们有了实际渲染的管道 
And now we have pipes that are actually rendering.

1647
01:32:19,750 --> 01:32:24,700
但我们遗漏了几件重要的事情 
But we're missing a couple of important things.

1648
01:32:24,700 --> 01:32:28,120
最重要的是 其中之一是我们现在还没有碰撞检测 
Foremost, among them being that now we don't have collision detection yet.

1649
01:32:28,120 --> 01:32:30,430
所以我们可以无限地飞过这条航线 
So we can just fly through this course infinitely,

1650
01:32:30,430 --> 01:32:35,110
但请注意 它们被移位了一个在负20之间的随机值
but notice that they're being shifted by a random value between negative 20

1651
01:32:35,110 --> 01:32:37,210
和20个像素 
and 20 pixels.

1652
01:32:37,210 --> 01:32:41,980
它看起来或多或少像是为了某种目标而产生的
It looks more or less like it's being generated with some sort of goal

1653
01:32:41,980 --> 01:32:42,780
在脑海中 
in mind.

1654
01:32:42,780 --> 01:32:44,199
这不是偶然的 
It's not haphazard.

1655
01:32:44,199 --> 01:32:46,240
它不是到处都是 但你可以很容易地
It's not all over the place, but you could easily

1656
01:32:46,240 --> 01:32:50,380
想方设法调整这一点 也许差距高度是
find ways to tweak this such that maybe the gap height is

1657
01:32:50,380 --> 01:32:53,470
一些介于60和120之间的值 
some value between 60 and 120.

1658
01:32:53,470 --> 01:32:57,413
所以你有容易的和困难的管子 或者你有--
And so you have easy and difficult pipes, or maybe you have--

1659
01:32:57,413 --> 01:33:02,760
我觉得我在屏幕下面太远了 我甚至都不能再站起来了 
I think I'm so far below the screen that I can't even get back up anymore.

1660
01:33:02,760 --> 01:33:06,490
哦 好吧 这是个物理错误 
Oh, OK, that's a physics error.

1661
01:33:06,490 --> 01:33:10,570
当你的价值达到某一点时 我认为这实际上就是它所做的
When your value gets to a certain point, I think that's actually what it's doing

1662
01:33:10,570 --> 01:33:13,839
它实际上是在溢出该值 并将其设置为负值 
is it's actually overflowing the value, and setting it to a negative.

1663
01:33:13,839 --> 01:33:16,130
或下溢 并将其设置为负值 
Or underflowing it, and setting it to a negative value,

1664
01:33:16,130 --> 01:33:21,850
然后递增 因为它变得太大了 
and then incrementing it because it's gotten so large.

1665
01:33:21,850 --> 01:33:26,480
但你可以很容易地调整参数 如管道之间的宽度
But you could easily modulate parameters such as the width between the pipes

1666
01:33:26,480 --> 01:33:29,570
正如你在前面的图表中看到的 或者说高度 
as you saw in the diagram before, or the height,

1667
01:33:29,570 --> 01:33:32,030
甚至是它们移动的速度 并发现
or even the speed at which they move, and find

1668
01:33:32,030 --> 01:33:37,880
调整它的方法 使游戏真正发挥作用 无论目标是什么
ways to tune it to make game play that actually works for whatever goal

1669
01:33:37,880 --> 01:33:40,230
你心里想的是--让它变得更容易或更难 
you have in mind-- making it easier or more difficult.

1670
01:33:40,230 --> 01:33:42,260
这实际上是他们在那篇文章中谈到的一个话题
And that's actually a topic that they talked about in that article

1671
01:33:42,260 --> 01:33:44,270
我之前链接过的 在那里他们产生了级别
that I linked to before, where they generated levels

1672
01:33:44,270 --> 01:33:46,561
然后以编程方式对它们进行测试
programmatically, and then tested them programmatically

1673
01:33:46,561 --> 01:33:50,410
来确定是什么让Flappy Bird的等级变得困难或容易 
to determine what makes level in Flappy Bird difficult or easy.

1674
01:33:50,410 --> 01:33:55,190
所以基本上 这些都是参数
And so basically, those are the parameters

1675
01:33:55,190 --> 01:33:58,160
当你在考虑程序生成时 你需要这样做 
you need to way as you're thinking of procedural generation.

1676
01:33:58,160 --> 01:34:00,259
而程序性的生成 归根结底是公正的
And procedural generation, ultimately, is just

1677
01:34:00,259 --> 01:34:02,300
取你用来构建场景的值 
taking values that you construct your scene with,

1678
01:34:02,300 --> 01:34:05,460
只是想方设法随意操控它们 
and just finding ways to just manipulate them randomly.

1679
01:34:05,460 --> 01:34:11,780
数学 随机取一些值 简而言之 这就是你如何制造随机水平 
Math.random some value, and that's how you make random levels in a nutshell.

1680
01:34:11,780 --> 01:34:16,344
制作好的随机水平是另一个问题 
Making good random levels is another question.

1681
01:34:16,344 --> 01:34:18,719
观众：这家伙做得很少 赚了很多钱 
AUDIENCE: This guy made a lot of money doing very little.

1682
01:34:18,719 --> 01:34:19,927
科尔顿·奥格登：他做到了 他做到了 
COLTON OGDEN: He did, he did.

1683
01:34:19,927 --> 01:34:22,430
早在2013年 这款游戏就引发了很大的争议 
There was a big controversy around this game back in 2013.

1684
01:34:22,430 --> 01:34:25,580
观众：他也有精神崩溃的症状 对吗？
AUDIENCE: He had like a nervous breakdown, too, right?

1685
01:34:25,580 --> 01:34:27,913
科尔顿·奥格登：我不知道我是否读得太多了 
COLTON OGDEN: I don't know if I read too much into that,

1686
01:34:27,913 --> 01:34:31,310
但我做了一点研究 读到了一些
but I was doing a little bit of research, and was reading about some

1687
01:34:31,310 --> 01:34:32,890
那些东西 
of that stuff.

1688
01:34:32,890 --> 01:34:35,300
我必须支持他 因为他寄希望于这一点 
I've got to give him props for banking on that.

1689
01:34:38,692 --> 01:34:39,650
现在我们有了管子对 
Now we have pipe pairs.

1690
01:34:39,650 --> 01:34:42,920
这可以说是该计划中最复杂的部分
That's arguably the most complex part of the program

1691
01:34:42,920 --> 01:34:46,740
因为现在向前看 当我们进入碰撞时 
because going forward now, as we get into collision,

1692
01:34:46,740 --> 01:34:49,460
还有一些更多的概念 碰撞实际上是
and some more concepts, collision is actually something

1693
01:34:49,460 --> 01:34:54,840
我们上周谈到的 基本上都是一样的东西 
that we touched on last week, and it's all basically the same stuff.

1694
01:34:54,840 --> 01:35:00,750
因此 如果我们进入Bird7 即我们应用程序的下一次迭代 
So if we go into bird7, the next iteration of our application.

1695
01:35:00,750 --> 01:35:07,420
我要继续 打开主电源 卢亚 
I'm going to go ahead, and open up main.lua,

1696
01:35:07,420 --> 01:35:10,680
然后我们要去74号线 
and then we're going to go to line 74.

1697
01:35:14,040 --> 01:35:19,510
为了测试碰撞 我们还没有打分 
And in order to test collision, we don't have scoring in place yet,

1698
01:35:19,510 --> 01:35:22,960
但我们需要一些方法来确定哦 我们撞上了一根管道 
but we need some way to determine oh, we collided with a pipe.

1699
01:35:22,960 --> 01:35:24,730
我们需要一些反馈 
We need some sort of feedback.

1700
01:35:24,730 --> 01:35:29,340
所以我们要做的是 我刚刚决定我们应该暂停比赛 
So what we're going to do is I've just decided we should just pause the game.

1701
01:35:29,340 --> 01:35:31,980
所以一旦我们与管道相撞 我们就立即停下来
So once we collide with a pipe, let's just pause instantly

1702
01:35:31,980 --> 01:35:34,577
所以我们马上就知道 哦 我们撞到了一根管道 
so we know immediately, oh, we collided with a pipe.

1703
01:35:34,577 --> 01:35:36,660
所以我将设置一个称为滚动的变量
So I'm going to set some variable called scrolling

1704
01:35:36,660 --> 01:35:39,239
在程序的顶部 从Main到True 
at the top of the program in main to true.

1705
01:35:39,239 --> 01:35:39,905
我们在滚动 
We're scrolling.

1706
01:35:39,905 --> 01:35:42,339
我们要开始滚动了 但当我
We're going to start scrolling, but when I

1707
01:35:42,339 --> 01:35:44,880
我不想再滚动了 当我想暂停游戏时 
don't want to scroll any more, when I want to pause the game,

1708
01:35:44,880 --> 01:35:47,580
应将其设置为False 
this should get set to false.

1709
01:35:47,580 --> 01:35:55,950
因此 在第120行 如果滚动 则执行所有这些更新逻辑
So on line 120, if scrolling, then do all of this update logic

1710
01:35:55,950 --> 01:35:58,091
就像我们以前做的那样 
that we did before.

1711
01:35:58,091 --> 01:36:00,840
最后 我们重新设置了输入表 
And then at the very end of that, we're resetting our input table.

1712
01:36:00,840 --> 01:36:03,330
因此我们仍然可以接受输入 但不能更新
So we can still take input, but no updates

1713
01:36:03,330 --> 01:36:05,940
如果将滚动设置为FALSE 则将发生 
will take place if scrolling is set to false.

1714
01:36:05,940 --> 01:36:09,030
所有这些东西都在这个范围内 如果--
All of this stuff is within this if--

1715
01:36:09,030 --> 01:36:10,710
打扰一下 如果是滚动的话 
excuse me, if scrolling, then.

1716
01:36:10,710 --> 01:36:11,477
非常简单 
So very simple.

1717
01:36:11,477 --> 01:36:13,560
我们只需将其封装在某个变量中
We'll just encapsulate it all within some variable

1718
01:36:13,560 --> 01:36:16,990
我们可以打开和关闭 
that we can turn on and off.

1719
01:36:16,990 --> 01:36:21,870
然后在152上 在该代码块内
And then on 152, within that chunk of code

1720
01:36:21,870 --> 01:36:25,280
它包含在If条件中 
that is being contained within that if condition,

1721
01:36:25,280 --> 01:36:28,920
我们只是在做一个非常简单的迭代 
we're just doing a very simple iteration.

1722
01:36:28,920 --> 01:36:33,420
每一根管子 这应该是L成对的--
For each pipe, this should be for l pair in pairs of--

1723
01:36:33,420 --> 01:36:34,590
哦 不 对不起 
oh no, sorry.

1724
01:36:34,590 --> 01:36:39,870
对于成对的每根管子--
For every pipe in the pairs of--

1725
01:36:39,870 --> 01:36:41,490
在本例中 它是一个嵌套的for循环 
it's a nested for loop in this case.

1726
01:36:41,490 --> 01:36:46,824
所以基本上 在检查每一对的循环中 为了更新它 
So basically, within the loop that looks over every single pair, to update it,

1727
01:36:46,824 --> 01:36:49,990
我们正在做另一个循环 循环通过这对管道 
we're doing another loop that's looping through with the pipes in that pair.

1728
01:36:49,990 --> 01:36:53,820
因此 它只是一个上下管道两次迭代的循环 
So it's only a loop of two iterations with the upper and the lower pipe.

1729
01:36:53,820 --> 01:36:57,930
我们也可以说 如果鸟撞上了上面--
We could just also say if bird collides with upper--

1730
01:36:57,930 --> 01:37:00,960
基本上 如果是上半身或下半身 或者是下半身
basically, if pair.upper or pair.lower, or pair.pipes

1731
01:37:00,960 --> 01:37:03,960
往上走 往下走 往下走 但这个干净多了 
to upper pair.pipes.lower, but this is a little cleaner.

1732
01:37:03,960 --> 01:37:04,847
它的可扩展性更强 
It's more scalable.

1733
01:37:04,847 --> 01:37:07,680
我们可以增加更多的管道 如果我们想的话 即使这不会发生 
We can add more pipes if we want to, even though it wouldn't happen.

1734
01:37:07,680 --> 01:37:12,480
但是对于每一个配对的管道 我们在这里有一个函数 我们
But for every pipe in pair.pipes, we have a function here that we

1735
01:37:12,480 --> 01:37:14,940
还没有定义为鸟：碰撞 
haven't defined yet called bird:collides.

1736
01:37:14,940 --> 01:37:19,030
所以 如果鸟撞上了管子 它就会吸进管子 
So if bird collides pipe-- so it takes in a pipe.

1737
01:37:19,030 --> 01:37:21,990
所以它将返回一个真或假的值 我们知道--
So it's going to return a true or false value, we know that--

1738
01:37:21,990 --> 01:37:23,220
将滚动设置为FALSE 
set scrolling to false.

1739
01:37:23,220 --> 01:37:26,590
所以我们发生冲突 滚动设置为假 更新逻辑
So we collide, scrolling set to false, update logic

1740
01:37:26,590 --> 01:37:28,090
将被完全关闭 
is going to get shut off completely.

1741
01:37:28,090 --> 01:37:31,620
所以我们会暂停游戏的效果 
So we're going to have the effect of pausing the game.

1742
01:37:31,620 --> 01:37:34,230
我们现在要进入小鸟 卢亚 
We're going to go into bird.lua right now,

1743
01:37:34,230 --> 01:37:36,700
我们将看看我们是如何实现这一点的 
and we're going to actually see how we implement this,

1744
01:37:36,700 --> 01:37:40,600
它看起来会和我们上周所做的非常相似 
and it's going look very familiar to what we did last week.

1745
01:37:40,600 --> 01:37:47,750
所以在Bird.Lua中 这个函数从29减到45 
So in bird.lua, this function here, from 29 down to 45,

1746
01:37:47,750 --> 01:37:51,350
这只是我们上周做的AABB碰撞检测测试 
it's just an aabb collision detection test that we did last week.

1747
01:37:51,350 --> 01:37:54,740
我们只是在检查以确保任何边缘--
We're just checking to make sure any edges are--

1748
01:37:54,740 --> 01:37:58,310
右边缘 确保它在左边
right edge, make sure that is to the left

1749
01:37:58,310 --> 01:38:00,440
第二个框的右边缘 
of the right edge of the second box.

1750
01:38:00,440 --> 01:38:02,740
第一个盒子的底边应该是--
Bottom edge of box one should be--

1751
01:38:02,740 --> 01:38:05,570
框1的底边或底边应在底边或顶边之上
or bottom edge of box one should be above bottom edge or top

1752
01:38:05,570 --> 01:38:06,590
第二个盒子的边缘 
edge of box two.

1753
01:38:06,590 --> 01:38:10,520
如果所有这些都成立 则返回TRUE 
If all of these things hold true, then return true.

1754
01:38:10,520 --> 01:38:11,440
否则 返回FALSE 
Else, return false.

1755
01:38:11,440 --> 01:38:13,070
这意味着我们发生了碰撞 
That means we have a collision.

1756
01:38:13,070 --> 01:38:18,107
注意 我把这里的所有东西都移了几个常量值 
And notice that I've shifted everything here by a couple of constant values.

1757
01:38:18,107 --> 01:38:19,940
有没有人本能地知道我为什么
Does anybody have any instinct as to why I'm

1758
01:38:19,940 --> 01:38:26,060
说的是self.x加2 而不是self.x self.wide减4？
saying self.x plus 2 instead of just self.x self.width minus 4?

1759
01:38:26,060 --> 01:38:30,620
为什么我们要检查这种情况下鸟的偏移量
Why we're checking for that offset for the bird in this case

1760
01:38:30,620 --> 01:38:32,240
当它与管子相比时 
when it is compared with the pipe.

1761
01:38:32,240 --> 01:38:34,004
观众：它是鸟的一半大小吗？
AUDIENCE: It's half the size of the bird?

1762
01:38:34,004 --> 01:38:35,420
科尔顿·奥格登：这还不到一半 
COLTON OGDEN: It's not quite half.

1763
01:38:35,420 --> 01:38:37,160
它比以前小了几个像素 
It's a few pixels smaller.

1764
01:38:37,160 --> 01:38:39,350
我们知道为什么要这么做吗？
Do we know why we want to do this?

1765
01:38:39,350 --> 01:38:41,450
我们基本上是在缩小盒子 
We're basically shrinking the box.

1766
01:38:41,450 --> 01:38:45,120
我们为什么要缩小盒子？
Why would we want to shrink the box?

1767
01:38:45,120 --> 01:38:49,405
观众：实际的画作之间有差距 
AUDIENCE: There's a gap between the actual drawing [INAUDIBLE]

1768
01:38:49,405 --> 01:38:50,530
科尔顿·奥格登：所以不完全是 
COLTON OGDEN: So not quite.

1769
01:38:50,530 --> 01:38:53,740
因此 这幅图之间并没有实际的差距 
So there isn't an actual gap between the drawing.

1770
01:38:53,740 --> 01:39:00,355
这更多的是一个问题 我们想在多大程度上挫败我们的用户 
It's more a question of how much we want to frustrate our users.

1771
01:39:00,355 --> 01:39:06,070
如果我们的像素完美地与管道相撞 就不会有取舍 
If we're pixel perfect colliding with the pipes, there's no give and take.

1772
01:39:06,070 --> 01:39:09,010
就像你们相撞了 即使--它甚至可能
It's like you collide, and even if-- it might even

1773
01:39:09,010 --> 01:39:11,369
看起来就像你甚至没有撞到管道 
look as if you're not even colliding with the pipe,

1774
01:39:11,369 --> 01:39:12,910
而你仍然会遇到碰撞 
and you're still getting a collision.

1775
01:39:12,910 --> 01:39:14,990
你的用户在想 好吧 这不公平 
Your users are thinking, well, that's not fair.

1776
01:39:14,990 --> 01:39:16,570
这真的很苛刻 
That's really harsh.

1777
01:39:16,570 --> 01:39:19,812
我们正在缩小盒子 这样即使它们只差一个像素 
We're shrinking our box so that even if they're just a pixel off,

1778
01:39:19,812 --> 01:39:21,520
他们仍然会有一点回旋余地 
they'll still get a little bit of leeway,

1779
01:39:21,520 --> 01:39:25,630
在碰撞方面 它会稍微放松一些 
and it'll be a little bit less strict in terms of the collision,

1780
01:39:25,630 --> 01:39:29,890
这在游戏中是很常见的事情 当你的角色具有精灵
and this is a very common thing in games when you have characters whose sprites

1781
01:39:29,890 --> 01:39:33,820
不一定会填满你为他们分配的整个盒子 
may not necessarily fill the entire box that you've allocated for them,

1782
01:39:33,820 --> 01:39:35,530
即使你在做长方体碰撞 
even though you're doing box collision.

1783
01:39:35,530 --> 01:39:39,250
只要给你的用户几个像素深度 不管多少
Just give your users a couple of pixels deep, however many

1784
01:39:39,250 --> 01:39:42,220
你想要的 它们可以与任何东西重叠
you want, and they can overlap with whatever

1785
01:39:42,220 --> 01:39:44,980
它们只是在它实际撞击之前的一小部分
they're colliding with just a tiny bit before it actually

1786
01:39:44,980 --> 01:39:48,610
在碰撞中触发真 这会让你的游戏感觉更宽容 
triggers a true on the collision, and it makes your game feel more forgiving,

1787
01:39:48,610 --> 01:39:51,770
然后也因此而更有趣 
and then also more fun as a result of that.

1788
01:39:51,770 --> 01:39:53,200
这就是为什么我们有--
So that's why we have--

1789
01:39:53,200 --> 01:39:57,940
我们不是直接在盒子的x0上测试 而是测试x+2 
instead of testing directly on x0 of that box, we're testing x plus 2,

1790
01:39:57,940 --> 01:40:00,490
然后是自身宽度减去4 因为当我们移动时 
and then self.width minus 4 because when we shift,

1791
01:40:00,490 --> 01:40:03,480
我们将宽度加到正2值上 我们需要负4
we add width to a plus 2 value, we need minus 4

1792
01:40:03,480 --> 01:40:06,370
所以我们从右边得到2 而且是一样的
so that we get 2 off the right edge, and same thing

1793
01:40:06,370 --> 01:40:10,010
表示高度和y值 
goes for the height, and the y value.

1794
01:40:10,010 --> 01:40:13,120
因此 这只执行AABB冲突检测 
And so this just performs aabb collision detection.

1795
01:40:13,120 --> 01:40:17,230
需要管道 这意味着我们需要确保
Expects a pipe, which means that we need to ensure

1796
01:40:17,230 --> 01:40:20,470
管子有一个x和一个y 一个宽度和一个高度 它确实有 
that the pipe has an x and a y, a width and a height, which it does.

1797
01:40:20,470 --> 01:40:22,090
实际上 这里只是一个常量 
Actually, just a constant here.

1798
01:40:22,090 --> 01:40:24,261
我们只是在检查管道的宽度和高度 
We're just checking pipe width and pipe height.

1799
01:40:24,261 --> 01:40:25,510
我们可能不该这么做 
We probably shouldn't do that.

1800
01:40:25,510 --> 01:40:29,071
在这种情况下 它应该是pipe.width pipe.height 
It should be pipe.width, pipe.height in that case,

1801
01:40:29,071 --> 01:40:31,320
因为这样一来 这不可能只是一根管子 
because then this couldn't necessarily just be a pipe.

1802
01:40:31,320 --> 01:40:34,990
它可以是场景中具有XY、宽度和高度的任何对象 
It could be anything in our scene that has a xy, a width, and a height.

1803
01:40:34,990 --> 01:40:37,090
这可能是一起一般用途的碰撞 
It could be a general purpose collision.

1804
01:40:37,090 --> 01:40:39,895
事实上 如果你愿意 你也可以做的是
And actually, something you could also do if you wanted to is

1805
01:40:39,895 --> 01:40:44,260
只需编写一个名为Collides的函数 该函数接受两个内容
just write a function called collides that takes in two things

1806
01:40:44,260 --> 01:40:46,354
你知道它有包围盒 而且会
that you know have bounding boxes, and will

1807
01:40:46,354 --> 01:40:48,520
允许您对任何对象执行碰撞检测
allow you to perform collision detection on anything

1808
01:40:48,520 --> 01:40:50,890
在场景中的任意两个实体之间 
in your scene between any two entities.

1809
01:40:50,890 --> 01:40:54,022
我想 这将是一种更具伸缩性的方式 
That would be a more scalable way, I guess,

1810
01:40:54,022 --> 01:40:56,230
处理它 而不是一定要拥有它
of dealing with it, rather than necessarily having it

1811
01:40:56,230 --> 01:40:59,422
明确定义为鸟类和管子是对撞机 
specifically defined as birds and pipes being the colliders.

1812
01:40:59,422 --> 01:41:01,630
但在这种情况下 这是我们唯一真正
But in this case, this is the only thing we're really

1813
01:41:01,630 --> 01:41:03,950
除了地面以外 都与之相撞 
colliding with, except for the ground.

1814
01:41:03,950 --> 01:41:06,283
但当你与地面相撞时 你需要做的就是
But when you collide with the ground, all you need to do

1815
01:41:06,283 --> 01:41:10,090
就是看看你的y体位加上你的身高
is just check to see whether your y position plus your height

1816
01:41:10,090 --> 01:41:12,700
已经到了屏幕边缘以下 
has gone below the edge of the screen.

1817
01:41:12,700 --> 01:41:15,197
那么 对于如何做到这一点 有什么问题吗？
So any questions as to how that?

1818
01:41:15,197 --> 01:41:20,560
观众：为什么你要加2n再减4 而不是只减2？
AUDIENCE: Why did you add 2n and subtract 4 instead of just subtract 2?

1819
01:41:20,560 --> 01:41:23,740
科尔顿·奥格登：所以问题是为什么我们要加2减去
COLTON OGDEN: So the question was why did we add 2 and subtract

1820
01:41:23,740 --> 01:41:26,590
4而不是减去2？
4 instead of just subtract 2?

1821
01:41:26,590 --> 01:41:31,090
因为当你添加一个--
Because when you add a--

1822
01:41:31,090 --> 01:41:34,270
因为我们做的是self.x+2 基本上我们是
because we're doing self.x plus 2, basically we're

1823
01:41:34,270 --> 01:41:36,930
移动整个盒子 基本上 在这里 在这一部分 
shifting the whole box, essentially, here in this part.

1824
01:41:36,930 --> 01:41:40,960
所以 self.x加2带来了盒子的开始
So self.x plus 2 brings the beginning of the box

1825
01:41:40,960 --> 01:41:43,930
我们与右侧的2个像素相撞 
that we're colliding with 2 pixels to the right.

1826
01:41:43,930 --> 01:41:49,780
但如果我们只做2个像素减去2 那么盒子的右边缘
But if we just do 2 pixels minus 2, then the box's right edge

1827
01:41:49,780 --> 01:41:51,460
仍然是框的右边缘 
is still the right edge of the box.

1828
01:41:51,460 --> 01:41:55,060
我们希望它向内移动2个像素 
We want it to be shifted inwards by 2 pixels.

1829
01:41:55,060 --> 01:41:59,740
因为我们在方框的开始处移动了x位置 2个像素以上 
Because we've shifted at the start of our box, the x position, 2 pixels over,

1830
01:41:59,740 --> 01:42:04,790
我们需要将它向内移动4个像素 因为
we need to shift it 4 pixels inwards because that

1831
01:42:04,790 --> 01:42:10,221
会产生这样的效果 我们的长方体在右边缘有2个像素 
will have the effect of our box being 2 pixels into the right edge.

1832
01:42:10,221 --> 01:42:11,694
这说得通吗？
Does that make sense?

1833
01:42:16,120 --> 01:42:18,895
好的 我想这就是Bird7的全部内容 
OK, so I think that's everything for bird7.

1834
01:42:23,960 --> 01:42:28,070
我们将继续 现在运行Bird7 
We're going to go ahead, and run bird7 now.

1835
01:42:28,070 --> 01:42:33,920
记住 如果我们碰到管道 我们应该立即暂停 
And recall, if we hit a pipe, we should instantly pause.

1836
01:42:33,920 --> 01:42:36,870
如此跳跃 跳跃 跳跃 
So bouncing, bouncing, bouncing.

1837
01:42:36,870 --> 01:42:39,694
我要在这里通过一对管道 
I'm going to go through one pair of pipes here,

1838
01:42:39,694 --> 01:42:41,610
然后我会故意打这个 
and then I'm going to hit this one on purpose.

1839
01:42:41,610 --> 01:42:42,364
哦 我们停顿了一下 
Oh, we paused.

1840
01:42:42,364 --> 01:42:44,280
请注意 我们有一点回旋余地 
And notice that we had a little bit of leeway.

1841
01:42:44,280 --> 01:42:47,330
我们在那里有几个像素--以防万一
We got a couple of pixels there just to give us-- in case we

1842
01:42:47,330 --> 01:42:50,330
意外的--而且 它还考虑到了你可能会移动 
accidentally-- and also, it takes into consideration you could move,

1843
01:42:50,330 --> 01:42:52,490
因为你的速度 几个像素
because of your velocity, a couple of pixels

1844
01:42:52,490 --> 01:42:57,530
超越了你所碰撞的东西的严格的硬边缘
beyond necessarily the strict hard edge of what you're colliding with

1845
01:42:57,530 --> 01:43:00,900
基于通过的帧的数量 
based on how many frames of passed.

1846
01:43:00,900 --> 01:43:04,177
基本上 你的速度是多少 你的位置是什么 
Basically, essentially what your velocity is, and what your position is.

1847
01:43:04,177 --> 01:43:06,260
在这种情况下 我认为看起来我们实际上
In this case, I think it looks like we're actually

1848
01:43:06,260 --> 01:43:08,759
边缘上方三四个像素 因为我们的速度是
three or four pixels above the edge because our velocity was

1849
01:43:08,759 --> 01:43:13,640
这么高是因为我们跳了 但它一检测到碰撞 就像
so high because we jumped, but as soon as it detected the collision, as

1850
01:43:13,640 --> 01:43:17,060
我们一到那个画面上 我们的位置就是这样
soon as we were on that frame where our position was such

1851
01:43:17,060 --> 01:43:19,830
我们确实触发了碰撞检测的True 
that we did trigger true for our collision detection,

1852
01:43:19,830 --> 01:43:20,750
它暂停了游戏 
it paused the game.

1853
01:43:20,750 --> 01:43:22,040
循环设置为FALSE 
Looping was set to false.

1854
01:43:22,040 --> 01:43:26,060
我们不再运行任何更新逻辑 这是我们的基本方式
We no longer ran any update logic, and this is our basic way

1855
01:43:26,060 --> 01:43:27,960
得到关于这方面的反馈 
of getting feedback about that.

1856
01:43:27,960 --> 01:43:33,230
然而 它并不是特别有说服力 游戏智慧 
However, it's not particularly compelling, gameplay wise,

1857
01:43:33,230 --> 01:43:37,430
所以我们想要进入得分领域 
and so we want to get into scoring.

1858
01:43:37,430 --> 01:43:41,390
在我们开始得分之前 也是与之相关的 
Before we get to scoring though, and also associated with that,

1859
01:43:41,390 --> 01:43:42,690
我们比赛的不同状态 
different states of our game.

1860
01:43:42,690 --> 01:43:44,440
因此 如果我们开始得分 显然我们想要
So if we get into scoring, clearly we want

1861
01:43:44,440 --> 01:43:47,489
有一个屏幕告诉我们什么时候输了 我们的比分是多少 
to have a screen that tells us when we lost, and what our score was.

1862
01:43:47,489 --> 01:43:49,280
我们可能还应该有一个标题屏幕
We should also probably have a title screen

1863
01:43:49,280 --> 01:43:51,830
因为我们才刚刚进入游戏阶段 
because we're just jumping right into the gameplay.

1864
01:43:51,830 --> 01:43:54,710
我们想要一个可以让我们玩完游戏的屏幕 
We want a screen that lets us play through the game,

1865
01:43:54,710 --> 01:43:57,890
正如我们将在稍后看到的 一个屏幕也为我们提供了
and as we'll see in a little bit, a screen that also gives us

1866
01:43:57,890 --> 01:44:01,340
有时间 一旦我们开始比赛 开始倒计时 
some time, once we start the game, to count down.

1867
01:44:01,340 --> 01:44:04,290
就像是说 哦 三 二 一 去 而不仅仅是哦 
Sort of say, oh, three, two, one, go, rather than just oh,

1868
01:44:04,290 --> 01:44:06,250
去吧 哦 我不知道我在做什么 
go, and oh, I don't know what I'm doing.

1869
01:44:06,250 --> 01:44:06,950
我大惑不解 
I'm bewildered.

1870
01:44:06,950 --> 01:44:10,220
所以这是一张对国家进行建模的图表
So this is a diagram that sort of models the state

1871
01:44:10,220 --> 01:44:15,180
我们将在我们的程序中使用的流 我们的游戏 
flow that we're going to be using in our program here, our game.

1872
01:44:15,180 --> 01:44:18,200
我们将假设我们从某种标题屏幕状态开始 
We're going to assume that we start on some sort of title screen state.

1873
01:44:18,200 --> 01:44:19,540
所以从左到右 
So going left to right.

1874
01:44:19,540 --> 01:44:22,860
标题屏幕状态将转换到倒计时状态 
A title screen state will transition to the count down state,

1875
01:44:22,860 --> 01:44:26,297
然后 我们可以随心所欲地定义这些转变 
and then we can define, however we want, those transitions to be.

1876
01:44:26,297 --> 01:44:28,130
在这种情况下 假设我们按Enter键 
In this case, let's just say we press Enter.

1877
01:44:28,130 --> 01:44:30,290
标题屏幕状态进入倒计时状态 
The title screen state goes to countdown state.

1878
01:44:30,290 --> 01:44:32,550
一旦倒计时状态--
Once countdown state has--

1879
01:44:32,550 --> 01:44:36,872
一旦为此触发了转换 我们就应该进入播放状态 
once the transition has triggered for that, we should go to the play state.

1880
01:44:36,872 --> 01:44:39,080
然后一旦转换触发到播放状态 
And then once the transition triggers for play state,

1881
01:44:39,080 --> 01:44:40,970
我们将进入得分状态 
we're going to go down to the score state.

1882
01:44:40,970 --> 01:44:44,630
然后得分状态应该回到倒计时状态 这个模型
And then score state should go back into countdown state, and this models

1883
01:44:44,630 --> 01:44:48,950
我们整个应用程序的流程--
our entire application's flow--

1884
01:44:48,950 --> 01:44:53,090
从上到下 从左到右 按时间顺序 
top to bottom, left to right, chronologically.

1885
01:44:53,090 --> 01:44:55,190
因此 让我们继续 看看一些代码
So let's go ahead, and take a look at some code

1886
01:44:55,190 --> 01:44:56,898
关于我们将如何实现这一点 
as to how we're going to accomplish this.

1887
01:44:56,898 --> 01:45:00,260
上周 我提到了我们--实际上在早些时候的演讲中--我们
Last week, I alluded to taking us-- and actually earlier in lecture, us

1888
01:45:00,260 --> 01:45:04,220
从这种基于字符串的方法 到使用if跟踪我们的状态
going from this string based approach, to keeping track of our state with if

1889
01:45:04,220 --> 01:45:06,470
条件 到基于类的方法 这就是
conditions, to a class based approach, and that's

1890
01:45:06,470 --> 01:45:08,140
我们今天要说明的是 
what we're going to illustrate today.

1891
01:45:08,140 --> 01:45:11,080
所以我要继续 打开Bird8 
So I'm going to go ahead, and open up bird8.

1892
01:45:11,080 --> 01:45:15,110
在Bird8中 我将继续 从Main开始 
And in bird8, I'm going to go ahead, and start with main.

1893
01:45:15,110 --> 01:45:23,240
在Main中 在第36行 我们正在获取一个名为状态机的新类 
So in main, on line 36, we're acquiring a new class called state machine,

1894
01:45:23,240 --> 01:45:26,600
以及我们正在定义的其他几个类 称为Bay State Play
and a few other classes that we're defining called bay state, play

1895
01:45:26,600 --> 01:45:28,920
状态和标题屏幕状态 
state, and title screen state.

1896
01:45:28,920 --> 01:45:31,630
这些是我们的状态机的组成部分 
And these are the components of our state machine,

1897
01:45:31,630 --> 01:45:35,120
现在 它们不再仅仅是我们更新函数中的代码块 
and they've now, instead of being just blocks of code in our update function,

1898
01:45:35,120 --> 01:45:37,670
它们是独立的块、独立的模块
they're separate blocks, separate modules that

1899
01:45:37,670 --> 01:45:40,310
有自己的逻辑 自己的更新和渲染逻辑 
have their own logic, their own update and render logic,

1900
01:45:40,310 --> 01:45:41,890
我们很快就会看到这一点 
and we'll see that very shortly.

1901
01:45:41,890 --> 01:45:45,560
在78号线 如果我们往下走--
On line 78, if we go down here--

1902
01:45:45,560 --> 01:45:48,290
除此之外 我还实例化了一些字体 
separate from that, I'm also instantiating a bunch of fonts.

1903
01:45:48,290 --> 01:45:49,610
我们上个星期就做过了 
We did this last week.

1904
01:45:49,610 --> 01:45:53,164
所以 love.graph ics.newfont接受一个字体文件 然后是一个大小 
So love.graphics.newfont takes in a font file and then a size.

1905
01:45:53,164 --> 01:45:56,330
我在这里创建了几种不同的字体 因为我们有几种不同的方式
I've created a few different fonts here because we have a few different ways

1906
01:45:56,330 --> 01:45:58,490
向用户提供反馈 
of giving feedback to the user.

1907
01:45:58,490 --> 01:46:01,220
我们想要一个小字体来显示按Enter键
We want a small font for displaying press Enter

1908
01:46:01,220 --> 01:46:02,860
作为一个开始 或者类似的东西 
to a start, or something like that.

1909
01:46:02,860 --> 01:46:06,214
我们想要一个中等字体来显示游戏的名称 也许 
We want a medium font to display the name of the game, perhaps.

1910
01:46:06,214 --> 01:46:08,630
或者 我认为实际上 Flappy Font应该对此负责 
Or, I think actually, Flappy Font is responsible for that.

1911
01:46:08,630 --> 01:46:10,550
中等字体 我想 是为了得分 
Medium font, I think, was for score.

1912
01:46:10,550 --> 01:46:12,170
巨大的字体为我们的倒计时 
Huge font for our countdown.

1913
01:46:12,170 --> 01:46:14,170
我们想要一个大字体 正好在屏幕中央
We want a big font right in the middle of screen

1914
01:46:14,170 --> 01:46:16,220
三 二 一 然后我们开始 
that says three, two, one, and then we start.

1915
01:46:16,220 --> 01:46:19,303
然后我们将首先将其设置为Flappy Font 它
And then we're just going to start off by setting it to Flappy Font, which

1916
01:46:19,303 --> 01:46:20,750
将成为我们的标题字体 
is going to be our title font.

1917
01:46:20,750 --> 01:46:25,520
所以没有什么真正的新东西 但可以说是我们的用户界面的开始 
So nothing really new, but the beginning of our UI, so to speak.

1918
01:46:25,520 --> 01:46:29,240
在第92行 这是新的 实际上这是
On line 92, this is new, and actually this

1919
01:46:29,240 --> 01:46:32,660
是一种命名约定的演示 
is a demonstration of a type of naming convention

1920
01:46:32,660 --> 01:46:35,240
您将经常在游戏代码库中看到 
you'll see often in game code bases.

1921
01:46:35,240 --> 01:46:38,420
我们还没有使用它 但我们将在未来开始使用它 
We haven't used it yet, but we will start using it in the future.

1922
01:46:38,420 --> 01:46:42,290
我们在全局变量前面加上一个小写的g 
We prefix a global variable with a lower case g.

1923
01:46:42,290 --> 01:46:45,260
这可以让您知道当您正在挖掘一系列文件时
This lets you know when you're digging through a bunch of files

1924
01:46:45,260 --> 01:46:46,940
那个哦 这是一个全局变量 
that oh, this is a global variable.

1925
01:46:46,940 --> 01:46:51,770
好的 所以我应该知道它可能没有在这个模块中定义 
OK, so I should probably know it's probably not defined in this module.

1926
01:46:51,770 --> 01:46:54,892
也许是这样 但我知道这是全球性的 
Maybe it is, but I know it's global.

1927
01:46:54,892 --> 01:46:56,600
您可能会看到的其他内容是小写
Other things you might see are lower case

1928
01:46:56,600 --> 01:47:03,770
M代表成员 这意味着这是一个成员函数 或者是一个类的字段 
m for member, which means that this is a member function, or a field of a class,

1929
01:47:03,770 --> 01:47:06,684
你可以一目了然 知道
and you can instantly see at a glance, and know

1930
01:47:06,684 --> 01:47:08,600
好的 如果我想找出这个的定义 
OK, if I want to find the definition for this,

1931
01:47:08,600 --> 01:47:10,141
它看起来像是一个成员函数 
it looks like it's a member function.

1932
01:47:10,141 --> 01:47:13,280
所以它可能就在这个班级里 在这里的某条线上 
So it's probably in this class, here at some line.

1933
01:47:13,280 --> 01:47:15,530
你很容易就能找到 
You can easily find it.

1934
01:47:15,530 --> 01:47:17,960
因此 在未来的课程中 我们将使用
And so in future lectures, we'll be using

1935
01:47:17,960 --> 01:47:23,140
更多的是这个小写的g 表示全局变量 我们一个模块一个模块地使用 
more of this lowercase g for global variables that we use module to module.

1936
01:47:23,140 --> 01:47:25,700
在本例中 我们实例化了一个状态机 
In this case, we're instantiating a StateMachine.

1937
01:47:25,700 --> 01:47:29,710
所以我们使用的是这个类 我们稍后会看一下 
So we're using the class that we will take a look at in a second.

1938
01:47:29,710 --> 01:47:32,200
StateMachine接收一个带有键的表
The StateMachine takes in a table with keys

1939
01:47:32,200 --> 01:47:36,890
映射到将返回我们的状态的函数 
that map to functions that will return our states.

1940
01:47:36,890 --> 01:47:43,910
所以我们可以只调用更改一些值 它将在我们的状态机中 
So we can just call change some value, and it'll have in our state machine,

1941
01:47:43,910 --> 01:47:48,340
它基本上会在这里引用该表中键 
it will basically reference that key in this table here,

1942
01:47:48,340 --> 01:47:51,160
它将根据--它将调用该函数
and it'll call that function based on-- it'll

1943
01:47:51,160 --> 01:47:57,340
基本上将该StateMachine的当前状态设置为任何状态
basically set the current state of that StateMachine to whatever state

1944
01:47:57,340 --> 01:48:00,050
由该键处的函数返回 
gets returned by the function at that key.

1945
01:48:00,050 --> 01:48:04,717
因此 在本例中 更改将触发返回新标题屏幕状态 
So in this case, change is going to trigger return new TitleScreenState,

1946
01:48:04,717 --> 01:48:06,550
我们将得到--状态机是
and we're going to get-- the StateMachine is

1947
01:48:06,550 --> 01:48:08,620
将设置为标题屏幕 有效地 
going to be set to the title screen, effectively,

1948
01:48:08,620 --> 01:48:12,950
我们马上来看看标题屏幕是什么样子的 
and we'll take a look at what the title screen looks like momentarily.

1949
01:48:12,950 --> 01:48:16,350
在第96行 是的 我们将切换到标题屏幕 
On line 96, yeah, we're changing to title screen.

1950
01:48:16,350 --> 01:48:20,290
在第134行 请注意我们实际上没有太多更新
On line 134, notice that we don't really have much update

1951
01:48:20,290 --> 01:48:22,060
这个应用程序中再也没有逻辑了 
logic in this application anymore.

1952
01:48:22,060 --> 01:48:25,480
我们仍在更新卷轴 因为这是
We're still updating the scrolls because this is

1953
01:48:25,480 --> 01:48:27,280
我们所有州都想要的行为 
behavior we want across all our states.

1954
01:48:27,280 --> 01:48:29,404
无论我们处于什么状态 我们都要确保
No matter what state we're in, we want to make sure

1955
01:48:29,404 --> 01:48:32,830
我们的背景和我们的地面滚动 所以我们有运动 
that our background and our ground scroll so that we have movement.

1956
01:48:32,830 --> 01:48:35,380
我们不需要将此行为状态复制到状态 
We don't need to duplicate this behavior state to state.

1957
01:48:35,380 --> 01:48:37,340
这是我们游戏的一个全球性特征 
This is a global feature of our game.

1958
01:48:37,340 --> 01:48:40,960
所以我们只是像以前一样在这里跟踪它 
So we're just keeping track of it here just as we would before,

1959
01:48:40,960 --> 01:48:44,110
但我们游戏中任何其他需要更新的内容
but anything else in our game that need to be updated

1960
01:48:44,110 --> 01:48:47,620
现在可以推迟到我们的StateMachine类 
can now be deferred to our StateMachine class.

1961
01:48:47,620 --> 01:48:51,490
当我们调用gStateMachine更新增量时间时 
And when we call gStateMachine update delta time,

1962
01:48:51,490 --> 01:48:53,745
它将会看看我们目前的状态是什么 
it's going to look and see what's our current state,

1963
01:48:53,745 --> 01:48:55,870
它将更新这种状态 
and it's going to update that state.

1964
01:48:55,870 --> 01:48:59,270
基本上就是那一大块 如果这块
And that's going to basically be that chunk, that if chunk

1965
01:48:59,270 --> 01:49:02,080
按照我们上个星期做的逻辑来做
do this logic that we were doing from before last week when

1966
01:49:02,080 --> 01:49:05,360
我们有一个更原始的状态机 
we had a more primitive StateMachine.

1967
01:49:05,360 --> 01:49:08,140
第46行 一模一样 
Line 46, same exact thing.

1968
01:49:08,140 --> 01:49:11,470
在背景和地面之间 因为它们将始终渲染场景
Between the background and the ground, because those will always render scene

1969
01:49:11,470 --> 01:49:15,400
要设置场景 我们希望呈现当前的活动状态
to scene, we want to render our current active state

1970
01:49:15,400 --> 01:49:19,120
使用我们的状态机渲染功能 
using our StateMachine render function.

1971
01:49:19,120 --> 01:49:23,410
因此 让我们继续下去 简单地看看我们的状态机程序库 
And so let's go ahead, and just look briefly at our state machine library.

1972
01:49:23,410 --> 01:49:25,420
这是一个非常简单的代码 
It's a very simple code.

1973
01:49:25,420 --> 01:49:29,710
它实际上取自我在课程前面提到的那本书--
It's actually taken from the book I alluded to earlier in the lecture--

1974
01:49:29,710 --> 01:49:31,000
如何制作RPG 
How to Make an RPG.

1975
01:49:31,000 --> 01:49:34,900
他们给了你这个状态机 我认为这真的很干净 
They give you this state machine, which really cleanly, I think,

1976
01:49:34,900 --> 01:49:37,330
处理状态转换 
handles state transition.

1977
01:49:37,330 --> 01:49:40,840
基本上 它需要一个初始化 然后是一系列的状态 
Basically, it takes an init, and then a series of states.

1978
01:49:40,840 --> 01:49:45,440
它有一个空类或空表 
It has an empty class, or empty table.

1979
01:49:45,440 --> 01:49:46,750
所以所有这些都是空的 
So all of these are just empty.

1980
01:49:50,680 --> 01:49:52,840
如果没有--这是你可以做的事情
If there is no-- this is a thing you can do

1981
01:49:52,840 --> 01:49:56,110
在Lua中 它只允许您在变量不是
in Lua, which just lets you initialize a variable if it's not

1982
01:49:56,110 --> 01:49:57,820
在您的函数中给定值 
given a value in your function.

1983
01:50:01,870 --> 01:50:05,090
因此 self.States获得州或某个值 
So self.states gets states or some value.

1984
01:50:05,090 --> 01:50:08,770
这意味着如果州等于假值 则等于零 
Which means that if states is equal to a false value, it's equal to nothing,

1985
01:50:08,770 --> 01:50:10,330
把它放到这张空桌子上 
just set it to this empty table.

1986
01:50:10,330 --> 01:50:14,380
所以这只是一种速记 而不是说如果国家等于零 
So it's just a shorthand for instead of saying if states equals nothing,

1987
01:50:14,380 --> 01:50:16,950
然后将STATES设置为空表 
then set states to empty table.

1988
01:50:16,950 --> 01:50:23,680
Self.Current只是一个空类或空状态 
Self.current is just an empty class or empty state.

1989
01:50:23,680 --> 01:50:26,670
所以这基本上就是一个国家 它只是一套方法--
So this is basically what a state is, it's just a set of methods--

1990
01:50:26,670 --> 01:50:28,780
渲染、更新、进入和退出功能 
a render, update, enter, and exit function.

1991
01:50:28,780 --> 01:50:31,960
这是一种状态 然后你定义所有的行为
That's a state, and then you define all of the behavior

1992
01:50:31,960 --> 01:50:36,060
在这些函数中的每一个中 这或多或少地编译了您的状态 
in each of these functions, and that compiles your state more or less.

1993
01:50:36,060 --> 01:50:39,430
我们的Change函数接受一个名称 然后还有一些可选参数
Our change function takes in a name, and then also some optional parameters

1994
01:50:39,430 --> 01:50:41,080
我们可以用来进入那种状态 
that we can use to enter that state.

1995
01:50:44,280 --> 01:50:48,201
当我们改变状态时 或者调用任何状态的退出函数时
When we change the state, or call the exit function of whatever state

1996
01:50:48,201 --> 01:50:48,700
我们进去了 
we're in.

1997
01:50:48,700 --> 01:50:50,260
所以 退出这个状态吧 
So exit that state.

1998
01:50:50,260 --> 01:50:53,660
也许您的函数需要您释放一些内存 
Maybe your function needs you to de-allocate some memory.

1999
01:50:53,660 --> 01:50:56,530
将电流设置为等于取那个名字 
Set the current equal to taking that name,

2000
01:50:56,530 --> 01:50:58,155
然后调用那里的任何函数 
and then call whatever functions there.

2001
01:50:58,155 --> 01:50:59,154
所以它会回来的 
So it's going to return.

2002
01:50:59,154 --> 01:51:02,530
在这种情况下 我们前面已经看到 它将返回一个新的标题屏幕状态 
In that case, we saw earlier, it's going to return a new title screen state.

2003
01:51:02,530 --> 01:51:05,050
所以这就是现在的情况 
So that's going to be what current is.

2004
01:51:05,050 --> 01:51:09,116
有了self.Current 我们将进入该状态机 
With self.current, we're going to then enter that state machine.

2005
01:51:09,116 --> 01:51:11,740
因此 我们将调用在那里定义的Enter函数
So we're going to call the Enter function that we defined there

2006
01:51:11,740 --> 01:51:17,180
使用我们传递给Change的任何输入参数 这些参数都是可选的 
with whatever enter parameters we pass into change, which are optional.

2007
01:51:17,180 --> 01:51:22,600
然后在这里 StateMachineUpdate只更新当前状态 
And then here, StateMachineUpdate just updates whatever the current state is,

2008
01:51:22,600 --> 01:51:27,140
并且无论当前状态是什么 都会进行渲染更新 
and render updates whatever the current state is as well.

2009
01:51:27,140 --> 01:51:29,962
所以我要开始稍微快一点
And so I'm going to start going a little bit quickly

2010
01:51:29,962 --> 01:51:31,670
就因为我们的时间不多了 
just because we're running short on time.

2011
01:51:31,670 --> 01:51:36,010
BaseState 它所做的只是实现空方法
BaseState, all it does is just implements empty methods

2012
01:51:36,010 --> 01:51:38,809
这样你就可以继承这个状态 而你
so that you can just inherit this state, and you

2013
01:51:38,809 --> 01:51:40,600
可以选择要定义的方法
can choose which methods you want to define

2014
01:51:40,600 --> 01:51:44,046
不会抛出任何错误 因为它会盲目地调用所有这些函数 
without throwing any errors because it blindly will call all these functions,

2015
01:51:44,046 --> 01:51:46,420
没有检查它们是否真正得到了实施 
not checking to see whether they're actually implemented.

2016
01:51:46,420 --> 01:51:50,530
所以这是一种让你快速避免
And so this is a way for you to just quickly avoid

2017
01:51:50,530 --> 01:51:52,960
从本质上讲 是大量的样板代码 
a lot of boilerplate code, essentially.

2018
01:51:52,960 --> 01:52:00,760
这里的标题屏幕状态 这是您处理类库的方式 
The TitleScreenState here, this is your way of with the class library,

2019
01:52:00,760 --> 01:52:04,210
只包括属于BaseState的所有东西 
just including everything that belongs to BaseState.

2020
01:52:04,210 --> 01:52:06,700
所以继承 如果你熟悉其他语言
So inheriting, if you're familiar with other languages

2021
01:52:06,700 --> 01:52:09,730
使用继承--获取一个对象 复制
that use inheritance-- take an object, copy

2022
01:52:09,730 --> 01:52:12,760
把那个物体或那个类的所有东西都放到这个里面 
everything from that object or that class, put it into this one,

2023
01:52:12,760 --> 01:52:14,170
然后再加入新的东西 
and then add new stuff to it.

2024
01:52:14,170 --> 01:52:15,711
这基本上就是继承的含义 
That's basically what inheritance is.

2025
01:52:15,711 --> 01:52:19,090
我们继承了BaseState 因此它具有BaseState的所有功能 
We're inheriting from BaseState so it has all the functions BaseState has,

2026
01:52:19,090 --> 01:52:22,800
最重要的是 我们定义了一个更新函数 
and then on top of that, we're defining an update function.

2027
01:52:22,800 --> 01:52:27,410
因此 如果我们按Enter或Return 则更改全局状态机
So if we press Enter or Return, change the global state machine

2028
01:52:27,410 --> 01:52:28,670
转到播放状态 
to the play state.

2029
01:52:28,670 --> 01:52:31,400
然后对于渲染 我们将渲染50只鸟 
And then for the render, we're just going to render fifty bird,

2030
01:52:31,400 --> 01:52:34,740
然后在屏幕中间按Enter键 
and press Enter halfway in the middle of the screen.

2031
01:52:34,740 --> 01:52:36,620
然后是PlayState 基本上是对一些人来说--
And then the PlayState, essentially to some--

2032
01:52:36,620 --> 01:52:40,850
基本上 PlayState是我们之前运行的所有代码 只是
basically, what the PlayState is is all of the code that we ran before, only

2033
01:52:40,850 --> 01:52:44,330
现在我们只是把它放在这里的更新函数中 
now we're just putting it in the update function here,

2034
01:52:44,330 --> 01:52:49,760
和这里的渲染功能 以及制作鸟、管子对、计时器
and the render function here, and making bird, pipe pairs, timer,

2035
01:52:49,760 --> 01:52:53,642
和此状态对象的最新成员字段 
and lastY member fields of this state object.

2036
01:52:53,642 --> 01:52:55,475
因此 我们将继续 并且运行得非常快 
So we'll go ahead, and run this really fast.

2037
01:53:01,010 --> 01:53:02,410
这是我们的标题屏幕状态 
This is our title screen state.

2038
01:53:02,410 --> 01:53:05,661
因此 在开始时 我们将更改为标题屏幕状态 
So at the very beginning, we change to title screen state.

2039
01:53:05,661 --> 01:53:07,910
它所做的就是渲染 然后是滚动行为
All it does is render, and then the scrolling behavior

2040
01:53:07,910 --> 01:53:10,136
遍及所有班级 所有州 
is throughout all classes, all states.

2041
01:53:10,136 --> 01:53:11,510
无论如何 我们都会看到这一点 
So we'll see that no matter what.

2042
01:53:11,510 --> 01:53:13,460
一旦您按下Enter 它就会触发更改
Once you press Enter, it'll trigger change

2043
01:53:13,460 --> 01:53:17,210
播放 这将返回播放状态 然后
to play, which will return a play state, and then

2044
01:53:17,210 --> 01:53:21,820
现在我们又回到了以前的地方 我们现在看到了不同之处
now we're back where we were before, and we're seeing the difference now

2045
01:53:21,820 --> 01:53:24,140
有几个不同的州 
in having a couple of different states.

2046
01:53:24,140 --> 01:53:27,480
所以快点 我来看一下比分更新 
So quickly, I'll go through the score update.

2047
01:53:27,480 --> 01:53:32,510
所以这比上一个例子稍微复杂一些 
So this is a little bit more complicated than the last example.

2048
01:53:32,510 --> 01:53:36,230
但总而言之 在鸟身上--
But to summarize, in bird--

2049
01:53:36,230 --> 01:53:38,360
对不起 我们坐的是Bird9 
sorry, we're in bird9.

2050
01:53:38,360 --> 01:53:45,350
所以在Bird9中 如果我们去这里 我们将去Main 
So in bird9, if we go here, we're going to go to main.

2051
01:53:45,350 --> 01:53:50,810
请注意 在Main中 下面是我们定义StateMachine的地方 
So notice that in main, down where we define our StateMachine,

2052
01:53:50,810 --> 01:53:54,080
我们将继续进行 还要注意我们需要一个新的分数
we're going to go ahead, and also note that we require a new score

2053
01:53:54,080 --> 01:53:57,810
状态 因为现在我们想要显示分数屏幕 
state because now we want to display a score screen.

2054
01:53:57,810 --> 01:54:05,130
在第96行 Score获得一个函数 我们在该函数中返回一个Score状态对象 
Down on line 96, score gets a function where we return a score state object.

2055
01:54:05,130 --> 01:54:08,960
所以现在我们可以更改为得分 它将返回到那个状态 
So now we can change to score, and it will return that state,

2056
01:54:08,960 --> 01:54:12,320
我们可以定义ScoreState中的所有行为
and we can define all the behavior within ScoreState

2057
01:54:12,320 --> 01:54:16,160
我们需要显示一个分数 
that we need to display a score.

2058
01:54:16,160 --> 01:54:24,140
在PipePair中 我们有一个名为self.core的新变量 
In PipePair, we have a new variable called self.scored.

2059
01:54:24,140 --> 01:54:25,766
将其设置为True或False 
Set it to true or false.

2060
01:54:25,766 --> 01:54:27,640
我们要把它设置为真 如果鸟有
We're going to set it to true if the bird has

2061
01:54:27,640 --> 01:54:31,060
穿过了这对管子的右边缘 
gone past the right edge of the pair of pipes.

2062
01:54:31,060 --> 01:54:34,910
这将使我们有效地得到一分 
That will have the effect of us scoring a point, effectively,

2063
01:54:34,910 --> 01:54:37,460
因为我们要做的就是确保鸟儿们
because all we need to do is just make sure the birds got

2064
01:54:37,460 --> 01:54:39,305
穿过那对管子 否则它
past that pair of pipes because otherwise it

2065
01:54:39,305 --> 01:54:40,430
都会与之相撞 
will have collided with it.

2066
01:54:40,430 --> 01:54:45,980
如果超过了它 将其设置为True 然后在我们的分数上增加一分 
If it does go past it, set it to true, and then add a point to our score.

2067
01:54:45,980 --> 01:54:53,130
在我们的游戏状态下 我们可以看到我们已经添加了一分 
And in our play state, we can see that we've added a point.

2068
01:54:53,130 --> 01:54:57,380
所以如果我们进入我们的播放状态 26是我们实际
So if we go to our play state, 26 is where we actually

2069
01:54:57,380 --> 01:54:58,510
记录我们的分数 
keep track of our score.

2070
01:54:58,510 --> 01:55:00,980
在我们的游戏状态下 Self.Score得0分 
Self.score gets 0 in our play state.

2071
01:55:00,980 --> 01:55:03,530
我们要继续往前走 一直走到第56行 
We're going to go ahead, and go down to line 56.

2072
01:55:03,530 --> 01:55:06,637
因此 对于每一双 如果还没有得分--
So for every pair, if it's not been scored yet--

2073
01:55:06,637 --> 01:55:09,470
因为如果已经打分了 我们就不需要计算了 
because we don't need to calculate this if it's already been scored.

2074
01:55:09,470 --> 01:55:13,460
一旦得分 我们就应该忽略它的得分 
We should ignore it in terms of scoring once it's been scored.

2075
01:55:13,460 --> 01:55:19,520
如果x加宽度小于我们的Bird.x 
If the x plus width is less than our bird.x,

2076
01:55:19,520 --> 01:55:22,820
这意味着我们的鸟在这对管子的右边 
meaning our bird is beyond the right edge of the pair of pipes,

2077
01:55:22,820 --> 01:55:25,190
增加我们的分数 并将该对设置为真 
increment our score, and set that pair to true.

2078
01:55:25,190 --> 01:55:28,237
然后我们会因为这个情况 然后忽略它 
We will then thereafter, because of this condition, ignore it,

2079
01:55:28,237 --> 01:55:30,070
我们还将增加我们的分数 
and we're also going to increment our score.

2080
01:55:30,070 --> 01:55:33,000
因此 它将被记录下来 
So it's going to be kept track of.

2081
01:55:33,000 --> 01:55:36,350
在83号公路上 请注意 如果我们与管道相撞 
On 83, notice that if we're colliding with a pipe,

2082
01:55:36,350 --> 01:55:38,920
我们现在应该转换到我们的得分状态 
we should transition to our score state now.

2083
01:55:38,920 --> 01:55:42,380
我们也会传入自己的分数 分数作为表格
And we're also passing in score gets self.score as a table

2084
01:55:42,380 --> 01:55:45,350
因为请记住 我们可以在调用Change时传入参数 
because remember, we can pass in parameters when we call change,

2085
01:55:45,350 --> 01:55:49,110
这将被传递到我们州的Enter函数中 
and this will be passed into our enter function in our state,

2086
01:55:49,110 --> 01:55:51,260
然后分数就等于自己 
and then score is going to equal self.score.

2087
01:55:51,260 --> 01:55:54,170
我们将有权访问该分数状态内的分数 
We'll have access to the score within that score state.

2088
01:55:54,170 --> 01:55:56,480
我们不必把它作为一个全局变量来跟踪
We don't have to keep track of it as a global variable

2089
01:55:56,480 --> 01:55:59,810
在这两个地方都能看到 
to see it in both locations.

2090
01:55:59,810 --> 01:56:02,360
在93号公路上 同样的事情 
And on 93, the same exact thing.

2091
01:56:02,360 --> 01:56:05,810
这是碰撞 以检查我们是否与屏幕底部发生碰撞 
This is collision to check whether we've collided with the bottom of the screen.

2092
01:56:05,810 --> 01:56:09,530
如果我们的y大于虚拟高度减去15 做完全相同的事情 
If our y is greater than virtual height minus 15, do the exact same thing.

2093
01:56:09,530 --> 01:56:12,440
转换到分数状态 并在当前分数中传递它 
Transition to the score state, and pass it in our current score.

2094
01:56:12,440 --> 01:56:14,540
所以另一个死亡条件 
So another death condition.

2095
01:56:14,540 --> 01:56:17,390
然后104 我们要设置Flappy Font 
And then 104, we're just going to set Flappy Font,

2096
01:56:17,390 --> 01:56:21,206
然后我们将把我们的分数呈现在屏幕左上角的8 8 
and then we're going to render our score at the top left of the screen at 8,8,

2097
01:56:21,206 --> 01:56:23,280
这将会产生这种效果 
and that will have that effect.

2098
01:56:23,280 --> 01:56:26,735
最后 在这里 我们的分数状态非常简单 
And so lastly, here, our scores state is pretty simple.

2099
01:56:29,197 --> 01:56:32,030
我们要做的就是--从我们传入的参数中
All it is is we're going to get-- from those parameters we passed in

2100
01:56:32,030 --> 01:56:35,540
更改后 self.core等于pars.core 
by a change, self.score equals params.score.

2101
01:56:35,540 --> 01:56:38,270
我们要 当我们按回车键的时候 回到游戏中 
We're going to, when we press Enter, go back to play,

2102
01:56:38,270 --> 01:56:42,170
然后我们将呈现“You Lost” 然后是分数 
and then we're going to render 'you lost', and the score,

2103
01:56:42,170 --> 01:56:45,320
我们可以访问它--self.core 然后按Enter键再次播放 
which we have access to-- self.score, and then press Enter to play again,

2104
01:56:45,320 --> 01:56:46,980
在此过程中更改字体 
changing fonts along the way.

2105
01:56:46,980 --> 01:56:51,650
因此 如果我们回到Bird9 我们运行这个 
And so if we go back to bird9, and we run this,

2106
01:56:51,650 --> 01:56:54,380
请注意 现在我们在左上角有一个分数 
notice that now we have a score in the top left.

2107
01:56:54,380 --> 01:57:01,220
我只得一分 然后就死定了 
And I'm going to get one point, and then die.

2108
01:57:01,220 --> 01:57:03,220
然后我们现在进入计分屏幕 
Then we go to our score screen now.

2109
01:57:03,220 --> 01:57:07,180
记住 我们从我们的Play状态向它传递了分数 
Remember, we passed score into it from our play state.

2110
01:57:07,180 --> 01:57:13,240
我们将其作为参数传递 然后我们
We passed it in as parameters, and then we

2111
01:57:13,240 --> 01:57:16,550
可以再次按回车键 返回播放状态 当我们倒地时 
can press Enter again, go back to play state, and when we fall to the ground,

2112
01:57:16,550 --> 01:57:17,540
我们也是这么做的 
we do it as well.

2113
01:57:17,540 --> 01:57:21,610
我们刚刚看了一下如何在我们的比赛中增加得分 
So we've just taken a look at how to add scoring to our game,

2114
01:57:21,610 --> 01:57:24,070
但是 如果我们想要添加一个倒计时屏幕呢？
but what if we want to add a count down screen?

2115
01:57:24,070 --> 01:57:28,810
也许我们希望在实际比赛之前提示用户三、二、一
Maybe we want the users to be prompted three, two, one before the actual game

2116
01:57:28,810 --> 01:57:30,660
开始向他们扔烟斗 
starts throwing pipes at them.

2117
01:57:30,660 --> 01:57:32,752
给他们时间让他们适应环境 
Give them the time to sort of get acclimated.

2118
01:57:32,752 --> 01:57:34,710
我们将继续下去 看看如何
We're going to go ahead, and take a look at how

2119
01:57:34,710 --> 01:57:38,870
我们可以使用与上一个示例非常类似的另一个状态来完成此操作 
we might do this using another state very similar to the last example.

2120
01:57:38,870 --> 01:57:41,350
我们将添加一个名为Countdown State的新州 
We're going to add a new state called CountdownState,

2121
01:57:41,350 --> 01:57:44,350
它显示在这里的第38行 
which is shown here on line 38.

2122
01:57:44,350 --> 01:57:47,590
我们还将在我们的状态机中 
We're also going to, down in our state machine,

2123
01:57:47,590 --> 01:57:51,899
添加一个新的键 它返回一个新的倒计时状态 就像以前一样 
add a new key, which returns one of the new countdown states, just as before,

2124
01:57:51,899 --> 01:57:54,940
然后我们将继续 看看我们的实际倒计时
and then we're going to go ahead, and take a look at our actual countdown

2125
01:57:54,940 --> 01:57:56,180
请在此说明 
state here.

2126
01:57:56,180 --> 01:58:04,510
因此 在我们的Countdown State.Lua中 与其他文件夹一样 它位于我们的States文件夹中 
So in our CountdownState.lua, which is in our states folder, as the others,

2127
01:58:04,510 --> 01:58:06,460
它继承自BaseState 
it inherits from BaseState.

2128
01:58:06,460 --> 01:58:09,160
我们已经将倒计时时间初始设置为0.75 
We have initialized a countdown time to 0.75.

2129
01:58:09,160 --> 01:58:10,700
这一次是在几秒钟内 
This time in seconds.

2130
01:58:10,700 --> 01:58:14,170
一秒太长了 所以我把它改成了0.75秒 
One second is a little long, so I made it 0.75 seconds.

2131
01:58:14,170 --> 01:58:16,810
我们将把计数初始化为3 将计时器初始化为0 
We're going to initialize a count to three, and a timer to 0.

2132
01:58:16,810 --> 01:58:18,130
点票就要开始了 
The count's going to start.

2133
01:58:18,130 --> 01:58:22,540
一旦倒计时过去 它就会使用计时器 
It's going to use a timer once the countdown time has elapsed,

2134
01:58:22,540 --> 01:58:24,040
就在这里 正如这个逻辑所示 
right here, as this logic shows.

2135
01:58:24,040 --> 01:58:27,530
一旦计时器超过倒计时时间 就增加计时器 
Increase the timer once the timer has gone past countdown time.

2136
01:58:27,530 --> 01:58:29,960
我们想要继续 并将其设置为--
We want to go ahead, and set it to--

2137
01:58:29,960 --> 01:58:31,630
我们要通过倒计时来取模 
we're going to modulo by countdown time.

2138
01:58:31,630 --> 01:58:34,930
所以循环返回到0加上超过倒计时时间的任何值
So loop it back to 0 plus whatever amount beyond the countdown time

2139
01:58:34,930 --> 01:58:38,740
我们去了 这样我们就能顺畅地追踪时间 
we went so that we have a smooth track of time.

2140
01:58:38,740 --> 01:58:41,650
我们将自己设定 计数减去它自己
We're going to set self.count minus itself

2141
01:58:41,650 --> 01:58:44,290
乘以1 我们就是3 2 1 
by 1 so that we go three, two, one.

2142
01:58:44,290 --> 01:58:46,632
如果我们的计数是0 这意味着我们已经
And then if our count is 0, which means that we've

2143
01:58:46,632 --> 01:58:48,340
在我们的统计中一路下降 我们是
gone all the way down in our count, we're

2144
01:58:48,340 --> 01:58:51,640
继续使用我们的状态机 并更改为Play状态 
going to go ahead and use our state machine, and change to the play state.

2145
01:58:51,640 --> 01:58:54,098
在这里 我们将字体设置为我们设置的字体--
And here, we're setting our font to a font that we've set--

2146
01:58:54,098 --> 01:58:56,770
HugeFont--然后我们就是两条线了 
hugeFont-- and then we're just twostring,

2147
01:58:56,770 --> 01:58:59,320
一个接受字符串或数字的小函数 
a little function that takes a string, or takes a number,

2148
01:58:59,320 --> 01:59:00,420
转换为字符串 
converts to a string.

2149
01:59:00,420 --> 01:59:05,110
我们在显示自己 数到0,120 然后我们的.
We're displaying self.count at 0, 120, and then our--

2150
01:59:05,110 --> 01:59:06,115
它是print tf 
it's printf.

2151
01:59:06,115 --> 01:59:10,814
所以我们基本上从0开始 y 120 虚拟宽度对齐 
So we're basically starting at 0, y 120, virtual width alignment,

2152
01:59:10,814 --> 01:59:11,980
然后我们把它放在中心 
and then we're centering it.

2153
01:59:11,980 --> 01:59:15,520
所以我们需要改变的最后一件事
So the one last piece of that that we need to change

2154
01:59:15,520 --> 01:59:21,010
处于标题屏幕状态 而不是直接进入播放状态
is in our title screen state, instead of going straight to a play state

2155
01:59:21,010 --> 01:59:24,070
在第15行 我们将进入倒计时状态 
here on line 15, we're going to a countdown state.

2156
01:59:24,070 --> 01:59:29,710
这样做的效果是 如果我们进入鸟10号 
And what this has the effect of doing, if we go into bird10,

2157
01:59:29,710 --> 01:59:34,300
就是当我们按回车键时 注意我们要走三 二 一 
is when we press Enter, notice that we're going three, two, one,

2158
01:59:34,300 --> 01:59:35,769
然后进入我们的游戏状态 
then going into our play state.

2159
01:59:35,769 --> 01:59:37,560
不仅仅是直接进入播放状态
Not just going straight into the play state

2160
01:59:37,560 --> 01:59:40,990
和以前一样 给我们的用户一点时间喘口气 
as before, giving our user a little bit of time to catch their breath.

2161
01:59:40,990 --> 01:59:45,370
如果我们死了 我们就会进入得分状态 但一旦我们按下Enter键 
And then if we die, we go to our score state, but once we press Enter,

2162
01:59:45,370 --> 01:59:48,320
请注意 我们也在这样做 
notice we're doing that as well.

2163
01:59:48,320 --> 01:59:53,450
因此 在我们的得分状态下 我们也将切换到倒计时状态 
So in our score state, we also are changing to the countdown state.

2164
01:59:53,450 --> 01:59:55,510
这就是如何建立一个倒计时状态 
So that was how to make a countdown state.

2165
01:59:55,510 --> 01:59:58,720
在这些例子中 可能我最喜欢的部分 就是这个例子
Probably my favorite part of many of these examples, and of this example

2166
01:59:58,720 --> 02:00:02,680
也是将音频添加到我们的应用程序中 
as well, is adding audio to our application.

2167
02:00:02,680 --> 02:00:05,306
音乐和音效 这真的将一切联系在一起 
Music and sound effects, which really ties everything together.

2168
02:00:05,306 --> 02:00:07,430
所以我们要继续 看看这个 
So we're going to go ahead and take a look at this.

2169
02:00:07,430 --> 02:00:08,290
这很简单 
It's very simple.

2170
02:00:08,290 --> 02:00:12,400
和我们上周学到的非常相似 甚至是我们刚练乒乓球的时候 
Very similar to what we learned last week, even when we just did Pong.

2171
02:00:12,400 --> 02:00:18,490
因此 在Bird11的主要流星中 这就是我们现在要看到的 
So in main.lua of bird11, which is what we're going to look at now,

2172
02:00:18,490 --> 02:00:22,390
我们要看一张音表
we're going to take a look at a table of sounds

2173
02:00:22,390 --> 02:00:24,580
我们已经在第88行进行了初始化 
that we've initialized on line 88.

2174
02:00:24,580 --> 02:00:26,230
我们已经给了他们所有的钥匙 
We've given them all keys.

2175
02:00:26,230 --> 02:00:28,160
跳跃 爆炸 受伤 得分 
Jump, explosion, hurt, score.

2176
02:00:28,160 --> 02:00:31,870
这些都是我用BFX程序生成的音效
These are all sound effects that I've generated with the BFX program

2177
02:00:31,870 --> 02:00:33,610
如果你还记得的话 我们上周用过的 
that we used last week, if you recall.

2178
02:00:33,610 --> 02:00:35,650
然后是我在网上找到的一首音乐曲目
And then a music track that I found online

2179
02:00:35,650 --> 02:00:38,440
在免费声音上 这是免费使用的 
on FreeSound, which is free to use.

2180
02:00:38,440 --> 02:00:40,345
如果好奇的话 这里有联系 
The link is here, if curious.

2181
02:00:40,345 --> 02:00:46,450
这只是一个很好的 快乐的配乐 我发现这个游戏 
It's just a nice, happy soundtrack that I found for this game.

2182
02:00:46,450 --> 02:00:49,510
在第99行到第100行 我们要做一个额外的步骤
On line 99 to 100, we're going to do one additional step

2183
02:00:49,510 --> 02:00:50,890
在我们开始音乐之前
before we start the music.

2184
02:00:50,890 --> 02:00:52,930
我们要将循环设置为true
We're going to set looping on that to true

2185
02:00:52,930 --> 02:00:55,930
因为在这样的无限博弈中
because in games that are infinite like this,

2186
02:00:55,930 --> 02:00:59,200
我们不想让我们的音乐就这么走了 然后突然停止 
we don't want our music to just go, and then stop abruptly.

2187
02:00:59,200 --> 02:01:03,370
我们想让它循环播放 
We want to have it loop.

2188
02:01:03,370 --> 02:01:05,220
将循环设置为true 
Set looping to true.

2189
02:01:05,220 --> 02:01:08,620
我实际上是在我们任何一个州之外开始演奏这种音乐的
I actually begin the play of that music outside of any of our states

2190
02:01:08,620 --> 02:01:14,060
因为这将是一个全球性的音乐轨道 然后这就是音乐 
because it's going to be a global music track, and then that's the music.

2191
02:01:14,060 --> 02:01:15,430
我们还需要音效 
We also need sound effects.

2192
02:01:18,340 --> 02:01:22,480
如果我们看一下鸟的档案第45行 
If we look in our bird file here line 45, which

2193
02:01:22,480 --> 02:01:26,020
我们有跳跃的逻辑 
is where we have the logic for jumping, we're

2194
02:01:26,020 --> 02:01:30,400
同时播放我们生成的跳跃音效 
also playing the jump sound effect that we've generated.

2195
02:01:30,400 --> 02:01:34,080
另外 在我们的游戏状态下 如果我们看一下那里 
Additionally, in our play state, if we take a look there,

2196
02:01:34,080 --> 02:01:36,520
我们可以在这里的州文件夹中查看 
we can go ahead and see in our states folder here.

2197
02:01:36,520 --> 02:01:42,040
去玩状态 看看第58行 
Go to play state, and take a look at line 58.

2198
02:01:42,040 --> 02:01:43,570
这是我们得分的地方 
This is where we score a point.

2199
02:01:43,570 --> 02:01:46,630
所以我们应该在这里播放配乐音效 简单地说 
So we should play our score sound effects here, simply put.

2200
02:01:46,630 --> 02:01:49,900
然后在第80到81行也是一样的 
And then the same thing on line 80 to 81,

2201
02:01:49,900 --> 02:01:52,720
碰撞 这里的声音效果 实际上我们
collide, the sound effect here, which is we're actually

2202
02:01:52,720 --> 02:01:55,840
把两个声音叠加在一起 这是很常见的 
layering two sounds on top of each other, which is a common thing

2203
02:01:55,840 --> 02:01:57,940
在声音设计和游戏设计中的应用 
to do in sound design, and game design.

2204
02:01:57,940 --> 02:02:01,857
一个声音 往往是不是所有你需要完成一个特定的效果 
One sound, often, isn't all you need to accomplish a particular effect.

2205
02:02:01,857 --> 02:02:04,690
所以我听到了爆炸声 这是一种白噪音效果 
So I have an explosion sound, which is kind of a white noise effect,

2206
02:02:04,690 --> 02:02:10,190
然后是一种伤害的声音效果 有点像向下的正弦波
and then a hurt sound effect, which is sort of like a downward sine wave

2207
02:02:10,190 --> 02:02:10,960
声音的类型 
type of sound.

2208
02:02:10,960 --> 02:02:14,140
95到96年的情况也是一样 
It would be the exact same here on 95 to 96.

2209
02:02:14,140 --> 02:02:17,560
一旦我们把所有这些拼在一起 我们就可以开始了 
Once we put all these pieces together, we're going to run bird11.

2210
02:02:17,560 --> 02:02:18,520
[音乐播放]
[MUSIC PLAYING]

2211
02:02:18,520 --> 02:02:19,230
我们有音乐 
We get music.

2212
02:02:23,038 --> 02:02:24,040
[哔哔声]
[BEEPING]

2213
02:02:24,040 --> 02:02:28,165
我们得到一个跳跃的声音效果 
We get a jump sound effect.

2214
02:02:28,165 --> 02:02:31,362
当我们得了一分 
And when we score a point,

2215
02:02:31,362 --> 02:02:32,760
[叮]
[DING]

2216
02:02:32,760 --> 02:02:34,110
我们得到了另一种声音效果 
we get another sound effect.

2217
02:02:34,110 --> 02:02:35,020
[碰撞]
[CRASH]

2218
02:02:35,020 --> 02:02:38,330
如果我们碰到一个管道 请注意 
And then if we hit a pipe, notice that we have a sort of

2219
02:02:38,330 --> 02:02:39,002
[模仿噪音]
[MIMICS NOISE]

2220
02:02:39,002 --> 02:02:42,790
和白噪声或爆炸效果叠加在一起 
and a white noise or an explosion effect layered together.

2221
02:02:42,790 --> 02:02:47,710
所以这就把所有的东西都结合在一起了 创造性的和艺术性的 
So that sort of brings everything together, creatively and artistically.

2222
02:02:47,710 --> 02:02:50,970
作为对观众的练习 在bird12中 
As an exercise to the viewer, in bird12--

2223
02:02:50,970 --> 02:02:52,900
在GitHub存储库中 我们有一些代码
in the GitHub repo, we have some code that

2224
02:02:52,900 --> 02:02:55,652
允许您实际将鼠标点击添加到Flappy Bird
allows you to actually add mouse clicks to the Flappy Bird

2225
02:02:55,652 --> 02:02:58,360
为了让它更像真正的游戏 
in order to make it a little bit more like the actual game, which

2226
02:02:58,360 --> 02:02:59,380
是一款iOS游戏 
was an iOS game.

2227
02:02:59,380 --> 02:03:01,720
所以它依赖于水龙头 
So it relied on taps.

2228
02:03:01,720 --> 02:03:06,040
您可能想要使用的功能是Love 鼠标按下x y 按钮 
The function that you might want to use is love.mousepressed x, y, button,

2229
02:03:06,040 --> 02:03:09,010
我鼓励你们思考我们是如何接受意见 并做出
and I would encourage you to think about how we took input, and made

2230
02:03:09,010 --> 02:03:12,970
在我们前面的一个例子中 它在键盘的上下文中是全局的
it global in the context of a keyboard in one of our earlier examples

2231
02:03:12,970 --> 02:03:20,140
所以我们可以称之为 这是在我们的Bird.Lua文件中按下的鼠标 
so that we can call this was the mouse just pressed in our bird.lua file,

2232
02:03:20,140 --> 02:03:22,150
而不是主文件 
as opposed to the main file.

2233
02:03:22,150 --> 02:03:24,920
因此 下一次 我们将介绍一些新概念 
And so next time, we're going to be covering a few new concepts.

2234
02:03:24,920 --> 02:03:26,140
或者精灵床单 
Or sprite sheets.

2235
02:03:26,140 --> 02:03:30,910
所以拿出一个大的图像文件 然后取出其中的一大块
So taking a large file of images, and taking out chunks of that

2236
02:03:30,910 --> 02:03:33,250
因此 我们不必拥有一百万个图形文件 
so we don't have to have a million graphic files.

2237
02:03:33,250 --> 02:03:34,379
程序布局 
Procedural layouts.

2238
02:03:34,379 --> 02:03:36,420
这将在游戏Breakout的背景下进行 
This will be in the context of the game Breakout.

2239
02:03:36,420 --> 02:03:40,082
所以我们想要在我们的游戏中铺开所有的砖块 在程序上 
So we want to lay out all the bricks in our game, procedurally,

2240
02:03:40,082 --> 02:03:42,040
在某种程度上 我们在程序上
in sort of the same way that we've procedurally

2241
02:03:42,040 --> 02:03:45,220
在这个游戏中创造了一个管道水平线 
created a pipe level in this game.

2242
02:03:45,220 --> 02:03:47,530
我们将讨论不同的级别 并拥有
We'll be talking about separate levels, and having

2243
02:03:47,530 --> 02:03:50,950
它们存储在内存中 而不是只有一个连续的级别 
them stored in memory as opposed to just one continuous level.

2244
02:03:50,950 --> 02:03:52,384
我们将谈论健康问题 
We'll be talking about health.

2245
02:03:52,384 --> 02:03:55,300
我们将讨论粒子系统 它正在催生小迷你
We'll be talking about particle systems, which is spawning little mini

2246
02:03:55,300 --> 02:03:59,170
图形来实现其他方式很难捕捉的各种效果
graphics to accomplish various effects that are otherwise difficult to capture

2247
02:03:59,170 --> 02:04:01,780
在简单的精灵动画中 
in simple sprite animation.

2248
02:04:01,780 --> 02:04:04,570
基于输入的碰撞检测稍微更花哨一点
A little bit fancier collision detection based on input

2249
02:04:04,570 --> 02:04:07,792
这样我们就能以我们想要的方式驱动球的行为 
so that we can drive ball behavior the way we want to,

2250
02:04:07,792 --> 02:04:09,250
然后还永久保存数据 
and then also persistent save data.

2251
02:04:09,250 --> 02:04:11,440
我们怎么能拿到高分 而不是
How can we take a high score, and not have

2252
02:04:11,440 --> 02:04:15,670
每次我们运行应用程序时 它都会刷新为0 但会将其保存到磁盘
it refresh to 0 every time we run the application, but rather save it to disk

2253
02:04:15,670 --> 02:04:18,310
所以以后每次运行程序时 我们都可以看到
so that every time you run the program thereafter, we can see

2254
02:04:18,310 --> 02:04:21,400
我们在过去几天里得到的分数 
what we've gotten scored in days past.

2255
02:04:21,400 --> 02:04:24,910
第一个赋值 或其他第二个赋值 赋值一 
The first assignment, or other the second assignment, assignment one,

2256
02:04:24,910 --> 02:04:27,520
会比过去几周稍微复杂一些 
is going to be a little bit more complicated than last weeks,

2257
02:04:27,520 --> 02:04:28,970
但仍相当可行 
but still fairly doable.

2258
02:04:28,970 --> 02:04:31,940
让管道间隙稍微随机一些 这是其中的第一个组成部分 
Make pipe gaps slightly random, being the first component of this.

2259
02:04:31,940 --> 02:04:34,240
因此 以前 管道间隙被设置为常量值 
So before, a pipe gap was set to a constant value.

2260
02:04:34,240 --> 02:04:36,190
也许让它成为某种随机值 
Maybe make it some sort of random value.

2261
02:04:36,190 --> 02:04:37,360
管道间距也是如此 
Pipe intervals as well.

2262
02:04:37,360 --> 02:04:38,860
所以我们每隔两秒就产卵一次 
So we're spawning every two seconds.

2263
02:04:38,860 --> 02:04:40,651
也许我们想要改变这一点 制造管道
Maybe we want to change that up, make pipes

2264
02:04:40,651 --> 02:04:44,020
产卵略有不同 更零星一些 
spawn a little differently, a little more sporadically.

2265
02:04:44,020 --> 02:04:46,330
这项任务的更复杂的方面
The more complicated aspect of this assignment

2266
02:04:46,330 --> 02:04:49,150
将根据运动员的表现授予他们一枚奖牌 
is going to be awarding players a medal based on their performance.

2267
02:04:49,150 --> 02:04:52,060
所以可能会有一枚铜牌、一枚银牌和一枚金牌--
So have maybe a bronze, a silver, and a gold medal--

2268
02:04:52,060 --> 02:04:55,930
除了他们的分数外 您还可以在分数屏幕中显示的图像
an image that you display in the score screen in addition to just their score

2269
02:04:55,930 --> 02:04:58,602
只是为了给他们一点个人反馈 
just to give them a little bit of personal feedback,

2270
02:04:58,602 --> 02:05:01,060
让他们觉得自己的努力是有回报的 并让他们
and make them feel rewarded for their effort, and make them

2271
02:05:01,060 --> 02:05:03,640
争取拿到最后一块奖牌 
strive to get that last medal.

2272
02:05:03,640 --> 02:05:06,640
最后 您将实现暂停功能 我们已经讨论过了
And then lastly, you'll implement a pause feature, which we talked about

2273
02:05:06,640 --> 02:05:11,170
例如 当你按下p键时 游戏就会停止 
in class, so that when you press, for example, the key p, the game will stop.

2274
02:05:11,170 --> 02:05:13,720
但与这个例子不同的是 当我们再次按p时 
But unlike that example, when we press p again,

2275
02:05:13,720 --> 02:05:16,990
比赛应该继续进行 就像它之前的状态一样 
the game should resume just as it was in its prior state.

2276
02:05:16,990 --> 02:05:19,154
所以 Flappy Bird就是这样了 
So that will be it for Flappy Bird.

2277
02:05:19,154 --> 02:05:20,320
下次再见了 
I'll see you guys next time.

2278
02:05:20,320 --> 02:05:22,170
非常感谢 
Thanks a lot.
