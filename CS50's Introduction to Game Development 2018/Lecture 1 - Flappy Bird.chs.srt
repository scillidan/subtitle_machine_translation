1
00:00:16,660 --> 00:00:18,000
科尔顿·奥格登：大家好 

2
00:00:18,000 --> 00:00:21,740
我的名字是科尔顿·奥格登 这是GD50第一课 

3
00:00:21,740 --> 00:00:24,480
今天我们将报道Flappy Bird 

4
00:00:24,480 --> 00:00:27,810
所以去年或上周 抱歉 我们报道了乒乓球 

5
00:00:27,810 --> 00:00:30,730
这只是基本的形状和颜色 

6
00:00:30,730 --> 00:00:32,640
今天 我们将真正潜入精灵之中 

7
00:00:32,640 --> 00:00:35,010
正如我们在这里看到的 我们有一些管子和一只鸟 

8
00:00:35,010 --> 00:00:39,540
我们还讨论了其他一些概念 如重力等 

9
00:00:39,540 --> 00:00:43,140
今天 我们将涵盖的主题简而言之就是图像和精灵 

10
00:00:43,140 --> 00:00:43,860
就像我刚才说的 

11
00:00:43,860 --> 00:00:46,530
因此 从我们的硬盘中加载内存中的图像 

12
00:00:46,530 --> 00:00:50,040
并将它们绘制到屏幕上 而不仅仅是矩形 

13
00:00:50,040 --> 00:00:50,825
诸如此类的 

14
00:00:50,825 --> 00:00:52,560
我们将覆盖无限滚动 

15
00:00:52,560 --> 00:00:55,170
所以 如果你玩过这个游戏 

16
00:00:55,170 --> 00:00:57,690
管道无限地从右向左延伸 

17
00:00:57,690 --> 00:01:00,240
如何真正让它无限地进行 这样我们就不会

18
00:01:00,240 --> 00:01:02,910
也会耗尽无限的内存 

19
00:01:02,910 --> 00:01:05,489
我们将以类似的方式讨论游戏是如何

20
00:01:05,489 --> 00:01:10,710
是幻觉 从某种意义上说 许多感知到的浩瀚和感知

21
00:01:10,710 --> 00:01:14,520
游戏的复杂性往往只是由于相机的诡计 

22
00:01:14,520 --> 00:01:17,650
更多的原因是有限的硬件 

23
00:01:17,650 --> 00:01:19,860
我们将介绍程序生成 它

24
00:01:19,860 --> 00:01:21,854
纽带还可以无限滚动 

25
00:01:21,854 --> 00:01:24,770
程序生成其实是我非常感兴趣的一个话题 

26
00:01:24,770 --> 00:01:27,720
并将在整个课程中在几个地点涉及到它 

27
00:01:27,720 --> 00:01:32,190
但在今天的演讲中 我们将用它来制作管道

28
00:01:32,190 --> 00:01:34,966
因为管子 它们在Flappy Bird中从右到左繁殖

29
00:01:34,966 --> 00:01:36,840
当你无限地通过关卡的时候 

30
00:01:36,840 --> 00:01:39,900
但它们可以在不同的高度产卵 

31
00:01:39,900 --> 00:01:44,640
正因为如此而移动 因此创造了这个无限的水平 

32
00:01:44,640 --> 00:01:46,744
我们将更详细地讨论状态机 

33
00:01:46,744 --> 00:01:49,410
因此 上周我们以非常抽象的方式介绍了状态机 

34
00:01:49,410 --> 00:01:53,040
我们基本上只使用一个字符串作为变量 然后使用if条件 

35
00:01:53,040 --> 00:01:55,170
今天我们将实际使用状态机

36
00:01:55,170 --> 00:01:57,870
用各种方法填充的类 这些方法允许

37
00:01:57,870 --> 00:02:00,210
美国在这些州的进进出出

38
00:02:00,210 --> 00:02:02,700
干净利落地 让我们打破所有这些逻辑

39
00:02:02,700 --> 00:02:05,700
我们以前在更新和渲染函数中拥有的 

40
00:02:05,700 --> 00:02:09,600
然后把它们分别放在各自的州立班级中 

41
00:02:09,600 --> 00:02:12,060
最后 我们还将讨论鼠标输入 

42
00:02:12,060 --> 00:02:15,010
还有一点是我忘了在这里提的 

43
00:02:15,010 --> 00:02:20,070
哎呀 我们还会讨论音乐 这基本上就是

44
00:02:20,070 --> 00:02:21,960
听起来像我们上周做的那样 

45
00:02:21,960 --> 00:02:24,369
但我们将添加这一点作为润色 

46
00:02:24,369 --> 00:02:26,160
如果你们想下载演示代码的话 

47
00:02:26,160 --> 00:02:31,410
我们现在在GitHub/Games50/五十鸟上有回购 

48
00:02:31,410 --> 00:02:34,440
这是我们对Flappy Bird的看法 

49
00:02:34,440 --> 00:02:36,700
有几件事 我被问了几次

50
00:02:36,700 --> 00:02:39,170
我们是否有这门课程的阅读材料 

51
00:02:39,170 --> 00:02:40,920
而且没有正式的阅读材料 

52
00:02:40,920 --> 00:02:42,961
但有几个资源我真的

53
00:02:42,961 --> 00:02:46,890
我喜欢阅读 尤其是在我对Lua和Love2D有了更多了解的时候 

54
00:02:46,890 --> 00:02:48,720
这是两本书 

55
00:02:48,720 --> 00:02:49,800
一种是在线图书 

56
00:02:49,800 --> 00:02:52,470
事实上 它们都是在线书籍 但后者

57
00:02:52,470 --> 00:02:54,180
也有一种物质形式 

58
00:02:54,180 --> 00:02:57,360
第一个是丹·肖勒所著的如何制作RPG 它

59
00:02:57,360 --> 00:02:59,820
实际上完全是用Lua编写的 

60
00:02:59,820 --> 00:03:03,330
他使用的定制游戏引擎非常类似于Love2D 

61
00:03:03,330 --> 00:03:04,910
但这是他亲笔写的 

62
00:03:04,910 --> 00:03:07,629
但很多相同的想法都适用 这是一个很好的机会 

63
00:03:07,629 --> 00:03:09,420
这就是我对Lua咬牙的方式 我会

64
00:03:09,420 --> 00:03:12,669
如果你对此感兴趣 鼓励你去看一看 

65
00:03:12,669 --> 00:03:14,310
或者如果你喜欢RPG的话 

66
00:03:14,310 --> 00:03:17,070
然后是Robert Nystrom的游戏编程模式

67
00:03:17,070 --> 00:03:20,220
是一款非常棒的通用游戏开发

68
00:03:20,220 --> 00:03:23,820
这本书谈到了许多更抽象的高级概念

69
00:03:23,820 --> 00:03:25,440
伴随着大规模的游戏开发 

70
00:03:25,440 --> 00:03:27,006
但除此之外 没有正式的阅读 

71
00:03:27,006 --> 00:03:28,380
这些也不是从阅读中获得的 

72
00:03:28,380 --> 00:03:29,730
这些只是如果你好奇的话 你

73
00:03:29,730 --> 00:03:32,146
我想读一些我觉得很有趣的资源 

74
00:03:32,146 --> 00:03:33,300
请随意这样做 

75
00:03:33,300 --> 00:03:36,660
今天的目标是实现看起来像这样的东西 

76
00:03:36,660 --> 00:03:39,150
这是我们的飞鸟版本 

77
00:03:39,150 --> 00:03:41,790
出于版权目的 我们并没有使用完全相同的精灵 

78
00:03:41,790 --> 00:03:45,640
但我们注意到 屏幕中央有一只鸟 

79
00:03:45,640 --> 00:03:49,410
这只鸟 点击一下 或者在空格键上 会跳上跳下 

80
00:03:49,410 --> 00:03:51,660
你的目标是防止这只鸟碰到

81
00:03:51,660 --> 00:03:55,380
要么是管道 要么是地面本身 

82
00:03:55,380 --> 00:03:58,920
每次你通过一对管子 你就得一分 

83
00:03:58,920 --> 00:04:01,590
你一碰烟斗或落地 游戏就结束了 

84
00:04:01,590 --> 00:04:03,700
就是这样 

85
00:04:03,700 --> 00:04:05,907
所以今天我们将会报道--

86
00:04:05,907 --> 00:04:07,740
我将进行更多的实时编码 

87
00:04:07,740 --> 00:04:09,750
所以我想要介绍的第一个例子

88
00:04:09,750 --> 00:04:12,660
是Flappy Bird的零日更新 

89
00:04:12,660 --> 00:04:15,540
一个重要的功能可能是

90
00:04:15,540 --> 00:04:18,149
最引人注目 最明显的功能 我们将

91
00:04:18,149 --> 00:04:23,010
在整个演讲中使用的是love.graph ics.newImage 

92
00:04:23,010 --> 00:04:24,360
它走的是一条路 

93
00:04:24,360 --> 00:04:28,320
这个功能 它所做的就是从你的磁盘上加载一个图像文件 

94
00:04:28,320 --> 00:04:32,640
您将其指定为字符串 然后可以将其用作对象 

95
00:04:32,640 --> 00:04:35,250
并在XY坐标下绘制任意位置 

96
00:04:35,250 --> 00:04:37,210
我们将在这里的实践中看到这一点 

97
00:04:37,210 --> 00:04:38,550
所以我要继续了 

98
00:04:38,550 --> 00:04:42,280
如果你在回购中查看 所有这些例子都有涵盖--

99
00:04:42,280 --> 00:04:44,640
0到12 

100
00:04:44,640 --> 00:04:48,210
我将在我创建的新文件夹中从头开始 

101
00:04:48,210 --> 00:04:53,250
我要创造一个全新的Main Lua 完全新鲜 

102
00:04:53,250 --> 00:04:57,000
我想做的第一件事是因为我们

103
00:04:57,000 --> 00:04:59,970
就像我们上周做的那样 使用虚拟分辨率 

104
00:04:59,970 --> 00:05:01,860
为了让我们有更多的修辞 我要走了

105
00:05:01,860 --> 00:05:03,568
继续执行并需要推送库 

106
00:05:03,568 --> 00:05:05,570
因此 推动平等是必要的 

107
00:05:05,570 --> 00:05:06,720
就像这样推 

108
00:05:06,720 --> 00:05:09,780
我已将pres.lua预先放入此目录中 

109
00:05:09,780 --> 00:05:12,240
默认情况下 它将加载到相同的目录中--

110
00:05:12,240 --> 00:05:15,724
运行Love时脚本的当前工作目录 

111
00:05:15,724 --> 00:05:18,515
接下来我要做的是 定义一些常量 

112
00:05:18,515 --> 00:05:23,910
所以窗宽应该是1280 然后窗高是720 

113
00:05:23,910 --> 00:05:26,100
这些是我们的物理窗户尺寸 

114
00:05:26,100 --> 00:05:30,960
但我们还需要一个虚拟宽度 我们将使用512乘以288 

115
00:05:30,960 --> 00:05:35,040
我发现这一解决方案对我们的资产非常有效

116
00:05:35,040 --> 00:05:38,970
现在就用 但你可以把它做成任何你想要的东西

117
00:05:38,970 --> 00:05:40,570
因为它在这个范围内的某个地方 

118
00:05:40,570 --> 00:05:43,260
它的分辨率也是16x9 所以很舒服

119
00:05:43,260 --> 00:05:48,362
在现代宽屏16x9显示器上 

120
00:05:48,362 --> 00:05:51,390
我们要做的是我们今天的第一个目标

121
00:05:51,390 --> 00:05:55,530
就是在屏幕上绘制两个图像 

122
00:05:55,530 --> 00:05:58,020
我们想要前景和背景 因为注意到 

123
00:05:58,020 --> 00:06:01,540
如果我们回到幻灯片上 我们可以在背景中看到

124
00:06:01,540 --> 00:06:08,700
我们有一个山丘景观 然后在底部我们有一个地面 

125
00:06:08,700 --> 00:06:12,150
这两家公司最终将以不同的速度滚动 

126
00:06:12,150 --> 00:06:14,396
它将被称为视差滚动 但只是

127
00:06:14,396 --> 00:06:16,770
对于我们的第一个例子 我们想要一些非常基本的东西 

128
00:06:16,770 --> 00:06:18,760
我只想在屏幕上画两个图像 

129
00:06:18,760 --> 00:06:22,500
所以我们将在这里通过设置一个局部变量来实现这一点 

130
00:06:22,500 --> 00:06:25,560
记住 LOCAL意味着它只是被定义到

131
00:06:25,560 --> 00:06:29,310
它是在 而不是全局的 这意味着我们不能访问这个变量

132
00:06:29,310 --> 00:06:31,590
在这份文件之外 

133
00:06:31,590 --> 00:06:34,895
本地背景获取love.graph ics.newImage 

134
00:06:34,895 --> 00:06:36,520
我们刚才谈到的功能 

135
00:06:36,520 --> 00:06:40,821
让我继续把这个检查员藏在这里 这样我们就可以有更多的房间代码了 

136
00:06:40,821 --> 00:06:42,570
然后它只需要一根绳子 

137
00:06:42,570 --> 00:06:44,536
所以背景.png 

138
00:06:44,536 --> 00:06:47,410
我意识到我实际上并没有将这些文件包括在目录中 

139
00:06:47,410 --> 00:06:50,080
所以我也需要这么做 

140
00:06:50,080 --> 00:06:52,225
地面也是一样 功能也完全一样 

141
00:06:52,225 --> 00:06:55,590
Love.graph ics.newImage 除了round.png 

142
00:06:55,590 --> 00:06:59,280
趁我还没忘记 让我们现在就去做吧 

143
00:06:59,280 --> 00:07:02,055
我这里有文件 

144
00:07:02,055 --> 00:07:03,660
所以背景和背景 

145
00:07:03,660 --> 00:07:09,150
我们将把这些文件从发行版repo复制到我的Bird0目录中

146
00:07:09,150 --> 00:07:11,589
我现在正在开发的 

147
00:07:11,589 --> 00:07:14,130
一旦我们做完了 我们就会继续下去 

148
00:07:14,130 --> 00:07:16,230
我们将定义love.Load 它

149
00:07:16,230 --> 00:07:20,500
是在程序执行开始时调用的Love2D函数 

150
00:07:20,500 --> 00:07:25,560
在那里 因为我们不想让这些图像看起来模糊

151
00:07:25,560 --> 00:07:27,510
当他们被加载和升级时 我们希望

152
00:07:27,510 --> 00:07:31,030
要继续并在min和mag上将默认筛选器设置为最近 

153
00:07:31,030 --> 00:07:34,950
这意味着在高端和低端 应用最近邻居过滤 这

154
00:07:34,950 --> 00:07:41,100
表示没有模糊 没有像素内插 

155
00:07:41,100 --> 00:07:47,120
然后有一件事只是一个小小的触摸 

156
00:07:47,120 --> 00:07:51,390
Love.window.settile五十只鸟因为它是GD50 

157
00:07:51,390 --> 00:07:54,960
然后我们继续在这里设置我们的屏幕

158
00:07:54,960 --> 00:08:01,670
用我们的虚拟宽度、虚拟高度、窗口宽度、窗口高度 

159
00:08:01,670 --> 00:08:05,730
它变得有点长了 然后它就占据了桌子 

160
00:08:05,730 --> 00:08:09,180
调用表格 只需像这样接受关键字 

161
00:08:09,180 --> 00:08:14,750
与在Python中使用冒号不同 我们在Love中使用等号 

162
00:08:14,750 --> 00:08:16,820
或者在卢阿岛 我应该说 

163
00:08:16,820 --> 00:08:23,740
可调整为True 这就是我们的Load函数的末尾 

164
00:08:23,740 --> 00:08:27,600
现在 有没有人记得如果我们想要调整尺寸--

165
00:08:27,600 --> 00:08:29,120
因此请注意 我将Resizable设置为True 

166
00:08:29,120 --> 00:08:34,169
我们知道如何发送消息来推动我们调整屏幕大小吗？

167
00:08:37,240 --> 00:08:41,110
因此 Love2D定义了一个名为love.resize的函数 

168
00:08:41,110 --> 00:08:43,510
它包含宽度和高度 

169
00:08:43,510 --> 00:08:48,005
在那里 我们要做的就是推迟推动 

170
00:08:48,005 --> 00:08:49,630
在推送时调用完全相同的函数 

171
00:08:49,630 --> 00:08:51,463
它需要一个宽度和高度 这将是

172
00:08:51,463 --> 00:08:55,390
注意动态调整其内部使用的画布的比例 

173
00:08:55,390 --> 00:08:58,157
它渲染到一个纹理 然后再渲染到这个纹理

174
00:08:58,157 --> 00:09:00,490
我们设置为虚拟宽度和虚拟高度 

175
00:09:00,490 --> 00:09:02,890
它将对其进行缩放以适应我们的屏幕 

176
00:09:02,890 --> 00:09:05,320
它需要知道我们的物理屏幕尺寸

177
00:09:05,320 --> 00:09:11,007
以便它实际上可以适当地适当地缩放内部画布 

178
00:09:11,007 --> 00:09:14,090
有人记得我们用来从用户那里获取输入的函数吗？

179
00:09:17,380 --> 00:09:23,370
因此 函数.love.keyPressed recall 接受一个键 

180
00:09:23,370 --> 00:09:26,310
每次我们按下一个键 爱就会自动呼唤 

181
00:09:26,310 --> 00:09:27,555
这将是--

182
00:09:27,555 --> 00:09:31,170
我们将可以访问该密钥 我们可以进行任何类型的逻辑运算

183
00:09:31,170 --> 00:09:36,180
我们想要那把钥匙 用那把钥匙 

184
00:09:36,180 --> 00:09:38,550
我们只需要给Love打个电话 退出

185
00:09:38,550 --> 00:09:41,100
因为我不喜欢按命令Q或点击红色的x 

186
00:09:41,100 --> 00:09:44,380
我只想逃走 结束这一切 

187
00:09:44,380 --> 00:09:47,130
然后我们的渲染是什么--Love的渲染函数叫什么？

188
00:09:49,810 --> 00:09:52,630
这叫爱 画画 

189
00:09:52,630 --> 00:09:55,300
所以给love.draw打电话吧 

190
00:09:55,300 --> 00:09:58,210
然后因为我们使用推送 有没有人

191
00:09:58,210 --> 00:10:01,180
请记住 我们需要实际执行哪些操作才能使推送渲染

192
00:10:01,180 --> 00:10:03,321
把我们的屏幕调到虚拟分辨率？

193
00:10:06,030 --> 00:10:11,200
回想一下 我们实际上有两种方法可以做到这一点 

194
00:10:11,200 --> 00:10:16,950
我们可以调用Push Start和Push Finish 我们上周没有讨论这一点 

195
00:10:16,950 --> 00:10:22,150
或者我们可以打电话--这实际上是一种新的事实上的方式 

196
00:10:22,150 --> 00:10:27,660
或者我们可以使用PUSH APPLY START 这是不推荐使用的方法 

197
00:10:27,660 --> 00:10:31,790
但从现在开始 我们将称之为Push Start

198
00:10:31,790 --> 00:10:34,740
然后按下Finish 

199
00:10:34,740 --> 00:10:37,110
最后 我们有自己的图像 

200
00:10:37,110 --> 00:10:40,680
我们已经把它们作为物品分配到这里了 

201
00:10:40,680 --> 00:10:44,190
我们有一个背景和一个背景 

202
00:10:44,190 --> 00:10:47,230
我们现在需要做的就是把它们吸引到屏幕上 

203
00:10:47,230 --> 00:10:49,470
所以这是一个新函数 

204
00:10:49,470 --> 00:10:52,650
或者它实际上不是一个新功能 

205
00:10:52,650 --> 00:10:55,080
实际上 这是一个新功能 

206
00:10:55,080 --> 00:10:59,320
矩形是我们上周在所有绘制调用中使用的内容 

207
00:10:59,320 --> 00:11:02,640
在本例中 我们希望绘制一个图像对象 

208
00:11:02,640 --> 00:11:04,660
我们在内存中拥有的纹理对象 

209
00:11:04,660 --> 00:11:06,810
所以我们将把它命名为love.graph ics.Drag 

210
00:11:06,810 --> 00:11:09,240
它需要一个可抽屉 这意味着

211
00:11:09,240 --> 00:11:11,760
爱的定义是可以画出来的东西 

212
00:11:11,760 --> 00:11:13,860
在这种情况下 图像是可绘制的 

213
00:11:13,860 --> 00:11:18,396
可以绘制它们 也可以在您指定的任何给定位置绘制它们 

214
00:11:18,396 --> 00:11:20,520
如果你想把它画在左上角 

215
00:11:20,520 --> 00:11:24,400
我们只会在0 0处说love.raphics.draBackground 

216
00:11:24,400 --> 00:11:25,670
而且它也有这种效果 

217
00:11:25,670 --> 00:11:30,437
我们要用我们的土地做同样的事情 

218
00:11:30,437 --> 00:11:32,520
唯一的区别是 很明显 我们不会

219
00:11:32,520 --> 00:11:34,100
想在角落的顶端画画 

220
00:11:34,100 --> 00:11:35,980
我们想在屏幕的底部画画 

221
00:11:35,980 --> 00:11:41,447
所以我们称之为虚拟身高减16 这是

222
00:11:41,447 --> 00:11:43,030
恰好是我们图像的高度 

223
00:11:43,030 --> 00:11:43,990
所以如果你运行这个--

224
00:11:43,990 --> 00:11:48,690
我将继续 并确保我在正确的目录中 

225
00:11:48,690 --> 00:11:52,500
我不在正确的目录中 所以我将进入我编写的目录 

226
00:11:52,500 --> 00:11:55,020
五十只鸟抓伤 

227
00:11:55,020 --> 00:11:56,830
进入小鸟0号 

228
00:11:56,830 --> 00:12:00,630
如果我运行这个 理论上我应该只有两个图像

229
00:12:00,630 --> 00:12:03,150
层叠在一起 但我不会 

230
00:12:06,570 --> 00:12:11,070
所以我们只需要确保它被保存下来 

231
00:12:11,070 --> 00:12:15,150
记住要始终保存您的工作 这样就可以了 

232
00:12:15,150 --> 00:12:18,900
所以我们现在所做的 看起来比上周好多了

233
00:12:18,900 --> 00:12:21,242
已经有了 但它非常简单 只有很少的代码行 

234
00:12:21,242 --> 00:12:22,950
我们为此付出的所有努力

235
00:12:22,950 --> 00:12:25,470
一直是我们精灵编辑的首选 而你

236
00:12:25,470 --> 00:12:28,140
几乎可以使用任何你想做这类事情的应用程序 

237
00:12:28,140 --> 00:12:30,480
我用一个叫Aseprite的程序 我很喜欢 

238
00:12:30,480 --> 00:12:33,090
但你可以用免费的Gimp做这件事 你可以用Photoshop做这件事 

239
00:12:33,090 --> 00:12:35,256
如果你愿意 你可以用微软的画笔来完成 

240
00:12:37,660 --> 00:12:40,790
如果你这么做的话祝你好运 

241
00:12:40,790 --> 00:12:43,900
但是 是的 这就像把图像画到屏幕上一样简单 

242
00:12:43,900 --> 00:12:48,000
所以我们已经在很短的时间内取得了相当大的进展

243
00:12:48,000 --> 00:12:50,280
在我们游戏的视觉方面 

244
00:12:50,280 --> 00:12:53,889
但是 除了最初的那种蜜月之外 看起来并不有趣

245
00:12:53,889 --> 00:12:55,680
到目前为止 我们在屏幕上有了颜色 

246
00:12:55,680 --> 00:13:01,320
我们想要真正开始滚动 因为这个游戏 Recall 是

247
00:13:01,320 --> 00:13:02,130
滚动游戏 

248
00:13:02,130 --> 00:13:05,490
实际上 有谁愿意自愿

249
00:13:05,490 --> 00:13:09,360
上台演奏《飞翔的小鸟》 这样我们就可以在舞台上看到现场表演了？

250
00:13:13,830 --> 00:13:15,390
大卫 你想上来玩吗？

251
00:13:15,390 --> 00:13:19,110
有志愿者吗？

252
00:13:19,110 --> 00:13:20,880
史蒂芬 你想上来玩吗？

253
00:13:20,880 --> 00:13:23,360
史蒂芬：当然可以 

254
00:13:23,360 --> 00:13:25,068
科尔顿·奥格登：谢谢你的志愿服务 

255
00:13:30,690 --> 00:13:34,410
我保证你比我更擅长这个游戏

256
00:13:34,410 --> 00:13:41,670
我将继续并cd进入目录中的Bird12 即

257
00:13:41,670 --> 00:13:43,735
游戏的最终版本完成 

258
00:13:43,735 --> 00:13:45,360
所以我要继续按Enter键 

259
00:13:45,360 --> 00:13:47,220
[电子游戏音乐播放]

260
00:13:47,220 --> 00:13:52,200
因此 我们已经可以看到视差滚动

261
00:13:52,200 --> 00:13:54,504
我之前提到的 就是楼层

262
00:13:54,504 --> 00:13:56,670
背景以不同的速度滚动 

263
00:13:56,670 --> 00:13:59,412
我们很快就会在下一个例子中看到这一点 

264
00:13:59,412 --> 00:14:00,120
我们有一个提示符 

265
00:14:00,120 --> 00:14:00,661
我们收到短信了 

266
00:14:00,661 --> 00:14:02,660
我们以前已经在字体中使用过这一点 

267
00:14:02,660 --> 00:14:05,740
所以继续 如果你按Enter 你就会倒计时 

268
00:14:05,740 --> 00:14:06,720
所以太空就是跳跃 

269
00:14:06,720 --> 00:14:08,507
[嘟嘟声]

270
00:14:08,507 --> 00:14:10,840
所以我们让我们的鸟在屏幕中央跳跃 

271
00:14:10,840 --> 00:14:12,255
我们得了第一名的分数 

272
00:14:12,255 --> 00:14:15,101
这样做的目的是避免撞到管道 

273
00:14:15,101 --> 00:14:16,412
[撞车]

274
00:14:16,412 --> 00:14:17,470
好的 得一分 

275
00:14:17,470 --> 00:14:18,386
你想再试一次吗？

276
00:14:18,386 --> 00:14:20,012
您先请 

277
00:14:20,012 --> 00:14:21,988
[嘟嘟声]

278
00:14:23,470 --> 00:14:25,990
所以它会记录他的位置 每次

279
00:14:25,990 --> 00:14:29,380
他穿过了一对管子的右边 如你所见 

280
00:14:29,380 --> 00:14:32,710
这就是他得到一分的时候 

281
00:14:32,710 --> 00:14:37,149
那么如果你回想起上周 我们认为是什么--

282
00:14:37,149 --> 00:14:38,440
是什么在检测碰撞？

283
00:14:38,440 --> 00:14:40,430
如果我们记得上个星期 这个词叫什么？

284
00:14:40,430 --> 00:14:42,580
有人记得吗？

285
00:14:42,580 --> 00:14:46,654
轴对齐边界AABB碰撞检测 轴对齐边界框 

286
00:14:46,654 --> 00:14:49,570
这和我们对Pong做的事情是一样的 只是现在我们正在做--

287
00:14:49,570 --> 00:14:52,240
我们有图形 但它的概念是一样的 

288
00:14:52,240 --> 00:14:54,000
我们只是使用矩形 

289
00:14:54,000 --> 00:14:58,690
当一个矩形与另一个矩形重叠时 我们就会触发死亡 

290
00:15:02,155 --> 00:15:04,585
所以我想是最后一次迭代 然后我们将 

291
00:15:04,585 --> 00:15:06,590
[撞车]

292
00:15:06,590 --> 00:15:09,110
我们会让你再试一次 

293
00:15:09,110 --> 00:15:09,980
您先请 

294
00:15:09,980 --> 00:15:11,410
我会试一试 

295
00:15:11,410 --> 00:15:12,720
我要故意输掉比赛 

296
00:15:12,720 --> 00:15:15,230
好了 我们开始吧 

297
00:15:15,230 --> 00:15:18,440
说句公道话 我在开发这个的时候有过很多练习 

298
00:15:18,440 --> 00:15:20,830
但我们将拭目以待 看看这是否真的适用于这里 

299
00:15:23,455 --> 00:15:25,730
所以还要注意 这些管子--

300
00:15:25,730 --> 00:15:27,870
我--哦 我失去了程序世代 

301
00:15:27,870 --> 00:15:29,050
三分 

302
00:15:29,050 --> 00:15:31,820
当我再做一次迭代时 让我再解释一下 

303
00:15:31,820 --> 00:15:34,362
但是管子本身 每次我们开始的时候 

304
00:15:34,362 --> 00:15:36,070
它们在不同的地点产卵 

305
00:15:36,070 --> 00:15:39,700
这几乎是在最简单的情况下进行的

306
00:15:39,700 --> 00:15:45,160
可能的方法 并注意到管道正在逐渐移动 

307
00:15:45,160 --> 00:15:48,370
所以这在某种程度上是我们水平的构成 

308
00:15:48,370 --> 00:15:51,910
它只是对一些简单的算法一点一点地生成DO

309
00:15:51,910 --> 00:15:54,670
我们只会说 嘿 在这里再生产一根烟斗 把它移开

310
00:15:54,670 --> 00:15:55,840
在一定程度上 

311
00:15:55,840 --> 00:16:00,340
这种非常简单的方法允许我们一遍又一遍地拥有无限的水平

312
00:16:00,340 --> 00:16:01,760
再说一次 这是非常有效的 

313
00:16:01,760 --> 00:16:05,665
我们的屏幕上只有那么多的管子 我们很快就会看到--

314
00:16:05,665 --> 00:16:09,362
内存中的管道数量只能与屏幕上看到的一样多

315
00:16:09,362 --> 00:16:12,070
有一段时间 尽管这一水平理论上可以

316
00:16:12,070 --> 00:16:16,460
无限地进行 所以这是非常划算的 

317
00:16:16,460 --> 00:16:18,250
因此 Bird1就是一个例子 

318
00:16:18,250 --> 00:16:19,420
这是视差更新 

319
00:16:19,420 --> 00:16:23,410
因此 视差滚动是2D中的一个重要概念

320
00:16:23,410 --> 00:16:26,160
还有3D 但2D游戏开发 

321
00:16:26,160 --> 00:16:31,750
它指的是在两个参照系的情况下运动的错觉

322
00:16:31,750 --> 00:16:33,680
以不同的速度移动 

323
00:16:33,680 --> 00:16:37,120
所以如果你在高速公路上开车 你看到你旁边有一道栅栏 

324
00:16:37,120 --> 00:16:39,160
你看到远处的群山 你就是

325
00:16:39,160 --> 00:16:41,857
通过观察栅栏移动的速度来观察视差滚动

326
00:16:41,857 --> 00:16:42,940
相对于山脉而言 

327
00:16:42,940 --> 00:16:46,330
山脉的移动速度会比栅栏慢得多

328
00:16:46,330 --> 00:16:47,170
就在你旁边 

329
00:16:47,170 --> 00:16:50,140
我们在我们的游戏中完成了同样的幻觉

330
00:16:50,140 --> 00:16:54,310
通过使用这种图形错觉 

331
00:16:54,310 --> 00:16:56,860
所以我将在我的目录中继续

332
00:16:56,860 --> 00:17:02,380
在这里 在鸟1号 这是一种无人居住的--

333
00:17:02,380 --> 00:17:07,329
它填充了Bird0的内容 即Bird0的完整内容 

334
00:17:07,329 --> 00:17:10,490
您将看到的版本将包含所有代码 

335
00:17:10,490 --> 00:17:16,700
但我将继续 如果我们在该目录中运行Bird0 

336
00:17:16,700 --> 00:17:19,900
所以我想现在我还在完整的发行版中 

337
00:17:19,900 --> 00:17:23,355
所以让我继续 再一次进入五十鸟抓 

338
00:17:26,609 --> 00:17:27,400
哎呀 我在哪里？

339
00:17:31,970 --> 00:17:34,562
然后我将进入Bird1 并运行它 

340
00:17:34,562 --> 00:17:36,770
我得到了和上次一模一样的图像 

341
00:17:36,770 --> 00:17:40,030
所以一切都是从以前开始的 只有两张图片 没有任何移动 

342
00:17:40,030 --> 00:17:41,980
我们观察不到视差 

343
00:17:41,980 --> 00:17:44,140
我将继续进行 并开始实施

344
00:17:44,140 --> 00:17:47,540
这种视差的基本原理 

345
00:17:47,540 --> 00:17:51,040
所以如果我继续我的主修课程 

346
00:17:51,040 --> 00:17:55,810
因此 我将在这里介绍一下我们的背景 

347
00:17:55,810 --> 00:17:58,580
所以我们需要一些新的东西 

348
00:17:58,580 --> 00:18:00,400
因此 与我们的背景图像一起 我们需要

349
00:18:00,400 --> 00:18:02,890
来跟踪它的滚动量 因为我们

350
00:18:02,890 --> 00:18:04,780
需要开始将此图像绘制到屏幕上 

351
00:18:04,780 --> 00:18:06,580
但如果我们要滚动它 那就意味着

352
00:18:06,580 --> 00:18:08,891
我们需要移动它的x偏移量 

353
00:18:08,891 --> 00:18:11,140
如果我们想让它滚动 而不是在0 0处绘制 

354
00:18:11,140 --> 00:18:15,190
相反 我们不得不把它画在某个负值上 

355
00:18:15,190 --> 00:18:18,680
随着时间的推移 这将产生它从右向左移动的效果 

356
00:18:18,680 --> 00:18:20,680
所以我要继续下去 并跟踪--

357
00:18:20,680 --> 00:18:22,570
我将使用一个变量来跟踪卷轴

358
00:18:22,570 --> 00:18:24,550
现在 对于这两张图片 我们只是

359
00:18:24,550 --> 00:18:27,549
我要将它们命名为BackdowScroll和Ground Scroll 并将它们设置为0 

360
00:18:27,549 --> 00:18:30,370
所以这会产生NOX偏移量的影响 

361
00:18:30,370 --> 00:18:34,780
所以我现在可以使用这个变量 在下面的这个绘图调用中 

362
00:18:34,780 --> 00:18:36,110
我真的要这么做 

363
00:18:36,110 --> 00:18:38,180
我要继续下去 去--

364
00:18:38,180 --> 00:18:40,460
我要去看看那是不是对的 

365
00:18:40,460 --> 00:18:46,681
我将继续将其设置为负背景滚动 

366
00:18:49,330 --> 00:18:53,170
在这里 我将把它设置为负值 

367
00:18:53,170 --> 00:18:55,160
因此 这还不会改变任何事情 

368
00:18:55,160 --> 00:18:57,701
这将是完全相同的事情 因为它们都是0 

369
00:18:57,701 --> 00:19:02,870
它们以前是0 但随着时间的推移 我们会改变它们 

370
00:19:02,870 --> 00:19:14,110
为了做到这一点 我将继续下去 进入到这里 

371
00:19:14,110 --> 00:19:17,600
实际上 在我们做这件事之前 我们需要设定一个速度 

372
00:19:17,600 --> 00:19:19,660
这将随着时间的推移而发生 但由于他们

373
00:19:19,660 --> 00:19:21,580
需要以不同的速度发生 背景

374
00:19:21,580 --> 00:19:23,580
需要以比前景更慢的速度运行

375
00:19:23,580 --> 00:19:28,300
为了得到视差效应 我们需要分离速度变量 

376
00:19:28,300 --> 00:19:32,500
一般来说 不会改变的东西的标准是

377
00:19:32,500 --> 00:19:34,690
就是用大写字母加下划线 

378
00:19:34,690 --> 00:19:35,900
这是常量记法 

379
00:19:35,900 --> 00:19:38,350
这在大多数编程语言中都很常见 

380
00:19:38,350 --> 00:19:39,102
我们将在这里使用它 

381
00:19:39,102 --> 00:19:41,560
我将设置一个名为BACKGROUND_SCROLL_SPEED的变量 

382
00:19:41,560 --> 00:19:44,130
我要把它设为30 

383
00:19:44,130 --> 00:19:48,580
我也要做同样的事情 GROUND_SCROLL_SPEED 

384
00:19:48,580 --> 00:19:54,520
这是否需要高于或低于BACKGROUND_SCROLL_SPEED？

385
00:19:54,520 --> 00:19:56,280
地面将会移动--

386
00:19:56,280 --> 00:19:59,341
因此 背景的移动速度需要比地面慢 

387
00:19:59,341 --> 00:20:00,590
所以这个数字会更高 

388
00:20:00,590 --> 00:20:01,930
所以我们只需将其设置为60 

389
00:20:01,930 --> 00:20:03,850
您可以将其设置为任何您想要获得的效果 

390
00:20:03,850 --> 00:20:05,680
但这一点已经相当明显了 

391
00:20:05,680 --> 00:20:09,670
地面的移动速度将是背景的两倍 

392
00:20:09,670 --> 00:20:14,590
所以我们要做的也是如果我们

393
00:20:14,590 --> 00:20:19,180
如果我们让我们的图像无限滚动 会发生什么呢？

394
00:20:19,180 --> 00:20:21,147
在某个时间点上会发生什么？

395
00:20:21,147 --> 00:20:22,460
观众：形象消失了？

396
00:20:22,460 --> 00:20:24,168
科尔顿·奥格登：它将以一种形象运行 

397
00:20:24,168 --> 00:20:26,621
那么 我们如何解决这个问题呢？

398
00:20:26,621 --> 00:20:27,370
观众：循环播放 

399
00:20:27,370 --> 00:20:28,894
科尔顿·奥格登：准确地说 是循环 

400
00:20:28,894 --> 00:20:31,060
所以我们要继续下去 设置一个循环点 

401
00:20:31,060 --> 00:20:35,230
因此 另一个恒定的背景循环点 

402
00:20:35,230 --> 00:20:39,340
我们要将其设置为413 这有点像

403
00:20:39,340 --> 00:20:43,330
为了查看你的图像 并确定--你必须设置你的图像 

404
00:20:43,330 --> 00:20:47,050
如果你想达到这个效果 就让它们成为一个循环的图像 

405
00:20:47,050 --> 00:20:51,040
所以有两个拷贝完全相同的东西 也就是你的屏幕宽度 

406
00:20:51,040 --> 00:20:53,226
或者只是复制相同的块 一遍又一遍 

407
00:20:53,226 --> 00:20:54,350
有很多方法可以做到这一点 

408
00:20:54,350 --> 00:20:57,520
在本例中 我们的背景图像的循环点

409
00:20:57,520 --> 00:20:59,100
在x轴上是413

410
00:20:59,100 --> 00:21:02,307
所以我们把它设为413 

411
00:21:02,307 --> 00:21:05,140
然后我们继续--下一步我们实际上有

412
00:21:05,140 --> 00:21:07,130
开始改变价值观 

413
00:21:07,130 --> 00:21:09,820
所以在我们的更新函数中 

414
00:21:09,820 --> 00:21:12,820
这是会发生的 我会继续

415
00:21:12,820 --> 00:21:16,270
爱的定义 更新 回忆起来 Love 2D将为你打电话 

416
00:21:16,270 --> 00:21:19,240
但你必须自己定义

417
00:21:19,240 --> 00:21:22,325
我要继续 并设置backgroundScroll 

418
00:21:32,366 --> 00:21:34,240
所以这是要做什么 背景滚动

419
00:21:34,240 --> 00:21:40,140
获取backgroundScroll到自身加上我们设置的速度before times delta time 

420
00:21:40,140 --> 00:21:42,035
所以它保持帧速率独立 

421
00:21:45,020 --> 00:21:48,400
这会给我们的图像增加速度 

422
00:21:48,400 --> 00:21:49,420
但我们得重新设置

423
00:21:49,420 --> 00:21:51,070
我们需要真正执行重置 

424
00:21:51,070 --> 00:21:54,730
为了做到这一点 我们只需要使用模 

425
00:21:54,730 --> 00:21:59,860
从像C这样的语言 简单地划分--

426
00:21:59,860 --> 00:22:04,700
基本上 将该值设置为该除法的余数 

427
00:22:04,700 --> 00:22:10,990
在这种情况下10模5等于0

428
00:22:10,990 --> 00:22:18,040
但10模9实际上等于1 因为我们有0

429
00:22:18,040 --> 00:22:20,050
剩下的部分 

430
00:22:20,050 --> 00:22:22,690
我们用10除以9就剩下1 

431
00:22:26,240 --> 00:22:30,950
所以我很抱歉 如果这个概念不是新的 

432
00:22:30,950 --> 00:22:40,930
但我们也要为我们的土地做同样的事情 

433
00:22:40,930 --> 00:22:47,500
只不过我们要对虚拟宽度取模 

434
00:22:47,500 --> 00:22:48,880
我没有设置循环点 

435
00:22:48,880 --> 00:22:52,250
在后面的例子中是这样的 但是我们的地面图像非常--

436
00:22:52,250 --> 00:22:54,280
它的一致性足以让你

437
00:22:54,280 --> 00:22:57,984
注意它在循环时没有使用虚拟with 

438
00:22:57,984 --> 00:23:00,400
所以在这种情况下 我们只使用虚拟宽度 

439
00:23:00,400 --> 00:23:05,260
它很有图案 而且很小 

440
00:23:05,260 --> 00:23:09,550
除此之外 我们已经有了背景卷轴

441
00:23:09,550 --> 00:23:11,840
在我们的绘图功能中 

442
00:23:11,840 --> 00:23:13,990
所以当我们运行这段代码时 理论上我们应该

443
00:23:13,990 --> 00:23:17,010
有滚动的背景 

444
00:23:17,010 --> 00:23:20,440
观众：那么它的宽度是不是要两倍呢

445
00:23:20,440 --> 00:23:21,910
这样就不会卖完了

446
00:23:21,910 --> 00:23:24,118
科尔顿·奥格登：是的 至少是宽度的两倍 

447
00:23:24,118 --> 00:23:27,280
有几种方法可以有效地平铺你的形象 

448
00:23:27,280 --> 00:23:30,180
这样做可以节省纹理大小的内存 

449
00:23:30,180 --> 00:23:32,942
如果你有屏幕大小的四分之一的东西

450
00:23:32,942 --> 00:23:34,900
你想要循环 一遍又一遍 你

451
00:23:34,900 --> 00:23:36,775
我不想把它当做一个大画面 

452
00:23:36,775 --> 00:23:39,400
您只需绘制该图像的四个副本来填充您的屏幕 

453
00:23:39,400 --> 00:23:40,694
然后把它们全部移走 

454
00:23:40,694 --> 00:23:42,610
可能有五个 实际上 所以你有一点

455
00:23:42,610 --> 00:23:48,272
超出屏幕边缘 然后将它们全部放回0 

456
00:23:48,272 --> 00:23:51,218
观众：所以最下面的那个 地面是--

457
00:23:51,218 --> 00:23:56,610
如果您只是重新开始显示带有较大图像的图像 您不会知道

458
00:23:56,610 --> 00:23:57,110
背景资料 

459
00:23:57,110 --> 00:24:00,547
你就不用担心山被切成两半了

460
00:24:00,547 --> 00:24:02,040
当你换掉右翼时--

461
00:24:02,040 --> 00:24:03,370
科尔顿·奥格登：没错 

462
00:24:03,370 --> 00:24:05,144
所以我们实际上可以--

463
00:24:05,144 --> 00:24:07,310
我现在就可以向你展示那会是什么样子 

464
00:24:07,310 --> 00:24:10,330
所以如果我们把这里的循环点去掉 

465
00:24:10,330 --> 00:24:15,390
或者我们将其设置为完全不准确的值 比如270 

466
00:24:15,390 --> 00:24:24,670
然后我们运行它 一段时间后它应该会停下来 

467
00:24:24,670 --> 00:24:26,480
是的 就在那里 

468
00:24:26,480 --> 00:24:28,686
观众：那么你真的要画两次吗？

469
00:24:28,686 --> 00:24:31,060
就像用完的时候一个接一个什么的？

470
00:24:31,060 --> 00:24:34,420
科尔顿·奥格登：不 图像太宽了 总是会填满屏幕 

471
00:24:34,420 --> 00:24:38,940
即使在它被设置回--即使在它超过了循环点之后 

472
00:24:38,940 --> 00:24:41,080
我忘了纹理有多大了 

473
00:24:41,080 --> 00:24:44,102
它有1157个像素宽 

474
00:24:44,102 --> 00:24:45,810
所以它是屏幕宽度的两倍多 

475
00:24:45,810 --> 00:24:48,257
实际上 我认为它正好是屏幕宽度的两倍 

476
00:24:48,257 --> 00:24:50,090
不 它不是屏幕宽度的两倍 

477
00:24:50,090 --> 00:24:51,820
但它是屏幕宽度的两倍多

478
00:24:51,820 --> 00:24:54,820
所以当413个像素已经过去的时候 

479
00:24:54,820 --> 00:24:59,410
它仍然远远超过了屏幕的右边缘和循环部分 

480
00:24:59,410 --> 00:25:02,420
它将与纹理上的外观完全相同 

481
00:25:02,420 --> 00:25:06,190
但它完全被移回了右翼 

482
00:25:06,190 --> 00:25:10,150
我们图像的0 0现在位于屏幕空间中的0 0 

483
00:25:10,150 --> 00:25:13,690
观众：所以循环只是重新加载[INAUDIBLE]？？

484
00:25:13,690 --> 00:25:16,660
科尔顿·奥格登：你的形象在这里 在移动 然后就在瞬间

485
00:25:16,660 --> 00:25:20,340
回到开始 然后回到--

486
00:25:20,340 --> 00:25:23,470
将其设置回0 或者从技术上讲 多少

487
00:25:23,470 --> 00:25:28,190
像素它已经超过了屏幕的边缘 因为使用了模数 

488
00:25:28,190 --> 00:25:29,606
观众：所以这只是一张图片 

489
00:25:29,606 --> 00:25:32,147
这就像你只需在正确的时间瞬间翻转它 

490
00:25:32,147 --> 00:25:33,130
科尔顿·奥格登：是的 

491
00:25:33,130 --> 00:25:33,940
这是一种翻译 

492
00:25:33,940 --> 00:25:34,900
这是一种即时翻译 

493
00:25:34,900 --> 00:25:36,010
它发生在一帧上 

494
00:25:36,010 --> 00:25:36,968
所以你没有注意到它 

495
00:25:36,968 --> 00:25:40,370
你的肉眼看不到它 因为它实际上发生在一帧中 

496
00:25:40,370 --> 00:25:43,780
这两个点的图像数据是完全相同的

497
00:25:43,780 --> 00:25:45,010
因为我们有质感 

498
00:25:45,010 --> 00:25:48,122
我们已经预先创建了一个具有完全相同数据的纹理

499
00:25:48,122 --> 00:25:49,330
这样你就有了这样的效果 

500
00:25:49,330 --> 00:25:53,560
你必须有一个纹理 让你能做到这一点 或者聪明

501
00:25:53,560 --> 00:25:55,390
画出四幅相同的图像 

502
00:25:55,390 --> 00:25:57,100
跟踪他们所有四个人--

503
00:25:57,100 --> 00:26:00,130
或者实际上 有八个--所以你可以把它们移到左边 

504
00:26:00,130 --> 00:26:03,020
然后把它们全部移回右边 

505
00:26:03,020 --> 00:26:05,445
观众：我想我们拍《超级马里奥兄弟》的时候 

506
00:26:05,445 --> 00:26:11,032
我们将有多个图像一个接一个地堆叠在一起 

507
00:26:11,032 --> 00:26:12,990
科尔顿·奥格登：当我们谈到超级马里奥兄弟时 

508
00:26:12,990 --> 00:26:15,750
我们将讨论一个称为平铺映射的概念 它

509
00:26:15,750 --> 00:26:19,830
就是我们拿一个雪碧纸 然后你基本上把它切碎

510
00:26:19,830 --> 00:26:25,740
有一张地图 基本上是数字的 所以一块砖是

511
00:26:25,740 --> 00:26:28,950
值为1 然后你可以看到这个巨大的二维数组

512
00:26:28,950 --> 00:26:31,740
然后遍历它 迭代它 

513
00:26:31,740 --> 00:26:35,945
然后根据地图上的索引在一定的偏移量上绘制一块瓷砖 

514
00:26:35,945 --> 00:26:38,820
所以它稍微复杂一点 而且实际上内存要大得多

515
00:26:38,820 --> 00:26:43,316
高效 但实现略有不同 

516
00:26:48,740 --> 00:26:53,740
好的 现在我们有视差滚动了 

517
00:26:53,740 --> 00:26:55,420
我想花点时间--

518
00:26:55,420 --> 00:26:58,510
因为我们已经谈到了--

519
00:26:58,510 --> 00:27:01,930
这是一种非常入门的方式来证明游戏是错觉 

520
00:27:01,930 --> 00:27:03,160
通过使用视差滚动 

521
00:27:03,160 --> 00:27:07,084
实际上 我们所做的只是设置了两种不同的滚动速度 

522
00:27:07,084 --> 00:27:09,500
这让我们觉得我们在场景中有深度 

523
00:27:09,500 --> 00:27:11,416
但我们所做的一切 我们有两个图像 我们是

524
00:27:11,416 --> 00:27:13,780
以不同的速度滚动它们 

525
00:27:13,780 --> 00:27:15,790
但这是游戏开发中的一个共同主题 

526
00:27:15,790 --> 00:27:20,530
正在试图设计一个可能非常精致的场景 

527
00:27:20,530 --> 00:27:24,790
但在像iPhone这样的资源密集型设备上做到这一点 

528
00:27:24,790 --> 00:27:27,520
或者像任天堂64这样的老式游戏机 

529
00:27:27,520 --> 00:27:34,672
这些错觉随处可见 一个YouTube频道

530
00:27:34,672 --> 00:27:37,830
我最近发现我真正喜欢的是

531
00:27:37,830 --> 00:27:41,320
这叫--频道的名字是她说的 但实际上他们的节目

532
00:27:41,320 --> 00:27:42,910
HAVE被称为边界突破 

533
00:27:42,910 --> 00:27:46,670
他们所做的就是拿起一台摄像机

534
00:27:46,670 --> 00:27:49,060
超越了游戏开发商允许它做的事情 

535
00:27:49,060 --> 00:27:52,729
他们基本上侵入了游戏摄像头 这样你就可以在

536
00:27:52,729 --> 00:27:54,520
你以前不应该看到的 而你

537
00:27:54,520 --> 00:27:57,314
可以看到很多非常酷的诡计 

538
00:27:57,314 --> 00:27:59,230
我要给你们看几个视频片段 

539
00:27:59,230 --> 00:28:02,480
不过 如果你对视频感兴趣的话 这里有YouTube的网址 

540
00:28:02,480 --> 00:28:04,940
这是一个大约33分钟的视频 

541
00:28:04,940 --> 00:28:08,440
这是在塞尔达 奥卡里纳的时间为N64 

542
00:28:08,440 --> 00:28:12,040
我提取了几个特别值得注意的片段

543
00:28:12,040 --> 00:28:15,127
我觉得很有趣 也很幽默 

544
00:28:15,127 --> 00:28:16,960
我现在要继续播放这段视频 

545
00:28:16,960 --> 00:28:21,160
所以如果我们可以把灯光调暗 我就开始了 

546
00:28:21,160 --> 00:28:23,802
这是第一个例子 

547
00:28:23,802 --> 00:28:26,260
演讲者1：好的 关于这家商店有很多可谈的

548
00:28:26,260 --> 00:28:27,627
《时代的奥卡里纳》中的主人 

549
00:28:27,627 --> 00:28:30,210
所以我要把它浓缩成最有趣的 

550
00:28:30,210 --> 00:28:32,001
我们要谈论的第一个问题是

551
00:28:32,001 --> 00:28:34,090
是海鲁尔的那个怪异的店主 

552
00:28:34,090 --> 00:28:38,980
现在 在马约拉的面具中 同样的角色实际上是有腿的 

553
00:28:38,980 --> 00:28:42,430
但在《时代的奥卡莉娜》中 他没有这些 

554
00:28:42,430 --> 00:28:46,950
事实上 他没有腿看起来非常滑稽 

555
00:28:50,530 --> 00:28:52,445
科尔顿·奥格登：所以这是一个--

556
00:28:52,445 --> 00:28:55,570
有没有人知道他们为什么要这么做？

557
00:28:55,570 --> 00:28:57,670
观众：反正你不会看到的 

558
00:28:57,670 --> 00:29:01,685
科尔顿·奥格登：没错 除此之外 还节省了内存 

559
00:29:01,685 --> 00:29:04,810
无需加载角色模型--相关的顶点和纹理

560
00:29:04,810 --> 00:29:05,680
用它--

561
00:29:05,680 --> 00:29:08,830
像N64这样内存受限的设备 

562
00:29:08,830 --> 00:29:10,510
我忘了它有多少内存 

563
00:29:10,510 --> 00:29:13,790
比如4兆字节的内存 我想还不到 

564
00:29:13,790 --> 00:29:16,540
因此 他们显然正在削减他们可以削减多少角落 

565
00:29:16,540 --> 00:29:19,690
在这种情况下 通过字面上使用的错觉 

566
00:29:19,690 --> 00:29:23,470
不是幻觉 而是你只能看到

567
00:29:23,470 --> 00:29:26,890
柜台 给你一个错觉 有一个完整的生活 

568
00:29:26,890 --> 00:29:30,000
会说话的店主但它只是半个模型

569
00:29:30,000 --> 00:29:35,260
这里的另一个例子更多的是展示时间陶笛

570
00:29:35,260 --> 00:29:39,550
利用N64有限的内存 

571
00:29:39,550 --> 00:29:43,250
一种感觉 在一个非常大的水平 而你可能实际上并没有 

572
00:29:43,250 --> 00:29:46,400
所以如果我们能把灯光调暗一次 我们将继续展示这个 

573
00:29:46,400 --> 00:29:48,850
演讲者1：这显然是一个热门的建议 

574
00:29:48,850 --> 00:29:50,570
[笑]

575
00:29:51,860 --> 00:29:56,340
这是死亡山的免费摄像机 包括我们的朋友 大戈兰

576
00:29:56,340 --> 00:29:59,920
在黑色天空的映衬下 烟圈看起来有点奇怪 

577
00:29:59,920 --> 00:30:02,440
这里你可以看到任天堂愚弄了我们

578
00:30:02,440 --> 00:30:05,430
它不是整座山 只有悬崖的表面被渲染 

579
00:30:05,430 --> 00:30:09,000
那是通往烈火圣殿的路

580
00:30:09,000 --> 00:30:13,060
如果我们缩小 我们可以看到整个拖把的规模 

581
00:30:13,060 --> 00:30:15,240
比我想象的要大 

582
00:30:15,240 --> 00:30:19,990
不过 战斗音乐不太适合史诗般的平移镜头 

583
00:30:19,990 --> 00:30:23,090
科尔顿·奥格登：同样的想法 真的 只是有限的内存空间 

584
00:30:23,090 --> 00:30:25,840
所以让我们尽可能多地了解你

585
00:30:25,840 --> 00:30:29,550
从林克摄影机的角度来看 

586
00:30:29,550 --> 00:30:32,560
我想这其实和人们

587
00:30:32,560 --> 00:30:36,230
在现实生活中创造一些场景让你觉得你是在一个

588
00:30:36,230 --> 00:30:38,920
当你去看戏的时候 感觉你真的在一个场景里 

589
00:30:38,920 --> 00:30:43,090
但他们显然已经尽可能多的削减角落 但它的工作 

590
00:30:43,090 --> 00:30:47,520
在游戏中 你无法分辨 这在游戏开发中很常见 

591
00:30:47,520 --> 00:30:50,260
如果你想达到一个特别宏伟的效果 

592
00:30:50,260 --> 00:30:52,090
这是一个需要思考的问题

593
00:30:52,090 --> 00:30:55,300
让我看起来像是在做什么但实际上我没有

594
00:30:55,300 --> 00:30:58,540
我怎样才能让它看起来像我是一只鸟飞过一个无限系列

595
00:30:58,540 --> 00:31:01,540
但实际上我不是

596
00:31:01,540 --> 00:31:07,020
我们还有更多精彩节目即将播出 

597
00:31:07,020 --> 00:31:10,750
到目前为止 我们有我们的背景 但我们没有

598
00:31:10,750 --> 00:31:16,870
有我们游戏的标题人物 在这种情况下 五十鸟 

599
00:31:16,870 --> 00:31:20,980
所以我将继续 并说明我们如何得到一只鸟 

600
00:31:20,980 --> 00:31:23,390
渲染在屏幕上 

601
00:31:23,390 --> 00:31:27,800
所以我将进入我创建的bird 2目录 

602
00:31:27,800 --> 00:31:31,000
再次注意 如果你已经加载了代码 

603
00:31:31,000 --> 00:31:34,210
将会有完整的实施 

604
00:31:34,210 --> 00:31:38,096
但总的来说 我会做几件事 

605
00:31:38,096 --> 00:31:39,970
实际上 我要做的第一件事 

606
00:31:39,970 --> 00:31:42,310
我们要注意到我已经包括了

607
00:31:42,310 --> 00:31:48,010
实际上 我没有包括类文件 

608
00:31:48,010 --> 00:31:49,580
所以我现在就去做 

609
00:31:49,580 --> 00:31:53,770
所以在bird 1中--对不起 我将从bird 3中获取类lua 

610
00:31:53,770 --> 00:31:56,590
我将把它输入bird 2 因为我们

611
00:31:56,590 --> 00:31:57,746
我们要做一个鸟类课 

612
00:31:57,746 --> 00:31:59,620
回想一下 从上周开始 

613
00:31:59,620 --> 00:32:03,010
把我们曾经认为是完全不同的变量

614
00:32:03,010 --> 00:32:04,989
另一个是把它们放在一个包里 

615
00:32:04,989 --> 00:32:07,030
把与这些变量相关的函数

616
00:32:07,030 --> 00:32:09,160
这样我们就能打电话

617
00:32:09,160 --> 00:32:13,660
我们可以把游戏世界想得更抽象 

618
00:32:13,660 --> 00:32:16,060
分隔开的 更干净的 

619
00:32:16,060 --> 00:32:19,000
所以我要继续--现在我有bird 2 类lua 

620
00:32:19,000 --> 00:32:23,394
这只是我们在Lua中使用Love 2D获取类的库 

621
00:32:23,394 --> 00:32:25,810
我要继续 我要创建一个新文件 

622
00:32:25,810 --> 00:32:27,490
这只叫Bird.Lua 

623
00:32:27,490 --> 00:32:31,660
所以请记住 趋势是类 将它们大写以区分它们

624
00:32:31,660 --> 00:32:35,920
从函数和变量 

625
00:32:35,920 --> 00:32:41,020
这一次 我将继续 只需继续使用我的小抄 

626
00:32:51,636 --> 00:32:53,940
我的床单粘在一起了 

627
00:32:53,940 --> 00:32:58,232
好的 这个鸟类课实际上相当简单 

628
00:32:58,232 --> 00:33:00,190
回想一下 我们要做的就是创建一个类

629
00:33:00,190 --> 00:33:03,220
就是使用类库 大写的C加上括号

630
00:33:03,220 --> 00:33:05,332
在那里初始化它 

631
00:33:05,332 --> 00:33:07,540
我们将继续定义我们的init函数 

632
00:33:07,540 --> 00:33:13,120
因此 每个类都有一个初始化对象的init函数

633
00:33:13,120 --> 00:33:16,420
它将在后面提到 

634
00:33:16,420 --> 00:33:18,800
在这种情况下 我们需要一些东西 

635
00:33:18,800 --> 00:33:20,932
所以我们需要一张这只鸟的照片

636
00:33:20,932 --> 00:33:22,640
因为我们希望它能被吸引到屏幕上 

637
00:33:22,640 --> 00:33:25,056
所以我们需要做的 和我们之前做的一样--

638
00:33:25,056 --> 00:33:26,140
Love.graph ics.newImage 

639
00:33:26,140 --> 00:33:28,480
我要继续下去 很快地把它藏起来 

640
00:33:28,480 --> 00:33:31,270
然后是Bird.png 

641
00:33:31,270 --> 00:33:33,280
简单 简单 

642
00:33:33,280 --> 00:33:37,600
我们想要我们的鸟的高度的宽度 

643
00:33:37,600 --> 00:33:40,640
所以我要继续 把它也设置好 

644
00:33:40,640 --> 00:33:45,130
因此 每个图像都有一组关联的函数

645
00:33:45,130 --> 00:33:46,930
有了它 爱为我们实现了 

646
00:33:46,930 --> 00:33:49,665
我们从love.graph ics.newImage上得到的图像

647
00:33:49,665 --> 00:33:54,400
本身就是一个类 它有一个名为getWidth的函数 

648
00:33:54,400 --> 00:33:58,600
因此 这将允许我们动态地实现任何

649
00:33:58,600 --> 00:34:00,250
班级我们--

650
00:34:00,250 --> 00:34:04,917
我们碰巧分配的任何图像文件 并从中创建对象 

651
00:34:04,917 --> 00:34:07,750
然后我们继续设置x和y 因为回想一下 

652
00:34:07,750 --> 00:34:09,310
我们必须把它画在某个地方 

653
00:34:09,310 --> 00:34:11,690
我们想把我们的鸟画在屏幕中央 

654
00:34:11,690 --> 00:34:14,126
所以我们要继续 计算一下这个

655
00:34:14,126 --> 00:34:15,250
根据我们的虚拟宽度 

656
00:34:15,250 --> 00:34:17,250
所以我们要做的是用虚拟宽度除以2 

657
00:34:17,250 --> 00:34:19,083
所以它在屏幕的中间 

658
00:34:19,083 --> 00:34:21,007
但由于它是从左上角画出来的 

659
00:34:21,007 --> 00:34:22,340
我们想把它移到左边 

660
00:34:22,340 --> 00:34:25,060
所以我们要用我们的宽度--

661
00:34:27,719 --> 00:34:30,730
即时错误--我们刚刚根据图像数据进行了初始化 

662
00:34:30,730 --> 00:34:34,060
然后我们要做的是自宽除以2 

663
00:34:34,060 --> 00:34:38,469
所以我们要把宽度除以2 在x轴上向左移动 

664
00:34:38,469 --> 00:34:41,650
这将把我们放在水平方向的中间 

665
00:34:41,650 --> 00:34:46,210
在垂直方向上 它是完全相同的 只是重复使用了高度而不是宽度 

666
00:34:46,210 --> 00:34:51,670
差不多就是这样 除了这里的最后一点 

667
00:34:51,670 --> 00:34:54,050
我们希望能够让我们的鸟变得非常重要 

668
00:34:54,050 --> 00:35:03,580
所以我们要做love.graph 绘制我们的图像 然后在self.x self.y 

669
00:35:03,580 --> 00:35:05,920
所以这就是我们真正需要的

670
00:35:05,920 --> 00:35:08,140
一个非常简单的精灵出现在屏幕上 

671
00:35:08,140 --> 00:35:10,930
现在 它什么也做不了 因为这种人生活在

672
00:35:10,930 --> 00:35:12,580
目前还处于真空状态 

673
00:35:12,580 --> 00:35:15,640
我们需要做的是在我们的主文件中 我们

674
00:35:15,640 --> 00:35:19,150
这将需要鸟 这实际上将把它放入我们的--

675
00:35:19,150 --> 00:35:20,560
允许我们在代码中使用它 

676
00:35:23,180 --> 00:35:32,790
我们将创建一个本地鸟类变量 

677
00:35:32,790 --> 00:35:35,180
我们就叫它小鸟吧 

678
00:35:35,180 --> 00:35:47,270
在那之后 我们将简单地渲染到屏幕上 

679
00:35:47,270 --> 00:35:51,560
如果一切都做好了 如果我在正确的目录中--

680
00:35:55,210 --> 00:35:56,270
但这并没有奏效 

681
00:35:59,810 --> 00:36:02,950
再次确保保存您的工作 

682
00:36:02,950 --> 00:36:07,291
哦 我不需要上课 

683
00:36:07,291 --> 00:36:07,790
我的错 

684
00:36:07,790 --> 00:36:15,280
同样 我们需要这样做 因为我们已将其添加到我们的目录中 

685
00:36:15,280 --> 00:36:17,762
我也没有把Bird.png也包括在内 

686
00:36:17,762 --> 00:36:19,345
所以我要继续下去 并做到这一点 

687
00:36:19,345 --> 00:36:22,100
我要从下一本目录中借用一下 

688
00:36:22,100 --> 00:36:27,740
这应该是我们需要做的全部工作 并尝试调用方法 

689
00:36:27,740 --> 00:36:29,990
呈现空值 

690
00:36:29,990 --> 00:36:32,720
有意思的 

691
00:36:32,720 --> 00:36:33,710
我不是救了小鸟吗？

692
00:36:33,710 --> 00:36:36,350
我没有救小鸟 

693
00:36:36,350 --> 00:36:37,180
我们走吧 

694
00:36:37,180 --> 00:36:38,240
我们做到了 

695
00:36:38,240 --> 00:36:42,440
所以并不是特别有趣 但我们正在采取措施 

696
00:36:42,440 --> 00:36:44,300
记住保存您的工作 

697
00:36:44,300 --> 00:36:47,960
正如我们所看到的 我不这样认为 

698
00:36:47,960 --> 00:36:49,400
但我们正在取得进展 

699
00:36:49,400 --> 00:36:51,500
我们有我们要控制的实体 

700
00:36:54,110 --> 00:36:59,540
从视觉上看 我们正在非常接近 但许多重要的细节都缺失了 

701
00:36:59,540 --> 00:37:03,170
我们认为下一步应该是什么？

702
00:37:08,127 --> 00:37:09,960
观众：让我们让他跳跃和摔倒 

703
00:37:09,960 --> 00:37:12,210
科尔顿·奥格登：没错 我们会在他们的帮助下做到这一点

704
00:37:12,210 --> 00:37:14,970
这一概念在平台游戏和许多游戏中都很常见 

705
00:37:14,970 --> 00:37:16,680
事实上 但重力 

706
00:37:16,680 --> 00:37:21,858
我们认为如何在2D游戏开发的背景下模拟重力？

707
00:37:21,858 --> 00:37:25,200
观众：只是默认的 以恒定的速度下降 

708
00:37:25,200 --> 00:37:27,180
科尔顿·奥格登：我们当然可以这么做 

709
00:37:27,180 --> 00:37:29,220
这实际上就是我们将要做的事情 

710
00:37:29,220 --> 00:37:32,820
我们将使用我们上周使用过的东西 即

711
00:37:32,820 --> 00:37:42,150
是速度 增量y 并将这个速度应用于我们的鸟类y 

712
00:37:42,150 --> 00:37:46,740
一帧接一帧 这会给人一种坠落的错觉 

713
00:37:46,740 --> 00:37:51,120
现在 以恒定的速度下落并不能准确地反映重力的实际作用 

714
00:37:51,120 --> 00:37:55,420
我们想要做的 可能是一次又一次的引力 

715
00:37:55,420 --> 00:37:58,330
以某种恒定值增加我们的重力

716
00:37:58,330 --> 00:38:02,320
因此 就像在现实生活中一样 事情下降得越来越快 

717
00:38:02,320 --> 00:38:05,470
然后我们想把它加到我们的y值上 

718
00:38:05,470 --> 00:38:08,630
所以我将继续下去 现在开始在Bird3中实现它 

719
00:38:08,630 --> 00:38:09,610
回购错误 

720
00:38:09,610 --> 00:38:16,670
所以小鸟3号 我们拥有我们以前拥有的一切 

721
00:38:16,670 --> 00:38:33,721
除了现在 我将继续 在main.lua中 在我们的更新函数中 

722
00:38:33,721 --> 00:38:35,470
这才是我们真正想要的

723
00:38:35,470 --> 00:38:44,230
执行更新逻辑以使速度应用于鸟 

724
00:38:44,230 --> 00:38:46,120
我们将把它推迟到鸟类课 

725
00:38:46,120 --> 00:38:49,286
我们将假设在我们的BIRD类中有一个名为UPDATE的方法 

726
00:38:49,286 --> 00:38:54,430
我们很快就会实施 这实际上是

727
00:38:54,430 --> 00:38:57,210
我们在主课上所要做的就是 

728
00:38:57,210 --> 00:39:01,150
而拥有可以委托所有这些工作的课程的好处是

729
00:39:01,150 --> 00:39:06,300
TO 您的主文件 尽管它仍然变得相当大--它有108行--

730
00:39:06,300 --> 00:39:11,470
它不是200、300、400、数千行代码 因为我们能够

731
00:39:11,470 --> 00:39:16,660
破解这段代码 并将其封装到其他地方 

732
00:39:16,660 --> 00:39:18,580
所以这一次我要记住保存它 

733
00:39:18,580 --> 00:39:23,500
然后我将进入Bird.Lua文件

734
00:39:23,500 --> 00:39:26,890
在该目录中 这与评论相同

735
00:39:26,890 --> 00:39:31,390
因为我是从官方回购上下载的 同样的鸟码

736
00:39:31,390 --> 00:39:33,310
我们之前写过的 

737
00:39:33,310 --> 00:39:35,390
我要继续下去 做几件事 

738
00:39:35,390 --> 00:39:38,440
所以我要做的第一件事是定义一个常量 

739
00:39:38,440 --> 00:39:42,760
所以我以前提到过重力 

740
00:39:42,760 --> 00:39:47,800
重力将是一个恒定值 就像它在现实生活中一样 

741
00:39:47,800 --> 00:39:49,040
我要把它定义为20 

742
00:39:49,040 --> 00:39:50,331
它只是一个任意值 

743
00:39:50,331 --> 00:39:52,656
这是一种我觉得正确的价值观 

744
00:39:52,656 --> 00:39:54,280
但您可以随心所欲地调整它 

745
00:39:54,280 --> 00:39:56,060
做这件事没有对错之分 

746
00:39:56,060 --> 00:39:58,794
重力越小 它下落的速度就越慢 

747
00:39:58,794 --> 00:40:01,960
你越觉得自己在外太空 或者在月球上 

748
00:40:01,960 --> 00:40:02,460
或者诸如此类的 

749
00:40:05,230 --> 00:40:10,030
我们还将继续 并定义--

750
00:40:10,030 --> 00:40:11,950
回想一下 我们需要一些方法来跟踪

751
00:40:11,950 --> 00:40:16,010
我们的鸟是如何坠落的 

752
00:40:16,010 --> 00:40:17,800
我们需要一个速度 一个y速度 

753
00:40:17,800 --> 00:40:19,870
这将更新我们每一帧的位置 

754
00:40:19,870 --> 00:40:22,000
它会让人感觉我们在坠落 

755
00:40:22,000 --> 00:40:24,000
所以我们要把初始速度设为0 

756
00:40:24,000 --> 00:40:25,749
这只鸟只会在中间 

757
00:40:25,749 --> 00:40:27,130
它还不会掉下来 

758
00:40:27,130 --> 00:40:31,300
我们不想做的是应用这个速度 

759
00:40:31,300 --> 00:40:35,650
记住 在我们的主文件中 我们假设我们有一个更新函数 

760
00:40:35,650 --> 00:40:37,480
但我们还没有真正实施它 

761
00:40:37,480 --> 00:40:38,980
所以我们现在就要这么做了 

762
00:40:38,980 --> 00:40:42,490
我们要说的是鸟食DT 

763
00:40:42,490 --> 00:40:47,530
我们将在主文件中使用的同一dt中传递它 

764
00:40:47,530 --> 00:40:51,370
接下来我们要说的是 我们的速度

765
00:40:51,370 --> 00:40:59,630
等于我们当前的速度加上重力乘以增量时间 

766
00:40:59,630 --> 00:41:01,720
我们只需要用增量时间来衡量重力 

767
00:41:01,720 --> 00:41:04,210
所以它将移动相同的量 无论

768
00:41:04,210 --> 00:41:07,960
无论我们以每秒10帧还是每秒60帧的速度运行 

769
00:41:07,960 --> 00:41:09,716
然后我们将继续--

770
00:41:09,716 --> 00:41:12,340
我们有一个速度 但它实际上并没有改变我们的y值 

771
00:41:12,340 --> 00:41:14,590
Y值是最终在屏幕上移动我们的东西 

772
00:41:14,590 --> 00:41:18,130
所以我们需要将新的增量y应用到y上 

773
00:41:18,130 --> 00:41:21,190
所以我们要继续下去 就这么做 

774
00:41:21,190 --> 00:41:26,310
得到了 加上自己的点 

775
00:41:26,310 --> 00:41:32,540
所以如果我回到Bird3 假设我保存了一切 

776
00:41:32,540 --> 00:41:34,900
我们应该直接跳到屏幕上 我们就是这么做的 

777
00:41:34,900 --> 00:41:40,840
不是特别有用 但请注意 它可能有点难说 

778
00:41:40,840 --> 00:41:44,470
但它确实一帧一帧地移动得越来越快 因为

779
00:41:44,470 --> 00:41:48,190
和我们的y一样增加 这个增量y也在增加 

780
00:41:48,190 --> 00:41:49,939
适用于我们的y 一帧接一帧 

781
00:41:49,939 --> 00:41:50,980
我会再做一次 

782
00:41:50,980 --> 00:41:52,150
只是看起来很有趣 

783
00:41:52,150 --> 00:41:55,210
好了 我们有了基本的重力 

784
00:41:55,210 --> 00:41:56,620
超基本计算 

785
00:41:56,620 --> 00:42:01,120
只需跟踪某个重力常数 

786
00:42:01,120 --> 00:42:05,740
增加它 并将它应用于y 这就给了你重力 

787
00:42:05,740 --> 00:42:07,670
但是Flappy Bird会跳 

788
00:42:07,670 --> 00:42:09,970
所以我们需要找到一种方法来对抗地心引力 

789
00:42:09,970 --> 00:42:12,280
所以我们要做的是--在鸟4中 我们

790
00:42:12,280 --> 00:42:14,440
我们把这叫做反重力更新 

791
00:42:14,440 --> 00:42:19,690
我们将讨论如何才能真正做到这一点 

792
00:42:19,690 --> 00:42:22,540
所以我找到了这张图 我觉得很合适 

793
00:42:22,540 --> 00:42:25,581
它还涵盖了我们今天讨论的其他一些概念 

794
00:42:25,581 --> 00:42:29,290
但是看这里 这个重力 这是我们之前定义的常量 

795
00:42:29,290 --> 00:42:31,780
20美元或更多 这就适用于

796
00:42:31,780 --> 00:42:33,340
你想让它值多少就值多少 

797
00:42:33,340 --> 00:42:36,670
这将逐帧应用于您的y 

798
00:42:36,670 --> 00:42:37,810
我们想要的是这个 

799
00:42:37,810 --> 00:42:40,360
这里的矢量是跳跃速度 

800
00:42:40,360 --> 00:42:46,420
我们想要一些价值来抵消我们一直在积累的重力 

801
00:42:46,420 --> 00:42:48,400
那么 我们认为我们可以如何着手做这件事呢？

802
00:42:51,640 --> 00:42:57,070
我们可以将重力设置为某个负值 或许是一个高值 

803
00:42:57,070 --> 00:42:59,740
这将产生一帧一帧的效果 

804
00:42:59,740 --> 00:43:04,270
如果我们从某个正值开始 这会使我们在y轴上下降 

805
00:43:04,270 --> 00:43:07,330
然后我们一帧接一帧地取负值 

806
00:43:07,330 --> 00:43:09,770
它会说 假设我们从负5开始 

807
00:43:09,770 --> 00:43:12,970
我们把它的速度设为负5

808
00:43:12,970 --> 00:43:17,590
要将y设置为负--它将设置为+负5像素

809
00:43:17,590 --> 00:43:20,350
加上负4.9像素 4.8像素 

810
00:43:20,350 --> 00:43:22,930
它将以相当快的速度以一系列像素拍摄我们 

811
00:43:22,930 --> 00:43:26,700
但由于我们是一帧一帧地应用重力 这个值

812
00:43:26,700 --> 00:43:30,210
我们之前设定的 20 它将会产生这样的效果--

813
00:43:30,210 --> 00:43:31,160
是三角洲时间的20倍 

814
00:43:31,160 --> 00:43:33,570
因此 实际上 它被除以60 

815
00:43:33,570 --> 00:43:36,060
它将再次抵消这一点 

816
00:43:36,060 --> 00:43:39,371
所以我们会以相当快的速度上升 但重力

817
00:43:39,371 --> 00:43:41,370
将立即开始站稳脚跟 

818
00:43:41,370 --> 00:43:45,570
我们将开始获得鸟类跳跃的效果 

819
00:43:45,570 --> 00:43:47,429
然后摔倒在地上 

820
00:43:47,429 --> 00:43:49,470
这张图还显示了其他几件事 

821
00:43:49,470 --> 00:43:54,032
我认为这很酷 这个管子缺口

822
00:43:54,032 --> 00:43:56,490
距离 这是我们将要讨论的很好的东西

823
00:43:56,490 --> 00:43:59,972
不久 因为需要定义这一点 以便我们可以抵消我们的管道 

824
00:43:59,972 --> 00:44:02,430
管道分离 这是我们将讨论的另一件事 

825
00:44:02,430 --> 00:44:05,100
还有管道宽度 这只是一个内在值

826
00:44:05,100 --> 00:44:07,400
我们将使用的管状精灵的特征 

827
00:44:07,400 --> 00:44:09,290
但我认为这是非常恰当的 

828
00:44:09,290 --> 00:44:11,970
纽约大学做了一篇不错的文章 如果你想看的话

829
00:44:11,970 --> 00:44:13,470
在这里 关于探索游戏空间 

830
00:44:13,470 --> 00:44:17,190
他们通过计算确定了什么才是一只会飞的鸟

831
00:44:17,190 --> 00:44:20,340
难度或非难度级别 并对Flappy Bird级别进行动态评级

832
00:44:20,340 --> 00:44:22,562
是基于某种规模生成的 

833
00:44:22,562 --> 00:44:24,270
所以如果你好奇的话 可以在幻灯片中找到 

834
00:44:24,270 --> 00:44:28,510
但我认为这是一个很酷的发现 因为我正在组织这次演讲 

835
00:44:28,510 --> 00:44:34,200
所以我们需要做的就是 简单地给重力增加一些负值 

836
00:44:34,200 --> 00:44:35,922
负反重力 

837
00:44:35,922 --> 00:44:37,380
所以我们要继续这样做 

838
00:44:37,380 --> 00:44:46,590
所以在我这里的迷你回购的第四只鸟中 

839
00:44:46,590 --> 00:44:48,715
我们将首先在主干道上继续前进 

840
00:44:55,540 --> 00:45:01,120
我们想要做的一件事是因为这件事的另一部分

841
00:45:01,120 --> 00:45:04,390
就是接受用户的输入 能够跳跃 

842
00:45:04,390 --> 00:45:08,050
我们希望能够检测到他们是否按下了空格键 

843
00:45:08,050 --> 00:45:15,260
但如果我们想要检测我们曾经的每一个实体的输入 

844
00:45:15,260 --> 00:45:19,070
在这样的情况下 这并不是特别重要 

845
00:45:19,070 --> 00:45:22,840
但假设我们有20或30种不同的实体 

846
00:45:22,840 --> 00:45:25,180
它们都有自己的输入处理 

847
00:45:25,180 --> 00:45:27,670
我们不想让它堵塞我们的主管道 这是必然的 

848
00:45:27,670 --> 00:45:30,760
所以我们可以把它献给--

849
00:45:30,760 --> 00:45:34,700
我应该说 把它委托给代码的另一个部分 

850
00:45:34,700 --> 00:45:37,120
在这种情况下 我们可以把我们的鸟儿输入

851
00:45:37,120 --> 00:45:40,080
和我们的鸟类班一起来处理 对 

852
00:45:40,080 --> 00:45:45,940
并阐述了类的模型 对代码和数据的控制

853
00:45:45,940 --> 00:45:49,850
对于我们场景中的特定对象 

854
00:45:49,850 --> 00:46:01,420
所以我们要做的就是在我们的爱中 

855
00:46:01,420 --> 00:46:05,190
我要继续下去 在这里做一些事情 

856
00:46:05,190 --> 00:46:09,130
我将继续设置love.keyboard.keysPressed

857
00:46:09,130 --> 00:46:10,130
等于一张桌子 

858
00:46:10,130 --> 00:46:15,385
而我所做的只是在一张由Love定义的桌子上添加内容 

859
00:46:15,385 --> 00:46:16,810
这叫爱情键盘 

860
00:46:16,810 --> 00:46:20,890
我将自己的值添加到它中 称为KeysPressed 

861
00:46:20,890 --> 00:46:23,060
我要把它分配给一张空桌子 

862
00:46:23,060 --> 00:46:24,520
所以我们要做的是--

863
00:46:24,520 --> 00:46:29,230
这是爱作为它的SDK的一部分给我们的一部分 

864
00:46:29,230 --> 00:46:32,050
但这是我们自己创造的东西 

865
00:46:32,050 --> 00:46:36,190
你可以这样做 因为在Lua 基本上所有的东西

866
00:46:36,190 --> 00:46:39,440
在基本变量之外 只有表 并且您可以操作表

867
00:46:39,440 --> 00:46:40,360
随心所欲 

868
00:46:40,360 --> 00:46:42,150
在本例中 love.key是一张表 

869
00:46:42,150 --> 00:46:43,720
我只是添加了一个名为keysPressed的新键 

870
00:46:43,720 --> 00:46:45,835
我把它分配给我自己的一张空桌子 

871
00:46:45,835 --> 00:46:50,120
稍后我们将看看它是如何实际使用的 

872
00:46:50,120 --> 00:46:55,060
所以我将在这里继续我们的按键功能--

873
00:46:58,540 --> 00:47:03,190
该函数在用户每次按下游戏中的键时被调用 

874
00:47:03,190 --> 00:47:06,850
但我会用它的 

875
00:47:06,850 --> 00:47:11,320
因为它做到了这一点 我可以继续下去 只做这样的事情 

876
00:47:11,320 --> 00:47:19,540
Love.keyboard.keysPressed Key为True 其含义在此表中

877
00:47:19,540 --> 00:47:23,500
我们刚刚定义的 我们自己创建的 任何时候用户

878
00:47:23,500 --> 00:47:27,220
按任何键 因为会为您调用love.keyPressed 

879
00:47:27,220 --> 00:47:30,220
我们可以放心 无论如何 这里都会有人居住

880
00:47:30,220 --> 00:47:32,290
他们按下什么键 因为这只是一种

881
00:47:32,290 --> 00:47:33,850
Love2D会照顾你的 

882
00:47:33,850 --> 00:47:35,810
但它直到现在才被储存起来 

883
00:47:35,810 --> 00:47:38,440
现在我们实际上要跟踪它

884
00:47:38,440 --> 00:47:44,180
原因很快就会显现出来 

885
00:47:44,180 --> 00:47:49,900
这段代码的下一部分是定义一个定制函数 

886
00:47:49,900 --> 00:47:55,420
因此 这其中的推动力是爱定义了几个功能 

887
00:47:55,420 --> 00:48:00,190
它定义了一个名为love.keyboard.isdown的函数 

888
00:48:00,190 --> 00:48:02,020
它接受一些关键的值 并且您可以

889
00:48:02,020 --> 00:48:06,700
使用它来测试连续输入 就像我们在上一节课中所做的那样 

890
00:48:06,700 --> 00:48:10,600
我们在说 如果UP现在是DOWN 或者DOWN是DOWN 

891
00:48:10,600 --> 00:48:13,820
然后我们需要相应地更新y速度 

892
00:48:13,820 --> 00:48:16,540
但它没有这样的机制 比如说 

893
00:48:16,540 --> 00:48:18,850
我们想要在主文件之外的某个文件中检查

894
00:48:18,850 --> 00:48:22,090
因为如果一个键只按了一次 

895
00:48:22,090 --> 00:48:24,880
它有这个函数love.keyPressed 它接受一个密钥 

896
00:48:24,880 --> 00:48:28,820
这将触发它 但我们不能在此函数之外访问它

897
00:48:28,820 --> 00:48:31,870
因为如果我们在Bird.Lua中定义这个函数 

898
00:48:31,870 --> 00:48:34,660
它将覆盖此实现 

899
00:48:34,660 --> 00:48:37,900
我们不一定要担心其他文件

900
00:48:37,900 --> 00:48:40,000
覆盖这些函数 因为谁知道呢--

901
00:48:40,000 --> 00:48:41,380
尤其是如果你在一个团队里 谁知道呢

902
00:48:41,380 --> 00:48:43,780
谁被覆盖了love.key按下了 以及在哪个模块中 

903
00:48:43,780 --> 00:48:47,620
以及它被加载的顺序 以及实际有效的函数 

904
00:48:47,620 --> 00:48:51,220
我们将通过赋予自己能力来解决这个问题

905
00:48:51,220 --> 00:48:54,520
测试是否已在最后一帧上按下键

906
00:48:54,520 --> 00:49:00,040
通过实现我们也添加到键盘命名空间的函数 

907
00:49:00,040 --> 00:49:04,420
我们自己的键盘桌 叫做wasPressed 

908
00:49:04,420 --> 00:49:09,100
它需要一把钥匙 它要做的就是

909
00:49:09,100 --> 00:49:11,040
就是检查我们之前创建表 

910
00:49:11,040 --> 00:49:18,250
它会说如果love.keyboard.keysPressed键 那么

911
00:49:18,250 --> 00:49:23,140
返回True 否则返回False 

912
00:49:23,140 --> 00:49:27,220
实际上 您可以只返回love.keyboard.keysPressed键 

913
00:49:27,220 --> 00:49:29,689
这将是一模一样的事情 

914
00:49:29,689 --> 00:49:31,480
因此 这样做的效果是

915
00:49:31,480 --> 00:49:35,860
说 好的 因为在我们即将看到的更新上--

916
00:49:35,860 --> 00:49:39,055
事实上 我可能应该在此之前这样做 这样所有这些都被捆绑在一起 

917
00:49:42,600 --> 00:49:45,100
在Love的最后 我们要做最后一件事 

918
00:49:45,100 --> 00:49:50,960
这就是重置表格 因为我们只想逐帧检查 

919
00:49:50,960 --> 00:49:55,470
我们有一个表 一个全局表 我们已经创建

920
00:49:55,470 --> 00:49:57,330
以检查是否按下了某个键 

921
00:49:57,330 --> 00:50:00,615
我们有一个Love2D提供的回调函数 允许我们这样做 

922
00:50:00,615 --> 00:50:02,490
所以每次按下一个键 我们就会

923
00:50:02,490 --> 00:50:07,230
只需将该键添加到该表 并将其设置为True 

924
00:50:07,230 --> 00:50:10,740
现在 我们可以使用此函数随时简单地查询该表

925
00:50:10,740 --> 00:50:14,160
我们已经创建了一个名为love.keyboard.wasPressed的键 它

926
00:50:14,160 --> 00:50:18,210
最后一帧的意思是 那个键按下了吗？

927
00:50:18,210 --> 00:50:20,152
基本上返回的是真还是假 

928
00:50:20,152 --> 00:50:22,110
现在 唯一的问题是我们没有冲洗它 

929
00:50:22,110 --> 00:50:24,550
我们永远不会将其设置为假 

930
00:50:24,550 --> 00:50:27,540
如果我们只需按下键盘上的所有键 

931
00:50:27,540 --> 00:50:32,370
在我们重新初始化表之前 这些都是正确的

932
00:50:32,370 --> 00:50:35,040
到某个空值 这就是我们在这里所做的 

933
00:50:35,040 --> 00:50:39,930
在检测到所有输入之后进行的更新上 

934
00:50:39,930 --> 00:50:44,580
我们要把那张桌子又放到一张空桌子上 

935
00:50:44,580 --> 00:50:48,880
在下一帧 它将--无论我们按下什么键 那些

936
00:50:48,880 --> 00:50:52,620
将被设置为True 然后我们可以根据需要在此处查询该表 

937
00:50:52,620 --> 00:50:55,320
以及今后的任何更新 

938
00:50:55,320 --> 00:51:00,262
那么 有没有人对这是如何运作的有任何疑问？

939
00:51:02,940 --> 00:51:06,542
因此 我们的最终驱动因素

940
00:51:06,542 --> 00:51:08,250
至于我们为什么要这样做 为什么我们想要

941
00:51:08,250 --> 00:51:13,320
为了进行跟踪该全局输入表的工作 

942
00:51:13,320 --> 00:51:23,550
这样我们就可以真正地查询输入 即基于其他文件的单键输入

943
00:51:23,550 --> 00:51:25,560
在Main.Lua之外 因为目前 所有

944
00:51:25,560 --> 00:51:29,010
我们能做的检查单键按下是在主线上 Lua 

945
00:51:29,010 --> 00:51:31,020
但这不是我们想要做的 

946
00:51:31,020 --> 00:51:38,790
我们将继续访问我们的Bird.lua 在我们的更新函数中 

947
00:51:38,790 --> 00:51:42,690
这才是我们真正需要付出努力的地方 

948
00:51:42,690 --> 00:51:49,800
并假设如果love.keyboard.wa按下空格 

949
00:51:49,800 --> 00:51:54,190
这是我们实际上想要允许我们跳跃的关键 

950
00:51:54,190 --> 00:51:56,510
去吧 把自己的生命设定为--

951
00:51:56,510 --> 00:51:59,040
当我们按空格键时 应该将self.dy设置为什么？

952
00:52:01,990 --> 00:52:04,379
它应该是正值还是负值？

953
00:52:04,379 --> 00:52:05,170
观众：没有 

954
00:52:05,170 --> 00:52:06,910
科尔顿·奥格登：负值 

955
00:52:06,910 --> 00:52:09,380
我们会将其设置为负5 我们可能应该

956
00:52:09,380 --> 00:52:12,230
把它定义为一个反重力常数 

957
00:52:12,230 --> 00:52:16,010
但为了速度起见 我们就说self.dy得到负5 

958
00:52:19,567 --> 00:52:20,650
我确实这么说过 对吧？

959
00:52:20,650 --> 00:52:21,750
我确实这么说过 

960
00:52:21,750 --> 00:52:25,210
我要继续往前走 走进鸟巢 

961
00:52:25,210 --> 00:52:28,472
继续运行此示例 

962
00:52:28,472 --> 00:52:32,950
看看这个 我们在跳 

963
00:52:32,950 --> 00:52:34,870
但我们仍然可以掉到地面上 

964
00:52:34,870 --> 00:52:36,866
而且我们没有任何真正的游戏可玩 

965
00:52:36,866 --> 00:52:37,990
但我们已经走了很长一段路 

966
00:52:37,990 --> 00:52:41,410
现在我们已经接受了单键输入 否则

967
00:52:41,410 --> 00:52:43,750
没有能力在Love2D中做到这一点 而我们已经

968
00:52:43,750 --> 00:52:46,570
仅仅通过跟踪我们的全局输入状态就可以实现 

969
00:52:46,570 --> 00:52:49,780
每次更新都会刷新 

970
00:52:49,780 --> 00:52:54,050
那么 有没有人对它的工作原理有任何疑问？

971
00:52:54,050 --> 00:52:55,660
好的 

972
00:52:55,660 --> 00:53:00,552
所以Flappy Bird的另一个主要视觉组件

973
00:53:00,552 --> 00:53:02,510
就是我们在屏幕上看到的这些管子 

974
00:53:02,510 --> 00:53:07,930
我们在那里有两个管道 但屏幕上充满了无限的管道 

975
00:53:07,930 --> 00:53:12,460
那么 有没有人对我们如何实现这一点有什么直觉呢？

976
00:53:16,036 --> 00:53:22,580
嗯 我们很快就会知道了 但我只想说我们需要一个新的雪碧 

977
00:53:22,580 --> 00:53:25,710
我们需要某种方法来跟踪

978
00:53:25,710 --> 00:53:32,520
何时产卵 因为它们会在一段时间后产卵 

979
00:53:32,520 --> 00:53:34,320
这将是我们的差距 

980
00:53:34,320 --> 00:53:40,354
如果我们让它永远地生下去 会发生什么呢？

981
00:53:40,354 --> 00:53:42,270
观众：你必须在他们离开的时候摧毁他们？

982
00:53:42,270 --> 00:53:43,500
科尔顿·奥格登：我们这样做是因为如果我们不这样做

983
00:53:43,500 --> 00:53:45,780
在一段时间后 我们会分配内存

984
00:53:45,780 --> 00:53:46,950
对于这些管道中的每一个 

985
00:53:46,950 --> 00:53:52,200
不是一吨的内存 只是本质上 x y 一个宽度和一个高度 

986
00:53:52,200 --> 00:53:54,480
而是因为它们引用的都是相同的--

987
00:53:54,480 --> 00:53:57,639
他们将引用相同的精灵图像 但如果有足够的时间 

988
00:53:57,639 --> 00:54:00,180
最终 您将分配一定数量的字节

989
00:54:00,180 --> 00:54:03,900
这将超过您的计算机内存或分配的内存量 

990
00:54:03,900 --> 00:54:06,810
你要么无限地挂着 要么崩溃 

991
00:54:06,810 --> 00:54:11,950
因此 我们想要在他们离开的同时摧毁他们 

992
00:54:11,950 --> 00:54:16,650
因此 我们将继续 并查看最终的实时编码示例

993
00:54:16,650 --> 00:54:20,120
只是因为从现在开始 这会有点太多了 

994
00:54:20,120 --> 00:54:25,785
我要走了 先去Main Lua 

995
00:54:30,300 --> 00:54:35,730
所以把我的笔记整理好 

996
00:54:35,730 --> 00:54:37,365
我们想做的第一件事是--

997
00:54:37,365 --> 00:54:38,990
哦 其实我也买错了 

998
00:54:38,990 --> 00:54:39,850
我向你道歉 

999
00:54:39,850 --> 00:54:40,920
我在发行回购中 

1000
00:54:40,920 --> 00:54:43,260
我想成为划痕回收员 

1001
00:54:43,260 --> 00:54:52,510
所以我要继续 进入Main 我将需要管道 

1002
00:54:52,510 --> 00:54:56,200
现在 我们还没有管道 但这是一个完美的例子

1003
00:54:56,200 --> 00:54:58,990
我们可以继续抽象我们的游戏 

1004
00:54:58,990 --> 00:55:02,110
我们有一节鸟类课 但我们也应该

1005
00:55:02,110 --> 00:55:05,810
我有一个管道类 因为管道在我们的游戏中是一种不同类型的实体

1006
00:55:05,810 --> 00:55:06,310
世界 

1007
00:55:06,310 --> 00:55:09,310
我们可以将它建模为一个单元 我们可以赋予它功能 

1008
00:55:09,310 --> 00:55:13,280
我们可以给它数据 把它想象成一根管道 

1009
00:55:13,280 --> 00:55:17,770
不是XY、宽度、高度等的集合 

1010
00:55:17,770 --> 00:55:20,530
无论您想要将什么数据归因于它 我们

1011
00:55:20,530 --> 00:55:24,130
可以把它抽象出来 用更抽象的术语思考 这将

1012
00:55:24,130 --> 00:55:25,812
让我们能够更好地扩大规模 

1013
00:55:25,812 --> 00:55:28,520
所以我们将继续 并假设我们有一个管道类 

1014
00:55:28,520 --> 00:55:32,320
我将继续 并立即将其添加到我们的文件夹中 

1015
00:55:32,320 --> 00:55:39,460
所以创建一个新文件 pipe.lua 我要

1016
00:55:39,460 --> 00:55:42,370
继续 并在这里引用一下音符 

1017
00:55:52,650 --> 00:55:56,900
所以管道类实际上非常简单 

1018
00:55:56,900 --> 00:55:59,115
就像最初的鸟类课一样 

1019
00:55:59,115 --> 00:56:00,990
我们不需要跟踪大量的数据 

1020
00:56:00,990 --> 00:56:03,770
但我们确实想要跟踪一些事情 

1021
00:56:03,770 --> 00:56:08,510
所以这只鸟--只会有一只鸟出来

1022
00:56:08,510 --> 00:56:11,900
一次 但是有了管子 我们就会把它们生出来 

1023
00:56:11,900 --> 00:56:13,170
一遍又一遍 

1024
00:56:13,170 --> 00:56:15,680
所以如果我们分配给他们--

1025
00:56:15,680 --> 00:56:20,030
对于我们实例化的每个管道 如果我们分配一个新的映像 

1026
00:56:20,030 --> 00:56:22,550
这可能不是很有效率 对吧？

1027
00:56:22,550 --> 00:56:23,930
我们使用的是相同的数据 

1028
00:56:23,930 --> 00:56:25,550
我们有一堆管子 

1029
00:56:25,550 --> 00:56:28,040
我们真的只需要一个精灵 

1030
00:56:28,040 --> 00:56:32,180
所以在init函数之外--就在哪里

1031
00:56:32,180 --> 00:56:34,882
我们声明管道是一个类 我们是

1032
00:56:34,882 --> 00:56:37,340
接下来我们将创建一个局部变量 该变量仍然

1033
00:56:37,340 --> 00:56:40,100
作用域为此文件 但只有

1034
00:56:40,100 --> 00:56:44,280
是这个物体的一个副本 

1035
00:56:44,280 --> 00:56:46,750
我们将把它命名为--

1036
00:56:46,750 --> 00:56:50,120
假设我们在此文件夹中有pipe.png 

1037
00:56:50,120 --> 00:56:52,290
这是从功能中分离出来的

1038
00:56:52,290 --> 00:56:54,331
我们将在这里定义 但这

1039
00:56:54,331 --> 00:56:59,180
具有创建半全局图形对象的效果 

1040
00:56:59,180 --> 00:57:02,124
即使它包含在这个类文件中 

1041
00:57:02,124 --> 00:57:04,040
它不能在这个类文件之外访问

1042
00:57:04,040 --> 00:57:05,390
因为我们不需要这样 

1043
00:57:05,390 --> 00:57:09,290
但它也不是每次都被实例化 因为回想一下 

1044
00:57:09,290 --> 00:57:16,430
如果我们看一下Bird.Lua 我们只是在设置它

1045
00:57:16,430 --> 00:57:20,600
As self.Image获得love.graph ics.newImage Bird.png 

1046
00:57:20,600 --> 00:57:24,440
这将产生每次都分配一个新图像的效果

1047
00:57:24,440 --> 00:57:25,880
我们创建了一个鸟对象 

1048
00:57:25,880 --> 00:57:29,570
但我们只创建了一个鸟对象 所以它并不是一个真正重要的设计

1049
00:57:29,570 --> 00:57:36,080
考虑到我们会说 也许我们应该创造一个半全球化的形象

1050
00:57:36,080 --> 00:57:37,250
这里 

1051
00:57:37,250 --> 00:57:39,050
在这种情况下 这并不重要 

1052
00:57:39,050 --> 00:57:43,670
对于更大的项目来说 这样做可能是一种不错的风格 但只是

1053
00:57:43,670 --> 00:57:44,837
这是这里的一个考虑因素 

1054
00:57:44,837 --> 00:57:46,670
这不是我们需要担心的事 

1055
00:57:46,670 --> 00:57:51,020
但是的 一定要试着拿到一笔资产 

1056
00:57:51,020 --> 00:57:56,045
并引用它 而不是尽可能多次地分配它 

1057
00:57:59,090 --> 00:58:00,950
我们希望我们的烟斗可以滚动 

1058
00:58:00,950 --> 00:58:02,330
因此 我们需要某种价值 

1059
00:58:02,330 --> 00:58:04,039
就像我们处理背景一样 我们

1060
00:58:04,039 --> 00:58:06,954
需要一些值来跟踪这些管道是否正在滚动 

1061
00:58:06,954 --> 00:58:08,390
它可以是一个常量值 

1062
00:58:08,390 --> 00:58:11,510
这一次我们直接把它称为负60 

1063
00:58:11,510 --> 00:58:18,360
而不是在我们稍后将其添加到我们的立场时予以否定 

1064
00:58:18,360 --> 00:58:24,590
所以PIPE_SCROLL负60 我们可以直接加到我们的x上 或者加到我们的--

1065
00:58:24,590 --> 00:58:26,455
是的 在这种情况下 只给我们的x 而且它

1066
00:58:26,455 --> 00:58:28,730
当然 会有-增量时间 

1067
00:58:28,730 --> 00:58:30,890
这将产生转移的效果

1068
00:58:30,890 --> 00:58:33,990
它离开是因为它是负数 

1069
00:58:33,990 --> 00:58:35,490
我们将在这里定义init函数 

1070
00:58:35,490 --> 00:58:37,760
所以 通过管道初始化 

1071
00:58:37,760 --> 00:58:40,460
在init函数中 我们要做几件事 

1072
00:58:40,460 --> 00:58:43,130
所以是x 

1073
00:58:43,130 --> 00:58:45,360
X应该在哪里？

1074
00:58:45,360 --> 00:58:49,340
比方说 如果我们希望管道产生 x应该设置为多少

1075
00:58:49,340 --> 00:58:51,702
超出屏幕右边缘？

1076
00:58:51,702 --> 00:58:55,630
观众：[听不见]

1077
00:58:55,630 --> 00:58:58,540
科尔顿·奥格登：虚拟宽度 你还可以

1078
00:58:58,540 --> 00:59:01,420
假设虚拟宽度加上一些数字 如果你想的话 

1079
00:59:01,420 --> 00:59:04,600
因为它被设置为0 0 所以它将有

1080
00:59:04,600 --> 00:59:07,660
你不会在实例化的画面上看到它 

1081
00:59:07,660 --> 00:59:12,310
但是的 虚拟宽度或虚拟宽度加上某个常量值 或一些

1082
00:59:12,310 --> 00:59:14,260
您已提前分配的值 

1083
00:59:14,260 --> 00:59:15,847
我们只需将其设置为虚拟宽度 

1084
00:59:15,847 --> 00:59:18,430
所以一旦管道被初始化 它就是不可见的 

1085
00:59:18,430 --> 00:59:22,390
但它会出现在屏幕的右边 

1086
00:59:22,390 --> 00:59:25,150
我们的y值呢？

1087
00:59:25,150 --> 00:59:29,260
首先 让我们看看图像是什么样子的 这样我们就可以看到了 

1088
00:59:29,260 --> 00:59:31,210
它将出现在我们的.

1089
00:59:31,210 --> 00:59:33,775
我不认为我在那个目录中有实际的图像 

1090
00:59:33,775 --> 00:59:34,960
所以我要来这里 

1091
00:59:34,960 --> 00:59:36,520
我去拿烟斗 

1092
00:59:36,520 --> 00:59:38,390
这就是管子的样子 

1093
00:59:38,390 --> 00:59:40,446
让我们看看我能不能把它扩大一点 

1094
00:59:44,795 --> 00:59:45,670
所以它有点高 

1095
00:59:45,670 --> 00:59:48,680
如果我们想要 我们应该把它放在哪里

1096
00:59:48,680 --> 00:59:54,420
它看起来像飞鸟吗？

1097
00:59:54,420 --> 00:59:58,050
很可能是在屏幕的下端 

1098
00:59:58,050 --> 01:00:00,420
我们也可以幻想它 我们甚至可以

1099
01:00:00,420 --> 01:00:02,919
让它像Flappy Bird那样随机化 

1100
01:00:02,919 --> 01:00:04,210
因此 我们将继续 并做到这一点 

1101
01:00:04,210 --> 01:00:07,290
我将继续复制 并将其放入我们的临时文件夹中

1102
01:00:07,290 --> 01:00:10,170
这里 

1103
01:00:10,170 --> 01:00:14,190
回到init函数 我将继续 并设置self.y 

1104
01:00:14,190 --> 01:00:17,100
因为我们想谈的是程序生成 

1105
01:00:17,100 --> 01:00:19,850
这将是我们第一次尝试如何随机化这一点 

1106
01:00:19,850 --> 01:00:23,394
我们将使用上周使用的函数 

1107
01:00:23,394 --> 01:00:24,810
这是一个无处不在的函数 

1108
01:00:24,810 --> 01:00:29,440
你会在你使用的任何框架或游戏引擎中随处可见--

1109
01:00:29,440 --> 01:00:31,900
数学 随机的 

1110
01:00:31,900 --> 01:00:34,690
我们希望它是屏幕的下半部分 

1111
01:00:34,690 --> 01:00:38,700
假设虚拟高度除以4是上限 也许

1112
01:00:38,700 --> 01:00:44,950
虚拟高度减去10作为上限 

1113
01:00:44,950 --> 01:00:49,110
因此 这将产生将其设置为大约四分之一屏幕的效果 

1114
01:00:49,110 --> 01:00:52,694
抱歉 虚拟高度除以4是屏幕的最高端 

1115
01:00:52,694 --> 01:00:55,360
然后虚拟高度减去10就是屏幕的下端 

1116
01:00:55,360 --> 01:00:59,220
因此 它实际上将覆盖从低于这一水平的第一季度开始的任何地方

1117
01:00:59,220 --> 01:01:00,780
从底部到大约10个像素 

1118
01:01:00,780 --> 01:01:03,902
观众：你一定要在这里面设置随机种子吗？

1119
01:01:03,902 --> 01:01:04,800
或者你主要做这件事？

1120
01:01:04,800 --> 01:01:06,050
科尔顿·奥格登：我在美因河畔做 

1121
01:01:06,050 --> 01:01:11,430
因此 在这个文件中 我不确定我这样做是否是为了这个演示 

1122
01:01:11,430 --> 01:01:13,395
这肯定是在回购中设定的 

1123
01:01:16,245 --> 01:01:18,750
我不认为我在这个例子中设置了它 但是 是的 您

1124
01:01:18,750 --> 01:01:21,570
如果您想让它每次都运行 就会在这里设置随机种子 

1125
01:01:21,570 --> 01:01:22,080
抱歉的 

1126
01:01:22,080 --> 01:01:26,850
问题是 我们是否应该在BIRD文件中设置随机种子 

1127
01:01:26,850 --> 01:01:29,130
或者我们应该把它设在主星上？

1128
01:01:29,130 --> 01:01:32,590
通常 您希望在应用程序的顶级设置它 

1129
01:01:32,590 --> 01:01:36,210
所以我们要把它放进去--

1130
01:01:36,210 --> 01:01:41,610
我们将继续 并将其设置为Main 

1131
01:01:41,610 --> 01:01:54,880
函数本身就在这里 我认为它是从Bird6开始的 从6开始 

1132
01:01:54,880 --> 01:01:55,610
所以它将会是--

1133
01:02:00,030 --> 01:02:01,300
我没设好吗？

1134
01:02:01,300 --> 01:02:04,254
我可能要到回购的晚些时候才会设置随机种子 

1135
01:02:04,254 --> 01:02:05,045
让我们检查一下Bird12 

1136
01:02:09,810 --> 01:02:13,170
所以 是的 数学 随机种子 然后是os.time的种子 

1137
01:02:13,170 --> 01:02:15,300
就像我们上周在课堂上用到的一样 

1138
01:02:18,160 --> 01:02:20,850
我把它放在这里 

1139
01:02:20,850 --> 01:02:23,370
也许 我们只会运行一次 但它会产生效果 

1140
01:02:23,370 --> 01:02:27,780
现在我们可以运行几次 看看管道中的不同之处 

1141
01:02:27,780 --> 01:02:37,200
让我们回到我们的管道 Lua在这里 我们有x y 

1142
01:02:37,200 --> 01:02:39,700
因此 这些都是相应地设置的 

1143
01:02:39,700 --> 01:02:41,340
我们还想设置宽度 

1144
01:02:41,340 --> 01:02:50,210
有人记得获取图形对象宽度的函数是什么吗

1145
01:02:50,210 --> 01:02:53,370
它的语法是什么？

1146
01:02:53,370 --> 01:02:56,420
所以我们在这里有我们的图像 管道图像 

1147
01:02:56,420 --> 01:02:58,700
它是love.graph ic.newImage pipe.png 

1148
01:03:01,480 --> 01:03:02,944
观众：[听不见]

1149
01:03:02,944 --> 01:03:03,920
科尔顿·奥格登：没错 

1150
01:03:03,920 --> 01:03:08,700
因此 我们将继续 并将其设置为PIPE_IMAGE冒号getWidth 

1151
01:03:08,700 --> 01:03:13,785
这将成为我们的新--这将使我们能够存储我们的宽度以备

1152
01:03:13,785 --> 01:03:14,940
我们稍后将使用它 

1153
01:03:18,430 --> 01:03:20,770
然后我们还需要一些其他函数 

1154
01:03:20,770 --> 01:03:24,000
所以烟斗会产生 但它不会移动 因为我们还没有

1155
01:03:24,000 --> 01:03:26,700
对它进行了任何形式的滚动 

1156
01:03:26,700 --> 01:03:29,520
我们在第五行有滚动的变量 

1157
01:03:29,520 --> 01:03:31,680
但我们需要将其实际应用到我们的管道中 

1158
01:03:31,680 --> 01:03:35,650
所以我们将继续 并创建一个更新函数 

1159
01:03:35,650 --> 01:03:38,580
然后在更新函数中 非常类似于

1160
01:03:38,580 --> 01:03:43,690
我们以前已经见过 pio_scroll乘以增量时间 

1161
01:03:43,690 --> 01:03:46,560
最后 我们想要渲染我们的烟斗 

1162
01:03:46,560 --> 01:03:50,640
所以我们将继续 调用我们今天已经看到的函数 

1163
01:03:50,640 --> 01:03:57,060
我们将使用上面的管子图像 

1164
01:03:57,060 --> 01:04:02,040
然后我们将继续使用self.x 

1165
01:04:02,040 --> 01:04:07,080
和自己 这就是我们的烟斗所需要的 

1166
01:04:07,080 --> 01:04:09,949
让我确保这就是我们真正需要的 

1167
01:04:09,949 --> 01:04:12,990
所以在主流星中--我们也必须回到主流星 因为我们实际上

1168
01:04:12,990 --> 01:04:14,198
必须开始产卵了 

1169
01:04:17,790 --> 01:04:20,990
所以让我们继续 去--

1170
01:04:20,990 --> 01:04:23,790
让我在这里再次调出我的代码 

1171
01:04:26,540 --> 01:04:30,510
在主线上--所以在第59行--

1172
01:04:30,510 --> 01:04:31,910
抱歉 你看不到的 

1173
01:04:31,910 --> 01:04:34,200
您将在实际发行版代码的第59行中看到它 

1174
01:04:34,200 --> 01:04:38,460
但对我来说 情况会略有不同 

1175
01:04:38,460 --> 01:04:41,210
我们将继续 并创建一个新表

1176
01:04:41,210 --> 01:04:44,060
来跟踪我们想要产生的所有管道 因为我们

1177
01:04:44,060 --> 01:04:45,518
需要一种方法将它们存储在内存中 

1178
01:04:45,518 --> 01:04:48,080
我们不能只设置一个变量来--

1179
01:04:48,080 --> 01:04:53,690
基本上 在这种情况下几乎像一个动态数组 或者更确切地说是一个链表 

1180
01:04:53,690 --> 01:04:55,844
我们要用这张桌子来容纳他们 

1181
01:04:55,844 --> 01:04:57,260
我们不会给他们钥匙的 

1182
01:04:57,260 --> 01:04:59,270
我们只需像我们所做的那样插入它们

1183
01:04:59,270 --> 01:05:03,830
例如 只需像在Python中那样使用链接列表即可 

1184
01:05:03,830 --> 01:05:07,880
我们要继续前进 我们需要什么

1185
01:05:07,880 --> 01:05:13,295
如果我们想让它们在一段时间后产卵怎么办？

1186
01:05:17,030 --> 01:05:19,000
可能想要一个计时器 

1187
01:05:19,000 --> 01:05:21,410
我们想要记录已经过去了多少时间 

1188
01:05:21,410 --> 01:05:23,720
也许会有一些时间

1189
01:05:23,720 --> 01:05:26,340
那是我们产生烟斗的触发点 

1190
01:05:26,340 --> 01:05:28,290
比方说大概两秒钟 

1191
01:05:28,290 --> 01:05:32,700
所以如果我们将计时器设置为0 它就从0开始 

1192
01:05:32,700 --> 01:05:35,390
但我们可以一帧一帧地添加 

1193
01:05:35,390 --> 01:05:40,370
我们可以将计时器增加增量时间 无论是什么 逐帧增加 

1194
01:05:40,370 --> 01:05:42,560
大概是1/60秒 

1195
01:05:42,560 --> 01:05:47,600
因此 在60帧之后 我们将有一秒钟的时间 

1196
01:05:47,600 --> 01:05:50,480
在120帧之后 我们将有两秒钟的时间 

1197
01:05:50,480 --> 01:05:54,180
在这一点上 我们可以决定好了 现在是时候产生一个新的管道了 

1198
01:05:54,180 --> 01:05:56,100
让我们继续做这件事吧 

1199
01:05:56,100 --> 01:06:06,780
因此 我将继续 在我们的更新功能中 

1200
01:06:06,780 --> 01:06:12,900
我们希望处理此计时器的实际增加 

1201
01:06:12,900 --> 01:06:16,290
所以这很简单--

1202
01:06:16,290 --> 01:06:18,915
我确定我把它叫做spawnTimer 

1203
01:06:18,915 --> 01:06:20,130
不 我只是叫它定时器 

1204
01:06:20,130 --> 01:06:21,755
让我们继续 并将其命名为spawnTimer 

1205
01:06:21,755 --> 01:06:24,670
更具体一点 我们想要什么 

1206
01:06:24,670 --> 01:06:25,702
所以我们的spawnTimer 

1207
01:06:25,702 --> 01:06:27,660
然后我们将继续更新 

1208
01:06:27,660 --> 01:06:34,740
并将spawnTimer设置为等于spawnTimer加上增量时间 

1209
01:06:34,740 --> 01:06:39,390
然后我们需要做的就是检查

1210
01:06:39,390 --> 01:06:42,277
我们的产卵计时器是否大于--因为它

1211
01:06:42,277 --> 01:06:44,610
以秒为单位跟踪时间 增量时间将为您提供

1212
01:06:44,610 --> 01:06:45,990
以秒为单位的分数 

1213
01:06:45,990 --> 01:06:49,510
所以它将在0.013 或类似的地方 

1214
01:06:49,510 --> 01:06:54,120
我们希望跟踪spawnTimer是否已经过了两点 对吗？

1215
01:06:54,120 --> 01:07:02,580
因此 如果spawnTimer大于2 我们希望添加一个新管道 

1216
01:07:02,580 --> 01:07:05,840
有人记得Lua中如何添加到表中的函数吗？

1217
01:07:09,450 --> 01:07:12,520
所以它是桌子 插入 

1218
01:07:12,520 --> 01:07:15,600
因此 Table.Insert将接受一个表 

1219
01:07:15,600 --> 01:07:19,770
因此 在本例中 我们需要前面分配的管道表 

1220
01:07:19,770 --> 01:07:23,450
然后我们要放入一个新的管道对象 

1221
01:07:23,450 --> 01:07:27,040
这就是为调用实例化对象的方式 圆括号 

1222
01:07:27,040 --> 01:07:29,480
这将对我们现在的管道产生影响

1223
01:07:29,480 --> 01:07:33,094
表将--每次我们调用它时 它都会得到一个新的索引 

1224
01:07:33,094 --> 01:07:34,260
所以它将从1开始 

1225
01:07:34,260 --> 01:07:37,222
LUA表的索引值为1 

1226
01:07:37,222 --> 01:07:39,320
第一次发生这种情况时 index1将

1227
01:07:39,320 --> 01:07:42,810
等于将要启动的新管道对象

1228
01:07:42,810 --> 01:07:45,530
它的XY在屏幕的边缘 

1229
01:07:45,530 --> 01:07:49,430
那么index2将是完全相同的东西 一个新的管道

1230
01:07:49,430 --> 01:07:52,370
在屏幕的边缘 诸如此类 每次我们

1231
01:07:52,370 --> 01:07:53,540
调用表 插入 

1232
01:07:56,180 --> 01:07:59,750
一旦我们的产卵计时器超过2 如果我们不想这样做

1233
01:07:59,750 --> 01:08:06,020
之后每一帧都会产生一根烟斗 很快就会堵塞我们的世界 

1234
01:08:06,020 --> 01:08:07,880
我们希望将产卵计时器重置为0 

1235
01:08:07,880 --> 01:08:11,360
所以这将产生现在的效果 它将再等待2秒 

1236
01:08:11,360 --> 01:08:13,457
然后这个条件将再次成为真的 

1237
01:08:13,457 --> 01:08:15,290
然后我们可以在场景中添加一个新的管道 

1238
01:08:19,180 --> 01:08:23,654
让我们继续来看看--

1239
01:08:23,654 --> 01:08:29,240
我们需要在这里添加一组新的逻辑 

1240
01:08:29,240 --> 01:08:39,040
事实上 我会把所有这些放在鸟的上面 更新 

1241
01:08:39,040 --> 01:08:42,119
然后在这下面 我将继续 并做--

1242
01:08:42,119 --> 01:08:43,910
我不确定我们是否已经谈到这一点 

1243
01:08:43,910 --> 01:08:46,835
我不认为我们有 但如果我们想迭代一个表 

1244
01:08:46,835 --> 01:08:48,960
Lua给了你一个叫做Pair的函数 

1245
01:08:48,960 --> 01:08:52,750
它将为您提供表的所有键值对

1246
01:08:52,750 --> 01:08:55,149
然后您可以在迭代它时使用它 

1247
01:08:55,149 --> 01:08:57,700
类似于在Python中枚举 如果熟悉 

1248
01:08:57,700 --> 01:09:02,120
不过 这实际上会给你提供关键字 而不仅仅是索引 

1249
01:09:02,120 --> 01:09:11,890
所以我们可以对k做 成对的管道做一些主体代码 

1250
01:09:11,890 --> 01:09:14,890
然后我们可以访问密钥和其中的管道 

1251
01:09:14,890 --> 01:09:17,510
我们可以只迭代它 并使用它 

1252
01:09:17,510 --> 01:09:20,580
因此 我们要做的第一件事是更新管道 

1253
01:09:20,580 --> 01:09:22,330
因此 对于每个管道 更新它 

1254
01:09:22,330 --> 01:09:26,770
为其指定当前帧的增量时间 

1255
01:09:26,770 --> 01:09:28,929
那么另一个重要的特点是什么呢？

1256
01:09:28,929 --> 01:09:30,970
因此 这将具有滚动它的效果 

1257
01:09:30,970 --> 01:09:33,370
它会把它的x移位 但是

1258
01:09:33,370 --> 01:09:36,861
我们需要对场景中的每一根烟斗做的另一件重要的事情是吗？

1259
01:09:36,861 --> 01:09:42,410
观众：当x小于0时 我们必须[INAUDIBLE]

1260
01:09:42,410 --> 01:09:44,090
科尔顿·奥格登：是的 

1261
01:09:44,090 --> 01:09:45,600
这完全是真的 

1262
01:09:45,600 --> 01:09:50,680
所以我们要做的是 如果pipe.x小于--

1263
01:09:50,680 --> 01:09:55,331
如果我们做的小于0 我们认为会发生什么？

1264
01:09:55,331 --> 01:09:58,850
观众：[听不见]

1265
01:09:58,850 --> 01:10:01,940
科尔顿·奥格登：我们会看到它立即消失 因为他们

1266
01:10:01,940 --> 01:10:03,590
根据左上角的坐标 

1267
01:10:03,590 --> 01:10:07,830
所以我们需要做的就是跟踪它的宽度 

1268
01:10:07,830 --> 01:10:09,980
所以我们要做的就是说如果pipe.x

1269
01:10:09,980 --> 01:10:15,500
小于负数pipe.width 这将允许管道

1270
01:10:15,500 --> 01:10:19,860
要一直穿过屏幕的边缘 

1271
01:10:19,860 --> 01:10:23,450
我们将调用一个名为Table.Remove的函数 该函数接受一个表 

1272
01:10:23,450 --> 01:10:26,600
在这种情况下 管道 然后它需要一把钥匙 

1273
01:10:26,600 --> 01:10:29,480
以及我们可以在124号线上获得的密钥 

1274
01:10:29,480 --> 01:10:32,090
我们可以只说k 这会产生这样的效果

1275
01:10:32,090 --> 01:10:36,560
把那根烟斗从现场移走 

1276
01:10:36,560 --> 01:10:40,370
一旦做完了 我们就可以走了 

1277
01:10:40,370 --> 01:10:42,817
我们现在最不需要做的就是 

1278
01:10:42,817 --> 01:10:44,900
我们实际上并没有将管道绘制到屏幕上 

1279
01:10:44,900 --> 01:10:50,750
所以在下面的渲染函数中 我们将继续 并在上面--

1280
01:10:50,750 --> 01:10:55,310
在我们做地面之前 因为如果我们正常地做--

1281
01:10:55,310 --> 01:10:57,764
如果我们在铺好地面后再做 这些管道

1282
01:10:57,764 --> 01:11:00,680
看起来就像是层叠在地面上 

1283
01:11:00,680 --> 01:11:03,620
我们希望它看起来像是从地面上伸出来的 

1284
01:11:03,620 --> 01:11:06,830
所以我们想要做的是有一个正确的渲染层 

1285
01:11:06,830 --> 01:11:08,780
将绘制顺序渲染到屏幕 

1286
01:11:08,780 --> 01:11:11,810
我们画背景 画管子 然后画地面 

1287
01:11:11,810 --> 01:11:14,120
这将产生管道看起来像是伸出的效果

1288
01:11:14,120 --> 01:11:15,140
在地面上 

1289
01:11:15,140 --> 01:11:18,170
所以我们要做的就是和刚才做的完全一样

1290
01:11:18,170 --> 01:11:31,050
上面通过说for k 管道成对地做管道 

1291
01:11:31,050 --> 01:11:33,480
然后是我们在PIPE中定义的呈现函数 

1292
01:11:33,480 --> 01:11:35,230
这将产生迭代的效果

1293
01:11:35,230 --> 01:11:37,530
通过我们场景中所有的管道 每个抽签电话 

1294
01:11:37,530 --> 01:11:41,160
在它画地面之前画它们 在它画鸟之前 

1295
01:11:41,160 --> 01:11:44,534
这应该就是我们所需要的 来说明这个例子 

1296
01:11:44,534 --> 01:11:46,075
让我确保所有东西都保存好了 

1297
01:11:46,075 --> 01:11:50,660
我要继续往前走 走进鸟巢 

1298
01:11:50,660 --> 01:11:56,610
如果我做的每件事都是正确的 那么在一段时间之后 

1299
01:11:56,610 --> 01:11:59,820
将正在滚动的管道放到屏幕上 它们是随机的 

1300
01:11:59,820 --> 01:12:02,760
它们的y值被设置为某个值

1301
01:12:02,760 --> 01:12:05,610
在屏幕顶部的四分之一之间 

1302
01:12:05,610 --> 01:12:09,190
所以从Flappy Bird现在的位置开始 向下

1303
01:12:09,190 --> 01:12:12,017
大约10个像素以上的屏幕宽度 这实际上 

1304
01:12:12,017 --> 01:12:13,350
这看起来像是10个像素以上 

1305
01:12:13,350 --> 01:12:14,570
所以这是一个小小的漏洞 

1306
01:12:14,570 --> 01:12:18,030
它可能应该在30或40左右 

1307
01:12:18,030 --> 01:12:19,890
我们不会在最终发行版中遇到这种情况

1308
01:12:19,890 --> 01:12:22,980
因为它们不会产卵那么低 

1309
01:12:22,980 --> 01:12:27,510
但是你可以看到这在某种程度上是我们程序层面的开始

1310
01:12:27,510 --> 01:12:31,480
生成系统 我们拥有场景的几乎所有组件 

1311
01:12:31,480 --> 01:12:35,040
现在 在Flappy Bird中 我们通常有两个管子 

1312
01:12:35,040 --> 01:12:38,730
我们在上面有一根管道 然后在下面有一根管道 

1313
01:12:38,730 --> 01:12:39,666
他们是成对的 

1314
01:12:39,666 --> 01:12:42,540
在下一个例子中 我们实际上将开始说明这一点 

1315
01:12:42,540 --> 01:12:45,360
我们将有几对连接在一起的管子 

1316
01:12:45,360 --> 01:12:46,620
它们一起滚动 

1317
01:12:46,620 --> 01:12:51,240
一旦你飞过它们 你就得了一分 

1318
01:12:51,240 --> 01:12:53,130
但就目前而言 我们拥有我们所有的碎片

1319
01:12:53,130 --> 01:13:00,310
需要有基本的视觉感才能完成游戏 

1320
01:13:00,310 --> 01:13:04,450
我们现在休息五分钟 等我们回来后 

1321
01:13:04,450 --> 01:13:07,850
我们将深入研究如何将成对的管道引入我们的场景中 

1322
01:13:07,850 --> 01:13:10,790
开始打球 做一些其他有趣的事情 比如音乐 

1323
01:13:14,050 --> 01:13:15,250
好了 欢迎回来 

1324
01:13:15,250 --> 01:13:16,600
所以下一部分--

1325
01:13:16,600 --> 01:13:20,790
所以在我们确定鸟的背景和管子之前 

1326
01:13:20,790 --> 01:13:23,940
我们已经准备好了比赛的所有视觉方面 

1327
01:13:23,940 --> 01:13:26,190
真正要解决的下一个重要问题是

1328
01:13:26,190 --> 01:13:29,550
我们怎么才能开始得分 我们怎么才能

1329
01:13:29,550 --> 01:13:33,330
让管道与它们在实际游戏中实现的方式相匹配？

1330
01:13:33,330 --> 01:13:38,430
回想一下 它们通常是成对的 如图所示 

1331
01:13:38,430 --> 01:13:41,430
我们也看到在右手边 正如我们到目前为止已经介绍过的那样 

1332
01:13:41,430 --> 01:13:44,130
我们有放烟斗的产卵区 在左边 

1333
01:13:44,130 --> 01:13:46,050
我们有我所说的死亡区 在那里

1334
01:13:46,050 --> 01:13:49,980
管道一旦消失就被取消实例化

1335
01:13:49,980 --> 01:13:52,410
越过了它们自身的负宽度 

1336
01:13:52,410 --> 01:13:55,380
但管子是成对的 他们会被移位 

1337
01:13:55,380 --> 01:13:58,941
一旦鸟儿在这些缝隙之间飞翔 

1338
01:13:58,941 --> 01:14:00,690
最终是当他们得到一分的时候 

1339
01:14:00,690 --> 01:14:07,620
因此 我们需要一种将管道配对在一起的方法 并定义这种逻辑

1340
01:14:07,620 --> 01:14:11,010
我们能说出这只鸟是否已经越过了缺口 

1341
01:14:11,010 --> 01:14:14,500
以及管道是否已被取消实例化 

1342
01:14:14,500 --> 01:14:17,760
所以我们要继续下去 我可能会

1343
01:14:17,760 --> 01:14:20,760
停止对其余演示进行实时编码

1344
01:14:20,760 --> 01:14:23,730
因为它们会变得更复杂一些 

1345
01:14:23,730 --> 01:14:28,190
但我相信我的代码编辑器在这里 

1346
01:14:28,190 --> 01:14:30,690
我要继续 然后打开--

1347
01:14:30,690 --> 01:14:32,680
哦 这是我的另一位编辑 

1348
01:14:32,680 --> 01:14:37,030
现在 在基本回购中 我们将继续 并查看完整的示例 

1349
01:14:37,030 --> 01:14:40,930
所以在Bird6中 这是管子对的更新--

1350
01:14:40,930 --> 01:14:44,440
我们现在看到的子文件夹--

1351
01:14:44,440 --> 01:14:45,660
我们要从美因河开始 

1352
01:14:45,660 --> 01:14:51,390
所以在Main的第33行 

1353
01:14:51,390 --> 01:14:53,820
我们可以看到我们正在获取管道对 它

1354
01:14:53,820 --> 01:14:55,440
是我们正在定义的一个新类别 

1355
01:14:55,440 --> 01:14:58,350
我们要用以前用过的管子 

1356
01:14:58,350 --> 01:15:00,500
我们正在创建一个新的复合类 

1357
01:15:00,500 --> 01:15:04,440
所以我们将获取一个将两个管道封装在一起的类 

1358
01:15:04,440 --> 01:15:08,400
一对管道 我们将用它来更多地思考我们的问题

1359
01:15:08,400 --> 01:15:10,050
比我们已经拥有的更抽象 

1360
01:15:10,050 --> 01:15:13,669
这种抽象的分层是一个非常重要的概念

1361
01:15:13,669 --> 01:15:15,960
在计算机科学中 一般说来 但特别是

1362
01:15:15,960 --> 01:15:19,470
在游戏中 您可能拥有由以下对象组合而成的对象

1363
01:15:19,470 --> 01:15:22,350
是对象的组合 而这些抽象层次结构是

1364
01:15:22,350 --> 01:15:24,600
是什么让程序员在处理事务时保持理智

1365
01:15:24,600 --> 01:15:28,800
当你有数千行代码时 有这么多级别的代码 

1366
01:15:28,800 --> 01:15:32,550
这是你真正理解它的唯一方法 

1367
01:15:32,550 --> 01:15:35,430
所以在第65行 如果我们看--

1368
01:15:35,430 --> 01:15:39,060
现在 我们将其重命名为管道对 而不是称为管道的表 

1369
01:15:39,060 --> 01:15:41,670
我们不再在场景中存储单个管道 

1370
01:15:41,670 --> 01:15:44,100
我们要把这些管子对 我们

1371
01:15:44,100 --> 01:15:51,270
我要创建它们 并将它们存储在我们的表中以及单个单元中 

1372
01:15:51,270 --> 01:15:56,390
在第71行 我们需要一个变量来跟踪--

1373
01:15:56,390 --> 01:15:58,500
我们把它叫做最后一年 

1374
01:15:58,500 --> 01:16:00,930
此变量的用途是为了让我们

1375
01:16:00,930 --> 01:16:04,620
可以跟踪最后一组管道产生缺口的位置 

1376
01:16:04,620 --> 01:16:08,060
因为如果我们让我们的差距完全随机的话 

1377
01:16:08,060 --> 01:16:12,840
它将产生一种效果 看起来不像是连续的 

1378
01:16:12,840 --> 01:16:15,450
也有可能是无法击败的 

1379
01:16:15,450 --> 01:16:19,580
我们想要一些光滑的轮廓来填补我们的缝隙

1380
01:16:19,580 --> 01:16:21,640
这样我们才能合理地飞越它们 

1381
01:16:21,640 --> 01:16:24,810
而且它看起来几乎是预制的 而且很光滑 

1382
01:16:24,810 --> 01:16:27,270
所以我们将跟踪一个名为last y的变量 

1383
01:16:27,270 --> 01:16:30,180
我们要从负管高开始 

1384
01:16:30,180 --> 01:16:37,830
超出屏幕顶部 加上介于1和80之间的某个值

1385
01:16:37,830 --> 01:16:39,030
和20岁 

1386
01:16:39,030 --> 01:16:42,340
它将大致位于屏幕的顶部 

1387
01:16:42,340 --> 01:16:45,900
这一点很重要 因为最后一个y是

1388
01:16:45,900 --> 01:16:49,976
我们将会--我们将会翻转我们的雪碧 

1389
01:16:49,976 --> 01:16:55,020
在y轴上翻转的结果是精灵看起来

1390
01:16:55,020 --> 01:16:59,580
就好像它的整个高度都超过了实际的y 

1391
01:16:59,580 --> 01:17:02,400
我们稍后会详细解释为什么

1392
01:17:02,400 --> 01:17:05,690
这最终会以它的方式工作 

1393
01:17:05,690 --> 01:17:15,150
我们要下到132行 在我们的条件下 

1394
01:17:15,150 --> 01:17:20,220
如果我们的spawnTimer大于2 我们要做的是

1395
01:17:20,220 --> 01:17:22,830
这是我们之前制作管道的地方

1396
01:17:22,830 --> 01:17:26,070
但现在我们正在生产成对的管道 

1397
01:17:26,070 --> 01:17:29,460
所以我们要设置一个局部变量y 

1398
01:17:29,460 --> 01:17:31,230
这将是-

1399
01:17:31,230 --> 01:17:34,050
这是我们上周讲过的夹钳操作

1400
01:17:34,050 --> 01:17:38,730
使用math.max和math.min来应用某种操作 

1401
01:17:38,730 --> 01:17:42,060
在本例中 我们将在负20之间添加一个随机值

1402
01:17:42,060 --> 01:17:44,850
20的y值 

1403
01:17:44,850 --> 01:17:49,690
将有效地将间隙移动负20或20个像素 

1404
01:17:49,690 --> 01:17:52,530
我们要把它夹在负管道高度加10之间 

1405
01:17:52,530 --> 01:17:56,100
离屏幕顶部大约10个像素 

1406
01:17:56,100 --> 01:18:02,520
然后我们将上限设为虚高减90

1407
01:18:02,520 --> 01:18:03,420
减去管道高度 

1408
01:18:03,420 --> 01:18:07,800
这个负管光只是因为我们在做翻转操作

1409
01:18:07,800 --> 01:18:09,750
在我们的精灵的y轴上 

1410
01:18:09,750 --> 01:18:11,850
我会更详细地讲

1411
01:18:11,850 --> 01:18:14,880
来解释我们为什么要这么做

1412
01:18:14,880 --> 01:18:17,760
也许我会拿出一些代码来说明它的样子

1413
01:18:17,760 --> 01:18:20,190
就像没有那个操作一样 

1414
01:18:20,190 --> 01:18:23,400
但基本上 它有从底部90像素的效果

1415
01:18:23,400 --> 01:18:26,550
是鸿沟产生的地方

1416
01:18:26,550 --> 01:18:29,540
基本上 就是最底下的管子 

1417
01:18:29,540 --> 01:18:31,600
回想一下 这个差距就是--

1418
01:18:31,600 --> 01:18:35,370
该值是间隙本身开始的位置 不一定

1419
01:18:35,370 --> 01:18:38,680
管道的起点

1420
01:18:38,680 --> 01:18:42,690
它会在负管道高度加10之间 

1421
01:18:42,690 --> 01:18:47,820
基本上 有效地 在屏幕顶部的10个像素之间 

1422
01:18:47,820 --> 01:18:50,560
在距离屏幕底部90个像素之间 

1423
01:18:50,560 --> 01:18:55,530
然后我们将应用这个值的随机排列 

1424
01:18:55,530 --> 01:18:58,590
我们要在负20和20之间加上一个值 

1425
01:18:58,590 --> 01:19:03,000
这将给我们一个等高线 这将是一个随机的等高线 

1426
01:19:06,540 --> 01:19:09,960
136线 我们有一对管子 

1427
01:19:09,960 --> 01:19:14,070
将桌子插入其中 而不是管道 我们只是添加了一个新管道对 

1428
01:19:14,070 --> 01:19:18,030
我们将它设置为y的值 

1429
01:19:18,030 --> 01:19:21,820
然后管子对接受y值 

1430
01:19:21,820 --> 01:19:23,930
而这将是差距的起点 

1431
01:19:23,930 --> 01:19:25,980
以及这将会产生什么效果

1432
01:19:25,980 --> 01:19:29,790
它是不是要把一个精灵翻转到缺口上方

1433
01:19:29,790 --> 01:19:32,880
所以我们在缝隙开始处的正上方有一根管道 然后它

1434
01:19:32,880 --> 01:19:37,380
要绘制另一个管道 在该管道下方约90个像素处未翻转 

1435
01:19:37,380 --> 01:19:39,735
这将是它将两者结合在一起的方式 

1436
01:19:42,850 --> 01:19:49,380
第144行是一个循环 它只更新我们的对 而不是我们的管道 

1437
01:19:49,380 --> 01:19:55,110
因此 我们在这里所做的只是将其从管道重命名为对 而不是

1438
01:19:55,110 --> 01:19:57,030
在管道中 我们使用管道对 

1439
01:19:57,030 --> 01:20:01,390
在第153行 我们正在做同样的事情 

1440
01:20:01,390 --> 01:20:05,490
我们已经做了k对成对的管子 

1441
01:20:05,490 --> 01:20:08,310
然后是150行--

1442
01:20:08,310 --> 01:20:12,210
抱歉 175线是我们现在的位置--

1443
01:20:12,210 --> 01:20:17,790
抱歉 170是我们渲染每对而不是每个管道的位置 

1444
01:20:17,790 --> 01:20:22,980
所以如果我们在这里打开管子对 我们可以看看

1445
01:20:22,980 --> 01:20:25,060
在这堂课上从头开始 

1446
01:20:25,060 --> 01:20:26,700
所以这是一个新的班级 

1447
01:20:26,700 --> 01:20:29,122
我们要将间隙高度设置为90像素 

1448
01:20:29,122 --> 01:20:31,080
所以这只是一个任意值 我

1449
01:20:31,080 --> 01:20:33,879
就大小而言 Feel是一个相当公平的价值 

1450
01:20:33,879 --> 01:20:35,670
但你可以把它调到你想要的任何地方 

1451
01:20:35,670 --> 01:20:37,570
你可以把这个设置为--

1452
01:20:37,570 --> 01:20:40,520
如果你真的想变得残酷 你可以把它设定在50左右 

1453
01:20:40,520 --> 01:20:42,420
或者 如果你想对球员非常慷慨 

1454
01:20:42,420 --> 01:20:44,430
你可以把它设置在150左右 然后

1455
01:20:44,430 --> 01:20:46,410
对他们来说 这是相当容易的 

1456
01:20:46,410 --> 01:20:50,430
或者作为作业的一部分 你可以随机化它

1457
01:20:50,430 --> 01:20:54,420
所以它一对一对地变化 你会得到更多

1458
01:20:54,420 --> 01:20:56,445
看起来像是有机的障碍赛道 

1459
01:20:56,445 --> 01:20:59,010
它仍然被移动了负20到20个像素 

1460
01:20:59,010 --> 01:21:02,939
但现在你的差距是不同的 你也可以随机化移位量

1461
01:21:02,939 --> 01:21:03,980
如果你也想的话 

1462
01:21:03,980 --> 01:21:05,460
假设你想要--

1463
01:21:05,460 --> 01:21:08,970
也许您希望间隔最大为40像素

1464
01:21:08,970 --> 01:21:11,190
差异而不是20个像素的差异

1465
01:21:11,190 --> 01:21:12,755
论负值和正值 

1466
01:21:12,755 --> 01:21:14,130
你也可以很容易地做到这一点 

1467
01:21:16,840 --> 01:21:20,760
在第18行 我们只是将x设置为

1468
01:21:20,760 --> 01:21:23,010
我们以前做过 虚拟宽度加32 

1469
01:21:23,010 --> 01:21:24,990
所以我们将其设置为--

1470
01:21:24,990 --> 01:21:27,090
实际上 在我们将其设置为虚拟宽度之前 

1471
01:21:27,090 --> 01:21:29,880
现在我们将其设置为虚拟宽度加32 

1472
01:21:29,880 --> 01:21:31,474
两者基本持平 

1473
01:21:31,474 --> 01:21:33,390
这只会让它有一点延迟

1474
01:21:33,390 --> 01:21:36,780
在它最终出现在屏幕上之前 但你可以有效地

1475
01:21:36,780 --> 01:21:38,190
这样做 虚拟宽度 

1476
01:21:41,680 --> 01:21:47,130
在下一行 24 这是我们捆绑在一起的地方

1477
01:21:47,130 --> 01:21:51,300
我们最终要渲染和更新的管道

1478
01:21:51,300 --> 01:21:52,100
传到屏幕上 

1479
01:21:52,100 --> 01:21:55,560
一对管道不是只有一根管道 而是两根管道 

1480
01:21:55,560 --> 01:21:58,090
我们可以很容易地把这些放在一张桌子里 

1481
01:21:58,090 --> 01:21:59,860
因此 我们将只创建self.pires 

1482
01:21:59,860 --> 01:22:03,420
我们将它设置到一个有两个键的桌子上 上键和下键 

1483
01:22:03,420 --> 01:22:06,390
上面的管子只是一根管子 

1484
01:22:06,390 --> 01:22:08,490
请注意 管道有一点不同 

1485
01:22:08,490 --> 01:22:10,890
现在 以前 这是不需要争论的 

1486
01:22:10,890 --> 01:22:12,180
这只是一根普通的烟斗 

1487
01:22:12,180 --> 01:22:13,740
管道有其自身的逻辑 

1488
01:22:13,740 --> 01:22:15,600
他们设置自己的x和y 

1489
01:22:15,600 --> 01:22:19,620
除此之外 他们不需要任何形式的参数化 

1490
01:22:19,620 --> 01:22:22,750
这一切都是随机为他们安排的 

1491
01:22:22,750 --> 01:22:24,910
现在 他们拿着一根绳子 

1492
01:22:24,910 --> 01:22:28,140
这根顶线意味着这将是一根顶管 

1493
01:22:28,140 --> 01:22:30,330
也就是说 如果这根管子是顶层管子 

1494
01:22:30,330 --> 01:22:33,840
在管道中可能会有逻辑 现在检查

1495
01:22:33,840 --> 01:22:35,940
看看它是顶部还是底部 

1496
01:22:35,940 --> 01:22:39,180
如果它是顶部的 那么我们需要把它倒过来 

1497
01:22:39,180 --> 01:22:44,400
我们需要将其沿y轴翻转 然后将其设置为self.y 

1498
01:22:47,160 --> 01:22:49,740
回想一下我们设置了self.y--

1499
01:22:49,740 --> 01:22:52,510
我们在主航道通过了SELFY 

1500
01:22:52,510 --> 01:22:54,390
实际上 我不确定我有没有提到这点 

1501
01:22:54,390 --> 01:22:56,770
让我们回到Main这里 

1502
01:22:56,770 --> 01:22:58,153
所以如果我们去--

1503
01:23:02,320 --> 01:23:07,580
我需要找出我实际实例化管道的位置 

1504
01:23:07,580 --> 01:23:11,090
在第136行 在我们计算出

1505
01:23:11,090 --> 01:23:13,220
我们希望这对管子的间隙是这样的 

1506
01:23:13,220 --> 01:23:18,170
我们继续往前 把一对管子插入 y处的管子 

1507
01:23:18,170 --> 01:23:24,950
计算的范围是--我们基本上取了最后一个y值 

1508
01:23:24,950 --> 01:23:29,570
我们实例化的最后一个间隙 然后将其移位了大约负20

1509
01:23:29,570 --> 01:23:33,500
随机调整到20个像素 并确保它不会超过或超过--

1510
01:23:33,500 --> 01:23:35,150
屏幕边缘上方或下方 

1511
01:23:38,570 --> 01:23:45,770
回到管子对中 我们将继续 看一下第30行 

1512
01:23:45,770 --> 01:23:49,250
对不起 实际上让我们更仔细地看看这里

1513
01:23:49,250 --> 01:23:50,840
在第26行 

1514
01:23:50,840 --> 01:23:53,360
所以上流社会就会变得自私自利 

1515
01:23:53,360 --> 01:23:59,250
这就是差距所在 而精灵将在这个值上进行翻转 

1516
01:23:59,250 --> 01:24:02,990
较低的价值将是这一点的转变 

1517
01:24:02,990 --> 01:24:09,880
因此 较低的精灵需要在顶部管道下方以缝隙的数量繁殖

1518
01:24:09,880 --> 01:24:12,492
所以这两个是自上而下的 但在那里

1519
01:24:12,492 --> 01:24:14,450
需要是他们两个之间的空间 

1520
01:24:14,450 --> 01:24:17,840
所以我们需要拿起那根管子 把它往下移 然后画下一根管子 

1521
01:24:17,840 --> 01:24:25,760
所以我们取自 Y加上管子高度加上间隙高度 

1522
01:24:25,760 --> 01:24:29,630
这会产生效果--记住 间隙高度是90像素 

1523
01:24:29,630 --> 01:24:36,300
管道高度是翻转y轴的结果 

1524
01:24:36,300 --> 01:24:41,160
不得不把它移到实际位置下 

1525
01:24:41,160 --> 01:24:48,085
所以如果我们回到第30行 

1526
01:24:51,241 --> 01:24:56,890
这是一个有趣的例子 说明了

1527
01:24:56,890 --> 01:25:00,072
当您在对表进行迭代时编辑表时发生 

1528
01:25:00,072 --> 01:25:01,780
我很快就会向你们详细展示这一点 

1529
01:25:01,780 --> 01:25:05,620
但基本上 在第30行 我们将一个名为Remove的标志设置为FALSE 

1530
01:25:05,620 --> 01:25:09,170
我们要做的是在我们摧毁这些物体之前 

1531
01:25:09,170 --> 01:25:11,920
只要它越过屏幕的边缘 我们就把它毁了 

1532
01:25:11,920 --> 01:25:15,580
但如果我们迭代一个值表 

1533
01:25:15,580 --> 01:25:22,810
当您在大多数编程中执行删除操作时 让我们假设有一个管道对的表

1534
01:25:22,810 --> 01:25:28,870
语言--在Lua中 当您删除表值时 它没有索引 

1535
01:25:28,870 --> 01:25:33,640
或者它是无键的 这意味着它是通过数字索引进行索引的 

1536
01:25:33,640 --> 01:25:36,470
这将使其他所有价值下降 

1537
01:25:36,470 --> 01:25:38,470
所以当你迭代它的时候 你移动

1538
01:25:38,470 --> 01:25:41,530
一切下跌 你目前正在操纵的价值 

1539
01:25:41,530 --> 01:25:45,970
假设它等于1 如果去掉这个值 

1540
01:25:45,970 --> 01:25:48,760
将它以外的所有内容都向下移动1 

1541
01:25:48,760 --> 01:25:50,650
但然后你会递增到2 

1542
01:25:50,650 --> 01:25:55,510
您跳过了以前只有2个 现在是1个 

1543
01:25:55,510 --> 01:25:59,160
所以你实际上是跳过了你的一个条目 

1544
01:25:59,160 --> 01:26:02,560
而且它在很多情况下都有错误行为 

1545
01:26:02,560 --> 01:26:06,070
在这种情况下 它会导致图形出现一点故障

1546
01:26:06,070 --> 01:26:10,090
因为它不在一帧上应用像素移位 

1547
01:26:10,090 --> 01:26:16,840
因此 每当一根管子被移除--我实际上可以直观地展示这一点 

1548
01:26:16,840 --> 01:26:20,292
移除该管道后留下的第一个管道

1549
01:26:20,292 --> 01:26:22,000
最后稍微向右移动了一点 

1550
01:26:22,000 --> 01:26:26,120
所以你会看到奇怪的管子在每一帧中移动到鸟的左边 

1551
01:26:26,120 --> 01:26:29,380
因此 当您就地编辑表时 请制作

1552
01:26:29,380 --> 01:26:32,100
确保在迭代时不要删除它 

1553
01:26:32,100 --> 01:26:34,870
这将会导致错误的行为 

1554
01:26:34,870 --> 01:26:40,030
就像我说的 我很快就会向你们说明这一点 

1555
01:26:40,030 --> 01:26:46,000
在第36行 我们正在执行更新逻辑 

1556
01:26:46,000 --> 01:26:50,740
现在 管道对有两个管道 每个管道都有自己的渲染组件 

1557
01:26:50,740 --> 01:26:52,480
以及他们自己的立场 

1558
01:26:52,480 --> 01:26:55,030
我们使用之前为管道编写的代码 

1559
01:26:55,030 --> 01:26:57,370
我们将尝试在此基础上再做一点扩展 

1560
01:26:57,370 --> 01:27:04,200
因此 我们仍然希望将大量代码推迟到管道类 

1561
01:27:04,200 --> 01:27:10,060
我们希望根据是否--更新管道--

1562
01:27:10,060 --> 01:27:13,630
我们希望仍然跟踪他们自己的x 以及他们的渲染函数 

1563
01:27:13,630 --> 01:27:18,310
所以我们要看看 基本上 如果我们的烟斗对

1564
01:27:18,310 --> 01:27:22,300
X大于负管道宽度 这与我们的逻辑完全相同

1565
01:27:22,300 --> 01:27:24,670
以前用过的 

1566
01:27:24,670 --> 01:27:33,160
将我们自己的x设置为减去管道速度时间

1567
01:27:33,160 --> 01:27:35,800
三角洲时间 这与我们之前所做的操作相同 

1568
01:27:35,800 --> 01:27:42,320
但我们也在编辑我们自己的x 管道的下部和上部 

1569
01:27:42,320 --> 01:27:45,910
这将允许我们--在第46行--

1570
01:27:45,910 --> 01:27:47,920
像我们以前所做的那样渲染管道

1571
01:27:47,920 --> 01:27:51,440
因为他们正在更新他们的x值 就像以前一样 

1572
01:27:51,440 --> 01:27:55,180
因此 我们实际上将渲染阶段推迟到管道 

1573
01:27:55,180 --> 01:27:58,820
并且不需要在我们的代码中为此添加任何额外的逻辑 

1574
01:28:01,360 --> 01:28:04,830
我们也对pipe.lua进行了更改 所以我

1575
01:28:04,830 --> 01:28:08,910
往前走 在这里打开管道 

1576
01:28:14,710 --> 01:28:20,710
我们在这里设置了它的高度和宽度作为内容 

1577
01:28:20,710 --> 01:28:23,020
所以管道高度为288 然后发生了

1578
01:28:23,020 --> 01:28:24,640
大小和屏幕差不多 

1579
01:28:24,640 --> 01:28:25,750
管道宽度达到70 

1580
01:28:28,270 --> 01:28:32,230
在31号 我们自己坐着 方向就是方向 

1581
01:28:32,230 --> 01:28:34,420
请注意我们的init函数 它之前刚刚

1582
01:28:34,420 --> 01:28:38,710
为空 它不带参数 现在采用方向 并采用y值 

1583
01:28:38,710 --> 01:28:44,980
定向将允许我们问 基本上 我们的代码是

1584
01:28:44,980 --> 01:28:46,190
上烟斗还是下烟斗？

1585
01:28:46,190 --> 01:28:50,050
如果它是顶管 我们需要翻转它 画出它 然后移动它 

1586
01:28:50,050 --> 01:28:53,800
如果它是底部的管子 我们就把它画成正常的 

1587
01:28:53,800 --> 01:28:58,240
而不是表演任何花哨的精灵翻转或类似的东西 

1588
01:28:58,240 --> 01:29:02,060
在渲染函数的下面是实际发生这种情况的地方 

1589
01:29:02,060 --> 01:29:05,620
因此 在第39行 我们像往常一样绘制管道图像

1590
01:29:05,620 --> 01:29:12,490
在x处 但在y处 因为当你翻转一个精灵

1591
01:29:12,490 --> 01:29:18,250
它最终完全翻转了y轴--它基本上是在它上面运行一面镜子 

1592
01:29:18,250 --> 01:29:20,020
但不是在0 0 

1593
01:29:20,020 --> 01:29:24,040
它基本上是按管道高度量向上移动 

1594
01:29:24,040 --> 01:29:29,910
我们需要跟踪这一点 并将其绘制为self.y加管道高度 

1595
01:29:29,910 --> 01:29:34,324
因为如果我们只画它自己 因为它是镜像的 

1596
01:29:34,324 --> 01:29:36,490
它会随着管道高度的变化而移动 

1597
01:29:36,490 --> 01:29:38,760
它将超出屏幕的顶部边缘 

1598
01:29:38,760 --> 01:29:41,470
我们需要解释这一点 解释这个事实

1599
01:29:41,470 --> 01:29:45,125
我们在y轴上翻转它 然后把它拉下来 

1600
01:29:45,125 --> 01:29:47,222
观众：你翻转它的代码在哪里？

1601
01:29:47,222 --> 01:29:49,930
科尔顿·奥格登：问题是代码在哪里 我们把它翻到哪里去 

1602
01:29:49,930 --> 01:29:52,660
这就是这条线上的实际情况 

1603
01:29:52,660 --> 01:29:57,250
在这种情况下 我们说如果自身方向等于顶部 

1604
01:29:57,250 --> 01:29:58,350
那么我们想--

1605
01:29:58,350 --> 01:30:02,722
所以这里的参数 我将对此进行注释 只是为了澄清 

1606
01:30:02,722 --> 01:30:05,320
观众：所以画图功能有翻转功能？

1607
01:30:05,320 --> 01:30:07,240
科尔顿·奥格登：是的 我在这里带你去看看 

1608
01:30:07,240 --> 01:30:09,610
所以在这个0中 我们添加了一些新参数

1609
01:30:09,610 --> 01:30:11,950
致我们的love.graph ics.DrawFunction 

1610
01:30:11,950 --> 01:30:13,120
零表示旋转 

1611
01:30:13,120 --> 01:30:14,930
我们根本不会旋转它 

1612
01:30:14,930 --> 01:30:17,560
这是x轴上的比例 

1613
01:30:17,560 --> 01:30:21,590
所以x刻度 这是y轴上的刻度 

1614
01:30:21,590 --> 01:30:24,070
因此 如果我们应用1的比例运算 它是

1615
01:30:24,070 --> 01:30:28,250
这与根本不做规模是一样的 

1616
01:30:28,250 --> 01:30:30,230
它会把它画在x轴上 

1617
01:30:30,230 --> 01:30:31,640
它只是会正常地画出来 

1618
01:30:31,640 --> 01:30:39,340
但如果是顶部 如果此管道已设置为顶部方向 

1619
01:30:39,340 --> 01:30:41,710
我们要将刻度设置为负1 

1620
01:30:41,710 --> 01:30:43,540
当你说精灵--

1621
01:30:43,540 --> 01:30:48,770
将其比例因子设置为负1 则会有效地沿该轴翻转它 

1622
01:30:48,770 --> 01:30:51,130
这就是你得到镜像的方式 

1623
01:30:51,130 --> 01:30:56,470
大多数引擎允许您将缩放操作应用于2D纹理或2D

1624
01:30:56,470 --> 01:31:01,120
精灵 在轴上的负操作会将其镜像到该轴上 

1625
01:31:01,120 --> 01:31:02,620
这就是我们在这里做的事情 

1626
01:31:02,620 --> 01:31:05,680
因此 如果是顶管 我们会对其进行镜像 

1627
01:31:05,680 --> 01:31:07,660
我们还改变了抽签地点

1628
01:31:07,660 --> 01:31:10,710
还有 因为当我们镜像它的时候 它会--

1629
01:31:10,710 --> 01:31:12,970
在0 0的时候 它会做同样的事情--它会

1630
01:31:12,970 --> 01:31:17,112
基本上绘制完全相同的东西 但镜像在y轴上 

1631
01:31:17,112 --> 01:31:18,070
所以它需要--

1632
01:31:18,070 --> 01:31:21,100
如果我们想要在一个给定的位置画 翻转--

1633
01:31:21,100 --> 01:31:23,410
仍将其绘制为0 0 但将其翻转 

1634
01:31:23,410 --> 01:31:27,040
我们需要解释这种反转 并在有意义的情况下将其向下调整 

1635
01:31:29,740 --> 01:31:33,970
因此 这基本上就是所有涉及到的事情 

1636
01:31:33,970 --> 01:31:38,150
我认为这几乎就是所有的代码 

1637
01:31:38,150 --> 01:31:42,100
因此 我们现在有了正在被翻转的管道 

1638
01:31:42,100 --> 01:31:44,460
如果它是顶管 它就会被拉移 

1639
01:31:44,460 --> 01:31:48,040
它将把另一根管子向下移动同样的量 

1640
01:31:48,040 --> 01:31:54,100
它的y轴将增加间隙高度

1641
01:31:54,100 --> 01:31:56,680
所以它会被绘制成90个像素 无论您使用多少像素

1642
01:31:56,680 --> 01:31:59,260
想放在那根管子下面 

1643
01:31:59,260 --> 01:32:02,100
因此 我们将进行演示 

1644
01:32:02,100 --> 01:32:10,360
现在转到50鸟 实际的repo和实际的发行版代码 

1645
01:32:10,360 --> 01:32:13,510
我要到Bird6去 我要去跑步 

1646
01:32:16,450 --> 01:32:19,750
现在我们有了实际渲染的管道 

1647
01:32:19,750 --> 01:32:24,700
但我们遗漏了几件重要的事情 

1648
01:32:24,700 --> 01:32:28,120
最重要的是 其中之一是我们现在还没有碰撞检测 

1649
01:32:28,120 --> 01:32:30,430
所以我们可以无限地飞过这条航线 

1650
01:32:30,430 --> 01:32:35,110
但请注意 它们被移位了一个在负20之间的随机值

1651
01:32:35,110 --> 01:32:37,210
和20个像素 

1652
01:32:37,210 --> 01:32:41,980
它看起来或多或少像是为了某种目标而产生的

1653
01:32:41,980 --> 01:32:42,780
在脑海中 

1654
01:32:42,780 --> 01:32:44,199
这不是偶然的 

1655
01:32:44,199 --> 01:32:46,240
它不是到处都是 但你可以很容易地

1656
01:32:46,240 --> 01:32:50,380
想方设法调整这一点 也许差距高度是

1657
01:32:50,380 --> 01:32:53,470
一些介于60和120之间的值 

1658
01:32:53,470 --> 01:32:57,413
所以你有容易的和困难的管子 或者你有--

1659
01:32:57,413 --> 01:33:02,760
我觉得我在屏幕下面太远了 我甚至都不能再站起来了 

1660
01:33:02,760 --> 01:33:06,490
哦 好吧 这是个物理错误 

1661
01:33:06,490 --> 01:33:10,570
当你的价值达到某一点时 我认为这实际上就是它所做的

1662
01:33:10,570 --> 01:33:13,839
它实际上是在溢出该值 并将其设置为负值 

1663
01:33:13,839 --> 01:33:16,130
或下溢 并将其设置为负值 

1664
01:33:16,130 --> 01:33:21,850
然后递增 因为它变得太大了 

1665
01:33:21,850 --> 01:33:26,480
但你可以很容易地调整参数 如管道之间的宽度

1666
01:33:26,480 --> 01:33:29,570
正如你在前面的图表中看到的 或者说高度 

1667
01:33:29,570 --> 01:33:32,030
甚至是它们移动的速度 并发现

1668
01:33:32,030 --> 01:33:37,880
调整它的方法 使游戏真正发挥作用 无论目标是什么

1669
01:33:37,880 --> 01:33:40,230
你心里想的是--让它变得更容易或更难 

1670
01:33:40,230 --> 01:33:42,260
这实际上是他们在那篇文章中谈到的一个话题

1671
01:33:42,260 --> 01:33:44,270
我之前链接过的 在那里他们产生了级别

1672
01:33:44,270 --> 01:33:46,561
然后以编程方式对它们进行测试

1673
01:33:46,561 --> 01:33:50,410
来确定是什么让Flappy Bird的等级变得困难或容易 

1674
01:33:50,410 --> 01:33:55,190
所以基本上 这些都是参数

1675
01:33:55,190 --> 01:33:58,160
当你在考虑程序生成时 你需要这样做 

1676
01:33:58,160 --> 01:34:00,259
而程序性的生成 归根结底是公正的

1677
01:34:00,259 --> 01:34:02,300
取你用来构建场景的值 

1678
01:34:02,300 --> 01:34:05,460
只是想方设法随意操控它们 

1679
01:34:05,460 --> 01:34:11,780
数学 随机取一些值 简而言之 这就是你如何制造随机水平 

1680
01:34:11,780 --> 01:34:16,344
制作好的随机水平是另一个问题 

1681
01:34:16,344 --> 01:34:18,719
观众：这家伙做得很少 赚了很多钱 

1682
01:34:18,719 --> 01:34:19,927
科尔顿·奥格登：他做到了 他做到了 

1683
01:34:19,927 --> 01:34:22,430
早在2013年 这款游戏就引发了很大的争议 

1684
01:34:22,430 --> 01:34:25,580
观众：他也有精神崩溃的症状 对吗？

1685
01:34:25,580 --> 01:34:27,913
科尔顿·奥格登：我不知道我是否读得太多了 

1686
01:34:27,913 --> 01:34:31,310
但我做了一点研究 读到了一些

1687
01:34:31,310 --> 01:34:32,890
那些东西 

1688
01:34:32,890 --> 01:34:35,300
我必须支持他 因为他寄希望于这一点 

1689
01:34:38,692 --> 01:34:39,650
现在我们有了管子对 

1690
01:34:39,650 --> 01:34:42,920
这可以说是该计划中最复杂的部分

1691
01:34:42,920 --> 01:34:46,740
因为现在向前看 当我们进入碰撞时 

1692
01:34:46,740 --> 01:34:49,460
还有一些更多的概念 碰撞实际上是

1693
01:34:49,460 --> 01:34:54,840
我们上周谈到的 基本上都是一样的东西 

1694
01:34:54,840 --> 01:35:00,750
因此 如果我们进入Bird7 即我们应用程序的下一次迭代 

1695
01:35:00,750 --> 01:35:07,420
我要继续 打开主电源 卢亚 

1696
01:35:07,420 --> 01:35:10,680
然后我们要去74号线 

1697
01:35:14,040 --> 01:35:19,510
为了测试碰撞 我们还没有打分 

1698
01:35:19,510 --> 01:35:22,960
但我们需要一些方法来确定哦 我们撞上了一根管道 

1699
01:35:22,960 --> 01:35:24,730
我们需要一些反馈 

1700
01:35:24,730 --> 01:35:29,340
所以我们要做的是 我刚刚决定我们应该暂停比赛 

1701
01:35:29,340 --> 01:35:31,980
所以一旦我们与管道相撞 我们就立即停下来

1702
01:35:31,980 --> 01:35:34,577
所以我们马上就知道 哦 我们撞到了一根管道 

1703
01:35:34,577 --> 01:35:36,660
所以我将设置一个称为滚动的变量

1704
01:35:36,660 --> 01:35:39,239
在程序的顶部 从Main到True 

1705
01:35:39,239 --> 01:35:39,905
我们在滚动 

1706
01:35:39,905 --> 01:35:42,339
我们要开始滚动了 但当我

1707
01:35:42,339 --> 01:35:44,880
我不想再滚动了 当我想暂停游戏时 

1708
01:35:44,880 --> 01:35:47,580
应将其设置为False 

1709
01:35:47,580 --> 01:35:55,950
因此 在第120行 如果滚动 则执行所有这些更新逻辑

1710
01:35:55,950 --> 01:35:58,091
就像我们以前做的那样 

1711
01:35:58,091 --> 01:36:00,840
最后 我们重新设置了输入表 

1712
01:36:00,840 --> 01:36:03,330
因此我们仍然可以接受输入 但不能更新

1713
01:36:03,330 --> 01:36:05,940
如果将滚动设置为FALSE 则将发生 

1714
01:36:05,940 --> 01:36:09,030
所有这些东西都在这个范围内 如果--

1715
01:36:09,030 --> 01:36:10,710
打扰一下 如果是滚动的话 

1716
01:36:10,710 --> 01:36:11,477
非常简单 

1717
01:36:11,477 --> 01:36:13,560
我们只需将其封装在某个变量中

1718
01:36:13,560 --> 01:36:16,990
我们可以打开和关闭 

1719
01:36:16,990 --> 01:36:21,870
然后在152上 在该代码块内

1720
01:36:21,870 --> 01:36:25,280
它包含在If条件中 

1721
01:36:25,280 --> 01:36:28,920
我们只是在做一个非常简单的迭代 

1722
01:36:28,920 --> 01:36:33,420
每一根管子 这应该是L成对的--

1723
01:36:33,420 --> 01:36:34,590
哦 不 对不起 

1724
01:36:34,590 --> 01:36:39,870
对于成对的每根管子--

1725
01:36:39,870 --> 01:36:41,490
在本例中 它是一个嵌套的for循环 

1726
01:36:41,490 --> 01:36:46,824
所以基本上 在检查每一对的循环中 为了更新它 

1727
01:36:46,824 --> 01:36:49,990
我们正在做另一个循环 循环通过这对管道 

1728
01:36:49,990 --> 01:36:53,820
因此 它只是一个上下管道两次迭代的循环 

1729
01:36:53,820 --> 01:36:57,930
我们也可以说 如果鸟撞上了上面--

1730
01:36:57,930 --> 01:37:00,960
基本上 如果是上半身或下半身 或者是下半身

1731
01:37:00,960 --> 01:37:03,960
往上走 往下走 往下走 但这个干净多了 

1732
01:37:03,960 --> 01:37:04,847
它的可扩展性更强 

1733
01:37:04,847 --> 01:37:07,680
我们可以增加更多的管道 如果我们想的话 即使这不会发生 

1734
01:37:07,680 --> 01:37:12,480
但是对于每一个配对的管道 我们在这里有一个函数 我们

1735
01:37:12,480 --> 01:37:14,940
还没有定义为鸟：碰撞 

1736
01:37:14,940 --> 01:37:19,030
所以 如果鸟撞上了管子 它就会吸进管子 

1737
01:37:19,030 --> 01:37:21,990
所以它将返回一个真或假的值 我们知道--

1738
01:37:21,990 --> 01:37:23,220
将滚动设置为FALSE 

1739
01:37:23,220 --> 01:37:26,590
所以我们发生冲突 滚动设置为假 更新逻辑

1740
01:37:26,590 --> 01:37:28,090
将被完全关闭 

1741
01:37:28,090 --> 01:37:31,620
所以我们会暂停游戏的效果 

1742
01:37:31,620 --> 01:37:34,230
我们现在要进入小鸟 卢亚 

1743
01:37:34,230 --> 01:37:36,700
我们将看看我们是如何实现这一点的 

1744
01:37:36,700 --> 01:37:40,600
它看起来会和我们上周所做的非常相似 

1745
01:37:40,600 --> 01:37:47,750
所以在Bird.Lua中 这个函数从29减到45 

1746
01:37:47,750 --> 01:37:51,350
这只是我们上周做的AABB碰撞检测测试 

1747
01:37:51,350 --> 01:37:54,740
我们只是在检查以确保任何边缘--

1748
01:37:54,740 --> 01:37:58,310
右边缘 确保它在左边

1749
01:37:58,310 --> 01:38:00,440
第二个框的右边缘 

1750
01:38:00,440 --> 01:38:02,740
第一个盒子的底边应该是--

1751
01:38:02,740 --> 01:38:05,570
框1的底边或底边应在底边或顶边之上

1752
01:38:05,570 --> 01:38:06,590
第二个盒子的边缘 

1753
01:38:06,590 --> 01:38:10,520
如果所有这些都成立 则返回TRUE 

1754
01:38:10,520 --> 01:38:11,440
否则 返回FALSE 

1755
01:38:11,440 --> 01:38:13,070
这意味着我们发生了碰撞 

1756
01:38:13,070 --> 01:38:18,107
注意 我把这里的所有东西都移了几个常量值 

1757
01:38:18,107 --> 01:38:19,940
有没有人本能地知道我为什么

1758
01:38:19,940 --> 01:38:26,060
说的是self.x加2 而不是self.x self.wide减4？

1759
01:38:26,060 --> 01:38:30,620
为什么我们要检查这种情况下鸟的偏移量

1760
01:38:30,620 --> 01:38:32,240
当它与管子相比时 

1761
01:38:32,240 --> 01:38:34,004
观众：它是鸟的一半大小吗？

1762
01:38:34,004 --> 01:38:35,420
科尔顿·奥格登：这还不到一半 

1763
01:38:35,420 --> 01:38:37,160
它比以前小了几个像素 

1764
01:38:37,160 --> 01:38:39,350
我们知道为什么要这么做吗？

1765
01:38:39,350 --> 01:38:41,450
我们基本上是在缩小盒子 

1766
01:38:41,450 --> 01:38:45,120
我们为什么要缩小盒子？

1767
01:38:45,120 --> 01:38:49,405
观众：实际的画作之间有差距 

1768
01:38:49,405 --> 01:38:50,530
科尔顿·奥格登：所以不完全是 

1769
01:38:50,530 --> 01:38:53,740
因此 这幅图之间并没有实际的差距 

1770
01:38:53,740 --> 01:39:00,355
这更多的是一个问题 我们想在多大程度上挫败我们的用户 

1771
01:39:00,355 --> 01:39:06,070
如果我们的像素完美地与管道相撞 就不会有取舍 

1772
01:39:06,070 --> 01:39:09,010
就像你们相撞了 即使--它甚至可能

1773
01:39:09,010 --> 01:39:11,369
看起来就像你甚至没有撞到管道 

1774
01:39:11,369 --> 01:39:12,910
而你仍然会遇到碰撞 

1775
01:39:12,910 --> 01:39:14,990
你的用户在想 好吧 这不公平 

1776
01:39:14,990 --> 01:39:16,570
这真的很苛刻 

1777
01:39:16,570 --> 01:39:19,812
我们正在缩小盒子 这样即使它们只差一个像素 

1778
01:39:19,812 --> 01:39:21,520
他们仍然会有一点回旋余地 

1779
01:39:21,520 --> 01:39:25,630
在碰撞方面 它会稍微放松一些 

1780
01:39:25,630 --> 01:39:29,890
这在游戏中是很常见的事情 当你的角色具有精灵

1781
01:39:29,890 --> 01:39:33,820
不一定会填满你为他们分配的整个盒子 

1782
01:39:33,820 --> 01:39:35,530
即使你在做长方体碰撞 

1783
01:39:35,530 --> 01:39:39,250
只要给你的用户几个像素深度 不管多少

1784
01:39:39,250 --> 01:39:42,220
你想要的 它们可以与任何东西重叠

1785
01:39:42,220 --> 01:39:44,980
它们只是在它实际撞击之前的一小部分

1786
01:39:44,980 --> 01:39:48,610
在碰撞中触发真 这会让你的游戏感觉更宽容 

1787
01:39:48,610 --> 01:39:51,770
然后也因此而更有趣 

1788
01:39:51,770 --> 01:39:53,200
这就是为什么我们有--

1789
01:39:53,200 --> 01:39:57,940
我们不是直接在盒子的x0上测试 而是测试x+2 

1790
01:39:57,940 --> 01:40:00,490
然后是自身宽度减去4 因为当我们移动时 

1791
01:40:00,490 --> 01:40:03,480
我们将宽度加到正2值上 我们需要负4

1792
01:40:03,480 --> 01:40:06,370
所以我们从右边得到2 而且是一样的

1793
01:40:06,370 --> 01:40:10,010
表示高度和y值 

1794
01:40:10,010 --> 01:40:13,120
因此 这只执行AABB冲突检测 

1795
01:40:13,120 --> 01:40:17,230
需要管道 这意味着我们需要确保

1796
01:40:17,230 --> 01:40:20,470
管子有一个x和一个y 一个宽度和一个高度 它确实有 

1797
01:40:20,470 --> 01:40:22,090
实际上 这里只是一个常量 

1798
01:40:22,090 --> 01:40:24,261
我们只是在检查管道的宽度和高度 

1799
01:40:24,261 --> 01:40:25,510
我们可能不该这么做 

1800
01:40:25,510 --> 01:40:29,071
在这种情况下 它应该是pipe.width pipe.height 

1801
01:40:29,071 --> 01:40:31,320
因为这样一来 这不可能只是一根管子 

1802
01:40:31,320 --> 01:40:34,990
它可以是场景中具有XY、宽度和高度的任何对象 

1803
01:40:34,990 --> 01:40:37,090
这可能是一起一般用途的碰撞 

1804
01:40:37,090 --> 01:40:39,895
事实上 如果你愿意 你也可以做的是

1805
01:40:39,895 --> 01:40:44,260
只需编写一个名为Collides的函数 该函数接受两个内容

1806
01:40:44,260 --> 01:40:46,354
你知道它有包围盒 而且会

1807
01:40:46,354 --> 01:40:48,520
允许您对任何对象执行碰撞检测

1808
01:40:48,520 --> 01:40:50,890
在场景中的任意两个实体之间 

1809
01:40:50,890 --> 01:40:54,022
我想 这将是一种更具伸缩性的方式 

1810
01:40:54,022 --> 01:40:56,230
处理它 而不是一定要拥有它

1811
01:40:56,230 --> 01:40:59,422
明确定义为鸟类和管子是对撞机 

1812
01:40:59,422 --> 01:41:01,630
但在这种情况下 这是我们唯一真正

1813
01:41:01,630 --> 01:41:03,950
除了地面以外 都与之相撞 

1814
01:41:03,950 --> 01:41:06,283
但当你与地面相撞时 你需要做的就是

1815
01:41:06,283 --> 01:41:10,090
就是看看你的y体位加上你的身高

1816
01:41:10,090 --> 01:41:12,700
已经到了屏幕边缘以下 

1817
01:41:12,700 --> 01:41:15,197
那么 对于如何做到这一点 有什么问题吗？

1818
01:41:15,197 --> 01:41:20,560
观众：为什么你要加2n再减4 而不是只减2？

1819
01:41:20,560 --> 01:41:23,740
科尔顿·奥格登：所以问题是为什么我们要加2减去

1820
01:41:23,740 --> 01:41:26,590
4而不是减去2？

1821
01:41:26,590 --> 01:41:31,090
因为当你添加一个--

1822
01:41:31,090 --> 01:41:34,270
因为我们做的是self.x+2 基本上我们是

1823
01:41:34,270 --> 01:41:36,930
移动整个盒子 基本上 在这里 在这一部分 

1824
01:41:36,930 --> 01:41:40,960
所以 self.x加2带来了盒子的开始

1825
01:41:40,960 --> 01:41:43,930
我们与右侧的2个像素相撞 

1826
01:41:43,930 --> 01:41:49,780
但如果我们只做2个像素减去2 那么盒子的右边缘

1827
01:41:49,780 --> 01:41:51,460
仍然是框的右边缘 

1828
01:41:51,460 --> 01:41:55,060
我们希望它向内移动2个像素 

1829
01:41:55,060 --> 01:41:59,740
因为我们在方框的开始处移动了x位置 2个像素以上 

1830
01:41:59,740 --> 01:42:04,790
我们需要将它向内移动4个像素 因为

1831
01:42:04,790 --> 01:42:10,221
会产生这样的效果 我们的长方体在右边缘有2个像素 

1832
01:42:10,221 --> 01:42:11,694
这说得通吗？

1833
01:42:16,120 --> 01:42:18,895
好的 我想这就是Bird7的全部内容 

1834
01:42:23,960 --> 01:42:28,070
我们将继续 现在运行Bird7 

1835
01:42:28,070 --> 01:42:33,920
记住 如果我们碰到管道 我们应该立即暂停 

1836
01:42:33,920 --> 01:42:36,870
如此跳跃 跳跃 跳跃 

1837
01:42:36,870 --> 01:42:39,694
我要在这里通过一对管道 

1838
01:42:39,694 --> 01:42:41,610
然后我会故意打这个 

1839
01:42:41,610 --> 01:42:42,364
哦 我们停顿了一下 

1840
01:42:42,364 --> 01:42:44,280
请注意 我们有一点回旋余地 

1841
01:42:44,280 --> 01:42:47,330
我们在那里有几个像素--以防万一

1842
01:42:47,330 --> 01:42:50,330
意外的--而且 它还考虑到了你可能会移动 

1843
01:42:50,330 --> 01:42:52,490
因为你的速度 几个像素

1844
01:42:52,490 --> 01:42:57,530
超越了你所碰撞的东西的严格的硬边缘

1845
01:42:57,530 --> 01:43:00,900
基于通过的帧的数量 

1846
01:43:00,900 --> 01:43:04,177
基本上 你的速度是多少 你的位置是什么 

1847
01:43:04,177 --> 01:43:06,260
在这种情况下 我认为看起来我们实际上

1848
01:43:06,260 --> 01:43:08,759
边缘上方三四个像素 因为我们的速度是

1849
01:43:08,759 --> 01:43:13,640
这么高是因为我们跳了 但它一检测到碰撞 就像

1850
01:43:13,640 --> 01:43:17,060
我们一到那个画面上 我们的位置就是这样

1851
01:43:17,060 --> 01:43:19,830
我们确实触发了碰撞检测的True 

1852
01:43:19,830 --> 01:43:20,750
它暂停了游戏 

1853
01:43:20,750 --> 01:43:22,040
循环设置为FALSE 

1854
01:43:22,040 --> 01:43:26,060
我们不再运行任何更新逻辑 这是我们的基本方式

1855
01:43:26,060 --> 01:43:27,960
得到关于这方面的反馈 

1856
01:43:27,960 --> 01:43:33,230
然而 它并不是特别有说服力 游戏智慧 

1857
01:43:33,230 --> 01:43:37,430
所以我们想要进入得分领域 

1858
01:43:37,430 --> 01:43:41,390
在我们开始得分之前 也是与之相关的 

1859
01:43:41,390 --> 01:43:42,690
我们比赛的不同状态 

1860
01:43:42,690 --> 01:43:44,440
因此 如果我们开始得分 显然我们想要

1861
01:43:44,440 --> 01:43:47,489
有一个屏幕告诉我们什么时候输了 我们的比分是多少 

1862
01:43:47,489 --> 01:43:49,280
我们可能还应该有一个标题屏幕

1863
01:43:49,280 --> 01:43:51,830
因为我们才刚刚进入游戏阶段 

1864
01:43:51,830 --> 01:43:54,710
我们想要一个可以让我们玩完游戏的屏幕 

1865
01:43:54,710 --> 01:43:57,890
正如我们将在稍后看到的 一个屏幕也为我们提供了

1866
01:43:57,890 --> 01:44:01,340
有时间 一旦我们开始比赛 开始倒计时 

1867
01:44:01,340 --> 01:44:04,290
就像是说 哦 三 二 一 去 而不仅仅是哦 

1868
01:44:04,290 --> 01:44:06,250
去吧 哦 我不知道我在做什么 

1869
01:44:06,250 --> 01:44:06,950
我大惑不解 

1870
01:44:06,950 --> 01:44:10,220
所以这是一张对国家进行建模的图表

1871
01:44:10,220 --> 01:44:15,180
我们将在我们的程序中使用的流 我们的游戏 

1872
01:44:15,180 --> 01:44:18,200
我们将假设我们从某种标题屏幕状态开始 

1873
01:44:18,200 --> 01:44:19,540
所以从左到右 

1874
01:44:19,540 --> 01:44:22,860
标题屏幕状态将转换到倒计时状态 

1875
01:44:22,860 --> 01:44:26,297
然后 我们可以随心所欲地定义这些转变 

1876
01:44:26,297 --> 01:44:28,130
在这种情况下 假设我们按Enter键 

1877
01:44:28,130 --> 01:44:30,290
标题屏幕状态进入倒计时状态 

1878
01:44:30,290 --> 01:44:32,550
一旦倒计时状态--

1879
01:44:32,550 --> 01:44:36,872
一旦为此触发了转换 我们就应该进入播放状态 

1880
01:44:36,872 --> 01:44:39,080
然后一旦转换触发到播放状态 

1881
01:44:39,080 --> 01:44:40,970
我们将进入得分状态 

1882
01:44:40,970 --> 01:44:44,630
然后得分状态应该回到倒计时状态 这个模型

1883
01:44:44,630 --> 01:44:48,950
我们整个应用程序的流程--

1884
01:44:48,950 --> 01:44:53,090
从上到下 从左到右 按时间顺序 

1885
01:44:53,090 --> 01:44:55,190
因此 让我们继续 看看一些代码

1886
01:44:55,190 --> 01:44:56,898
关于我们将如何实现这一点 

1887
01:44:56,898 --> 01:45:00,260
上周 我提到了我们--实际上在早些时候的演讲中--我们

1888
01:45:00,260 --> 01:45:04,220
从这种基于字符串的方法 到使用if跟踪我们的状态

1889
01:45:04,220 --> 01:45:06,470
条件 到基于类的方法 这就是

1890
01:45:06,470 --> 01:45:08,140
我们今天要说明的是 

1891
01:45:08,140 --> 01:45:11,080
所以我要继续 打开Bird8 

1892
01:45:11,080 --> 01:45:15,110
在Bird8中 我将继续 从Main开始 

1893
01:45:15,110 --> 01:45:23,240
在Main中 在第36行 我们正在获取一个名为状态机的新类 

1894
01:45:23,240 --> 01:45:26,600
以及我们正在定义的其他几个类 称为Bay State Play

1895
01:45:26,600 --> 01:45:28,920
状态和标题屏幕状态 

1896
01:45:28,920 --> 01:45:31,630
这些是我们的状态机的组成部分 

1897
01:45:31,630 --> 01:45:35,120
现在 它们不再仅仅是我们更新函数中的代码块 

1898
01:45:35,120 --> 01:45:37,670
它们是独立的块、独立的模块

1899
01:45:37,670 --> 01:45:40,310
有自己的逻辑 自己的更新和渲染逻辑 

1900
01:45:40,310 --> 01:45:41,890
我们很快就会看到这一点 

1901
01:45:41,890 --> 01:45:45,560
在78号线 如果我们往下走--

1902
01:45:45,560 --> 01:45:48,290
除此之外 我还实例化了一些字体 

1903
01:45:48,290 --> 01:45:49,610
我们上个星期就做过了 

1904
01:45:49,610 --> 01:45:53,164
所以 love.graph ics.newfont接受一个字体文件 然后是一个大小 

1905
01:45:53,164 --> 01:45:56,330
我在这里创建了几种不同的字体 因为我们有几种不同的方式

1906
01:45:56,330 --> 01:45:58,490
向用户提供反馈 

1907
01:45:58,490 --> 01:46:01,220
我们想要一个小字体来显示按Enter键

1908
01:46:01,220 --> 01:46:02,860
作为一个开始 或者类似的东西 

1909
01:46:02,860 --> 01:46:06,214
我们想要一个中等字体来显示游戏的名称 也许 

1910
01:46:06,214 --> 01:46:08,630
或者 我认为实际上 Flappy Font应该对此负责 

1911
01:46:08,630 --> 01:46:10,550
中等字体 我想 是为了得分 

1912
01:46:10,550 --> 01:46:12,170
巨大的字体为我们的倒计时 

1913
01:46:12,170 --> 01:46:14,170
我们想要一个大字体 正好在屏幕中央

1914
01:46:14,170 --> 01:46:16,220
三 二 一 然后我们开始 

1915
01:46:16,220 --> 01:46:19,303
然后我们将首先将其设置为Flappy Font 它

1916
01:46:19,303 --> 01:46:20,750
将成为我们的标题字体 

1917
01:46:20,750 --> 01:46:25,520
所以没有什么真正的新东西 但可以说是我们的用户界面的开始 

1918
01:46:25,520 --> 01:46:29,240
在第92行 这是新的 实际上这是

1919
01:46:29,240 --> 01:46:32,660
是一种命名约定的演示 

1920
01:46:32,660 --> 01:46:35,240
您将经常在游戏代码库中看到 

1921
01:46:35,240 --> 01:46:38,420
我们还没有使用它 但我们将在未来开始使用它 

1922
01:46:38,420 --> 01:46:42,290
我们在全局变量前面加上一个小写的g 

1923
01:46:42,290 --> 01:46:45,260
这可以让您知道当您正在挖掘一系列文件时

1924
01:46:45,260 --> 01:46:46,940
那个哦 这是一个全局变量 

1925
01:46:46,940 --> 01:46:51,770
好的 所以我应该知道它可能没有在这个模块中定义 

1926
01:46:51,770 --> 01:46:54,892
也许是这样 但我知道这是全球性的 

1927
01:46:54,892 --> 01:46:56,600
您可能会看到的其他内容是小写

1928
01:46:56,600 --> 01:47:03,770
M代表成员 这意味着这是一个成员函数 或者是一个类的字段 

1929
01:47:03,770 --> 01:47:06,684
你可以一目了然 知道

1930
01:47:06,684 --> 01:47:08,600
好的 如果我想找出这个的定义 

1931
01:47:08,600 --> 01:47:10,141
它看起来像是一个成员函数 

1932
01:47:10,141 --> 01:47:13,280
所以它可能就在这个班级里 在这里的某条线上 

1933
01:47:13,280 --> 01:47:15,530
你很容易就能找到 

1934
01:47:15,530 --> 01:47:17,960
因此 在未来的课程中 我们将使用

1935
01:47:17,960 --> 01:47:23,140
更多的是这个小写的g 表示全局变量 我们一个模块一个模块地使用 

1936
01:47:23,140 --> 01:47:25,700
在本例中 我们实例化了一个状态机 

1937
01:47:25,700 --> 01:47:29,710
所以我们使用的是这个类 我们稍后会看一下 

1938
01:47:29,710 --> 01:47:32,200
StateMachine接收一个带有键的表

1939
01:47:32,200 --> 01:47:36,890
映射到将返回我们的状态的函数 

1940
01:47:36,890 --> 01:47:43,910
所以我们可以只调用更改一些值 它将在我们的状态机中 

1941
01:47:43,910 --> 01:47:48,340
它基本上会在这里引用该表中键 

1942
01:47:48,340 --> 01:47:51,160
它将根据--它将调用该函数

1943
01:47:51,160 --> 01:47:57,340
基本上将该StateMachine的当前状态设置为任何状态

1944
01:47:57,340 --> 01:48:00,050
由该键处的函数返回 

1945
01:48:00,050 --> 01:48:04,717
因此 在本例中 更改将触发返回新标题屏幕状态 

1946
01:48:04,717 --> 01:48:06,550
我们将得到--状态机是

1947
01:48:06,550 --> 01:48:08,620
将设置为标题屏幕 有效地 

1948
01:48:08,620 --> 01:48:12,950
我们马上来看看标题屏幕是什么样子的 

1949
01:48:12,950 --> 01:48:16,350
在第96行 是的 我们将切换到标题屏幕 

1950
01:48:16,350 --> 01:48:20,290
在第134行 请注意我们实际上没有太多更新

1951
01:48:20,290 --> 01:48:22,060
这个应用程序中再也没有逻辑了 

1952
01:48:22,060 --> 01:48:25,480
我们仍在更新卷轴 因为这是

1953
01:48:25,480 --> 01:48:27,280
我们所有州都想要的行为 

1954
01:48:27,280 --> 01:48:29,404
无论我们处于什么状态 我们都要确保

1955
01:48:29,404 --> 01:48:32,830
我们的背景和我们的地面滚动 所以我们有运动 

1956
01:48:32,830 --> 01:48:35,380
我们不需要将此行为状态复制到状态 

1957
01:48:35,380 --> 01:48:37,340
这是我们游戏的一个全球性特征 

1958
01:48:37,340 --> 01:48:40,960
所以我们只是像以前一样在这里跟踪它 

1959
01:48:40,960 --> 01:48:44,110
但我们游戏中任何其他需要更新的内容

1960
01:48:44,110 --> 01:48:47,620
现在可以推迟到我们的StateMachine类 

1961
01:48:47,620 --> 01:48:51,490
当我们调用gStateMachine更新增量时间时 

1962
01:48:51,490 --> 01:48:53,745
它将会看看我们目前的状态是什么 

1963
01:48:53,745 --> 01:48:55,870
它将更新这种状态 

1964
01:48:55,870 --> 01:48:59,270
基本上就是那一大块 如果这块

1965
01:48:59,270 --> 01:49:02,080
按照我们上个星期做的逻辑来做

1966
01:49:02,080 --> 01:49:05,360
我们有一个更原始的状态机 

1967
01:49:05,360 --> 01:49:08,140
第46行 一模一样 

1968
01:49:08,140 --> 01:49:11,470
在背景和地面之间 因为它们将始终渲染场景

1969
01:49:11,470 --> 01:49:15,400
要设置场景 我们希望呈现当前的活动状态

1970
01:49:15,400 --> 01:49:19,120
使用我们的状态机渲染功能 

1971
01:49:19,120 --> 01:49:23,410
因此 让我们继续下去 简单地看看我们的状态机程序库 

1972
01:49:23,410 --> 01:49:25,420
这是一个非常简单的代码 

1973
01:49:25,420 --> 01:49:29,710
它实际上取自我在课程前面提到的那本书--

1974
01:49:29,710 --> 01:49:31,000
如何制作RPG 

1975
01:49:31,000 --> 01:49:34,900
他们给了你这个状态机 我认为这真的很干净 

1976
01:49:34,900 --> 01:49:37,330
处理状态转换 

1977
01:49:37,330 --> 01:49:40,840
基本上 它需要一个初始化 然后是一系列的状态 

1978
01:49:40,840 --> 01:49:45,440
它有一个空类或空表 

1979
01:49:45,440 --> 01:49:46,750
所以所有这些都是空的 

1980
01:49:50,680 --> 01:49:52,840
如果没有--这是你可以做的事情

1981
01:49:52,840 --> 01:49:56,110
在Lua中 它只允许您在变量不是

1982
01:49:56,110 --> 01:49:57,820
在您的函数中给定值 

1983
01:50:01,870 --> 01:50:05,090
因此 self.States获得州或某个值 

1984
01:50:05,090 --> 01:50:08,770
这意味着如果州等于假值 则等于零 

1985
01:50:08,770 --> 01:50:10,330
把它放到这张空桌子上 

1986
01:50:10,330 --> 01:50:14,380
所以这只是一种速记 而不是说如果国家等于零 

1987
01:50:14,380 --> 01:50:16,950
然后将STATES设置为空表 

1988
01:50:16,950 --> 01:50:23,680
Self.Current只是一个空类或空状态 

1989
01:50:23,680 --> 01:50:26,670
所以这基本上就是一个国家 它只是一套方法--

1990
01:50:26,670 --> 01:50:28,780
渲染、更新、进入和退出功能 

1991
01:50:28,780 --> 01:50:31,960
这是一种状态 然后你定义所有的行为

1992
01:50:31,960 --> 01:50:36,060
在这些函数中的每一个中 这或多或少地编译了您的状态 

1993
01:50:36,060 --> 01:50:39,430
我们的Change函数接受一个名称 然后还有一些可选参数

1994
01:50:39,430 --> 01:50:41,080
我们可以用来进入那种状态 

1995
01:50:44,280 --> 01:50:48,201
当我们改变状态时 或者调用任何状态的退出函数时

1996
01:50:48,201 --> 01:50:48,700
我们进去了 

1997
01:50:48,700 --> 01:50:50,260
所以 退出这个状态吧 

1998
01:50:50,260 --> 01:50:53,660
也许您的函数需要您释放一些内存 

1999
01:50:53,660 --> 01:50:56,530
将电流设置为等于取那个名字 

2000
01:50:56,530 --> 01:50:58,155
然后调用那里的任何函数 

2001
01:50:58,155 --> 01:50:59,154
所以它会回来的 

2002
01:50:59,154 --> 01:51:02,530
在这种情况下 我们前面已经看到 它将返回一个新的标题屏幕状态 

2003
01:51:02,530 --> 01:51:05,050
所以这就是现在的情况 

2004
01:51:05,050 --> 01:51:09,116
有了self.Current 我们将进入该状态机 

2005
01:51:09,116 --> 01:51:11,740
因此 我们将调用在那里定义的Enter函数

2006
01:51:11,740 --> 01:51:17,180
使用我们传递给Change的任何输入参数 这些参数都是可选的 

2007
01:51:17,180 --> 01:51:22,600
然后在这里 StateMachineUpdate只更新当前状态 

2008
01:51:22,600 --> 01:51:27,140
并且无论当前状态是什么 都会进行渲染更新 

2009
01:51:27,140 --> 01:51:29,962
所以我要开始稍微快一点

2010
01:51:29,962 --> 01:51:31,670
就因为我们的时间不多了 

2011
01:51:31,670 --> 01:51:36,010
BaseState 它所做的只是实现空方法

2012
01:51:36,010 --> 01:51:38,809
这样你就可以继承这个状态 而你

2013
01:51:38,809 --> 01:51:40,600
可以选择要定义的方法

2014
01:51:40,600 --> 01:51:44,046
不会抛出任何错误 因为它会盲目地调用所有这些函数 

2015
01:51:44,046 --> 01:51:46,420
没有检查它们是否真正得到了实施 

2016
01:51:46,420 --> 01:51:50,530
所以这是一种让你快速避免

2017
01:51:50,530 --> 01:51:52,960
从本质上讲 是大量的样板代码 

2018
01:51:52,960 --> 01:52:00,760
这里的标题屏幕状态 这是您处理类库的方式 

2019
01:52:00,760 --> 01:52:04,210
只包括属于BaseState的所有东西 

2020
01:52:04,210 --> 01:52:06,700
所以继承 如果你熟悉其他语言

2021
01:52:06,700 --> 01:52:09,730
使用继承--获取一个对象 复制

2022
01:52:09,730 --> 01:52:12,760
把那个物体或那个类的所有东西都放到这个里面 

2023
01:52:12,760 --> 01:52:14,170
然后再加入新的东西 

2024
01:52:14,170 --> 01:52:15,711
这基本上就是继承的含义 

2025
01:52:15,711 --> 01:52:19,090
我们继承了BaseState 因此它具有BaseState的所有功能 

2026
01:52:19,090 --> 01:52:22,800
最重要的是 我们定义了一个更新函数 

2027
01:52:22,800 --> 01:52:27,410
因此 如果我们按Enter或Return 则更改全局状态机

2028
01:52:27,410 --> 01:52:28,670
转到播放状态 

2029
01:52:28,670 --> 01:52:31,400
然后对于渲染 我们将渲染50只鸟 

2030
01:52:31,400 --> 01:52:34,740
然后在屏幕中间按Enter键 

2031
01:52:34,740 --> 01:52:36,620
然后是PlayState 基本上是对一些人来说--

2032
01:52:36,620 --> 01:52:40,850
基本上 PlayState是我们之前运行的所有代码 只是

2033
01:52:40,850 --> 01:52:44,330
现在我们只是把它放在这里的更新函数中 

2034
01:52:44,330 --> 01:52:49,760
和这里的渲染功能 以及制作鸟、管子对、计时器

2035
01:52:49,760 --> 01:52:53,642
和此状态对象的最新成员字段 

2036
01:52:53,642 --> 01:52:55,475
因此 我们将继续 并且运行得非常快 

2037
01:53:01,010 --> 01:53:02,410
这是我们的标题屏幕状态 

2038
01:53:02,410 --> 01:53:05,661
因此 在开始时 我们将更改为标题屏幕状态 

2039
01:53:05,661 --> 01:53:07,910
它所做的就是渲染 然后是滚动行为

2040
01:53:07,910 --> 01:53:10,136
遍及所有班级 所有州 

2041
01:53:10,136 --> 01:53:11,510
无论如何 我们都会看到这一点 

2042
01:53:11,510 --> 01:53:13,460
一旦您按下Enter 它就会触发更改

2043
01:53:13,460 --> 01:53:17,210
播放 这将返回播放状态 然后

2044
01:53:17,210 --> 01:53:21,820
现在我们又回到了以前的地方 我们现在看到了不同之处

2045
01:53:21,820 --> 01:53:24,140
有几个不同的州 

2046
01:53:24,140 --> 01:53:27,480
所以快点 我来看一下比分更新 

2047
01:53:27,480 --> 01:53:32,510
所以这比上一个例子稍微复杂一些 

2048
01:53:32,510 --> 01:53:36,230
但总而言之 在鸟身上--

2049
01:53:36,230 --> 01:53:38,360
对不起 我们坐的是Bird9 

2050
01:53:38,360 --> 01:53:45,350
所以在Bird9中 如果我们去这里 我们将去Main 

2051
01:53:45,350 --> 01:53:50,810
请注意 在Main中 下面是我们定义StateMachine的地方 

2052
01:53:50,810 --> 01:53:54,080
我们将继续进行 还要注意我们需要一个新的分数

2053
01:53:54,080 --> 01:53:57,810
状态 因为现在我们想要显示分数屏幕 

2054
01:53:57,810 --> 01:54:05,130
在第96行 Score获得一个函数 我们在该函数中返回一个Score状态对象 

2055
01:54:05,130 --> 01:54:08,960
所以现在我们可以更改为得分 它将返回到那个状态 

2056
01:54:08,960 --> 01:54:12,320
我们可以定义ScoreState中的所有行为

2057
01:54:12,320 --> 01:54:16,160
我们需要显示一个分数 

2058
01:54:16,160 --> 01:54:24,140
在PipePair中 我们有一个名为self.core的新变量 

2059
01:54:24,140 --> 01:54:25,766
将其设置为True或False 

2060
01:54:25,766 --> 01:54:27,640
我们要把它设置为真 如果鸟有

2061
01:54:27,640 --> 01:54:31,060
穿过了这对管子的右边缘 

2062
01:54:31,060 --> 01:54:34,910
这将使我们有效地得到一分 

2063
01:54:34,910 --> 01:54:37,460
因为我们要做的就是确保鸟儿们

2064
01:54:37,460 --> 01:54:39,305
穿过那对管子 否则它

2065
01:54:39,305 --> 01:54:40,430
都会与之相撞 

2066
01:54:40,430 --> 01:54:45,980
如果超过了它 将其设置为True 然后在我们的分数上增加一分 

2067
01:54:45,980 --> 01:54:53,130
在我们的游戏状态下 我们可以看到我们已经添加了一分 

2068
01:54:53,130 --> 01:54:57,380
所以如果我们进入我们的播放状态 26是我们实际

2069
01:54:57,380 --> 01:54:58,510
记录我们的分数 

2070
01:54:58,510 --> 01:55:00,980
在我们的游戏状态下 Self.Score得0分 

2071
01:55:00,980 --> 01:55:03,530
我们要继续往前走 一直走到第56行 

2072
01:55:03,530 --> 01:55:06,637
因此 对于每一双 如果还没有得分--

2073
01:55:06,637 --> 01:55:09,470
因为如果已经打分了 我们就不需要计算了 

2074
01:55:09,470 --> 01:55:13,460
一旦得分 我们就应该忽略它的得分 

2075
01:55:13,460 --> 01:55:19,520
如果x加宽度小于我们的Bird.x 

2076
01:55:19,520 --> 01:55:22,820
这意味着我们的鸟在这对管子的右边 

2077
01:55:22,820 --> 01:55:25,190
增加我们的分数 并将该对设置为真 

2078
01:55:25,190 --> 01:55:28,237
然后我们会因为这个情况 然后忽略它 

2079
01:55:28,237 --> 01:55:30,070
我们还将增加我们的分数 

2080
01:55:30,070 --> 01:55:33,000
因此 它将被记录下来 

2081
01:55:33,000 --> 01:55:36,350
在83号公路上 请注意 如果我们与管道相撞 

2082
01:55:36,350 --> 01:55:38,920
我们现在应该转换到我们的得分状态 

2083
01:55:38,920 --> 01:55:42,380
我们也会传入自己的分数 分数作为表格

2084
01:55:42,380 --> 01:55:45,350
因为请记住 我们可以在调用Change时传入参数 

2085
01:55:45,350 --> 01:55:49,110
这将被传递到我们州的Enter函数中 

2086
01:55:49,110 --> 01:55:51,260
然后分数就等于自己 

2087
01:55:51,260 --> 01:55:54,170
我们将有权访问该分数状态内的分数 

2088
01:55:54,170 --> 01:55:56,480
我们不必把它作为一个全局变量来跟踪

2089
01:55:56,480 --> 01:55:59,810
在这两个地方都能看到 

2090
01:55:59,810 --> 01:56:02,360
在93号公路上 同样的事情 

2091
01:56:02,360 --> 01:56:05,810
这是碰撞 以检查我们是否与屏幕底部发生碰撞 

2092
01:56:05,810 --> 01:56:09,530
如果我们的y大于虚拟高度减去15 做完全相同的事情 

2093
01:56:09,530 --> 01:56:12,440
转换到分数状态 并在当前分数中传递它 

2094
01:56:12,440 --> 01:56:14,540
所以另一个死亡条件 

2095
01:56:14,540 --> 01:56:17,390
然后104 我们要设置Flappy Font 

2096
01:56:17,390 --> 01:56:21,206
然后我们将把我们的分数呈现在屏幕左上角的8 8 

2097
01:56:21,206 --> 01:56:23,280
这将会产生这种效果 

2098
01:56:23,280 --> 01:56:26,735
最后 在这里 我们的分数状态非常简单 

2099
01:56:29,197 --> 01:56:32,030
我们要做的就是--从我们传入的参数中

2100
01:56:32,030 --> 01:56:35,540
更改后 self.core等于pars.core 

2101
01:56:35,540 --> 01:56:38,270
我们要 当我们按回车键的时候 回到游戏中 

2102
01:56:38,270 --> 01:56:42,170
然后我们将呈现“You Lost” 然后是分数 

2103
01:56:42,170 --> 01:56:45,320
我们可以访问它--self.core 然后按Enter键再次播放 

2104
01:56:45,320 --> 01:56:46,980
在此过程中更改字体 

2105
01:56:46,980 --> 01:56:51,650
因此 如果我们回到Bird9 我们运行这个 

2106
01:56:51,650 --> 01:56:54,380
请注意 现在我们在左上角有一个分数 

2107
01:56:54,380 --> 01:57:01,220
我只得一分 然后就死定了 

2108
01:57:01,220 --> 01:57:03,220
然后我们现在进入计分屏幕 

2109
01:57:03,220 --> 01:57:07,180
记住 我们从我们的Play状态向它传递了分数 

2110
01:57:07,180 --> 01:57:13,240
我们将其作为参数传递 然后我们

2111
01:57:13,240 --> 01:57:16,550
可以再次按回车键 返回播放状态 当我们倒地时 

2112
01:57:16,550 --> 01:57:17,540
我们也是这么做的 

2113
01:57:17,540 --> 01:57:21,610
我们刚刚看了一下如何在我们的比赛中增加得分 

2114
01:57:21,610 --> 01:57:24,070
但是 如果我们想要添加一个倒计时屏幕呢？

2115
01:57:24,070 --> 01:57:28,810
也许我们希望在实际比赛之前提示用户三、二、一

2116
01:57:28,810 --> 01:57:30,660
开始向他们扔烟斗 

2117
01:57:30,660 --> 01:57:32,752
给他们时间让他们适应环境 

2118
01:57:32,752 --> 01:57:34,710
我们将继续下去 看看如何

2119
01:57:34,710 --> 01:57:38,870
我们可以使用与上一个示例非常类似的另一个状态来完成此操作 

2120
01:57:38,870 --> 01:57:41,350
我们将添加一个名为Countdown State的新州 

2121
01:57:41,350 --> 01:57:44,350
它显示在这里的第38行 

2122
01:57:44,350 --> 01:57:47,590
我们还将在我们的状态机中 

2123
01:57:47,590 --> 01:57:51,899
添加一个新的键 它返回一个新的倒计时状态 就像以前一样 

2124
01:57:51,899 --> 01:57:54,940
然后我们将继续 看看我们的实际倒计时

2125
01:57:54,940 --> 01:57:56,180
请在此说明 

2126
01:57:56,180 --> 01:58:04,510
因此 在我们的Countdown State.Lua中 与其他文件夹一样 它位于我们的States文件夹中 

2127
01:58:04,510 --> 01:58:06,460
它继承自BaseState 

2128
01:58:06,460 --> 01:58:09,160
我们已经将倒计时时间初始设置为0.75 

2129
01:58:09,160 --> 01:58:10,700
这一次是在几秒钟内 

2130
01:58:10,700 --> 01:58:14,170
一秒太长了 所以我把它改成了0.75秒 

2131
01:58:14,170 --> 01:58:16,810
我们将把计数初始化为3 将计时器初始化为0 

2132
01:58:16,810 --> 01:58:18,130
点票就要开始了 

2133
01:58:18,130 --> 01:58:22,540
一旦倒计时过去 它就会使用计时器 

2134
01:58:22,540 --> 01:58:24,040
就在这里 正如这个逻辑所示 

2135
01:58:24,040 --> 01:58:27,530
一旦计时器超过倒计时时间 就增加计时器 

2136
01:58:27,530 --> 01:58:29,960
我们想要继续 并将其设置为--

2137
01:58:29,960 --> 01:58:31,630
我们要通过倒计时来取模 

2138
01:58:31,630 --> 01:58:34,930
所以循环返回到0加上超过倒计时时间的任何值

2139
01:58:34,930 --> 01:58:38,740
我们去了 这样我们就能顺畅地追踪时间 

2140
01:58:38,740 --> 01:58:41,650
我们将自己设定 计数减去它自己

2141
01:58:41,650 --> 01:58:44,290
乘以1 我们就是3 2 1 

2142
01:58:44,290 --> 01:58:46,632
如果我们的计数是0 这意味着我们已经

2143
01:58:46,632 --> 01:58:48,340
在我们的统计中一路下降 我们是

2144
01:58:48,340 --> 01:58:51,640
继续使用我们的状态机 并更改为Play状态 

2145
01:58:51,640 --> 01:58:54,098
在这里 我们将字体设置为我们设置的字体--

2146
01:58:54,098 --> 01:58:56,770
HugeFont--然后我们就是两条线了 

2147
01:58:56,770 --> 01:58:59,320
一个接受字符串或数字的小函数 

2148
01:58:59,320 --> 01:59:00,420
转换为字符串 

2149
01:59:00,420 --> 01:59:05,110
我们在显示自己 数到0,120 然后我们的.

2150
01:59:05,110 --> 01:59:06,115
它是print tf 

2151
01:59:06,115 --> 01:59:10,814
所以我们基本上从0开始 y 120 虚拟宽度对齐 

2152
01:59:10,814 --> 01:59:11,980
然后我们把它放在中心 

2153
01:59:11,980 --> 01:59:15,520
所以我们需要改变的最后一件事

2154
01:59:15,520 --> 01:59:21,010
处于标题屏幕状态 而不是直接进入播放状态

2155
01:59:21,010 --> 01:59:24,070
在第15行 我们将进入倒计时状态 

2156
01:59:24,070 --> 01:59:29,710
这样做的效果是 如果我们进入鸟10号 

2157
01:59:29,710 --> 01:59:34,300
就是当我们按回车键时 注意我们要走三 二 一 

2158
01:59:34,300 --> 01:59:35,769
然后进入我们的游戏状态 

2159
01:59:35,769 --> 01:59:37,560
不仅仅是直接进入播放状态

2160
01:59:37,560 --> 01:59:40,990
和以前一样 给我们的用户一点时间喘口气 

2161
01:59:40,990 --> 01:59:45,370
如果我们死了 我们就会进入得分状态 但一旦我们按下Enter键 

2162
01:59:45,370 --> 01:59:48,320
请注意 我们也在这样做 

2163
01:59:48,320 --> 01:59:53,450
因此 在我们的得分状态下 我们也将切换到倒计时状态 

2164
01:59:53,450 --> 01:59:55,510
这就是如何建立一个倒计时状态 

2165
01:59:55,510 --> 01:59:58,720
在这些例子中 可能我最喜欢的部分 就是这个例子

2166
01:59:58,720 --> 02:00:02,680
也是将音频添加到我们的应用程序中 

2167
02:00:02,680 --> 02:00:05,306
音乐和音效 这真的将一切联系在一起 

2168
02:00:05,306 --> 02:00:07,430
所以我们要继续 看看这个 

2169
02:00:07,430 --> 02:00:08,290
这很简单 

2170
02:00:08,290 --> 02:00:12,400
和我们上周学到的非常相似 甚至是我们刚练乒乓球的时候 

2171
02:00:12,400 --> 02:00:18,490
因此 在Bird11的主要流星中 这就是我们现在要看到的 

2172
02:00:18,490 --> 02:00:22,390
我们要看一张音表

2173
02:00:22,390 --> 02:00:24,580
我们已经在第88行进行了初始化 

2174
02:00:24,580 --> 02:00:26,230
我们已经给了他们所有的钥匙 

2175
02:00:26,230 --> 02:00:28,160
跳跃 爆炸 受伤 得分 

2176
02:00:28,160 --> 02:00:31,870
这些都是我用BFX程序生成的音效

2177
02:00:31,870 --> 02:00:33,610
如果你还记得的话 我们上周用过的 

2178
02:00:33,610 --> 02:00:35,650
然后是我在网上找到的一首音乐曲目

2179
02:00:35,650 --> 02:00:38,440
在免费声音上 这是免费使用的 

2180
02:00:38,440 --> 02:00:40,345
如果好奇的话 这里有联系 

2181
02:00:40,345 --> 02:00:46,450
这只是一个很好的 快乐的配乐 我发现这个游戏 

2182
02:00:46,450 --> 02:00:49,510
在第99行到第100行 我们要做一个额外的步骤

2183
02:00:49,510 --> 02:00:50,890
在我们开始音乐之前

2184
02:00:50,890 --> 02:00:52,930
我们要将循环设置为true

2185
02:00:52,930 --> 02:00:55,930
因为在这样的无限博弈中

2186
02:00:55,930 --> 02:00:59,200
我们不想让我们的音乐就这么走了 然后突然停止 

2187
02:00:59,200 --> 02:01:03,370
我们想让它循环播放 

2188
02:01:03,370 --> 02:01:05,220
将循环设置为true 

2189
02:01:05,220 --> 02:01:08,620
我实际上是在我们任何一个州之外开始演奏这种音乐的

2190
02:01:08,620 --> 02:01:14,060
因为这将是一个全球性的音乐轨道 然后这就是音乐 

2191
02:01:14,060 --> 02:01:15,430
我们还需要音效 

2192
02:01:18,340 --> 02:01:22,480
如果我们看一下鸟的档案第45行 

2193
02:01:22,480 --> 02:01:26,020
我们有跳跃的逻辑 

2194
02:01:26,020 --> 02:01:30,400
同时播放我们生成的跳跃音效 

2195
02:01:30,400 --> 02:01:34,080
另外 在我们的游戏状态下 如果我们看一下那里 

2196
02:01:34,080 --> 02:01:36,520
我们可以在这里的州文件夹中查看 

2197
02:01:36,520 --> 02:01:42,040
去玩状态 看看第58行 

2198
02:01:42,040 --> 02:01:43,570
这是我们得分的地方 

2199
02:01:43,570 --> 02:01:46,630
所以我们应该在这里播放配乐音效 简单地说 

2200
02:01:46,630 --> 02:01:49,900
然后在第80到81行也是一样的 

2201
02:01:49,900 --> 02:01:52,720
碰撞 这里的声音效果 实际上我们

2202
02:01:52,720 --> 02:01:55,840
把两个声音叠加在一起 这是很常见的 

2203
02:01:55,840 --> 02:01:57,940
在声音设计和游戏设计中的应用 

2204
02:01:57,940 --> 02:02:01,857
一个声音 往往是不是所有你需要完成一个特定的效果 

2205
02:02:01,857 --> 02:02:04,690
所以我听到了爆炸声 这是一种白噪音效果 

2206
02:02:04,690 --> 02:02:10,190
然后是一种伤害的声音效果 有点像向下的正弦波

2207
02:02:10,190 --> 02:02:10,960
声音的类型 

2208
02:02:10,960 --> 02:02:14,140
95到96年的情况也是一样 

2209
02:02:14,140 --> 02:02:17,560
一旦我们把所有这些拼在一起 我们就可以开始了 

2210
02:02:17,560 --> 02:02:18,520
[音乐播放]

2211
02:02:18,520 --> 02:02:19,230
我们有音乐 

2212
02:02:23,038 --> 02:02:24,040
[哔哔声]

2213
02:02:24,040 --> 02:02:28,165
我们得到一个跳跃的声音效果 

2214
02:02:28,165 --> 02:02:31,362
当我们得了一分 

2215
02:02:31,362 --> 02:02:32,760
[叮]

2216
02:02:32,760 --> 02:02:34,110
我们得到了另一种声音效果 

2217
02:02:34,110 --> 02:02:35,020
[碰撞]

2218
02:02:35,020 --> 02:02:38,330
如果我们碰到一个管道 请注意 

2219
02:02:38,330 --> 02:02:39,002
[模仿噪音]

2220
02:02:39,002 --> 02:02:42,790
和白噪声或爆炸效果叠加在一起 

2221
02:02:42,790 --> 02:02:47,710
所以这就把所有的东西都结合在一起了 创造性的和艺术性的 

2222
02:02:47,710 --> 02:02:50,970
作为对观众的练习 在bird12中 

2223
02:02:50,970 --> 02:02:52,900
在GitHub存储库中 我们有一些代码

2224
02:02:52,900 --> 02:02:55,652
允许您实际将鼠标点击添加到Flappy Bird

2225
02:02:55,652 --> 02:02:58,360
为了让它更像真正的游戏 

2226
02:02:58,360 --> 02:02:59,380
是一款iOS游戏 

2227
02:02:59,380 --> 02:03:01,720
所以它依赖于水龙头 

2228
02:03:01,720 --> 02:03:06,040
您可能想要使用的功能是Love 鼠标按下x y 按钮 

2229
02:03:06,040 --> 02:03:09,010
我鼓励你们思考我们是如何接受意见 并做出

2230
02:03:09,010 --> 02:03:12,970
在我们前面的一个例子中 它在键盘的上下文中是全局的

2231
02:03:12,970 --> 02:03:20,140
所以我们可以称之为 这是在我们的Bird.Lua文件中按下的鼠标 

2232
02:03:20,140 --> 02:03:22,150
而不是主文件 

2233
02:03:22,150 --> 02:03:24,920
因此 下一次 我们将介绍一些新概念 

2234
02:03:24,920 --> 02:03:26,140
或者精灵床单 

2235
02:03:26,140 --> 02:03:30,910
所以拿出一个大的图像文件 然后取出其中的一大块

2236
02:03:30,910 --> 02:03:33,250
因此 我们不必拥有一百万个图形文件 

2237
02:03:33,250 --> 02:03:34,379
程序布局 

2238
02:03:34,379 --> 02:03:36,420
这将在游戏Breakout的背景下进行 

2239
02:03:36,420 --> 02:03:40,082
所以我们想要在我们的游戏中铺开所有的砖块 在程序上 

2240
02:03:40,082 --> 02:03:42,040
在某种程度上 我们在程序上

2241
02:03:42,040 --> 02:03:45,220
在这个游戏中创造了一个管道水平线 

2242
02:03:45,220 --> 02:03:47,530
我们将讨论不同的级别 并拥有

2243
02:03:47,530 --> 02:03:50,950
它们存储在内存中 而不是只有一个连续的级别 

2244
02:03:50,950 --> 02:03:52,384
我们将谈论健康问题 

2245
02:03:52,384 --> 02:03:55,300
我们将讨论粒子系统 它正在催生小迷你

2246
02:03:55,300 --> 02:03:59,170
图形来实现其他方式很难捕捉的各种效果

2247
02:03:59,170 --> 02:04:01,780
在简单的精灵动画中 

2248
02:04:01,780 --> 02:04:04,570
基于输入的碰撞检测稍微更花哨一点

2249
02:04:04,570 --> 02:04:07,792
这样我们就能以我们想要的方式驱动球的行为 

2250
02:04:07,792 --> 02:04:09,250
然后还永久保存数据 

2251
02:04:09,250 --> 02:04:11,440
我们怎么能拿到高分 而不是

2252
02:04:11,440 --> 02:04:15,670
每次我们运行应用程序时 它都会刷新为0 但会将其保存到磁盘

2253
02:04:15,670 --> 02:04:18,310
所以以后每次运行程序时 我们都可以看到

2254
02:04:18,310 --> 02:04:21,400
我们在过去几天里得到的分数 

2255
02:04:21,400 --> 02:04:24,910
第一个赋值 或其他第二个赋值 赋值一 

2256
02:04:24,910 --> 02:04:27,520
会比过去几周稍微复杂一些 

2257
02:04:27,520 --> 02:04:28,970
但仍相当可行 

2258
02:04:28,970 --> 02:04:31,940
让管道间隙稍微随机一些 这是其中的第一个组成部分 

2259
02:04:31,940 --> 02:04:34,240
因此 以前 管道间隙被设置为常量值 

2260
02:04:34,240 --> 02:04:36,190
也许让它成为某种随机值 

2261
02:04:36,190 --> 02:04:37,360
管道间距也是如此 

2262
02:04:37,360 --> 02:04:38,860
所以我们每隔两秒就产卵一次 

2263
02:04:38,860 --> 02:04:40,651
也许我们想要改变这一点 制造管道

2264
02:04:40,651 --> 02:04:44,020
产卵略有不同 更零星一些 

2265
02:04:44,020 --> 02:04:46,330
这项任务的更复杂的方面

2266
02:04:46,330 --> 02:04:49,150
将根据运动员的表现授予他们一枚奖牌 

2267
02:04:49,150 --> 02:04:52,060
所以可能会有一枚铜牌、一枚银牌和一枚金牌--

2268
02:04:52,060 --> 02:04:55,930
除了他们的分数外 您还可以在分数屏幕中显示的图像

2269
02:04:55,930 --> 02:04:58,602
只是为了给他们一点个人反馈 

2270
02:04:58,602 --> 02:05:01,060
让他们觉得自己的努力是有回报的 并让他们

2271
02:05:01,060 --> 02:05:03,640
争取拿到最后一块奖牌 

2272
02:05:03,640 --> 02:05:06,640
最后 您将实现暂停功能 我们已经讨论过了

2273
02:05:06,640 --> 02:05:11,170
例如 当你按下p键时 游戏就会停止 

2274
02:05:11,170 --> 02:05:13,720
但与这个例子不同的是 当我们再次按p时 

2275
02:05:13,720 --> 02:05:16,990
比赛应该继续进行 就像它之前的状态一样 

2276
02:05:16,990 --> 02:05:19,154
所以 Flappy Bird就是这样了 

2277
02:05:19,154 --> 02:05:20,320
下次再见了 

2278
02:05:20,320 --> 02:05:22,170
非常感谢 
