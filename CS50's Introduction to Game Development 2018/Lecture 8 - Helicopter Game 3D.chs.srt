1
00:00:00,000 --> 00:00:03,493
[音乐播放]

2
00:00:16,410 --> 00:00:17,410
科尔顿·奥格登：好的 

3
00:00:17,410 --> 00:00:18,850
欢迎回到GD50 

4
00:00:18,850 --> 00:00:19,930
这是第八课 

5
00:00:19,930 --> 00:00:22,900
今天 我们将深入到团结的世界

6
00:00:22,900 --> 00:00:25,030
这是第一次 这让我很兴奋 

7
00:00:25,030 --> 00:00:28,450
这将是一次旋风式的旅行 但我会尽可能多地报道 

8
00:00:28,450 --> 00:00:34,690
从2D、Lua和Love 2D过渡到3D和C#

9
00:00:34,690 --> 00:00:35,700
在团结的背景下 

10
00:00:35,700 --> 00:00:37,700
今天我们要讨论的是直升机3D游戏 

11
00:00:37,700 --> 00:00:42,220
所以直升机游戏是一款在2000年代非常出名的2D游戏 

12
00:00:42,220 --> 00:00:44,570
这是一款网络游戏 

13
00:00:44,570 --> 00:00:46,542
我在很多网站上得到了赞助 

14
00:00:46,542 --> 00:00:48,250
Addidicinggames.com上仍然有它 

15
00:00:48,250 --> 00:00:49,625
其他一些网站也有这一功能 

16
00:00:49,625 --> 00:00:50,697
这是一款快闪游戏 

17
00:00:50,697 --> 00:00:52,030
但我记得我经常玩它 

18
00:00:52,030 --> 00:00:54,940
它是Flappy Bird的旧前身 它

19
00:00:54,940 --> 00:00:56,470
在维基百科的页面上被提及 

20
00:00:56,470 --> 00:00:58,040
那里有提到它的地方 

21
00:00:58,040 --> 00:00:59,470
这就是游戏的样子 

22
00:00:59,470 --> 00:01:01,928
它与Flappy Bird非常相似--有一点不同

23
00:01:01,928 --> 00:01:04,750
在这种情况下 你不是试图避开管道 而是在一个洞穴里 

24
00:01:04,750 --> 00:01:08,080
你要尽量避开天花板和地面 

25
00:01:08,080 --> 00:01:10,180
中间会出现一些小障碍 

26
00:01:10,180 --> 00:01:10,560
也是 

27
00:01:10,560 --> 00:01:11,851
所以你必须驾驭它 

28
00:01:11,851 --> 00:01:15,710
但它是完全一样的机械师--就像 点击一下就能上去 

29
00:01:15,710 --> 00:01:17,710
然后 当你没有点击的时候 你的直升机

30
00:01:17,710 --> 00:01:20,890
会在重力的作用下下沉 

31
00:01:20,890 --> 00:01:25,240
今天我们将谈论一系列全新的话题 比如团结 

32
00:01:25,240 --> 00:01:28,150
首先也是最重要的--我们将利用的生态系统

33
00:01:28,150 --> 00:01:29,980
我们将要做的很多事情 

34
00:01:29,980 --> 00:01:32,410
C#是我们将使用的主要语言 

35
00:01:32,410 --> 00:01:36,100
因此 我们将不再使用动态语言 而是转向

36
00:01:36,100 --> 00:01:38,200
静态类型语言--

37
00:01:38,200 --> 00:01:40,899
C#和Java等语言 

38
00:01:40,899 --> 00:01:42,940
搅拌机是我们今天将简要介绍的一个程序 

39
00:01:42,940 --> 00:01:45,220
只是因为 在3D开发的背景下 

40
00:01:45,220 --> 00:01:48,053
你会想要一个可以让你创建模型的工具 

41
00:01:48,053 --> 00:01:51,027
因此 我最喜欢提倡的3D软件 特别是

42
00:01:51,027 --> 00:01:53,860
对于那些刚刚开始的人来说 是Blder 因为它是免费的 

43
00:01:53,860 --> 00:01:56,290
和开放源码 并且它具有大致相同的功能

44
00:01:56,290 --> 00:02:00,070
设置为任何商业软件 如3D Studio Max和Cinema 4D 

45
00:02:00,070 --> 00:02:01,329
诸如此类 

46
00:02:01,329 --> 00:02:04,120
我们将讨论什么是组件--实体和组件 以及如何

47
00:02:04,120 --> 00:02:08,470
它们与Unity在其所有方案编制中采用的这一模式有关 

48
00:02:08,470 --> 00:02:11,740
组件是行为的小片段 然后您可以

49
00:02:11,740 --> 00:02:16,330
结合成一个整体 这将驱动任何物体的行为

50
00:02:16,330 --> 00:02:18,250
你想要的场景 而不是

51
00:02:18,250 --> 00:02:23,920
通过一长串继承和实例化来自定义它的行为 

52
00:02:23,920 --> 00:02:26,660
对撞机和触发器在3D中很重要--

53
00:02:26,660 --> 00:02:27,391
和2D 

54
00:02:27,391 --> 00:02:29,140
但今天我们要讨论的是对撞机

55
00:02:29,140 --> 00:02:30,848
以及触发器--像直升机这样的东西

56
00:02:30,848 --> 00:02:34,930
与硬币、建筑物和其他飞行中的飞机相撞 

57
00:02:34,930 --> 00:02:37,365
其中每一个都必须有一个对撞机 

58
00:02:37,365 --> 00:02:40,240
某些事情必须被认为是触发因素才能触发

59
00:02:40,240 --> 00:02:43,060
与其他实体的某些行为 

60
00:02:43,060 --> 00:02:46,090
预制体和产卵--预制体在Unity中是一个巨大的概念 

61
00:02:46,090 --> 00:02:48,910
所以预制板基本上是预制件

62
00:02:48,910 --> 00:02:52,570
你可以按照你想要的方式进行定制--在编辑器中进行布局 

63
00:02:52,570 --> 00:02:55,310
而不是必须对所有细节进行编码 

64
00:02:55,310 --> 00:02:58,330
然后您可以在实际场景中实例化它们 

65
00:02:58,330 --> 00:03:02,330
以编程的方式通过代码 以适合您正在努力的模型的方式 

66
00:03:02,330 --> 00:03:05,080
纹理滚动是我们将简要介绍的内容 因为它是

67
00:03:05,080 --> 00:03:09,899
我们完成无限滚动美学或行为的方式 

68
00:03:09,899 --> 00:03:12,190
我们将看看如何以一种不同的方式实现这一点

69
00:03:12,190 --> 00:03:14,410
比我们以前做的更多 使用u-v坐标 

70
00:03:14,410 --> 00:03:17,530
特别是查看材料 并修改

71
00:03:17,530 --> 00:03:20,050
这些材料的某些属性 

72
00:03:20,050 --> 00:03:23,350
最后 像我们以前所做的那样 将所有的东西联系在一起 

73
00:03:23,350 --> 00:03:26,370
我们会看看音频--比如音频监听器和音频源--

74
00:03:26,370 --> 00:03:28,203
它们之间的区别是什么 

75
00:03:28,203 --> 00:03:30,070
将它们轻松添加到我们的游戏项目中 

76
00:03:30,070 --> 00:03:32,110
但首先 演示一下 如果有人愿意

77
00:03:32,110 --> 00:03:35,230
愿意上来看看 玩3D直升机游戏 

78
00:03:35,230 --> 00:03:37,656
放在一起 那就太棒了

79
00:03:37,656 --> 00:03:40,332
有人知道吗？

80
00:03:40,332 --> 00:03:41,230
史蒂文？

81
00:03:41,230 --> 00:03:42,840
棒了

82
00:03:42,840 --> 00:03:44,070
太感谢了

83
00:03:44,070 --> 00:03:46,580
让我继续 实际上得到它--

84
00:03:46,580 --> 00:03:48,990
所以我预先做好了

85
00:03:48,990 --> 00:03:52,800
所以让我继续 

86
00:03:52,800 --> 00:03:55,710
Unity的好处是 它可以导出到多个平台 

87
00:03:55,710 --> 00:03:57,690
一出门 你就能看到

88
00:03:57,690 --> 00:03:59,400
我没给它贴图标 

89
00:03:59,400 --> 00:04:02,970
但是你可以很容易地创建一个本地应用程序 

90
00:04:02,970 --> 00:04:05,190
所以当你准备好的时候 点击播放 

91
00:04:05,190 --> 00:04:08,462
上下移动你的直升机

92
00:04:12,080 --> 00:04:14,300
这就是3D直升机游戏 

93
00:04:14,300 --> 00:04:18,405
我不认为我们有声音现场 但应该有音频 

94
00:04:18,405 --> 00:04:20,816
哦 我可能真的--又来了 

95
00:04:20,816 --> 00:04:21,841
[音乐播放]

96
00:04:21,841 --> 00:04:22,340
好了

97
00:04:22,340 --> 00:04:23,567
是我的错

98
00:04:23,567 --> 00:04:24,650
所以有音乐播放 

99
00:04:24,650 --> 00:04:25,566
有音效 

100
00:04:25,566 --> 00:04:27,800
注意我们有一个3D模型 

101
00:04:27,800 --> 00:04:30,470
这就是所谓的2.5D游戏 

102
00:04:30,470 --> 00:04:33,170
所以即使一切都是3D的

103
00:04:33,170 --> 00:04:34,940
模型等等--

104
00:04:34,940 --> 00:04:38,390
实际上我们所依赖的轴只有两个 

105
00:04:38,390 --> 00:04:40,949
我相信 我们只是被束缚在x和y上 

106
00:04:40,949 --> 00:04:41,990
可能是z和x

107
00:04:41,990 --> 00:04:42,980
我一时想不起来 

108
00:04:42,980 --> 00:04:45,800
但我们只能有两个运动轴 

109
00:04:45,800 --> 00:04:48,290
但是所有的模特 正如我们在镜头前看到的 

110
00:04:48,290 --> 00:04:50,586
都是3D的包括我们的直升机

111
00:04:50,586 --> 00:04:51,960
所以我们有一些事情要做 

112
00:04:51,960 --> 00:04:54,140
我们有摩天大楼滚动 

113
00:04:54,140 --> 00:04:58,910
我们有硬币 也是以同样的速度通过的摩天大楼 

114
00:04:58,910 --> 00:05:02,420
我们有一个无限滚动的背景 

115
00:05:02,420 --> 00:05:07,250
当然 我们有直升机 它有一组旋转的桨叶 

116
00:05:07,250 --> 00:05:10,865
当我们与硬币碰撞时 注意我们会有一点--

117
00:05:10,865 --> 00:05:13,490
在室内可能很难看到 但我们有一个小颗粒

118
00:05:13,490 --> 00:05:15,592
效果发挥 

119
00:05:15,592 --> 00:05:17,300
有飞机在上面飞过 

120
00:05:17,300 --> 00:05:20,090
所以我们也实例化它们 让它们从我们身边飞过

121
00:05:20,090 --> 00:05:22,800
以提供另一层障碍 

122
00:05:22,800 --> 00:05:26,930
如果我们与一架飞机相撞 注意到我们会去产卵 

123
00:05:26,930 --> 00:05:29,785
然后我们触发另一个粒子效果来模拟爆炸 

124
00:05:29,785 --> 00:05:32,160
然后 请注意 我们还有其他几个元素 

125
00:05:32,160 --> 00:05:32,870
我们有一个图形用户界面 

126
00:05:32,870 --> 00:05:36,050
我们有两个图形用户界面元素--右上角有一个硬币总数 

127
00:05:36,050 --> 00:05:38,660
然后是屏幕中央的一款游戏 

128
00:05:38,660 --> 00:05:41,930
只有在我们死后才会出现 

129
00:05:41,930 --> 00:05:45,380
而爆炸性的行为--如果你想撞上一座建筑 

130
00:05:45,380 --> 00:05:46,190
你会看到的 

131
00:05:46,190 --> 00:05:48,273
当你与建筑物相撞时 它也会触发 

132
00:05:48,273 --> 00:05:52,990
所以有两个东西在寻找这些爆炸--上面的飞机 

133
00:05:52,990 --> 00:05:53,990
以及下面的建筑 

134
00:05:53,990 --> 00:05:55,640
这是我们的两个障碍 

135
00:05:55,640 --> 00:05:59,000
但当它们与硬币相撞时 我们应该增加硬币总数 

136
00:05:59,000 --> 00:06:01,130
然后显示不同的粒子效果 

137
00:06:01,130 --> 00:06:02,849
然后这个就会无限地继续下去 

138
00:06:02,849 --> 00:06:04,140
您可以按空格键重新启动 

139
00:06:04,140 --> 00:06:06,950
所以我们有基于什么的键盘输入

140
00:06:06,950 --> 00:06:09,090
我们按下按钮 就会发生不同的事情 

141
00:06:09,090 --> 00:06:11,780
这实际上就是我今天制作的演示 

142
00:06:11,780 --> 00:06:12,530
所以谢谢你 史蒂文 

143
00:06:12,530 --> 00:06:14,113
我很感谢你来演示它 

144
00:06:17,670 --> 00:06:19,140
这就是3D直升机游戏 

145
00:06:19,140 --> 00:06:24,610
它拥有与以前的网络版本基本相同的机制--

146
00:06:24,610 --> 00:06:29,225
我想说 也许还有更多的功能 只是为了说明一些新的概念 

147
00:06:29,225 --> 00:06:31,350
但这实际上就是我们今天要做的 

148
00:06:31,350 --> 00:06:37,590
我们只是一个非常简单的 Flappy Bird风格的不同主题的游戏 

149
00:06:37,590 --> 00:06:38,850
基于同样的原则 

150
00:06:38,850 --> 00:06:40,950
永远飞翔 避开障碍 

151
00:06:40,950 --> 00:06:43,920
在这种情况下 甚至可以得到一些收藏品 

152
00:06:43,920 --> 00:06:46,710
所以请注意 实际上也有两种状态

153
00:06:46,710 --> 00:06:50,310
在我们的游戏中 这只是正在进行的状态 然后是游戏结束的状态 

154
00:06:50,310 --> 00:06:52,210
这两者实际上几乎是一样的 

155
00:06:52,210 --> 00:06:56,130
唯一真正的区别是没有直升机在场 

156
00:06:56,130 --> 00:07:00,210
并在屏幕中央显示不同的图形用户界面元素 

157
00:07:00,210 --> 00:07:02,880
如果你还没有下载Unity 这里有两个链接 

158
00:07:02,880 --> 00:07:06,610
所以最上面的链接只是一个包罗万象的下载链接 

159
00:07:06,610 --> 00:07:08,430
然后第二个链接是测试版链接 

160
00:07:08,430 --> 00:07:10,430
因此 我们在本课程中实际上使用的是测试版 

161
00:07:10,430 --> 00:07:12,510
因为Unity已经开始过渡到

162
00:07:12,510 --> 00:07:15,450
从他们释放的数字系统中 

163
00:07:15,450 --> 00:07:17,490
现在每年都会发布他们的作品 

164
00:07:17,490 --> 00:07:22,090
所以最后一个长期发行的候选影片是2017年的《S》版 

165
00:07:22,090 --> 00:07:25,050
但现在我们已经快到2018年的一半了 

166
00:07:25,050 --> 00:07:27,330
最新的测试版是2018版 

167
00:07:27,330 --> 00:07:28,829
它有一系列新功能 

168
00:07:28,829 --> 00:07:30,120
因此 请继续查看这一点 

169
00:07:30,120 --> 00:07:33,270
一切都经过了良好的测试 运行得非常好--

170
00:07:33,270 --> 00:07:36,060
在Windows和Mac上运行非常流畅--

171
00:07:36,060 --> 00:07:37,750
使用新的测试版 

172
00:07:37,750 --> 00:07:40,034
那么 什么是团结呢？

173
00:07:40,034 --> 00:07:43,200
我们到目前为止所做的和我们今天所做的不同之处在于 

174
00:07:43,200 --> 00:07:46,430
现在我们实际上使用的是一个成熟的游戏引擎--

175
00:07:46,430 --> 00:07:47,190
这个系统 

176
00:07:47,190 --> 00:07:49,650
它有一个内置的编辑器 所有这一切都很棒 很酷

177
00:07:49,650 --> 00:07:52,460
这是我们以前在Love2D中没有得到的功能 

178
00:07:52,460 --> 00:07:54,540
我们之前所做的是使用一个框架 

179
00:07:54,540 --> 00:07:56,880
并且只需纯粹用代码实现所有内容 

180
00:07:56,880 --> 00:08:00,210
正如我们今天将看到的 您想做的一切都是可定制的

181
00:08:00,210 --> 00:08:01,530
实际上是--

182
00:08:01,530 --> 00:08:03,690
或者可以--通过代码来完成 

183
00:08:03,690 --> 00:08:06,810
但有很多更高效、更人性化的

184
00:08:06,810 --> 00:08:09,960
完成相同任务的方法 我们将会来看看 

185
00:08:09,960 --> 00:08:12,990
因此 Unity目前拥有巨大的市场份额 

186
00:08:12,990 --> 00:08:13,560
我忘了 

187
00:08:13,560 --> 00:08:19,670
我认为在2016年 它发布的所有游戏中有43%是在Unity中完成的 

188
00:08:19,670 --> 00:08:21,420
我不知道目前的数字是多少 

189
00:08:21,420 --> 00:08:22,295
我找不到他们 

190
00:08:22,295 --> 00:08:25,290
但还有其他的发动机也被很好地利用了--

191
00:08:25,290 --> 00:08:26,345
不真实的存在于他们之中 

192
00:08:26,345 --> 00:08:28,470
而虚幻现在可能拥有更多的市场份额 

193
00:08:28,470 --> 00:08:30,510
因为像堡垒之夜这样的游戏 因为它

194
00:08:30,510 --> 00:08:35,720
在过去的几年里有了很大的改进 而且确实营销得很好 

195
00:08:35,720 --> 00:08:38,010
但是Godot CryEngine--有很多游戏引擎

196
00:08:38,010 --> 00:08:39,718
类似于这个 

197
00:08:39,718 --> 00:08:42,840
这种处理游戏场景的包罗万象的方式

198
00:08:42,840 --> 00:08:44,220
和你所有的游戏数据 

199
00:08:44,220 --> 00:08:48,570
但是Unity是一个非常容易开始习惯的引擎 

200
00:08:48,570 --> 00:08:51,195
把事情做好 并且富有成效 

201
00:08:51,195 --> 00:08:54,030
没有巨大的学习曲线 

202
00:08:54,030 --> 00:08:56,220
其他引擎的性能 

203
00:08:56,220 --> 00:08:58,930
Unreal确实有一种更用户友好的做事方式 

204
00:08:58,930 --> 00:09:02,760
但如果你想深入了解虚幻的本质 

205
00:09:02,760 --> 00:09:05,737
你用的是半神秘的C++语言

206
00:09:05,737 --> 00:09:08,820
所以对于那些不习惯3D游戏开发的人来说 

207
00:09:08,820 --> 00:09:11,812
它可以是一种很大的板上 

208
00:09:11,812 --> 00:09:13,770
Unity的好处是 除了

209
00:09:13,770 --> 00:09:16,311
它很容易上手 因为它是免费的

210
00:09:16,311 --> 00:09:19,350
你可以完全使用它的所有功能

211
00:09:19,350 --> 00:09:26,280
直到你发布Unity产品的总收入超过10万美元 

212
00:09:26,280 --> 00:09:27,900
然后还有其他层次 

213
00:09:27,900 --> 00:09:30,540
再上一层就是如果你开始赚20万美元 

214
00:09:30,540 --> 00:09:33,232
你还可以通过其他层获得新的功能 

215
00:09:33,232 --> 00:09:35,190
但如果你想开一家新公司 

216
00:09:35,190 --> 00:09:38,179
and use Unity团结 and take something to market市场--

217
00:09:38,179 --> 00:09:39,220
完全自由地这样做 

218
00:09:39,220 --> 00:09:41,850
一旦你超过10万美元 这是一个很好的问题 

219
00:09:41,850 --> 00:09:44,850
开始的时候要求不一定太多

220
00:09:44,850 --> 00:09:48,300
付钱给Unity 让它作为一种

221
00:09:48,300 --> 00:09:49,970
投放到市场上

222
00:09:49,970 --> 00:09:55,120
特别是在移动和VR领域 Unity有点像是走在最前沿的 

223
00:09:55,120 --> 00:09:56,910
它的比例甚至更高 

224
00:09:56,910 --> 00:10:00,330
这就像60%或70%的移动市场份额 

225
00:10:00,330 --> 00:10:05,774
然后是虚拟现实--从一开始 它就非常强烈地推销自己

226
00:10:05,774 --> 00:10:06,690
使用VR 

227
00:10:06,690 --> 00:10:10,260
下节课我们会用到虚拟现实

228
00:10:10,260 --> 00:10:14,850
以及我们完成所有项目的方式

229
00:10:14,850 --> 00:10:17,160
用代码来实现

230
00:10:17,160 --> 00:10:20,400
是通过C# 这与我们到目前为止使用的非常不同 

231
00:10:20,400 --> 00:10:23,010
我们使用Lua 这是一种动态脚本语言 

232
00:10:23,010 --> 00:10:25,980
非常像Java脚本 

233
00:10:25,980 --> 00:10:30,270
所以C#非常类似于Java 在Java中 事物实际上是有类型的 

234
00:10:30,270 --> 00:10:34,674
因此 这里有几个屏幕截图的联合编辑是什么样子 

235
00:10:34,674 --> 00:10:36,840
所以 联合编辑的好处是 实际上--

236
00:10:36,840 --> 00:10:38,670
我们可以在这里的大门上看到--

237
00:10:38,670 --> 00:10:40,380
它是非常可定制的 

238
00:10:40,380 --> 00:10:43,050
因此 在顶部 这是默认的视图 

239
00:10:43,050 --> 00:10:46,340
你有一个底部的面板 向你展示你的所有资源 

240
00:10:46,340 --> 00:10:49,530
您的所有资源 如脚本、着色器和模型 

241
00:10:49,530 --> 00:10:50,934
纹理和声音 

242
00:10:50,934 --> 00:10:53,850
在左侧有一个很好的文件浏览器 它允许

243
00:10:53,850 --> 00:10:55,350
使您能够轻松导航您的项目 

244
00:10:55,350 --> 00:10:58,612
您不必查看Windows或Mac电脑 使用

245
00:10:58,612 --> 00:11:00,570
你的发现者或诸如此类的人 或你的文件资源管理器 

246
00:11:00,570 --> 00:11:02,278
然后真正查看你所有的文件 

247
00:11:02,278 --> 00:11:05,310
你可以在那里看到很好的景色 这样你就可以保持一体化

248
00:11:05,310 --> 00:11:08,419
就在那里的联合生态系统里 

249
00:11:08,419 --> 00:11:11,460
在右侧 您可以看到任何对象的所有行为

250
00:11:11,460 --> 00:11:12,690
你在你的场景中可能会有 

251
00:11:12,690 --> 00:11:14,310
你可以看到一个很棒的大场景 

252
00:11:14,310 --> 00:11:17,500
所以 与其让你的游戏现场直播 不如

253
00:11:17,500 --> 00:11:19,250
以这种方式 你实际上可以

254
00:11:19,250 --> 00:11:22,370
提前看到你的场景是什么样子 并分析

255
00:11:22,370 --> 00:11:25,220
你的游戏对象是这样的 它们的外观 

256
00:11:25,220 --> 00:11:27,080
以及你想用它们做什么 

257
00:11:27,080 --> 00:11:29,000
把它们完美地铺开 而不是

258
00:11:29,000 --> 00:11:31,607
以编程的方式解决问题 

259
00:11:31,607 --> 00:11:33,440
在左边 你可以看到

260
00:11:33,440 --> 00:11:35,052
所有游戏对象的完整列表 

261
00:11:35,052 --> 00:11:36,760
然后在右下角的屏幕截图上 

262
00:11:36,760 --> 00:11:39,550
您可以看到 该编辑器是高度可定制的 

263
00:11:39,550 --> 00:11:41,300
所以你可以随心所欲地摆放东西

264
00:11:41,300 --> 00:11:43,310
以适应您的开发风格 

265
00:11:43,310 --> 00:11:47,737
我经常喜欢在上面有一个面板 它向我展示我的场景视图 

266
00:11:47,737 --> 00:11:50,570
然后在它的正下方有一个面板 它向我展示了游戏的视图 

267
00:11:50,570 --> 00:11:54,470
因此 如果我真的在运行一个游戏 并看到它发生在现场 

268
00:11:54,470 --> 00:11:58,310
我也可以在场景中看到它 并在这个上帝模式下旋转

269
00:11:58,310 --> 00:12:00,380
你可以在很多比赛中都能看到 

270
00:12:00,380 --> 00:12:03,700
并以这种方式分析和看待事物 

271
00:12:03,700 --> 00:12:05,800
并逐帧分析它们的行为 

272
00:12:05,800 --> 00:12:08,930
即使我想 但在某种程度上这是不可能的

273
00:12:08,930 --> 00:12:13,010
我可能已经在实际游戏中编写了摄像头的代码 

274
00:12:13,010 --> 00:12:14,810
所以C# 

275
00:12:14,810 --> 00:12:17,334
在座有人使用过静态语言吗 

276
00:12:17,334 --> 00:12:19,250
或者熟悉静态类型语言

277
00:12:19,250 --> 00:12:21,360
与动态类型语言相比？

278
00:12:21,360 --> 00:12:23,270
[听不见] 史蒂文 

279
00:12:23,270 --> 00:12:27,610
出于好奇 你们用过什么语言？

280
00:12:27,610 --> 00:12:28,110
史蒂文 

281
00:12:28,110 --> 00:12:29,320
史蒂文：Java、C、C++ 

282
00:12:29,320 --> 00:12:30,445
Colton Ogden：Java、C、C++ 

283
00:12:30,445 --> 00:12:31,165
唐尼？

284
00:12:31,165 --> 00:12:31,690
唐尼：[听不见]

285
00:12:31,690 --> 00:12:32,320
Colton Ogden：C和C++ 

286
00:12:32,320 --> 00:12:32,820
好的 

287
00:12:32,820 --> 00:12:35,940
所以对你们来说 这将是非常相似的 

288
00:12:35,940 --> 00:12:38,516
因此 C#非常类似于Java 

289
00:12:38,516 --> 00:12:40,140
乍一看 它们几乎一模一样 

290
00:12:40,140 --> 00:12:42,830
有些功能是不同的 

291
00:12:42,830 --> 00:12:49,100
但与Java竞争是微软的创举 

292
00:12:49,100 --> 00:12:51,200
首先 它是一种微软语言 

293
00:12:51,200 --> 00:12:55,805
但有一些方法可以在其他平台上运行C#代码 

294
00:12:55,805 --> 00:12:57,680
主要是使用所谓的Mono 

295
00:12:57,680 --> 00:13:01,760
所以Mono是CLR的开源实现--

296
00:13:01,760 --> 00:13:03,740
公共语言运行时--

297
00:13:03,740 --> 00:13:09,980
这就是微软如何允许它的几种语言 如F#和C# 

298
00:13:09,980 --> 00:13:12,320
和Visual C++、Visual Basic 

299
00:13:12,320 --> 00:13:15,080
它们都编译成这种中间格式 

300
00:13:15,080 --> 00:13:17,450
就像Java如何编译成字节码一样 

301
00:13:17,450 --> 00:13:21,520
你可以运行任何一种语言的代码--

302
00:13:21,520 --> 00:13:24,880
他们版本的字节码--使用CLR 

303
00:13:24,880 --> 00:13:27,440
Mono--Mono是什么 Unity依赖于什么

304
00:13:27,440 --> 00:13:30,830
为了允许跨多个操作系统使用它 

305
00:13:30,830 --> 00:13:33,950
是一个CLR 它不仅仅是Windows特有的 

306
00:13:33,950 --> 00:13:37,380
它实际上也可以在Mac和Linux机器上运行 

307
00:13:37,380 --> 00:13:43,580
你实际上会通过使用的命名法看到它存在的证据

308
00:13:43,580 --> 00:13:45,229
用于单声道行为 

309
00:13:45,229 --> 00:13:47,270
因此在Unity内部 有一种叫做单声道的东西

310
00:13:47,270 --> 00:13:49,230
行为 我们将会看一看 

311
00:13:49,230 --> 00:13:53,360
事实上 从一开始 Unity就是为Mac平台开发的 

312
00:13:53,360 --> 00:13:54,920
独家 

313
00:13:54,920 --> 00:14:00,020
但在2012年或2011年 他们最终使其在所有主要桌面上可用

314
00:14:00,020 --> 00:14:02,150
操作系统.

315
00:14:02,150 --> 00:14:04,760
但是C#--可以说 非常类似于Java 

316
00:14:04,760 --> 00:14:05,850
我们来看看它的语法 

317
00:14:05,850 --> 00:14:09,770
但它与Lua的不同之处在于 对于Lua 你可以说 

318
00:14:09,770 --> 00:14:14,150
x等于10 或者object等于--然后创建

319
00:14:14,150 --> 00:14:16,220
一张桌子 你想要什么都行 

320
00:14:16,220 --> 00:14:20,015
在这个意义上 C#的灵活性要小得多 因为你必须真正告诉它 

321
00:14:20,015 --> 00:14:23,460
你要创建的每种数据类型 

322
00:14:23,460 --> 00:14:26,720
所以你不能只创建一个表或一个整数 

323
00:14:26,720 --> 00:14:31,820
你实际上必须说 int my_int 或者x等于 然后10 

324
00:14:31,820 --> 00:14:33,020
然后是分号

325
00:14:33,020 --> 00:14:37,430
所以还有更多的语法需要注意 

326
00:14:37,430 --> 00:14:41,150
所以很快 我可以向你展示一些C#是什么样子的 

327
00:14:41,150 --> 00:14:43,590
我们以后会再看一遍 

328
00:14:43,590 --> 00:14:46,620
但正如你所看到的 我们有公众 

329
00:14:46,620 --> 00:14:49,160
这是关于C#的另一件事 

330
00:14:49,160 --> 00:14:51,740
在Java中 如果你熟悉Java 

331
00:14:51,740 --> 00:14:54,270
面向对象的编程语言 

332
00:14:54,270 --> 00:14:59,000
因此 有公共和私人的对象 

333
00:14:59,000 --> 00:15:04,130
不同的变量和类有访问说明符

334
00:15:04,130 --> 00:15:06,590
告诉其他变量和类

335
00:15:06,590 --> 00:15:08,270
他们可以有效地沟通 

336
00:15:08,270 --> 00:15:12,230
所以公共类实际上意味着任何人都可以看到这个类 

337
00:15:12,230 --> 00:15:15,590
其他类可以看到这一点 

338
00:15:15,590 --> 00:15:17,880
但是你有...

339
00:15:17,880 --> 00:15:21,204
看看有没有一个有私有变量的

340
00:15:21,204 --> 00:15:22,370
我知道至少有一个 

341
00:15:22,370 --> 00:15:23,120
开始吧

342
00:15:23,120 --> 00:15:25,220
比如这里的私密文本

343
00:15:25,220 --> 00:15:27,980
首先 注意这些是变量声明

344
00:15:27,980 --> 00:15:29,960
就像我们之前看到的那样

345
00:15:29,960 --> 00:15:32,450
我们说 这是一个变量 我将使用 

346
00:15:32,450 --> 00:15:34,940
在这种情况下 公共GameObject直升机 

347
00:15:34,940 --> 00:15:36,470
所以我只是定义它 

348
00:15:36,470 --> 00:15:37,880
或者我宣布 

349
00:15:37,880 --> 00:15:38,920
我不是在定义它 

350
00:15:38,920 --> 00:15:40,220
它还不等于任何东西 

351
00:15:40,220 --> 00:15:43,730
但我想说 这是会存在的 对吧？

352
00:15:43,730 --> 00:15:50,510
你可以说等于某事 然后在同一行上定义它 

353
00:15:50,510 --> 00:15:55,730
但在这种情况下 我们只是提前声明了不同的变量

354
00:15:55,730 --> 00:15:57,742
我们以后会需要的 

355
00:15:57,742 --> 00:15:58,700
比如 这里 

356
00:15:58,700 --> 00:16:00,134
我们看到了 在我们的Start方法中 

357
00:16:00,134 --> 00:16:03,050
我们将回顾所有这些方法是什么 以及它们是如何相关的 

358
00:16:03,050 --> 00:16:05,690
但我们可以在这里看到 文字等于--

359
00:16:05,690 --> 00:16:08,880
然后我们调用一个名为GetComponent的函数 

360
00:16:08,880 --> 00:16:10,760
然后我们这里有一些时髦的语法--

361
00:16:10,760 --> 00:16:12,800
小于 文本 大于--

362
00:16:12,800 --> 00:16:15,500
然后是函数调用语法--

363
00:16:15,500 --> 00:16:16,740
两个括号 

364
00:16:16,740 --> 00:16:19,880
所以我们可以看到有更多的语法 

365
00:16:19,880 --> 00:16:22,070
但所有同样的原则仍然适用 

366
00:16:22,070 --> 00:16:25,330
这仍然是思考编程的大致相同的方式 

367
00:16:25,330 --> 00:16:28,250
只是 还有更多的东西需要保持意识 

368
00:16:28,250 --> 00:16:32,490
我们牺牲了这种活力 换取了更高的性能 

369
00:16:32,490 --> 00:16:35,870
这就是归根结底的问题--静态语言与动态语言

370
00:16:35,870 --> 00:16:39,930
在这种情况下 您是在牺牲灵活性来换取性能 

371
00:16:39,930 --> 00:16:42,320
尽管C#显然比Lua快得多 

372
00:16:42,320 --> 00:16:44,250
我们可以用它做更多的事情 

373
00:16:44,250 --> 00:16:47,280
实际上 Unity本身并不是用C#编写的 

374
00:16:47,280 --> 00:16:50,390
Unity本身是用C++编写的 

375
00:16:50,390 --> 00:16:58,320
但它允许我们用C#编程任何我们想要的行为 

376
00:16:58,320 --> 00:16:58,820
好的 

377
00:16:58,820 --> 00:17:04,760
这就是C# 所以我们也可以看到我在这里提到的东西 

378
00:17:04,760 --> 00:17:08,400
我们有私人的 公共的 我们和他们一起做事情 

379
00:17:08,400 --> 00:17:12,290
然后 根据我们宣布的公共或私人内容 

380
00:17:12,290 --> 00:17:14,089
这些东西也会转移到编辑器中 

381
00:17:14,089 --> 00:17:16,649
我们很快就会看到这一切是如何结合在一起的 

382
00:17:16,649 --> 00:17:19,190
但我要说的是 这就是C#--它看起来是什么样子 

383
00:17:19,190 --> 00:17:21,356
我们会使用它 我们会对它感到舒服 

384
00:17:21,356 --> 00:17:25,940
但这与我们到目前为止所做的略有不同 

385
00:17:25,940 --> 00:17:29,450
除了编程 我们将非常简短地了解一下Blder是什么 

386
00:17:29,450 --> 00:17:31,820
所以我把它安装在这里 

387
00:17:31,820 --> 00:17:33,800
这不是这门课的必修课 

388
00:17:33,800 --> 00:17:36,410
我会为你提供所有的模型和所有的资产

389
00:17:36,410 --> 00:17:39,320
你需要开始工作了 

390
00:17:39,320 --> 00:17:40,730
但这就是搅拌机的本质 

391
00:17:40,730 --> 00:17:46,790
因此 搅拌机乍一看几乎与Unity非常相似 

392
00:17:46,790 --> 00:17:50,300
最大的区别在于 这意味着要创造新的资产 

393
00:17:50,300 --> 00:17:53,540
从技术上讲 Blder确实有一个内置的游戏引擎 

394
00:17:53,540 --> 00:17:55,850
但它并没有太多地用于这个目的 

395
00:17:55,850 --> 00:18:00,257
但我们在本课程中使用它的唯一目的是

396
00:18:00,257 --> 00:18:01,840
就是创建新的3D模型 

397
00:18:01,840 --> 00:18:06,500
正如你在这里看到的 我可以点击这些顶点 并移动它们 

398
00:18:06,500 --> 00:18:12,050
当谈到搅拌机时 我不是任何想象力的大师 

399
00:18:12,050 --> 00:18:15,230
但直升机、喷气式飞机和摩天大楼 

400
00:18:15,230 --> 00:18:18,200
那些简单的模型 都是我在搅拌机里做的 

401
00:18:18,200 --> 00:18:21,229
这些都与项目捆绑在一起 如果您

402
00:18:21,229 --> 00:18:23,270
我想看看这些是如何实现的 

403
00:18:23,270 --> 00:18:25,750
你可以在--上下载Blder

404
00:18:25,750 --> 00:18:27,500
实际上 我忘了确切的联系是什么 

405
00:18:27,500 --> 00:18:28,740
让我们来看看 

406
00:18:28,740 --> 00:18:30,610
搅拌器网站 

407
00:18:33,780 --> 00:18:36,120
然后 如果我们从这里下载搅拌机 

408
00:18:36,120 --> 00:18:39,720
2.79看起来像是最新的版本 

409
00:18:39,720 --> 00:18:42,000
搅拌器2.8--我猜它还在开发中 

410
00:18:42,000 --> 00:18:45,220
但头版没有任何具体的内容 

411
00:18:45,220 --> 00:18:45,720
不过 是的 

412
00:18:45,720 --> 00:18:48,660
如果您想对3D资源进行建模 并且您很好奇 

413
00:18:48,660 --> 00:18:51,240
你想要一个免费的非常棒的软件 

414
00:18:51,240 --> 00:18:53,040
怎么推荐Blder都不为过 

415
00:18:53,040 --> 00:18:57,300
但就像我说的 我会花太多时间在上面 因为它不是

416
00:18:57,300 --> 00:18:59,640
课程中实际需要的内容

417
00:18:59,640 --> 00:19:02,000
为了实现3D模型 为了创建3D模型 

418
00:19:02,000 --> 00:19:07,040
因为我将在GitHub回购的项目中向您提供所有这些内容 

419
00:19:07,040 --> 00:19:10,450
这是我们刚刚看到的截图 

420
00:19:10,450 --> 00:19:13,740
因此 团结的基本部分 

421
00:19:13,740 --> 00:19:17,550
因此 首先 让我们来看一看Unity编辑器 

422
00:19:17,550 --> 00:19:20,820
所以我们可以在这里看到很多我们在屏幕截图中看到的东西 

423
00:19:20,820 --> 00:19:24,030
但在这里 我正在现场观看我的场景 对吗？

424
00:19:24,030 --> 00:19:25,380
我有一架直升机 

425
00:19:25,380 --> 00:19:27,780
我在这里有这样的背景 

426
00:19:27,780 --> 00:19:28,650
我有个相机--

427
00:19:28,650 --> 00:19:30,060
就在这里 

428
00:19:30,060 --> 00:19:32,180
你可以看到这是一个相机 因为它有一个小相机图标 

429
00:19:32,180 --> 00:19:34,500
但它实际上只是一个看不见的游戏对象 

430
00:19:34,500 --> 00:19:38,670
它实际上永远不会呈现在屏幕上 

431
00:19:38,670 --> 00:19:42,204
注意 那里没有摩天大楼 没有硬币 没有喷气式飞机 

432
00:19:42,204 --> 00:19:43,120
或者诸如此类的事情 

433
00:19:43,120 --> 00:19:45,090
这些都是动态实例化的 

434
00:19:45,090 --> 00:19:47,135
但这只是我们场景的开始 

435
00:19:47,135 --> 00:19:48,510
而且这一切都是事先安排好的 

436
00:19:48,510 --> 00:19:50,426
我们可以在这里看到这台摄像机的预览图--

437
00:19:50,426 --> 00:19:53,190
这是很难看到的 因为它真的很小

438
00:19:53,190 --> 00:19:56,550
但这里是它看起来像什么的更大的视角 

439
00:19:56,550 --> 00:19:59,192
然后我们这里有一个图形用户界面元素 我们这里有硬币 

440
00:19:59,192 --> 00:20:00,150
我们有直升机了 

441
00:20:00,150 --> 00:20:04,950
但所有这些都与我们所得到的有明显的不同

442
00:20:04,950 --> 00:20:07,700
过去 也就是 对所有东西进行编程 然后加载它 

443
00:20:07,700 --> 00:20:09,660
还有 哦 我把这个放对地方了吗？

444
00:20:09,660 --> 00:20:09,780
不是的 

445
00:20:09,780 --> 00:20:10,280
我没有 

446
00:20:10,280 --> 00:20:10,920
所以我必须这么做 

447
00:20:10,920 --> 00:20:13,720
如果我想来这里 然后搬走

448
00:20:13,720 --> 00:20:15,840
直升机有点--

449
00:20:15,840 --> 00:20:16,540
就像那样 

450
00:20:16,540 --> 00:20:17,040
哎呦 

451
00:20:17,040 --> 00:20:17,873
我刚刚触发了它 

452
00:20:17,873 --> 00:20:20,670
如果你点击某件东西 顺便说一句 它

453
00:20:20,670 --> 00:20:23,532
将播放与其关联的任何粒子系统 

454
00:20:23,532 --> 00:20:25,740
因此 你实际上也可以得到它们的预览 

455
00:20:25,740 --> 00:20:27,840
但我可以很容易地把它移到这里 移到右边 

456
00:20:27,840 --> 00:20:30,600
或者在比赛真正开始之前向左转 

457
00:20:30,600 --> 00:20:33,760
如果我点击摄像机 我们可以在那里看到它 

458
00:20:33,760 --> 00:20:37,780
它有点向左移动 而不是以前的样子 

459
00:20:37,780 --> 00:20:41,560
但如果我只按几次Command-Z 它就会恢复正常 

460
00:20:41,560 --> 00:20:44,500
因此 游戏对象是一个重要的概念 

461
00:20:44,500 --> 00:20:49,500
因此 游戏对象基本上就是Unity中的一切 

462
00:20:49,500 --> 00:20:51,840
因此 摄像机是一个游戏对象 

463
00:20:51,840 --> 00:20:54,090
直升机 就在这里 是一个游戏对象 

464
00:20:54,090 --> 00:20:57,180
顺便说一句 你想在你的Unity场景中看到的一切

465
00:20:57,180 --> 00:20:59,760
就在这个左手边的层次结构上 

466
00:20:59,760 --> 00:21:02,760
所以直升机 游戏对象 

467
00:21:02,760 --> 00:21:05,220
在3D场景中必须有一个光源

468
00:21:05,220 --> 00:21:06,720
让你真正看到一些东西 

469
00:21:06,720 --> 00:21:09,330
所以平行光--这是一个游戏对象 

470
00:21:09,330 --> 00:21:12,360
背景摩天大楼--我们在任何地方都看不到它 

471
00:21:12,360 --> 00:21:13,650
但这也是一个游戏对象 

472
00:21:13,650 --> 00:21:15,960
它只是一个看不见的东西 

473
00:21:15,960 --> 00:21:17,010
一个硬币产生者 

474
00:21:17,010 --> 00:21:20,550
有一种叫做画布的东西 如果我们双击它 

475
00:21:20,550 --> 00:21:26,670
我们可以看到这里有一个非常大的图形用户界面 矛盾的是 

476
00:21:26,670 --> 00:21:29,850
并不是我们的头等大事 

477
00:21:29,850 --> 00:21:33,210
Unity用它的所有图形用户界面元素做了一件非常有趣的事情 

478
00:21:33,210 --> 00:21:40,080
因为它基本上将画布映射到一个像素

479
00:21:40,080 --> 00:21:44,460
等于一个单位 通常相当于一米 

480
00:21:44,460 --> 00:21:48,720
并且它在与它不同的绘制调用中绘制它

481
00:21:48,720 --> 00:21:52,710
画出所有真实的3D素材--

482
00:21:52,710 --> 00:21:55,710
所有这些东西 基本上都在这里--在世界空间 

483
00:21:55,710 --> 00:21:59,760
所以当你创作一幅画布时 你会发现它是巨大的 

484
00:21:59,760 --> 00:22:01,330
这只是Unity做图形用户界面的方式 

485
00:22:01,330 --> 00:22:03,180
很奇怪 

486
00:22:03,180 --> 00:22:05,490
但显然 他们这样做是出于性能原因 

487
00:22:05,490 --> 00:22:08,700
因为他们不需要计算小数点

488
00:22:08,700 --> 00:22:13,530
用户界面应该在World Space中 它可能会变得非常小 

489
00:22:13,530 --> 00:22:18,100
但画布是一个游戏对象 

490
00:22:18,100 --> 00:22:21,309
请注意 直升机有孩子 

491
00:22:21,309 --> 00:22:24,350
它有刀片 一个身体 然后是刀片对撞机 这实际上可能

492
00:22:24,350 --> 00:22:26,390
是刀片物体的一部分 

493
00:22:26,390 --> 00:22:30,420
Canvas本身有两个孩子--硬币文本和游戏结束 

494
00:22:30,420 --> 00:22:34,590
这些是右上角的文字 中间是“游戏结束” 

495
00:22:34,590 --> 00:22:38,430
所以这只是两个文本对象 

496
00:22:38,430 --> 00:22:43,200
是标签 我们只需要用我们想要的任何文本数据来填充 

497
00:22:43,200 --> 00:22:45,210
事件系统是一个对象 

498
00:22:45,210 --> 00:22:49,110
当您添加画布时 它会自动添加到场景中 

499
00:22:49,110 --> 00:22:52,590
飞机产卵器、爆炸粒子和爆炸声 

500
00:22:52,590 --> 00:22:54,780
所以我们有所有这些不同的物体 

501
00:22:54,780 --> 00:22:58,359
他们都是我们场景的一部分 他们都做了不同的事情 

502
00:22:58,359 --> 00:23:00,150
但从本质上讲 它们只是游戏对象 

503
00:23:00,150 --> 00:23:03,600
这就是核心--就像最底层的那种 

504
00:23:03,600 --> 00:23:04,382
是?

505
00:23:04,382 --> 00:23:07,274
观众：所以我可以想象你不是真的在用

506
00:23:07,274 --> 00:23:11,130
直升机[国际航空运输协会]

507
00:23:11,130 --> 00:23:12,972
科尔顿·奥格登：正确 

508
00:23:12,972 --> 00:23:16,924
观众：那么你真的应该重新设置位置吗？

509
00:23:16,924 --> 00:23:20,890
背景[INAUDIBLE]？

510
00:23:20,890 --> 00:23:25,420
科尔顿·奥格登：所以问题是 既然我们坚持

511
00:23:25,420 --> 00:23:28,255
一贯的立场与--

512
00:23:28,255 --> 00:23:30,720
我要试着滚动进去 好了 

513
00:23:30,720 --> 00:23:32,726
Unity 2的好处是 如果你右击 

514
00:23:32,726 --> 00:23:34,600
你可以用W-A-S-D在现场移动 

515
00:23:34,600 --> 00:23:37,420
这是超级简单和方便的 

516
00:23:37,420 --> 00:23:40,570
但这里的直升机停留在一个地方 

517
00:23:40,570 --> 00:23:43,630
而相机总是永远停留在一个地方 

518
00:23:43,630 --> 00:23:50,890
那么我们要移动背景图像吗 就像我们

519
00:23:50,890 --> 00:23:54,070
在Flappy Bird的Love2D实现中 

520
00:23:54,070 --> 00:23:55,930
我们在哪里重置它的位置？

521
00:23:55,930 --> 00:23:57,610
答案是--

522
00:23:57,610 --> 00:24:03,170
我现在就在场景中播放它 让你自己决定 

523
00:24:03,170 --> 00:24:04,940
那么让我们去窗口吧 

524
00:24:04,940 --> 00:24:06,322
我要去排练了 

525
00:24:06,322 --> 00:24:08,280
所以我喜欢二乘三 就像我之前说的 

526
00:24:08,280 --> 00:24:14,080
这样你就可以同时看到现场和比赛的实况 

527
00:24:14,080 --> 00:24:16,870
我要在场景中移动我的相机 这样我就

528
00:24:16,870 --> 00:24:21,680
从后面看这个 

529
00:24:21,680 --> 00:24:26,460
然后我要玩这个游戏 

530
00:24:26,460 --> 00:24:29,750
[音乐播放]

531
00:24:29,750 --> 00:24:32,770
但就是这样 

532
00:24:32,770 --> 00:24:37,090
这就是我们--我要把它按住不动 

533
00:24:37,090 --> 00:24:40,570
那么 我们认为正在发生什么呢？

534
00:24:40,570 --> 00:24:42,280
我们的东西看起来像是在动吗？

535
00:24:42,280 --> 00:24:43,238
还是原地踏步？

536
00:24:46,720 --> 00:24:48,910
它正按兵不动 

537
00:24:48,910 --> 00:24:52,940
你能猜到我们是怎么做到这一点的吗？

538
00:24:52,940 --> 00:24:54,670
改变纹理 

539
00:24:54,670 --> 00:24:58,120
我们正在滚动它的纹理 

540
00:24:58,120 --> 00:25:01,540
因此 当您将纹理应用到3D表面时 

541
00:25:01,540 --> 00:25:08,880
将纹理坐标映射到对象的3D坐标

542
00:25:08,880 --> 00:25:09,880
您想要渲染的 

543
00:25:09,880 --> 00:25:11,134
这称为UV贴图 

544
00:25:11,134 --> 00:25:14,050
他们称它为紫外线 因为通常 当你处理3D对象时 

545
00:25:14,050 --> 00:25:15,340
你有你的x y z 

546
00:25:15,340 --> 00:25:18,670
然后你想把你的纹理和3D物体分开考虑 

547
00:25:18,670 --> 00:25:21,520
所以你用u v代替x y 因为你已经有了x y z

548
00:25:21,520 --> 00:25:22,810
为您的3D对象分配的 

549
00:25:27,840 --> 00:25:32,500
基本上 纹理有一个偏置的部分--

550
00:25:32,500 --> 00:25:34,340
保持纹理的材料--

551
00:25:34,340 --> 00:25:39,040
有一个将重新定位UV贴图的偏移字段

552
00:25:39,040 --> 00:25:43,160
在3D表面上的纹理 

553
00:25:43,160 --> 00:25:47,680
当你抵消它的时候 它就会自己包裹起来 

554
00:25:47,680 --> 00:25:49,070
如果这有任何意义的话 

555
00:25:49,070 --> 00:25:51,054
所以我们要做的就是--

556
00:25:51,054 --> 00:25:53,540
我可以在代码中告诉你这是什么地方 

557
00:25:53,540 --> 00:25:55,990
这一点将在讲座结束时提到 

558
00:25:55,990 --> 00:26:01,300
但我们这里有滚动背景组件 

559
00:26:01,300 --> 00:26:06,070
每种材质上都有一个叫做纹理偏移量的东西 

560
00:26:06,070 --> 00:26:10,240
这基本上会将纹理的UV贴图移动到3D对象 

561
00:26:10,240 --> 00:26:14,740
因此 通过将纹理偏移量设置为某个值偏移量 

562
00:26:14,740 --> 00:26:17,740
这与我们以前所做的非常相似 

563
00:26:17,740 --> 00:26:21,370
请注意 偏移量是滚动速度乘以时间--

564
00:26:21,370 --> 00:26:23,424
在本例中 指的是时间 

565
00:26:23,424 --> 00:26:26,340
我的意思并不是一定要用这里的所有细节来淹没 

566
00:26:26,340 --> 00:26:29,980
但更大的图景是 我们正在花时间--

567
00:26:29,980 --> 00:26:33,430
自游戏开始以来的时间量--

568
00:26:33,430 --> 00:26:36,460
我们有一些我们预先设定的滚动速度 

569
00:26:36,460 --> 00:26:40,180
我们可以在这里滚动纹理偏移量 

570
00:26:40,180 --> 00:26:41,770
我们只是把它放在这里的x 

571
00:26:41,770 --> 00:26:44,290
所以这个新的向量2 偏移量0--

572
00:26:44,290 --> 00:26:46,320
把这两个想象成x和y--

573
00:26:46,320 --> 00:26:47,830
向量2 向量3 

574
00:26:47,830 --> 00:26:50,060
向量只是数字的组合 

575
00:26:50,060 --> 00:26:52,720
所以1 2 3 4--你想要多少都行 

576
00:26:52,720 --> 00:26:55,240
0中的向量2偏移 

577
00:26:55,240 --> 00:26:57,370
所以我们不想在y轴上滚动 

578
00:26:57,370 --> 00:26:59,020
我们只想从左向右滚动 

579
00:26:59,020 --> 00:27:03,100
因此 我们将不对y轴应用纹理偏移 

580
00:27:03,100 --> 00:27:06,700
但我们希望将纹理偏移量应用于x轴 

581
00:27:06,700 --> 00:27:09,220
这就是他们的偏移量 

582
00:27:09,220 --> 00:27:11,140
我也把它包括在这里--

583
00:27:11,140 --> 00:27:13,960
请注意 存在凹凸贴图纹理偏移 

584
00:27:13,960 --> 00:27:16,050
实际上 我们的纹理上没有凹凸贴图 

585
00:27:16,050 --> 00:27:17,650
所以凹凸贴图是有效的--

586
00:27:17,650 --> 00:27:21,730
我也许能为它找到一张好的谷歌图片 

587
00:27:21,730 --> 00:27:23,360
如果您不熟悉凹凸贴图 

588
00:27:25,915 --> 00:27:26,665
让我进去吧 

589
00:27:30,050 --> 00:27:35,240
我希望Google Images上没有可疑的图片 而是一个Bump

590
00:27:35,240 --> 00:27:37,010
地图--

591
00:27:37,010 --> 00:27:37,710
我们能看看吗？

592
00:27:37,710 --> 00:27:41,110
嗯 这有点难说 

593
00:27:41,110 --> 00:27:46,640
但在许多3D游戏中 你会看到像是凹凸不平和闪闪发光

594
00:27:46,640 --> 00:27:47,960
在曲面上 

595
00:27:47,960 --> 00:27:51,050
这在很大程度上是通过使用凹凸贴图实现的 

596
00:27:51,050 --> 00:27:55,010
因为很明显 如果你要模拟每一个微小的凸起或模型

597
00:27:55,010 --> 00:27:59,390
在曲面中 渲染大型对象将变得极其困难 

598
00:27:59,390 --> 00:28:02,990
因为你看到的是一个曲面的数千个多边形

599
00:28:02,990 --> 00:28:06,440
这实际上在一场比赛中是如此详细 

600
00:28:06,440 --> 00:28:09,290
所以你要做的是 你拿出所谓的凹凸贴图 

601
00:28:09,290 --> 00:28:11,570
而凹凸贴图得到了--

602
00:28:11,570 --> 00:28:18,350
在照明过程中 它将有效地倾斜3D网格的曲面法线 

603
00:28:18,350 --> 00:28:23,840
因此 它将有效地假装您的3D网格中有一堆凹凸

604
00:28:23,840 --> 00:28:26,390
用来照明 

605
00:28:26,390 --> 00:28:27,350
只是为了照明 

606
00:28:27,350 --> 00:28:32,540
所以当它变亮 变暗时 它看起来就像是颠簸的 

607
00:28:32,540 --> 00:28:35,030
但你仍然在处理一个完全平坦 完全平坦的

608
00:28:35,030 --> 00:28:39,650
在这种情况下是简单的立方体网格 或者任何你想要的网格 

609
00:28:39,650 --> 00:28:43,027
所以长话短说 这里 如果你

610
00:28:43,027 --> 00:28:45,860
想要在想要滚动的任何表面上包含凹凸贴图 

611
00:28:45,860 --> 00:28:47,720
或者 如果要编辑凹凸贴图 请执行此操作

612
00:28:47,720 --> 00:28:52,110
只是因为您还可以操纵凹凸贴图纹理偏移 

613
00:28:52,110 --> 00:28:58,130
它是一个包含在材料中的字段 

614
00:28:58,130 --> 00:29:02,770
那么 对于这项工作是如何运作的 有什么问题吗？

615
00:29:02,770 --> 00:29:06,230
在我们进入更多细节之前 我们还有很多内容要谈 

616
00:29:06,230 --> 00:29:11,310
但从概念上讲 我们了解这种工作原理吗？

617
00:29:11,310 --> 00:29:12,480
好的?

618
00:29:12,480 --> 00:29:12,980
凉爽的 

619
00:29:12,980 --> 00:29:14,271
所以让我们回到幻灯片上 

620
00:29:18,390 --> 00:29:18,890
正确的 

621
00:29:18,890 --> 00:29:20,473
所以我们谈论的是游戏物品 

622
00:29:20,473 --> 00:29:25,890
因此 我们之前看到的所有东西都只是游戏对象 

623
00:29:25,890 --> 00:29:32,120
让我们回到默认布局 然后我们可以回顾我们的场景 

624
00:29:32,120 --> 00:29:33,380
这就是我们的场景 

625
00:29:33,380 --> 00:29:36,120
所有这些东西都是我们的游戏对象 

626
00:29:36,120 --> 00:29:38,300
这些归根结底都是容器 

627
00:29:38,300 --> 00:29:39,990
我在之前的一堂课中谈到了这一点 

628
00:29:39,990 --> 00:29:43,820
但这是实体组件系统的开始 在这种情况下 

629
00:29:43,820 --> 00:29:45,600
这些游戏对象是我们的实体 

630
00:29:45,600 --> 00:29:47,510
它们是实体类--

631
00:29:47,510 --> 00:29:50,240
容器类--用于驱动行为的类 

632
00:29:50,240 --> 00:29:55,610
而让我们真正了解有趣行为的是

633
00:29:55,610 --> 00:29:59,400
这种抽象的一种就是使用组件 

634
00:29:59,400 --> 00:30:01,130
我们会讨论这个问题的 

635
00:30:01,130 --> 00:30:05,150
所以组件是所有在右边的东西 

636
00:30:05,150 --> 00:30:07,740
默认情况下使用Unity编辑器 

637
00:30:07,740 --> 00:30:09,894
例如 如果我们看着我们的相机 

638
00:30:09,894 --> 00:30:12,060
我们来看看右边的所有这些东西 

639
00:30:12,060 --> 00:30:14,660
我们可以看到我们有一种叫做变换的东西 

640
00:30:14,660 --> 00:30:16,550
我们有一种叫相机的东西 

641
00:30:16,550 --> 00:30:19,060
已弃用的图形用户界面层 因此这是默认设置 

642
00:30:19,060 --> 00:30:21,750
它是从以前版本的Unity导入的 

643
00:30:21,750 --> 00:30:23,635
所以你真的可以删除它 

644
00:30:23,635 --> 00:30:26,110
一层耀光层 我们没有用到 

645
00:30:26,110 --> 00:30:29,210
音频监听器--我相信默认情况下所有摄像头都有这个功能 

646
00:30:29,210 --> 00:30:30,910
不过 如果你真的想用它 

647
00:30:30,910 --> 00:30:33,410
音频监听器和音频源 

648
00:30:33,410 --> 00:30:37,120
所以所有这些不同的部件都是部件 

649
00:30:37,120 --> 00:30:40,670
它们是驱动这个游戏对象的行为的原因 

650
00:30:40,670 --> 00:30:43,840
我们可以只创建一个全新的、空的游戏对象--哦 

651
00:30:43,840 --> 00:30:45,380
我还是个孩子的时候就创造了 

652
00:30:45,380 --> 00:30:48,720
我们可以在这里创建一个全新的、空的游戏对象 

653
00:30:48,720 --> 00:30:51,380
它只是我们场景中的一个游戏对象 

654
00:30:51,380 --> 00:30:55,430
它就是我们的鼠标所在的地方 

655
00:30:55,430 --> 00:30:56,810
嗯 就在这里 

656
00:30:56,810 --> 00:30:59,100
但它什么也做不了 

657
00:30:59,100 --> 00:31:01,130
它只有一个组成部分 

658
00:31:01,130 --> 00:31:03,704
而这个组件就是变换 

659
00:31:03,704 --> 00:31:05,120
有人猜猜什么是变身吗？

660
00:31:08,850 --> 00:31:09,350
嗯 

661
00:31:09,350 --> 00:31:11,810
观众：那是位置、旋转、比例等等吗？

662
00:31:11,810 --> 00:31:12,560
科尔顿·奥格登：是的 

663
00:31:12,560 --> 00:31:16,580
它是游戏对象的位置、旋转和比例 

664
00:31:16,580 --> 00:31:20,120
以前放在六个领域的东西--

665
00:31:20,120 --> 00:31:22,940
或者在这种情况下 可能是九个字段 或者可能是

666
00:31:22,940 --> 00:31:29,570
三个子字段 现在是一个我们可以随意修改的对象 

667
00:31:29,570 --> 00:31:32,960
嗯 这是一个我们可以随意修改的组件 

668
00:31:32,960 --> 00:31:36,380
所以如果我这样做--注意 我只是滚动x 

669
00:31:36,380 --> 00:31:40,520
它只是移动那个变换 也就是那个物体的位置 

670
00:31:40,520 --> 00:31:44,150
Unity知道要观察变换分量 

671
00:31:44,150 --> 00:31:47,720
并根据其变换所在的位置渲染我们的对象 

672
00:31:47,720 --> 00:31:51,320
而不是我们必须手动设置所有这些东西 我们仍然

673
00:31:51,320 --> 00:31:52,760
可以在代码中做什么 

674
00:31:52,760 --> 00:31:55,460
我们只需在Unity编辑器中修改它们即可

675
00:31:55,460 --> 00:31:57,500
直接通过图形界面 

676
00:31:57,500 --> 00:32:01,260
这只是一个有趣的、有用的抽象层 

677
00:32:01,260 --> 00:32:05,344
因此 变换是一个组件--在本例中是一个照相机 

678
00:32:05,344 --> 00:32:06,260
这只是一个组件 

679
00:32:06,260 --> 00:32:09,900
我们可以把它连接到任何我们想要的东西上 它就变成了一个相机 

680
00:32:09,900 --> 00:32:13,340
然后我们可以将其设置为默认摄像头或非默认摄像头 

681
00:32:13,340 --> 00:32:15,550
相机有一堆不同的东西 

682
00:32:15,550 --> 00:32:18,710
我不能说我知道每个物体的所有领域

683
00:32:18,710 --> 00:32:21,320
在团结中 因为有太多的东西 

684
00:32:21,320 --> 00:32:24,830
但清晰的旗帜 背景 扑杀面具--

685
00:32:24,830 --> 00:32:29,490
所有这些与相机如何工作相关的东西--

686
00:32:29,490 --> 00:32:31,550
这些都是我们拥有完全访问权限的东西

687
00:32:31,550 --> 00:32:32,716
到这里 在Unity编辑器中 

688
00:32:32,716 --> 00:32:36,564
我们甚至不需要接触代码 真的 很多事情 

689
00:32:36,564 --> 00:32:38,480
一个有趣的有趣的事情 我们可以看一看

690
00:32:38,480 --> 00:32:43,590
如果我们去布局--回到两个三个 看看我们的比赛

691
00:32:43,590 --> 00:32:44,090
再来一次 

692
00:32:44,090 --> 00:32:51,140
所以我们的摄像机现在正看着屏幕 

693
00:32:51,140 --> 00:32:52,570
只是它总是在一个地方 

694
00:32:52,570 --> 00:32:55,790
它有一种投射场景的方式 

695
00:32:55,790 --> 00:32:57,080
它可以做两件事中的一件 

696
00:32:57,080 --> 00:33:03,020
它可以是透视投影或正交投影 

697
00:33:03,020 --> 00:33:08,760
有人知道这两者之间的区别吗 至少在视觉上是这样？

698
00:33:08,760 --> 00:33:11,520
所以透视投影--它的作用是什么

699
00:33:11,520 --> 00:33:15,570
它是模拟真实的相机 真实的镜头 人眼 等等 

700
00:33:15,570 --> 00:33:17,790
在现实生活中举止得体 

701
00:33:17,790 --> 00:33:19,350
事情会有一点扭曲 

702
00:33:19,350 --> 00:33:22,290
所以你看到的东西 取决于你看它们的角度 

703
00:33:22,290 --> 00:33:27,150
它们看起来更宽或倾斜 并不完全是几何形状 

704
00:33:27,150 --> 00:33:31,320
就像你把它们画在一定的距离上一样 

705
00:33:31,320 --> 00:33:34,359
事物有消失点 等等 

706
00:33:34,359 --> 00:33:36,150
正字法--情况看起来有很大不同 

707
00:33:36,150 --> 00:33:40,230
所以立即注意 所以我们可以在这里看到 透视

708
00:33:40,230 --> 00:33:44,550
我们的直升机在视觉上并没有太大的改变 

709
00:33:44,550 --> 00:33:46,980
随着背景的变化 事情确实会有一点变化 

710
00:33:46,980 --> 00:33:50,420
因为两者的视角是不同的 

711
00:33:50,420 --> 00:33:52,440
透视和正射相机 

712
00:33:52,440 --> 00:33:55,790
但如果我们把这个做大一点 

713
00:33:55,790 --> 00:33:59,210
所以我要像这样增加大小 

714
00:34:02,550 --> 00:34:05,251
然后我就去打球 

715
00:34:05,251 --> 00:34:06,250
有一件事我们会注意到--

716
00:34:06,250 --> 00:34:10,150
人们注意到的第一件事是什么？

717
00:34:10,150 --> 00:34:14,620
你实际上可以看到顶部和底部之间的差异 

718
00:34:14,620 --> 00:34:16,770
哇哦 

719
00:34:16,770 --> 00:34:20,840
尤其是 我会把你们的注意力放在建筑物上 

720
00:34:20,840 --> 00:34:22,209
这些建筑有什么不同？

721
00:34:22,209 --> 00:34:23,889
观众：你看不到侧面 

722
00:34:23,889 --> 00:34:27,590
科尔顿·奥格登：你再也看不到那一面了 

723
00:34:27,590 --> 00:34:30,790
镜头有点弯曲 

724
00:34:30,790 --> 00:34:34,880
所以我并不完全熟悉其中涉及的所有数学知识 

725
00:34:34,880 --> 00:34:38,500
但归根结底 用透视相机 

726
00:34:38,500 --> 00:34:40,300
你实际上可以用距离来衡量事物

727
00:34:40,300 --> 00:34:42,091
相对彼此来说要好一点 

728
00:34:42,091 --> 00:34:45,170
有了正射相机 一切都是完全平坦的 

729
00:34:45,170 --> 00:34:47,739
不管它离你有多远

730
00:34:47,739 --> 00:34:51,040
在与你完全垂直的通道上 

731
00:34:51,040 --> 00:34:53,090
它看起来会一模一样 

732
00:34:53,090 --> 00:34:55,570
因此 无论距离有多远 这些建筑看起来都是一样的

733
00:34:55,570 --> 00:34:57,611
无论他们在哪个位置 他们都在远方 

734
00:34:57,611 --> 00:35:00,700
因为一切都是完全平淡的 

735
00:35:00,700 --> 00:35:06,230
并且以不同的方式计算视图矩阵 

736
00:35:06,230 --> 00:35:09,010
因此 只需一个简单的按钮 您就可以

737
00:35:09,010 --> 00:35:12,131
彻底改变您的游戏外观 

738
00:35:12,131 --> 00:35:13,630
你可能看过很多比赛 

739
00:35:13,630 --> 00:35:17,320
我相信Crossy Road所有的东西都是用正射相机做的 

740
00:35:17,320 --> 00:35:18,970
而不是透视相机 

741
00:35:18,970 --> 00:35:21,430
它有一个非常独特的外观 特别是

742
00:35:21,430 --> 00:35:23,920
一旦你稍微歪曲了一些东西 

743
00:35:23,920 --> 00:35:26,492
但这只是你可以改变的一件事

744
00:35:26,492 --> 00:35:28,450
而不需要接触一行代码--

745
00:35:28,450 --> 00:35:32,114
仅仅通过摄像头的实现 你的游戏看起来是什么样子 

746
00:35:32,114 --> 00:35:33,655
让我们把事情回到原来的样子 

747
00:35:36,066 --> 00:35:38,190
而且还有很多东西 比如视野 

748
00:35:38,190 --> 00:35:40,064
因此 如果你想更多地了解游戏世界 

749
00:35:40,064 --> 00:35:42,730
所以像在地震和其他射击游戏中 

750
00:35:42,730 --> 00:35:46,210
您可以更改此视图 通常是在您的菜单设置中

751
00:35:46,210 --> 00:35:49,180
这样你就能看到你周围更多的东西 

752
00:35:49,180 --> 00:35:51,490
它看起来有点像鱼眼镜头 

753
00:35:51,490 --> 00:35:52,615
这要看你怎么做了 

754
00:35:52,615 --> 00:35:55,761
这只是透视投影的更大扭曲 

755
00:35:58,640 --> 00:35:59,140
嗯 

756
00:35:59,140 --> 00:36:00,760
所有这些东西 他们都有--

757
00:36:00,760 --> 00:36:03,260
我不知道他们中的每一个人都做了什么 

758
00:36:03,260 --> 00:36:05,669
只是因为牵涉的太多了 

759
00:36:05,669 --> 00:36:07,960
一般来说 你不需要太多地摆弄它 

760
00:36:07,960 --> 00:36:11,290
这最终取决于你在游戏中想要实现的目标 

761
00:36:11,290 --> 00:36:14,212
最后 您将找到该编辑器的特定区域

762
00:36:14,212 --> 00:36:16,420
以及代码库和文档的特定区域

763
00:36:16,420 --> 00:36:18,190
你会深深地投入其中 

764
00:36:18,190 --> 00:36:23,500
但这基本上是组件为您提供的功能 

765
00:36:23,500 --> 00:36:26,680
当您创建组件并将其附加到游戏对象时 

766
00:36:26,680 --> 00:36:29,770
你不仅可以很容易地将不同的东西组合在一起

767
00:36:29,770 --> 00:36:33,640
创造这种新兴的新行为和组合

768
00:36:33,640 --> 00:36:36,130
游戏对象的行为 

769
00:36:36,130 --> 00:36:40,990
但Unity允许您通过不同的组件编程方式 

770
00:36:40,990 --> 00:36:45,100
要修改它们 取决于您希望它们的可定制化程度 

771
00:36:45,100 --> 00:36:46,660
在编辑器本身中 

772
00:36:46,660 --> 00:36:49,639
因此 您不必在代码中触及任何这些内容 

773
00:36:49,639 --> 00:36:51,430
您只需进入编辑器并快速

774
00:36:51,430 --> 00:36:55,870
因为您对所有组件进行建模的方式 所以可以加快速度 

775
00:36:55,870 --> 00:36:58,060
所以我们看到了其他东西 比如音频监听器 

776
00:36:58,060 --> 00:37:01,300
音频收听者是字面上会收听音频的东西 

777
00:37:01,300 --> 00:37:04,360
然后像麦克风一样回放给游戏玩家 

778
00:37:04,360 --> 00:37:07,030
那么音频源就是实际的音频源 

779
00:37:07,030 --> 00:37:09,670
因此它将在该位置播放该音频

780
00:37:09,670 --> 00:37:11,530
不管那个游戏对象是什么 

781
00:37:11,530 --> 00:37:13,300
所以我们把所有这些都结合起来了 

782
00:37:13,300 --> 00:37:17,320
所以现在我们有了一个可以投射一切的摄像机

783
00:37:17,320 --> 00:37:19,990
使用透视投影 

784
00:37:19,990 --> 00:37:24,090
它是一个音频监听器 所以它将在我们的场景中监听音频 

785
00:37:24,090 --> 00:37:29,440
它还将播放音频源并自我监听 

786
00:37:29,440 --> 00:37:30,750
而这仅仅是个开始 

787
00:37:30,750 --> 00:37:32,896
我们还有一大堆其他组件

788
00:37:32,896 --> 00:37:35,020
在这里 我们可以很快地看一看 

789
00:37:35,020 --> 00:37:39,902
因此 平行光具有光分量 

790
00:37:39,902 --> 00:37:41,860
所以一盏灯 你可以做各种各样的事情 

791
00:37:41,860 --> 00:37:44,660
你可以制作聚光灯、平行光、点光源 

792
00:37:44,660 --> 00:37:46,787
所有这些看起来都有一点不同 

793
00:37:46,787 --> 00:37:48,370
你可以让它有一种特定的颜色 

794
00:37:48,370 --> 00:37:53,650
所以 如果你想要一个非常黑暗的场景 你可以有一个黑暗的灯光 

795
00:37:53,650 --> 00:37:57,820
或者你甚至可以用橙色的灯光来模仿黎明或黄昏 

796
00:37:57,820 --> 00:38:01,126
这就是你要做的事情 

797
00:38:01,126 --> 00:38:04,000
你可以烘焙你的灯光 这意味着你只需预先计算它 

798
00:38:04,000 --> 00:38:06,000
这样你就不必实时渲染它了

799
00:38:06,000 --> 00:38:07,619
当你在硬件上播放它的时候 

800
00:38:07,619 --> 00:38:09,910
很多不同的东西 很多不同的背景 

801
00:38:09,910 --> 00:38:11,890
我们不一定有时间深入研究所有这些问题 

802
00:38:11,890 --> 00:38:13,750
但纵观所有这些 你可以

803
00:38:13,750 --> 00:38:17,980
看 所有这些游戏对象都是这些组件的组合 

804
00:38:17,980 --> 00:38:24,070
而这些组件的组合是行为的原因

805
00:38:24,070 --> 00:38:25,540
我们在游戏中得到的东西 

806
00:38:25,540 --> 00:38:29,500
这就是团结的终极本质 以及它是如何做到这一点的 

807
00:38:29,500 --> 00:38:32,480
为了说明不同之处 我们以前讨论过这一点 

808
00:38:32,480 --> 00:38:35,442
这是一条继承链 Monster

809
00:38:35,442 --> 00:38:38,650
继承自生物 然后传给地精 地精酋长 精英地精

810
00:38:38,650 --> 00:38:39,250
头儿 

811
00:38:39,250 --> 00:38:42,850
在Unity中 您可以创建一个游戏对象 

812
00:38:42,850 --> 00:38:47,330
然后给它一个生物组件 一个妖精组件 一个巡逻组件--

813
00:38:47,330 --> 00:38:47,830
对吗？

814
00:38:47,830 --> 00:38:52,110
所以也许你想要不同的东西去巡逻 

815
00:38:52,110 --> 00:38:53,860
在联合行动中 情况会有些复杂 

816
00:38:53,860 --> 00:38:57,760
但你基本上可以创建一条路径 

817
00:38:57,760 --> 00:39:02,030
然后让你的实体在特定的时间遵循这条路径 

818
00:39:02,030 --> 00:39:04,030
然后 根据你是如何编程的 

819
00:39:04,030 --> 00:39:07,670
您可以在编辑器中指定所有这些不同的特征 

820
00:39:07,670 --> 00:39:09,520
所以你可以在编辑上说 好的 我

821
00:39:09,520 --> 00:39:12,100
我要你从这个靶场巡逻到这个靶场 

822
00:39:12,100 --> 00:39:15,610
我想让你们在这段时间里 暂停这么长时间--

823
00:39:15,610 --> 00:39:16,110
对吗？

824
00:39:16,110 --> 00:39:18,318
然后你可以把它赋予你场景中的任何东西 

825
00:39:18,318 --> 00:39:21,040
如果你想的话你可以组织一次照相巡逻 

826
00:39:21,040 --> 00:39:24,540
然后将其作为游戏开始时的演示代码 

827
00:39:24,540 --> 00:39:26,520
这种灵活性简直是疯了 

828
00:39:26,520 --> 00:39:27,341
精英成分 

829
00:39:27,341 --> 00:39:27,840
对吗？

830
00:39:27,840 --> 00:39:31,410
如果你想 也许 某些敌人或某些物体 如果他们是精英 

831
00:39:31,410 --> 00:39:32,410
也许它们闪耀着光芒 

832
00:39:32,410 --> 00:39:34,451
也许他们丢掉了更多的经验之类的东西 

833
00:39:34,451 --> 00:39:38,130
一个主要组成部分可能比一个非主要组成部分拥有更好的武器 

834
00:39:38,130 --> 00:39:41,190
然后是一种有毒成分 可能是敌人 当它死亡时 

835
00:39:41,190 --> 00:39:46,410
它把有毒气体或有毒液体喷得到处都是 

836
00:39:46,410 --> 00:39:48,000
但灵活性是存在的 

837
00:39:48,000 --> 00:39:52,470
您可以将任何组件归于任何对象以获得任何类型的行为

838
00:39:52,470 --> 00:39:53,240
这是你想要的 

839
00:39:53,240 --> 00:39:56,139
当然 实现所有这些组件都是您的责任 对吗？

840
00:39:56,139 --> 00:39:57,930
你不会免费得到所有这些的 

841
00:39:57,930 --> 00:39:59,388
你会免费得到很多东西 

842
00:39:59,388 --> 00:40:04,360
Unity为您提供了大量组件--非常好的组件 

843
00:40:04,360 --> 00:40:07,886
但你最终需要对你的游戏逻辑进行编程 

844
00:40:07,886 --> 00:40:10,260
因此 你将不得不实施所有这些东西--精英 

845
00:40:10,260 --> 00:40:12,660
妖精 成为所有这些东西意味着什么 

846
00:40:12,660 --> 00:40:15,690
但值得庆幸的是 这并不是非常痛苦 

847
00:40:15,690 --> 00:40:19,800
我们做这一切的方式--顺便说一句 

848
00:40:19,800 --> 00:40:23,100
到目前为止 对于Unity的模型如何工作 有什么问题吗 

849
00:40:23,100 --> 00:40:25,350
组合和遗传之间的区别 

850
00:40:25,350 --> 00:40:28,830
到目前为止我们还谈过什么吗？

851
00:40:28,830 --> 00:40:30,510
好的 

852
00:40:30,510 --> 00:40:35,250
我们制造自己的组件的实际方式 

853
00:40:35,250 --> 00:40:38,655
这可能是你大部分时间都在做的事情 

854
00:40:38,655 --> 00:40:41,280
至少在一开始 当你在引导你的游戏时 

855
00:40:41,280 --> 00:40:45,900
正在对所谓的单一行为进行编程 

856
00:40:45,900 --> 00:40:48,610
所以我们之前谈到了Mono 

857
00:40:48,610 --> 00:40:52,980
因此 Mono是CLR的开源实现 

858
00:40:52,980 --> 00:40:54,271
而MonoBehaviour 我想--

859
00:40:54,271 --> 00:40:56,520
我试着查了查 看看它是从哪里来的 

860
00:40:56,520 --> 00:41:03,120
我想这是因为它最初是Mac独家的项目 Unity 

861
00:41:03,120 --> 00:41:05,910
因此 因为一切都是在Mono中实现的 

862
00:41:05,910 --> 00:41:11,070
因为这就是它的脚本编写方式 MonoBehaviour成为了这个名字 

863
00:41:11,070 --> 00:41:14,640
但单一行为才是组件 

864
00:41:14,640 --> 00:41:16,340
它们实际上是一模一样的 

865
00:41:16,340 --> 00:41:18,048
不同的是 单一行为

866
00:41:18,048 --> 00:41:19,620
它是如何用代码来说明的 

867
00:41:19,620 --> 00:41:23,700
在C#中 如果您想要将某物编程为组件 则可以

868
00:41:23,700 --> 00:41:28,380
附加到游戏对象 它需要从MonoBehaviour继承 

869
00:41:31,620 --> 00:41:37,260
所以如果我们去硬币产生者网站 这里 

870
00:41:37,260 --> 00:41:40,080
您可以看到Unity内置的组件之间的区别

871
00:41:40,080 --> 00:41:42,660
你自己的途径是什么--

872
00:41:42,660 --> 00:41:44,230
它会在这里写剧本 

873
00:41:44,230 --> 00:41:46,950
所以在这种情况下 我有一个硬币产生器对象 对吗？

874
00:41:46,950 --> 00:41:51,090
它只是一个空物体 至少就它显示的内容而言是这样 

875
00:41:51,090 --> 00:41:53,410
它有一个转变 这是无关紧要的 

876
00:41:53,410 --> 00:41:56,610
它可能在我们整个场景中的任何地方 

877
00:41:56,610 --> 00:42:00,240
这和空洞的游戏唯一的区别是

878
00:42:00,240 --> 00:42:04,260
我们之前看到的物体是它有一个硬币产生器 

879
00:42:04,260 --> 00:42:10,590
而这个硬币产生器在这里有一个东西 

880
00:42:10,590 --> 00:42:14,700
您添加的所有组件都将在此处显示此脚本字段 

881
00:42:14,700 --> 00:42:17,070
只是想让你知道这就是剧本

882
00:42:17,070 --> 00:42:19,560
从获取它的代码行为 

883
00:42:19,560 --> 00:42:25,350
但是 我们这里有一个叫做预制板的领域 它的大小是1 

884
00:42:25,350 --> 00:42:29,850
它实际上是根据有多少元素来计算的

885
00:42:29,850 --> 00:42:32,610
它负责的名单上有 

886
00:42:32,610 --> 00:42:35,110
正如它所说 我们这里有一个元素 

887
00:42:35,110 --> 00:42:38,667
它有一个预制的硬币 就在这里 

888
00:42:38,667 --> 00:42:40,000
注意 我点击了它 

889
00:42:40,000 --> 00:42:42,435
它把我带到了我的资产中 

890
00:42:42,435 --> 00:42:45,060
所以预制板和所有这些--这意味着什么 以及如何获得

891
00:42:45,060 --> 00:42:47,460
这一切都在起作用--我们会讨论这个 

892
00:42:47,460 --> 00:42:54,660
但是我们的代码库中必须存在一个催生硬币的脚本

893
00:42:54,660 --> 00:42:58,440
然后我们才能真正将其添加到任何游戏对象中 对吗？

894
00:42:58,440 --> 00:43:02,610
所以在我的项目中 我确实有--

895
00:43:02,610 --> 00:43:06,870
通常 您有资源 在您的Unity项目中有一个名为Assets的文件夹 

896
00:43:06,870 --> 00:43:09,240
然后我通常会创建一个Resources文件夹 

897
00:43:09,240 --> 00:43:12,070
你这样做并不是强制性的 但只是为了组织 我会

898
00:43:12,070 --> 00:43:14,442
创建一个资源 

899
00:43:14,442 --> 00:43:17,400
然后我会有一大堆文件夹来存放各种不同的东西

900
00:43:17,400 --> 00:43:18,358
就像我们以前做过的那样 

901
00:43:18,358 --> 00:43:21,180
在Love2D项目中 在父级 

902
00:43:21,180 --> 00:43:27,750
你有一个字体 一个音乐或声音 然后是一个源代码目录 

903
00:43:27,750 --> 00:43:30,510
在本例中 我们有字体、材料、型号、

904
00:43:30,510 --> 00:43:33,120
我们在游戏中需要的所有不同的资产 

905
00:43:33,120 --> 00:43:35,040
而且还有一个脚本文件夹 

906
00:43:35,040 --> 00:43:41,970
以及我们将在所有组件中使用的所有C#脚本--

907
00:43:41,970 --> 00:43:43,470
我们所有的游戏物品 

908
00:43:43,470 --> 00:43:46,020
所以你可以很容易地去任何一个地方 

909
00:43:46,020 --> 00:43:50,910
而不必进入您的操作系统 打开一个新窗口 

910
00:43:50,910 --> 00:43:53,790
找到您的文件 然后浏览所有文件

911
00:43:53,790 --> 00:43:56,910
这种团结为你创造了 这可能是一种痛苦 

912
00:43:56,910 --> 00:43:59,940
例如 你只需双击一个硬币脚本即可 

913
00:43:59,940 --> 00:44:02,640
它将在您的默认编辑器中打开 

914
00:44:02,640 --> 00:44:06,210
所以我只想在这里提到一件事

915
00:44:06,210 --> 00:44:08,850
就是 如果你转到你的统一偏好--

916
00:44:08,850 --> 00:44:11,002
在Mac上 它是统一 然后是首选项--

917
00:44:11,002 --> 00:44:12,210
您可以转到外部工具 

918
00:44:12,210 --> 00:44:15,510
因此 默认情况下 从2018年开始 Unity将过渡到

919
00:44:15,510 --> 00:44:19,649
来自它之前的IDE 称为MonoDeDevelopment 这是一个很好的IDE 

920
00:44:19,649 --> 00:44:21,690
他们正在摆脱这一点 他们

921
00:44:21,690 --> 00:44:26,970
使其专注于将Visual Studio作为默认的IDE 

922
00:44:26,970 --> 00:44:28,170
我不使用Visual Studio 

923
00:44:28,170 --> 00:44:29,580
我喜欢VS Code 

924
00:44:29,580 --> 00:44:33,000
所以我做的是--你能做的是--

925
00:44:33,000 --> 00:44:35,724
您可以在此处选择您的外部脚本编辑器 

926
00:44:35,724 --> 00:44:37,890
如果您更喜欢不同的脚本编辑器--比如Atom 

927
00:44:37,890 --> 00:44:40,330
或VS代码 或崇高文本 

928
00:44:40,330 --> 00:44:42,665
然后只需在您的文件系统上浏览它 

929
00:44:42,665 --> 00:44:44,790
无论您是在Windows、Linux还是Mac机器上 

930
00:44:44,790 --> 00:44:47,123
然后你可以很容易地选择你想要的文件 

931
00:44:47,123 --> 00:44:48,670
在这个例子中 我选择了VS Code 

932
00:44:48,670 --> 00:44:50,610
因此 无论何时 

933
00:44:50,610 --> 00:44:53,130
我在Unity中双击一个脚本 

934
00:44:53,130 --> 00:44:56,370
将实际打开IDE或文本编辑器

935
00:44:56,370 --> 00:45:00,630
我在Unity的偏好中分配给它 

936
00:45:00,630 --> 00:45:08,220
这里是我为这个例子创建的Coin组件 

937
00:45:08,220 --> 00:45:13,440
请注意 每个组件首先都是一个类 

938
00:45:13,440 --> 00:45:20,370
实际上 C#中的所有东西 就像Java中一样 都是一个类 

939
00:45:20,370 --> 00:45:21,790
这是公开课

940
00:45:21,790 --> 00:45:26,710
注意我把它命名为Coin 还有这个冒号 然后是MonoBehaviour 

941
00:45:26,710 --> 00:45:30,630
这个冒号 有人知道吗 有人猜猜冒号是什么意思吗？

942
00:45:30,630 --> 00:45:31,130
东尼？

943
00:45:31,130 --> 00:45:31,845
托尼：延伸 

944
00:45:31,845 --> 00:45:32,970
科尔顿·奥格登：延伸 是的 

945
00:45:32,970 --> 00:45:36,525
从MonoBehaviour扩展或继承 

946
00:45:36,525 --> 00:45:38,400
所以任何时候你有你想要的组件

947
00:45:38,400 --> 00:45:41,970
要创建 您需要将其添加到Unity 并允许您在编辑器中查看它 

948
00:45:41,970 --> 00:45:45,430
并允许你实际驱动一个对象的行为 

949
00:45:45,430 --> 00:45:47,670
你需要从MonoBehaviour继承 

950
00:45:47,670 --> 00:45:52,680
就像我的VS代码上说的 因为我有OmniSharp的扩展 

951
00:45:52,680 --> 00:45:55,410
它会告诉我MonoBehaviour是基类

952
00:45:55,410 --> 00:45:59,547
每个Unity脚本都是从它派生出来的 

953
00:45:59,547 --> 00:46:00,880
有几件事 

954
00:46:00,880 --> 00:46:03,450
注意我们有几个方法 

955
00:46:03,450 --> 00:46:10,320
所以void Start、void Update和void OnTriggerEnter 

956
00:46:10,320 --> 00:46:12,609
有人猜猜看是什么吗

957
00:46:12,609 --> 00:46:14,400
忽略OnTriggerEnter--有没有人

958
00:46:14,400 --> 00:46:16,784
猜猜启动和更新是做什么的？

959
00:46:16,784 --> 00:46:17,768
是啊

960
00:46:17,768 --> 00:46:21,220
“难道 这是真的吗？”陈小北问道 

961
00:46:21,220 --> 00:46:22,281
对不起 再说一遍 

962
00:46:22,281 --> 00:46:24,870
“难道 这只是一种猜测 还是一种猜测？”

963
00:46:24,870 --> 00:46:25,786
科尔顿·奥格登：没错 

964
00:46:25,786 --> 00:46:29,490
就像我们之前创建对象时一样

965
00:46:29,490 --> 00:46:35,220
在我们的Love 2D项目中 我们为每个类分配了一个init函数 

966
00:46:35,220 --> 00:46:37,250
以及分配给每个类的更新功能 

967
00:46:37,250 --> 00:46:39,090
我们自己也会这样称呼它们 

968
00:46:39,090 --> 00:46:44,070
每个MonoBehaviour都可以有一个Start方法 

969
00:46:44,070 --> 00:46:46,800
在这种情况下 它是空的 因为每次你

970
00:46:46,800 --> 00:46:50,190
用Unity编辑器创建一个新的脚本 它会自动--首先 

971
00:46:50,190 --> 00:46:53,390
它会自动为您创建一个全新的文件 

972
00:46:53,390 --> 00:46:55,530
这么说吧 我想创作一部新剧本 

973
00:46:55,530 --> 00:46:58,500
所以 如果我在联合编辑中 我去找我的资产--

974
00:46:58,500 --> 00:47:00,720
我右键单击Create(创建) 

975
00:47:00,720 --> 00:47:03,160
然后我想创建一个新的C#脚本 

976
00:47:03,160 --> 00:47:04,830
它会在那里创造它 

977
00:47:04,830 --> 00:47:06,480
我可以说 也许我希望这是--

978
00:47:06,480 --> 00:47:08,880
我不知道--测试组件 对吗？

979
00:47:11,430 --> 00:47:15,870
所以这应该有这样的效果 当我在我的VS代码中打开它时 

980
00:47:15,870 --> 00:47:18,330
这个测试组件--这是为我们自动生成的 

981
00:47:18,330 --> 00:47:20,340
我们不需要写任何这些样板文件 

982
00:47:20,340 --> 00:47:26,850
但默认情况下 您创建的每个脚本

983
00:47:26,850 --> 00:47:29,805
是一种单一行为 但严格来说 它并不是必须的 

984
00:47:29,805 --> 00:47:34,034
你可以创建一个你自己的类 也许你可以在幕后称之为它 

985
00:47:34,034 --> 00:47:36,450
或者 它可能只代表一个数据结构或其他什么 

986
00:47:36,450 --> 00:47:39,810
但默认情况下 每当您在Unity中创建新脚本时 

987
00:47:39,810 --> 00:47:43,200
这将使你省去手工打字的麻烦 

988
00:47:43,200 --> 00:47:48,380
它将为您提供一个空的Start方法和一个空的Update方法 

989
00:47:48,380 --> 00:47:53,130
因此 正如Tony所说 一旦对象被调用 就会调用Start方法

990
00:47:53,130 --> 00:47:55,980
它被赋值的对象被实例化 

991
00:47:55,980 --> 00:47:59,640
更确切地说 只要这个组件被实例化 

992
00:47:59,640 --> 00:48:03,750
通常情况下 它被实例化

993
00:48:03,750 --> 00:48:05,490
同时作为游戏对象 

994
00:48:05,490 --> 00:48:06,020
不总是这样 

995
00:48:06,020 --> 00:48:10,140
您可以即时创建游戏组件 

996
00:48:10,140 --> 00:48:12,535
但此Start方法将被调用 

997
00:48:12,535 --> 00:48:14,910
你放在这里的任何东西都会立即被召回 

998
00:48:14,910 --> 00:48:17,640
然后这个更新方法 统一将--每一帧 

999
00:48:17,640 --> 00:48:20,760
仔细检查每个实时游戏对象上的每个组件--

1000
00:48:20,760 --> 00:48:26,010
并将调用此更新函数中包含的代码 

1001
00:48:26,010 --> 00:48:28,140
而且你不需要自己在任何地方打这个电话 

1002
00:48:28,140 --> 00:48:34,410
只需将此组件分配给场景中的游戏对象 

1003
00:48:34,410 --> 00:48:38,460
你就可以得到更新 启动 以及所有其他功能 

1004
00:48:38,460 --> 00:48:40,110
免费送给你的

1005
00:48:40,110 --> 00:48:43,140
而MonoBehaviours实际上要复杂得多

1006
00:48:43,140 --> 00:48:48,190
而不仅仅是开始和更新 

1007
00:48:48,190 --> 00:48:56,650
如果你去MonoBehaviour 我们可以看到--

1008
00:48:56,650 --> 00:48:59,440
顺便说一句 我想大声说出Unity的文档 

1009
00:48:59,440 --> 00:49:01,780
Unity有惊人的文档--

1010
00:49:01,780 --> 00:49:02,790
docs.unity3d.com.

1011
00:49:02,790 --> 00:49:05,610
你会经历几乎所有

1012
00:49:05,610 --> 00:49:10,600
在Unity中实现的每一个对象 

1013
00:49:10,600 --> 00:49:12,886
一个很好的细节 有很多例子 

1014
00:49:12,886 --> 00:49:14,760
但在这里我们可以看到 仅仅在描述中 

1015
00:49:14,760 --> 00:49:23,010
它会告诉我们 MonoBehaviour将开始 更新 修复更新 延迟

1016
00:49:23,010 --> 00:49:26,859
更新 在GUI上--所有这些函数都为我们调用 假设

1017
00:49:26,859 --> 00:49:27,900
它们被实施了 

1018
00:49:27,900 --> 00:49:30,316
如果你不想的话 你可以不去执行它们 

1019
00:49:30,316 --> 00:49:32,469
如果不实施 它们就不会发生 

1020
00:49:32,469 --> 00:49:34,260
如果没有start方法 那就意味着

1021
00:49:34,260 --> 00:49:35,710
这个组件没有启动逻辑 

1022
00:49:35,710 --> 00:49:37,050
所以它不需要执行 

1023
00:49:37,050 --> 00:49:39,420
如果没有更新 也许它只需要从头开始 

1024
00:49:39,420 --> 00:49:41,760
但在那之后永远不会更新 不要实现更新 

1025
00:49:41,760 --> 00:49:44,880
和更新将不会被调用 

1026
00:49:44,880 --> 00:49:46,680
所有这些都是可选的 

1027
00:49:46,680 --> 00:49:48,570
这只是MonoBehaviour的一小部分 

1028
00:49:48,570 --> 00:49:51,540
因为你也有留言

1029
00:49:51,540 --> 00:49:56,610
所以消息是你覆盖的函数 

1030
00:49:56,610 --> 00:49:59,650
如你所见 有很多 

1031
00:49:59,650 --> 00:50:02,760
所有这些信息都会被调用 

1032
00:50:02,760 --> 00:50:04,770
发生在游戏场景中 

1033
00:50:04,770 --> 00:50:12,690
例如 OnTriggerEnter 如果我们的对象是一个触发器 我们输入它 

1034
00:50:12,690 --> 00:50:15,750
那么这个行为就会在这个函数中被调用 

1035
00:50:15,750 --> 00:50:20,340
可以让我们做一些事情 比如 如果我们的直升机进入一座建筑物 

1036
00:50:20,340 --> 00:50:22,350
我们可以称之为直升机爆炸法 

1037
00:50:22,350 --> 00:50:26,790
这正是我们在这个项目中所做的 多亏了这个功能 

1038
00:50:26,790 --> 00:50:29,420
我们真正需要做的只是几行代码 

1039
00:50:29,420 --> 00:50:31,080
这很简单 

1040
00:50:31,080 --> 00:50:34,250
OnPostRender OnPreRender--所有这些不同的东西

1041
00:50:34,250 --> 00:50:35,500
在不同的时间被调用 

1042
00:50:35,500 --> 00:50:38,499
如果您愿意 只需点击它们 您就可以查看所有这些内容

1043
00:50:38,499 --> 00:50:41,070
看着他们的文件 

1044
00:50:41,070 --> 00:50:44,070
LateUpdate在所有更新函数都被调用之后被调用 

1045
00:50:44,070 --> 00:50:49,560
这可能与某些物理计算相关 

1046
00:50:49,560 --> 00:50:53,760
但你可以做很多不同的事情 

1047
00:50:53,760 --> 00:50:56,490
你不一定需要自己做很多事情 

1048
00:50:56,490 --> 00:50:59,370
如果Unity为您提供的功能为您提供

1049
00:50:59,370 --> 00:51:00,970
你想要的效果 

1050
00:51:00,970 --> 00:51:03,880
所以 如果你很好奇 MonoBehaviour 然后是逍遥法外的医生 

1051
00:51:03,880 --> 00:51:07,200
这只是所有的文档--只是数量惊人的文档 

1052
00:51:07,200 --> 00:51:09,640
这只是在课堂上出现的 

1053
00:51:09,640 --> 00:51:14,470
还有其他所有这些小的侧边区域 

1054
00:51:14,470 --> 00:51:17,352
这就是MonoBehaviour的本质 

1055
00:51:17,352 --> 00:51:18,060
这是一个组成部分 

1056
00:51:18,060 --> 00:51:20,526
它会为您调用很多这样的函数 

1057
00:51:20,526 --> 00:51:21,900
您不必执行它们 

1058
00:51:21,900 --> 00:51:26,160
但如果你这样做了 基本上你会免费获得很多功能 

1059
00:51:26,160 --> 00:51:30,450
关于MonoBehaviour是什么 它是如何工作的 等等 有什么问题吗？

1060
00:51:30,450 --> 00:51:37,150
或者我们到目前为止看到的用于创建MonoBehaviour的任何语法？

1061
00:51:37,150 --> 00:51:38,240
好的 

1062
00:51:38,240 --> 00:51:42,090
例如 在我们之前看到的硬币中 

1063
00:51:42,090 --> 00:51:45,300
请注意 我引用的是一种称为转换的东西 

1064
00:51:45,300 --> 00:51:51,780
Transform.postion.x小于负25 则销毁游戏对象 

1065
00:51:51,780 --> 00:51:54,983
如果这就是硬币 我们认为这是在实现什么？

1066
00:51:57,804 --> 00:51:59,720
观众：它从屏幕上消失了[INAUDIBLE]

1067
00:51:59,720 --> 00:52:00,960
科尔顿·奥格登：是的 

1068
00:52:00,960 --> 00:52:06,480
所以转换 回想一下 是我们的组件

1069
00:52:06,480 --> 00:52:09,450
它包含了我们的旋转、比例和位置 

1070
00:52:09,450 --> 00:52:13,530
所以我们可以说 如果Transform.Position.x

1071
00:52:13,530 --> 00:52:17,280
比负25 消灭游戏对象 

1072
00:52:17,280 --> 00:52:19,320
因为我们是在动态地生产硬币 

1073
00:52:19,320 --> 00:52:22,020
当他们离开屏幕时--就像我们处理管道一样 如果你还记得的话 

1074
00:52:22,020 --> 00:52:23,978
实际上 我在那张幻灯片里有一张截图

1075
00:52:23,978 --> 00:52:25,770
展示了那是什么样子的 

1076
00:52:25,770 --> 00:52:29,940
我们可以看到这里生活着一模一样的东西 

1077
00:52:29,940 --> 00:52:33,450
如果我去布局 两个三个 我们再玩一次游戏 

1078
00:52:33,450 --> 00:52:37,340
然后我就会在某个时刻死去 

1079
00:52:37,340 --> 00:52:42,741
但如果我们这样做 我们会看到现场直播 

1080
00:52:42,741 --> 00:52:43,990
所以我们在跟踪这个--是的 

1081
00:52:43,990 --> 00:52:46,920
看看硬币是如何--一旦大楼和飞机 

1082
00:52:46,920 --> 00:52:48,570
所有的硬币都到了这一步--

1083
00:52:48,570 --> 00:52:53,875
这是单位负25 而不是像素 

1084
00:52:53,875 --> 00:52:56,500
Unity中的所有东西都是基于单位的 默认情况下 

1085
00:52:56,500 --> 00:53:02,310
1等于1米 而不是- 我们到目前为止只使用像素 

1086
00:53:02,310 --> 00:53:07,152
但像素在3D模式下是不可行的 

1087
00:53:07,152 --> 00:53:10,291
[音乐播放]

1088
00:53:10,291 --> 00:53:12,290
但这实际上就是该组件的作用 

1089
00:53:12,290 --> 00:53:16,010
它正在检查 在我们的更新功能中--无效更新--

1090
00:53:16,010 --> 00:53:20,300
如果转换位置.x小于负25 

1091
00:53:20,300 --> 00:53:23,090
请注意 我们实际上不必声明转换

1092
00:53:23,090 --> 00:53:26,000
任何地方 这很有趣 

1093
00:53:26,000 --> 00:53:28,130
这是因为默认情况下 MonoBehaviour为您提供

1094
00:53:28,130 --> 00:53:32,000
对其游戏对象的访问仅在默认情况下进行转换 

1095
00:53:32,000 --> 00:53:35,270
那只是你免费得到的东西 

1096
00:53:35,270 --> 00:53:39,500
然后 请注意GameObject--我们还没有在任何地方声明GameObject 

1097
00:53:39,500 --> 00:53:42,050
因为默认情况下 我们可以访问GameObject 

1098
00:53:42,050 --> 00:53:46,330
这是该脚本所属的游戏对象 

1099
00:53:46,330 --> 00:53:48,058
该组件所属的 

1100
00:53:48,058 --> 00:53:50,930
观众：[听不见]

1101
00:53:50,930 --> 00:53:54,170
科尔顿·奥格登：这将是真正的--

1102
00:53:54,170 --> 00:53:57,980
所以关于课程的有趣之处在于

1103
00:53:57,980 --> 00:54:00,920
就是 你不必明确地说这一点 

1104
00:54:00,920 --> 00:54:08,490
因为如果你把我的数字设为10 你只需说 我的数字--

1105
00:54:08,490 --> 00:54:12,260
Lua、C#和Java之间的区别在于 

1106
00:54:12,260 --> 00:54:16,070
它应该已经知道myNumber是什么了 这是myNumber 

1107
00:54:16,070 --> 00:54:17,535
它就会知道它是这个对象 

1108
00:54:17,535 --> 00:54:18,160
观众：是的 

1109
00:54:18,160 --> 00:54:19,826
科尔顿·奥格登：你没必要这么做 

1110
00:54:23,000 --> 00:54:26,870
这是一件很好的小事 可以帮你节省一点时间 

1111
00:54:26,870 --> 00:54:30,500
因为你可以直接说 myNumber加上等于10 

1112
00:54:30,500 --> 00:54:33,710
顺便说一下 C#的另一个优点是 我们在Lua中没有得到的--

1113
00:54:33,710 --> 00:54:36,051
你可以使用复合赋值运算符 

1114
00:54:36,051 --> 00:54:38,300
所以你可以做加等于 减等于 乘以等于 

1115
00:54:38,300 --> 00:54:40,890
这是我最讨厌的事之一

1116
00:54:40,890 --> 00:54:41,390
哦

1117
00:54:41,390 --> 00:54:43,806
请注意 我的优点是 

1118
00:54:43,806 --> 00:54:45,220
有OmniSharp--它会加下划线 

1119
00:54:45,220 --> 00:54:48,410
老实说 这只是大多数IDE的一个特点 

1120
00:54:48,410 --> 00:54:50,660
所以你在很多地方都能得到这个 

1121
00:54:50,660 --> 00:54:55,994
但它会告诉你我的号码没有被分配 用下划线 

1122
00:54:55,994 --> 00:54:57,410
and also也just by hovering盘旋over it.

1123
00:54:57,410 --> 00:55:00,650
当前上下文中不存在命名的myNumber 

1124
00:55:00,650 --> 00:55:03,260
但我可以直接说 int myNumber 

1125
00:55:03,260 --> 00:55:05,480
然后就没了

1126
00:55:05,480 --> 00:55:07,430
我们需要担心的事情 

1127
00:55:07,430 --> 00:55:09,950
也少了一点我们需要担心的

1128
00:55:09,950 --> 00:55:12,300
一点让步 

1129
00:55:12,300 --> 00:55:16,040
但是 我仍然认为 总的来说 C#将更加语法沉重 

1130
00:55:16,040 --> 00:55:19,820
你必须担心像大括号和分号这样的东西 

1131
00:55:19,820 --> 00:55:23,020
把所有的东西都放在样板里 

1132
00:55:23,020 --> 00:55:26,570
然后 很明显 类型声明和返回类型声明 

1133
00:55:26,570 --> 00:55:29,810
可能比我们现在习惯的要多一点 

1134
00:55:29,810 --> 00:55:34,190
但老实说 这并不太糟糕 只是考虑到你可以使用IDE 

1135
00:55:34,190 --> 00:55:37,610
首先 你静态地输入所有东西 

1136
00:55:37,610 --> 00:55:40,040
你可以提前发现更多的错误 

1137
00:55:40,040 --> 00:55:42,664
如果你想用某种

1138
00:55:42,664 --> 00:55:45,080
你不应该做的事情 比如一些函数接受

1139
00:55:45,080 --> 00:55:48,230
某个类型的对象 但你传入了另一个对象 

1140
00:55:48,230 --> 00:55:50,620
你会提前发现的

1141
00:55:50,620 --> 00:55:53,760
所以这是一件非常好的事情 

1142
00:55:53,760 --> 00:55:54,260
不过是的

1143
00:55:54,260 --> 00:55:57,440
这是一个给予和接受 

1144
00:55:57,440 --> 00:56:00,770
而且 IDE会给你 就像我说的 

1145
00:56:00,770 --> 00:56:03,470
很多功能--很多自动补全功能--

1146
00:56:03,470 --> 00:56:05,342
让很多东西更可持续 

1147
00:56:05,342 --> 00:56:08,550
当然 这并不是说Lua和Love 2D没有自己的IDE 

1148
00:56:08,550 --> 00:56:11,637
就像ZeroBrane工作室很受欢迎一样 据我所知 

1149
00:56:11,637 --> 00:56:12,470
还没用过呢 

1150
00:56:12,470 --> 00:56:16,930
但尤其是当你涉足Java、C#和编译语言时 

1151
00:56:16,930 --> 00:56:20,890
静态语言--拥有这些功能确实可以为您节省更多时间 

1152
00:56:20,890 --> 00:56:23,390
相对而言 这比你使用动态语言时要好 

1153
00:56:25,920 --> 00:56:28,730
这就是MonoBehavies的含义 

1154
00:56:28,730 --> 00:56:32,720
我们游戏的每个组件实际上都有--比如直升机

1155
00:56:32,720 --> 00:56:35,330
有自己的脚本 Heli控制器 

1156
00:56:35,330 --> 00:56:38,450
硬币有自己的剧本--硬币产生者 摩天大楼产生者 

1157
00:56:38,450 --> 00:56:39,546
摩天大楼--

1158
00:56:39,546 --> 00:56:42,170
他们都有自己的脚本来驱动他们的游戏行为 

1159
00:56:42,170 --> 00:56:46,490
但他们也有脚本和组件 这些脚本和组件是Unity Core的一部分 

1160
00:56:46,490 --> 00:56:48,110
也是 

1161
00:56:48,110 --> 00:56:50,280
包括对撞机和触发器 

1162
00:56:50,280 --> 00:56:52,370
因此 如果我看的是Unity--

1163
00:56:52,370 --> 00:56:54,350
所以我要去--

1164
00:56:54,350 --> 00:56:57,530
而这实际上将是我们休息前最后一件事 

1165
00:56:57,530 --> 00:57:03,380
但如果我在Unity中 并且我要返回到我的默认布局 

1166
00:57:03,380 --> 00:57:06,830
就因为它在720便士上有点局促 

1167
00:57:06,830 --> 00:57:09,530
去我的直升机那里 

1168
00:57:09,530 --> 00:57:11,450
直升机上有几块碎片 

1169
00:57:11,450 --> 00:57:15,000
所以让我们来看看我能看到它的地方 

1170
00:57:15,000 --> 00:57:17,630
所以我最喜欢的一件事就是

1171
00:57:17,630 --> 00:57:23,690
是 它给了你很多编辑的魔力--这个编辑有点甜蜜 

1172
00:57:23,690 --> 00:57:27,590
它直观地向你展示了你的游戏世界中很多东西的位置 

1173
00:57:27,590 --> 00:57:31,551
所以绿色的长方形--有人知道它们是什么吗 或者你能猜到吗？

1174
00:57:31,551 --> 00:57:32,384
观众：热门单曲？

1175
00:57:32,384 --> 00:57:33,180
科尔顿·奥格登：是的 

1176
00:57:33,180 --> 00:57:34,030
命中率高 

1177
00:57:34,030 --> 00:57:36,500
一点儿没错 

1178
00:57:36,500 --> 00:57:38,900
这些是对撞机 

1179
00:57:38,900 --> 00:57:41,750
所以刀片--它没有对撞机 

1180
00:57:41,750 --> 00:57:44,510
那个刀片对撞机实际上是分开的 

1181
00:57:44,510 --> 00:57:50,630
这个盒子对撞机就是这个对撞机 

1182
00:57:50,630 --> 00:57:53,454
所以对撞机从字面上讲就是

1183
00:57:53,454 --> 00:57:54,870
这会与其他东西发生碰撞 

1184
00:57:54,870 --> 00:57:56,870
你可以将其设置为触发器或非触发器 

1185
00:57:56,870 --> 00:58:02,930
如果它是一个触发器 那么它实际上不会触发OnTriggerCallback

1186
00:58:02,930 --> 00:58:07,710
功能 我们在前面简单地看到了 

1187
00:58:07,710 --> 00:58:10,860
所以你想要激活触发器的东西 

1188
00:58:10,860 --> 00:58:12,360
你应该做那些不是触发器的事 

1189
00:58:12,360 --> 00:58:15,760
然后触发 你所要做的就是点击这个小触发按钮 

1190
00:58:15,760 --> 00:58:19,190
因此 触发因素只是你已经确定的一个区域--

1191
00:58:19,190 --> 00:58:22,020
或者你已经确定的某个物体--应该会导致行为

1192
00:58:22,020 --> 00:58:23,700
当它被触发时 

1193
00:58:23,700 --> 00:58:27,420
所以在这种情况下 我分配了--

1194
00:58:30,390 --> 00:58:33,930
实际上 我只会播放它 

1195
00:58:33,930 --> 00:58:39,170
但飞机是有扳机的 对吧？

1196
00:58:44,190 --> 00:58:48,930
所有这些东西都有对撞机 不管它们是不是触发器 

1197
00:58:48,930 --> 00:58:51,930
直升机--它的叶片和身体--

1198
00:58:51,930 --> 00:58:55,860
有两个对撞机 两个盒子 

1199
00:58:55,860 --> 00:58:57,810
这些硬币都有撞击器 

1200
00:58:57,810 --> 00:59:00,900
摩天大楼会有对撞机 飞机也会有对撞机 

1201
00:59:00,900 --> 00:59:06,220
不同的是--哦 顺便说一句 还有一件很酷的事情 

1202
00:59:06,220 --> 00:59:08,810
这很容易偏离主题 仅仅因为有

1203
00:59:08,810 --> 00:59:10,560
有那么多很酷的事情可以聊 

1204
00:59:10,560 --> 00:59:12,430
您可以在游戏运行时暂停游戏 

1205
00:59:12,430 --> 00:59:17,500
所以它现在暂停了 但它处于我离开它时的状态 

1206
00:59:17,500 --> 00:59:18,990
所以这里有三枚硬币 

1207
00:59:18,990 --> 00:59:20,190
我的直升机就在那里 

1208
00:59:20,190 --> 00:59:21,600
我可以自由地在现场走动 

1209
00:59:21,600 --> 00:59:23,070
我可以分析事情 

1210
00:59:23,070 --> 00:59:26,980
我实际上可以实时修改它 

1211
00:59:26,980 --> 00:59:30,630
所以我可以改变它的旋转 如果我想的话 

1212
00:59:30,630 --> 00:59:32,559
可能不想这么做 

1213
00:59:32,559 --> 00:59:33,600
但如果我想的话我可以 

1214
00:59:33,600 --> 00:59:35,700
我可以改变它的位置 对吗？

1215
00:59:35,700 --> 00:59:37,450
这样我就可以把它从左向右移动 就像这样 

1216
00:59:37,450 --> 00:59:39,741
请注意 我实际上只选择了身体 

1217
00:59:39,741 --> 00:59:42,111
所以刀片是分开的 

1218
00:59:42,111 --> 00:59:43,860
我甚至不知道是什么疯狂的事情

1219
00:59:43,860 --> 00:59:45,840
如果我把它弄乱 让它运行 就会发生 

1220
00:59:45,840 --> 00:59:47,214
我还没有那么疯狂地测试它 

1221
00:59:47,214 --> 00:59:49,480
但你是被允许通过的 

1222
00:59:49,480 --> 00:59:49,980
哦 好的 

1223
00:59:49,980 --> 00:59:51,360
看起来他们俩都走了 

1224
00:59:51,360 --> 00:59:54,360
哦 是啊 因为他们是直升机物体的父母 

1225
00:59:54,360 --> 00:59:56,250
所以他们两个都会对齐 

1226
00:59:56,250 --> 00:59:58,950
它们将以完全相同的速度移动 

1227
00:59:58,950 --> 01:00:02,220
不管他们相距有多远 

1228
01:00:02,220 --> 01:00:03,720
单个对象 

1229
01:00:03,720 --> 01:00:08,010
但你可以一帧一帧地执行你的游戏 

1230
01:00:08,010 --> 01:00:09,839
并得到一种感觉--

1231
01:00:09,839 --> 01:00:11,880
如果你想找出一个漏洞 那可能就是

1232
01:00:11,880 --> 01:00:13,325
以职位为基础或其他棘手的东西

1233
01:00:13,325 --> 01:00:15,950
而你只是一直无法找到到底发生了什么 

1234
01:00:19,156 --> 01:00:21,030
你可以看完你的整个场景和所有

1235
01:00:21,030 --> 01:00:26,506
在步长时间内的每个物体的场中 

1236
01:00:26,506 --> 01:00:28,380
只要一步一步地走--这个按钮--

1237
01:00:28,380 --> 01:00:29,910
假设您处于暂停模式 

1238
01:00:29,910 --> 01:00:32,460
然后看看右边的所有组件 

1239
01:00:32,460 --> 01:00:34,020
因为这些都会不断更新 

1240
01:00:34,020 --> 01:00:37,050
所有这些字段都将在您执行以下操作时随时更新

1241
01:00:37,050 --> 01:00:40,590
实际场景中的任何更改 

1242
01:00:40,590 --> 01:00:42,570
所以对调试非常有帮助 

1243
01:00:42,570 --> 01:00:44,010
我知道我已经用过很多次了 

1244
01:00:44,010 --> 01:00:46,630
如果我重新开始 或者如果我停止 

1245
01:00:46,630 --> 01:00:49,170
好的是 你所做的任何改变

1246
01:00:49,170 --> 01:00:51,920
使它在运行到您的对象时 它们

1247
01:00:51,920 --> 01:00:54,930
当你真的回到游戏中时 不要申请 

1248
01:00:54,930 --> 01:00:59,104
注意 我弄乱了这两个部分 我把它们分开了 

1249
01:00:59,104 --> 01:01:00,270
然后我停止了比赛 

1250
01:01:00,270 --> 01:01:04,120
它最终回到了最初的位置 

1251
01:01:04,120 --> 01:01:06,820
因此 所有这些基本上都像快照一样保存下来 

1252
01:01:06,820 --> 01:01:10,080
你可以在游戏中做任何你想做的事 然后回来 

1253
01:01:10,080 --> 01:01:12,440
一切都会恢复到原来的水平 

1254
01:01:12,440 --> 01:01:12,951
嗯 

1255
01:01:12,951 --> 01:01:15,306
托尼：所以如果你打单人 

1256
01:01:15,306 --> 01:01:20,190
在我不参与的时候 我一直在做改变[INAUDIBLE]

1257
01:01:20,190 --> 01:01:20,940
科尔顿·奥格登：是的 

1258
01:01:20,940 --> 01:01:21,720
所以 是的 

1259
01:01:21,720 --> 01:01:24,011
托尼基本上是在附和我刚才所说的话 

1260
01:01:24,011 --> 01:01:27,270
如果您在游戏运行时对其进行更改 

1261
01:01:27,270 --> 01:01:31,020
你可能会试着调整它们 这样当你

1262
01:01:31,020 --> 01:01:32,580
实际上 他们不会被拯救 

1263
01:01:32,580 --> 01:01:36,600
所以你必须有意识地努力记住你做过的事情 

1264
01:01:36,600 --> 01:01:40,830
您如何更改不同的字段 以修复任何错误(如果它们确实存在) 

1265
01:01:40,830 --> 01:01:45,400
但这是一件令人沮丧或沮丧的事情 如果你

1266
01:01:45,400 --> 01:01:48,150
最后修复了一些东西 然后你就忘了你改变了什么 

1267
01:01:48,150 --> 01:01:50,350
然后你就得把它搞得乱七八糟 

1268
01:01:50,350 --> 01:01:52,350
所以记住你所做的所有改变 如果它们是

1269
01:01:52,350 --> 01:01:53,970
与你的实际游戏执行相关

1270
01:01:53,970 --> 01:01:55,320
和调试你的游戏

1271
01:01:58,170 --> 01:02:02,700
还有一个控制台 很不错 

1272
01:02:02,700 --> 01:02:08,550
如果你想在网络上输出类似JavaScript风格的东西 

1273
01:02:08,550 --> 01:02:09,810
你可以使用console.log 

1274
01:02:09,810 --> 01:02:13,410
你可以在Unity中使用调试调用做同样的事情 

1275
01:02:13,410 --> 01:02:16,620
我在实际比赛中没有任何这样的电话 

1276
01:02:16,620 --> 01:02:19,347
但这是我们未来会考虑的事情 

1277
01:02:19,347 --> 01:02:21,180
这是一件非常有帮助的事情

1278
01:02:21,180 --> 01:02:24,660
如果你想测量或输出一些你不能

1279
01:02:24,660 --> 01:02:26,202
一定要看检查员 

1280
01:02:26,202 --> 01:02:29,243
在这个博弈中 我们想研究的

1281
01:02:29,243 --> 01:02:30,570
在检查员中可见 

1282
01:02:30,570 --> 01:02:36,120
但是如果你有一个算法 也许你有一个非视觉的生成器 

1283
01:02:36,120 --> 01:02:37,380
就像电平发生器一样

1284
01:02:37,380 --> 01:02:41,040
你要确保代表你的水平的数据结构

1285
01:02:41,040 --> 01:02:44,840
正确地生成东西 你可以通过哈希标记输出所有东西 

1286
01:02:44,840 --> 01:02:46,590
或者你的控制台里的什么东西 实际上

1287
01:02:46,590 --> 01:02:48,810
当你运行代码的时候 

1288
01:02:48,810 --> 01:02:52,460
而不是必须运行实际的游戏并以这种方式查看它 

1289
01:02:52,460 --> 01:02:55,230
有些东西很难在编辑器中建模 

1290
01:02:55,230 --> 01:02:57,310
并且仍然需要控制台输出 

1291
01:02:57,310 --> 01:02:59,890
所以控制台是来帮助你的 

1292
01:02:59,890 --> 01:03:02,980
所以我相信debug.log是一个函数 

1293
01:03:02,980 --> 01:03:07,150
你需要看到这些东西

1294
01:03:07,150 --> 01:03:07,650
对的

1295
01:03:07,650 --> 01:03:08,640
碰撞器和触发器 

1296
01:03:08,640 --> 01:03:10,390
所以我们有点跑题了 

1297
01:03:10,390 --> 01:03:14,684
但是直升机是由这三个东西组成的 

1298
01:03:14,684 --> 01:03:16,600
但是叶片对撞机最终应该

1299
01:03:16,600 --> 01:03:18,580
在这里与blades对象合并 

1300
01:03:18,580 --> 01:03:21,610
但我们可以把它想象成刀刃和身体 

1301
01:03:21,610 --> 01:03:26,470
他们分居的原因有两个

1302
01:03:26,470 --> 01:03:30,010
它们分开的一个核心原因是它们的大小不同 

1303
01:03:30,010 --> 01:03:32,300
所以刀刃比身体长 

1304
01:03:32,300 --> 01:03:35,500
因此 我们有两个独立的对撞机 

1305
01:03:35,500 --> 01:03:38,800
所以我们现在看到的是直升机 

1306
01:03:38,800 --> 01:03:42,850
我们可以看到刀片的对撞机

1307
01:03:42,850 --> 01:03:44,840
比身体延伸得稍微远一点 

1308
01:03:44,840 --> 01:03:48,490
我们不想为整个直升机创建一个盒子对撞机 

1309
01:03:48,490 --> 01:03:52,220
因为一个盒子对撞机就在这里 例如 

1310
01:03:52,220 --> 01:03:54,460
如果我们只是来对了 可能不太公平

1311
01:03:54,460 --> 01:03:56,515
在一栋建筑上 我们的身体--

1312
01:03:59,080 --> 01:04:01,740
也许大楼就在这里 我们只是错过了它 

1313
01:04:01,740 --> 01:04:03,500
我们不希望与之发生冲突 

1314
01:04:03,500 --> 01:04:05,590
所以有时候你需要把对撞机

1315
01:04:05,590 --> 01:04:09,112
来完成您所看到的碰撞检测行为 

1316
01:04:09,112 --> 01:04:11,570
我们在这里使用的盒子对撞机的好处是 

1317
01:04:11,570 --> 01:04:14,194
它们不是很贵 因为它们只是盒子 

1318
01:04:14,194 --> 01:04:19,340
计算3D长方体与其他3D长方体的碰撞很容易 

1319
01:04:19,340 --> 01:04:23,320
而这实际上就是一个主题 

1320
01:04:23,320 --> 01:04:27,520
取一个复杂的模型或物体 然后将其分解 

1321
01:04:27,520 --> 01:04:29,920
不是在它看起来像是被碰撞的情况下 

1322
01:04:29,920 --> 01:04:32,890
而是如何简化物体的碰撞检测 

1323
01:04:32,890 --> 01:04:38,320
就像一个角色 只需将它的手臂、身体、腿建模为圆柱体

1324
01:04:38,320 --> 01:04:42,100
或长方体 而不是复杂的几何体 

1325
01:04:42,100 --> 01:04:45,850
您通常不希望对任何对象执行对等几何体碰撞 

1326
01:04:45,850 --> 01:04:48,130
因为那真的很贵 

1327
01:04:48,130 --> 01:04:52,510
你想尝试并瞄准简单的形状作为你的对撞机 

1328
01:04:52,510 --> 01:04:54,370
Unity为您提供了许多简单的形状

1329
01:04:54,370 --> 01:04:59,212
默认情况下 例如 如果你看一下我们的直升机--

1330
01:04:59,212 --> 01:05:01,420
如果你想添加一个组件--顺便说一句 

1331
01:05:01,420 --> 01:05:05,170
只需在组件检查器中 您就可以轻松地在此处执行操作 

1332
01:05:05,170 --> 01:05:08,290
如果你看右下角 有一个添加组件按钮 

1333
01:05:08,290 --> 01:05:12,020
因此 您可以添加您已经编写的任何组件 

1334
01:05:12,020 --> 01:05:15,050
以及Unity默认为您提供的所有组件 

1335
01:05:15,050 --> 01:05:16,851
所以如果我们用对撞机观察它 我们可以看到

1336
01:05:16,851 --> 01:05:19,600
Unity免费提供给我们很多不同的对撞机 

1337
01:05:19,600 --> 01:05:25,810
多边形对撞机 网格对撞机 长方体对撞机 胶囊对撞机 

1338
01:05:25,810 --> 01:05:28,540
我尽我所能地尝试和争取禁区 

1339
01:05:28,540 --> 01:05:29,470
球体还不错 

1340
01:05:29,470 --> 01:05:31,750
球体通常也很容易计算 

1341
01:05:31,750 --> 01:05:33,730
但盒子是最简单的 

1342
01:05:33,730 --> 01:05:35,770
胶囊也很容易 

1343
01:05:35,770 --> 01:05:39,220
很多玩家会是太空舱对撞机 因为角色通常

1344
01:05:39,220 --> 01:05:40,270
有圆形的头 

1345
01:05:40,270 --> 01:05:45,142
因此 模拟头部与太空舱的碰撞更有意义 

1346
01:05:45,142 --> 01:05:48,100
事实上 我们将在下周使用第一人称的时候来看这一点

1347
01:05:48,100 --> 01:05:49,810
我们可以免费获得的组件 

1348
01:05:49,810 --> 01:05:55,180
它的默认碰撞器是胶囊 

1349
01:05:55,180 --> 01:06:02,950
但叶片和身体都有自己的对撞机 

1350
01:06:02,950 --> 01:06:04,360
它们不是导火索 

1351
01:06:04,360 --> 01:06:08,050
但如果我们看看我们的预制板--

1352
01:06:08,050 --> 01:06:10,900
我们很快就会来看看预制板是什么--

1353
01:06:10,900 --> 01:06:16,240
正如我们在这里看到的 一座摩天大楼有一个盒子对撞机 这是一个触发器 

1354
01:06:16,240 --> 01:06:18,340
而这枚硬币是一个导火索 

1355
01:06:18,340 --> 01:06:20,710
而飞机是一个导火索 

1356
01:06:20,710 --> 01:06:27,800
所以这些东西都会触发 除了其他不会触发的对撞机 

1357
01:06:27,800 --> 01:06:30,940
如果它检测到与不是触发器的对撞机发生碰撞 

1358
01:06:30,940 --> 01:06:33,923
它将调用OnTriggerEnter函数 

1359
01:06:33,923 --> 01:06:36,506
我们看到的是你可以通过MonoBehaviour获得的东西 

1360
01:06:36,506 --> 01:06:37,438
嗯 

1361
01:06:37,438 --> 01:06:41,163
观众：如果你想叫特价的话 你能有两个值吗？

1362
01:06:41,163 --> 01:06:44,931
同时执行两个函数 则会有常规的[INAUDIBLE]..

1363
01:06:44,931 --> 01:06:47,456
有没有更简单的方法来做到这一点？

1364
01:06:47,456 --> 01:06:49,497
科尔顿·奥格登：你能给我举个具体的例子吗？

1365
01:06:49,497 --> 01:06:53,473
观众：嗯 如果我想玩弹球之类的 

1366
01:06:53,473 --> 01:06:58,443
我想要模拟当我的球打到什么东西时的功能 

1367
01:06:58,443 --> 01:07:01,440
但与此同时 我只是不想从东西上反弹 

1368
01:07:01,440 --> 01:07:02,398
科尔顿·奥格登：哦 是的 

1369
01:07:02,398 --> 01:07:03,910
观众：所以你可以这么做吗？

1370
01:07:03,910 --> 01:07:09,674
科尔顿·奥格登：所以问题是 我能不能实现 例如 

1371
01:07:09,674 --> 01:07:12,340
在弹球游戏中 如果我有一个球撞到了什么东西

1372
01:07:12,340 --> 01:07:15,994
并导致触发发生 但也让它从某些东西上反弹 

1373
01:07:15,994 --> 01:07:17,660
对于刚体 你会这样做 

1374
01:07:17,660 --> 01:07:19,330
所以你给它一个刚体 

1375
01:07:19,330 --> 01:07:23,110
在这种情况下 我实际上给了直升机一个刚体

1376
01:07:23,110 --> 01:07:26,699
因为我最初的目标是让它受到重力的影响 

1377
01:07:26,699 --> 01:07:29,990
但事实证明 我实际上更喜欢没有重力的地方 

1378
01:07:29,990 --> 01:07:32,200
所以这个刚体并不是严格必要的 

1379
01:07:32,200 --> 01:07:34,720
但它有一个重力分量 你可以

1380
01:07:34,720 --> 01:07:39,640
赋值给它 然后 实际计算出重力 并将其拉动

1381
01:07:39,640 --> 01:07:44,350
在任何地方--你有一个全球重力定义

1382
01:07:44,350 --> 01:07:47,810
在你的单位设置中 这将会以这种方式影响它 

1383
01:07:47,810 --> 01:07:51,066
所以你要做的是 给你的球一个刚体 

1384
01:07:51,066 --> 01:07:53,440
以及其他你想让它从这些东西上反弹的东西 

1385
01:07:53,440 --> 01:07:55,450
它们也有刚体 

1386
01:07:55,450 --> 01:07:59,532
它们基本上可以是运动学的 也可以不是运动学的 

1387
01:07:59,532 --> 01:08:00,740
我们之前谈过的 

1388
01:08:00,740 --> 01:08:05,990
运动学可以移动 但不受其他对象的影响 

1389
01:08:05,990 --> 01:08:10,495
因此 作为触发器的对象 你仍然触发代码 它会做一些事情 

1390
01:08:10,495 --> 01:08:12,870
所以你的弹球机 当它撞到什么东西时 

1391
01:08:12,870 --> 01:08:17,054
它触发了那个东西 它仍然会触发那个代码 

1392
01:08:17,054 --> 01:08:19,470
所以无论这是增加你的分数 还是引起什么

1393
01:08:19,470 --> 01:08:22,259
为了闪现 它的一部分会闪现 或者播放声音 

1394
01:08:22,259 --> 01:08:23,800
它会在你的OnTriggerEnter中做到这一点 

1395
01:08:23,800 --> 01:08:26,640
但你的刚体也会做它的工作 

1396
01:08:26,640 --> 01:08:28,890
并从任何东西上反弹--

1397
01:08:28,890 --> 01:08:32,729
假设您不使用OnTriggerEnter函数销毁它 

1398
01:08:32,729 --> 01:08:35,520
它将从表面反弹 并以这种方式运行

1399
01:08:35,520 --> 01:08:37,450
你在暗指的那个人 

1400
01:08:37,450 --> 01:08:40,130
这说得通吗？

1401
01:08:40,130 --> 01:08:41,298
好的 

1402
01:08:41,298 --> 01:08:41,798
凉爽的 

1403
01:08:44,810 --> 01:08:47,540
所以所有这些事情都有触发因素 

1404
01:08:47,540 --> 01:08:49,719
IsTrigger标志--

1405
01:08:49,719 --> 01:08:51,510
我是说 这就像我们想要的那样简单 

1406
01:08:51,510 --> 01:08:52,939
所以你只要给出一个盒子对撞机 

1407
01:08:52,939 --> 01:08:54,950
盒子对撞机的好处也是如此 

1408
01:08:54,950 --> 01:09:00,020
如果你的网格是长方体、正方形或长方形 

1409
01:09:00,020 --> 01:09:04,686
它通常会完美地适应您试图将其分配给的任何对象 

1410
01:09:04,686 --> 01:09:07,810
所以在这种情况下 我记得为这些摩天大楼添加了盒子对撞机 

1411
01:09:07,810 --> 01:09:12,050
因为它们都是长方体或者立方体

1412
01:09:12,050 --> 01:09:12,649
我不知道

1413
01:09:12,649 --> 01:09:14,060
什么是矩形3D？

1414
01:09:14,060 --> 01:09:15,780
我忘了这个词 

1415
01:09:15,780 --> 01:09:16,279
什么事？

1416
01:09:16,279 --> 01:09:17,479
观众：长方体 

1417
01:09:17,479 --> 01:09:19,020
科尔顿·奥格登：直角棱镜 是的 

1418
01:09:19,020 --> 01:09:23,000
因为它们都是矩形棱柱 所以盒子收集器适合它们 

1419
01:09:23,000 --> 01:09:25,310
它会以正确的方式扩展 

1420
01:09:25,310 --> 01:09:27,950
当你有不同形状的物体时 

1421
01:09:27,950 --> 01:09:30,229
它基本上就像它需要的那样大

1422
01:09:30,229 --> 01:09:32,960
to be to completely完全encapsulate封装it.

1423
01:09:32,960 --> 01:09:37,460
但就像我之前说的 因为直升机有一些奇怪的几何形状 

1424
01:09:37,460 --> 01:09:41,090
如果我们这样做 默认情况下 它将是整个盒子 

1425
01:09:41,090 --> 01:09:45,470
因为这是它在这条轴上延伸的最远距离 

1426
01:09:45,470 --> 01:09:50,870
所以我们要结合网格来产生碰撞

1427
01:09:50,870 --> 01:09:52,310
我们正在寻找的行为 

1428
01:09:52,310 --> 01:10:02,090
而触发器的输入位是相关的 因为如果你的游戏对象是

1429
01:10:02,090 --> 01:10:09,560
一个触发器 一旦我们与那个物体相撞 

1430
01:10:09,560 --> 01:10:11,920
我们想要--默认情况下 当你执行OnTriggerEnter时 

1431
01:10:11,920 --> 01:10:15,830
它会在这个物体上寻找对撞机

1432
01:10:15,830 --> 01:10:18,630
它会接受一个对撞机 对吧？

1433
01:10:18,630 --> 01:10:21,950
那是另一个对撞机

1434
01:10:21,950 --> 01:10:24,650
与这个物体和这个硬币相撞 

1435
01:10:24,650 --> 01:10:27,680
所以直升机 因为它是我们场景中唯一的其他物体

1436
01:10:27,680 --> 01:10:31,267
有一个非触发对撞机 

1437
01:10:31,267 --> 01:10:33,350
OnTriggerEnter--这是一架直升机 

1438
01:10:33,350 --> 01:10:38,480
我们可以直接说other.transform.parent 因为我们的直升机有孩子 

1439
01:10:38,480 --> 01:10:42,200
有真正的对撞机 父母有直升机控制器 

1440
01:10:42,200 --> 01:10:43,060
成分

1441
01:10:43,060 --> 01:10:47,460
我们要去GetComponent直升机控制器 

1442
01:10:47,460 --> 01:10:50,254
所以我们要通过我们的那个对象 那个其他的

1443
01:10:50,254 --> 01:10:51,170
与我们相撞

1444
01:10:51,170 --> 01:10:54,182
我们将得到它的transform父对象 

1445
01:10:54,182 --> 01:10:57,140
我们要做的是GetComponent 它是一个函数 

1446
01:10:57,140 --> 01:10:59,360
通过它的所有组件列表 

1447
01:10:59,360 --> 01:11:03,770
我们在这里使用这个标识符指定我们想要的组件 

1448
01:11:03,770 --> 01:11:06,050
类HeliController 

1449
01:11:06,050 --> 01:11:16,130
这些尖括号是泛型类型说明符

1450
01:11:16,130 --> 01:11:17,930
语法 它基本上是在寻找它 

1451
01:11:17,930 --> 01:11:20,780
您可以在这里有效地传递任何类型的参数 

1452
01:11:20,780 --> 01:11:23,210
GetComponent将查看这里的任何类型 

1453
01:11:23,210 --> 01:11:25,850
并获取该类型的组件 特别是 

1454
01:11:25,850 --> 01:11:29,750
因此 在C#中确实具有某种类型灵活性 

1455
01:11:29,750 --> 01:11:32,330
但你必须走得更远 并具体说明 

1456
01:11:32,330 --> 01:11:35,840
并实现接受如下泛型参数的函数 

1457
01:11:35,840 --> 01:11:41,430
它类似于Java、C++和其他这样做的语言 

1458
01:11:41,430 --> 01:11:45,590
然后 一旦我们获得了HeliController类型的组件 

1459
01:11:45,590 --> 01:11:50,010
通过这个函数调用 我们执行PickupCoin 

1460
01:11:50,010 --> 01:11:53,390
这是HeliController的一个功能 

1461
01:11:53,390 --> 01:11:55,110
有人猜到PickupCoin做什么了吗？

1462
01:11:59,574 --> 01:12:00,570
观众：[听不见]

1463
01:12:00,570 --> 01:12:01,278
科尔顿·奥格登：什么？

1464
01:12:01,278 --> 01:12:04,180
观众：递增硬币计数器 并告诉硬币消失 

1465
01:12:04,180 --> 01:12:06,470
科尔顿·奥格登：增加硬币指示器 呼唤硬币消失 

1466
01:12:06,470 --> 01:12:09,910
实际上 这并不意味着硬币会消失 因为我们在这里就是这么做的 

1467
01:12:09,910 --> 01:12:10,710
观众：哦 

1468
01:12:10,710 --> 01:12:13,510
科尔顿·奥格登：摧毁游戏对象--

1469
01:12:13,510 --> 01:12:17,284
游戏对象将是执行此功能的硬币 

1470
01:12:17,284 --> 01:12:18,450
还有一件事 

1471
01:12:18,450 --> 01:12:21,120
你还记得当我们拿起一枚硬币时会发生什么吗？

1472
01:12:21,120 --> 01:12:21,620
一点儿没错 

1473
01:12:21,620 --> 01:12:22,280
粒子效应 

1474
01:12:22,280 --> 01:12:23,530
它会触发一种粒子效应 

1475
01:12:23,530 --> 01:12:28,060
我们可以转到HeliController类并查看这一点 

1476
01:12:28,060 --> 01:12:28,840
捡起的硬币 

1477
01:12:31,540 --> 01:12:33,730
在这里 coinTotal加等于1 

1478
01:12:33,730 --> 01:12:37,851
获取组件音频来源 

1479
01:12:37,851 --> 01:12:38,350
玩 

1480
01:12:38,350 --> 01:12:39,860
所以这有点奇怪 

1481
01:12:39,860 --> 01:12:44,150
所以有了音频源 你可以有多个音频文件 

1482
01:12:44,150 --> 01:12:48,160
因此 GetComponents AudioSource才是我们真正需要的

1483
01:12:48,160 --> 01:12:49,970
附加到此对象的音频 

1484
01:12:49,970 --> 01:12:51,400
在指数0处--

1485
01:12:51,400 --> 01:12:54,400
因为无论如何都只有一个音频源 

1486
01:12:54,400 --> 01:12:58,510
然后我们只需调用Play 这样就会播放硬币的声音 

1487
01:12:58,510 --> 01:13:00,430
然后是GetComponent 因为只有

1488
01:13:00,430 --> 01:13:04,944
将是与该直升机对象相关联的一个粒子系统 

1489
01:13:04,944 --> 01:13:06,860
我们将获得粒子系统对象 

1490
01:13:06,860 --> 01:13:09,985
然后我们将调用Play 这实际上会触发

1491
01:13:09,985 --> 01:13:14,830
其粒子的一次发射 

1492
01:13:14,830 --> 01:13:18,100
简而言之 这就是对撞机和触发器 

1493
01:13:18,100 --> 01:13:22,780
它同时有很多语法 因为Unity真的很大 

1494
01:13:22,780 --> 01:13:25,030
但这很简单 

1495
01:13:25,030 --> 01:13:27,940
只要确保你给你的对象赋予了正确的形状 

1496
01:13:27,940 --> 01:13:29,950
做正确的事情会触发你想要的

1497
01:13:29,950 --> 01:13:34,930
当非触发的东西接触到它们时 会导致行为发生 

1498
01:13:34,930 --> 01:13:38,440
然后实现OnTriggerEnter的行为--游戏逻辑--

1499
01:13:38,440 --> 01:13:39,880
这是你需要的 

1500
01:13:39,880 --> 01:13:43,270
以摩天大楼为例 如果我们看看摩天大楼 

1501
01:13:43,270 --> 01:13:45,890
所以我这里有一个摩天大楼的部件 

1502
01:13:45,890 --> 01:13:49,990
然后如果我在触发器上输入 它实际上

1503
01:13:49,990 --> 01:13:53,890
做着和飞机一样的事情 

1504
01:13:53,890 --> 01:14:00,500
这只是浏览其他游戏对象 变换父游戏对象 

1505
01:14:00,500 --> 01:14:03,350
HeliController 然后调用分解 

1506
01:14:03,350 --> 01:14:06,890
所以爆炸--类似于PickupCoin做的事情 

1507
01:14:06,890 --> 01:14:08,950
它会引发粒子效应 

1508
01:14:08,950 --> 01:14:14,200
但它也摧毁了直升机 并通过文本调整了游戏

1509
01:14:14,200 --> 01:14:16,850
在这一点上打开 

1510
01:14:16,850 --> 01:14:20,794
因此 关于触发器如何工作的任何问题 或者我们已经介绍的任何语法

1511
01:14:20,794 --> 01:14:21,710
到目前为止都在谈论什么？

1512
01:14:21,710 --> 01:14:24,010
我知道这很多 

1513
01:14:24,010 --> 01:14:25,330
这是一次很快的旅行 

1514
01:14:25,330 --> 01:14:30,130
不过 我们还在继续前进 

1515
01:14:30,130 --> 01:14:30,910
好的 

1516
01:14:30,910 --> 01:14:34,240
哦 这是我用来展示绿线的截图--

1517
01:14:34,240 --> 01:14:40,690
这个盒子--然后橙色是直升机的实际网格 

1518
01:14:40,690 --> 01:14:41,975
所以我们要休息一下 

1519
01:14:41,975 --> 01:14:44,350
当我们回来的时候 我们会谈论预制板

1520
01:14:44,350 --> 01:14:47,350
然后产卵 然后潜入更深的地方

1521
01:14:47,350 --> 01:14:49,821
到项目的其他部分 

1522
01:14:49,821 --> 01:14:50,320
好的 

1523
01:14:50,320 --> 01:14:52,090
欢迎回到GD50第八讲 

1524
01:14:52,090 --> 01:14:53,560
这是直升机游戏3D 

1525
01:14:53,560 --> 01:14:57,130
所以在休息之前 我们谈论的是对撞机和触发器 

1526
01:14:57,130 --> 01:15:01,930
而且我们也刚刚习惯使用MonoBehaviour和编辑器 

1527
01:15:01,930 --> 01:15:03,610
以及各种各样的事情 

1528
01:15:03,610 --> 01:15:05,680
但我们还没有真正看过预制板 

1529
01:15:05,680 --> 01:15:08,260
这是这场比赛的一个主要部分 

1530
01:15:08,260 --> 01:15:12,040
所以硬币 摩天大楼 飞机--

1531
01:15:12,040 --> 01:15:16,810
这些都是我们得到的预制资产

1532
01:15:16,810 --> 01:15:19,670
准备好进入我们的场景了 

1533
01:15:19,670 --> 01:15:22,730
我们将看看它是如何实际工作的 

1534
01:15:22,730 --> 01:15:24,670
所以这里有一份清单--

1535
01:15:24,670 --> 01:15:27,310
在我们的编辑看来--我们拥有的所有不同的预制件 

1536
01:15:27,310 --> 01:15:31,960
所以我们可以看到飞机、叶片和机身都是预制的 

1537
01:15:31,960 --> 01:15:33,812
硬币 所有的摩天大楼 

1538
01:15:33,812 --> 01:15:35,770
有三种不同类型的摩天大楼 

1539
01:15:35,770 --> 01:15:37,227
然后是直升机 

1540
01:15:37,227 --> 01:15:39,310
直升机本身并不是我们使用的预制件 

1541
01:15:39,310 --> 01:15:40,870
因为我已经在场景中创建了它 

1542
01:15:40,870 --> 01:15:42,670
而且它永远不会被动态实例化 

1543
01:15:42,670 --> 01:15:45,910
但我们可以很容易地这样做 因为我有

1544
01:15:45,910 --> 01:15:49,990
用直升机制作了一个预制件 

1545
01:15:49,990 --> 01:15:53,290
所以当我们看着这里的场景时 我们

1546
01:15:53,290 --> 01:15:57,350
请注意 我们只有直升机 并且我们有背景 

1547
01:15:57,350 --> 01:16:01,790
但这里没有摩天大楼 没有硬币 也没有飞机 

1548
01:16:01,790 --> 01:16:07,170
嗯 我们确实有我们的摩天大楼产生器 硬币产生器和飞机

1549
01:16:07,170 --> 01:16:07,840
产卵者 

1550
01:16:07,840 --> 01:16:10,570
而这三个只是空的游戏对象 

1551
01:16:10,570 --> 01:16:13,450
但他们将这些产卵者脚本与它们联系在一起 

1552
01:16:13,450 --> 01:16:16,120
而产卵人的剧本 是我们自己写的 

1553
01:16:16,120 --> 01:16:19,580
然后 一旦我们编写了它们 我们只需在这里添加组件 

1554
01:16:19,580 --> 01:16:22,450
然后选择了合适的产卵者 

1555
01:16:22,450 --> 01:16:24,040
所以这些是做什么的--

1556
01:16:24,040 --> 01:16:28,450
如果我们实际上查看我们的代码 我们去 例如 飞机

1557
01:16:28,450 --> 01:16:33,520
产卵者 我们有一个开始的方法 

1558
01:16:33,520 --> 01:16:34,610
我们有一个更新方法 

1559
01:16:34,610 --> 01:16:38,140
请注意 自相矛盾的是 更新方法并不做任何事情 

1560
01:16:38,140 --> 01:16:42,040
因为飞机产卵器正在随着时间的推移而运行 

1561
01:16:42,040 --> 01:16:45,100
随着时间的推移 我们正在催生飞机 

1562
01:16:45,100 --> 01:16:48,430
但随着时间的推移 我们在Unity中异步行事的方式

1563
01:16:48,430 --> 01:16:51,470
与我们到目前为止所做的任何事情都有一点不同 

1564
01:16:51,470 --> 01:16:54,910
所以这里的这个Start方法 我们看到我们正在调用

1565
01:16:54,910 --> 01:16:57,400
此函数称为StartCoroutine 

1566
01:16:57,400 --> 01:17:01,330
该函数包含一个名为SpawnAirPlanes的函数 

1567
01:17:01,330 --> 01:17:06,460
因此 在高层次上 协程实际上是一个函数

1568
01:17:06,460 --> 01:17:09,850
这在每次调用时都会产生控制 

1569
01:17:09,850 --> 01:17:15,310
所以它会运行 然后 不是遍历它的整个代码主体 

1570
01:17:15,310 --> 01:17:19,180
然后结束或返回一些值 然后让它结束 

1571
01:17:19,180 --> 01:17:25,720
当你使用关键字Year时 它实际上会屈服 

1572
01:17:25,720 --> 01:17:30,160
而这取决于你用这些收益做了什么 

1573
01:17:30,160 --> 01:17:34,660
它会暂停一段时间 或者做一件事一段时间 

1574
01:17:34,660 --> 01:17:37,130
而不是结束该函数调用 

1575
01:17:37,130 --> 01:17:39,310
所以这架SpawnAirets在这里起作用--

1576
01:17:39,310 --> 01:17:41,770
请注意 它有一段时间为真 

1577
01:17:41,770 --> 01:17:45,550
因此 虽然真通常不是你想要在游戏中看到的东西 

1578
01:17:45,550 --> 01:17:49,480
因为这只会永远锁定你的比赛 

1579
01:17:49,480 --> 01:17:54,760
但在协程的情况下 协程将运行 

1580
01:17:54,760 --> 01:17:56,680
但之后它就会重新控制产量

1581
01:17:56,680 --> 01:17:58,600
在一段时间内无论它叫什么 

1582
01:17:58,600 --> 01:18:00,940
或者取决于我们是如何编程的 

1583
01:18:00,940 --> 01:18:02,500
在这种情况下 你可以看到这里--

1584
01:18:02,500 --> 01:18:07,270
Year Return新WaitForSecond随机数 范围3 10 

1585
01:18:07,270 --> 01:18:10,270
有谁知道这是干什么的吗？

1586
01:18:10,270 --> 01:18:10,770
嗯 

1587
01:18:10,770 --> 01:18:15,650
观众：逻辑[INAUDIBLE]等待3到10秒 

1588
01:18:15,650 --> 01:18:16,600
而且还在继续 

1589
01:18:16,600 --> 01:18:19,050
科尔顿·奥格登：的确如此 

1590
01:18:19,050 --> 01:18:22,660
它会产生3到10秒的时间 然后继续执行 

1591
01:18:22,660 --> 01:18:23,605
这是完全正确的 

1592
01:18:23,605 --> 01:18:24,760
你有什么问题吗？

1593
01:18:24,760 --> 01:18:27,984
观众：我在想 为什么你们有三个不同的摩天大楼

1594
01:18:27,984 --> 01:18:28,484
向上?

1595
01:18:28,484 --> 01:18:32,177
你就不能只有一座摩天大楼 然后改变吗？

1596
01:18:32,177 --> 01:18:33,510
科尔顿·奥格登：你可以这么做 

1597
01:18:33,510 --> 01:18:34,129
嗯 

1598
01:18:34,129 --> 01:18:36,045
我猜是为了展示预制件 

1599
01:18:36,045 --> 01:18:38,503
而且 它有点复杂 更复杂的是

1600
01:18:38,503 --> 01:18:42,981
转换为动态材料设置 并在代码中更改材料 

1601
01:18:42,981 --> 01:18:43,480
不过 是的 

1602
01:18:43,480 --> 01:18:50,230
你可以有效地用一种基色来创建一座摩天大楼 

1603
01:18:50,230 --> 01:18:56,570
然后动态改变它的材质 

1604
01:18:56,570 --> 01:18:59,885
也是为了说明拥有多个不同的预制件

1605
01:18:59,885 --> 01:19:02,260
分配给一个对象 然后可以随机选择

1606
01:19:02,260 --> 01:19:03,510
在游戏场景中生成 

1607
01:19:03,510 --> 01:19:05,600
它们可能不一定是摩天大楼

1608
01:19:05,600 --> 01:19:07,100
会有完全一样的颜色 

1609
01:19:07,100 --> 01:19:12,770
它可能是一个妖精 或兽人 或巨魔 或什么的 

1610
01:19:12,770 --> 01:19:15,290
它们都是我们创造的不同的预制板 

1611
01:19:15,290 --> 01:19:18,220
但您可以将它们放在列表中 然后动态选择

1612
01:19:18,220 --> 01:19:20,305
我们想要哪一个是随机的 

1613
01:19:20,305 --> 01:19:21,430
所以有几个不同的原因 

1614
01:19:21,430 --> 01:19:21,929
不过 是的 

1615
01:19:21,929 --> 01:19:25,027
在一种情况下 所有的东西都是有效区分的

1616
01:19:25,027 --> 01:19:26,860
通过单一的颜色和材料的变化 您

1617
01:19:26,860 --> 01:19:29,020
可以根据需要动态交换 

1618
01:19:33,610 --> 01:19:36,730
我们已经启动的这个代码例程--这个函数

1619
01:19:36,730 --> 01:19:42,400
可以有效地暂停自身 即使它在被调用时为True

1620
01:19:42,400 --> 01:19:45,170
正在发挥作用 

1621
01:19:45,170 --> 01:19:47,290
它使用这个Year关键字进行控制 

1622
01:19:47,290 --> 01:19:51,100
它的作用是 它允许我们一遍又一遍地调用某个东西 

1623
01:19:51,100 --> 01:19:53,300
但随后会停顿一段时间 

1624
01:19:53,300 --> 01:19:53,800
对吗？

1625
01:19:53,800 --> 01:19:57,201
我们不需要在这里维持一个产卵时间的计数器 

1626
01:19:57,201 --> 01:19:57,950
我们可以做到的 

1627
01:19:57,950 --> 01:20:01,690
我们可以做漂浮繁殖时间等于0 对吗？

1628
01:20:01,690 --> 01:20:06,880
然后浮动产卵增量等于1,000 

1629
01:20:06,880 --> 01:20:13,000
当产卵时间小于产卵增量时--

1630
01:20:13,000 --> 01:20:16,450
我们可以说在更新中 如果产卵增量 

1631
01:20:16,450 --> 01:20:20,389
或者我们会做繁殖时间加等于时间 首先是增量时间 

1632
01:20:20,389 --> 01:20:22,930
以获取自最后一帧以来经过的时间长度 

1633
01:20:22,930 --> 01:20:26,170
然后我们会说 如果繁殖时间更长

1634
01:20:26,170 --> 01:20:32,260
而不是产生增量 实例化一架新飞机 

1635
01:20:32,260 --> 01:20:37,120
然后将繁殖时间设置回0 

1636
01:20:37,120 --> 01:20:40,430
然后冲洗 一遍又一遍地重复这个过程 

1637
01:20:40,430 --> 01:20:44,470
但协程程序消除了这种需求 就像定时器一样

1638
01:20:44,470 --> 01:20:49,000
是这样做的 因为你有一个特定的定时器来跟踪任何事情 

1639
01:20:49,000 --> 01:20:51,550
你可以用协程做一大堆不同的事情 

1640
01:20:51,550 --> 01:20:53,341
其中之一 在我们正在做的这种情况下 

1641
01:20:53,341 --> 01:20:57,850
只是暂停一段时间来做某事 

1642
01:20:57,850 --> 01:21:00,160
在这种情况下 我们想再等一段时间

1643
01:21:00,160 --> 01:21:07,000
在飞机的每个实例化之间 

1644
01:21:07,000 --> 01:21:10,850
所以我们要把控制权交还给我们的游戏 

1645
01:21:10,850 --> 01:21:12,850
因为我们想在真实的时候挣脱这一切 

1646
01:21:12,850 --> 01:21:16,141
但我们不想摆脱它 完全摆脱这个功能 

1647
01:21:16,141 --> 01:21:19,930
我们希望这种情况一遍又一遍地发生 

1648
01:21:19,930 --> 01:21:23,500
所以我们在这里看到 这个实例化函数是

1649
01:21:23,500 --> 01:21:25,540
实际实例化发生的位置 

1650
01:21:25,540 --> 01:21:29,500
实例化包含一个预制件--

1651
01:21:29,500 --> 01:21:30,900
因此 一个游戏对象 

1652
01:21:30,900 --> 01:21:35,350
因此 在这种情况下 我们有一个预制板清单 

1653
01:21:35,350 --> 01:21:39,259
游戏对象公共 称为预制的游戏对象数组 

1654
01:21:39,259 --> 01:21:41,800
因此 它可以容纳我们想要的任何数量的预制件 

1655
01:21:44,380 --> 01:21:48,700
我们将返回一个介于0和长度之间的范围 

1656
01:21:48,700 --> 01:21:52,992
然后 我们还希望它能产卵 

1657
01:21:52,992 --> 01:21:54,950
我们给它一个我们想要产卵的位置 

1658
01:21:54,950 --> 01:21:58,480
所以实例化--它接受一个对象 它接受一个位置 

1659
01:21:58,480 --> 01:21:59,890
它会旋转一圈 

1660
01:21:59,890 --> 01:22:02,710
在这种情况下 我们想给它这个位置 

1661
01:22:02,710 --> 01:22:03,840
所以这是一辆Vector3--

1662
01:22:03,840 --> 01:22:05,740
它是一个x y 和一个z--

1663
01:22:05,740 --> 01:22:06,460
26岁 

1664
01:22:06,460 --> 01:22:09,580
因此 从屏幕7到10的右边缘 

1665
01:22:09,580 --> 01:22:14,140
所以在垂直于顶部的范围内 

1666
01:22:14,140 --> 01:22:17,920
然后在z轴上的11点 这与我们的直升机对齐

1667
01:22:17,920 --> 01:22:21,280
还有摩天大楼 

1668
01:22:21,280 --> 01:22:25,300
然后是这个四元数 欧拉--

1669
01:22:25,300 --> 01:22:30,230
所以3D旋转 背后的数学是相当复杂的 

1670
01:22:30,230 --> 01:22:32,000
我一点也不了解它 

1671
01:22:32,000 --> 01:22:35,700
但是四元数 欧拉允许我们以度为单位思考 

1672
01:22:35,700 --> 01:22:40,130
还可以很容易地对一些东西进行3D旋转 

1673
01:22:40,130 --> 01:22:43,540
因此 如果你想在3D中旋转一些东西 可以使用Quaternion.Euler 

1674
01:22:43,540 --> 01:22:46,980
零下90度 我相信是z x y 

1675
01:22:46,980 --> 01:22:50,860
在这种情况下 飞机的默认旋转方式是 

1676
01:22:50,860 --> 01:22:54,070
我们希望将其设置为负90 负90 0 

1677
01:22:54,070 --> 01:22:58,180
你也可以这样设置你的预制件

1678
01:22:58,180 --> 01:23:00,550
你不需要把这个交给我 

1679
01:23:00,550 --> 01:23:03,420
你可以做四元数 在这种情况下 身份 

1680
01:23:03,420 --> 01:23:06,632
但这只是为了说明 如果你想旋转一些东西

1681
01:23:06,632 --> 01:23:07,840
在代码中 你会怎么做 

1682
01:23:07,840 --> 01:23:10,720
所以四元数 欧拉是你在3D中旋转物体的方式 

1683
01:23:13,660 --> 01:23:15,957
所以实例化--全局函数

1684
01:23:15,957 --> 01:23:18,040
您可以随心所欲地拨打电话 只要

1685
01:23:18,040 --> 01:23:23,560
给它一个它知道如何实例化的实际对象或预制件 

1686
01:23:23,560 --> 01:23:25,700
然后是WaitForSecond--另一个全局对象 

1687
01:23:25,700 --> 01:23:28,120
它是一个异步对象 它将允许

1688
01:23:28,120 --> 01:23:31,630
在这段时间里 我们不得不屈服 

1689
01:23:31,630 --> 01:23:33,302
你在这里度过了一段时间 

1690
01:23:33,302 --> 01:23:35,260
它只需要几秒钟 因为WaitForSecond 

1691
01:23:35,260 --> 01:23:39,610
然后 一旦这段时间过去了 

1692
01:23:39,610 --> 01:23:42,910
它将回到这里 回到这条真正的指令中 

1693
01:23:42,910 --> 01:23:44,290
然后再次实例化 

1694
01:23:44,290 --> 01:23:47,950
我们不需要记录时间或任何事情--任何奇怪的样板 

1695
01:23:47,950 --> 01:23:51,290
我们只要给StartCoroutine打电话就行了 

1696
01:23:51,290 --> 01:23:54,640
请注意 我们必须按顺序显式调用StartCoroutine例程

1697
01:23:54,640 --> 01:23:58,760
才能触发协同程序功能 

1698
01:23:58,760 --> 01:24:02,410
要做到这一点 它返回所谓的IEnumerator 

1699
01:24:02,410 --> 01:24:05,570
所以很多细节 你不一定需要知道

1700
01:24:05,570 --> 01:24:06,760
的低级别细节 

1701
01:24:06,760 --> 01:24:10,120
我当然不知道每件事的所有细节

1702
01:24:10,120 --> 01:24:11,560
这发生在联合航空公司 

1703
01:24:11,560 --> 01:24:13,810
但要知道 如果您想要异步行为 

1704
01:24:13,810 --> 01:24:15,730
您的函数需要返回IEnumerator 

1705
01:24:15,730 --> 01:24:22,750
C#知道它是一个生成器函数 它将产生控制

1706
01:24:22,750 --> 01:24:24,910
在预定的时间 

1707
01:24:24,910 --> 01:24:27,250
它会为你管理它 

1708
01:24:27,250 --> 01:24:29,590
要触发它 你需要启动协和程序 

1709
01:24:29,590 --> 01:24:33,280
这是Unity为您定义的功能 

1710
01:24:33,280 --> 01:24:38,555
那么 对于这一机制如何在高层运作 至少有什么问题吗？

1711
01:24:38,555 --> 01:24:40,888
观众：我对Year这个词的语法有点困惑 

1712
01:24:40,888 --> 01:24:42,390
收益率是否会回归--

1713
01:24:42,390 --> 01:24:44,680
科尔顿·奥格登：是的 

1714
01:24:44,680 --> 01:24:51,670
Year接受一些东西 而你得到一个新的来实例化一个新的WaitForSecond 

1715
01:24:51,670 --> 01:24:56,451
这就是生成对象的语法的方式 

1716
01:24:56,451 --> 01:24:56,950
收益率--

1717
01:24:56,950 --> 01:24:58,482
观众：它的回归是什么？

1718
01:24:58,482 --> 01:25:00,940
科尔顿·奥格登：它正在将这一点返还给Year指令 

1719
01:25:00,940 --> 01:25:05,260
然后 让步指令就会产生这种效果 

1720
01:25:05,260 --> 01:25:06,980
不过 这有点奇怪 

1721
01:25:06,980 --> 01:25:09,970
但你真的只需要--

1722
01:25:09,970 --> 01:25:11,900
这是一个常见的模式 你会看到 

1723
01:25:11,900 --> 01:25:13,316
所以你会习惯的 

1724
01:25:16,360 --> 01:25:20,080
老实说 这可能是语法上比较困难的事情之一

1725
01:25:20,080 --> 01:25:20,600
关于团结 

1726
01:25:20,600 --> 01:25:22,349
所以我的意思是 一旦你理解了这一点 

1727
01:25:22,349 --> 01:25:25,840
在这一点上 几乎任何其他事情都相当容易 

1728
01:25:25,840 --> 01:25:28,930
我会说这是更奇怪的一面之一 

1729
01:25:28,930 --> 01:25:32,680
因为在Lua和Love2D 以及这些环境中 

1730
01:25:32,680 --> 01:25:37,540
用同样多的语法来做这类事情会更容易一些 

1731
01:25:37,540 --> 01:25:42,400
C# 作为一个静态类型的环境 为了获得相同的行为 

1732
01:25:42,400 --> 01:25:46,290
你必须走得更远一点 

1733
01:25:46,290 --> 01:25:48,460
按他们自己的方式做事 

1734
01:25:48,460 --> 01:25:54,190
但这就是让异步行为在C#中工作 

1735
01:25:54,190 --> 01:26:01,290
而在联合 通常 为了避免混乱的州管理 

1736
01:26:01,290 --> 01:26:06,790
您将经常使用协程 它们是IE分子运算符

1737
01:26:06,790 --> 01:26:09,910
使用WaitForSecond对象 

1738
01:26:09,910 --> 01:26:14,290
只要确保用StartCoroutine触发它们 

1739
01:26:14,290 --> 01:26:17,115
然后调用该函数 就像它是对象一样 

1740
01:26:17,115 --> 01:26:17,740
简单得不得了 

1741
01:26:20,710 --> 01:26:25,960
而飞机产卵的行为 硬币产卵的行为 

1742
01:26:25,960 --> 01:26:27,950
以此类推 它们都相当相似 

1743
01:26:27,950 --> 01:26:31,330
因此 开始协和典当币 

1744
01:26:31,330 --> 01:26:32,560
然后 尽管这是真的 

1745
01:26:32,560 --> 01:26:36,670
所以硬币--这一排垂直地产生随机数量的硬币 

1746
01:26:36,670 --> 01:26:40,387
所以你可以喝一杯 或者你也可以喝两杯 

1747
01:26:40,387 --> 01:26:42,220
然后 对于每一个 实例化它们

1748
01:26:42,220 --> 01:26:46,330
在y轴上的任意位置 

1749
01:26:46,330 --> 01:26:49,180
在这里 随机负10到10 

1750
01:26:49,180 --> 01:26:52,540
在这种情况下 是四元数 身份 因为我们不想

1751
01:26:52,540 --> 01:26:58,250
让它们以不同的方式旋转 这是我之前提到过的 

1752
01:26:58,250 --> 01:27:01,350
因此 Quaternion.Identity只是表示不对对象应用旋转 

1753
01:27:01,350 --> 01:27:05,510
所以无论它的底座旋转是什么 它都是预制的 

1754
01:27:05,510 --> 01:27:08,000
所以当你在编辑器中看到它时 它将是任何东西 

1755
01:27:08,000 --> 01:27:12,270
当你创建一个新的 这将是它的默认旋转 

1756
01:27:12,270 --> 01:27:15,230
所以基本上等同于 不要旋转任何东西 

1757
01:27:18,200 --> 01:27:25,400
然后 与我们之前看到的一样 生成一个新的WaitForSecond 

1758
01:27:25,400 --> 01:27:29,660
在这种情况下 1到5 所以频率比飞机高一点 

1759
01:27:29,660 --> 01:27:30,230
平均来说 

1760
01:27:30,230 --> 01:27:31,870
更多的硬币 

1761
01:27:31,870 --> 01:27:37,580
因为飞机 我相信 是3到10秒 所以每3到10秒 

1762
01:27:37,580 --> 01:27:39,920
基本上就是这样 

1763
01:27:39,920 --> 01:27:44,660
然后我们启动协和程序 就像我们以前对飞机产卵器所做的那样 

1764
01:27:44,660 --> 01:27:47,330
最后是摩天大楼的发源地 

1765
01:27:47,330 --> 01:27:52,690
在这种情况下 我们只有一个预制硬币 

1766
01:27:52,690 --> 01:27:57,230
我们只有一个飞机预制件 但我们有三个摩天大楼预制件 

1767
01:27:57,230 --> 01:28:01,070
所以真正的随机 这里的Range开始发挥作用 

1768
01:28:01,070 --> 01:28:05,010
因为这就是我们随机产生不同颜色的摩天大楼的方法 

1769
01:28:05,010 --> 01:28:07,100
就像我之前说的 这是可以推断的

1770
01:28:07,100 --> 01:28:09,016
任何你想要的游戏环境 

1771
01:28:09,016 --> 01:28:11,120
其中您有多种类型的对象

1772
01:28:11,120 --> 01:28:13,220
不仅仅是颜色交换 

1773
01:28:13,220 --> 01:28:17,180
你想随机选择它们 

1774
01:28:17,180 --> 01:28:20,000
我们正在做我们以前做过的所有事情 

1775
01:28:20,000 --> 01:28:25,850
而且 在这里 我们可以看到他们有一个随机的机会

1776
01:28:25,850 --> 01:28:30,610
1/4 所以有25%的机会提高速度 

1777
01:28:30,610 --> 01:28:35,950
所以摩天大楼产生者实际上有--这是与任务相关的--

1778
01:28:35,950 --> 01:28:41,570
摩天大楼派生程序在这里有一个名为速度的浮点 默认情况下是10 

1779
01:28:41,570 --> 01:28:46,460
这推动了摩天大楼的滚动速度 硬币

1780
01:28:46,460 --> 01:28:48,340
还有飞机 

1781
01:28:48,340 --> 01:28:53,388
所以当我们称之为静态时 我们知道那是什么意思吗？

1782
01:28:53,388 --> 01:28:53,888
嗯?

1783
01:28:53,888 --> 01:29:00,730
观众：嗯 所有的[INAUDIBLE]对象[INAUDIBLE]都是一样的 

1784
01:29:00,730 --> 01:29:01,500
科尔顿·奥格登：是的 

1785
01:29:01,500 --> 01:29:07,290
所以不管我们创造了多少摩天大楼 

1786
01:29:07,290 --> 01:29:10,410
他们都将分享这个领域的速度 

1787
01:29:10,410 --> 01:29:13,590
在所有情况下 它总是等于相同的量 

1788
01:29:13,590 --> 01:29:15,660
所以静态意味着它是类的一部分 

1789
01:29:15,660 --> 01:29:18,090
它属于摩天大楼Spawner级 

1790
01:29:18,090 --> 01:29:21,390
它不属于SkycreperSpawner对象 

1791
01:29:21,390 --> 01:29:26,340
所以我们自己也不想在这场比赛中改变这一点 

1792
01:29:26,340 --> 01:29:32,740
但以飞机为例 请注意 在我们的更新功能中

1793
01:29:32,740 --> 01:29:37,360
这里 如果转换位置x小于负25 

1794
01:29:37,360 --> 01:29:38,740
我们应该摧毁这架飞机 

1795
01:29:38,740 --> 01:29:41,180
所以当它从屏幕上消失的时候 我们应该毁了它 

1796
01:29:41,180 --> 01:29:47,110
但如果不是 那么我们想要平移这个物体

1797
01:29:47,110 --> 01:29:52,780
在x轴上被负的摩天大楼斯帕纳 速度乘2倍

1798
01:29:52,780 --> 01:29:54,610
Time.Delta时间 

1799
01:29:54,610 --> 01:29:57,040
所以我们在x轴上平移它 我们

1800
01:29:57,040 --> 01:30:00,940
使用摩天大楼Spawner.SPEED作为核心乘法器 

1801
01:30:00,940 --> 01:30:03,850
然后如果我们看看硬币--

1802
01:30:03,850 --> 01:30:04,480
同样的事情 

1803
01:30:08,740 --> 01:30:11,350
我应该问 设计时需要考虑的一个因素是什么？

1804
01:30:11,350 --> 01:30:12,610
如果我们看到的是这个--

1805
01:30:12,610 --> 01:30:13,840
所有这些组件？

1806
01:30:13,840 --> 01:30:17,380
比方说 我们正试图像我们一样脱钩

1807
01:30:17,380 --> 01:30:19,580
可以 而且我们可以设计得很好 

1808
01:30:19,580 --> 01:30:23,110
我们可以考虑什么 例如 注意到 

1809
01:30:23,110 --> 01:30:29,135
这存在于硬币中 而这存在于飞机中？

1810
01:30:33,750 --> 01:30:35,250
观众：再问一遍 问题是什么？

1811
01:30:35,250 --> 01:30:37,374
科尔顿·奥格登：那么 我们如何才能更好地设计这项技术呢？

1812
01:30:37,374 --> 01:30:39,120
注意 我们有--

1813
01:30:39,120 --> 01:30:43,290
并考虑到Unity中的这个组件模型--

1814
01:30:43,290 --> 01:30:45,738
例如 我们可以用这个做什么？

1815
01:30:45,738 --> 01:30:50,420
观众：这样团结才能更好 

1816
01:30:50,420 --> 01:30:53,640
科尔顿·奥格登：我是这么想的 因为飞机和硬币--

1817
01:30:53,640 --> 01:30:55,890
首先 它不属于产卵池 

1818
01:30:55,890 --> 01:30:58,230
因为产卵者的工作是生产硬币 

1819
01:30:58,230 --> 01:31:00,980
但是硬币和飞机--他们有他们的行为 对吗？

1820
01:31:00,980 --> 01:31:03,320
他们有自己的更新行为 

1821
01:31:03,320 --> 01:31:06,800
但他们都在做同样的事情 向左滚动 

1822
01:31:06,800 --> 01:31:09,330
然后在负25度时去产卵 

1823
01:31:09,330 --> 01:31:13,940
所以这里的设计考虑因素是 也许我们有一个滚动组件 

1824
01:31:13,940 --> 01:31:15,395
对吗？

1825
01:31:15,395 --> 01:31:17,300
或滚动和销毁组件 

1826
01:31:17,300 --> 01:31:20,697
或者仅仅是具有可选销毁标志的滚动组件 

1827
01:31:20,697 --> 01:31:23,780
然后我们就把这个放在我们想要自动滚动的任何东西上

1828
01:31:23,780 --> 01:31:25,904
到左侧屏幕并取消产卵 而不是让

1829
01:31:25,904 --> 01:31:28,530
在每个单独的类中进行编码 

1830
01:31:28,530 --> 01:31:30,800
所以 如果你曾经看过你的代码 

1831
01:31:30,800 --> 01:31:39,410
例如 你可以看到 这个和这个是完全相同的 特别是

1832
01:31:39,410 --> 01:31:42,560
在Unity中 由于组件非常灵活 

1833
01:31:42,560 --> 01:31:46,340
试着想一想怎样才能把它变成它自己的组件 

1834
01:31:46,340 --> 01:31:48,800
观众：那么你会把硬币放在哪里呢？

1835
01:31:48,800 --> 01:31:50,258
科尔顿·奥格登：你自己做的 

1836
01:31:50,258 --> 01:31:53,210
所以如果我们进入这里 进入我们的脚本程序 然后

1837
01:31:53,210 --> 01:31:56,870
写了一个新剧本 

1838
01:31:56,870 --> 01:31:59,600
然后我们称它为可滚动的 

1839
01:31:59,600 --> 01:32:02,720
然后我们双击它 它将在我们的编辑器中打开

1840
01:32:02,720 --> 01:32:04,434
这是我们在偏好中选择的 

1841
01:32:04,434 --> 01:32:07,100
默认情况下 它将是具有较新版本的Visual Studio 

1842
01:32:07,100 --> 01:32:09,320
但现在我们有了一个新的可滚动行为 

1843
01:32:09,320 --> 01:32:10,580
然后我们需要做的就是--

1844
01:32:10,580 --> 01:32:12,470
我们会说 哦--

1845
01:32:12,470 --> 01:32:13,970
不是那个 

1846
01:32:13,970 --> 01:32:17,360
如果--再一次 我不能打字 

1847
01:32:17,360 --> 01:32:23,150
Transform.postion.x小于负25 

1848
01:32:23,150 --> 01:32:25,850
摧毁游戏对象 对吧？

1849
01:32:25,850 --> 01:32:30,510
所以这和我们之前看到的行为是一模一样的 

1850
01:32:30,510 --> 01:32:35,120
所以现在我们可以把所有这些都从硬币里拿出来--

1851
01:32:35,120 --> 01:32:38,450
我们可以把这个拿出来 我们可以把这个拿出来 然后

1852
01:32:38,450 --> 01:32:42,710
只需添加到飞机和硬币预制件中 

1853
01:32:42,710 --> 01:32:44,600
我们只需添加这个新的可滚动预制件 

1854
01:32:44,600 --> 01:32:45,680
它会帮我们解决这个问题的 

1855
01:32:45,680 --> 01:32:46,180
嗯 

1856
01:32:46,180 --> 01:32:48,330
观众：你怎么补充这一点？

1857
01:32:48,330 --> 01:32:50,330
科尔顿·奥格登：所以如果我们要回到团结号--

1858
01:32:50,330 --> 01:32:54,230
所以问题是 你将如何将组件添加到预制件中？

1859
01:32:54,230 --> 01:32:57,410
所以在我们的预制板里 注意我们有飞机 我们有硬币 

1860
01:32:57,410 --> 01:32:58,940
我们有所有的摩天大楼 

1861
01:32:58,940 --> 01:33:00,169
所以这些都是预制板 

1862
01:33:00,169 --> 01:33:02,210
哦 我还没有详细说明如何创建

1863
01:33:02,210 --> 01:33:04,700
一个预制件 我为此道歉 

1864
01:33:04,700 --> 01:33:08,429
所以预制--你需要做的就是在场景中创建一个对象 

1865
01:33:08,429 --> 01:33:10,220
例如 我用这架直升机做到了这一点 

1866
01:33:10,220 --> 01:33:13,700
所以我要删除直升机 因为这只是一架直升机

1867
01:33:13,700 --> 01:33:14,240
预制件 

1868
01:33:14,240 --> 01:33:17,660
它实际上不会将直升机从我们的场景中删除 

1869
01:33:17,660 --> 01:33:24,796
但如果我把这架直升机开到这里 然后把它拖到这里 

1870
01:33:24,796 --> 01:33:29,720
请注意 现在我们在这里有一个预制件 

1871
01:33:29,720 --> 01:33:33,120
我们可以把这架直升机拿出来 然后在那里加一架新的 

1872
01:33:33,120 --> 01:33:36,490
所以现在我有两架直升机 

1873
01:33:36,490 --> 01:33:37,700
这就是预制件的全部内容 

1874
01:33:37,700 --> 01:33:40,070
这只是你在你的场景中制作的东西

1875
01:33:40,070 --> 01:33:44,780
你想在未来复制或复制的东西 理想情况下是通过代码 

1876
01:33:44,780 --> 01:33:50,870
请注意它显示在我们的层次视图中 

1877
01:33:50,870 --> 01:33:53,780
但很明显你不想那样 

1878
01:33:53,780 --> 01:33:57,290
但这就是你如何创造一个预制件 你找到一些东西 

1879
01:33:57,290 --> 01:34:01,850
你在游戏场景中配置好了 然后在代码中 

1880
01:34:01,850 --> 01:34:04,220
你可以实例化这个预制件

1881
01:34:04,220 --> 01:34:10,400
假设你已经把这个预制件变成了

1882
01:34:10,400 --> 01:34:11,210
实例化它 

1883
01:34:11,210 --> 01:34:13,940
在这个例子中 是飞机产卵器 

1884
01:34:13,940 --> 01:34:18,430
请注意 我们在这里调用了Instantiate 就像我们之前在第24行看到的那样 

1885
01:34:18,430 --> 01:34:21,130
但它着眼于预制构件 

1886
01:34:21,130 --> 01:34:24,980
它是一个列表 它在0和0之间的随机范围内查找

1887
01:34:24,980 --> 01:34:27,560
和预制件的长度 

1888
01:34:27,560 --> 01:34:31,280
你必须在这里声明一个公共的GameObject列表预置 

1889
01:34:31,280 --> 01:34:35,330
然后 一旦我们这样做 我们去我们的飞机产卵器在这里 

1890
01:34:35,330 --> 01:34:38,300
请注意这里有一个预制件列表 

1891
01:34:38,300 --> 01:34:44,450
所以我们实际上得到了代码的编辑器视图 数据结构 

1892
01:34:44,450 --> 01:34:48,770
我们可以添加我们想要的预制件 

1893
01:34:48,770 --> 01:34:54,560
如果我们将尺寸改为2 那么我们可以添加第二个预制件 

1894
01:34:54,560 --> 01:34:59,360
或者如果我们做10号 那么我们可以在那里放10架不同的飞机 

1895
01:34:59,360 --> 01:35:02,800
但我们只有一架飞机是我做的 所以我打算把它做成1 

1896
01:35:02,800 --> 01:35:05,480
但这是一回事 

1897
01:35:05,480 --> 01:35:08,720
这个游戏对象列表是相同的列表 只是

1898
01:35:08,720 --> 01:35:10,910
这是我们在编辑器中看到的视图 

1899
01:35:10,910 --> 01:35:13,730
这只是看待数据的不同方式 

1900
01:35:13,730 --> 01:35:16,790
Unity的好处是 如果你

1901
01:35:16,790 --> 01:35:19,640
任何一个字段都是公开的 就像这样

1902
01:35:19,640 --> 01:35:24,590
如果我做了public int someNumber 对吧？

1903
01:35:24,590 --> 01:35:27,590
我把它保存起来 回到这里 我的飞机产卵器

1904
01:35:27,590 --> 01:35:32,510
这里应该有个号码

1905
01:35:32,510 --> 01:35:34,760
然后我就可以把someNumber设置成我想要的任何值 

1906
01:35:34,760 --> 01:35:36,290
它现在什么都不做 因为

1907
01:35:36,290 --> 01:35:37,860
不会影响剧本 

1908
01:35:37,860 --> 01:35:44,090
但这是一个很好的方式来减轻代码的负担 

1909
01:35:44,090 --> 01:35:46,910
你不是在用代码做实验 

1910
01:35:46,910 --> 01:35:49,120
你没有在你的脚本中调整一些变量 

1911
01:35:49,120 --> 01:35:52,810
数字10 运行我 好的--数字12 运行它 

1912
01:35:52,810 --> 01:35:56,680
您只需在您的实际编辑器视图中将其分配到此处 

1913
01:35:56,680 --> 01:35:58,227
然后按你想要的方式调整它 

1914
01:35:58,227 --> 01:35:59,560
这样我就可以滚动它了 

1915
01:35:59,560 --> 01:36:03,010
我可以开始比赛 也可以暂停比赛 

1916
01:36:03,010 --> 01:36:05,082
观众：所以你就把它公之于众了吗？

1917
01:36:05,082 --> 01:36:06,790
科尔顿·奥格登：你必须把它公之于众 

1918
01:36:06,790 --> 01:36:07,240
一点儿没错 

1919
01:36:07,240 --> 01:36:08,320
观众：哦 那就说明问题了 

1920
01:36:08,320 --> 01:36:09,070
科尔顿·奥格登：是的 

1921
01:36:09,070 --> 01:36:10,240
所以我可以这样做 

1922
01:36:10,240 --> 01:36:11,490
然后我应该能够--

1923
01:36:11,490 --> 01:36:14,170
如果我想的话 我现在可以把它改成67 

1924
01:36:14,170 --> 01:36:18,070
所以如果这真的对我的游戏世界产生了某种影响--

1925
01:36:18,070 --> 01:36:21,490
如果我的游戏依赖于这个数字是否有意义--

1926
01:36:21,490 --> 01:36:22,980
这将更新场景 

1927
01:36:22,980 --> 01:36:25,540
所以你可以制造任何东西--你可以用这种方式调试 

1928
01:36:25,540 --> 01:36:29,190
或者 您可以通过这种方式更多地定制您的组件 

1929
01:36:29,190 --> 01:36:33,220
但这只是一个巨大的灵活性 

1930
01:36:33,220 --> 01:36:37,630
这就是我们如何从这个预制板列表中实例化它的 

1931
01:36:37,630 --> 01:36:39,640
这是一张游戏物品的清单 

1932
01:36:39,640 --> 01:36:42,460
我们已经向联合军团明确表示过 

1933
01:36:42,460 --> 01:36:45,580
编辑会知道 好的 这些都是游戏对象 

1934
01:36:45,580 --> 01:36:47,710
因此 预制板是游戏对象 

1935
01:36:47,710 --> 01:36:51,520
所以我们可以把其中的任何一个放入这个领域

1936
01:36:51,520 --> 01:36:55,870
这里 这个元素0字段 或者我们有多少个字段 

1937
01:36:55,870 --> 01:36:59,410
它将在代码中随机选择其中一个 

1938
01:36:59,410 --> 01:37:01,690
然后实例化它 

1939
01:37:01,690 --> 01:37:04,374
因此 任何关于预制板如何工作的问题 或实例化 

1940
01:37:04,374 --> 01:37:05,290
或诸如此类的事？

1941
01:37:07,721 --> 01:37:08,220
好的 

1942
01:37:11,118 --> 01:37:14,500
观众：每个预制件有没有唯一的编号？

1943
01:37:14,500 --> 01:37:16,750
科尔顿·奥格登：每个预制件都有一个唯一的编号吗？

1944
01:37:16,750 --> 01:37:18,250
不是唯一的数字 

1945
01:37:18,250 --> 01:37:21,880
它们只是您文件夹中的所有资产 

1946
01:37:21,880 --> 01:37:26,170
他们有一种对你隐藏的统一的标识 

1947
01:37:26,170 --> 01:37:28,180
如果你看的话 你可能会看到它 

1948
01:37:28,180 --> 01:37:31,180
他们可能有某种生成的ID或类似的东西 所以

1949
01:37:31,180 --> 01:37:33,380
这是它知道的 在场景下 

1950
01:37:33,380 --> 01:37:38,380
但这并不是您在实际代码中担心的问题 

1951
01:37:38,380 --> 01:37:41,540
我们在这里创建了一个列表 它只是--

1952
01:37:41,540 --> 01:37:43,720
它预计会有一些数字 

1953
01:37:43,720 --> 01:37:44,832
它不知道有多少人 

1954
01:37:44,832 --> 01:37:47,290
然后 在编辑器中 您实际上可以告诉它有多少 

1955
01:37:50,830 --> 01:37:55,630
因为您在中显示的每个列表

1956
01:37:55,630 --> 01:37:58,420
编辑器将显示此大小字段 

1957
01:37:58,420 --> 01:38:00,850
这只是编辑抽象的一部分 

1958
01:38:00,850 --> 01:38:04,030
该编辑器对许多不同的对象进行了抽象 

1959
01:38:04,030 --> 01:38:07,630
您可以在您的MonoBehaviour中创建许多不同的对象 

1960
01:38:07,630 --> 01:38:12,220
并将其公之于众 Unity将对他们有不同的看法 

1961
01:38:12,220 --> 01:38:14,596
比如颜色选择器之类的东西 

1962
01:38:14,596 --> 01:38:17,470
我现在还不知道确切的物品 但如果你把一个公共颜色

1963
01:38:17,470 --> 01:38:20,081
在你的MonoBehavior或类似的地方 

1964
01:38:20,081 --> 01:38:23,080
实际上你会在这里得到一个颜色选择器 你可以为它选择一种颜色 

1965
01:38:23,080 --> 01:38:24,560
这真是太棒了 

1966
01:38:24,560 --> 01:38:27,190
有很多不同的定制视图 

1967
01:38:30,529 --> 01:38:33,070
我认为 实际上 平行光可能就是一个例子 

1968
01:38:33,070 --> 01:38:34,510
看到这个颜色了吗？

1969
01:38:34,510 --> 01:38:37,300
这是代码中的某个地方 

1970
01:38:37,300 --> 01:38:40,040
有一种公共颜色的东西 

1971
01:38:40,040 --> 01:38:42,520
然后在编辑器中 当您实际编辑它时 

1972
01:38:42,520 --> 01:38:43,600
你可以选择颜色 

1973
01:38:43,600 --> 01:38:46,400
而Unity让你可以选择在任何你想要的地方制造它 

1974
01:38:46,400 --> 01:38:50,740
请注意 它实际上影响了那里的背景 

1975
01:38:50,740 --> 01:38:52,690
“团结”的一大优势是 

1976
01:38:52,690 --> 01:38:56,350
以及真正使您的组件可定制的原因 

1977
01:38:56,350 --> 01:39:01,390
您的数据、代码、

1978
01:39:01,390 --> 01:39:05,485
以及您对数据的编辑视图 

1979
01:39:05,485 --> 01:39:07,360
减轻你编程的负担 

1980
01:39:07,360 --> 01:39:10,630
你也更容易犯错 

1981
01:39:10,630 --> 01:39:12,640
而且也浪费了大量的时间 

1982
01:39:12,640 --> 01:39:14,620
然后就可以修改了 

1983
01:39:14,620 --> 01:39:16,900
对我来说 仅仅是说 

1984
01:39:16,900 --> 01:39:20,470
我想要这个红色 而不是颜色 

1985
01:39:20,470 --> 01:39:23,440
然后 Color.g等于某个值 Color.b等于某个值 

1986
01:39:23,440 --> 01:39:24,800
然后以这种方式进行分配 

1987
01:39:24,800 --> 01:39:26,841
这只是一个简单的例子来说明它 

1988
01:39:26,841 --> 01:39:29,890
但这其中蕴含着巨大的潜力

1989
01:39:29,890 --> 01:39:33,320
使您的组件可自定义 

1990
01:39:33,320 --> 01:39:34,570
这就是我在这里所做的 

1991
01:39:34,570 --> 01:39:43,270
因为我希望摩天大楼的创造者不只是一座摩天大楼

1992
01:39:43,270 --> 01:39:48,160
但有几栋摩天大楼 我创建了这份公共预制件清单 

1993
01:39:48,160 --> 01:39:50,770
然后我就可以从这里的单位来填充了 

1994
01:39:50,770 --> 01:39:53,620
然后说 好的 这个物体 

1995
01:39:53,620 --> 01:39:56,560
把它放到摩天大楼的孵化器里 在这些狭缝里 

1996
01:39:56,560 --> 01:40:02,200
然后我的代码知道实例化它 随机选择其中之一 

1997
01:40:02,200 --> 01:40:02,700
嗯 

1998
01:40:02,700 --> 01:40:04,986
听众：在前面的例子中 您将如何

1999
01:40:04,986 --> 01:40:09,560
既然你已经制作了可滚动的东西 你真的要开始制作它了吗？

2000
01:40:09,560 --> 01:40:12,329
你能在硬币里加点硬币吗？

2001
01:40:12,329 --> 01:40:15,370
科尔顿·奥格登：现在你将如何制作可滚动的东西？

2002
01:40:15,370 --> 01:40:15,869
你已经--

2003
01:40:15,869 --> 01:40:18,670
观众：你宣布了那个可滚动的类 对吗？

2004
01:40:18,670 --> 01:40:19,690
科尔顿·奥格登：哦 是的 

2005
01:40:19,690 --> 01:40:24,550
所以我这里有一个可滚动的脚本 

2006
01:40:24,550 --> 01:40:28,507
哦 你是指无限滚动的背景 还是可滚动的对象？

2007
01:40:28,507 --> 01:40:31,840
观众：你把它定义为当它被[INAUDIBLE]摧毁的那个..

2008
01:40:31,840 --> 01:40:32,798
科尔顿·奥格登：哦 是的 

2009
01:40:32,798 --> 01:40:35,780
为了做到这一点--我们在这里制作了可滚动的脚本 

2010
01:40:35,780 --> 01:40:38,050
所以你会去--在这种情况下 因为我们

2011
01:40:38,050 --> 01:40:42,340
将所有的硬币、摩天大楼和飞机实例化为预制件 

2012
01:40:42,340 --> 01:40:44,470
你实际上是在编辑预制件本身 

2013
01:40:44,470 --> 01:40:46,160
所以我会去这个硬币预制场 

2014
01:40:46,160 --> 01:40:48,370
我会在底部添加组件 

2015
01:40:48,370 --> 01:40:51,580
我会在那里添加Scrollable 这是一个脚本 

2016
01:40:51,580 --> 01:40:54,070
你可以看出来它是你的 因为上面写着剧本 

2017
01:40:54,070 --> 01:40:57,460
就像硬币是剧本一样 旋转剧本也是剧本 

2018
01:40:57,460 --> 01:41:01,110
这实际上是一个我不再使用的旧剧本 

2019
01:41:01,110 --> 01:41:05,200
因为我刚刚把它变成了硬币本身的一部分 

2020
01:41:05,200 --> 01:41:08,380
但这是硬币课程的另一个部分 顺便说一句 

2021
01:41:08,380 --> 01:41:14,590
这是变换吗？旋转x、y和z 相对的

2022
01:41:14,590 --> 01:41:16,340
无论是对自身还是对世界空间 

2023
01:41:16,340 --> 01:41:18,590
在这种情况下 它显示了世界空间 因为我想

2024
01:41:18,590 --> 01:41:20,370
它绕着世界的y轴旋转 

2025
01:41:20,370 --> 01:41:24,227
但如果你旋转一个物体 它自己的x y z仍然存在 

2026
01:41:24,227 --> 01:41:26,560
所以你可以让物体围绕它自己的x y旋转 

2027
01:41:26,560 --> 01:41:29,574
和z 与它在世界上的自转无关 

2028
01:41:29,574 --> 01:41:31,240
所以我想让硬币一直旋转 

2029
01:41:31,240 --> 01:41:35,450
所以在y轴上5度 

2030
01:41:35,450 --> 01:41:40,030
所以这是另一个部分 你可以把它变成自己的剧本--

2031
01:41:40,030 --> 01:41:42,190
只是一个可旋转的剧本 

2032
01:41:42,190 --> 01:41:43,390
自动旋转脚本 

2033
01:41:43,390 --> 01:41:47,590
然后把这些公共字段 比如公共x 公共y 公共z 

2034
01:41:47,590 --> 01:41:49,570
然后您可以在编辑器中更改这些设置 

2035
01:41:49,570 --> 01:41:54,970
然后真正地定制您的对象 而不必进入代码

2036
01:41:54,970 --> 01:41:56,324
它本身 

2037
01:41:56,324 --> 01:42:00,300
观众：所以你不需要做任何碰撞 实际上 你自己 

2038
01:42:00,300 --> 01:42:04,019
您只需点击按钮并输入碰撞函数即可 

2039
01:42:04,019 --> 01:42:04,810
科尔顿·奥格登：是的 

2040
01:42:04,810 --> 01:42:06,934
你不需要自己做任何碰撞 

2041
01:42:06,934 --> 01:42:09,744
因为Unity配备了3D物理引擎 

2042
01:42:09,744 --> 01:42:12,160
你必须告诉它当碰撞发生时该怎么做 

2043
01:42:12,160 --> 01:42:16,750
但你不必自己编写3D物理引擎的代码 这

2044
01:42:16,750 --> 01:42:19,710
是一项巨大的工作量 

2045
01:42:19,710 --> 01:42:21,460
当然 最大的卖点之一 

2046
01:42:21,460 --> 01:42:23,410
在Unity中做任何3D的事情 

2047
01:42:23,410 --> 01:42:26,800
我的意思是 现在很多引擎都有免费的3D引擎 

2048
01:42:26,800 --> 01:42:29,202
曾经有一段时间 它不那么流行 

2049
01:42:29,202 --> 01:42:31,619
观众：你怎么知道你撞上了什么？

2050
01:42:31,619 --> 01:42:33,910
科尔顿·奥格登：因为它有一个对撞机 

2051
01:42:38,331 --> 01:42:39,080
再说一遍它在哪里？

2052
01:42:39,080 --> 01:42:41,572
例如 是摩天大楼吗？

2053
01:42:41,572 --> 01:42:43,780
所以每座摩天大楼 当它与什么东西相撞时 

2054
01:42:43,780 --> 01:42:47,320
这个OnTriggerEnter在这个对撞器Other中传递 

2055
01:42:47,320 --> 01:42:53,014
这就是你与之碰撞的物体 

2056
01:42:53,014 --> 01:42:56,180
您可以为对象指定一个名称 然后也可以在代码中获取其名称 

2057
01:42:56,180 --> 01:42:58,599
如果你需要这么做的话 

2058
01:42:58,599 --> 01:43:01,390
在这种情况下 我们想知道是不是直升机 

2059
01:43:01,390 --> 01:43:04,160
所以我们从它那里得到了直升机控制器 

2060
01:43:04,160 --> 01:43:06,280
但在我们的游戏中 这是一种特殊情况 

2061
01:43:06,280 --> 01:43:08,290
因为只有一种物体

2062
01:43:08,290 --> 01:43:11,500
有一个非触发的对撞机 那就是直升机 

2063
01:43:11,500 --> 01:43:15,400
所以当我们遇到碰撞时 我们可以假设这是存在的 

2064
01:43:15,400 --> 01:43:20,410
但在其他情况下 我们可能想说 获取HeliController组件 

2065
01:43:20,410 --> 01:43:22,340
然后测试它是否等于空 

2066
01:43:22,340 --> 01:43:26,500
如果它等于Null 那么我们就不想做某事 

2067
01:43:26,500 --> 01:43:29,587
如果我们尝试对空对象调用EXPLODE 

2068
01:43:29,587 --> 01:43:31,420
这将是一个空指针异常 

2069
01:43:31,420 --> 01:43:33,624
然后你就会毁了你的游戏 

2070
01:43:33,624 --> 01:43:36,040
但在这种情况下 我们保证不会发生这种情况 

2071
01:43:36,040 --> 01:43:38,530
因为 就像我说的 唯一一个

2072
01:43:38,530 --> 01:43:42,900
与之相撞的不是扳机的是直升机上的物体 

2073
01:43:42,900 --> 01:43:45,085
那么 这说得通吗？

2074
01:43:45,085 --> 01:43:48,480
观众：听起来像是一个有爆炸元素的物理问题 

2075
01:43:48,480 --> 01:43:49,640
科尔顿·奥格登：哦 是的 

2076
01:43:49,640 --> 01:43:50,280
嗯 

2077
01:43:50,280 --> 01:43:52,230
这一切太真实了 

2078
01:43:55,370 --> 01:43:59,196
不过 在这种情况下 幸好爆炸只是摧毁了游戏对象

2079
01:43:59,196 --> 01:44:00,570
然后开始粒子效果 

2080
01:44:00,570 --> 01:44:04,800
因此 任何关于如何实例化的问题 

2081
01:44:04,800 --> 01:44:08,610
预制件 使用Unity编辑器 与您的模型交互

2082
01:44:08,610 --> 01:44:10,330
行为 公共变量？

2083
01:44:10,330 --> 01:44:11,905
嗯 

2084
01:44:11,905 --> 01:44:15,300
观众：你有流程 你首先把数据输入到那里 

2085
01:44:15,300 --> 01:44:19,665
然后它运行代码来加载数据 

2086
01:44:19,665 --> 01:44:23,070
或者 您还可以将值数据放入编辑器中吗？

2087
01:44:23,070 --> 01:44:24,480
科尔顿·奥格登：你不能定义--

2088
01:44:24,480 --> 01:44:27,570
所以问题是 您是否首先在编辑器中创建数据 

2089
01:44:27,570 --> 01:44:31,380
然后是代码 然后把它们以这种方式捆绑在一起？

2090
01:44:31,380 --> 01:44:34,650
为了获得新组件 您必须首先创建类--

2091
01:44:34,650 --> 01:44:37,440
你想要的模范行为

2092
01:44:37,440 --> 01:44:41,550
并为其提供编辑者实际阅读所需的公共字段 

2093
01:44:41,550 --> 01:44:45,000
因此 编辑阅读您的脚本 查看所有公共字段 

2094
01:44:45,000 --> 01:44:47,820
然后将在该编辑器中创建必要的图形用户界面元素

2095
01:44:47,820 --> 01:44:50,020
来与代码交互 

2096
01:44:50,020 --> 01:44:51,390
但这需要存在 

2097
01:44:51,390 --> 01:44:52,980
所有这些代码都需要存在 

2098
01:44:52,980 --> 01:44:56,430
具有您希望在编辑器中访问的这些公共变量的任何内容

2099
01:44:56,430 --> 01:44:59,130
需要首先存在于代码中 然后您

2100
01:44:59,130 --> 01:45:00,900
有能力在编辑器中使用它 

2101
01:45:00,900 --> 01:45:04,440
然后 它可以在这一点上进行定制 

2102
01:45:04,440 --> 01:45:08,130
还有什么问题吗？

2103
01:45:08,130 --> 01:45:09,540
好的 

2104
01:45:09,540 --> 01:45:11,460
这就是预制板 

2105
01:45:11,460 --> 01:45:13,456
所以我们以前看过纹理滚动 

2106
01:45:13,456 --> 01:45:15,580
我们会很快地看完这一点 

2107
01:45:15,580 --> 01:45:18,220
但所有的质地显示 如果我们记得的话 

2108
01:45:18,220 --> 01:45:21,450
我在这里有一个滚动的背景课程 

2109
01:45:21,450 --> 01:45:22,510
它有一个滚动速度 

2110
01:45:22,510 --> 01:45:25,387
因此 如果我们愿意 因为它是公开的 我们可以在编辑器中编辑它

2111
01:45:25,387 --> 01:45:26,595
让它变得更快或更慢 

2112
01:45:29,170 --> 01:45:31,230
但如果我们保持对我们的呈现器的引用 

2113
01:45:31,230 --> 01:45:35,550
每个对象都有一个渲染器--网格渲染器 通常用于3D对象 

2114
01:45:35,550 --> 01:45:39,900
并且该渲染器具有与其相关联的材质 

2115
01:45:39,900 --> 01:45:43,230
Unity中的所有东西都有材料 

2116
01:45:43,230 --> 01:45:45,660
而且材料不一定有质地 

2117
01:45:45,660 --> 01:45:48,570
但在这种情况下 我们的背景确实有一种质感 

2118
01:45:48,570 --> 01:45:51,000
默认情况下 它将被称为MainTex 

2119
01:45:51,000 --> 01:45:53,910
这是主纹理 如果我们想要指定一个纹理

2120
01:45:53,910 --> 01:45:55,920
在材料上进行视觉查看 

2121
01:45:55,920 --> 01:45:59,700
因此 材料通常只是一种颜色 但它也可以

2122
01:45:59,700 --> 01:46:02,350
既是一种颜色 也是一种质地 

2123
01:46:02,350 --> 01:46:04,410
因此 在这种情况下 背景是一种纹理 

2124
01:46:04,410 --> 01:46:05,993
它确实具有指定给它的纹理 

2125
01:46:05,993 --> 01:46:09,810
注意 如果我们转到背景 

2126
01:46:09,810 --> 01:46:13,590
然后这是我们实际创造的地方 

2127
01:46:13,590 --> 01:46:15,360
所以这是一种材料 

2128
01:46:15,360 --> 01:46:16,530
它有一个着色器 

2129
01:46:16,530 --> 01:46:19,037
因此 我们不会过多地讨论着色器是什么 

2130
01:46:19,037 --> 01:46:20,370
我们已经简单地谈过了 

2131
01:46:20,370 --> 01:46:24,720
在Unity中 你可以和他们一起走得更远 

2132
01:46:24,720 --> 01:46:28,860
嗯 从技术上讲 我想你可以用Love2D走得同样远--

2133
01:46:28,860 --> 01:46:34,290
2D着色器和3D着色器 至少在顶点着色器和碎片着色器中 

2134
01:46:34,290 --> 01:46:37,590
但无论出于何种意图和目的 我们都不是

2135
01:46:37,590 --> 01:46:40,560
今天我们将详细介绍着色器 

2136
01:46:40,560 --> 01:46:42,690
但它们非常相似 

2137
01:46:42,690 --> 01:46:47,247
在这种情况下 每种材质在Unity中都有一个着色器 

2138
01:46:47,247 --> 01:46:48,330
为了让它呈现出来 

2139
01:46:48,330 --> 01:46:52,170
因为渲染的任何内容都需要在Unity中进行着色 

2140
01:46:52,170 --> 01:46:54,340
但请注意 我们这里有一个纹理 

2141
01:46:54,340 --> 01:46:57,100
这就是我们之前看到的主要纹理 

2142
01:46:57,100 --> 01:46:58,904
这是这里的凹凸贴图 

2143
01:46:58,904 --> 01:47:01,320
我们没有凹凸贴图 因为我们的纹理并不凹凸不平 

2144
01:47:01,320 --> 01:47:04,170
它没有任何轮廓细节或类似的东西 

2145
01:47:04,170 --> 01:47:06,300
但您可以在此处仅选择一种纹理 

2146
01:47:06,300 --> 01:47:08,670
所以如果我想的话我可以给它那种质感 

2147
01:47:08,670 --> 01:47:10,440
或者我这里还有几个纹理 

2148
01:47:13,730 --> 01:47:14,910
这里的质地 

2149
01:47:14,910 --> 01:47:18,120
选择哪种纹理并不重要 但您可以选择一种纹理 

2150
01:47:18,120 --> 01:47:21,810
然后 这些材料就会 它会计算 

2151
01:47:21,810 --> 01:47:25,770
基于网格 如何最好地将纹理绘制到它 

2152
01:47:25,770 --> 01:47:32,520
并且您可以通过其SetTextureOffset来设置每种材质的纹理偏移

2153
01:47:32,520 --> 01:47:34,800
X轴和y轴上的函数 

2154
01:47:34,800 --> 01:47:38,850
这将改变它 有效地实现

2155
01:47:38,850 --> 01:47:41,010
滚动背景需要的是什么 

2156
01:47:41,010 --> 01:47:44,340
它会把它画出来 然后它基本上会绕到另一边 

2157
01:47:44,340 --> 01:47:48,330
这就是我们如何获得无限滚动纹理的方法 

2158
01:47:48,330 --> 01:47:51,050
我们只是设置了它的纹理偏移 

2159
01:47:51,050 --> 01:47:54,480
我们在主纹理上具体调用SetTextureOffset 

2160
01:47:54,480 --> 01:47:55,910
然后我们传入一个向量2 

2161
01:47:55,910 --> 01:47:57,720
所以只有两个数字--

2162
01:47:57,720 --> 01:47:58,650
偏移量和0 

2163
01:47:58,650 --> 01:48:01,920
因为我们不想碰y轴 所以它是0 然后偏移

2164
01:48:01,920 --> 01:48:04,590
只是随着时间的推移而增加的一些价值 

2165
01:48:04,590 --> 01:48:06,390
然后是时间 时间 回忆--

2166
01:48:06,390 --> 01:48:08,640
从比赛开始到现在时间已经开始了 

2167
01:48:08,640 --> 01:48:11,550
时间 增量时间--从最后一帧开始的时间 

2168
01:48:11,550 --> 01:48:15,480
所以我们可以在这里只做一次计算 每次都要更新 

2169
01:48:15,480 --> 01:48:17,610
然后将其乘以滚动速度得到

2170
01:48:17,610 --> 01:48:19,440
我们这里想要的卷轴数量 

2171
01:48:19,440 --> 01:48:23,710
我将其设置为0.1只是为了达到半慢速效果 

2172
01:48:23,710 --> 01:48:32,170
但在编辑器中 如果我们看一下滚动的背景 它在这里 

2173
01:48:32,170 --> 01:48:36,584
然后我把它公之于众 所以我可以很容易地把它变成1 

2174
01:48:36,584 --> 01:48:39,250
我不知道它会有多快 但会快10倍 

2175
01:48:39,250 --> 01:48:41,334
所以可能会很快 

2176
01:48:41,334 --> 01:48:42,650
是啊 

2177
01:48:42,650 --> 01:48:45,200
所以它是拖运的 

2178
01:48:45,200 --> 01:48:45,840
不过 是的 

2179
01:48:45,840 --> 01:48:50,310
所有这一切只是改变了它将纹理映射到3D表面的方式 

2180
01:48:50,310 --> 01:48:53,760
而这个3D表面 明确地说 只是一个平面 

2181
01:48:53,760 --> 01:48:55,350
所以只有一架飞机 

2182
01:48:55,350 --> 01:48:57,600
请注意 它不是从后面渲染的 

2183
01:48:57,600 --> 01:49:02,970
所以任何多边形都有一条被阴影覆盖的边

2184
01:49:02,970 --> 01:49:05,560
还有一面不会被遮挡住 

2185
01:49:05,560 --> 01:49:09,522
所以如果你看到一边是看不见的 而不是一边是看不见的 

2186
01:49:09,522 --> 01:49:10,230
这不是个窃听器 

2187
01:49:10,230 --> 01:49:12,807
这是一个特点 

2188
01:49:12,807 --> 01:49:14,640
这就是事物的纹理滚动的一面 

2189
01:49:14,640 --> 01:49:18,160
有人对它的工作原理有任何疑问吗？

2190
01:49:18,160 --> 01:49:20,747
在未来 我们不会真的需要它 

2191
01:49:20,747 --> 01:49:22,080
这不是任务的一部分 

2192
01:49:22,080 --> 01:49:24,500
但这与我们以前做过的事情有关 

2193
01:49:24,500 --> 01:49:27,214
所以我想报道一下会很有趣 

2194
01:49:27,214 --> 01:49:28,630
我们最后要看的是音频 

2195
01:49:28,630 --> 01:49:30,190
音频非常简单 

2196
01:49:30,190 --> 01:49:37,440
在Unity中 您只需要一个音频源和一个音频监听器即可进行音频操作 

2197
01:49:37,440 --> 01:49:39,150
因此 信号源播放音频 

2198
01:49:39,150 --> 01:49:44,670
所以詹姆斯 如果你是一个音频源 我就是一个音频听众 

2199
01:49:44,670 --> 01:49:46,920
我在听音频 然后回放

2200
01:49:46,920 --> 01:49:52,770
当我在游戏世界中听到任何类型的音频来源时 对着扬声器说 

2201
01:49:52,770 --> 01:49:56,820
所以你可以有无限的音频源 但理想情况下只有一个音频收听者 

2202
01:49:56,820 --> 01:50:02,550
它通常是你用来画画的任何主相机 

2203
01:50:02,550 --> 01:50:05,520
然后 Unity中的声音可以是2D或3D 

2204
01:50:05,520 --> 01:50:10,110
在这种情况下 我在游戏中输入的所有声音都是2D的 

2205
01:50:10,110 --> 01:50:12,560
这就是这里的空间融合 

2206
01:50:12,560 --> 01:50:15,570
请注意 这里有一个2D到3D的幻灯片 

2207
01:50:15,570 --> 01:50:17,820
因此 根据声音的位置进行计算 

2208
01:50:17,820 --> 01:50:19,380
它在游戏空间里听起来怎么样 

2209
01:50:19,380 --> 01:50:23,430
这是基于它有多远 以及它在你的哪一边 

2210
01:50:23,430 --> 01:50:27,150
所以主摄像头有音乐的音频源 

2211
01:50:27,150 --> 01:50:29,730
所以它马上就开始播放音乐了 

2212
01:50:29,730 --> 01:50:31,870
注意 我们不需要对这些代码进行任何编码 

2213
01:50:31,870 --> 01:50:34,000
我刚在摄像机上装了一个音频源 

2214
01:50:34,000 --> 01:50:38,340
然后有一个唤醒时播放复选框和一个循环复选框 

2215
01:50:38,340 --> 01:50:40,260
所以通常我们会做这样的事--

2216
01:50:40,260 --> 01:50:43,650
在游戏代码的开头 将循环设置为真 然后

2217
01:50:43,650 --> 01:50:44,595
播放信号源 

2218
01:50:44,595 --> 01:50:46,720
在这种情况下 我们不需要做这些事情 

2219
01:50:46,720 --> 01:50:49,260
这是Unity默认情况下提供给我们的 

2220
01:50:49,260 --> 01:50:51,106
观众：你把音频放在摄像机上了吗？

2221
01:50:51,106 --> 01:50:51,855
科尔顿·奥格登：是的 

2222
01:50:51,855 --> 01:50:53,070
观众：你可以把它涂在任何东西上 

2223
01:50:53,070 --> 01:50:54,876
科尔顿·奥格登：你可以把它涂在任何你想要的东西上 

2224
01:50:54,876 --> 01:50:56,700
观众：声音是相对于那个物体的 

2225
01:50:56,700 --> 01:50:59,075
科尔顿·奥格登：声音是相对于那个物体的 是的 

2226
01:51:01,439 --> 01:51:01,980
那是音频 

2227
01:51:01,980 --> 01:51:03,420
这相当简单 

2228
01:51:03,420 --> 01:51:05,460
我是说 这是一种艺术形式

2229
01:51:05,460 --> 01:51:06,840
你想要在你的游戏世界中定位东西 

2230
01:51:06,840 --> 01:51:09,030
以及你想让他们听起来怎么样 诸如此类 

2231
01:51:09,030 --> 01:51:10,738
你可以用它变得更复杂 

2232
01:51:10,738 --> 01:51:14,360
但这就是你做基本2D的方法 在这种情况下 音频 

2233
01:51:14,360 --> 01:51:16,110
但你也可以很容易地做3D音频

2234
01:51:16,110 --> 01:51:19,620
通过将此设置从0设置为0到1 

2235
01:51:19,620 --> 01:51:21,660
你也可以让它或多或少地变成3D的 

2236
01:51:21,660 --> 01:51:24,290
如果它不是一直到1 它将在某种程度上是2D的 

2237
01:51:24,290 --> 01:51:27,660
因此 无论如何 你都会听到其中的一些内容 其中一些将是3D的 

2238
01:51:27,660 --> 01:51:29,977
然后将其设置为1 它将是纯3D的 

2239
01:51:29,977 --> 01:51:32,310
所以 如果声音传到足够远的地方 你根本听不到 

2240
01:51:35,640 --> 01:51:40,240
爆炸声也会被触发 

2241
01:51:40,240 --> 01:51:41,520
所以这发生在--

2242
01:51:41,520 --> 01:51:44,130
我马上就忘了它是在哪里触发的 

2243
01:51:49,000 --> 01:51:55,020
我相信它在直升机爆炸功能里？

2244
01:51:55,020 --> 01:51:55,590
啊 是 

2245
01:52:01,435 --> 01:52:04,560
我在场景中创建了一个具有爆炸音频源的对象

2246
01:52:04,560 --> 01:52:05,220
声音 

2247
01:52:05,220 --> 01:52:08,470
因为我把这件事公之于众 所以我可以把它放在这个物体上 

2248
01:52:08,470 --> 01:52:12,130
所以在任何时候都会引用到那个音频源 

2249
01:52:12,130 --> 01:52:16,230
因此 每当我们调用此分解方法时 我都会触发爆炸性声音 

2250
01:52:16,230 --> 01:52:17,754
在直升机控制器上 

2251
01:52:17,754 --> 01:52:20,670
因为我没有把它放在这个物体上 因为我们摧毁了

2252
01:52:20,670 --> 01:52:24,180
一旦我们发生碰撞 这个物体就会消失 

2253
01:52:24,180 --> 01:52:27,515
所以我不想把爆炸声

2254
01:52:27,515 --> 01:52:30,390
这个物体上的音频源 因为它在那里会被摧毁 

2255
01:52:30,390 --> 01:52:33,270
一旦我们摧毁它 它就不能有效地播放音频 

2256
01:52:33,270 --> 01:52:35,380
所以我们必须把它放在现场的其他地方 

2257
01:52:35,380 --> 01:52:40,505
我也可以让这个物体隐形 但我没有 

2258
01:52:40,505 --> 01:52:41,130
我把它毁了 

2259
01:52:44,670 --> 01:52:46,270
所以 是的 

2260
01:52:46,270 --> 01:52:51,930
这就是这个爆炸声物体 如果我们看一下直升机 

2261
01:52:51,930 --> 01:52:57,910
在直升机控制器中 它一直在这里 

2262
01:52:57,910 --> 01:53:01,780
请注意 它引用了一个爆炸粒子

2263
01:53:01,780 --> 01:53:03,760
系统和爆炸声 

2264
01:53:03,760 --> 01:53:08,320
我们只需有效地点击并将对象从这里拖到这里

2265
01:53:08,320 --> 01:53:09,550
把他们两个配对 

2266
01:53:09,550 --> 01:53:11,710
然后是它所指的脚本

2267
01:53:11,710 --> 01:53:14,170
TO将始终引用那些 只要这些

2268
01:53:14,170 --> 01:53:15,580
都是有目的的 

2269
01:53:15,580 --> 01:53:18,010
请注意 我们还公开了硬币总数 

2270
01:53:18,010 --> 01:53:19,660
所以我想我可以用它来做实验 

2271
01:53:19,660 --> 01:53:22,900
然后速度--我们把这件事公之于众 这样你就可以让直升机

2272
01:53:22,900 --> 01:53:25,100
如果你愿意 可以更快 也可以更慢 

2273
01:53:25,100 --> 01:53:30,987
因此 您会发现将这些字段中的许多字段公之于众是很有用的

2274
01:53:30,987 --> 01:53:32,320
只是给你做个实验 

2275
01:53:32,320 --> 01:53:34,930
而且这样做也不会有真正的坏处 

2276
01:53:34,930 --> 01:53:39,452
因为人们不会在编辑器中真正看到这一点

2277
01:53:39,452 --> 01:53:40,660
当他们下载你的游戏时 

2278
01:53:40,660 --> 01:53:43,210
因此 出于调试目的 请尽可能多地公开 

2279
01:53:43,210 --> 01:53:46,027
尽情享受吧 

2280
01:53:46,027 --> 01:53:46,735
但那是音频 

2281
01:53:46,735 --> 01:53:48,600
音频源产生声音 

2282
01:53:48,600 --> 01:53:50,260
音频收听者收听声音 

2283
01:53:50,260 --> 01:53:53,050
让它通过你的电脑扬声器

2284
01:53:53,050 --> 01:53:57,460
或者您的默认音频系统是什么 

2285
01:53:57,460 --> 01:54:01,360
这只是两个人在镜头前的展示 

2286
01:54:01,360 --> 01:54:03,070
这就是音频 

2287
01:54:03,070 --> 01:54:08,384
那么 对于音频是如何工作的 有什么问题吗？

2288
01:54:08,384 --> 01:54:09,280
好的 

2289
01:54:09,280 --> 01:54:11,321
在我们结束之前还有几件事要做 

2290
01:54:11,321 --> 01:54:14,380
因此 资产商店可能是Unity最重要的事情之一

2291
01:54:14,380 --> 01:54:16,630
这就能卖出它 

2292
01:54:16,630 --> 01:54:20,590
所以通常情况下 简单地得到一些东西要容易得多 

2293
01:54:20,590 --> 01:54:23,560
无论它是一个图书馆 如果你在编程 或者其他什么 

2294
01:54:23,560 --> 01:54:25,930
得到一些为你实现的东西 

2295
01:54:25,930 --> 01:54:29,950
这样你就不必自己去实现它了 

2296
01:54:29,950 --> 01:54:32,680
在这种情况下 有一个快速开发的RPG系统

2297
01:54:32,680 --> 01:54:36,850
视觉脚本系统看起来类似于虚幻 

2298
01:54:36,850 --> 01:54:43,990
Asset Store中有一大堆东西--模型、脚本、音频、编辑器

2299
01:54:43,990 --> 01:54:44,800
工具包 

2300
01:54:44,800 --> 01:54:45,820
很多很酷的东西 

2301
01:54:45,820 --> 01:54:48,190
很多都是免费的 如果你想尝试的话 

2302
01:54:48,190 --> 01:54:52,660
所以我在这个游戏中要处理的很多资产

2303
01:54:52,660 --> 01:54:56,312
是免费的 就像硬币和其他一些捆绑在一起的东西一样 

2304
01:54:56,312 --> 01:54:58,770
有很多非常酷的东西和非常酷的系统

2305
01:54:58,770 --> 01:55:00,340
以10美元或20美元的价格帮你 

2306
01:55:00,340 --> 01:55:02,830
你可以花一点钱 然后

2307
01:55:02,830 --> 01:55:06,310
马上完成你游戏的25% 

2308
01:55:06,310 --> 01:55:08,860
然后你就可以离发货更近了 

2309
01:55:08,860 --> 01:55:12,790
所以我认为看看Asset Store是非常有价值的

2310
01:55:12,790 --> 01:55:15,310
思考着如何通过这种方式节省时间 

2311
01:55:15,310 --> 01:55:18,830
如果你真的想把一款游戏运到市场上去 

2312
01:55:18,830 --> 01:55:21,070
所以一定要去资产商店看看 

2313
01:55:21,070 --> 01:55:24,220
看看有没有什么能让你的生活更轻松

2314
01:55:24,220 --> 01:55:25,930
当谈到开发游戏时 

2315
01:55:25,930 --> 01:55:30,940
因为我知道我已经用过好几次了 而且我很少后悔这样做 

2316
01:55:30,940 --> 01:55:35,120
所以作业8会非常简单 

2317
01:55:35,120 --> 01:55:39,820
因此 在第二部分 游戏中存在一个错误

2318
01:55:39,820 --> 01:55:45,400
在那里 如果你一次又一次地死去 滚动速度永远不会重置 

2319
01:55:45,400 --> 01:55:48,940
因此 它会保持更快 而且永远更快 

2320
01:55:48,940 --> 01:55:50,890
但这只是一句话而已 

2321
01:55:50,890 --> 01:55:54,010
我想让你们找到解决办法 鉴于我们知道 

2322
01:55:54,010 --> 01:55:55,390
考虑到我们今天所看到的 

2323
01:55:55,390 --> 01:55:57,880
这里有一个关于静态变量的提示 

2324
01:55:57,880 --> 01:56:01,540
因此 它也将在规范中详细说明 

2325
01:56:01,540 --> 01:56:03,010
但这是一个简单的部分 

2326
01:56:03,010 --> 01:56:05,665
这一部分也相当容易 因为它真正的

2327
01:56:05,665 --> 01:56:08,740
采用了我们已经看到的相同的东西--

2328
01:56:08,740 --> 01:56:10,570
硬币生成器和硬币--

2329
01:56:10,570 --> 01:56:16,780
然后制造除了硬币外还能以更罕见的速度繁殖的宝石 

2330
01:56:16,780 --> 01:56:19,150
这些宝石应该值五个硬币 

2331
01:56:19,150 --> 01:56:22,765
所以当你碰到宝石时 只需在硬币总数上加5 

2332
01:56:22,765 --> 01:56:25,392
如果你撞到一枚硬币 硬币总数加1 

2333
01:56:25,392 --> 01:56:27,100
作业8基本上就是这些了 

2334
01:56:27,100 --> 01:56:31,750
因此 下一次 我们将深入到Unity中的第一人称游戏 

2335
01:56:31,750 --> 01:56:35,080
因此 我们将看看我们免费获得的一些功能 

2336
01:56:35,080 --> 01:56:39,100
我们将实现一个简单的迷宫游戏 您可以在其中导航 

2337
01:56:39,100 --> 01:56:41,080
它将是黑暗的 有点吓人的 类似的

2338
01:56:41,080 --> 01:56:43,600
这是一款移动VR游戏 名为《恐怖大厅》 

2339
01:56:43,600 --> 01:56:48,160
我们将实际测试Unity的VR 并尝试在这里安装VR耳机

2340
01:56:48,160 --> 01:56:51,080
这样人们就可以查看这一点 

2341
01:56:51,080 --> 01:56:51,580
凉爽的 

2342
01:56:51,580 --> 01:56:52,121
非常感谢 

2343
01:56:52,121 --> 01:56:54,030
下次再见了 
