1
00:00:16,511 --> 00:00:17,510
科尔顿·奥格登：好的 

2
00:00:17,510 --> 00:00:18,510
大家晚上好 

3
00:00:18,510 --> 00:00:19,600
欢迎回到GD50 

4
00:00:19,600 --> 00:00:21,040
这是第六讲 

5
00:00:21,040 --> 00:00:23,980
今天 我们将冒险走出8位世界

6
00:00:23,980 --> 00:00:26,350
回到一个更现代的游戏时代 

7
00:00:26,350 --> 00:00:28,432
今天我们要谈论的是《愤怒的小鸟》 

8
00:00:28,432 --> 00:00:30,640
事实上 我对《愤怒的小鸟》有着非常美好的回忆 

9
00:00:30,640 --> 00:00:33,640
这是我记忆中的第一款手机游戏

10
00:00:33,640 --> 00:00:38,870
在那里我意识到移动设备实际上是一个可行的游戏平台 

11
00:00:38,870 --> 00:00:42,100
我想 早在2009年 也就是它第一次发行的时候 我就玩过了 

12
00:00:42,100 --> 00:00:43,440
我真的很享受 

13
00:00:43,440 --> 00:00:45,340
它有一个非常简单的公式 

14
00:00:45,340 --> 00:00:47,870
如果你不熟悉 我们的目标是你有

15
00:00:47,870 --> 00:00:52,030
你可以通过屏幕左侧的弹弓来控制鸟儿 

16
00:00:52,030 --> 00:00:54,610
然后这些偷了你卵子的猪 

17
00:00:54,610 --> 00:00:56,830
你在试图摧毁他们或杀死他们

18
00:00:56,830 --> 00:01:01,080
通过推倒他们用各种材料 木头 玻璃 

19
00:01:01,080 --> 00:01:02,195
金属 

20
00:01:02,195 --> 00:01:03,820
你会得到几种不同类型的鸟 

21
00:01:03,820 --> 00:01:08,350
但它的大意是 基本上 只是把一只鸟扔进某种结构中 

22
00:01:08,350 --> 00:01:09,280
把它打倒 

23
00:01:09,280 --> 00:01:12,850
以及整个潜在的机制

24
00:01:12,850 --> 00:01:15,130
因为事物是如何通过物理引擎工作的 

25
00:01:15,130 --> 00:01:18,190
今天我们将在课程中讨论它 可能名为Box2D

26
00:01:18,190 --> 00:01:21,280
最普遍的2D物理引擎 

27
00:01:21,280 --> 00:01:24,070
但这就是游戏的总体结构 

28
00:01:24,070 --> 00:01:27,960
从字面上讲 就是把东西扔进建筑物里 把它们推倒 

29
00:01:27,960 --> 00:01:32,906
然后 触觉和有趣的游戏玩法造就了真正伟大的手机游戏 

30
00:01:32,906 --> 00:01:34,530
我以前也很喜欢这样的比赛 

31
00:01:34,530 --> 00:01:38,980
这是第一部《愤怒的小鸟》第一关的截图 

32
00:01:38,980 --> 00:01:41,410
我想大多数人可能都见过 

33
00:01:41,410 --> 00:01:44,020
这是他们的一款新游戏中的一个样本 

34
00:01:44,020 --> 00:01:48,020
正如你所看到的 这里已经有了一个全新的层面 

35
00:01:48,020 --> 00:01:54,400
有石头和一堆错综复杂的结构和新生物

36
00:01:54,400 --> 00:01:55,330
诸如此类的事情 

37
00:01:55,330 --> 00:01:57,996
比赛已经发生了很大的变化 但规则并没有改变 

38
00:01:57,996 --> 00:02:02,250
今天 我们将探索这款游戏赖以运行的基础 

39
00:02:02,250 --> 00:02:04,960
而今天的话题 比平时要小一些 

40
00:02:04,960 --> 00:02:09,009
但是Box2D 我们可以认为是一个相当大的话题 

41
00:02:09,009 --> 00:02:11,200
我们将谈论Box2D 也就是物理学

42
00:02:11,200 --> 00:02:13,430
我们将在今天的课程中使用发动机 

43
00:02:13,430 --> 00:02:16,674
还有通过Love2D 它有自己的Box2D包装器 

44
00:02:16,674 --> 00:02:19,840
我们还将讨论鼠标输入 这是您还没有真正了解到的

45
00:02:19,840 --> 00:02:20,560
做了很多事 

46
00:02:20,560 --> 00:02:23,680
但这是非常恰当的 特别是在手机游戏的背景下 

47
00:02:23,680 --> 00:02:28,960
因为鼠标输入和触摸输入是同义词 

48
00:02:28,960 --> 00:02:30,460
但首先 让我们来看一段演讲演示 

49
00:02:30,460 --> 00:02:34,750
如果我们有一位志愿者上台展示

50
00:02:34,750 --> 00:02:35,990
我在这里所做的一切 

51
00:02:35,990 --> 00:02:38,395
所以让我确保我在这里的目录中是正确的 

52
00:02:42,960 --> 00:02:45,220
因此 只要您准备好了 就继续并按Enter键 

53
00:02:49,450 --> 00:02:54,727
这是我放在一起的一个小演示 用来演示我们将

54
00:02:54,727 --> 00:02:55,810
在课堂上谈论今天 

55
00:02:55,810 --> 00:02:57,700
这只是开始屏幕 但它已经

56
00:02:57,700 --> 00:03:02,950
显示了代表一群方形外星人的Box2D 它

57
00:03:02,950 --> 00:03:05,880
我们实际上将成为我们在游戏中试图瞄准的目标 

58
00:03:05,880 --> 00:03:08,740
但请注意 它们都坠落了 并有自己的碰撞

59
00:03:08,740 --> 00:03:12,970
以及它们自己的物理过程 我不必手动编写代码

60
00:03:12,970 --> 00:03:14,290
旋转和诸如此类的东西 

61
00:03:14,290 --> 00:03:17,539
这些都是Box2D为我们打理的东西 

62
00:03:17,539 --> 00:03:19,330
我们很快就会看到它被用来产生巨大的效果 

63
00:03:19,330 --> 00:03:20,960
如果你继续点击屏幕上的任何地方 

64
00:03:20,960 --> 00:03:22,970
我们将进入比赛的主要部分 

65
00:03:22,970 --> 00:03:26,422
这是《愤怒的小鸟》的一个非常简单的描述 

66
00:03:26,422 --> 00:03:28,130
您从屏幕的左侧开始 

67
00:03:28,130 --> 00:03:29,880
你有一只鸟 在这种情况下是外星人 我们

68
00:03:29,880 --> 00:03:33,100
使用了一个使用外星人而不是鸟类的免费艺术包 

69
00:03:33,100 --> 00:03:34,540
但这是同一个概念 

70
00:03:34,540 --> 00:03:36,487
你有一个外星人 你可以点击和拖动 

71
00:03:36,487 --> 00:03:38,320
因此 如果您单击它 然后四处拖动 您就可以

72
00:03:38,320 --> 00:03:43,070
可以看到当你松开鼠标时你将拥有的轨迹 

73
00:03:43,070 --> 00:03:46,840
所以我们通过这些紫色的圆圈来模拟它的去向 

74
00:03:46,840 --> 00:03:50,605
然后《愤怒的小鸟》的目标是把小鸟扔进 

75
00:03:50,605 --> 00:03:53,980
或者外星人 进入守卫着猪的堡垒 

76
00:03:53,980 --> 00:03:56,170
或者在这种情况下 是方形的外星人 

77
00:03:56,170 --> 00:03:59,086
因此 如果您继续 只需松开鼠标即可将鸟发射出去

78
00:03:59,086 --> 00:04:00,124
你终究会明白的 

79
00:04:00,124 --> 00:04:00,790
哦 又来了 

80
00:04:00,790 --> 00:04:02,980
然后我们推倒了 

81
00:04:02,980 --> 00:04:04,330
好的 

82
00:04:04,330 --> 00:04:08,890
事情是这样的 我们把外星人射进了建筑里 

83
00:04:08,890 --> 00:04:16,360
它摧毁了守卫另一个外星人的一块木块 

84
00:04:16,360 --> 00:04:19,540
然后 这一切一发生 顶部的盒子 

85
00:04:19,540 --> 00:04:23,590
因为这些都是通过Box2D的物理引擎模拟的 

86
00:04:23,590 --> 00:04:27,190
另一个盒子被检测为不受支持 

87
00:04:27,190 --> 00:04:29,290
所以它掉了下来 撞到了另一个外星人 

88
00:04:29,290 --> 00:04:31,960
我们已经对它进行了编码 这样当发生碰撞时

89
00:04:31,960 --> 00:04:35,950
在障碍物和速度足够快的外星人之间 

90
00:04:35,950 --> 00:04:37,060
它应该会杀死外星人 

91
00:04:37,060 --> 00:04:38,800
这就是《愤怒的小鸟》的工作原理 

92
00:04:38,800 --> 00:04:40,210
所以如果你愿意再试一次 

93
00:04:40,210 --> 00:04:42,470
这一次 我们同时击中了这两个目标 

94
00:04:42,470 --> 00:04:44,890
因此 它引发了这两个被删除的消息 

95
00:04:44,890 --> 00:04:46,540
但这家伙还活着 

96
00:04:46,540 --> 00:04:50,110
所以在它停止运动后 这类似于如何

97
00:04:50,110 --> 00:04:54,430
它表现在最初的游戏中 它会让我们再次尝试射击 

98
00:04:54,430 --> 00:04:57,440
所以如果我们再试一次 

99
00:04:57,440 --> 00:05:00,800
然后我们发射并击中它 我们杀死它 然后我们就取得了胜利 

100
00:05:00,800 --> 00:05:04,690
这就是《愤怒的小鸟》的整体基础 

101
00:05:04,690 --> 00:05:06,850
显然 我们使用的是一个非常简单的表示法 

102
00:05:06,850 --> 00:05:09,340
它不像《愤怒的小鸟》那样有太多的装饰 

103
00:05:09,340 --> 00:05:13,000
但我们可以很容易地在此基础上创建一个完全充实的

104
00:05:13,000 --> 00:05:14,811
这款游戏与《愤怒的小鸟》非常相似 

105
00:05:14,811 --> 00:05:15,560
所以谢谢你 史蒂文 

106
00:05:15,560 --> 00:05:17,300
我很感谢你的示范 

107
00:05:25,800 --> 00:05:26,880
这就是我们今天的目标 

108
00:05:26,880 --> 00:05:33,540
我们将讨论如何构建一个非常基本但功能强大的模拟

109
00:05:33,540 --> 00:05:35,610
《愤怒的小鸟》的核心是什么 

110
00:05:35,610 --> 00:05:38,760
这只是把东西扔进障碍物 摧毁它们 

111
00:05:38,760 --> 00:05:41,820
最终摧毁他们所保护的东西 

112
00:05:41,820 --> 00:05:46,364
外星人 基地游戏中的猪 

113
00:05:46,364 --> 00:05:49,530
下面是我们将使用的不同精灵床单的快照

114
00:05:49,530 --> 00:05:50,250
是 

115
00:05:50,250 --> 00:05:53,730
我从《开放游戏艺术》上学到了一张很棒的精灵单子 

116
00:05:53,730 --> 00:05:54,690
肯尼是艺术家 

117
00:05:54,690 --> 00:05:56,040
他创作了很多伟大的艺术作品 

118
00:05:56,040 --> 00:05:58,260
如果你注意到了 它看起来很像艺术

119
00:05:58,260 --> 00:06:01,020
我们在马里奥的演讲中用到的 

120
00:06:01,020 --> 00:06:02,520
实际上 是同一个艺术家 

121
00:06:02,520 --> 00:06:06,210
所以 如果你在寻找资产 他有一大堆了不起的资产

122
00:06:06,210 --> 00:06:07,200
关于开放游戏艺术 

123
00:06:07,200 --> 00:06:10,110
所以我们有一组外星人 方形和圆形的 

124
00:06:10,110 --> 00:06:14,130
我武断地决定 我们把圆形的外星人做成鸟 

125
00:06:14,130 --> 00:06:17,880
所以我们把它们射入结构中

126
00:06:17,880 --> 00:06:19,380
保护正方形的外星人 

127
00:06:19,380 --> 00:06:23,662
在这种情况下 正方形的外星人将是坏人 

128
00:06:23,662 --> 00:06:26,620
然后我们有另一张精灵纸在下面的左边 

129
00:06:26,620 --> 00:06:30,360
只是 我用这里的瓷砖做了一个地面元素 

130
00:06:30,360 --> 00:06:33,510
剩下的这些你可以很容易地包括在游戏中 如果你想的话 

131
00:06:33,510 --> 00:06:36,060
但我们只是在使用这里的地面 

132
00:06:36,060 --> 00:06:38,400
然后注意这里 我们有一个很大的精灵纸

133
00:06:38,400 --> 00:06:42,930
它有一堆不同形状和大小的材料 

134
00:06:42,930 --> 00:06:47,040
整个精灵薄片都有金属、炸药和玻璃薄片 

135
00:06:47,040 --> 00:06:49,500
但为了简单起见 我们只使用这里的木头 

136
00:06:49,500 --> 00:06:53,190
但请注意 我们有完整的部件

137
00:06:53,190 --> 00:06:55,470
然后我们有部分被摧毁的碎片

138
00:06:55,470 --> 00:06:57,120
然后是中空的碎片 

139
00:06:57,120 --> 00:07:00,540
您可以很容易地在游戏中对所有这些进行建模并使用它们 

140
00:07:00,540 --> 00:07:04,200
但我们只决定使用其中的几个 

141
00:07:04,200 --> 00:07:07,020
只有水平的和垂直的

142
00:07:07,020 --> 00:07:09,630
是完全完整的 

143
00:07:09,630 --> 00:07:14,370
不幸的是 它们的系统布局并不完全相同

144
00:07:14,370 --> 00:07:16,170
就像我们以前用过的精灵 

145
00:07:16,170 --> 00:07:18,820
它们不是均匀分布在网格中的 

146
00:07:18,820 --> 00:07:22,740
所以在这种情况下 在util dotLua中 我最终很难

147
00:07:22,740 --> 00:07:26,160
对不同的XY宽度和高度四元组进行编码

148
00:07:26,160 --> 00:07:29,160
对于其中的每一个 这是你在一种情况下必须做的

149
00:07:29,160 --> 00:07:31,780
在这里 你不是在与瓷砖本身互动 

150
00:07:31,780 --> 00:07:33,960
但有了更多有机形状的物体 

151
00:07:33,960 --> 00:07:36,390
所以它可能需要更多的时间才能结束

152
00:07:36,390 --> 00:07:39,205
为您的对象构建所有四边形

153
00:07:39,205 --> 00:07:40,830
当你有这样一张精灵床单的时候 

154
00:07:40,830 --> 00:07:43,560
但是 幸运的是 你只需要做一次 

155
00:07:43,560 --> 00:07:46,890
在我们开始讨论Box2D是什么之前 这里有一些有用的链接

156
00:07:46,890 --> 00:07:50,190
以及如何使用它 以及它基本上是如何被称为爱情圆点的

157
00:07:50,190 --> 00:07:52,670
物理学 有效地 在爱的2D中 

158
00:07:52,670 --> 00:07:56,325
前两个链接是LOVE 2D的文档 

159
00:07:56,325 --> 00:07:58,950
我们将要讨论的函数和对象是什么 

160
00:07:58,950 --> 00:08:01,324
还有一个简单的教程 讲述了如何制造一个球

161
00:08:01,324 --> 00:08:05,070
使用Box2D在爱情2D中弹跳 

162
00:08:05,070 --> 00:08:07,950
第三个是我实际使用的一个很好的资源

163
00:08:07,950 --> 00:08:11,250
要了解我对Box2D的大部分了解 特别是

164
00:08:11,250 --> 00:08:13,984
在这堂课的背景下 

165
00:08:13,984 --> 00:08:15,900
所以它谈到了很多不同的概念 

166
00:08:15,900 --> 00:08:17,290
它谈到了我们将要讨论的所有事情 

167
00:08:17,290 --> 00:08:19,710
然后 它将更详细地介绍如何

168
00:08:19,710 --> 00:08:24,540
你可以着手建造很多非常酷、很疯狂的东西 比如坦克

169
00:08:24,540 --> 00:08:27,150
滑轮和一大堆不同的东西

170
00:08:27,150 --> 00:08:30,030
如果您正在寻找潜在的

171
00:08:30,030 --> 00:08:31,230
一款基于物理的游戏 

172
00:08:31,230 --> 00:08:35,429
显然 我们不会在这里讨论这种复杂的事情 

173
00:08:35,429 --> 00:08:37,169
但你可以用Box2D很容易地做到这一点 

174
00:08:37,169 --> 00:08:40,350
这使得这一点非常非常有可能 

175
00:08:40,350 --> 00:08:43,620
所以我们要谈的第一件事

176
00:08:43,620 --> 00:08:47,100
关于我们什么时候想要构建一个游戏或模拟 

177
00:08:47,100 --> 00:08:50,490
或者无论我们想做什么 使用Box2D是我们

178
00:08:50,490 --> 00:08:55,320
需要某种系统来为我们实际执行模拟 

179
00:08:55,320 --> 00:09:02,670
Box2D应用程序或游戏的基本核心是世界

180
00:09:02,670 --> 00:09:03,280
对象 

181
00:09:03,280 --> 00:09:06,780
所以有一个世界 你可以把它想象成你的世界

182
00:09:06,780 --> 00:09:12,810
但它实际上是一台模拟所有部件的机器

183
00:09:12,810 --> 00:09:16,200
你已经告诉它在Box2D中相互作用 

184
00:09:16,200 --> 00:09:20,310
因此 Box2D具有一组称为灯具和实体的对象 

185
00:09:20,310 --> 00:09:22,820
它们执行物理上的互动 

186
00:09:22,820 --> 00:09:25,650
全世界都有责任更新这些

187
00:09:25,650 --> 00:09:28,680
并应用相关的力和物理计算

188
00:09:28,680 --> 00:09:32,450
解决碰撞和做各种事情 

189
00:09:32,450 --> 00:09:35,487
Box2D为我们和世界所做的一切

190
00:09:35,487 --> 00:09:36,570
会帮我们解决这件事

191
00:09:36,570 --> 00:09:40,050
所以我们不需要手动检查和更新每一个对象

192
00:09:40,050 --> 00:09:43,020
我们之前做过的 并检查碰撞 

193
00:09:43,020 --> 00:09:45,240
世界为我们做了这些 并解决了这些问题 

194
00:09:45,240 --> 00:09:48,120
基于我们如何告诉它去解决它们 

195
00:09:48,120 --> 00:09:51,120
这个世界也拥有 就像一个真实的世界

196
00:09:51,120 --> 00:09:53,730
重力在x轴和y轴上 

197
00:09:53,730 --> 00:09:57,630
在这个例子中 重力作用在y轴上 

198
00:09:57,630 --> 00:09:59,820
所以它是正值

199
00:09:59,820 --> 00:10:03,420
我们在这个发行版中将其设置为300 但您可以将其设置为任何您想要的值 

200
00:10:03,420 --> 00:10:05,610
设定一个较低的重力会产生这样的效果

201
00:10:05,610 --> 00:10:08,110
让我们感觉像是在月球上

202
00:10:08,110 --> 00:10:10,110
感觉我们在另一个星球 

203
00:10:10,110 --> 00:10:11,276
原来世界就是这样 

204
00:10:11,276 --> 00:10:12,650
世界模拟一切 

205
00:10:12,650 --> 00:10:14,400
我们在这里讲几个术语

206
00:10:14,400 --> 00:10:15,990
在我们看一些源代码之前 

207
00:10:15,990 --> 00:10:20,250
但在我们真正理解

208
00:10:20,250 --> 00:10:22,930
了解Box2D在做什么 

209
00:10:22,930 --> 00:10:26,490
这是我们用来在love2D中创建一个新世界的函数 

210
00:10:26,490 --> 00:10:29,730
很简单 爱点物理点新世界 

211
00:10:29,730 --> 00:10:33,510
这个爱点物理学只是一个命名空间 

212
00:10:33,510 --> 00:10:41,410
封装了love2D可以访问的所有Box2D函数和对象 

213
00:10:41,410 --> 00:10:44,220
所以你在爱点物理学中看到的任何东西

214
00:10:44,220 --> 00:10:47,100
Box2D的包装器 

215
00:10:47,100 --> 00:10:51,330
为了澄清Box2D Box2D只是一个用C++编写的库

216
00:10:51,330 --> 00:10:54,240
你可以在任何你想插入的地方插入 

217
00:10:54,240 --> 00:10:58,080
Unity使用它 实际上 大多数2D游戏引擎都使用它 

218
00:10:58,080 --> 00:11:03,420
包括Live GDX 这是一个非常大的Java

219
00:11:03,420 --> 00:11:05,880
2D游戏框架使用Box2D 

220
00:11:05,880 --> 00:11:07,920
你可以在任何地方使用它 

221
00:11:07,920 --> 00:11:11,640
在这种情况下 我们使用love2D自己的包装器 

222
00:11:11,640 --> 00:11:15,270
所以创造爱情2D的人 他们采用了Box2D

223
00:11:15,270 --> 00:11:17,490
然后他们只需要把一组Lua函数

224
00:11:17,490 --> 00:11:19,650
围绕着它们 围绕着所有的对象和功能

225
00:11:19,650 --> 00:11:22,620
以使其可以在相同的样式中使用

226
00:11:22,620 --> 00:11:24,592
我们使用框架的其余部分 

227
00:11:24,592 --> 00:11:26,050
这就是你创造一个新世界的方式 

228
00:11:26,050 --> 00:11:29,310
这是使Box2D模拟工作的第一步 

229
00:11:29,310 --> 00:11:32,460
那么 到目前为止 我们对如何实现这一目标有什么问题吗？

230
00:11:32,460 --> 00:11:34,050
好的 

231
00:11:34,050 --> 00:11:39,240
因此 超越世界对象 这是基础 某种程度上搭建了我们的舞台 

232
00:11:39,240 --> 00:11:42,540
你可以把它想象成我们的舞台 我们需要身体

233
00:11:42,540 --> 00:11:44,770
才能真正地相互影响 

234
00:11:44,770 --> 00:11:47,880
所以身体只是一个抽象的容器 

235
00:11:47,880 --> 00:11:52,650
它基本上保持着一个位置和一个速度 

236
00:11:52,650 --> 00:11:56,190
你通过所谓的固定装置将东西固定在它上面

237
00:11:56,190 --> 00:12:00,612
它允许你给身体一个形状 因此是一个碰撞框 

238
00:12:00,612 --> 00:12:02,820
从而允许它与其他事物相互作用 

239
00:12:02,820 --> 00:12:07,590
但身体本质上是场景中所有不同的东西相互作用

240
00:12:07,590 --> 00:12:09,510
彼此在一起 四处走动 

241
00:12:09,510 --> 00:12:14,160
因此 为了创造一个新的身体 我们只是喜欢点物理 点新的身体 

242
00:12:14,160 --> 00:12:17,610
我们在这个世界上走过 所以当我们这样做的时候 

243
00:12:17,610 --> 00:12:19,950
现在 全世界都提到了这个机构 

244
00:12:19,950 --> 00:12:22,440
每次我们呼吁更新我们的世界 这是

245
00:12:22,440 --> 00:12:25,230
我们会在源代码中看到 它会知道 好的 

246
00:12:25,230 --> 00:12:29,280
我有这个机构的参考资料 进行所有相关的检查

247
00:12:29,280 --> 00:12:33,660
关于该车身及其所包含的所有夹具的碰撞 

248
00:12:33,660 --> 00:12:38,770
更新其位置、更新速度等 

249
00:12:38,770 --> 00:12:41,700
不仅是一个世界 而且还有一个x和y 

250
00:12:41,700 --> 00:12:45,900
这将把它放在实例化的世界中 

251
00:12:45,900 --> 00:12:48,970
这里的最后一个参数是输入 

252
00:12:48,970 --> 00:12:51,330
有三种基本类型的物体

253
00:12:51,330 --> 00:12:56,130
我们将在爱情中看到2D的、静态的、动态的和运动学的 

254
00:12:56,130 --> 00:12:59,580
这基本上影响了它与其他物体的互动方式 

255
00:12:59,580 --> 00:13:01,810
其他身体 在我们的场景中 

256
00:13:01,810 --> 00:13:04,860
所以我们有这个世界 它囊括了一切 

257
00:13:04,860 --> 00:13:06,900
所有的身体 所有的固定装置 

258
00:13:06,900 --> 00:13:10,380
然后我们有身体 这是我们游戏世界中的实体

259
00:13:10,380 --> 00:13:14,310
它们有位置和速度

260
00:13:14,310 --> 00:13:18,180
最后一个关键因素是

261
00:13:18,180 --> 00:13:23,820
在我们的身体之间创造相互作用是固定的 

262
00:13:23,820 --> 00:13:28,680
而夹具 夹具的全部 就是这个抽象的对象

263
00:13:28,680 --> 00:13:31,650
它可以让你把一个形状附加到一个物体上 

264
00:13:31,650 --> 00:13:34,740
所以身体是无形的 它们没有形状 

265
00:13:34,740 --> 00:13:39,930
它们只是一个有效地具有位置速度的容器 

266
00:13:39,930 --> 00:13:42,010
但它们不与其他任何东西相互作用 

267
00:13:42,010 --> 00:13:44,260
他们不知道如何与其他东西互动

268
00:13:44,260 --> 00:13:46,290
直到你给他们一个固定的 

269
00:13:46,290 --> 00:13:50,170
和夹具你会给身体和形状 

270
00:13:50,170 --> 00:13:52,860
比如说 如果你想要一只鸟

271
00:13:52,860 --> 00:13:56,715
我们之前看到的外星人 圆形的外星人 我们为它创造了一个身体 

272
00:13:56,715 --> 00:13:59,880
在我们的世界里这还不意味着什么

273
00:13:59,880 --> 00:14:03,810
但是我们说 我要给那个外星人装一个固定装置 

274
00:14:03,810 --> 00:14:05,760
我要给它一个圆形 

275
00:14:05,760 --> 00:14:08,970
它就会知道无论何时进行任何计算 

276
00:14:08,970 --> 00:14:13,170
外星人应该和圆形物体互动

277
00:14:13,170 --> 00:14:16,410
从而触发基于圆形命中盒的碰撞 

278
00:14:16,410 --> 00:14:21,180
而不是长方形或多边形的击中盒

279
00:14:21,180 --> 00:14:24,390
固定装置 除了附加形状

280
00:14:24,390 --> 00:14:27,300
到身体 这将 正如这里所说 影响

281
00:14:27,300 --> 00:14:32,010
它们如何与其他物体碰撞 它们有密度 我们会看到 

282
00:14:32,010 --> 00:14:34,110
所以密度大的物体

283
00:14:34,110 --> 00:14:38,704
会下降得更快 或者不会下降得更快 但它们会影响事情 

284
00:14:38,704 --> 00:14:39,870
就像他们有更多的重量 

285
00:14:39,870 --> 00:14:43,660
当它们与物体碰撞时 它们会把物体推得更远 

286
00:14:43,660 --> 00:14:46,110
他们也有摩擦 他们有恢复 

287
00:14:46,110 --> 00:14:48,120
喘息是有弹性的 

288
00:14:48,120 --> 00:14:51,810
所以如果有什么东西 如果我们有外星人 当它落地的时候 

289
00:14:51,810 --> 00:14:53,590
它会失败的

290
00:14:53,590 --> 00:14:55,410
但如果我们给它更高的回报 

291
00:14:55,410 --> 00:14:58,080
会在落地时反弹

292
00:14:58,080 --> 00:15:02,380
因此与世界的互动略有不同 

293
00:15:02,380 --> 00:15:08,000
因此 当我们想要一个固定装置 并将一个形状应用到身体上时 

294
00:15:08,000 --> 00:15:09,750
我们可以有几种不同的形状

295
00:15:09,750 --> 00:15:12,930
适用于在2D爱中默认给予我们的爱 

296
00:15:12,930 --> 00:15:15,340
所以圆形 长方形 边形 

297
00:15:15,340 --> 00:15:18,520
这些就是我们如何有效地定义

298
00:15:18,520 --> 00:15:20,680
我们的身体与其他身体相互作用 

299
00:15:20,680 --> 00:15:24,010
例如 如果它是圆形的东西

300
00:15:24,010 --> 00:15:26,680
当它沿着地面移动时 它应该滚动 

301
00:15:26,680 --> 00:15:29,680
或者当它击中某物时 显然是在它的一角

302
00:15:29,680 --> 00:15:32,990
不会打到什么东西 因为它是圆角的 而不是

303
00:15:32,990 --> 00:15:36,670
有一个方形的点击框 它会以一种略有不同的方式影响事情 

304
00:15:36,670 --> 00:15:40,840
我们可以定义任意形状的点击框 这要归功于多边形 

305
00:15:40,840 --> 00:15:45,560
例如 如果我们想要一个形状像五角形的东西 

306
00:15:45,560 --> 00:15:47,870
让它像这样滚来滚去 

307
00:15:47,870 --> 00:15:51,730
我们可以通过一组顶点来定义一个多边形 

308
00:15:51,730 --> 00:15:54,820
然后把它贴在身体上 它就会

309
00:15:54,820 --> 00:15:57,900
表现得好像它是五角形的 

310
00:15:57,900 --> 00:16:00,280
这就是您将如何实例化 就像我们

311
00:16:00,280 --> 00:16:03,940
看到了爱点物理点新世界和爱点物理点新身体 

312
00:16:03,940 --> 00:16:07,180
爱点物理点新的夹具以身体和形状 

313
00:16:07,180 --> 00:16:10,180
并将该形状应用到身体上 

314
00:16:10,180 --> 00:16:14,779
而在那之后的世界将确切地知道如何与事物碰撞 

315
00:16:14,779 --> 00:16:16,570
所以最后一件事 最后一张幻灯片

316
00:16:16,570 --> 00:16:19,229
在我们开始查看源代码之前 请先看这里

317
00:16:19,229 --> 00:16:20,770
不同的体型是什么 

318
00:16:20,770 --> 00:16:25,600
所以我之前提到过有三种不同的体型 静态的 动态的 

319
00:16:25,600 --> 00:16:26,710
和运动学的 

320
00:16:26,710 --> 00:16:32,080
因此 我们的世界中将存在一个静止的物体 但实际上不会受到重力的影响

321
00:16:32,080 --> 00:16:34,090
或者其他任何东西的碰撞 

322
00:16:34,090 --> 00:16:36,730
事物可以撞击它 然后弹出来 做它们自己的事情 

323
00:16:36,730 --> 00:16:39,790
但静态的身体永远不会受到其他东西的影响 

324
00:16:39,790 --> 00:16:43,817
它以某种永久结构的形式存在 几乎就像地面一样 

325
00:16:43,817 --> 00:16:46,900
你并不会通过移动和弹跳来影响地面 

326
00:16:46,900 --> 00:16:49,360
除非你用足够的力

327
00:16:49,360 --> 00:16:55,090
但是在我们的Box2D世界中 一个静态的身体不可能受到任何其他东西的影响 

328
00:16:55,090 --> 00:16:57,770
动态的身体是相反的 

329
00:16:57,770 --> 00:17:03,310
它具有Box2D的完整模拟 

330
00:17:03,310 --> 00:17:06,790
重力影响它 物体碰撞它 它会反弹 

331
00:17:06,790 --> 00:17:09,010
它会做你所期望的一个正常的身体做 

332
00:17:09,010 --> 00:17:13,150
如果我在这个房间里扔一个球 它碰到了墙 这是一个动态物体 

333
00:17:13,150 --> 00:17:15,940
在这种情况下 墙壁是静态物体 

334
00:17:15,940 --> 00:17:19,720
运动体是两者的混合体 

335
00:17:19,720 --> 00:17:24,109
它是一种可以移动 可以旋转和做一些事情的东西 

336
00:17:24,109 --> 00:17:28,400
但不受其他物体碰撞的影响 

337
00:17:28,400 --> 00:17:32,860
举个例子 如果我有一个平台 它不停地旋转 

338
00:17:32,860 --> 00:17:36,940
但它不受重力的影响 当我撞击它时 它不会移动 

339
00:17:36,940 --> 00:17:38,170
这是一个运动体 

340
00:17:38,170 --> 00:17:42,400
它仍然在移动 它是半静态的 它影响着其他东西 

341
00:17:42,400 --> 00:17:43,660
但它不是纯粹的静态的 

342
00:17:43,660 --> 00:17:47,197
它确实有一点行为可以授予它 

343
00:17:47,197 --> 00:17:49,030
让我们继续看几个例子

344
00:17:49,030 --> 00:17:53,030
现在来看看这在代码中是什么样子的 

345
00:17:53,030 --> 00:17:56,380
所以我将进入一个例子 如果你在发行版中查找 

346
00:17:56,380 --> 00:17:58,600
有一个叫做静态的例子 

347
00:17:58,600 --> 00:18:02,227
我们来看看在我们的场景中 静态物体是什么样子的 

348
00:18:02,227 --> 00:18:04,560
对于所有这些导致愤怒的小鸟的例子 

349
00:18:04,560 --> 00:18:08,320
为了简单起见 我们将用形状来渲染所有东西 

350
00:18:08,320 --> 00:18:14,350
但这是一个完整的Box2D世界 

351
00:18:14,350 --> 00:18:17,020
只有一个静止的身体 

352
00:18:17,020 --> 00:18:19,410
就是这个正方形 白色的

353
00:18:19,410 --> 00:18:21,620
静止的物体不动 什么也不做 

354
00:18:21,620 --> 00:18:25,000
没有什么能影响它的动作或行为 

355
00:18:25,000 --> 00:18:27,190
但它在我们的世界里是一个永久的固定装置 

356
00:18:27,190 --> 00:18:30,370
如果我们有一个动态的物体 我们把它扔到一个动态的物体上 

357
00:18:30,370 --> 00:18:32,770
比如说 动态物体会弹开 

358
00:18:32,770 --> 00:18:34,872
静止的物体将永久留在那里 

359
00:18:34,872 --> 00:18:36,580
让我们继续下去 看看是什么

360
00:18:36,580 --> 00:18:38,200
其源代码如下所示 

361
00:18:38,200 --> 00:18:42,820
所以我现在在静态文件的main点Lua中 

362
00:18:42,820 --> 00:18:46,630
就像我们以前看到的 我们需要找到一个世界 

363
00:18:46,630 --> 00:18:49,270
所以我在第45行有一个世界 

364
00:18:49,270 --> 00:18:52,960
爱点物理点点新世界 没有x-可引力 

365
00:18:52,960 --> 00:18:57,910
但是我们在y轴上会有300个单位的正重力 

366
00:18:57,910 --> 00:19:01,720
是从上到下 

367
00:19:01,720 --> 00:19:06,460
我们的方块需要一个在游戏世界中的实体 我们的静态方块 

368
00:19:06,460 --> 00:19:08,800
因此 我们将继续在这里定义一个新的身体 

369
00:19:08,800 --> 00:19:11,251
爱点物理点新身体走进世界 

370
00:19:11,251 --> 00:19:14,500
回想一下 因为这就是我们的世界将如何引用那个身体 

371
00:19:14,500 --> 00:19:18,117
不知道 除非我们把它传到这里 我们的新身体构造者 

372
00:19:18,117 --> 00:19:20,950
然后我就把它放在屏幕中央 

373
00:19:20,950 --> 00:19:25,030
所以虚拟宽度除以2 虚拟高度除以2 

374
00:19:25,030 --> 00:19:29,020
Box2D物体与物体的区别

375
00:19:29,020 --> 00:19:31,270
我们以前画过或见过的东西是

376
00:19:31,270 --> 00:19:34,690
一切都是由它的中心点定义的 而不是它的左上角 

377
00:19:34,690 --> 00:19:37,150
所以我可以说虚拟宽度除以2

378
00:19:37,150 --> 00:19:39,270
这里用虚拟高度除以2 

379
00:19:39,270 --> 00:19:42,790
但实际上我不需要说虚拟宽度除以2减去任何东西

380
00:19:42,790 --> 00:19:44,800
那个正方形的一半是 

381
00:19:44,800 --> 00:19:50,740
默认情况下 中心点是该对象的XY 

382
00:19:50,740 --> 00:19:55,600
我们新Body的构造函数中的最后一个字符串是静态的 

383
00:19:55,600 --> 00:19:58,810
告诉构造函数这将是一个特定的静态主体 

384
00:19:58,810 --> 00:20:02,960
既不是动力学物体 也不是运动学物体 

385
00:20:02,960 --> 00:20:05,962
所以我们有一个物体 它是静态的 但它没有形状 

386
00:20:05,962 --> 00:20:08,920
它真的不知道如何与我们世界中的任何其他东西互动 

387
00:20:08,920 --> 00:20:10,270
所以我们要给它一个--

388
00:20:10,270 --> 00:20:12,340
我们首先要创建一个新的形状 

389
00:20:12,340 --> 00:20:18,347
因此 爱以新的X字形的形式给了我们一些功能 

390
00:20:18,347 --> 00:20:20,930
我们有新的矩形 新的圆形 新的边缘形状 

391
00:20:20,930 --> 00:20:22,620
还有其他几个 

392
00:20:22,620 --> 00:20:26,380
我们只需要创建一个宽度和高度为10的新矩形 

393
00:20:26,380 --> 00:20:28,420
这就是10号和10号在这里的原因 

394
00:20:28,420 --> 00:20:31,070
然后我们将创建一个新的灯具 

395
00:20:31,070 --> 00:20:37,370
我们要用这个功能把盒子的形状固定在我们的身体上 

396
00:20:37,370 --> 00:20:44,420
一旦我们这样做了 我们所要做的就是用填充渲染一个多边形

397
00:20:44,420 --> 00:20:48,950
然后我们得到我们的--或我们的多边形的顶点的坐标

398
00:20:48,950 --> 00:20:52,190
通过这句话 身体得到了世界积分 

399
00:20:52,190 --> 00:20:55,940
所以这是任何Box2D实体的函数

400
00:20:55,940 --> 00:21:01,400
这基本上会得到它在世界上的位置和它的所有顶点 

401
00:21:01,400 --> 00:21:04,730
然后你只需传递你想要得到的分数的形状 

402
00:21:04,730 --> 00:21:08,300
最终会在这里爆炸成一组顶点

403
00:21:08,300 --> 00:21:10,790
填满了这个爱心的圆点图形圆点多边形 

404
00:21:10,790 --> 00:21:17,090
这样做的最终结果是我们得到了一个平方 

405
00:21:17,090 --> 00:21:21,275
我们特别使用多边形而不是爱情

406
00:21:21,275 --> 00:21:24,566
点图形点出新的矩形 因为这就是

407
00:21:24,566 --> 00:21:26,690
世界积分函数爆炸到 

408
00:21:26,690 --> 00:21:32,150
它不会爆炸到满足以下条件的参数数量

409
00:21:32,150 --> 00:21:35,040
喜欢圆点图形 圆点矩形 

410
00:21:35,040 --> 00:21:37,460
所以这不是一个非常令人兴奋的例子 

411
00:21:37,460 --> 00:21:43,110
但这基本上是完整的Box2D应用程序的基础 

412
00:21:43,110 --> 00:21:46,411
那么 对于这是如何运作的 有什么问题吗？

413
00:21:46,411 --> 00:21:47,036
观众：是的 

414
00:21:47,036 --> 00:21:48,032
我在想 

415
00:21:48,032 --> 00:21:52,514
它如何确定反常形状的中心？

416
00:21:52,514 --> 00:21:54,804
不像多边形、正方形、矩形或圆形 

417
00:21:54,804 --> 00:21:56,720
科尔顿·奥格登：反常形状的中心 

418
00:21:56,720 --> 00:21:57,710
我不完全确定 

419
00:21:57,710 --> 00:22:00,774
这个圈子就是...

420
00:22:00,774 --> 00:22:01,680
观众：[听不见]

421
00:22:01,680 --> 00:22:02,471
科尔顿·奥格登：是的 

422
00:22:02,471 --> 00:22:04,790
不过 我对多边形不是完全确定 

423
00:22:04,790 --> 00:22:06,790
我还没有对此进行太多的细节研究 

424
00:22:06,790 --> 00:22:08,040
我可以探索一下 看看 

425
00:22:08,040 --> 00:22:11,320
这就是我认为Box2D是什么--

426
00:22:11,320 --> 00:22:14,300
实际的库实现并计算了这一点 

427
00:22:14,300 --> 00:22:18,029
很可能是根据计算出的--

428
00:22:18,029 --> 00:22:20,570
如果我还没有重复的话 对着镜头重复 那就是

429
00:22:20,570 --> 00:22:25,340
Box2D如何计算非对称物体的中心点 

430
00:22:25,340 --> 00:22:27,860
就像一个多边形？

431
00:22:27,860 --> 00:22:33,230
我所能理解的最好的情况是 它会计算出它的面积

432
00:22:33,230 --> 00:22:38,567
然后找出所有顶点的走向 我猜 

433
00:22:38,567 --> 00:22:41,150
但是 是的 这是在图书馆中实现的东西 

434
00:22:41,150 --> 00:22:42,170
我不完全确定 

435
00:22:42,170 --> 00:22:46,469
我可以查一查 看看 然后我会在《松弛》上发帖 

436
00:22:46,469 --> 00:22:48,718
观众：[INAUDIBLE]看起来你确实有 

437
00:22:48,718 --> 00:22:52,940
很难把它放在一个非常精确的位置 

438
00:22:52,940 --> 00:22:55,010
科尔顿·奥格登：是的 

439
00:22:55,010 --> 00:22:56,810
如果是的话--是的 

440
00:22:56,810 --> 00:23:00,220
如果我们确实有一个奇怪的形状来把它放在一个准确的位置 

441
00:23:00,220 --> 00:23:01,440
是啊 我也不是很确定 

442
00:23:01,440 --> 00:23:04,450
我得稍微探索一下这一点 

443
00:23:04,450 --> 00:23:05,450
不过 这个想法很有趣 

444
00:23:07,980 --> 00:23:13,444
但是 是的 这就是我们建立和运行Box2D世界的基本方式 

445
00:23:13,444 --> 00:23:14,360
我们有一个静止的物体 

446
00:23:14,360 --> 00:23:16,580
这并不是特别有趣 

447
00:23:16,580 --> 00:23:19,130
但有一个变化--

448
00:23:19,130 --> 00:23:23,150
所以我在源代码发行版中有一个单独的示例 名为Dynamic 

449
00:23:23,150 --> 00:23:26,760
但我们需要做的就是真正看到不同之处

450
00:23:26,760 --> 00:23:32,360
静态和动态之间的物体在第48行 只需将静态改为动态 

451
00:23:32,360 --> 00:23:35,660
保存它 然后重新运行它 

452
00:23:35,660 --> 00:23:38,300
然后我们会立即看到它受到重力的影响

453
00:23:38,300 --> 00:23:41,930
它向下移动 正如我们告诉世界 我们的引力是

454
00:23:41,930 --> 00:23:43,880
设置为正300 

455
00:23:43,880 --> 00:23:47,000
所以这就是我们预期的行为方式 

456
00:23:47,000 --> 00:23:50,730
现在 场景中没有其他东西 所以它不是特别有趣 

457
00:23:50,730 --> 00:23:55,220
所以我创建了另一个名为GROUND的例子 

458
00:23:55,220 --> 00:23:58,110
所以让我们继续下去 看看这个 

459
00:24:02,970 --> 00:24:09,408
因此 如果我们想要更有趣的行为 简而言之 我们需要做什么？

460
00:24:09,408 --> 00:24:11,719
观众：有更多的形状 并形成一个地面 

461
00:24:11,719 --> 00:24:13,760
科尔顿·奥格登：更多的形状 并形成一个地面 

462
00:24:13,760 --> 00:24:14,600
一点儿没错 

463
00:24:14,600 --> 00:24:17,330
这是一个简单的方法 我们可以立即开始

464
00:24:17,330 --> 00:24:19,490
了解Box2D的功能有多强大 

465
00:24:19,490 --> 00:24:22,940
只需引入更多以不同方式相互作用的形状 

466
00:24:22,940 --> 00:24:28,540
因此地面是一个例子 它将地面引入到我们的场景中 

467
00:24:28,540 --> 00:24:33,590
这样我们就能看到盒子掉落下来 实际上撞上了其他东西 

468
00:24:33,590 --> 00:24:36,480
而Love2D让这一切变得简单而美好 

469
00:24:36,480 --> 00:24:37,190
打扰一下

470
00:24:37,190 --> 00:24:40,640
它们有一个实际的边缘形状 

471
00:24:40,640 --> 00:24:44,150
在地面上形成 

472
00:24:44,150 --> 00:24:48,710
任何与之相碰撞的东西 实际上就是一条线

473
00:24:48,710 --> 00:24:52,430
但无论场景中的物体移动得有多快 

474
00:24:52,430 --> 00:24:56,690
身体不会越过那条线

475
00:24:56,690 --> 00:25:00,100
所以这是一个很好的 简单的方法来获得一个地面在我们的场景

476
00:25:00,100 --> 00:25:03,560
而不必实现可能有两个顶点的多边形 

477
00:25:03,560 --> 00:25:05,387
屏幕上从左到右 

478
00:25:05,387 --> 00:25:06,470
所以这就是我们在这里做的 

479
00:25:06,470 --> 00:25:11,720
我们有一个地面身体 这是一个静态的身体 回忆一下 

480
00:25:11,720 --> 00:25:14,150
因为地面不应该移动 

481
00:25:14,150 --> 00:25:18,101
我们要把盒子变成一个动态的物体 

482
00:25:18,101 --> 00:25:19,350
但地面不应该移动

483
00:25:19,350 --> 00:25:21,183
地面应该不受任何影响 

484
00:25:21,183 --> 00:25:23,210
在我们的场景中 它将是静态的 

485
00:25:23,210 --> 00:25:25,400
它会有一个边缘形状 

486
00:25:25,400 --> 00:25:28,850
注意这里 我们取0 0作为XY轴 

487
00:25:28,850 --> 00:25:31,220
然后虚拟宽度为零 

488
00:25:31,220 --> 00:25:35,510
所以当我们在这里定义形状时 

489
00:25:35,510 --> 00:25:39,690
它不会在0 0 虚拟宽度为0处绘制形状 

490
00:25:39,690 --> 00:25:42,680
这是相对于身体所在的地方而言的 

491
00:25:42,680 --> 00:25:45,350
所以无论我们的身体在哪里 

492
00:25:45,350 --> 00:25:49,460
用这些坐标 这个X和Y 这个宽度和高度 

493
00:25:49,460 --> 00:25:50,930
相对于此 

494
00:25:50,930 --> 00:25:56,130
特别是相对于我们放置物体的中心点 

495
00:25:56,130 --> 00:26:01,440
所以如果这个地被设置为0 0在虚拟宽度和零 

496
00:26:01,440 --> 00:26:03,440
我们要把尸体放在哪里

497
00:26:03,440 --> 00:26:08,125
来适当地渲染地面

498
00:26:08,125 --> 00:26:09,829
观众：中间的底部 

499
00:26:09,829 --> 00:26:12,370
是的 所以我们把它放在中间的底部 

500
00:26:12,370 --> 00:26:18,670
所以我们实际上把物体本身放在这里 虚拟高度减30 

501
00:26:18,670 --> 00:26:21,850
当我们把这个边缘形状固定在身体上时 

502
00:26:21,850 --> 00:26:24,280
即使它写的是0 0虚拟宽度零 

503
00:26:24,280 --> 00:26:27,070
它是相对于物体的XY坐标的 

504
00:26:27,070 --> 00:26:31,210
实际上是0虚拟高度减30 

505
00:26:31,210 --> 00:26:35,800
虚拟宽度零将是该边缘存在的地方 

506
00:26:35,800 --> 00:26:37,990
最后 就像我们对盒子做的那样 

507
00:26:37,990 --> 00:26:41,980
我们需要一个地面固定装置 这样地面机构才能知道如何

508
00:26:41,980 --> 00:26:43,820
它应该与其他东西互动 

509
00:26:43,820 --> 00:26:47,350
所以我们要贴上边缘形状 这只是一条线 

510
00:26:47,350 --> 00:26:49,870
到我们的地面躯体 

511
00:26:49,870 --> 00:26:53,410
然后在这里 我们确实喜欢点图形--只是

512
00:26:53,410 --> 00:26:58,030
就像我们对长方体的Love点图形点多边形所做的那样 

513
00:26:58,030 --> 00:27:00,931
我们将为我们的地面实体做点图形点线 

514
00:27:00,931 --> 00:27:03,430
我们将做同样的事情 获得世界积分

515
00:27:03,430 --> 00:27:06,510
然后在这里得到通过边缘形状的点数 

516
00:27:06,510 --> 00:27:09,850
我还将线宽设置为2

517
00:27:09,850 --> 00:27:11,920
这样我们就能看得更清楚一点 

518
00:27:11,920 --> 00:27:13,580
我要把它涂成红色 

519
00:27:13,580 --> 00:27:17,770
再一次 我把盒子涂成了绿色 

520
00:27:17,770 --> 00:27:20,570
所以 继续来看看这是什么样子的 

521
00:27:20,570 --> 00:27:24,280
所以我要进入地下了 

522
00:27:27,120 --> 00:27:30,460
所以请注意--我还添加了一点恢复原状

523
00:27:30,460 --> 00:27:33,910
对于--就像我之前说的 修复是固定装置可以做到的一种品质

524
00:27:33,910 --> 00:27:35,890
具有赋予它弹力的 

525
00:27:35,890 --> 00:27:38,350
因此 与其只是平直地倒在地上 

526
00:27:38,350 --> 00:27:39,740
它也会有一点反弹 

527
00:27:39,740 --> 00:27:42,323
我们可以看到互动 所以我再播放一次 

528
00:27:42,323 --> 00:27:43,630
它从中间开始 

529
00:27:43,630 --> 00:27:46,600
然后当它一击中地面物体

530
00:27:46,600 --> 00:27:49,840
我们之前创建的边缘形状 它会反弹几次 

531
00:27:49,840 --> 00:27:54,580
但它表明盒子是动态的 但地面是静态的 

532
00:27:54,580 --> 00:27:57,040
没有任何东西会影响地面的位置 

533
00:27:57,040 --> 00:28:01,900
它变得坚硬 并将永久留在那里 

534
00:28:01,900 --> 00:28:05,260
这显示了一个很好、简单、简单的演示

535
00:28:05,260 --> 00:28:09,820
静态物体和动态物体之间的相互作用 

536
00:28:09,820 --> 00:28:13,250
我将继续在这里举另一个例子 

537
00:28:13,250 --> 00:28:18,460
所以运动学 回想一下 运动学和

538
00:28:18,460 --> 00:28:21,298
是静态的还是动态的呢？

539
00:28:21,298 --> 00:28:23,798
观众：运动学可以移动 但不能影响其他形状 

540
00:28:23,798 --> 00:28:24,714
科尔顿·奥格登：正确 

541
00:28:24,714 --> 00:28:26,030
所以运动学的物体可以移动 

542
00:28:26,030 --> 00:28:31,000
你可以把它归结为位置速度或角速度 它是旋转 

543
00:28:31,000 --> 00:28:35,290
但当有东西与它相撞时 它不会受到它的影响 

544
00:28:35,290 --> 00:28:38,530
它会影响与之相撞的物体 

545
00:28:38,530 --> 00:28:40,780
它会以某种方式影响它 但不会

546
00:28:40,780 --> 00:28:42,700
与运动学物体的碰撞

547
00:28:42,700 --> 00:28:45,790
对其位置或速度产生影响 

548
00:28:45,790 --> 00:28:48,970
它是某种存在的东西 并做一些编程的事情

549
00:28:48,970 --> 00:28:50,920
并将无限期地这样做 但它

550
00:28:50,920 --> 00:28:55,260
会按照我们的程序与其他动态体相互作用 

551
00:28:55,260 --> 00:28:57,760
它也不会与其他运动学物体相互作用 

552
00:28:57,760 --> 00:29:00,280
他们几乎会假装对方并不存在 

553
00:29:00,280 --> 00:29:03,785
如果将静态和运动学实体或运动学和运动学实体重叠 

554
00:29:03,785 --> 00:29:06,160
它们在彼此之上渲染 但它们实际上并不

555
00:29:06,160 --> 00:29:09,470
影响彼此的立场或诸如此类的事情 

556
00:29:09,470 --> 00:29:13,695
所以我将继续 运行运动学的例子 

557
00:29:19,550 --> 00:29:23,780
所以这里我们有几件事正在发生 

558
00:29:23,780 --> 00:29:27,410
我们有我们以前拥有的盒体 动感盒子

559
00:29:27,410 --> 00:29:29,520
从屏幕中央掉落 

560
00:29:29,520 --> 00:29:31,700
我们在最底层有一块地可以抓住它 

561
00:29:31,700 --> 00:29:35,240
但我们在中间有三个运动学盒子 

562
00:29:35,240 --> 00:29:39,440
正在旋转 影响着绿色盒子

563
00:29:39,440 --> 00:29:41,700
当绿色的盒子与它们相撞时 

564
00:29:41,700 --> 00:29:44,510
如你所见 它把它抛来抛去 然后

565
00:29:44,510 --> 00:29:46,610
绿色的身体掉落到底部 

566
00:29:46,610 --> 00:29:49,070
在这个例子中 我取消了它的原状 

567
00:29:49,070 --> 00:29:53,300
因此 它一落地 就会平直地坠落 

568
00:29:53,300 --> 00:29:54,870
简单得不得了 

569
00:29:54,870 --> 00:29:57,330
所以 如你所见 这些蓝色的物体 它们在移动 

570
00:29:57,330 --> 00:30:00,830
它们有无限的角速度 

571
00:30:00,830 --> 00:30:04,940
具体来说就是每秒360度 

572
00:30:04,940 --> 00:30:09,080
它们将保持在正确的位置并以正确的方式旋转

573
00:30:09,080 --> 00:30:10,080
直到永远 

574
00:30:10,080 --> 00:30:13,370
但一旦它们与一个有活力的物体互动 

575
00:30:13,370 --> 00:30:16,670
它们实际上导致了与那个动态物体的碰撞 

576
00:30:16,670 --> 00:30:19,550
碰撞解决了 这个绿色的物体

577
00:30:19,550 --> 00:30:21,710
被抛来抛去 因为它是动态的 

578
00:30:21,710 --> 00:30:27,350
它基本上会尽其所能与游戏世界互动

579
00:30:27,350 --> 00:30:30,590
只要它与其他物体相互作用

580
00:30:30,590 --> 00:30:32,270
并以这种方式解决它的碰撞 

581
00:30:34,800 --> 00:30:39,860
这就是三个不同物体之间的关键例子

582
00:30:39,860 --> 00:30:40,580
从根本上说 

583
00:30:40,580 --> 00:30:45,182
有了这三种体型 你几乎可以构建任何场景

584
00:30:45,182 --> 00:30:45,890
这是你想要的 

585
00:30:45,890 --> 00:30:50,180
显然 车身和固定装置可能会变得非常复杂 

586
00:30:50,180 --> 00:30:55,010
我的意思是 我们可以回顾一下第一个例子 

587
00:30:55,010 --> 00:31:05,780
这些结构是许多不同类型的动态体的组合

588
00:31:05,780 --> 00:31:11,330
它们被赋予了锚和关节以及其他各种各样的东西

589
00:31:11,330 --> 00:31:15,170
让它们看起来像是大型建筑 

590
00:31:15,170 --> 00:31:18,370
但最后 他们都只是一群小肉体

591
00:31:18,370 --> 00:31:20,870
焊接在一起的设备 焊接在一起的设备 

592
00:31:23,480 --> 00:31:27,710
而这些基本的构建块就是如何构建这样的场景的 

593
00:31:27,710 --> 00:31:32,210
把这些块放在一起 用接头把它们焊接在一起 

594
00:31:32,210 --> 00:31:33,050
在这种情况下 

595
00:31:33,050 --> 00:31:35,840
我们不会在这堂课的上下文中讨论关节 

596
00:31:35,840 --> 00:31:39,290
但如果你想知道所有这些个体的东西

597
00:31:39,290 --> 00:31:44,729
是可碰撞的 同时仍然构建这些巨大的场景

598
00:31:44,729 --> 00:31:46,520
将物理学应用于它们 它们是

599
00:31:46,520 --> 00:31:51,140
只是使用焊接接头或其他类型的接头、滑轮接头连接在一起

600
00:31:51,140 --> 00:31:52,640
这取决于它们是什么 

601
00:31:52,640 --> 00:31:58,760
在这种情况下 这里有两个圆形 圆形灯具 

602
00:31:58,760 --> 00:32:01,190
这是这辆车上的轮子 然后

603
00:32:01,190 --> 00:32:06,740
它们被焊接到这里的扁平建筑上 

604
00:32:06,740 --> 00:32:09,980
允许那些是动态的允许车轮滚动 因此

605
00:32:09,980 --> 00:32:12,650
随身带着另一件重担 

606
00:32:12,650 --> 00:32:14,390
这座桥也是如此 

607
00:32:14,390 --> 00:32:18,710
我忘了关节的确切名称 但它是一串固定装置

608
00:32:18,710 --> 00:32:20,720
由特定类型的接头焊接而成 

609
00:32:20,720 --> 00:32:23,090
通过以这种方式将它们放在一起 

610
00:32:23,090 --> 00:32:27,740
你有一座桥 还有你能想到的各种东西 

611
00:32:27,740 --> 00:32:33,830
包括坦克 这是在这里的注释中 

612
00:32:33,830 --> 00:32:36,080
第三个环节 其中一个谈到了如何

613
00:32:36,080 --> 00:32:37,970
用踏板来实施坦克

614
00:32:37,970 --> 00:32:40,580
绕着圆圈 然后是一个巨大的身体 

615
00:32:40,580 --> 00:32:45,156
你可以用Box2D做任何事情 它是一个很棒的库 

616
00:32:45,156 --> 00:32:47,030
在《愤怒的小鸟》的背景下 我们真的只是

617
00:32:47,030 --> 00:32:49,400
对于这里可能发生的事情 触及了皮毛 

618
00:32:52,470 --> 00:32:54,590
现在我要做演示了 

619
00:32:54,590 --> 00:32:59,480
事实上 我觉得我很喜欢这个演示 这段代码 

620
00:32:59,480 --> 00:33:03,410
比起我更喜欢《愤怒的小鸟》的实现 

621
00:33:03,410 --> 00:33:06,400
这是我写的一个叫球坑的程序 

622
00:33:06,400 --> 00:33:08,160
哦 顺便说一句 在我开始之前 

623
00:33:08,160 --> 00:33:11,840
因此 我想我会把它作为一个小小的预告片 

624
00:33:11,840 --> 00:33:15,440
看运动学 真的很快 

625
00:33:15,440 --> 00:33:18,590
我们要看看我已经创造了

626
00:33:18,590 --> 00:33:23,450
运动体工作台 夹具工作台 

627
00:33:23,450 --> 00:33:24,802
然后是一个形状 

628
00:33:24,802 --> 00:33:26,510
因为你实际上只需要一个形状 

629
00:33:26,510 --> 00:33:28,400
您可以将一个形状应用于任意多个实体

630
00:33:28,400 --> 00:33:32,960
只要它们都有相同的形状 就可以 

631
00:33:32,960 --> 00:33:35,690
我在这里只创建了三个运动学实体 

632
00:33:35,690 --> 00:33:39,590
所以用这个数学方法 把它们相对于中心隔开 

633
00:33:39,590 --> 00:33:41,019
他们得到了运动学的弦 

634
00:33:41,019 --> 00:33:42,560
这真的是关键的区别 

635
00:33:42,560 --> 00:33:45,830
然后在结束之前 我要确保我

636
00:33:45,830 --> 00:33:47,920
将它们设置为角速度 

637
00:33:47,920 --> 00:33:49,400
所以这就是你旋转东西的方式 

638
00:33:49,400 --> 00:33:51,483
如果你想让某物无限期地旋转 

639
00:33:51,483 --> 00:33:52,730
只要设置一个角速度即可 

640
00:33:52,730 --> 00:33:56,540
在这种情况下 360度为弧度 

641
00:33:56,540 --> 00:34:01,880
这只是一个写成常量的公式 这只是一个数字--

642
00:34:01,880 --> 00:34:05,942
我马上就忘了公式到底是什么 

643
00:34:05,942 --> 00:34:06,650
但它就在上面 

644
00:34:06,650 --> 00:34:13,070
温度是弧度0.01745329度 等等 

645
00:34:13,070 --> 00:34:15,949
但就像圆周率一样 这是一个你可以

646
00:34:15,949 --> 00:34:19,540
用度数乘一个数 就会得到一个弧度数 

647
00:34:19,540 --> 00:34:22,120
而且在那里也有相反的情况 

648
00:34:22,120 --> 00:34:26,949
我们必须这样做 因为Box2D预计 对于任何类型的旋转 

649
00:34:26,949 --> 00:34:28,239
它预计会以弧度为单位 

650
00:34:28,239 --> 00:34:30,050
我更喜欢按度思考 

651
00:34:30,050 --> 00:34:33,370
所以我把360度变成弧度 

652
00:34:33,370 --> 00:34:37,340
所以我们在这里渲染 就像我们对盒体所做的那样 

653
00:34:37,340 --> 00:34:42,790
我们在I处渲染运动体、多边形填充、运动体

654
00:34:42,790 --> 00:34:45,639
获取世界点运动学形状获取点 

655
00:34:45,639 --> 00:34:47,179
没有太大的不同 

656
00:34:47,179 --> 00:34:50,949
唯一真正的关键区别是我们将运动学添加为字符串

657
00:34:50,949 --> 00:34:53,659
传递给Body的构造函数 

658
00:34:53,659 --> 00:34:55,810
我们增加了一些角速度 

659
00:34:55,810 --> 00:34:58,082
记住 这会让它无限期地旋转 

660
00:34:58,082 --> 00:35:00,790
但它永远不会受到影响--它的角速度永远不会

661
00:35:00,790 --> 00:35:03,850
受到影响 它的地位永远不会受到影响

662
00:35:03,850 --> 00:35:06,310
在我们的场景中被其他任何东西 

663
00:35:06,310 --> 00:35:10,060
好了 现在我要把球坑拉起来 

664
00:35:13,170 --> 00:35:15,590
也许我只是对这个有点太兴奋了 

665
00:35:15,590 --> 00:35:18,160
但我很享受这个过程 

666
00:35:18,160 --> 00:35:22,300
所以 这就像是一个更大的演示

667
00:35:22,300 --> 00:35:24,680
把所有这些碎片放在一起 

668
00:35:24,680 --> 00:35:26,994
我们有一堆圆形的形状 

669
00:35:26,994 --> 00:35:28,660
它们都在相互作用 

670
00:35:28,660 --> 00:35:29,770
他们都有物理课 

671
00:35:29,770 --> 00:35:33,190
然后我这里有一个更大的形状 这个正方形 

672
00:35:33,190 --> 00:35:35,510
它的密度比其他任何东西都要高 

673
00:35:35,510 --> 00:35:38,660
按下空格键 我就可以直接进入--

674
00:35:38,660 --> 00:35:41,440
把它扔到球坑里 它会引起相互作用

675
00:35:41,440 --> 00:35:42,670
以及其他的一切 

676
00:35:42,670 --> 00:35:46,780
和我发现的一个错误斜杠功能

677
00:35:46,780 --> 00:35:51,070
如果你一次又一次地按空格键 

678
00:35:51,070 --> 00:35:53,510
它永远不会重置它的速度 

679
00:35:53,510 --> 00:35:55,854
所以它就撞到了球坑里 

680
00:35:55,854 --> 00:35:58,270
所以这只是一种乐趣 我认为实际上

681
00:35:58,270 --> 00:36:00,580
在这里可能是个游戏创意 

682
00:36:00,580 --> 00:36:02,710
但是 我的意思是 好吧 这里的碎片是什么？

683
00:36:02,710 --> 00:36:04,000
这有什么不同？

684
00:36:07,388 --> 00:36:10,949
观众：它们都是动态的造型 

685
00:36:10,949 --> 00:36:11,740
科尔顿·奥格登：是的 

686
00:36:11,740 --> 00:36:13,490
所以它们都是动态的形状 

687
00:36:13,490 --> 00:36:15,410
除了最底层的地面 

688
00:36:15,410 --> 00:36:21,994
此外 隐藏在视野之外的还有另外两个静态形状

689
00:36:21,994 --> 00:36:22,910
在左边和右边 

690
00:36:22,910 --> 00:36:25,160
因为如果我们没有这些 所有的球

691
00:36:25,160 --> 00:36:28,520
会掉到看不见的一边 

692
00:36:28,520 --> 00:36:33,020
但没错 我们的场景有静态分隔符 

693
00:36:33,020 --> 00:36:38,420
但我们有一堆动态的物体 这些球都是动态的 

694
00:36:38,420 --> 00:36:42,470
然后广场也是充满活力的 

695
00:36:42,470 --> 00:36:45,387
然后 就像我之前说的 他们之间唯一真正的区别是

696
00:36:45,387 --> 00:36:47,220
很明显 正方形是一个长方形 

697
00:36:47,220 --> 00:36:49,200
但它也有更高的密度 

698
00:36:49,200 --> 00:36:53,027
因此 通过赋予它更高的密度 它推动了其他一切--哦 

699
00:36:53,027 --> 00:36:53,860
那里发生了什么事？

700
00:36:53,860 --> 00:36:54,485
这太奇怪了 

701
00:36:54,485 --> 00:36:57,410
它在推动--我想它睡着了 因为我们什么都没做

702
00:36:57,410 --> 00:36:57,980
一段时间 

703
00:36:57,980 --> 00:37:01,550
但它可能会跌落到其他任何地方

704
00:37:01,550 --> 00:37:05,960
因为它知道它更重 它应该推动和应用

705
00:37:05,960 --> 00:37:09,800
一种更强大的力量来对付它周围的一切 

706
00:37:09,800 --> 00:37:14,030
因此 通过使用Box2D的这些基本构建块 

707
00:37:14,030 --> 00:37:18,320
你可以构建很多非常酷的模拟和其他有趣的程序

708
00:37:18,320 --> 00:37:20,840
真正得到有趣的游戏点子 

709
00:37:20,840 --> 00:37:25,010
我倾向于相信《愤怒的小鸟》一开始是有人在胡闹

710
00:37:25,010 --> 00:37:27,780
使用Box2D 或者像这样的物理引擎 

711
00:37:27,780 --> 00:37:31,430
它的灵感来自于其他一些游戏 我应该稍微研究一下 

712
00:37:31,430 --> 00:37:34,837
但据推测 这款游戏的创建者发现了这个物理引擎

713
00:37:34,837 --> 00:37:36,170
然后我们就想 哦 这太酷了 

714
00:37:36,170 --> 00:37:39,650
我要在这里建一座积木塔 然后向它扔东西 

715
00:37:39,650 --> 00:37:42,130
然后他们意识到 哦 我们可以用这个做一个游戏 

716
00:37:42,130 --> 00:37:46,890
所以我鼓励你 如果你曾经好奇地尝试一些东西

717
00:37:46,890 --> 00:37:47,390
就像那样 

718
00:37:47,390 --> 00:37:49,040
我们或许可以把这变成一场游戏 

719
00:37:49,040 --> 00:37:49,581
我不知道 

720
00:37:49,581 --> 00:37:50,480
我很喜欢这个 

721
00:37:50,480 --> 00:38:00,050
这是一个很好的抽象片段 因为没有更好的词、例子

722
00:38:00,050 --> 00:38:05,030
 并将其更多地合并到领域中

723
00:38:05,030 --> 00:38:09,230
我们如何才能让这件事变得有趣呢？

724
00:38:09,230 --> 00:38:14,570
这就是我们今天开始进入发行版的方式 

725
00:38:14,570 --> 00:38:21,320
所以今天演讲的主要话题是Box2D 以及我们如何使用它来制作游戏 

726
00:38:21,320 --> 00:38:23,780
我们应该考虑的另一件事是鼠标输入 

727
00:38:23,780 --> 00:38:25,480
我们还没有真正用过它 

728
00:38:25,480 --> 00:38:29,450
我想我以前已经提到过了 有点随意 

729
00:38:29,450 --> 00:38:31,060
但Love2D让这一切变得超级简单 

730
00:38:31,060 --> 00:38:33,761
这就像我们对键盘输入所做的那样 

731
00:38:33,761 --> 00:38:36,260
我们在Main Dot Lua中只有几个回调 

732
00:38:36,260 --> 00:38:38,390
按下鼠标 然后松开鼠标 

733
00:38:38,390 --> 00:38:41,705
这些与按键和按键之间的区别

734
00:38:41,705 --> 00:38:45,500
他们也会得到一个X和一个Y 因为通常 

735
00:38:45,500 --> 00:38:47,420
当您单击鼠标或释放鼠标时 

736
00:38:47,420 --> 00:38:49,461
你想知道是在哪里发生的 因为

737
00:38:49,461 --> 00:38:53,250
显然与你在使用鼠标时所做的事情有关 

738
00:38:53,250 --> 00:38:58,940
因此 每当你点击或释放鼠标按键时 Love2D就会触发这些命令 

739
00:38:58,940 --> 00:39:01,670
他们得到了X、Y和钥匙 而你

740
00:39:01,670 --> 00:39:03,350
你可以用这些东西做任何你想做的事 

741
00:39:03,350 --> 00:39:05,900
就像我们在之前的课程中所做的那样

742
00:39:05,900 --> 00:39:10,220
我们可以在主点Lua之外的其他模块中使用鼠标输入 

743
00:39:10,220 --> 00:39:13,505
有一个功能叫爱点鼠标点按键和按键

744
00:39:13,505 --> 00:39:15,341
发布了我在Main Dot Lua中实现的 

745
00:39:15,341 --> 00:39:16,340
你可以去看看那些 

746
00:39:16,340 --> 00:39:20,540
它们与我们之前制作键盘输入表的方式非常相似 

747
00:39:20,540 --> 00:39:24,020
但它们允许我们在内部使用此功能

748
00:39:24,020 --> 00:39:30,350
除了Main Dot Lua之外的其他函数、其他模块 

749
00:39:30,350 --> 00:39:35,180
所以让我们继续下去 开始看--

750
00:39:35,180 --> 00:39:42,140
这就是我们开始寻找《愤怒的小鸟》发行版的地方

751
00:39:42,140 --> 00:39:46,489
以及我们如何将所有这些棋子组合成一场真正的游戏 

752
00:39:46,489 --> 00:39:49,530
所以我们要做的第一件事 我们将只看几件事

753
00:39:49,530 --> 00:39:51,530
然后我们会休息一会儿 然后我们会

754
00:39:51,530 --> 00:39:53,150
更深入地了解其中的实质 

755
00:39:53,150 --> 00:39:55,820
但让我继续下去 把所有这些都清除掉 

756
00:39:58,800 --> 00:40:02,460
然后我们要拉起--所以发行版是愤怒的50 

757
00:40:02,460 --> 00:40:06,270
所以Main Dot Lua就在这里 

758
00:40:06,270 --> 00:40:08,280
所以在这里并没有什么不同 

759
00:40:08,280 --> 00:40:11,700
所以我们在游戏中有两种状态 

760
00:40:11,700 --> 00:40:14,490
所以我们有一个开始和一个比赛状态 就像我们之前看到的 

761
00:40:14,490 --> 00:40:16,810
开始状态和我们以前做过的一样 

762
00:40:16,810 --> 00:40:20,070
唯一的区别是在这个开始状态下 嗯 首先 

763
00:40:20,070 --> 00:40:22,020
它正在运行Box2D模拟 

764
00:40:22,020 --> 00:40:25,800
第二 我们实际上使用的是鼠标输入 

765
00:40:25,800 --> 00:40:27,780
所以实际上 让我们看看Main 这样你就可以

766
00:40:27,780 --> 00:40:31,540
看看我在哪里添加了这个 这与以前不同 

767
00:40:31,540 --> 00:40:35,310
所以我们按下了Love的点键 就像我们以前看到的那样 

768
00:40:35,310 --> 00:40:38,520
但我们也有按下鼠标和释放鼠标的方法 

769
00:40:38,520 --> 00:40:40,660
然后按下鼠标 松开鼠标 

770
00:40:40,660 --> 00:40:44,340
这些是这次Main Dot Lua的主要不同之处 而不是

771
00:40:44,340 --> 00:40:49,020
上一节课 我们只用键盘输入 

772
00:40:49,020 --> 00:40:53,490
正如您在这里看到的 我们有按下和释放键的输入表

773
00:40:53,490 --> 00:40:54,570
在鼠标上 

774
00:40:54,570 --> 00:40:57,870
因此 我们将其初始化为在每个更新帧上清空

775
00:40:57,870 --> 00:41:00,840
就像我们对键盘所做的那样 

776
00:41:00,840 --> 00:41:05,820
然后在回调函数中更新输入表

777
00:41:05,820 --> 00:41:07,517
就像我们以前做过的那样 

778
00:41:07,517 --> 00:41:10,600
这就是这次Main Dot Lua的所有不同之处 

779
00:41:10,600 --> 00:41:15,540
这就是我们将刚刚推出的新鼠标功能捆绑在一起的方式

780
00:41:15,540 --> 00:41:17,040
看着我们的比赛 

781
00:41:19,830 --> 00:41:24,270
我们的游戏中存在的状态是PLAY状态和START状态 

782
00:41:24,270 --> 00:41:25,110
非常简单 

783
00:41:25,110 --> 00:41:27,480
非常类似于上周我们观看塞尔达的比赛 

784
00:41:27,480 --> 00:41:31,470
我们基本上只有一个开始状态和一个比赛状态 

785
00:41:31,470 --> 00:41:37,860
开始状态 我们可以在这里看到 只是为了连接在一起

786
00:41:37,860 --> 00:41:41,160
鼠标的最后一点用法 

787
00:41:41,160 --> 00:41:43,920
爱点鼠标点被按下1点 

788
00:41:43,920 --> 00:41:46,695
有人知道这个1是什么吗？

789
00:41:46,695 --> 00:41:48,120
观众：那是左键点击吗？

790
00:41:48,120 --> 00:41:49,411
科尔顿·奥格登：点击鼠标左键 

791
00:41:49,411 --> 00:41:53,850
因此 Love2D会将整数值指定给所有鼠标按键 

792
00:41:53,850 --> 00:41:58,230
而1传统上是左击的缺省值 

793
00:41:58,230 --> 00:42:00,420
一些框架将使用0 

794
00:42:00,420 --> 00:42:06,300
但是Lua 1索引是从1开始的 而不是0 

795
00:42:06,300 --> 00:42:10,810
关于这里的开始状态 这是一种酷和有趣的事情 

796
00:42:10,810 --> 00:42:18,030
所以我要继续下去 再玩一次 这个游戏 

797
00:42:18,030 --> 00:42:21,440
所以我们一开始就开始 只是为了让事情变得有趣

798
00:42:21,440 --> 00:42:23,940
而不是只有一个静态屏幕 上面显示

799
00:42:23,940 --> 00:42:28,050
愤怒50点击开始 我们实际上正在运行一个Love2D 

800
00:42:28,050 --> 00:42:30,790
在这里进行Box2D模拟 

801
00:42:30,790 --> 00:42:33,720
这是一个有一堆方块的世界 

802
00:42:33,720 --> 00:42:37,812
那么 这些都是什么样的身体呢？

803
00:42:37,812 --> 00:42:38,810
观众：[听不见] 

804
00:42:38,810 --> 00:42:40,518
科尔顿·奥格登：它们都是有活力的物体 

805
00:42:40,518 --> 00:42:44,210
我们已经将它们全部封装起来 就像我们之前在球坑例子中所做的那样 

806
00:42:44,210 --> 00:42:47,895
屏幕的左侧、右侧和底部都有一些看不见的静态体 

807
00:42:47,895 --> 00:42:49,770
因为如果我们没有那些静止的物体

808
00:42:49,770 --> 00:42:52,980
它们只会一路往下掉 

809
00:42:52,980 --> 00:42:56,100
最好的是 我们实际上不需要渲染任何东西 

810
00:42:56,100 --> 00:43:01,850
所以如果你想在你的游戏中为某些东西设置一个无形的障碍 

811
00:43:01,850 --> 00:43:04,364
或者你想要封装一些东西 一些物质上的东西 

812
00:43:04,364 --> 00:43:05,780
您不必渲染任何内容 

813
00:43:05,780 --> 00:43:10,160
你可以只拥有任意形状和位置的静态物体 

814
00:43:10,160 --> 00:43:11,977
而这将充当一个容器 

815
00:43:11,977 --> 00:43:13,310
这就是我们在那里所做的一切 

816
00:43:13,310 --> 00:43:17,960
我们为我们所有的小正方形外星人准备了一个集装箱 

817
00:43:17,960 --> 00:43:22,580
我认为 通过创造100个这样的物体 然后让它们掉落 

818
00:43:22,580 --> 00:43:27,140
我们的游戏有一个有趣的视觉开始

819
00:43:27,140 --> 00:43:29,310
只需非常非常小的努力 

820
00:43:29,310 --> 00:43:31,340
让我们来看看这个 

821
00:43:31,340 --> 00:43:36,260
所以在我们的开始状态init中 正如我之前所说的 我们有一个世界 

822
00:43:36,260 --> 00:43:38,570
我们显然需要一个新世界的成员 

823
00:43:38,570 --> 00:43:40,670
任何时候我们做任何Box2D的事情你都必须开始

824
00:43:40,670 --> 00:43:43,185
通过让爱点缀新世界 物理点点新世界

825
00:43:43,185 --> 00:43:46,730
否则 您将无法运行任何模拟 

826
00:43:46,730 --> 00:43:51,740
建造一片地面 一堵墙 然后是一群外星人 

827
00:43:51,740 --> 00:43:57,630
所以在这里 我们可以看到我们有一个表格 我们正在向其中插入外星人 

828
00:43:57,630 --> 00:44:00,980
但我们有一个班级叫外星人 

829
00:44:00,980 --> 00:44:04,520
所以 有没有人想大致了解一下外星人的职业

830
00:44:04,520 --> 00:44:05,930
封装了还是最终是？

831
00:44:10,421 --> 00:44:15,694
观众：可能是它的外观 就像皮肤一样 

832
00:44:15,694 --> 00:44:18,110
科尔顿·奥格登：是的 这绝对是其中的一部分 

833
00:44:18,110 --> 00:44:19,880
所以它看起来 或者是它的皮肤 

834
00:44:19,880 --> 00:44:23,210
所以它确实提到了这一点 

835
00:44:23,210 --> 00:44:31,970
然后更多的功能 它还拥有一个身体和一个固定装置 

836
00:44:31,970 --> 00:44:35,000
因此 与其让一堆身体和固定装置

837
00:44:35,000 --> 00:44:38,780
它们是分开的 可能只在桌子上

838
00:44:38,780 --> 00:44:44,240
在任何东西的表面水平上 我们的水平 只需将它们包装在一个类中 

839
00:44:44,240 --> 00:44:46,370
然后我们就可以保持一个引用

840
00:44:46,370 --> 00:44:50,630
每一个外星人的身体和固定装置 

841
00:44:50,630 --> 00:44:53,240
所以它更具封装性 

842
00:44:53,240 --> 00:44:57,500
在我看来 它更面向对象 更简洁 

843
00:44:57,500 --> 00:45:03,230
外星人阶级可以用正方形或圆形作为它的--

844
00:45:03,230 --> 00:45:05,900
嗯 它可以接受任何你想要的类型 

845
00:45:05,900 --> 00:45:09,290
因此 这最终将决定它是如何渲染的 以及它的形状 

846
00:45:09,290 --> 00:45:13,670
但如果它是方形的 这是默认的 所以如果你只是

847
00:45:13,670 --> 00:45:18,020
创造一个没有类型的外星人 它会得到

848
00:45:18,020 --> 00:45:21,350
一个爱心网点 物理网点呈长方形 

849
00:45:21,350 --> 00:45:23,720
所以 正如我们之前看到的 这只是一个盒子 

850
00:45:23,720 --> 00:45:26,510
如果不是 我们就默认为圆形 

851
00:45:26,510 --> 00:45:29,450
但你可以把它编程成你想要的任何形状 

852
00:45:29,450 --> 00:45:30,980
然后就给它那个形状 

853
00:45:30,980 --> 00:45:33,230
你真的不需要做太多的事情

854
00:45:33,230 --> 00:45:36,890
编码它如何与其他任何东西相互作用 至少在碰撞方面是这样 

855
00:45:36,890 --> 00:45:40,220
因为 谢天谢地 Box2D会知道 好的 这是一个圆 

856
00:45:40,220 --> 00:45:43,790
它应该旋转 并与像圆圈一样的东西互动 

857
00:45:43,790 --> 00:45:47,090
或者它是一个矩形 所以它应该与像盒子一样的东西交互 

858
00:45:47,090 --> 00:45:48,680
只是又好又方便 

859
00:45:48,680 --> 00:45:52,070
然后我们将在这里创建一个固定装置 

860
00:45:52,070 --> 00:45:55,860
此处的设置用户数据功能很重要

861
00:45:55,860 --> 00:46:01,850
因为我们将在我们如何实际解决碰撞的上下文中看到

862
00:46:01,850 --> 00:46:05,300
以定制的方式 我们需要用户数据

863
00:46:05,300 --> 00:46:08,840
能够区分出在我们的世界中发生碰撞的东西 

864
00:46:08,840 --> 00:46:14,900
但目前你可以知道 这基本上允许我们进入--

865
00:46:14,900 --> 00:46:17,720
将任意数据设置到灯具上 

866
00:46:17,720 --> 00:46:22,850
所以我们可以说 灯具集用户数据外星人 串外星人 

867
00:46:22,850 --> 00:46:28,520
这意味着Fixture有一些关于它的定制元数据

868
00:46:28,520 --> 00:46:30,290
说 这是一个外星人 

869
00:46:30,290 --> 00:46:31,892
这是我们想要用它做的任何事情 

870
00:46:31,892 --> 00:46:33,350
我们也可以给这张桌子 

871
00:46:33,350 --> 00:46:35,570
我们可以这样说 用户数据是一个表

872
00:46:35,570 --> 00:46:40,190
然后有一堆信息 我们可以在碰撞时使用

873
00:46:40,190 --> 00:46:42,050
对它进行不同的工作 

874
00:46:42,050 --> 00:46:44,210
但是这个设置用户数据的功能是我们如何

875
00:46:44,210 --> 00:46:48,900
能够以不同的方式解决障碍和外星人之间的碰撞 

876
00:46:48,900 --> 00:46:53,460
比如玩家和外星人 甚至外星人和地面 

877
00:46:53,460 --> 00:46:57,110
因为当我们做任何Box2D碰撞时 对 世界

878
00:46:57,110 --> 00:46:59,150
为我们解决碰撞问题 

879
00:46:59,150 --> 00:47:04,460
我们如何告诉世界 好吧 当我落地时 我想要播放一个声音 

880
00:47:04,460 --> 00:47:05,810
但什么都不做 

881
00:47:05,810 --> 00:47:10,130
如果我以这个速度撞击这个盒子 我想让它摧毁它 

882
00:47:10,130 --> 00:47:12,860
如果我击中外星人 我希望外星人消失

883
00:47:12,860 --> 00:47:16,280
我想展示一个胜利的标签 

884
00:47:16,280 --> 00:47:18,890
我们如何做所有这些不同的事情？

885
00:47:18,890 --> 00:47:21,770
我们通过所谓的冲突回调来做到这一点

886
00:47:21,770 --> 00:47:23,400
在Box2D的上下文中 

887
00:47:23,400 --> 00:47:24,720
我们将拭目以待 

888
00:47:24,720 --> 00:47:30,870
但可以说 用户数据将是非常重要的 

889
00:47:30,870 --> 00:47:33,350
然后这个推出了假的 实际上我们并没有结束

890
00:47:33,350 --> 00:47:34,910
使用这个 所以这是无关紧要的 

891
00:47:34,910 --> 00:47:43,190
但它在这里有一个渲染函数 它只接受身体X和Y

892
00:47:43,190 --> 00:47:46,242
并会以它所在的角度绘制它 

893
00:47:46,242 --> 00:47:47,450
所以这是一件重要的事情 

894
00:47:47,450 --> 00:47:52,400
以前 我们所做的是通过形状来画东西 

895
00:47:52,400 --> 00:47:55,790
所以爱点图形的点多边形 爱点图形的点圆 

896
00:47:55,790 --> 00:47:57,710
喜欢网点图形的网点线 

897
00:47:57,710 --> 00:48:03,440
但如果我们想要画一个精灵 我们

898
00:48:03,440 --> 00:48:06,440
首先需要把它画在正确的位置 对吗？

899
00:48:06,440 --> 00:48:09,890
然后物体也会在Box2D中旋转 

900
00:48:09,890 --> 00:48:13,500
所以我们需要把它画在正确的角度 

901
00:48:13,500 --> 00:48:17,270
所以我们要做的是 我们可以在身体上查询它的X 

902
00:48:17,270 --> 00:48:21,770
我们可以查询物体的Y 也可以查询物体的角度 

903
00:48:21,770 --> 00:48:24,560
然后我们可以绘制纹理和四边形

904
00:48:24,560 --> 00:48:28,470
我们想要利用XY和角度 

905
00:48:28,470 --> 00:48:33,560
这将产生在世界上画出一个精灵的效果

906
00:48:33,560 --> 00:48:37,190
反映了Box2D中正在发生的事情 而不仅仅是一个简单的形状 

907
00:48:37,190 --> 00:48:42,260
所以这就像画一个精灵而不是一个形状一样简单 

908
00:48:42,260 --> 00:48:46,230
你可以在这里看到 17.5号高速公路 

909
00:48:46,230 --> 00:48:48,404
有人知道这是干嘛用的吗？

910
00:48:48,404 --> 00:48:49,240
观众：不确定 

911
00:48:49,240 --> 00:48:52,940
科尔顿·奥格登：所以17.5、17.5、17.5是宽度的一半

912
00:48:52,940 --> 00:48:56,030
外星人身高的一半 

913
00:48:56,030 --> 00:48:58,670
所以外星人在这个游戏中是35乘35的 

914
00:48:58,670 --> 00:49:00,050
我们把这些都传进去 

915
00:49:00,050 --> 00:49:02,450
这是起源的中心 

916
00:49:02,450 --> 00:49:05,600
所以当我们以原点为中心旋转物体时 

917
00:49:05,600 --> 00:49:11,620
它基本上描述了旋转将在哪里发生 

918
00:49:11,620 --> 00:49:15,237
所以如果它绕着左上角旋转 我们旋转一些东西 

919
00:49:15,237 --> 00:49:17,570
它会产生像精灵一样的效果

920
00:49:17,570 --> 00:49:20,150
以一种奇怪的方式围成一圈 

921
00:49:20,150 --> 00:49:23,960
如果我们基于实际精灵的原点旋转精灵

922
00:49:23,960 --> 00:49:28,760
本身 这将具有在其中心旋转精灵的效果 

923
00:49:28,760 --> 00:49:31,520
因此 您可以将原点设置为您想要设置位置

924
00:49:31,520 --> 00:49:35,180
它将围绕该点进行360度旋转 

925
00:49:35,180 --> 00:49:37,590
我们将这一点设定为一半--

926
00:49:37,590 --> 00:49:40,040
基本上到我们画精灵的中间 

927
00:49:40,040 --> 00:49:42,720
所以当我们给它这个角度时 它会产生这样的效果 

928
00:49:42,720 --> 00:49:46,880
自身网体要获得角度 旋转时就会发生在原地 

929
00:49:46,880 --> 00:49:50,570
这不会发生--左上角不会有什么奇怪的事情

930
00:49:50,570 --> 00:49:52,770
轮换 这不是我们想要的 

931
00:49:52,770 --> 00:49:55,840
因此 当你看到起源中心被这样修改时 

932
00:49:55,840 --> 00:49:58,610
你可以假设这是因为我们有一个偏移量

933
00:49:58,610 --> 00:50:01,550
我们试图找到我们所画的地方的中心

934
00:50:01,550 --> 00:50:04,980
然后绕着它旋转 做一个原地旋转 

935
00:50:04,980 --> 00:50:08,720
但不一定 你也可以画一些东西 

936
00:50:08,720 --> 00:50:12,800
你也可以 也许你想要某种神奇的能量球

937
00:50:12,800 --> 00:50:15,230
绕着棍子或其他东西旋转 

938
00:50:15,230 --> 00:50:17,780
所以你想让它绕着不同的中心旋转 

939
00:50:17,780 --> 00:50:20,660
或者你随意想要的任何东西 

940
00:50:20,660 --> 00:50:23,840
但通常情况下 至少在我见过的大部分情况下 

941
00:50:23,840 --> 00:50:27,950
这对于确保您的旋转 您的原地旋转 

942
00:50:27,950 --> 00:50:29,360
被准确地渲染 

943
00:50:29,360 --> 00:50:33,320
关于外星人职业是如何工作的 有什么问题吗？

944
00:50:36,860 --> 00:50:38,340
好的 

945
00:50:38,340 --> 00:50:40,650
这就是外星人班级 

946
00:50:40,650 --> 00:50:44,160
这基本上是我们游戏的基本组成部分 

947
00:50:44,160 --> 00:50:48,120
另一个部分是障碍 

948
00:50:48,120 --> 00:50:50,280
我们有障碍 我们有外星人 

949
00:50:50,280 --> 00:50:53,610
障碍物和外星人实际上非常相似 

950
00:50:53,610 --> 00:50:55,560
那么 这两者有什么不同呢？

951
00:50:55,560 --> 00:50:58,080
我的意思是 归根结底 它们有什么相似之处？

952
00:51:03,470 --> 00:51:05,430
观众：他们都很有活力 

953
00:51:05,430 --> 00:51:07,580
科尔顿·奥格登：是的 它们都是充满活力的物体 

954
00:51:07,580 --> 00:51:11,720
真的 障碍物和外星人唯一不同的是

955
00:51:11,720 --> 00:51:14,570
是我们在场景中如何处理它们以及它们是如何渲染的 

956
00:51:14,570 --> 00:51:16,760
但它们的功能非常相似 

957
00:51:16,760 --> 00:51:18,950
它们只是我们赋予其形状的动态体

958
00:51:18,950 --> 00:51:21,200
我们把它们渲染成那个形状 

959
00:51:24,680 --> 00:51:28,670
在这种情况下 障碍构造器 我们已经

960
00:51:28,670 --> 00:51:33,540
我决定把它设计成水平或垂直的形状 

961
00:51:33,540 --> 00:51:36,620
这与我们之前看到的外星人的类型相似 

962
00:51:36,620 --> 00:51:38,840
它可以是正方形也可以是圆形 

963
00:51:38,840 --> 00:51:45,860
在这种情况下 如果我们回过头来看看我们的精灵工作表 

964
00:51:45,860 --> 00:51:48,124
我们可以看到有一大堆不同的形状 

965
00:51:48,124 --> 00:51:51,290
但我们在这个游戏中要用到的只有两个形状 

966
00:51:51,290 --> 00:51:55,970
仅为演示 这里是水平的、干净的木制形状

967
00:51:55,970 --> 00:51:59,150
还有这个垂直的 就在这里 

968
00:51:59,150 --> 00:52:02,120
所以为了找出这些东西 我不得不敞开心扉

969
00:52:02,120 --> 00:52:05,567
基本上就是我的精灵编辑器中的这个精灵 

970
00:52:05,567 --> 00:52:08,150
找出XY宽度和高度的位置 然后创建

971
00:52:08,150 --> 00:52:10,340
一个四人手动队离开那里 

972
00:52:10,340 --> 00:52:14,120
然后我编辑了util点Lua--或者不是util点Lua 

973
00:52:14,120 --> 00:52:17,480
依赖关系在这里点缀着Lua 

974
00:52:17,480 --> 00:52:21,050
正常情况下 我们只需创建框架 然后使用生成四边形 

975
00:52:21,050 --> 00:52:25,460
你可以像对待外星人一样 用瓷砖 瓷砖

976
00:52:25,460 --> 00:52:28,190
就是这张精灵床单--

977
00:52:28,190 --> 00:52:29,510
这个就在这里 

978
00:52:29,510 --> 00:52:31,310
这些是35乘35的 

979
00:52:31,310 --> 00:52:32,720
这些是35乘35的 

980
00:52:32,720 --> 00:52:34,130
这些不是35x35 

981
00:52:34,130 --> 00:52:38,280
这些是一堆不同形状和大小的东西 

982
00:52:38,280 --> 00:52:47,840
所以我检查了一下 格框木板是用来手工制作四边形的 

983
00:52:47,840 --> 00:52:53,540
然后是四个 因为我还添加了半断线的形状 

984
00:52:53,540 --> 00:52:55,820
但我们实际上并不使用这些 

985
00:52:55,820 --> 00:53:03,100
但你可以决定在碰撞时把这些变成这些 

986
00:53:03,100 --> 00:53:06,350
也许如果速度还不够强 不足以打破它 

987
00:53:06,350 --> 00:53:09,740
但你想要得到某种反馈 说你与它发生了冲突 

988
00:53:09,740 --> 00:53:15,140
您只需将该对象的碰撞帧设置为1或2即可 

989
00:53:15,140 --> 00:53:18,950
而不是2 并适当地渲染它 

990
00:53:18,950 --> 00:53:21,380
但如果你面对的是精灵床单

991
00:53:21,380 --> 00:53:26,450
而那张精灵纸上的精灵分布得很奇怪 

992
00:53:26,450 --> 00:53:29,480
有时 您必须手动找出偏移量的位置

993
00:53:29,480 --> 00:53:31,190
然后用这种方式来做 

994
00:53:31,190 --> 00:53:34,910
理想的情况是 您不必这样做 并且可以通过编程来完成 

995
00:53:34,910 --> 00:53:38,270
但这真的取决于游戏 你的域名是什么

996
00:53:38,270 --> 00:53:42,090
以及您在场景中与哪些对象交互 

997
00:53:42,090 --> 00:53:44,950
对于为什么或如何做到这一点 有什么问题吗？

998
00:53:47,700 --> 00:53:48,320
凉爽的 

999
00:53:48,320 --> 00:53:51,780
那么回到障碍上来吧 

1000
00:53:51,780 --> 00:53:54,020
所以它们是水平的或垂直的 这是

1001
00:53:54,020 --> 00:53:55,730
是将帧设置为2还是4 

1002
00:53:55,730 --> 00:54:02,180
两个或四个在框架中 我有一只手的四个四边形 

1003
00:54:02,180 --> 00:54:03,620
计算出的坐标 

1004
00:54:06,350 --> 00:54:09,800
真的 在这一点上并没有太大的不同 

1005
00:54:09,800 --> 00:54:15,260
如果它是水平或垂直的形状 

1006
00:54:15,260 --> 00:54:17,690
然后我们需要适当地设置它的宽度和高度 

1007
00:54:17,690 --> 00:54:19,820
因为它会有不同的宽度和高度 

1008
00:54:19,820 --> 00:54:22,770
如果它是垂直的 显然高度高于宽度 

1009
00:54:22,770 --> 00:54:25,910
如果它是水平的 情况正好相反 

1010
00:54:25,910 --> 00:54:27,929
但它们都是长方形的 

1011
00:54:27,929 --> 00:54:29,720
这样你就可以传递宽度和高度

1012
00:54:29,720 --> 00:54:32,520
在你计算之后 并给它正确的形状 

1013
00:54:32,520 --> 00:54:33,770
然后将其归因于一种固定装置 

1014
00:54:33,770 --> 00:54:37,310
然后设置用户数据在这种情况下 我们将用户数据设置为障碍 

1015
00:54:37,310 --> 00:54:40,760
所以现在这个障碍 特别是固定装置 

1016
00:54:40,760 --> 00:54:45,080
知道这是一种障碍 而不是作为一个外星人 而不是

1017
00:54:45,080 --> 00:54:47,510
成为其他任何东西 而不是成为地面 

1018
00:54:47,510 --> 00:54:54,500
因此 当我们在几分钟内探索什么定制碰撞 世界

1019
00:54:54,500 --> 00:54:56,420
碰撞回调 我们实际上可以

1020
00:54:56,420 --> 00:54:58,940
定义所有这些有趣的碰撞行为 

1021
00:54:58,940 --> 00:55:01,370
这些用户数据将是相关的 

1022
00:55:01,370 --> 00:55:08,310
然后我们像以前一样渲染外星人一样渲染它 

1023
00:55:08,310 --> 00:55:10,875
所以任何关于障碍物和外星人的问题 它们有什么不同 

1024
00:55:10,875 --> 00:55:11,750
它们有什么相同之处？

1025
00:55:14,588 --> 00:55:15,750
凉爽的 

1026
00:55:15,750 --> 00:55:16,250
好的 

1027
00:55:16,250 --> 00:55:18,500
现在让我们休息五分钟 

1028
00:55:18,500 --> 00:55:21,710
当我们回来时 我们将实际查看播放状态 

1029
00:55:21,710 --> 00:55:23,870
我们来看看怎样才能达到水平 

1030
00:55:23,870 --> 00:55:27,650
我们将真正了解如何定制这个世界

1031
00:55:27,650 --> 00:55:32,480
以与我们的游戏行为相关的方式解决冲突 

1032
00:55:32,480 --> 00:55:36,080
比如 当我们与物体相撞时 如何让它们破碎 

1033
00:55:36,080 --> 00:55:40,310
当我们摧毁这只鸟时 如何让胜利屏幕弹出来 

1034
00:55:40,310 --> 00:55:41,240
以此类推 

1035
00:55:43,971 --> 00:55:44,470
好的 

1036
00:55:44,470 --> 00:55:45,250
欢迎回来 

1037
00:55:45,250 --> 00:55:47,110
所以在我们休息之前 我们在谈论

1038
00:55:47,110 --> 00:55:51,120
关于我们游戏中的外星人和障碍

1039
00:55:51,120 --> 00:55:52,880
相互影响的世界 

1040
00:55:52,880 --> 00:55:58,900
他们是让我们的游戏大幅削减《愤怒的小鸟》发挥作用的支柱 

1041
00:55:58,900 --> 00:56:02,170
你把外星人扔进障碍物 障碍物就会被打破 

1042
00:56:02,170 --> 00:56:07,660
坏猪砍死外星人 然后你就得分了 

1043
00:56:07,660 --> 00:56:10,120
但我们实际上必须对这些相互作用进行建模

1044
00:56:10,120 --> 00:56:13,030
我们必须告诉我们的游戏 我们的世界 什么

1045
00:56:13,030 --> 00:56:16,900
当这些碰撞发生时 为了让事情变得更有趣

1046
00:56:16,900 --> 00:56:19,354
而不仅仅是物体相互弹跳才能工作 

1047
00:56:19,354 --> 00:56:20,520
这是默认行为 

1048
00:56:20,520 --> 00:56:26,230
默认情况下 Box2D的目标是当两个物体重叠时 

1049
00:56:26,230 --> 00:56:29,170
假设它们是动态的 或者至少其中一个是动态的 

1050
00:56:29,170 --> 00:56:34,840
就是推开动态物体 直到它们不再重叠

1051
00:56:34,840 --> 00:56:38,950
通过位置或旋转 

1052
00:56:38,950 --> 00:56:42,640
但这不是我们比赛的主旨或目标 

1053
00:56:42,640 --> 00:56:45,490
因为我们希望发生的是不同的事情发生

1054
00:56:45,490 --> 00:56:49,330
某些东西消失了 破碎了 还有各种各样的其他东西

1055
00:56:49,330 --> 00:56:52,210
当不同种类的物体

1056
00:56:52,210 --> 00:56:56,290
以不同的速度与不同类型的物体交互 

1057
00:56:56,290 --> 00:57:00,790
因此 为了做到这一点 我们需要定义冲突回调

1058
00:57:00,790 --> 00:57:01,630
为了我们的世界 

1059
00:57:01,630 --> 00:57:04,810
因此 回调 recall 是一个函数 它得到

1060
00:57:04,810 --> 00:57:06,850
出事的时候给我回电话 

1061
00:57:06,850 --> 00:57:12,950
它只是在特定时间或以后会被调用的东西 

1062
00:57:12,950 --> 00:57:16,090
我们可以为我们的世界定义这些回调

1063
00:57:16,090 --> 00:57:19,210
这样当两个物体相互碰撞时 

1064
00:57:19,210 --> 00:57:23,350
它将执行此回调 然后执行相应的逻辑

1065
00:57:23,350 --> 00:57:25,750
这是我们在其中定义的 

1066
00:57:25,750 --> 00:57:30,850
对于Box2D中的每个冲突 都会发生四个回调 

1067
00:57:30,850 --> 00:57:35,770
有开始接触 所以当两件事开始重叠时

1068
00:57:35,770 --> 00:57:37,630
或者开始彼此联系 

1069
00:57:37,630 --> 00:57:40,480
结束接触 所以一旦结束 一旦两个物体

1070
00:57:40,480 --> 00:57:42,990
被彼此推开 

1071
00:57:42,990 --> 00:57:46,270
已预先解决 这发生在碰撞实际得到

1072
00:57:46,270 --> 00:57:50,200
在Box2D中解决 这意味着这些东西相互推开 

1073
00:57:50,200 --> 00:57:54,130
然后后解决 意思是在他们被推开之后 

1074
00:57:54,130 --> 00:57:58,040
尤其是后解题很有趣

1075
00:57:58,040 --> 00:58:02,540
因为它获得了有关如何解决冲突的信息 

1076
00:58:02,540 --> 00:58:08,650
那么在这种相互作用中需要多大的速度或自转 

1077
00:58:08,650 --> 00:58:12,340
我们不会使用末端接触、预解算或后解算 

1078
00:58:12,340 --> 00:58:15,370
我们将只使用Begin Contact 因为 真的

1079
00:58:15,370 --> 00:58:18,612
我们所需要的就是模拟我们正在寻找的行为 

1080
00:58:18,612 --> 00:58:20,320
因为在我们的游戏中发生的任何事情

1081
00:58:20,320 --> 00:58:23,170
只要两个物体相互接触 我们就能搞清楚 

1082
00:58:25,730 --> 00:58:28,600
这些都是 如果你对一个教程感兴趣的话

1083
00:58:28,600 --> 00:58:31,420
可能会更详细地介绍这些内容 

1084
00:58:31,420 --> 00:58:33,520
幻灯片中有一个链接 

1085
00:58:33,520 --> 00:58:38,470
但我将向您展示如何自己实际实现这些回调 

1086
00:58:38,470 --> 00:58:42,040
这是通过一个名为World Set Callback的函数来实现的 

1087
00:58:42,040 --> 00:58:45,110
在本例中为F1、F2、F3、F4 

1088
00:58:45,110 --> 00:58:47,770
回想一下 因为Lua是一种动态语言 其中函数

1089
00:58:47,770 --> 00:58:52,210
是第一类对象 则可以将函数作为参数传递

1090
00:58:52,210 --> 00:58:53,300
转到其他功能 

1091
00:58:53,300 --> 00:58:54,260
这就是我们在这里做的事情 

1092
00:58:54,260 --> 00:58:56,218
假设我们有四个函数

1093
00:58:56,218 --> 00:59:00,820
我们已经定义了开始接触 结束接触 解算前或解算后 

1094
00:59:00,820 --> 00:59:03,250
他们的真实名字根本无关紧要 

1095
00:59:03,250 --> 00:59:05,881
这些只是它们的实际名称 

1096
00:59:05,881 --> 00:59:09,130
重要的是 您在那里有逻辑 并且您传递函数对象

1097
00:59:09,130 --> 00:59:11,170
它们会表现出一些东西 

1098
00:59:11,170 --> 00:59:15,130
并且您可以传入所有空函数 而Box2D仍将正常运行 

1099
00:59:15,130 --> 00:59:20,680
只有当你想要更复杂的行为从你的游戏中消失的时候 这些才会出现

1100
00:59:20,680 --> 00:59:23,320
不只是物体相互弹跳

1101
00:59:23,320 --> 00:59:26,200
并且彼此相对移动 

1102
00:59:26,200 --> 00:59:29,620
那么 这有意义吗？

1103
00:59:29,620 --> 00:59:32,020
因此 我们将看看这是如何实际工作的 

1104
00:59:32,020 --> 00:59:34,390
我们将继续进行 并开放Level doLua 

1105
00:59:34,390 --> 00:59:37,090
因此Level..Lua是一个容器类 

1106
00:59:37,090 --> 00:59:40,120
基本上有我们的游戏水平 包括

1107
00:59:40,120 --> 00:59:42,430
世界和所有实体 

1108
00:59:42,430 --> 00:59:47,391
我们更新它 并能够有效地建模 

1109
00:59:47,391 --> 00:59:48,640
就像《愤怒的小鸟》中的关卡 

1110
00:59:48,640 --> 00:59:50,080
事实就是如此 

1111
00:59:50,080 --> 00:59:51,220
它有一个世界 

1112
00:59:51,220 --> 00:59:55,720
所以水平线有自己的世界 有300正Y重力 就像我们之前看到的 

1113
00:59:55,720 --> 00:59:58,630
它有一张桌子 叫做被毁的身体 

1114
00:59:58,630 --> 01:00:01,160
我们稍后会看到这一点 

1115
01:00:01,160 --> 01:00:02,710
然后这里我们有四个函数 

1116
01:00:02,710 --> 01:00:06,730
从第22行开始 我们有了Begin Contact 这是一个长函数 

1117
01:00:06,730 --> 01:00:09,510
然后我们有结束接触 预解和后解 

1118
01:00:09,510 --> 01:00:11,590
这四个回调函数是我

1119
01:00:11,590 --> 01:00:14,659
几秒钟前才提到 

1120
01:00:14,659 --> 01:00:16,450
他们接受的签名略有不同 

1121
01:00:16,450 --> 01:00:19,150
前三个分别是A、B和碰撞 

1122
01:00:19,150 --> 01:00:23,260
然后最后一个是A B 碰撞 然后是正常的冲量

1123
01:00:23,260 --> 01:00:26,680
和切线冲量 这是它需要按顺序施加的力

1124
01:00:26,680 --> 01:00:29,620
将这两个物体分开 

1125
01:00:29,620 --> 01:00:31,840
就像我说的 我们不会使用这三个函数 

1126
01:00:31,840 --> 01:00:36,550
但在某些情况下 您可能需要使用这些函数 

1127
01:00:36,550 --> 01:00:40,330
也许你想要结束接触 因为在你的游戏中 两个物体连接在一起

1128
01:00:40,330 --> 01:00:43,640
当它们相互碰撞时 也许它们是有磁性的或什么的 

1129
01:00:43,640 --> 01:00:46,550
然后 一旦它们分开 也许你想要粒子效果

1130
01:00:46,550 --> 01:00:50,690
或者是什么来表明他们已经分居了什么的 

1131
01:00:50,690 --> 01:00:52,310
然后进行预解算和后解算 

1132
01:00:52,310 --> 01:00:54,980
PResolve 我现在想不出一个用例 

1133
01:00:54,980 --> 01:00:59,360
但后期解算可能有用 取决于您的游戏 

1134
01:00:59,360 --> 01:01:03,552
你是不是只需要计算出

1135
01:01:03,552 --> 01:01:04,760
他们需要分开 

1136
01:01:04,760 --> 01:01:11,540
也许你把它乘以某个数量 就会产生某种戏剧性的效果 

1137
01:01:11,540 --> 01:01:14,120
这些最终取决于您的游戏领域 

1138
01:01:14,120 --> 01:01:16,120
我们今天要使用的重要功能

1139
01:01:16,120 --> 01:01:18,830
是第一个 开始联系 

1140
01:01:18,830 --> 01:01:21,050
注意 我们已经定义了这四个函数 

1141
01:01:21,050 --> 01:01:23,460
即使这三个只是空的 

1142
01:01:23,460 --> 01:01:27,080
但就像我之前说过的那样 我们通过了SET回调

1143
01:01:27,080 --> 01:01:29,510
函数包含这四个函数 

1144
01:01:29,510 --> 01:01:33,410
注意另一件有趣的事情 因为Lua的动态性质 Line

1145
01:01:33,410 --> 01:01:35,330
11您可以看到我们有Level init 它

1146
01:01:35,330 --> 01:01:37,820
是我们的Level类的构造函数 

1147
01:01:37,820 --> 01:01:41,060
在构造函数中 我们定义了更多函数 

1148
01:01:41,060 --> 01:01:45,020
您可以根据需要定义任意多层的函数 

1149
01:01:45,020 --> 01:01:47,690
您甚至可以从函数返回函数 这

1150
01:01:47,690 --> 01:01:50,959
被称为高阶函数 

1151
01:01:50,959 --> 01:01:52,250
真的想做什么就做什么 

1152
01:01:52,250 --> 01:01:55,730
在本例中 我们只是在内部定义冲突回调

1153
01:01:55,730 --> 01:01:56,321
我们的初始版本 

1154
01:01:56,321 --> 01:01:58,320
但你可以把最多的放在你想放的任何地方 

1155
01:01:58,320 --> 01:02:01,370
你可以在课外使用 你可以在任何你想要的地方使用 

1156
01:02:01,370 --> 01:02:03,828
您可以在您的主点Lua中将它们作为全局函数 

1157
01:02:03,828 --> 01:02:05,660
我不知道我对此有何感想 

1158
01:02:05,660 --> 01:02:08,930
但只要这些功能存在 您就可以做任何您想做的事情

1159
01:02:08,930 --> 01:02:11,180
你可以引用他们的符号 你可以传递他们

1160
01:02:11,180 --> 01:02:14,540
进入自己的点世界 设置回调 

1161
01:02:14,540 --> 01:02:19,490
现在 每当碰撞发生在世界周期 

1162
01:02:19,490 --> 01:02:22,640
它会调用这四个函数

1163
01:02:22,640 --> 01:02:26,040
在每次碰撞的每个阶段 

1164
01:02:26,040 --> 01:02:29,960
所以你可以看到 

1165
01:02:29,960 --> 01:02:33,810
如果你用你所有的逻辑来衡量的话 

1166
01:02:33,810 --> 01:02:36,100
如果你有一百万行代码在每一个

1167
01:02:36,100 --> 01:02:38,796
每次碰撞它要执行百万行代码 

1168
01:02:38,796 --> 01:02:39,920
你可能会遇到麻烦

1169
01:02:39,920 --> 01:02:43,910
但幸运的是 我们不会去接近它 

1170
01:02:43,910 --> 01:02:49,100
开始接触的要点 所以它接受了A B和碰撞 

1171
01:02:49,100 --> 01:02:53,100
我们不用碰撞本身 我们只用A和B

1172
01:02:53,100 --> 01:02:56,060
因为这就是我们游戏世界所需要的 

1173
01:02:56,060 --> 01:02:58,868
A和B是什么？

1174
01:02:58,868 --> 01:03:00,368
我们知道A和B是什么吗？

1175
01:03:00,368 --> 01:03:02,000
观众：可能是两个物体[听不见] 

1176
01:03:02,000 --> 01:03:02,810
科尔顿·奥格登：这两个物体 

1177
01:03:02,810 --> 01:03:04,685
你知道是尸体还是固定物吗？

1178
01:03:08,749 --> 01:03:10,040
观众：这将是固定装置 

1179
01:03:10,040 --> 01:03:11,623
科尔顿·奥格登：这将是一个固定装置 

1180
01:03:11,623 --> 01:03:14,640
是固定装置相互碰撞 而不是身体 

1181
01:03:14,640 --> 01:03:18,420
所以当你有一个实体时 回忆一下夹具将形状附加到实体上 

1182
01:03:18,420 --> 01:03:22,830
物体只是一个位置和速度的容器 

1183
01:03:22,830 --> 01:03:24,150
身体是 

1184
01:03:24,150 --> 01:03:27,810
每一个固定装置都会与其他东西发生碰撞 

1185
01:03:27,810 --> 01:03:30,150
你游戏世界里的其他装置

1186
01:03:30,150 --> 01:03:33,700
所以 回想一下 在我们有固定装置之前 

1187
01:03:33,700 --> 01:03:36,480
设置用户数据 因为这就是我们最终

1188
01:03:36,480 --> 01:03:39,720
我们需要有碰撞的数据 

1189
01:03:39,720 --> 01:03:43,650
我们通过获取用户数据来检查

1190
01:03:43,650 --> 01:03:46,230
或者我们给那个装置的元数据 

1191
01:03:46,230 --> 01:03:51,690
然后我们就可以用这种方法来区分不同类别的对象 

1192
01:03:51,690 --> 01:03:55,630
我们可以说 哦 这个物体是外星人 或者这个物体是一个障碍物 

1193
01:03:55,630 --> 01:03:56,880
或者这个物体是地面

1194
01:03:56,880 --> 01:03:59,129
然后我们可以说 哦 我们是不是撞上了外星人？

1195
01:03:59,129 --> 01:04:01,830
是外星人与地面的碰撞？

1196
01:04:01,830 --> 01:04:04,620
如果是的话 好吧 让我们播放一个弹跳的声音效果 

1197
01:04:04,620 --> 01:04:07,230
如果是一个外星人和另一个外星人 

1198
01:04:07,230 --> 01:04:10,170
和另一个外星人 而且速度足够快 

1199
01:04:10,170 --> 01:04:11,820
好吧 外星人应该去死 

1200
01:04:11,820 --> 01:04:12,420
对吗？

1201
01:04:12,420 --> 01:04:15,810
我们可以做武断的事情 

1202
01:04:15,810 --> 01:04:19,320
所以我在这里编程的方式是 我们

1203
01:04:19,320 --> 01:04:21,870
可以看到是什么两个东西相互作用 

1204
01:04:21,870 --> 01:04:26,280
这是对用户数据的一个非常简单的使用 

1205
01:04:26,280 --> 01:04:31,020
我们在这个代码库中所做的只是将字符串分配给装备 

1206
01:04:31,020 --> 01:04:34,770
但是您可以将表分配给具有任意数据量的装置

1207
01:04:34,770 --> 01:04:36,780
做各种各样的事情 

1208
01:04:36,780 --> 01:04:39,120
在本例中 我们只使用字符串 

1209
01:04:39,120 --> 01:04:42,960
所以我创建了一张桌子 一张空桌子 然后我就

1210
01:04:42,960 --> 01:04:47,490
在表中 在该字符串处赋值为真 

1211
01:04:47,490 --> 01:04:49,360
然后我就可以查询那个表了 

1212
01:04:49,360 --> 01:04:52,200
我有关键球员和关键外星人吗？

1213
01:04:52,200 --> 01:04:56,324
我有一个关键障碍和一个关键障碍吗？

1214
01:04:56,324 --> 01:04:58,740
这就是您可以计算出您的两个对象是什么的方法 

1215
01:04:58,740 --> 01:05:02,242
因为A可能是一个球员 而B可能是一个障碍 

1216
01:05:02,242 --> 01:05:04,200
A可以是障碍 B可以是球员 

1217
01:05:04,200 --> 01:05:08,050
所以你必须把这两点都考虑进去 

1218
01:05:08,050 --> 01:05:12,990
所以它允许我们这样做 如果类型障碍和类型球员 所以

1219
01:05:12,990 --> 01:05:20,370
球员与障碍物的碰撞 如果速度足够快 那么我们

1220
01:05:20,370 --> 01:05:22,750
可以摧毁障碍物 

1221
01:05:22,750 --> 01:05:23,880
这就是我们在这里做的事情 

1222
01:05:23,880 --> 01:05:29,760
所以我取X和Y轴上速度的绝对值 

1223
01:05:29,760 --> 01:05:33,790
所以我计算 X Y 得到物体的线速度 

1224
01:05:33,790 --> 01:05:37,220
所以线速度就是它在世界上移动的地方 

1225
01:05:37,220 --> 01:05:42,360
它返回两个值 因为速度有X和Y分量 

1226
01:05:42,360 --> 01:05:48,810
然后我们在这里求和 取两部分的绝对值

1227
01:05:48,810 --> 01:05:50,230
然后把它们加在一起 

1228
01:05:50,230 --> 01:05:54,450
因此 如果它在x轴上移动得很快 但在y轴上移动得不快 

1229
01:05:54,450 --> 01:05:57,420
或者如果它在两个方向上都没有快速移动 或者如果它在两个方向上都快速移动 

1230
01:05:57,420 --> 01:06:02,220
一般来说 我们有一个感觉 物体的平均速度是多少 

1231
01:06:02,220 --> 01:06:04,620
如果它在任一轴上快速移动 我们

1232
01:06:04,620 --> 01:06:08,580
可以假设这是足够的力来导致物体

1233
01:06:08,580 --> 01:06:10,500
会被毁掉 对吧？

1234
01:06:10,500 --> 01:06:14,250
如果速度大于20 我们就会这样做 这是一个任意值

1235
01:06:14,250 --> 01:06:16,680
我想出的那个似乎是合适的 

1236
01:06:16,680 --> 01:06:19,370
然后我们就要这么做了 

1237
01:06:19,370 --> 01:06:24,280
桌子圆点插入自我圆点毁灭的身体 这是我们之前看到的 

1238
01:06:24,280 --> 01:06:25,860
然后是障碍物的身体 

1239
01:06:25,860 --> 01:06:30,030
现在 为什么我们在这里插入该值为

1240
01:06:30,030 --> 01:06:33,968
反对 也许只是在这个函数中销毁它？

1241
01:06:38,155 --> 01:06:39,530
观众：破坏灯具 

1242
01:06:39,530 --> 01:06:41,080
科尔顿·奥格登：毁灭肉体 

1243
01:06:41,080 --> 01:06:43,490
固定装置 是的 在这种情况下 

1244
01:06:43,490 --> 01:06:45,110
观众：对不起 我是说这场比赛 

1245
01:06:45,110 --> 01:06:47,360
因为您稍后仍会在代码中引用它 

1246
01:06:47,360 --> 01:06:49,735
Colton Ogden：您在代码的后面仍在引用 

1247
01:06:49,735 --> 01:06:52,070
Box2D维护对所有Body、All

1248
01:06:52,070 --> 01:06:58,820
你的世界中的固定装置 而不管

1249
01:06:58,820 --> 01:07:00,440
不管你有没有删除它们 

1250
01:07:00,440 --> 01:07:03,470
但是如果你在它正在运行的时候把它们删除 

1251
01:07:03,470 --> 01:07:06,950
就像检查冲突一样 它会尝试进行另一次冲突

1252
01:07:06,950 --> 01:07:12,100
使用被销毁的主体 您将得到崩溃或堆栈溢出错误 

1253
01:07:12,100 --> 01:07:14,300
我发现这两件事我都经历过 

1254
01:07:14,300 --> 01:07:19,940
你不会想要在碰撞中删除或销毁任何东西

1255
01:07:19,940 --> 01:07:21,260
回拨你的世界 

1256
01:07:21,260 --> 01:07:24,192
它会导致可怕的事情发生 

1257
01:07:24,192 --> 01:07:26,900
所以我们所做的就是保持对我们所做的一切的引用

1258
01:07:26,900 --> 01:07:29,480
只要把它插进去就会毁了它 

1259
01:07:29,480 --> 01:07:37,220
所以如果我们把我们想要的任何东西的身体放进被销毁的身体里 

1260
01:07:37,220 --> 01:07:40,250
然后 我们可以在世界更新后对其进行循环 

1261
01:07:40,250 --> 01:07:45,750
然后在更新函数之外逐个销毁它们 

1262
01:07:45,750 --> 01:07:49,760
我们通过身体而不是固定装置的原因

1263
01:07:49,760 --> 01:07:55,430
当我们摧毁一具身体时 它就摧毁了所有的固定装置

1264
01:07:55,430 --> 01:07:57,451
也与那具身体有关 

1265
01:07:57,451 --> 01:07:59,700
所以我们只是在摧毁这里的顶层集装箱 

1266
01:07:59,700 --> 01:08:04,970
在这种情况下 我们是销毁一个固定装置还是销毁一个身体并不重要

1267
01:08:04,970 --> 01:08:09,090
因为这是一对一的关系 

1268
01:08:09,090 --> 01:08:14,012
但如果你有 比方说 一个身体上有五个固定物 

1269
01:08:14,012 --> 01:08:16,220
如果这整个东西和别的东西相撞

1270
01:08:16,220 --> 01:08:18,080
你想毁掉这一切

1271
01:08:18,080 --> 01:08:20,479
你想毁掉的是尸体而不是一个人

1272
01:08:20,479 --> 01:08:24,410
因为当你摧毁尸体的时候 它摧毁了所有的固定装置 而不仅仅是

1273
01:08:24,410 --> 01:08:25,760
唯一的固定装置 

1274
01:08:25,760 --> 01:08:29,990
所以我们删除了尸体 把尸体加到被摧毁的尸体上 

1275
01:08:29,990 --> 01:08:34,189
然后再删除

1276
01:08:34,189 --> 01:08:39,740
函数在这里被销毁 

1277
01:08:39,740 --> 01:08:42,350
所以在157行--

1278
01:08:42,350 --> 01:08:45,859
从155到159 这就是我们

1279
01:08:45,859 --> 01:08:48,310
把所有我们想标记的东西都盖上 

1280
01:08:48,310 --> 01:08:51,560
或者我们标记为已销毁的 然后销毁

1281
01:08:51,560 --> 01:08:55,910
如果身体没有被摧毁 那就摧毁它 

1282
01:08:55,910 --> 01:09:01,790
一旦我们摧毁了它 我们就到这里 

1283
01:09:01,790 --> 01:09:05,420
实际上消除了障碍和外星人阶级

1284
01:09:05,420 --> 01:09:09,410
从我们的外星人和障碍物列表中删除

1285
01:09:09,410 --> 01:09:12,479
因为它保持了我们所画的

1286
01:09:12,479 --> 01:09:13,979
我们也想删除它

1287
01:09:13,979 --> 01:09:17,450
所以我们不仅想从世界上删除这个物体 

1288
01:09:17,450 --> 01:09:19,970
我们要删除我们创建的对象

1289
01:09:19,970 --> 01:09:23,090
用来包装尸体和固定装置

1290
01:09:23,090 --> 01:09:26,540
还有外星人的画像 这样它就不会再被吸引到这个场景 

1291
01:09:26,540 --> 01:09:27,388
基本上

1292
01:09:30,020 --> 01:09:36,410
所以 永远不要删除回调函数中的body或fixture 

1293
01:09:36,410 --> 01:09:39,109
总是标记它们 然后删除它们 

1294
01:09:39,109 --> 01:09:43,700
基本上 不要在世界更新功能的中间删除

1295
01:09:43,700 --> 01:09:45,410
这就是我们在这里看到的 

1296
01:09:45,410 --> 01:09:49,550
请注意 这发生在152 正在进行自我世界更新 

1297
01:09:49,550 --> 01:09:55,850
然后在155到159 我们通过碰撞填充了被摧毁的身体 

1298
01:09:55,850 --> 01:09:57,780
我们在上面定义的回调 

1299
01:09:57,780 --> 01:10:00,650
在这里 我们可以摧毁一切 

1300
01:10:00,650 --> 01:10:04,920
这是更新功能之外的 这里是世界更新功能 

1301
01:10:04,920 --> 01:10:08,210
我们不需要担心堆栈溢出或segfault 

1302
01:10:08,210 --> 01:10:13,070
我们可以删除中间的内容

1303
01:10:13,070 --> 01:10:16,280
来处理碰撞 

1304
01:10:16,280 --> 01:10:17,390
不幸的bug

1305
01:10:17,390 --> 01:10:21,620
如果您发现自己遇到了堆栈溢出或段错误

1306
01:10:21,620 --> 01:10:25,680
在冲突回调中 请确保没有删除任何内容 

1307
01:10:25,680 --> 01:10:28,430
但我们可以在这里看到 它非常相似 行为

1308
01:10:28,430 --> 01:10:32,960
我们定义了障碍和玩家之间 障碍和外星人之间 

1309
01:10:32,960 --> 01:10:34,940
以及玩家和外星人之间的关系 

1310
01:10:34,940 --> 01:10:38,480
最终 它要检查的是它的平均速度

1311
01:10:38,480 --> 01:10:41,000
大于某个数字 在本例中为20 

1312
01:10:41,000 --> 01:10:44,627
如果是 则将其标记为已销毁 

1313
01:10:44,627 --> 01:10:46,460
因此 如果玩家击中外星人 摧毁它 

1314
01:10:46,460 --> 01:10:48,560
如果障碍物击中外星人 摧毁它 

1315
01:10:48,560 --> 01:10:51,230
这与《愤怒的小鸟》中的工作原理相似 

1316
01:10:51,230 --> 01:10:57,020
当你在《愤怒的小鸟》中向建筑物扔东西和一块碎片时

1317
01:10:57,020 --> 01:11:00,740
从它上掉下来撞到猪 通常也会杀死猪 

1318
01:11:00,740 --> 01:11:04,331
如果你的鸟撞上了猪 通常会杀死猪 

1319
01:11:04,331 --> 01:11:06,830
但如果你移动得不够快 或者如果一块碎片

1320
01:11:06,830 --> 01:11:09,530
移动得还不够快 它只会轻推猪 

1321
01:11:09,530 --> 01:11:11,000
它实际上不会杀死那头猪 

1322
01:11:11,000 --> 01:11:13,820
这就是为什么我们要把所有这些都考虑进去 

1323
01:11:13,820 --> 01:11:18,780
我们不仅仅是在代码中盲目删除身体的内容 

1324
01:11:18,780 --> 01:11:22,540
我们实际上是在确定 它的移动速度是否也足够快 即

1325
01:11:22,540 --> 01:11:24,170
它有足够的力量吗？

1326
01:11:24,170 --> 01:11:28,890
如果是 则执行代码 然后执行删除或标记

1327
01:11:28,890 --> 01:11:30,210
已被删除 

1328
01:11:30,210 --> 01:11:33,110
因此 这就是为什么用户数据很重要的原因 

1329
01:11:33,110 --> 01:11:37,920
因为这就是我们能够--因为在回调中注意到

1330
01:11:37,920 --> 01:11:41,820
我们只得到了A和B 而这些将永远是固定的 

1331
01:11:41,820 --> 01:11:44,520
固定装置 以便它知道是哪种固定装置

1332
01:11:44,520 --> 01:11:48,000
它是 无论它属于玩家还是外星人 

1333
01:11:48,000 --> 01:11:50,010
我们需要给它一些信息 

1334
01:11:50,010 --> 01:11:55,090
因此 设置的用户数据将装置标记为特定类型 

1335
01:11:55,090 --> 01:11:58,170
然后我们可以使用Get User Data在这里获取它

1336
01:11:58,170 --> 01:12:02,490
然后实际执行相关的博弈逻辑 

1337
01:12:02,490 --> 01:12:05,424
对于这是如何工作的 有什么问题吗？

1338
01:12:05,424 --> 01:12:11,412
观众：你是在检查两个障碍物是否相撞吗？

1339
01:12:11,412 --> 01:12:14,370
科尔顿·奥格登：我是在检查两个相互碰撞的障碍物吗？

1340
01:12:14,370 --> 01:12:15,570
我可能不是 

1341
01:12:15,570 --> 01:12:18,720
如果是那样的话--你应该这样做 

1342
01:12:18,720 --> 01:12:21,930
在这种情况下 既然我们不是 他们就会撞在一起 

1343
01:12:21,930 --> 01:12:24,780
但是 是的 如果我们想要两个木制障碍

1344
01:12:24,780 --> 01:12:27,240
如果他们打得足够快的话就会互相摧毁 

1345
01:12:27,240 --> 01:12:29,340
你在这里也会做同样的事情 

1346
01:12:29,340 --> 01:12:32,850
如果类型有障碍 我想 

1347
01:12:32,850 --> 01:12:35,490
但在这种情况下 因为它们都是同一把钥匙 

1348
01:12:35,490 --> 01:12:39,342
你必须做的是 如果类型--

1349
01:12:39,342 --> 01:12:40,800
让我们看看我们怎么再做一次 

1350
01:12:40,800 --> 01:12:45,310
所以类型障碍是真的 类型障碍是真的 

1351
01:12:45,310 --> 01:12:50,740
你会说如果类型障碍而不是外星人类型 不是类型玩家 不是--

1352
01:12:50,740 --> 01:12:52,300
有一种更干净的方法来做这件事 

1353
01:12:52,300 --> 01:12:54,390
观众：就像一系列的[INAUDIBLE]声明 

1354
01:12:54,390 --> 01:12:54,630
科尔顿·奥格登：是的 

1355
01:12:54,630 --> 01:12:55,800
观众：[听不见]陈述 

1356
01:12:55,800 --> 01:12:56,591
科尔顿·奥格登：是的 

1357
01:12:56,591 --> 01:12:57,330
那是真的 

1358
01:12:57,330 --> 01:12:59,680
是啊 有很多种方法 

1359
01:12:59,680 --> 01:13:02,702
如果我要重新设计这个 我也会抽象出这个代码

1360
01:13:02,702 --> 01:13:03,660
并把它变成一个函数 

1361
01:13:03,660 --> 01:13:07,620
因为这三者之间的代码基本相同 

1362
01:13:07,620 --> 01:13:09,630
但为了说明 为了简单起见

1363
01:13:09,630 --> 01:13:12,080
因为这是非常相似的互动 

1364
01:13:12,080 --> 01:13:15,420
并没有真正在其中投入太多的工程预见性 

1365
01:13:15,420 --> 01:13:20,580
当然 如果您对它进行扩展 我会建议您这样做 

1366
01:13:20,580 --> 01:13:26,070
但这是让我们的世界表现得不仅仅是解决

1367
01:13:26,070 --> 01:13:28,620
碰撞和相互推开障碍物 这

1368
01:13:28,620 --> 01:13:31,690
是默认行为 

1369
01:13:31,690 --> 01:13:33,090
所以我们设置了回调 

1370
01:13:33,090 --> 01:13:33,630
我们很好 

1371
01:13:33,630 --> 01:13:36,671
现在 当我们彼此互动时 它们的行为会有所不同 

1372
01:13:36,671 --> 01:13:39,210
它们会引发不同的行为 

1373
01:13:39,210 --> 01:13:42,270
我们有一个叫发射标志的东西 一个外星人发射标志 

1374
01:13:42,270 --> 01:13:43,711
有人知道这可能是什么吗？

1375
01:13:47,559 --> 01:13:50,697
观众：这是显示轨迹的小圆点吗？

1376
01:13:50,697 --> 01:13:53,280
科尔顿·奥格登：是的 所以是圆点显示了轨迹 

1377
01:13:53,280 --> 01:13:56,220
这是一个 外星人被渲染在屏幕的左侧

1378
01:13:56,220 --> 01:14:00,180
没有任何物理作用 那就是点击和拖动 

1379
01:14:00,180 --> 01:14:02,040
它也会呈现出一个轨迹 

1380
01:14:02,040 --> 01:14:07,050
当你松开鼠标时 它会发射一个真正的Box 2D外星人

1381
01:14:07,050 --> 01:14:12,630
沿着轨迹所预示的方向移动

1382
01:14:12,630 --> 01:14:19,024
如果我们看这里的外星人发射标记 它基本上保持了一个参考 

1383
01:14:19,024 --> 01:14:20,190
不管我们有没有瞄准

1384
01:14:20,190 --> 01:14:21,600
所以它有几个州 

1385
01:14:21,600 --> 01:14:25,190
它有发射状态和瞄准状态 

1386
01:14:25,190 --> 01:14:27,960
我们最终会找到一个外星人 

1387
01:14:27,960 --> 01:14:30,400
会产生并给它一个动力

1388
01:14:30,400 --> 01:14:36,420
所以一个脉冲有效地将它的速度立即设置为某个值 

1389
01:14:36,420 --> 01:14:38,160
而不是随着时间的推移 

1390
01:14:38,160 --> 01:14:40,170
我们可以对物体施力 

1391
01:14:40,170 --> 01:14:43,230
就像你开车撞上了什么东西

1392
01:14:43,230 --> 01:14:46,110
然后逐渐加速 这就是施加力

1393
01:14:46,110 --> 01:14:49,920
我们也可以通过汽车全速行驶来施加冲力

1394
01:14:49,920 --> 01:14:52,230
撞击一个物体 

1395
01:14:52,230 --> 01:14:56,220
以一定速度施加脉冲的效果 

1396
01:14:56,220 --> 01:15:00,450
当我们拖着外星人然后把它放了 

1397
01:15:00,450 --> 01:15:03,480
我们要在相反的方向施加一个脉冲

1398
01:15:03,480 --> 01:15:06,060
基于一定量的拖动 

1399
01:15:06,060 --> 01:15:10,500
我把它放大了10倍 但你可以让它任意放大 

1400
01:15:10,500 --> 01:15:14,550
然后弹道模型会显示出它的去向 

1401
01:15:14,550 --> 01:15:20,110
轨迹是通过这些线计算出来的 

1402
01:15:20,110 --> 01:15:22,250
从第90行到第104行 

1403
01:15:22,250 --> 01:15:25,620
在Box 2D集合中有一个公式

1404
01:15:25,620 --> 01:15:27,390
的教程 这实际上告诉你如何

1405
01:15:27,390 --> 01:15:31,890
为了计算给定启动脉冲和启动脉冲的估计轨迹 

1406
01:15:31,890 --> 01:15:33,900
位置

1407
01:15:33,900 --> 01:15:36,060
也就是这个公式

1408
01:15:36,060 --> 01:15:38,190
有点复杂

1409
01:15:38,190 --> 01:15:40,500
这篇文章详细介绍了它是如何工作的 

1410
01:15:40,500 --> 01:15:45,420
但它有效地计算了1/60秒 

1411
01:15:45,420 --> 01:15:48,580
假设我们以1/60秒的速度进行模拟 

1412
01:15:48,580 --> 01:15:52,810
它将在这里进行90次迭代 从1到90 

1413
01:15:52,810 --> 01:15:56,310
计算模拟的每一步 

1414
01:15:56,310 --> 01:15:58,900
然后我在这里只渲染每5个 

1415
01:15:58,900 --> 01:16:03,180
所以如果i是mod 5s 那么我最终会得到

1416
01:16:03,180 --> 01:16:05,640
在轨迹X处绘制圆 轨迹

1417
01:16:05,640 --> 01:16:07,830
轨迹X和Y在这里 

1418
01:16:07,830 --> 01:16:10,950
平移了X 平移了Y作为起始位置 

1419
01:16:10,950 --> 01:16:15,180
然后我们将I乘以1/60秒 这将得到

1420
01:16:15,180 --> 01:16:19,860
这里是这个脉冲的标量 

1421
01:16:19,860 --> 01:16:23,600
然后在重力的作用下 我们必须做这个 我的平方加

1422
01:16:23,600 --> 01:16:31,530
I乘以y轴上重力的1/2乘以1/60的平方 

1423
01:16:31,530 --> 01:16:34,530
这篇文章更详细地介绍了它的工作原理 

1424
01:16:34,530 --> 01:16:38,910
但这就是它被转换成源代码的原因 

1425
01:16:38,910 --> 01:16:41,010
但这实际上是一种重力模拟

1426
01:16:41,010 --> 01:16:44,490
以及随时间变化的速度模拟 

1427
01:16:44,490 --> 01:16:47,670
并通过基于90次迭代来呈现它 这

1428
01:16:47,670 --> 01:16:51,210
是1.5秒 也就是1/60秒

1429
01:16:51,210 --> 01:16:54,750
我们可以准确地预测我们要去哪里 

1430
01:16:54,750 --> 01:17:00,620
然后当我们施加这个脉冲 X和Y时 球实际上会移动 

1431
01:17:00,620 --> 01:17:04,690
外星人实际上会以那个准确的轨迹朝那个方向移动 

1432
01:17:09,050 --> 01:17:12,050
这是发射标志的复杂部分 

1433
01:17:12,050 --> 01:17:16,550
另一部分是它有几个州 就像我之前说的那样 

1434
01:17:16,550 --> 01:17:20,180
因此 当我们点击时 我们没有发射 它应该进入瞄准模式 

1435
01:17:20,180 --> 01:17:25,790
所以如果我们瞄准了 我们就会设置一个旋转来--

1436
01:17:25,790 --> 01:17:31,610
实际上 轮换并不重要 因为这是在我结束之前

1437
01:17:31,610 --> 01:17:34,760
使用预测轨迹方法 

1438
01:17:34,760 --> 01:17:39,470
然而 X和Y处的移动是相关的 因为这是开始

1439
01:17:39,470 --> 01:17:41,240
你的轨迹的位置 

1440
01:17:41,240 --> 01:17:43,084
这就是你的鼠标所在的位置 

1441
01:17:43,084 --> 01:17:45,500
我们夹住它 这样它就不会超过一定的极限

1442
01:17:45,500 --> 01:17:49,730
在左边或右边 这样它就会留在方框区域内 

1443
01:17:49,730 --> 01:17:52,160
但这将是当你放开鼠标的时候 

1444
01:17:52,160 --> 01:17:55,670
将是我们孕育Box2D外星人并应用

1445
01:17:55,670 --> 01:17:59,460
相对于我们移动鼠标的位置向负方向的冲动 

1446
01:17:59,460 --> 01:18:01,820
因此 如果我们将鼠标向左向下移动 

1447
01:18:01,820 --> 01:18:05,620
它将用一种上升的冲动来否定这一点

1448
01:18:05,620 --> 01:18:08,330
向右 如果这有意义的话 

1449
01:18:08,330 --> 01:18:10,378
这就是轨迹所显示的 

1450
01:18:13,130 --> 01:18:15,560
除此之外 它还呈现了不同的东西

1451
01:18:15,560 --> 01:18:16,827
取决于是否--

1452
01:18:16,827 --> 01:18:17,660
我们现在处于什么状态 

1453
01:18:17,660 --> 01:18:20,600
因此 如果我们没有发射 它将只渲染外星人 

1454
01:18:20,600 --> 01:18:23,660
如果我们处于瞄准模式 那么它实际上应该渲染并计算

1455
01:18:23,660 --> 01:18:24,710
弹道 

1456
01:18:24,710 --> 01:18:27,080
否则 它只会渲染外星人 

1457
01:18:27,080 --> 01:18:34,130
所以一旦我们释放了鼠标 我们就释放了1并瞄准了它 

1458
01:18:34,130 --> 01:18:35,960
发射是真的 生一个外星人 

1459
01:18:35,960 --> 01:18:40,610
所以我们创造了一个新的外星人和自我世界 它是圆的 

1460
01:18:40,610 --> 01:18:43,400
我们从换X换到换Y开始 我们

1461
01:18:43,400 --> 01:18:48,720
将其线速度设置为我们之前计算的相同值 

1462
01:18:48,720 --> 01:18:51,960
所以它是基数X减去移位X乘以10 

1463
01:18:51,960 --> 01:18:53,450
所以 乘以10是一个标量 

1464
01:18:56,450 --> 01:19:03,421
然后 基数X实际上就是我们移动它的地方 

1465
01:19:03,421 --> 01:19:03,920
或者 不是 

1466
01:19:03,920 --> 01:19:07,970
基数X是它开始的地方 移位X是我们移动它的地方 

1467
01:19:07,970 --> 01:19:11,390
因此 通过从基数减去移位 

1468
01:19:11,390 --> 01:19:16,280
我们得到了我们想要影响冲动的负面方向 

1469
01:19:16,280 --> 01:19:21,560
然后在这里设置冲量 线速度 

1470
01:19:21,560 --> 01:19:26,660
然后我们也将其设置为恢复原状为0.4 

1471
01:19:26,660 --> 01:19:29,420
回想一下 恢复原状就是反弹 

1472
01:19:29,420 --> 01:19:32,450
所以我们的外星人在落地时会反弹一点 

1473
01:19:32,450 --> 01:19:37,170
然后有人知道角衰减可能是什么吗？

1474
01:19:37,170 --> 01:19:39,680
有没有人猜到？

1475
01:19:39,680 --> 01:19:45,860
角阻尼是指当它旋转时 基本上是它旋转时的摩擦力 

1476
01:19:45,860 --> 01:19:49,520
因此 当它在地面上旋转时 它不会无限滚动 

1477
01:19:49,520 --> 01:19:52,997
如果我们不设置 它只会永远地滚动 

1478
01:19:52,997 --> 01:19:54,080
这不是我们想要的 

1479
01:19:54,080 --> 01:19:56,990
我们希望它在某个时间点停止 因为一旦它停止 

1480
01:19:56,990 --> 01:20:00,170
我们知道 好了 现在我们可以让下一个外星人准备发射了 

1481
01:20:03,170 --> 01:20:05,420
这就是发射标志背后的主旨 

1482
01:20:05,420 --> 01:20:07,294
我们如何呈现轨迹 

1483
01:20:07,294 --> 01:20:10,460
对于这方面的计算 更详细地说 我将探索该URL 

1484
01:20:10,460 --> 01:20:12,740
它深入到了非常好的细节中 

1485
01:20:12,740 --> 01:20:18,156
我在这里使用它作为创建这段代码的参考 

1486
01:20:18,156 --> 01:20:20,030
但实际上 它只是在渲染

1487
01:20:20,030 --> 01:20:24,470
一堆有这个轨迹的圆 然后计算它

1488
01:20:24,470 --> 01:20:30,770
超过90个刻度 90帧迭代 

1489
01:20:30,770 --> 01:20:32,860
回到那一层 

1490
01:20:32,860 --> 01:20:37,402
对不起 关于发射标记的整体工作原理有什么问题吗？

1491
01:20:37,402 --> 01:20:38,334
观众：没有 

1492
01:20:38,334 --> 01:20:40,000
科尔顿·奥格登：酷 

1493
01:20:40,000 --> 01:20:40,500
好的 

1494
01:20:40,500 --> 01:20:44,190
所以我们有一个外星人的桌子 一个障碍物桌子 

1495
01:20:44,190 --> 01:20:47,580
地面的边缘形状 

1496
01:20:47,580 --> 01:20:50,660
然后我们只需创造一个外星人来摧毁 

1497
01:20:50,660 --> 01:20:52,140
在这里制造一些障碍 

1498
01:20:52,140 --> 01:20:56,280
在这种情况下 有两个垂直障碍物和一个水平障碍物 

1499
01:20:56,280 --> 01:20:59,580
定位成水平的在垂直的上方

1500
01:20:59,580 --> 01:21:04,730
它们是分开的 所以外星人就在它们中间 

1501
01:21:04,730 --> 01:21:08,980
然后这里的地面 我们给地面一些摩擦 0.5 

1502
01:21:08,980 --> 01:21:12,280
这很大程度上是为了建立我们的水平 

1503
01:21:12,280 --> 01:21:18,330
所以 如果我们想 在这一点之后 我们有了基础

1504
01:21:18,330 --> 01:21:24,030
必须使用公认简单的障碍才能真正产生任意级别

1505
01:21:24,030 --> 01:21:24,900
在这点上 

1506
01:21:24,900 --> 01:21:26,970
但我们可以设定--

1507
01:21:26,970 --> 01:21:30,270
因为我们在这里所做的只是简单地插入我们的外星人

1508
01:21:30,270 --> 01:21:36,030
和障碍物桌 我们可以创建几乎任何关卡 也许

1509
01:21:36,030 --> 01:21:40,710
在数据中 指定级别可能类似于表

1510
01:21:40,710 --> 01:21:44,220
然后外星人可能会成为另一张桌子 

1511
01:21:44,220 --> 01:21:53,100
然后可能只是X等于某个值 

1512
01:21:53,100 --> 01:21:55,170
然后Y等于某个值 

1513
01:21:55,170 --> 01:21:59,340
然后障碍也是一回事 

1514
01:21:59,340 --> 01:22:02,640
然后我们所要做的就是迭代这个级别的定义

1515
01:22:02,640 --> 01:22:07,440
我们只是说 这里的每一张桌子都有新的外星人 

1516
01:22:07,440 --> 01:22:09,390
然后这里的每一张桌子都有了新的障碍 

1517
01:22:09,390 --> 01:22:11,640
然后现在你的水平是由数据驱动的 

1518
01:22:11,640 --> 01:22:13,260
只需调整级别就很容易了 

1519
01:22:13,260 --> 01:22:15,134
你不需要编写代码 真的 很多 

1520
01:22:15,134 --> 01:22:16,800
你可以把它放在一个单独的文件里 

1521
01:22:16,800 --> 01:22:21,240
就像 关卡点缀Lua 然后一次只加载单独的关卡 

1522
01:22:21,240 --> 01:22:28,020
级别1等于--级别将是顶级容器 

1523
01:22:28,020 --> 01:22:33,720
然后你会得到1等于所有这些 然后是2

1524
01:22:33,720 --> 01:22:36,004
等于另一个 3等于另一个 

1525
01:22:36,004 --> 01:22:37,920
然后你就不会真的编程那么多了

1526
01:22:37,920 --> 01:22:40,170
因为你只是在数据中展示事物 

1527
01:22:40,170 --> 01:22:41,640
超级漂亮和简洁 

1528
01:22:41,640 --> 01:22:44,980
这是像Lua这样的语言的一件好事 就是你可以 

1529
01:22:44,980 --> 01:22:47,130
在JSON中的Java脚本中也是如此 

1530
01:22:47,130 --> 01:22:50,970
您可以将事物定义为数据 然后编写

1531
01:22:50,970 --> 01:22:54,630
一个脚本来遍历它并构建您实际相关的数据结构

1532
01:22:54,630 --> 01:22:55,760
这样一来 

1533
01:22:55,760 --> 01:22:57,240
在您的代码中以这种方式 

1534
01:22:57,240 --> 01:22:59,580
当你有了像我们现在这样的基础

1535
01:22:59,580 --> 01:23:02,340
在那里你可以从障碍和外星人的角度来思考 

1536
01:23:02,340 --> 01:23:04,650
您可以像这样构建关卡 

1537
01:23:04,650 --> 01:23:07,170
显然 你可以用这个做得更复杂 

1538
01:23:07,170 --> 01:23:14,280
我们所做的只是一些非常简单、几乎令人厌烦的静态障碍 

1539
01:23:14,280 --> 01:23:17,280
它们在技术意义上不是静态的 因为它们是动态对象 

1540
01:23:17,280 --> 01:23:21,520
但他们真正做的就是站在那里 然后摔倒 

1541
01:23:21,520 --> 01:23:25,890
但如果你想要滑轮系统或者

1542
01:23:25,890 --> 01:23:29,520
一种被塑造成一个巨大的头部的东西 

1543
01:23:29,520 --> 01:23:36,880
可以使用关节以这种方式创建任意复杂的对象 

1544
01:23:36,880 --> 01:23:40,050
如果你很好奇 我建议你去看看Love2D的文档

1545
01:23:40,050 --> 01:23:40,980
再多一点 

1546
01:23:40,980 --> 01:23:44,340
尤其是他们的焊接接头是你会用到的

1547
01:23:44,340 --> 01:23:47,970
把碎片组合成任意形状 

1548
01:23:47,970 --> 01:23:50,820
但你可以很容易地把这一点带到下一个层次

1549
01:23:50,820 --> 01:23:56,520
并开始在相同的层次定义中创建 任意形状 

1550
01:23:56,520 --> 01:24:01,495
把障碍物焊接在一起 

1551
01:24:01,495 --> 01:24:03,870
但我认为 这将是下一步 如果你想

1552
01:24:03,870 --> 01:24:06,990
让这一点超越一个层次 

1553
01:24:06,990 --> 01:24:12,510
我会说 想一想 我如何才能让我的游戏世界得到展示

1554
01:24:12,510 --> 01:24:14,850
以一种非常简单的数据方式？

1555
01:24:14,850 --> 01:24:17,670
因为它不仅让您更容易创建内容 

1556
01:24:17,670 --> 01:24:20,430
它允许你将负担转嫁给其他人

1557
01:24:20,430 --> 01:24:23,002
并允许您将创建关卡的任务交给

1558
01:24:23,002 --> 01:24:24,960
对程序员来说更少 对某人来说可能更多

1559
01:24:24,960 --> 01:24:28,290
他只有一个设计背景 对编写代码不是很在行 

1560
01:24:28,290 --> 01:24:31,920
并允许您创建引擎来构建基于

1561
01:24:31,920 --> 01:24:34,440
这些数据 

1562
01:24:34,440 --> 01:24:40,560
对我们是怎么安排的有什么问题吗？

1563
01:24:40,560 --> 01:24:41,877
好的 

1564
01:24:41,877 --> 01:24:43,710
所以我们有了背景 我们有了背景 

1565
01:24:43,710 --> 01:24:47,550
背景只是一个呈现静态图像的简单类

1566
01:24:47,550 --> 01:24:49,860
你可以用左或右滚动图像 

1567
01:24:49,860 --> 01:24:51,930
但我们最终并不经常使用它 

1568
01:24:51,930 --> 01:24:55,590
这与《愤怒的小鸟》相关 因为《愤怒的小鸟》里有摄像头 

1569
01:24:55,590 --> 01:25:00,540
摄像机会根据距离从左到右摇摄

1570
01:25:00,540 --> 01:25:02,790
堡垒是从你的弹弓上射出的 

1571
01:25:02,790 --> 01:25:06,660
所以如果你想要做实验的话 这就是你的想法 

1572
01:25:06,660 --> 01:25:08,160
并用一个移动的相机进行实验 

1573
01:25:08,160 --> 01:25:11,280
也许可以使用定时器点补间来补间相机

1574
01:25:11,280 --> 01:25:15,690
或者只是让它追踪外星人 如果你想要更大的世界 

1575
01:25:15,690 --> 01:25:19,320
但我们在发行版中使用它的次数并不多 

1576
01:25:19,320 --> 01:25:20,890
我们的更新功能很简单 

1577
01:25:20,890 --> 01:25:23,070
我们更新发射标志 更新世界 

1578
01:25:23,070 --> 01:25:26,280
然后我们处理所有我们标记为已销毁的身体 

1579
01:25:26,280 --> 01:25:27,680
我们已经看到了这一点 

1580
01:25:27,680 --> 01:25:29,640
我们把被销毁的身体放在一张空桌子上

1581
01:25:29,640 --> 01:25:31,740
因为我们已经全部处理过了 

1582
01:25:31,740 --> 01:25:38,504
我们实际上把障碍物从我们的水平线上移走

1583
01:25:38,504 --> 01:25:40,670
所以它们不再被渲染 我们也不再

1584
01:25:40,670 --> 01:25:44,650
试着参考那些被销毁的身体 

1585
01:25:44,650 --> 01:25:49,160
然后注意 当我们摧毁障碍物时 

1586
01:25:49,160 --> 01:25:52,050
我们在这段代码中播放音效 

1587
01:25:52,050 --> 01:25:54,650
所以我们可以只做G音 

1588
01:25:54,650 --> 01:25:57,260
我在里面放了五个木制音效 只是为了变化无常 

1589
01:25:57,260 --> 01:25:58,280
它会随机挑选一个 

1590
01:25:58,280 --> 01:26:00,650
然后用来串起数字 只需

1591
01:26:00,650 --> 01:26:03,020
在这里创造一 二 三 四 五 

1592
01:26:03,020 --> 01:26:06,420
然后停下来播放它 

1593
01:26:06,420 --> 01:26:07,197
这里也是一样 

1594
01:26:07,197 --> 01:26:09,530
我有一种声音叫当我们消灭外星人时的杀戮 

1595
01:26:09,530 --> 01:26:14,240
所以当我们将一个外星人标记为毁灭并将其从场景中移走时 

1596
01:26:14,240 --> 01:26:16,910
我们也应该称之为音效 

1597
01:26:16,910 --> 01:26:27,050
然后如果外星人停止在我们的场景中移动 玩家 

1598
01:26:27,050 --> 01:26:31,430
我们可以在这里找到它的参考 自助点发射标记点外星人 

1599
01:26:31,430 --> 01:26:33,667
而不是我们场景中的任何外星人 

1600
01:26:33,667 --> 01:26:36,125
当它停止运动时 我们就得到了它的平均速度

1601
01:26:36,125 --> 01:26:38,510
如果它低于1.5 那么就不是很完美

1602
01:26:38,510 --> 01:26:43,610
尽管如此 因为等待那么长时间是乏味的 但几乎还是如此 

1603
01:26:43,610 --> 01:26:48,950
我们摧毁外星人 然后创建一个新的发射标志 

1604
01:26:48,950 --> 01:26:52,439
我们摧毁外星人 这样世界就不会再提及它

1605
01:26:52,439 --> 01:26:54,230
然后我们只需创建一个全新的标记 

1606
01:26:54,230 --> 01:27:00,530
它的作用是在我们重新启动时在那里实例化一个新的外星人 

1607
01:27:00,530 --> 01:27:04,369
在这里 如果我们的场景中没有更多的外星人 

1608
01:27:04,369 --> 01:27:07,410
如果我们摧毁了所有的外星人 在这种情况下只有一个 

1609
01:27:07,410 --> 01:27:09,800
但是 只要多做一点工作 就可以很容易地做到 

1610
01:27:09,800 --> 01:27:13,040
在场景中再增加几个外星人 如果设置为零 

1611
01:27:13,040 --> 01:27:14,630
然后回到起点 

1612
01:27:14,630 --> 01:27:18,160
当我们最终杀死外星人时我们看到了这一点 

1613
01:27:18,160 --> 01:27:19,910
然后我们在这里所做的就是推迟

1614
01:27:19,910 --> 01:27:26,090
渲染到我们要渲染的各个对象、启动标记、

1615
01:27:26,090 --> 01:27:27,650
外星人 障碍 

1616
01:27:27,650 --> 01:27:29,420
我们绘制地砖 

1617
01:27:29,420 --> 01:27:34,070
回想一下 从我们之前的地面示例中 我们只使用了一行 

1618
01:27:34,070 --> 01:27:36,200
表示地面的边形状 

1619
01:27:36,200 --> 01:27:44,630
但如果我们看看我们的比赛 这就有点难看出了 因为我是720 

1620
01:27:44,630 --> 01:27:49,250
但实际上在底部有一块地砖 有一堆 

1621
01:27:49,250 --> 01:27:52,760
即使我们有所有的瓷砖 

1622
01:27:52,760 --> 01:27:56,090
我们所做的只是检测碰撞的边缘形状 

1623
01:27:56,090 --> 01:28:02,720
因此 我们所做的不仅仅是场景中的边缘形状 

1624
01:28:02,720 --> 01:28:09,530
我们绘制该瓷砖 它是精灵工作表中的第12帧

1625
01:28:09,530 --> 01:28:11,930
从负虚拟宽度到虚拟时间2 

1626
01:28:11,930 --> 01:28:13,850
所以总共有三个屏幕宽度 

1627
01:28:13,850 --> 01:28:16,130
然后我们只需以35像素为增量

1628
01:28:16,130 --> 01:28:17,630
因为这就是瓷砖的宽度 

1629
01:28:17,630 --> 01:28:19,856
这只会产生一堆相同的瓷砖

1630
01:28:19,856 --> 01:28:21,230
在我们屏幕的最底部 

1631
01:28:24,660 --> 01:28:28,130
所以只是一个图形化的东西 并不是真的有功能 

1632
01:28:28,130 --> 01:28:31,190
我们的场景中已经有了边缘形状 但只是为了铺设地面

1633
01:28:31,190 --> 01:28:35,540
看起来比一个像素高一点 

1634
01:28:35,540 --> 01:28:38,300
如果我们还没有发射任何东西 

1635
01:28:38,300 --> 01:28:40,610
我们应该在这里显示一些说明 

1636
01:28:40,610 --> 01:28:45,050
然后如果我们没有外星人留下 那么我们

1637
01:28:45,050 --> 01:28:47,570
应显示胜利屏幕 

1638
01:28:47,570 --> 01:28:51,650
胜利的事情只会持续一小段时间 

1639
01:28:51,650 --> 01:28:55,370
因为即使自我点状的外星人是零 这一点代码

1640
01:28:55,370 --> 01:28:59,840
直到我们移动的外星人的速度

1641
01:28:59,840 --> 01:29:01,520
减速到足够慢 

1642
01:29:01,520 --> 01:29:05,420
所以 当我们最终要停止移动时 这将会被调用 

1643
01:29:05,420 --> 01:29:09,500
然后我们检查一下 哦 好的 我们真的没有外星人了吗？

1644
01:29:09,500 --> 01:29:12,380
如果不是 那么是时候回到起点了 

1645
01:29:12,380 --> 01:29:13,475
我们已经完成了一个关卡 

1646
01:29:13,475 --> 01:29:15,350
然后很明显你会改变这一点

1647
01:29:15,350 --> 01:29:19,179
如果您最终实现了更多 则进入下一个级别

1648
01:29:19,179 --> 01:29:20,720
在你的游戏中只有一个级别 

1649
01:29:23,600 --> 01:29:27,550
除此之外 这几乎就是本例中的所有代码 

1650
01:29:27,550 --> 01:29:32,300
我想说 这是一个相当朴素的亲戚

1651
01:29:32,300 --> 01:29:33,260
之前的例子 

1652
01:29:33,260 --> 01:29:35,630
但主要的负担是学习如何使用

1653
01:29:35,630 --> 01:29:38,960
物理引擎 Box2D物理引擎 它

1654
01:29:38,960 --> 01:29:42,240
本身就是相当多的函数 

1655
01:29:42,240 --> 01:29:47,060
我认为这是Love2D维基上最长的文档 

1656
01:29:47,060 --> 01:29:50,270
但在我看来 这些原则非常简单 

1657
01:29:50,270 --> 01:29:54,905
我认为 有了很多很酷的功能 其实很容易上手 

1658
01:29:57,617 --> 01:30:00,200
我认为我们甚至没有真正涵盖其中的绝大多数 

1659
01:30:00,200 --> 01:30:03,920
至少在可以对复合对象和关节执行的操作方面

1660
01:30:03,920 --> 01:30:06,260
诸如此类的事情 真的开始

1661
01:30:06,260 --> 01:30:12,260
进入更复杂、更有趣的物理模拟世界 

1662
01:30:12,260 --> 01:30:16,130
就像我之前提到的滑轮和坦克之类的东西 

1663
01:30:16,130 --> 01:30:19,580
一些我们可以考虑潜在扩展的功能

1664
01:30:19,580 --> 01:30:21,920
如果我们想让我们的游戏更有趣 

1665
01:30:21,920 --> 01:30:24,430
是为我们的对象提供更多的形状 

1666
01:30:24,430 --> 01:30:28,280
所以 如果我们看一下这里的精灵图 我们

1667
01:30:28,280 --> 01:30:33,290
可以看到有屋顶和圆圈之类的东西 

1668
01:30:33,290 --> 01:30:36,710
所以除了正方形之外还有更多有趣的障碍

1669
01:30:36,710 --> 01:30:37,590
有形状的障碍 

1670
01:30:40,790 --> 01:30:44,540
回到--就像我之前说的 复合障碍 

1671
01:30:44,540 --> 01:30:47,240
所以一堆东西通过关节组合在一起 

1672
01:30:47,240 --> 01:30:51,210
所以滑轮 有马达 焊接接头 你可以用来--你

1673
01:30:51,210 --> 01:30:56,840
可以将屋顶固定在正方形上 然后将两块绑在一起 

1674
01:30:56,840 --> 01:30:59,330
你可以制造出任意复杂和有形状的东西

1675
01:30:59,330 --> 01:31:01,010
而且真的很有趣 

1676
01:31:01,010 --> 01:31:03,890
还有那个很大的东西 有这么多固定装置的身体 

1677
01:31:03,890 --> 01:31:09,740
会发生碰撞 就像任何其他东西一样 这要归功于Box2D 

1678
01:31:09,740 --> 01:31:13,670
正如我之前提到的 不是硬编码级别

1679
01:31:13,670 --> 01:31:19,100
到我们的Level类中 也许可以在一个名为LevelsDot Lua的Lua文件中定义它们 

1680
01:31:19,100 --> 01:31:22,070
然后让外星人成为一张桌子 障碍

1681
01:31:22,070 --> 01:31:23,870
是一张桌子 然后是其他任何东西 然而

1682
01:31:23,870 --> 01:31:25,869
你想用你的游戏变得更复杂 

1683
01:31:25,869 --> 01:31:27,260
您可以添加更多内容 

1684
01:31:27,260 --> 01:31:32,409
但只要将其表示为简单的数据结构即可 

1685
01:31:32,409 --> 01:31:34,700
所以外星人可能有不同的射击机制 

1686
01:31:34,700 --> 01:31:37,280
所以 如果你玩过《愤怒的小鸟》 你就会熟悉这样一个事实

1687
01:31:37,280 --> 01:31:40,070
一些鸟会分裂成多只鸟 

1688
01:31:40,070 --> 01:31:44,150
有些鸟会以超快的速度俯冲 冲破所有的障碍

1689
01:31:44,150 --> 01:31:45,290
挡在他们的道路上 

1690
01:31:45,290 --> 01:31:48,020
一些鸟会爆炸 然后它们的爆炸

1691
01:31:48,020 --> 01:31:50,610
影响他们周围的所有障碍物 

1692
01:31:50,610 --> 01:31:52,970
所以有很多不同的游戏机制

1693
01:31:52,970 --> 01:31:57,240
您可以使用不同类型的鸟类或外星人来实现 

1694
01:31:57,240 --> 01:32:01,670
然后 不同的障碍材料是我们可以尝试的另一个方向 

1695
01:32:01,670 --> 01:32:04,280
它开箱即用精灵薄片支撑

1696
01:32:04,280 --> 01:32:08,300
这是我提供的 因为它有金属板

1697
01:32:08,300 --> 01:32:10,080
玻璃和爆炸性材料 

1698
01:32:10,080 --> 01:32:12,080
所以有很多不同的有趣的东西

1699
01:32:12,080 --> 01:32:15,800
你只需要改变你在游戏中使用的材料就可以了 

1700
01:32:15,800 --> 01:32:19,250
显然 它们的密度不同 行为方式也不同 

1701
01:32:19,250 --> 01:32:21,450
所以作业5是一个相当简单的作业 

1702
01:32:21,450 --> 01:32:24,320
所以这就是我之前提到的 

1703
01:32:24,320 --> 01:32:27,620
这里的任务是把你的鸟分成两半

1704
01:32:27,620 --> 01:32:31,850
当它在鸟的时候按空格键拍摄--外星人 当

1705
01:32:31,850 --> 01:32:35,360
它在空中 按空格键并将其一分为三 

1706
01:32:35,360 --> 01:32:37,680
所以你已经有了一部你正在拍摄的电影 

1707
01:32:37,680 --> 01:32:39,470
所以它应该再发射两个 

1708
01:32:39,470 --> 01:32:41,600
一个角度更高 一个角度更低 

1709
01:32:41,600 --> 01:32:45,945
所有这些都应该与你的游戏世界互动 

1710
01:32:45,945 --> 01:32:46,820
真的是这样 

1711
01:32:46,820 --> 01:32:48,944
因此 如果你能做到这一点 那么它将表明你知道

1712
01:32:48,944 --> 01:32:52,580
如何影响Box2D游戏世界 

1713
01:32:52,580 --> 01:32:55,574
下一次 下一堂课 我们将讨论--

1714
01:32:55,574 --> 01:32:57,365
主题将是精灵宝可梦 但我们将

1715
01:32:57,365 --> 01:33:03,057
更广泛地说 是RPG和基于回合的游戏 

1716
01:33:03,057 --> 01:33:05,390
它可能不一定会看起来像这样漂亮 

1717
01:33:05,390 --> 01:33:08,390
但我们将为类似的世界而努力

1718
01:33:08,390 --> 01:33:11,937
我们可以四处走动 然后进行相当简单的基于回合的战斗

1719
01:33:11,937 --> 01:33:12,770
诸如此类的事情 

1720
01:33:12,770 --> 01:33:15,530
此外 我们还将讨论用户界面和其他东西

1721
01:33:15,530 --> 01:33:18,080
比如对话之类的东西 

1722
01:33:18,080 --> 01:33:20,332
但第六课《愤怒的小鸟》到此为止 

1723
01:33:20,332 --> 01:33:21,290
下次见 

1724
01:33:21,290 --> 01:33:23,140
谢谢 
