1
00:00:00,500 --> 00:00:04,374
[音乐播放]
[MUSIC PLAYING]

2
00:00:16,540 --> 00:00:19,690
科尔顿·奥格登：好的 欢迎来到GD50 第5堂课 
COLTON OGDEN: All right, welcome to GD50, Lecture 5.

3
00:00:19,690 --> 00:00:23,320
今天的主题是塞尔达的传说 正如你在屏幕上看到的那样 
Today's topic is The Legend of Zelda, as you can see on the screen there.

4
00:00:23,320 --> 00:00:25,030
一款非常标志性的游戏 
A very iconic game.

5
00:00:25,030 --> 00:00:28,660
上周 我们制作了《超级马里奥兄弟》 它可以说是最具标志性的视频游戏
Last week we did Super Mario Bros, which is arguably the most iconic video game

6
00:00:28,660 --> 00:00:29,200
史无前例的 
of all time.

7
00:00:29,200 --> 00:00:31,162
塞尔达传奇是一个势均力敌的竞争者 
Legend of Zelda is a close contender.

8
00:00:31,162 --> 00:00:34,120
即使是现在 就像马里奥一样 他们也在制作非常精彩的比赛 
Even now, just like with Mario, they're producing very wonderful games.

9
00:00:34,120 --> 00:00:39,250
我想去年《野性的呼吸》夺走了所有的 我忘了是哪一个
I think last year Breath of the Wild took all the, I forget which

10
00:00:39,250 --> 00:00:41,830
这是一场颁奖典礼 或者说颁奖典礼 
ceremony it was, or award sort of show.

11
00:00:41,830 --> 00:00:44,470
但它几乎囊括了所有可能的奖项 
But it took like every award possible.

12
00:00:44,470 --> 00:00:46,960
就在去年 最新的塞尔达 野性的呼吸 
Just last year, the latest Zelda, the Breath of the Wild.

13
00:00:46,960 --> 00:00:50,650
因此 在这样的背景下谈论塞尔达传奇感觉有点不合时宜
So it feels sort of apropos to talk about Legend of Zelda in that context

14
00:00:50,650 --> 00:00:51,724
也是 
as well.

15
00:00:51,724 --> 00:00:53,890
以下是原版《塞尔达传奇》的截图 
Here's a screenshot of the original Legend of Zelda.

16
00:00:53,890 --> 00:00:57,386
这是NES的头衔 就像超级马里奥兄弟一样--
It was an NES title, just like Super Mario Bros--

17
00:00:57,386 --> 00:00:59,260
就像它那个时代的大多数游戏一样 以瓷砖为基础 
just like most games of its time, tile based.

18
00:00:59,260 --> 00:01:04,269
你可以在某种程度上看到周围是如何一点点地分层的瓷砖 
You can sort of see how the surroundings are sort of layered tiles bit by bit.

19
00:01:04,269 --> 00:01:08,470
这个游戏的总体目标是探索这个开放的世界 这
The goal of the game overall was to sort of explore this open world, which

20
00:01:08,470 --> 00:01:11,112
这在这方面还是头一回 
is kind of a first of its kind.

21
00:01:11,112 --> 00:01:13,650
您控制了Link 如最下面所示 
You controlled Link, shown at the very bottom there.

22
00:01:13,650 --> 00:01:16,360
你有剑 你有炸弹 你有箭 
You had a sword, yo had bombs, you had arrows.

23
00:01:16,360 --> 00:01:19,030
你想去找红宝石 你得穿过地牢 
You want to go find rubies, you went through dungeons.

24
00:01:19,030 --> 00:01:22,120
你杀死了怪物和头目 然后最终的目标
You slayed monsters and bosses, and then ultimately the goal

25
00:01:22,120 --> 00:01:25,930
是为了获得左上角和右上角所示的三重力
was to obtain the Triforce which is shown at the very top left and right

26
00:01:25,930 --> 00:01:27,690
在这里的幻灯片 
of the slide here.

27
00:01:27,690 --> 00:01:30,190
这是一个截图 塞尔达传奇的另一个截图 
Here's a screenshot, another screen shot of Legend of Zelda,

28
00:01:30,190 --> 00:01:32,770
在一个真正的地牢里 你可以在最上面看到 
inside an actual dungeon where you can see at the very top,

29
00:01:32,770 --> 00:01:34,420
有一个类似于地图的布局 
there's got like a map layout.

30
00:01:34,420 --> 00:01:36,340
地图在某种程度上是在网格中排列的 
Maps are sort of arranged in a grid.

31
00:01:36,340 --> 00:01:40,960
你可以一个房间一个房间地进去 这样每个房间都是整个宽度
And you could go in a room by room, whereby each room was the entire width

32
00:01:40,960 --> 00:01:45,160
和屏幕高度 寻找 解决谜题 寻找物品 
and height of the screen, looking for, solving puzzles, looking for items,

33
00:01:45,160 --> 00:01:46,390
这类事情 
that sort of thing.

34
00:01:46,390 --> 00:01:47,890
你可以看到那里有一个怪物 
You can see there's a monster there.

35
00:01:47,890 --> 00:01:49,473
你们的心在最右上角 
You have hearts at the very top right.

36
00:01:49,473 --> 00:01:51,880
所以当你受到伤害时 心脏就会减少 
So when you take damage, hearts sort of decrement.

37
00:01:51,880 --> 00:01:55,990
会看到这两个方面 游戏的心和地牢的一面 
Will see both of these, the hearts and the dungeon aspect of the game,

38
00:01:55,990 --> 00:02:00,460
今天的讲座 以及房间的宽度和高度
today in lecture, as well as the width and height of the room

39
00:02:00,460 --> 00:02:01,630
成为一块地牢瓷砖 
being a dungeon tile.

40
00:02:01,630 --> 00:02:02,789
以及控制一个化身 
And controlling an avatar.

41
00:02:02,789 --> 00:02:05,080
但这是一个有代表性的屏幕截图 
But this is sort of a representative screenshot of what

42
00:02:05,080 --> 00:02:07,515
这场比赛看起来像是回到了过去 
the game looked like back in the day.

43
00:02:07,515 --> 00:02:09,639
今天我们要讨论的一些话题
Some topics today that we'll be discussing in order

44
00:02:09,639 --> 00:02:12,760
来实现像这样的游戏引擎的基础
to implement sort of the foundation for what a game engine like this

45
00:02:12,760 --> 00:02:15,500
可能看起来像是自上而下的透视法 
might look like are things like top down perspective.

46
00:02:15,500 --> 00:02:17,410
如你所见 在这个截图中 我们
So as you can see, in this screenshot, we're

47
00:02:17,410 --> 00:02:20,650
在鸟瞰视图中从最高处俯瞰林肯 与之相反
looking at Link from the very top in a bird's eye view, as opposed

48
00:02:20,650 --> 00:02:24,880
到我们过去看马里奥的方式 从侧面 在哪里
to how we used to look at Mario, from the side, where

49
00:02:24,880 --> 00:02:28,360
它有点像侧滚轴 
it was sort of like a side scroller.

50
00:02:28,360 --> 00:02:31,040
在这里 我们实际上是自上而下地看事情 
Here we're actually looking at things from the top down.

51
00:02:31,040 --> 00:02:36,850
所以我们以一种不同的视角来看待这个房间 
So we have a view of the room in a sort of a different perspective.

52
00:02:36,850 --> 00:02:39,155
从技术上讲 这并不是一个真正的z轴 
There's not really a z axis, technically speaking.

53
00:02:39,155 --> 00:02:40,030
但在某种程度上是有的 
But there sort of is.

54
00:02:40,030 --> 00:02:42,970
您可以在游戏引擎中实现像重力这样的东西 如下所示
You can implement things like gravity in a game engine like this

55
00:02:42,970 --> 00:02:44,992
通过跳跃洞穴之类的方式 
by jumping over holes and things like that.

56
00:02:44,992 --> 00:02:47,200
但没有像《超级马里奥》那样的重力 
But there's no gravity like there was in Super Mario,

57
00:02:47,200 --> 00:02:49,390
当你从左向右走的时候 你会跳过缝隙 
where you walk left to right, you jump over gaps,

58
00:02:49,390 --> 00:02:51,950
从这个意义上来说 这是很容易看到的 
and it's very easy to see in that sense.

59
00:02:51,950 --> 00:02:54,860
我们将谈论无限的地牢世代 
We'll be talking about infinite dungeon generation.

60
00:02:54,860 --> 00:02:57,700
因此 在今天的例子中 我们将
So in the context of today's example, we'll

61
00:02:57,700 --> 00:03:00,985
看看我们如何着手实施一个像你这样的地牢
see how we can go about implementing a dungeon that sort of you

62
00:03:00,985 --> 00:03:03,901
可以永远持续下去 以及如何对其进行建模
can go through forever and ever, and how to sort of model that

63
00:03:03,901 --> 00:03:07,150
让它看起来就像你一遍又一遍地穿过地牢 
and make it look as if you're traveling through a dungeon over and over again.

64
00:03:07,150 --> 00:03:10,400
在不同的房间里通过不同的屏幕 这些房间都是不同的 
And going through different screens in different rooms that are all different.

65
00:03:10,400 --> 00:03:13,210
但在现实中 我们会看到它实际上只是一个错觉 就像我们
But in reality, we'll see it's actually just an illusion like we've

66
00:03:13,210 --> 00:03:15,280
在以前的课程中见过 
seen before in prior lectures.

67
00:03:15,280 --> 00:03:17,470
我们来谈谈打击手和伤兵手 还有什么？
Well talk about hitboxes and hurtboxes, and what

68
00:03:17,470 --> 00:03:18,960
两者之间的区别在于 
the difference is between the two.

69
00:03:18,960 --> 00:03:22,660
希特盒是屏幕上的矩形 造成伤害
Hitboxes being rectangles on the screen that inflict damage

70
00:03:22,660 --> 00:03:25,630
在您的游戏世界中的其他实体上 以及伤害盒
upon other entities in your game world, and hurtboxes

71
00:03:25,630 --> 00:03:29,020
某种程度上是一个矩形 用来模拟你的玩家 
sort of being the rectangle that models where your player,

72
00:03:29,020 --> 00:03:33,750
或者游戏中的实体可能被其他命中框伤害的地方 
or where an entity in the game can be hurt by other hit boxes.

73
00:03:33,750 --> 00:03:34,820
好的 看看这些事件 
Well look at events.

74
00:03:34,820 --> 00:03:39,610
因此 事件是一种传播一些关键信息的方式 这些信息告诉
So events are a way of broadcasting some key message that tells

75
00:03:39,610 --> 00:03:41,650
游戏世界哦 这件事发生了 
the game world oh this thing happened.

76
00:03:41,650 --> 00:03:46,610
并让我注册一个函数 以便在处理该事件时调用 
And let me register a function to call when that event is processed.

77
00:03:46,610 --> 00:03:50,170
因此 在某些事件上 调度一个事件 然后
So on some event, dispatch an event, and then

78
00:03:50,170 --> 00:03:53,210
在该事件被监听它的任何东西接收时 
upon that event being received by whatever is listening for it,

79
00:03:53,210 --> 00:03:54,400
执行这段代码 
perform this chunk of code.

80
00:03:54,400 --> 00:03:56,740
它允许您在某种程度上分离游戏的各个方面
It allows you to sort of decouple aspects of your game

81
00:03:56,740 --> 00:03:59,710
对引擎进行了一点改进 并使代码更具可读性 
engine a little bit, and makes for a little bit more readable code.

82
00:03:59,710 --> 00:04:02,334
并允许你用成就做一些有趣的事情 
And allows you to do some interesting things with achievements,

83
00:04:02,334 --> 00:04:05,740
例如 您不一定要拉动每一帧 
for example, where you don't necessarily want to pull every single frame.

84
00:04:05,740 --> 00:04:09,250
哦 我在这个框架里做了这种武断的事情清单吗？
Oh, did I do this sort of arbitrary list of things this frame?

85
00:04:09,250 --> 00:04:12,070
相反 你可以通过一个事件来处理所有这些事情 
Rather, you can just process all of that with an event,

86
00:04:12,070 --> 00:04:16,990
有一个监听器和一个功能 每次你播放捡硬币的时候 
and have a listener and a function that every time you broadcast pick up coin,

87
00:04:16,990 --> 00:04:19,839
也许我的成就就像是 
maybe I have an achievement that's like oh,

88
00:04:19,839 --> 00:04:23,170
我是如何在这个关卡里捡到50枚硬币的 
how I picked up 50 coins in this level.

89
00:04:23,170 --> 00:04:28,440
然后 您的事件中的成就回调函数可以查找它 
Your achievement callback function in your event can then look for that,

90
00:04:28,440 --> 00:04:31,130
在你的游戏循环中 你不必说每一帧 
and in your game loop, you don't have to say every frame,

91
00:04:31,130 --> 00:04:34,690
如果一名玩家有850枚硬币 你可以说
if a player has 850 coins, and you sort of

92
00:04:34,690 --> 00:04:39,010
通过这种方式去掉你整个游戏循环中可能存在的臃肿 
take out bloat that would exist in your sort of overall game loop that way.

93
00:04:39,010 --> 00:04:41,979
在今天的课程中 我们将看到一个如何使用它的例子 
And we'll see an example of how we use that in today's lecture.

94
00:04:41,979 --> 00:04:43,270
我们将查看屏幕滚动 
We'll look at screen scrolling.

95
00:04:43,270 --> 00:04:47,230
所以《塞尔达传奇》的一个非常标志性的方面
So a very iconic aspect of Legend of Zelda

96
00:04:47,230 --> 00:04:49,720
就是当你从一个屏幕转到另一个屏幕时 
is when you're going from one screen to another,

97
00:04:49,720 --> 00:04:53,500
当一个屏幕加载而另一个屏幕加载时 会有一种过渡期
there is a sort of transition period as one screen loads and the other screen

98
00:04:53,500 --> 00:04:54,730
就会消失 
goes away.

99
00:04:54,730 --> 00:04:59,620
在硬件上 在NES中 这是唯一的方法
In hardware, in the NES, this was sort of the only way

100
00:04:59,620 --> 00:05:04,840
您实际上可以渲染超过一个屏幕宽度的瓷砖 
you could actually render more than a screen width of tiles.

101
00:05:04,840 --> 00:05:07,180
实际上 您必须动态加载切片并进行排序
You actually had to dynamically load in tiles and sort

102
00:05:07,180 --> 00:05:09,790
覆盖在此之前存在于内存中的磁贴 
of overwrite tiles that existed before that in memory.

103
00:05:09,790 --> 00:05:12,220
但今天 我们将看看如何创造出
But today, we'll see how we can sort of create

104
00:05:12,220 --> 00:05:15,340
只要画一间房间就能做到这一点的错觉
the illusion of doing that by just drawing a room

105
00:05:15,340 --> 00:05:18,240
然后有了我们的主房间 然后就像是补丁一样 
and then having our main room, and then just sort of tweening over,

106
00:05:18,240 --> 00:05:21,360
然后将所有内容设置回原点为0.0 
and then setting everything back to the origin at 0.0.

107
00:05:21,360 --> 00:05:24,120
这让我们看起来就像是在
And it makes it look as if we're moving back and forth between all

108
00:05:24,120 --> 00:05:26,911
这些房间 而实际上我们所做的只是换班 
these rooms, when in reality all we're doing is just doing a shift,

109
00:05:26,911 --> 00:05:28,680
然后把一切都恢复到0.0 
and then putting everything back to 0.0.

110
00:05:28,680 --> 00:05:32,655
所以 如果可以的话 我会在屏幕上说明这一点 
So I'll illustrate that on the screen, if I can.

111
00:05:32,655 --> 00:05:35,280
我们最后要讨论的一件事是数据驱动设计 
And one of the last things we'll look at is data driven design.

112
00:05:35,280 --> 00:05:39,240
在许多类型的游戏的背景下 特别是RPG和动作
In the context of a lot of types of games, particularly RPGs and action

113
00:05:39,240 --> 00:05:44,010
在游戏中 能够为你所有的物品建模通常是非常有价值的 
games, it's often very valuable to be able to model all of your items,

114
00:05:44,010 --> 00:05:46,440
实体 某种能力 任何你真正想要的东西
entities, sort of abilities, anything you really

115
00:05:46,440 --> 00:05:51,780
可以 作为数据而不是逻辑 为了让你更容易写一个 
can, as data rather than logic, in order to make it easier for you to write one.

116
00:05:51,780 --> 00:05:55,530
第二 你可以分配你游戏的设计方面
And two, for you to sort of allocate the design aspect of your game

117
00:05:55,530 --> 00:05:57,630
给其他人 而不仅仅是程序员 
to other people, not just programmers.

118
00:05:57,630 --> 00:05:59,670
并有一个非常通用的发动机 
And have an engine that's very versatile.

119
00:05:59,670 --> 00:06:02,370
和模型 我们将看看我们是如何实现
And model and we'll take a look at how we implement

120
00:06:02,370 --> 00:06:05,410
这在某种程度上为以后的研究奠定了基础 
sort of a foundation for that later on.

121
00:06:05,410 --> 00:06:09,540
但首先 我想为今天的课程演示一个演示 
But first I'd like to illustrate a demo for today's lecture,

122
00:06:09,540 --> 00:06:11,982
这是塞尔达传奇的一种实现 
a sort of implementation of Legend of Zelda.

123
00:06:11,982 --> 00:06:14,940
今天有没有人愿意来演示一下这个
Is there anybody that would like to come up and sort of demo this today

124
00:06:14,940 --> 00:06:15,480
在课堂上？
in class?

125
00:06:19,232 --> 00:06:21,580
太棒了 
Awesome.

126
00:06:21,580 --> 00:06:24,460
非常感谢 
Thank you so much.

127
00:06:24,460 --> 00:06:29,274
所以 只要你准备好了 就继续按那里的Return键 
So whenever you're ready, go ahead and press the Return key there.

128
00:06:29,274 --> 00:06:30,770
[音乐播放]
[MUSIC PLAYING]

129
00:06:30,770 --> 00:06:34,560
所以我们在屏幕上看到 50岁的传奇 这是我们的塞尔达传奇
And so we see on the screen, Legend of 50, which is our Legend of Zelda

130
00:06:34,560 --> 00:06:35,370
你敲竹杠 
you rip off.

131
00:06:35,370 --> 00:06:36,720
因此 您按Enter键 
So you press Enter.

132
00:06:36,720 --> 00:06:39,000
你进入 这就是游戏的发挥状态 
You go into, this is the play state of the game.

133
00:06:39,000 --> 00:06:40,880
所以你控制了一个化身 
So you control an avatar.

134
00:06:40,880 --> 00:06:42,040
你可以四处走走 
You can walk around.

135
00:06:42,040 --> 00:06:44,520
他可以与开关互动 就像我们在这里看到的那样 
He can interact with switches, as we saw here.

136
00:06:44,520 --> 00:06:47,240
当他按下开关时 门就会打开 
When he presses a switch, the doors open.

137
00:06:47,240 --> 00:06:51,000
一旦门打开了 你就可以走进去了
And once the doors are open, you can walk through them

138
00:06:51,000 --> 00:06:54,720
而且 正如我之前提到的 它将屏幕转换为
and it does, as I alluded to before, it transitions the screen, one

139
00:06:54,720 --> 00:06:59,320
整个屏幕的高度或宽度取决于向上和向下的方向 
entire screen height or width, depending on the direction, up above and below.

140
00:06:59,320 --> 00:07:02,790
我们现在看到 我们按空格键实际上是在挥舞我们的剑 
We see here now where we're pressing spacebar to actually swing our sword.

141
00:07:02,790 --> 00:07:05,830
它正在摧毁游戏空间中的实体 
It's destroying the entities in the game space.

142
00:07:05,830 --> 00:07:10,170
所以当你按下碰撞的空格键时会触发Hitbox
So there's a hitbox triggering when you press the space bar that collides

143
00:07:10,170 --> 00:07:11,940
与游戏世界中的其他实体 
with other entities in the game world.

144
00:07:11,940 --> 00:07:15,720
如果希特箱击中了他们的伤害箱 那么他们就会被标记为死亡 
If that hitbox hits their hurtbox, then they are flagged as dead,

145
00:07:15,720 --> 00:07:17,890
他们从游戏世界中消失了 
and they disappear from the game world.

146
00:07:17,890 --> 00:07:19,510
所以这就是无止境的 
And so this goes on ad infinitum.

147
00:07:19,510 --> 00:07:20,760
这只是一个无尽的地牢 
It's just an infinite dungeon.

148
00:07:20,760 --> 00:07:24,600
这样他就可以进入我们想要的楼层之间 
So he can go in-between as many floors as we want to.

149
00:07:24,600 --> 00:07:27,667
我们所做的就是每次我们穿过一扇门 生出一个新房间 
All we're doing is every time we go through a doorway, spawn a new room,

150
00:07:27,667 --> 00:07:30,500
删除旧的 然后继续下去 永远 
delete the old one, and just keep going forever, and ever, and ever.

151
00:07:30,500 --> 00:07:33,333
在像塞尔达传奇这样的游戏中 它通常不会像这样工作 
In a game like Legend of Zelda, it typically doesn't work like this.

152
00:07:33,333 --> 00:07:38,220
有固定数量的房间 它们都以一种2D阵列的形式存在 
There is a hard set number of rooms, and they all exist in sort of a 2D array.

153
00:07:38,220 --> 00:07:40,590
当你产生你的地牢时 你可以说
And when you generate your dungeon, you sort of

154
00:07:40,590 --> 00:07:43,460
必须考虑到我把钥匙放在哪里之类的事情 
have to take into consideration things like where do I put the keys?

155
00:07:43,460 --> 00:07:44,460
我该把老板放在哪里？
Where do I put the boss?

156
00:07:44,460 --> 00:07:45,590
我该把宝藏放在哪里？
Where do I put treasure?

157
00:07:45,590 --> 00:07:46,381
这类事情 
That sort of thing.

158
00:07:46,381 --> 00:07:51,000
我们不会太深入地讨论如何实现像这样的复杂算法 
We won't get too in-depth as to how we can implement a complex algorithm like.

159
00:07:51,000 --> 00:07:54,120
但我们会稍微谈一谈 也许会谈到一些想法
But we'll touch on it a little bit, and talk about maybe some ideas

160
00:07:54,120 --> 00:07:55,230
这是我们拥有的 
that we have.

161
00:07:55,230 --> 00:07:58,150
最后 如果我们只是--如果我们想演示--
And then lastly, if we just-- if we want to demo--

162
00:07:58,150 --> 00:08:00,540
如果我们能看到左上角 我们的心就在那里 
if we can see the top left, we have hearts there,

163
00:08:00,540 --> 00:08:02,580
这是塞尔达的标志性作品 
which is iconic sort of Zelda.

164
00:08:02,580 --> 00:08:05,810
当我们确实受到敌人的伤害时 注意到我们会有一点闪烁 
When we do take damage from an enemy, notice that we flicker a little bit.

165
00:08:05,810 --> 00:08:07,800
所以有一些渲染行为被触发 
So there's some rendering behavior triggering,

166
00:08:07,800 --> 00:08:09,759
当我们受到伤害时 我们就变得无懈可击 
and we become invulnerable when we take damage.

167
00:08:09,759 --> 00:08:11,883
最后 当我们终于接受最后一击的时候 
And then lastly, when we finally take the last hit,

168
00:08:11,883 --> 00:08:14,190
我们在屏幕上看到一个小游戏 使用的是塞尔达字体 
we get a little game over screen, using the Zelda font.

169
00:08:14,190 --> 00:08:15,320
简而言之 这就是游戏 
And that's the game in a nutshell.

170
00:08:15,320 --> 00:08:16,780
我们按Enter键并循环返回 
We press Enter and loop back.

171
00:08:16,780 --> 00:08:19,364
总体来说很简单 但有很多片段
So pretty simple altogether, but there's a lot of pieces

172
00:08:19,364 --> 00:08:21,030
在这里 我们从来没有真正看到过 
here that we haven't really seen before.

173
00:08:21,030 --> 00:08:24,910
因此 非常感谢你们前来演示这款游戏 
So thank you very much for coming up to demo the game.

174
00:08:24,910 --> 00:08:25,410
好的 
All right.

175
00:08:25,410 --> 00:08:31,320
这就是《50岁的传奇》、《塞尔达传奇》的演示 
So that was a demo of Legend of 50, Legend of Zelda.

176
00:08:31,320 --> 00:08:33,419
它有很多塞尔达拥有的东西 
It has a lot of the pieces that Zelda has.

177
00:08:33,419 --> 00:08:35,220
当然 它还没有完全充实起来 
It's not as fully fleshed out, of course,

178
00:08:35,220 --> 00:08:38,368
作为像塞尔达这样的完整游戏 这将是一个巨大的游戏 
as a full game like Zelda, which would be monstrously large.

179
00:08:38,368 --> 00:08:40,409
我们还需要考虑很多因素 
And there's a lot of things we need to factor in.

180
00:08:40,409 --> 00:08:42,210
但基础就在那里 
But the foundation is there.

181
00:08:42,210 --> 00:08:46,290
我们有地牢的基础 我们可以在上面建造一个真正的发电机 
We have the dungeon foundation upon which we can build an actual generator,

182
00:08:46,290 --> 00:08:47,370
如果我们想的话 
if we wanted to.

183
00:08:47,370 --> 00:08:48,240
我们有实体 
We have entities.

184
00:08:48,240 --> 00:08:49,140
我们有命中率高的 
We have hit boxes.

185
00:08:49,140 --> 00:08:51,970
我们可以很容易地建模 因为我们在游戏中有开关 
We could easily model, because we have switches in the game,

186
00:08:51,970 --> 00:08:53,995
我们可以对宝物箱这样的东西进行建模
we could model things like treasure chests that

187
00:08:53,995 --> 00:08:57,120
打开有不同的状态 就像开关有不同的状态一样 
open that have different states, just like the switch had different states.

188
00:08:57,120 --> 00:09:00,690
并让我们游戏空间中的不同对象与其他对象互动 
And have different objects in our game space interact with other objects.

189
00:09:00,690 --> 00:09:04,270
我们在这里有很多东西 今天我们将讨论所有的东西 
We have a lot here, and we'll talk about all of it today.

190
00:09:04,270 --> 00:09:07,440
这里有几个截图 只是为了展示我们刚刚看到的东西 
So here's a few screenshots just to show what we just looked at.

191
00:09:07,440 --> 00:09:10,170
我们的目标主要是第二个截图 
Our goal mainly is the second screen shot,

192
00:09:10,170 --> 00:09:12,690
在右上角 这是播放状态 它具有
on the top right, which is the play state, which has

193
00:09:12,690 --> 00:09:14,560
我们刚刚看到的所有小碎片 
all of the little pieces we just saw.

194
00:09:14,560 --> 00:09:17,429
但为了把这一切联系起来 我们这里确实有一个开始状态 
But just to tie it all together, we do have a start state here,

195
00:09:17,429 --> 00:09:19,470
以及一场与国家相关的博弈
and a Game Over state which is relevant in regard

196
00:09:19,470 --> 00:09:22,390
传到左上角的心脏 
to the hearts on the top left.

197
00:09:22,390 --> 00:09:27,300
所以我要谈的第一件事是 我们把发动机组装好了
So the first thing that I'll talk about as we sort of get the engine built up

198
00:09:27,300 --> 00:09:30,970
是 我们要把我们的资产投入到游戏中去吗？
is, where do we go for getting our assets into the game?

199
00:09:30,970 --> 00:09:33,960
就像之前的课程一样 在今天之前 
And just like in prior lectures, prior to today,

200
00:09:33,960 --> 00:09:36,210
我们只有一个精灵床单 就像我们对马里奥所做的那样 
we just have a sprite sheet, like we did with Mario,

201
00:09:36,210 --> 00:09:40,560
其中所有内容都以相当均匀的瓷砖分段顺序进行布局 
where everything is laid out in a fairly even sequence of tile segments.

202
00:09:40,560 --> 00:09:43,710
在本例中 线段为16x16像素 
In this case, the segments are 16 by 16 pixels.

203
00:09:43,710 --> 00:09:48,270
在这里 我叠加了一个网格 只是为了显示图片确实是完美的16
Here, I've overlaid a grid just to show that the picture is indeed perfectly 16

204
00:09:48,270 --> 00:09:48,930
到16岁 
by 16.

205
00:09:48,930 --> 00:09:51,790
这是你应该考虑的事情 
And this is something that you should take into consideration.

206
00:09:51,790 --> 00:09:54,439
当你构建你的游戏资产时 你会有意识地这样做 
And consciously do when you're building your game assets.

207
00:09:54,439 --> 00:09:56,230
让它很容易被切成小块 
Make it easy to chop up into little pieces,

208
00:09:56,230 --> 00:10:01,800
这样你就可以通过一些四边形的表格来索引这个精灵了 
so you can then index into this sprite via some table of quads.

209
00:10:01,800 --> 00:10:04,260
然后为任何对象分配ID 
And then assign an ID to whatever object,

210
00:10:04,260 --> 00:10:07,410
或要渲染到屏幕上的平铺 
or tile you want to render to the screen.

211
00:10:07,410 --> 00:10:11,130
所以我们看到 如果你看这里 像门这样的东西 
And so we see if you look here, things like the doors,

212
00:10:11,130 --> 00:10:14,640
它们并不是由一块瓷砖完美地塑造出来的 
they're not perfectly modeled by one tile.

213
00:10:14,640 --> 00:10:18,270
所以当你有大于16乘以16的东西时 
And so when you do have things that are larger than 16 by 16,

214
00:10:18,270 --> 00:10:23,820
这并不像拥有具有该帧ID实体或对象那样简单 
it's not quite as easy as oh have an entity or an object with this frame ID,

215
00:10:23,820 --> 00:10:25,110
并将其绘制到屏幕上 
and draw it to the screen.

216
00:10:25,110 --> 00:10:27,776
您实际上需要稍微复杂一点的呈现逻辑 
You actually need to a little bit more complicated render logic.

217
00:10:27,776 --> 00:10:30,150
所以随便说说 如果我想画一扇门 
So just offhand, if I wanted to draw a door,

218
00:10:30,150 --> 00:10:32,780
有没有人对我如何建模有什么建议？
does anybody have any suggestions as to how I would model that?

219
00:10:32,780 --> 00:10:33,988
或者把它画到屏幕上？
And or draw it to the screen?

220
00:10:39,310 --> 00:10:49,870
因此 如果我们的门不是16x16像素的瓷砖 
So if we have a door that's not perfectly a 16 x 16 pixel tile,

221
00:10:49,870 --> 00:10:54,540
现在 我们需要做的就是存储所有四个
offhand, what we need to do is just basically store all four

222
00:10:54,540 --> 00:10:57,810
在这种情况下 这些瓷砖 或至少跟踪有多少瓷砖
of those tiles in this case, or at least keep track of however many tiles

223
00:10:57,810 --> 00:11:01,260
你的目标是 
your object is.

224
00:11:01,260 --> 00:11:03,290
然后只需根据一些偏移量绘制它们 
And then just draw them based on some offset.

225
00:11:03,290 --> 00:11:06,940
具有表示该对象左上角的XY 
Have an xy that represents the top left of that object.

226
00:11:06,940 --> 00:11:09,870
把它放在正确的位置 而不是只画一个瓷砖 
Place it in the right position, and instead of drawing just one tile,

227
00:11:09,870 --> 00:11:11,430
我们画了四块瓷砖 
we draw four tiles.

228
00:11:11,430 --> 00:11:15,831
然后 不是只有一个16乘16瓦的碰撞凸起 
And then instead of having just one collision boss that's 16 by 16 tiles,

229
00:11:15,831 --> 00:11:17,080
你可以做几件事 
you can do a couple of things.

230
00:11:17,080 --> 00:11:20,340
您可以检查所有四个瓷砖上的碰撞 
You can either check collision on all four of these tiles,

231
00:11:20,340 --> 00:11:24,180
或者至少是所有的两块门砖 或者是你自己定制的打印件
or at least all two of these door tiles, or model your own custom hit

232
00:11:24,180 --> 00:11:28,230
然后 可能代表门口的对象可以控制的框 
box that then maybe that object that represents a doorway has control of.

233
00:11:28,230 --> 00:11:31,860
所以你可以说门口撞到了玩家 然后门口
So you can say doorway collides player, and then the doorway

234
00:11:31,860 --> 00:11:37,890
它的高度和宽度是多少像素 它在这里是宽是高 
has a height and width of however many pixels it is wide by tall here.

235
00:11:37,890 --> 00:11:39,030
只有门的这一部分 
Just this door part.

236
00:11:39,030 --> 00:11:44,310
然后 您可以在不只有一块瓷砖的基础上构建
And then, you are able to then build upon not just having one tile that

237
00:11:44,310 --> 00:11:46,710
在您的游戏空间中为对象或实体建模 
models an object or entity in your game space,

238
00:11:46,710 --> 00:11:48,700
但现在你有了更多的艺术灵活性 
but now you have more artistic flexibility.

239
00:11:48,700 --> 00:11:52,710
你可以做一些事情 比如有超过一个像素宽的门口 
You can do things like have doorways that are more than one pixel wide.

240
00:11:52,710 --> 00:11:55,699
因此 游戏世界变得更有说服力了 
And sort of have a more convincing gameworld as a result of that.

241
00:11:55,699 --> 00:11:57,990
你会在RPG这样的游戏中看到很多类似的东西
You'll see a lot of things like that in games like RPGs

242
00:11:57,990 --> 00:12:02,880
在那里 你有满座的房子 显然不仅仅是一块瓷砖 
where you have full houses that are obviously not just one tile.

243
00:12:02,880 --> 00:12:06,360
如果你愿意 你可以用一块瓷砖来建模 
You can model things as one tile if you want to,

244
00:12:06,360 --> 00:12:10,540
但从艺术的角度 从游戏引擎的角度来看 
but from an artistic perspective, and from just a game engine perspective,

245
00:12:10,540 --> 00:12:13,020
它以编程方式更容易一些
it's a little bit easier to programmatically

246
00:12:13,020 --> 00:12:18,190
能够将你所有的资产切成瓷砖 然后这样画出来 
be able to cut up all your assets into tiles and draw them as such.

247
00:12:18,190 --> 00:12:22,500
所以能够在单人精灵的基础上
So being able to build upon just the single sprite

248
00:12:22,500 --> 00:12:24,930
并且能够用多个精灵来表示
and be able to do multiple sprites represent

249
00:12:24,930 --> 00:12:30,480
物体是房屋、大树等事物的关键 
an object is the key to things like houses, things like big trees,

250
00:12:30,480 --> 00:12:34,710
比我们在这里看到的单一瓷砖更复杂的东西 
things that are just more complicated than single tiles as we see here.

251
00:12:34,710 --> 00:12:39,160
正如你所看到的 角色的精灵工作表有点复杂 
The character sprite sheet is, as you can see, a little bit more complicated.

252
00:12:39,160 --> 00:12:42,000
这是一个带有填充的精灵工作表的示例 
So this is an example of a sprite sheet that has padding.

253
00:12:42,000 --> 00:12:45,630
有时你会得到没有被整齐分割的精灵床单
Sometimes you will get sprite sheets that aren't neatly divided

254
00:12:45,630 --> 00:12:46,657
分成偶数段 
into even segments.

255
00:12:46,657 --> 00:12:47,490
这是有充分理由的 
And for good reason.

256
00:12:47,490 --> 00:12:50,850
因为有时候你的瓷砖不是很完美
Because sometimes you have tiles that are not perfectly

257
00:12:50,850 --> 00:12:53,850
游戏引擎的瓷砖的宽度和高度 
the width and height of whatever your game engine's tiles are.

258
00:12:53,850 --> 00:12:57,692
在这种情况下 播放器实际上是20像素高 16像素宽 
In this case, the player is actually 20 pixels tall, and 16 pixels wide.

259
00:12:57,692 --> 00:13:00,150
最重要的是 他有不同的动画画面 
And on top of that, he's got different frames of animation.

260
00:13:00,150 --> 00:13:03,330
我们可以在左下角看到 他有一个挥剑的动画 
We can see here at the bottom left, he's got a sword swinging animation.

261
00:13:03,330 --> 00:13:06,930
挥剑动画实际上存储在32×32像素的帧中 
The sword swing animation is actually stored in a 32 by 32 pixel frame,

262
00:13:06,930 --> 00:13:10,590
因为有时取决于他看的角度 
because sometimes depending on which angle he's looking at,

263
00:13:10,590 --> 00:13:12,820
他的精灵可以变大一点 也可以变小一点 
his sprite can get a little larger or smaller.

264
00:13:12,820 --> 00:13:16,350
所以当你有一个带衬垫的精灵 什么是一种
So when you have a sprite with padding, what's sort of a way

265
00:13:16,350 --> 00:13:19,740
我们可以可靠地把这个画到屏幕上吗？
that we can draw this to the screen reliably?

266
00:13:19,740 --> 00:13:22,170
我们该如何考虑这一点呢？
How do we take this into consideration?

267
00:13:22,170 --> 00:13:24,360
我们将如何呈现带有填充的屏幕精灵？
How would we render a screen sprite with padding?

268
00:13:28,150 --> 00:13:32,560
所以让我们假设这个精灵 我们的角色挥舞着一把剑 是在32
So let's say this sprite here, our character swinging a sword, is in a 32

269
00:13:32,560 --> 00:13:34,670
乘以32像素框 
by 32 pixel box.

270
00:13:34,670 --> 00:13:35,200
对吗？
Right?

271
00:13:35,200 --> 00:13:37,810
在这附近的这个盒子 这个空白空间 
This sort of box around here, this white space.

272
00:13:37,810 --> 00:13:40,810
但他仍然可能只有16个像素宽乘20个像素高 
But he's only still maybe 16 pixels wide by 20 pixels tall.

273
00:13:40,810 --> 00:13:43,994
或者 也许他在某种程度上与此类似 
Or maybe he is some amount similar to that.

274
00:13:43,994 --> 00:13:46,910
为了把他吸引到屏幕上 你可以在代码中看到 
In order to draw him to the screen, which you can look at in the code,

275
00:13:46,910 --> 00:13:50,170
我们真正需要做的就是为那个精灵分配一个偏移量 
all we really need to do is assign that sprite an offset.

276
00:13:50,170 --> 00:13:52,315
只要说 好的 这个精灵的偏移量x和偏移量
Just say, OK, this sprite's offset x and offset

277
00:13:52,315 --> 00:13:57,670
Y是一些值 基本上可以让我们绘制精灵
y are some value that basically lets us draw the sprite

278
00:13:57,670 --> 00:14:00,940
为负的x和负的y值 
to a negative x and a negative y value.

279
00:14:00,940 --> 00:14:03,910
这将使精灵向上移动 使其完美地对齐
And that'll shift the sprite up, such that it aligns perfectly

280
00:14:03,910 --> 00:14:05,650
无论他的XY在哪里 
with wherever his xy are.

281
00:14:05,650 --> 00:14:09,490
您可以查看代码以了解它到底是如何工作的 
And you can take a look at the code to see exactly how that works.

282
00:14:09,490 --> 00:14:13,079
最后 我们游戏世界的实际实体是不同的生物 
Lastly the actual entities for our game world are different creatures.

283
00:14:13,079 --> 00:14:16,120
这是一张精灵图--这是一张更理想的精灵图
And this is a sprite sheet-- this is a more ideal sprite where everything

284
00:14:16,120 --> 00:14:18,792
是16x16像素宽和高 
is 16 by 16 pixels wide and tall.

285
00:14:18,792 --> 00:14:21,250
我们在这里真正做的就是分好精灵床单
And all we really did here was just divide the sprite sheet

286
00:14:21,250 --> 00:14:26,470
使用常规实用函数生成16个16的四边形 
using the regular utility function generate quads by 16 16.

287
00:14:26,470 --> 00:14:30,640
我们不必担心所有东西都有不同的宽度和高度 
We don't have to worry about separate widths and heights for everything,

288
00:14:30,640 --> 00:14:34,570
正因为如此 我们才能非常简单地制作动画 
and we can create animations very simply because of this.

289
00:14:34,570 --> 00:14:38,260
顺便说一句 当我在解析时 我喜欢做的事情
As a side note, something that I like to do, when I'm parsing

290
00:14:38,260 --> 00:14:42,870
或者当我拼接一张有很多单独框架的精灵纸时 
or when I'm piecing apart a sprite sheet that's got a lot of individual frames,

291
00:14:42,870 --> 00:14:45,130
尤其是在我创作动画的时候 或者我只是
particularly if I'm creating animations, or I just

292
00:14:45,130 --> 00:14:49,120
需要知道对于一个瓷砖 一个特定的瓷砖要画到屏幕上 
need to know for a tile, a particular tile to draw to the screen.

293
00:14:49,120 --> 00:14:52,311
手动查看每一块瓷砖是一种痛苦 
It's kind of a pain to manually look through each and every tile, one

294
00:14:52,311 --> 00:14:52,810
差一分 
by one.

295
00:14:52,810 --> 00:14:54,580
然后说好的 这是一个 但是好的 
And say OK, this is one but OK.

296
00:14:54,580 --> 00:14:57,040
但如果我想找出粘液是哪一种 
But if I want to find out which one the slime is,

297
00:14:57,040 --> 00:14:59,630
我数了一下 好的 这个有多少像素宽？
I got a count, OK how many pixels wide does this?

298
00:14:59,630 --> 00:15:02,330
好的 然后是4乘以12 
OK, and then it's times 4, it's 12.

299
00:15:02,330 --> 00:15:07,030
然后它在第五排 所以12乘以4加1会得到 好的 
And then it's on the fifth row, so 12 times 4 plus 1 will give me, OK.

300
00:15:07,030 --> 00:15:09,520
所以它的指数是49 
So it's at index 49.

301
00:15:09,520 --> 00:15:12,940
所以我花了相当多的时间
So I've spent a non-trivial amount of time sort of hand

302
00:15:12,940 --> 00:15:14,920
计算所有这些都做了什么 
calculating what all these do.

303
00:15:14,920 --> 00:15:18,820
我编写了一个简单的Python脚本 它只会遍历一个文件 
I wrote a simple Python script that will just go over a file,

304
00:15:18,820 --> 00:15:23,290
只需在每个单独的四元组中添加一个数字 
and just add a digit to each individual quad,

305
00:15:23,290 --> 00:15:26,650
让你一目了然地看到每个精灵是什么 
to just show you at a glance what each sprite is.

306
00:15:26,650 --> 00:15:30,460
这包括发行版 所以你可以看到它是什么样子的 
And this is including the distro, so you can see what it looks like.

307
00:15:30,460 --> 00:15:31,660
节省了很多时间 
Saves a lot of time.

308
00:15:31,660 --> 00:15:34,840
我建议尝试一下 当你在处理资产的时候
And I recommend trying, when you're sort of working with assets

309
00:15:34,840 --> 00:15:37,484
你发现自己在做一件需要很长时间的事情 
and you find yourself doing something that takes a long time,

310
00:15:37,484 --> 00:15:39,400
这可能有点繁琐和机械
and it's sort of tedious and mechanical, maybe

311
00:15:39,400 --> 00:15:41,691
试着找到一种自动化的方法 或者至少
try to find a way to sort of automate that, or at least

312
00:15:41,691 --> 00:15:43,420
让事情变得更容易一目了然 
make it easier to do things at a glance.

313
00:15:43,420 --> 00:15:47,187
在这种情况下 只需简单地施加一个数字网格就可以解决这个问题 
In this case, just simply imposing a numerical grid solves that problem.

314
00:15:47,187 --> 00:15:49,270
我不需要花很多时间
I don't have to spend a significant amount of time

315
00:15:49,270 --> 00:15:52,930
找出幽灵面向左侧的动画的哪一帧 
figuring out which frames of animation the ghost facing left is.

316
00:15:52,930 --> 00:15:58,120
我立刻就知道它是67、68和69 这让我可以把事情搞砸
I know instantly it's 67, 68 and 69, and allows me to just crank things

317
00:15:58,120 --> 00:16:00,350
升得快得多 
up that much faster.

318
00:16:00,350 --> 00:16:04,870
所以我们首先要看的是一种自上而下的视角 
So the first thing we'll take a look at is sort of top down perspective.

319
00:16:04,870 --> 00:16:07,840
我们之前主要讨论过这个问题 早些时候 
And we mostly talked about this before, earlier.

320
00:16:07,840 --> 00:16:12,500
但它实际上只是一张我们以前见过的瓷砖地图 
But all it really is is a tile map, which we've seen before.

321
00:16:12,500 --> 00:16:16,120
唯一的不同是 现在不是从侧面看事情 
The only difference is now, instead of looking at things from the side,

322
00:16:16,120 --> 00:16:18,290
我们只是从上面看事情 
we're just looking at things from up above.

323
00:16:18,290 --> 00:16:21,880
那么最明显的考虑可能是什么呢？
So what's probably the most obvious consideration

324
00:16:21,880 --> 00:16:27,460
在设计自上而下的透视图而不是侧边滚动时
when designing a top down perspective versus a sort of side scrolling

325
00:16:27,460 --> 00:16:29,860
观点是什么？
point of view?

326
00:16:29,860 --> 00:16:32,620
特别关注瓷砖是如何绘制的？
Looking at particularly at how the tiles are drawn?

327
00:16:32,620 --> 00:16:33,696
最突出的是什么？
What stands out?

328
00:16:37,030 --> 00:16:39,250
所以对我来说最突出的是我们
So the thing that stands out to me is that we

329
00:16:39,250 --> 00:16:42,790
这里的墙壁上有影子之类的东西 
have things like shadows on walls here.

330
00:16:42,790 --> 00:16:46,960
我们也有角落 和所有的东西
We have also corners, and things altogether

331
00:16:46,960 --> 00:16:51,220
是倾斜的 以至于它们几乎像是稍微旋转了一下 就好像它们
are skewed such that they are almost like rotated slightly as if they're

332
00:16:51,220 --> 00:16:56,890
模拟相对于相机从上方朝上的旋转角度 
simulating an angle of rotation relative to the camera facing from up above.

333
00:16:56,890 --> 00:16:58,970
例如 你可以在播放器上看到这一点 
You can see this on the player, for example.

334
00:16:58,970 --> 00:17:01,960
看起来你是在上下打量他 
It looks like you're looking at him from backwards and up.

335
00:17:01,960 --> 00:17:07,150
当你以这种方式为你的资产建模时 它更有说服力 
When you're modeling your assets that way, it's more convincing.

336
00:17:07,150 --> 00:17:10,030
泽尔达总是这样做 让你的资产看起来
And Zelda has always done this, to make your assets look

337
00:17:10,030 --> 00:17:13,004
就好像它们略微倾斜 你抬头看着上面 
as if they are slightly tilted, and that you're looking up above.

338
00:17:13,004 --> 00:17:14,920
所以当你设计一个自上而下的游戏时 只要
So when you're designing a top down game, just

339
00:17:14,920 --> 00:17:20,200
为了令人信服 为了更有说服力 试着效仿一下 
for convincing the sake of being more convincing, try and emulate that.

340
00:17:20,200 --> 00:17:23,650
这里的实体 比如骨架 等等 
The entities here, like the skeleton, and such,

341
00:17:23,650 --> 00:17:25,690
更直截了当一点 
are a little bit more straight on.

342
00:17:25,690 --> 00:17:28,259
蝙蝠和泥巴之类的东西 尽管他们仍然
The bats and slimes and whatnot, even though they still

343
00:17:28,259 --> 00:17:29,800
有一点那样的外表 
have a little bit of that appearance.

344
00:17:29,800 --> 00:17:33,250
就像蜘蛛一样 它看起来有点像是从上到后的 
Like the spider it sort of looks as if it's from the top back.

345
00:17:33,250 --> 00:17:37,600
但从自上而下的角度对你的资产进行建模 主要是这件事 
But modeling your assets from a top down perspective, mainly the thing.

346
00:17:37,600 --> 00:17:39,910
注意阴影和高光 它们
Pay attention to shadows and highlights, which

347
00:17:39,910 --> 00:17:43,930
增加了很多方面 让我们相信我们是在这个有灯光的房间里 
adds a lot in terms of convincing us that we're in this room with lighting.

348
00:17:43,930 --> 00:17:48,850
还要确保你做的事情像是拐角之类的
And also make sure that you're doing things like corners and stuff

349
00:17:48,850 --> 00:17:54,490
而且 它看起来似乎是稍微倾斜的旋转方向 
and making, it look as if things are slightly skewed rotation wise.

350
00:17:54,490 --> 00:17:58,090
我们要看的第一件事是发行版中的代码
The first thing that we're going to look at in terms of the code in the distro

351
00:17:58,090 --> 00:18:00,170
就是地牢一代 
is Dungeon Generation.

352
00:18:00,170 --> 00:18:05,180
所以在塞尔达传说中 地下城是固定的 
So in Legend of Zelda, dungeons are fixed.

353
00:18:05,180 --> 00:18:08,500
它们完全是设计师事先设定的 
They're completely set in advance by the designers.

354
00:18:08,500 --> 00:18:10,960
在大多数游戏中 实际情况就是这样 
And in most games, this is actually the case.

355
00:18:10,960 --> 00:18:13,600
在我们的例子中 以及其他几个例子中 
In our example, and in a couple of other examples,

356
00:18:13,600 --> 00:18:16,210
其中一个主要的例子是我能想到的 
a primary example of them being that I can think of,

357
00:18:16,210 --> 00:18:19,750
我在幻灯片中看到了一个著名的游戏 叫做《艾萨克的装订》 
that I have in the slides, a famous game called The Binding of Isaac,

358
00:18:19,750 --> 00:18:23,000
也可以生成地下城 
dungeons can also be generated.

359
00:18:23,000 --> 00:18:27,280
那么 地下城的主单元是什么样的呢？
So what's the sort of like the main unit of a dungeon?

360
00:18:27,280 --> 00:18:29,080
至少在《塞尔达传奇》的背景下是这样？
At least in the context of Legend of Zelda?

361
00:18:29,080 --> 00:18:32,350
如果你必须提炼出地下城的组成成分 
If you had to distill what comprises a dungeon,

362
00:18:32,350 --> 00:18:34,000
最基本的单位是什么？
what's the most fundamental unit?

363
00:18:36,811 --> 00:18:37,311
托尼 
Tony.

364
00:18:37,311 --> 00:18:37,811
一个房间 
A room.

365
00:18:37,811 --> 00:18:38,500
是 
Yes.

366
00:18:38,500 --> 00:18:39,680
一个房间 
A room.

367
00:18:39,680 --> 00:18:43,940
所以我们几乎可以看到这一点 如果我们用2D阵列来描述它 
So we can almost look at this, if we picture it in terms of a 2D array,

368
00:18:43,940 --> 00:18:44,570
对吗？
right?

369
00:18:44,570 --> 00:18:47,650
我们有 假设这类似于指数1.1
We have, assuming that this is like index 1.1

370
00:18:47,650 --> 00:18:52,580
在Lua中是0.0 在其他语言中是从左到右、从上到下 
in Lua, 0.0 in other languages, going left to right, top to bottom.

371
00:18:52,580 --> 00:18:56,100
基本上 我们有开或关 相对于每一个 
Basically we have on or off, relative to each of these.

372
00:18:56,100 --> 00:18:59,030
关 开 关 
Off, on, off, off, off.

373
00:18:59,030 --> 00:19:03,320
这个2D数组中的每个索引都有一个空间 
Each of the indexes in this 2D array holds a room.

374
00:19:03,320 --> 00:19:08,810
因此 这个房间在其他房间之间有隐含的联系 
And so the room has connections implicitly between the other rooms.

375
00:19:08,810 --> 00:19:12,290
如果你想去 比方说 从这个房间到这个房间
If you wanted to go, let's say, from this room here to the room

376
00:19:12,290 --> 00:19:16,670
在它上面 就2D数组而言 偏移量是多少？
up above it, what's the offset, in terms of the 2D array?

377
00:19:16,670 --> 00:19:18,860
我们要怎么从这个房间走到这个房间？
How are we going from this room up to this room?

378
00:19:23,420 --> 00:19:25,490
所以我们只是上升了一级 对吗？
So we're just going up a y level, right?

379
00:19:25,490 --> 00:19:27,920
这是x级3 y级3 
So this is x level 3, y level 3.

380
00:19:27,920 --> 00:19:31,636
如果我们想上到隔壁房间 我们需要上车 
If we wanted to go up to the next room, we need to load in.

381
00:19:31,636 --> 00:19:33,260
如果我们用泽尔达的方式来做 对吗？
If we're doing it the Zelda way, right?

382
00:19:33,260 --> 00:19:34,310
我们只是要去--
And we're just going--

383
00:19:34,310 --> 00:19:36,500
我们在一个房间和一个房间之间做过渡
we're doing a transition between one room

384
00:19:36,500 --> 00:19:42,410
对另一个人来说 我们需要做的就是在这个房间里装东西 
to another, what we need to do is load in the room at this room,

385
00:19:42,410 --> 00:19:45,809
在y上减去1 然后执行转换 
minus one on the y, and then perform the transition.

386
00:19:45,809 --> 00:19:47,600
然后将其设置为当前房间 例如
And then set that to the current room, such

387
00:19:47,600 --> 00:19:51,200
现在我们知道我们处于y水平2 x水平3 
that now we know we're at y level 2, x level 3.

388
00:19:51,200 --> 00:19:52,220
那是我们的地牢 
That's our dungeon.

389
00:19:52,220 --> 00:19:56,810
在塞尔达传说中的2D地下城的背景下 
In the context of 2D dungeons in The Legend of Zelda,

390
00:19:56,810 --> 00:19:58,430
这就像它的实际情况一样简单 
that's as simple as it really is.

391
00:19:58,430 --> 00:20:00,980
你有一个由地牢房间组成的2D网格 
You have a 2D grid of dungeon rooms.

392
00:20:00,980 --> 00:20:04,100
每个房间都有自己的实体和对象集合
Each room has its own collection of entities and objects

393
00:20:04,100 --> 00:20:06,650
以及与其他房间的联系 
and connections to other rooms.

394
00:20:06,650 --> 00:20:12,020
但实际上 填充地牢所要做的就是以一种智能的方式填充数组
But really, all you do to fill a dungeon is fill an array in a smart way

395
00:20:12,020 --> 00:20:15,372
使得不存在例如它们自己留下的房间 
such that there is no rooms that are, for example, left by themselves.

396
00:20:15,372 --> 00:20:18,080
请注意 地牢中的每个房间都至少有一个连接
Notice that every room in the dungeon has at least one connection

397
00:20:18,080 --> 00:20:21,110
去另一个房间 
to another room.

398
00:20:21,110 --> 00:20:23,690
当你在做你的算法时
And that when you're maybe doing your algorithm

399
00:20:23,690 --> 00:20:27,470
为了创造一个令人信服的地下城 让我们假设这里的这个房间有
to create a convincing dungeon, let's say this room here has

400
00:20:27,470 --> 00:20:31,710
右边有一扇门 门上有锁 
a door on the right, that has a lock.

401
00:20:31,710 --> 00:20:32,870
对吗？
Right?

402
00:20:32,870 --> 00:20:36,312
我们要确保钥匙不在那个房间里 
We want to make sure that the key isn't in that room.

403
00:20:36,312 --> 00:20:38,020
因为如果是的话 我们永远都不会是
Because if it is, we're never going to be

404
00:20:38,020 --> 00:20:41,010
能够到达它 假设我们来自另一个方向 
able to get to it, assuming that we come from another direction.

405
00:20:41,010 --> 00:20:43,880
所以当你按程序设计地牢时 
So when you're designing dungeons procedurally,

406
00:20:43,880 --> 00:20:46,350
你想把这些事情都考虑进去 
you want to take these sort of things into consideration.

407
00:20:46,350 --> 00:20:47,850
然后 例如 老板的房间 
And then for example, the boss room.

408
00:20:47,850 --> 00:20:49,880
假设这是老板的房间 老板的房间
Let's say this is the boss room, the boss room

409
00:20:49,880 --> 00:20:52,970
应该有一把老板的钥匙之类的 
should have maybe a boss key, or something like that.

410
00:20:52,970 --> 00:20:57,300
但显然 老板的钥匙不应该在那个房间里 
But the boss key should not be, obviously, in that room.

411
00:20:57,300 --> 00:21:01,840
它应该在某个地方 也许前面还有几个房间
It should be somewhere maybe where there's a couple of rooms before it

412
00:21:01,840 --> 00:21:06,260
有一把锁或一把钥匙 这样你就知道有某种挑战
that have a lock or a key, so that you know there's some sort of challenge

413
00:21:06,260 --> 00:21:07,520
卷入了你的地牢 
involved in your dungeon.

414
00:21:07,520 --> 00:21:11,460
这不是像我们以前做的那样只是随机的 
It's not just random as we've done before.

415
00:21:11,460 --> 00:21:14,960
必须有一些有意识的设计来代表
There has to be a little bit of sort of conscious design on behalf

416
00:21:14,960 --> 00:21:16,640
你的算法 
of your algorithms.

417
00:21:16,640 --> 00:21:19,370
今天我们做的事情完全是随机的
Today we're doing things completely random

418
00:21:19,370 --> 00:21:22,760
作为说明 仅仅因为像这样的系统是相当健壮和复杂的 
for illustration, just because a system like this is fairly robust and complex.

419
00:21:22,760 --> 00:21:26,504
但只要付出一些努力 您就可以创建一个简单的地下城生成器
But with some effort, you could create a simple dungeon generator just using

420
00:21:26,504 --> 00:21:27,170
那些机械师 
those mechanics.

421
00:21:27,170 --> 00:21:29,140
只要确保你锁上门就行了 
Just make sure that you have locked doors.

422
00:21:29,140 --> 00:21:31,265
只有当你有钥匙时 锁着的门才能打开 
The locked doors can only open when you have a key.

423
00:21:31,265 --> 00:21:33,800
确保钥匙放在可以接近的地方 
Make sure the key exists in a place that's accessible,

424
00:21:33,800 --> 00:21:38,090
并在某种程度上创建了一个控制流的链 
and sort of create a chain of a control flow.

425
00:21:38,090 --> 00:21:42,830
模型可以通过某种图形来表示你的地牢 
Model maybe via graph of some kind that represents your dungeon,

426
00:21:42,830 --> 00:21:45,950
以及它的进程 
and the progression thereof.

427
00:21:45,950 --> 00:21:48,600
这就是塞尔达地牢的样子 
So that's what a Zelda dungeon looks like.

428
00:21:48,600 --> 00:21:52,430
这就是2D地牢在这种视角下的样子 
That's what a 2D dungeon in this sort of perspective looks like.

429
00:21:52,430 --> 00:21:55,490
而且它看起来--它看起来会和其他游戏引擎中的类似 
And it looks-- it will look similar to this in other game engines.

430
00:21:55,490 --> 00:21:57,890
它不一定要被完美地建模
It doesn't necessarily have to be perfectly modeled

431
00:21:57,890 --> 00:22:01,860
作为一个屏幕宽度 屏幕高度空间变成另一个屏幕宽度 屏幕
as a screen width, screen height room going into another screen width, screen

432
00:22:01,860 --> 00:22:02,360
房间很宽敞 
wide room.

433
00:22:02,360 --> 00:22:07,610
您可以拥有任意复杂的房间 这些房间的大小可以任意复杂
You can have arbitrarily complex rooms that have arbitrarily complex sizes

434
00:22:07,610 --> 00:22:10,590
和形状 
and shapes.

435
00:22:10,590 --> 00:22:14,180
但你仍然需要确保房间外的连接 
But you still need to make sure that the connections going out of the rooms,

436
00:22:14,180 --> 00:22:18,110
如果你还能做左、右、上、下的模型 如果你想的话 
like if you can still model left, right, up, down, if you want to.

437
00:22:18,110 --> 00:22:21,140
您可以对房间之间的任意数量的连接进行建模 
You can model arbitrary numbers of connections between rooms.

438
00:22:21,140 --> 00:22:24,230
只要确保你有可以解决的谜题 
Just make sure that you have puzzles that can be solved.

439
00:22:24,230 --> 00:22:28,610
这是产生你的地下城的主要障碍 
That's the main sort of obstacle in generating your dungeons.

440
00:22:28,610 --> 00:22:32,360
这是一款我非常喜欢的游戏 它使用了塞尔达传奇的古老公式
Here's a game that I really like that uses the old Legend of Zelda formula

441
00:22:32,360 --> 00:22:33,890
现在效果非常好 
to very good effect now.

442
00:22:33,890 --> 00:22:35,300
这叫做《以撒的捆绑》 
It's called The Binding of Isaac.

443
00:22:35,300 --> 00:22:38,840
请注意 我们已经可以立即看到它是自上而下的透视图 
Notice already we can instantly see that it's top-down perspective.

444
00:22:38,840 --> 00:22:42,740
整个房间的宽度和高度都是--
It's the entire width and height of the room is the dungeon of--

445
00:22:42,740 --> 00:22:46,700
整个屏幕的宽度和高度都是地下城的房间 
the entire width and height of the screen is the dungeon room.

446
00:22:46,700 --> 00:22:51,140
这里有一张地图 上面显示 好的 我就在这个房间里 
You have a map up here that shows you, OK, I'm in this room right here.

447
00:22:51,140 --> 00:22:52,850
我可以上去 我可以往左走 
I can go up, I can go left.

448
00:22:52,850 --> 00:22:54,590
我可以向右走 我可以往下走 
I can go right, I can go down.

449
00:22:54,590 --> 00:22:56,680
上面这个黄色皇冠的房间 那是
This room up here with the yellow crown, that's

450
00:22:56,680 --> 00:22:58,880
会被锁在某个门后面 拿着钥匙 
going to be locked behind some door with a key.

451
00:22:58,880 --> 00:23:02,840
所以我们需要有在这些房间里产生的钥匙
So we need to have keys that spawn in any of these rooms that

452
00:23:02,840 --> 00:23:05,635
只是盲目地接近而已 
are just blindly accessible.

453
00:23:05,635 --> 00:23:07,760
艾萨克做事情的方式也有点不同
And Isaac does things a little bit differently also

454
00:23:07,760 --> 00:23:09,980
因为它随机生成密钥和炸弹 
in that it generates keys and bombs randomly,

455
00:23:09,980 --> 00:23:11,600
这样你就可以真正得到--
so that you can actually get--

456
00:23:11,600 --> 00:23:15,860
你不一定要把钥匙放在非常特定的位置 
you don't necessarily have to plant your keys in very specific locations,

457
00:23:15,860 --> 00:23:19,100
如果您的算法足够灵活和足够复杂 
if your algorithm is sufficiently accommodating and complex enough.

458
00:23:19,100 --> 00:23:22,970
你可以在每个房间的尽头 有机会随机产生一把钥匙 
You can just at, the end of every room, have a chance to spawn a key randomly.

459
00:23:22,970 --> 00:23:25,520
如果你幸运 或者如果你不幸运 假设
And if you're lucky, or if you're not lucky, and assuming

460
00:23:25,520 --> 00:23:29,540
地牢的尽头并不存在于你锁着的门后面 
that the end of the dungeon doesn't exist behind your locked doors.

461
00:23:29,540 --> 00:23:33,500
你有机会拖延并锁上那些门 或者不 
You have the opportunity to stall and lock those doors, or not.

462
00:23:33,500 --> 00:23:36,570
并在需要的时候穿过你的地牢 
And just go on through your dungeon as needed.

463
00:23:36,570 --> 00:23:39,260
在这种情况下 他们不会锁上老板的门 
In this case, they don't lock the boss doors.

464
00:23:39,260 --> 00:23:42,500
这样 无论你有没有钥匙 你都可以通过老板的门 
So you can go through the boss door regardless of whether you have a key.

465
00:23:42,500 --> 00:23:45,980
所以他们已经适应了这种纯粹随机的方法 
So they've accommodated for this purely random approach,

466
00:23:45,980 --> 00:23:49,940
这正好说明了你如何仍然可以采取随机化
and that just goes to illustrate how you can still take randomisation

467
00:23:49,940 --> 00:23:53,240
使用非常复杂的原理 并制作游戏
using very complex principles, and produce games

468
00:23:53,240 --> 00:23:55,520
非常令人上瘾和有趣的东西 
that are extremely addicting and fun.

469
00:23:55,520 --> 00:24:00,380
而且你也不一定要非常详细 
And you don't necessarily need to be super elaborate.

470
00:24:00,380 --> 00:24:01,700
第一件事 好的 
The first thing, OK.

471
00:24:01,700 --> 00:24:03,840
因此 热门话题和伤害性话题将成为下一个话题 
So hitboxes and hurtboxes will be the next topic.

472
00:24:03,840 --> 00:24:07,430
所以 我想在代码中谈一谈 我们是如何在地下城
So I want to touch on, in the code, how we sort of do dungeon

473
00:24:07,430 --> 00:24:09,610
这是游戏引擎中的一代 
generation in the game engine here.

474
00:24:09,610 --> 00:24:11,000
所以我要敞开心扉 
So I'm going to open up--

475
00:24:11,000 --> 00:24:12,110
有几份文件 
there's a few files.

476
00:24:12,110 --> 00:24:17,580
请注意 在源代码发行版中 有一个World文件夹 
So doorway, notice in the source distro, there's a World folder.

477
00:24:17,580 --> 00:24:20,120
我们已经对所有的文件进行了分类
We've sort of categorized all of the files that

478
00:24:20,120 --> 00:24:24,410
与那个World文件夹中的世界一代有关 
have to do with world generation within that World folder.

479
00:24:24,410 --> 00:24:29,500
我们有一份门口档案 一份地牢档案 还有一份房间档案 
We have a doorway file, we have a dungeon file, and we have a room file.

480
00:24:29,500 --> 00:24:34,030
因此 地牢文件对地牢进行了建模 
So the dungeon file models the dungeon.

481
00:24:34,030 --> 00:24:38,740
所有形成我们地牢的房间 就像一个非常高的 水平的顶层
All of the rooms that form our dungeon, just as a very high, level top

482
00:24:38,740 --> 00:24:39,850
级别、数据结构 
level, data structure.

483
00:24:39,850 --> 00:24:42,100
其实很简单 
It's actually very simple.

484
00:24:42,100 --> 00:24:46,120
正如我们之前看到的 这个房间是地牢的个体单位 
The room is, as we saw before, the individual unit of the dungeon.

485
00:24:46,120 --> 00:24:49,900
因此 地牢实际上就像一张房间的桌子 
So a dungeon is effectively like a table of rooms.

486
00:24:49,900 --> 00:24:55,086
然后它保存着我们如何在它们之间转换的代码 
And then it holds the code for how we can transition between them.

487
00:24:55,086 --> 00:24:56,960
但这在某种程度上是我们可以思考的 
But that's sort of how we can think about it.

488
00:24:56,960 --> 00:24:59,890
当你的游戏水平一般时 在这种情况下是地下城
When you a game level in general, in this case dungeon

489
00:24:59,890 --> 00:25:01,510
在某种程度上是我们的比赛水平 
is sort of our game level.

490
00:25:01,510 --> 00:25:04,210
您可以对不同的子集方面建模
You can model the different subset aspects

491
00:25:04,210 --> 00:25:06,187
通过某种数据结构来了解你的水平 
of your level via some data structure.

492
00:25:06,187 --> 00:25:08,020
在这种情况下 我们决定把它腾出空间 
In this case, we've decided to make it room.

493
00:25:08,020 --> 00:25:09,728
但如果你只有一个平台或关卡 
But if you have just a platform or level,

494
00:25:09,728 --> 00:25:12,460
也许你有区域或区域 或任何东西 
maybe you have regions or zones, or anything.

495
00:25:12,460 --> 00:25:16,120
只是你所在级别的一些小部分 你可以在它们之间过渡 
Just little subsegments of your level that you can transition between.

496
00:25:16,120 --> 00:25:19,150
从这个角度考虑是很有用的 因为从效率来看
It's useful to think in terms of that, because from an efficiency

497
00:25:19,150 --> 00:25:22,840
从性能的角度来看 您希望动态加载
and performance standpoint, you want to dynamically probably load

498
00:25:22,840 --> 00:25:24,760
特定的级别 一次一个 
certain levels one at a time.

499
00:25:24,760 --> 00:25:29,500
某些方面 某些部分 你所在水平的子领域 一次一个 
Certain aspects, certain components, sub areas of your level, one at a time,

500
00:25:29,500 --> 00:25:31,540
而不是一次只有整个级别 
rather than just the entire level at once,

501
00:25:31,540 --> 00:25:35,170
因为这取决于你的关卡有多复杂和多大 
because depending on how sufficiently complex and large your level is,

502
00:25:35,170 --> 00:25:38,650
您可以开始练习您的计算机的内存限制 
you can get to exercising your computer's memory constraints.

503
00:25:38,650 --> 00:25:40,550
所以我不想这么做 
So don't want to do that.

504
00:25:40,550 --> 00:25:45,160
所以在这种情况下 我们的算法是我们有一个地牢 我们有房间 
So in this case, our algorithm is we have a dungeon, we have rooms.

505
00:25:45,160 --> 00:25:48,130
我们有一个活动房间 只能在同一时间看到 那是
We have one active room that's only visible at one time that's

506
00:25:48,130 --> 00:25:49,300
加载到内存中 
loaded in memory.

507
00:25:49,300 --> 00:25:51,580
然后每当我们在不同房间之间转换时 
And then whenever we transition between rooms,

508
00:25:51,580 --> 00:25:55,280
我们想要另一间临时入住的房间 
we want to have another room that gets temporarily loaded.

509
00:25:55,280 --> 00:25:57,670
那么让我们来看看这里的地下城班级 
So let's look at the dungeon class here.

510
00:25:57,670 --> 00:25:59,290
地下城 卢亚 
Dungeon.lua.

511
00:25:59,290 --> 00:26:03,200
所以14间自学的房间 空着桌子 
So 14 self-taught rooms, empty table.

512
00:26:03,200 --> 00:26:06,130
我们要在里面放满房间 就是房间里的东西 
We're going to fill that with rooms, just room objects.

513
00:26:06,130 --> 00:26:07,550
自助室 
Self.currentroom.

514
00:26:07,550 --> 00:26:11,230
房间 我们要把它传给球员 
Room, and we're going to pass it in the player.

515
00:26:11,230 --> 00:26:15,760
从而玩家可以访问其中的所有实体和对象 
So that the player has access to all the entities and objects therein,

516
00:26:15,760 --> 00:26:19,630
可以做碰撞检测之类的事情 这是非常重要的 
and can do things like collision detection, which is very important.

517
00:26:19,630 --> 00:26:26,680
也是为了让房间里的实体可以看到玩家
And also so that the entities in the room can look at the player

518
00:26:26,680 --> 00:26:30,370
然后决定他们想要对他们的人工智能做什么 
and then decide what they want to do with their AI, which

519
00:26:30,370 --> 00:26:34,270
您可以对任意复杂的模型进行建模 
you can model arbitrarily complex.

520
00:26:34,270 --> 00:26:39,140
Room.lua的整个初始化函数都在运行 我们将在这里展示它 
The whole init function of room.lua is going, we're going to show it here.

521
00:26:39,140 --> 00:26:42,590
所以在room.lua中 在同一个World文件夹中 
So in room.lua, in that same world folder,

522
00:26:42,590 --> 00:26:44,680
我们已经在高级别实例化了地牢 
we've instantiated the dungeon at a high level.

523
00:26:44,680 --> 00:26:47,860
我们知道地牢 它基本上是一张桌子的房间 
We know the dungeons, it's basically a table of rooms.

524
00:26:47,860 --> 00:26:51,190
那么房间是什么样子的呢？
So what's a room look like?

525
00:26:51,190 --> 00:26:54,130
嗯 一个房间 就像我们以前看到的 有哪些部分
Well a room, as we saw before, what are the pieces

526
00:26:54,130 --> 00:26:56,595
一个房间需要什么才能发挥作用？
that a room needs in order to function?

527
00:26:56,595 --> 00:26:58,720
在某种程度上 房间需要控制什么？
What does the room have to sort of keep control of?

528
00:27:02,064 --> 00:27:02,730
观众：门 
AUDIENCE: Doors.

529
00:27:02,730 --> 00:27:03,563
科尔顿·奥格登：门 
COLTON OGDEN: Doors.

530
00:27:06,287 --> 00:27:06,870
还要别的吗？
Anything else?

531
00:27:09,640 --> 00:27:11,620
所以它必须跟踪门 对吗？
So doors it has to keep track of, right?

532
00:27:11,620 --> 00:27:14,590
因为当我们触摸一扇门时 我们应该过渡到另一个房间 
Because when we touch a door, we should transition to the next room.

533
00:27:14,590 --> 00:27:16,720
它应该跟踪玩家 
It should keep track of the player.

534
00:27:16,720 --> 00:27:18,330
这样玩家就可以更新了 
So the player can update.

535
00:27:18,330 --> 00:27:21,500
它应该跟踪房间里的物体 比如开关 
It should keep track of objects in the room like switches,

536
00:27:21,500 --> 00:27:25,556
正如我们在示例中看到的 这样他们就可以更新那些 
as we saw in the example, such that they can update those.

537
00:27:25,556 --> 00:27:27,430
看看这位选手踩到开关了吗？
And see has the player stepped on the switch?

538
00:27:27,430 --> 00:27:30,070
如果他有 就把门打开 
If he has, open the doors.

539
00:27:30,070 --> 00:27:31,830
然后是实体 对吗？
And then entities, right?

540
00:27:31,830 --> 00:27:34,750
它应该跟踪房间里的所有生物
It should keep track of all of the creatures in the room

541
00:27:34,750 --> 00:27:37,240
这样他们就可以更新 他们可以相互互动 
so that they can update, they can interact with each other.

542
00:27:37,240 --> 00:27:40,660
球员可以打他们 或者他们可以打球员 
The player can hit them, or they can hit the player.

543
00:27:40,660 --> 00:27:44,890
您可以对任何您想要的交互进行建模 
And you can model whatever interactions you want to.

544
00:27:44,890 --> 00:27:45,820
所以我们可以在这里看到 
So we can see here.

545
00:27:45,820 --> 00:27:47,190
哦 还有一件事 
Oh, and another thing too.

546
00:27:47,190 --> 00:27:50,830
可能是它更重要的视觉方面之一 
Probably one of the more important visual aspects of it,

547
00:27:50,830 --> 00:27:54,640
我们还需要一套瓷砖来模拟房间的样子 
we need to also have a set of tiles that model what the room looks like.

548
00:27:54,640 --> 00:27:55,850
这是一个集装箱 
It's a container.

549
00:27:55,850 --> 00:28:00,550
所以我们要画 我们有一个角 一个角 
So we're going to draw, we have a corner, a corner, a corner, a corner.

550
00:28:00,550 --> 00:28:01,630
两边都是墙 
Walls on the sides.

551
00:28:01,630 --> 00:28:02,830
顶部和底部的墙 
Walls on the top and bottom.

552
00:28:02,830 --> 00:28:03,910
然后是一层楼 
And then a floor.

553
00:28:03,910 --> 00:28:06,040
所以我们显然需要画出房间
And so we need to obviously draw the room

554
00:28:06,040 --> 00:28:09,039
在我们画出所有其他的东西之前 更新所有其他的东西 
before we draw all of the other things, and update all the other things.

555
00:28:09,039 --> 00:28:14,550
因此 瓷砖、门口、实体和对象 
So tiles, doorways, entities, and objects.

556
00:28:14,550 --> 00:28:16,151
所以我们可以在这里看到 
So we can see here.

557
00:28:16,151 --> 00:28:18,400
你有瓷砖 柔和的瓷砖靠在一张空桌子上 
You have tiles, soft-lit tiles against an empty table.

558
00:28:18,400 --> 00:28:21,040
我们有一个叫做生成墙和楼板的功能 
We have a function called Generate Walls And Floors.

559
00:28:21,040 --> 00:28:22,330
实体、空表 
Entities, empty table.

560
00:28:22,330 --> 00:28:24,520
我们有一个名为生成实体的函数 
We have a function called Generate Entities.

561
00:28:24,520 --> 00:28:26,425
然后对象就等于空桌了 
And then objects equals empty table.

562
00:28:26,425 --> 00:28:28,720
我们有一个名为生成对象的函数 
We have a function called Generate Objects.

563
00:28:28,720 --> 00:28:29,980
最后是门口 
And lastly, doorways.

564
00:28:29,980 --> 00:28:33,100
然后是这里 因为它不一定
And then here because it's not necessarily

565
00:28:33,100 --> 00:28:38,740
就像我们需要一个完整的功能一样复杂 我们只有四个门 
as complex as we need for a entire function, we just have four doorways.

566
00:28:38,740 --> 00:28:40,090
这是静态的 
And this is static.

567
00:28:40,090 --> 00:28:43,300
在本例中 我选择始终保留所有的门口
I've chosen in this example to have all the doorways always

568
00:28:43,300 --> 00:28:46,210
处于相同的位置 并以相同的方式行事 
be in the same place, and sort of behave in the same way.

569
00:28:46,210 --> 00:28:50,710
但您可以创建一个更复杂的系统 特别是
But you could create a more complex system, whereby especially

570
00:28:50,710 --> 00:28:54,310
如果你有一个动态生成地牢的算法 
if you have an algorithm that generates a dungeon dynamically,

571
00:28:54,310 --> 00:28:56,660
也许你的房间不一定是硬性的 
and maybe your rooms aren't necessarily hard set.

572
00:28:56,660 --> 00:28:58,660
也许你有一把扫帚 对吧？
Maybe you have a broom, right?

573
00:28:58,660 --> 00:29:02,162
如果我们早点回到我们的幻灯片 
If we go back to our slides earlier.

574
00:29:02,162 --> 00:29:05,120
让我们假设我们看的是这个房间 就在这个最中间的地方 
And let's say we're looking at this room right here in the very center.

575
00:29:05,120 --> 00:29:08,470
我们可以看到它的左边有一个门 上面有一个门 
We can see it has a doorway on the left, a doorway up top,

576
00:29:08,470 --> 00:29:10,000
右手边还有一扇门 
and a doorway to the right.

577
00:29:10,000 --> 00:29:13,510
但它的底部没有通道 
But there's no doorway on the bottom.

578
00:29:13,510 --> 00:29:17,200
这看起来像是代表设计师的一个武断的设计决定 
And that looks like an arbitrary design decision on behalf of the designers.

579
00:29:17,200 --> 00:29:21,820
但如果我们看看上面的这个房间 我们
But if we look at this room up top here, we

580
00:29:21,820 --> 00:29:24,286
可以看到它在某种程度上是以同样的方式运行的 
can see that it sort of behaves in the same way.

581
00:29:24,286 --> 00:29:26,410
左边有一扇门通往这个房间 
There's a doorway going into this room to the left.

582
00:29:26,410 --> 00:29:28,780
下面有一个通往这个房间的门道 
There's doorway going to this room down below.

583
00:29:28,780 --> 00:29:31,446
但上面没有门 右边也没有门 
But it doesn't have a doorway up top and a doorway on the right,

584
00:29:31,446 --> 00:29:35,390
因为那个房间和那些方向之间没有房间 
because there are no rooms going between that room and those directions.

585
00:29:35,390 --> 00:29:38,770
所以当你有一个二维地牢房间阵列时 
So when you have a 2D array of dungeon rooms,

586
00:29:38,770 --> 00:29:42,220
你想要为你的门口建模 它可以很简单
and you want to model your doorways, it can be as simple

587
00:29:42,220 --> 00:29:45,130
那么 那个方向还有空间吗？
as is there room in that direction?

588
00:29:45,130 --> 00:29:48,160
如果有 您将拥有您的数据结构
If there is, and you will have your data structures sort of

589
00:29:48,160 --> 00:29:53,420
在生成这些门口之前预先布置好 如果它不存在 
laid out in advance before you generate these doorways, if it does not exist,

590
00:29:53,420 --> 00:29:54,250
不要做一扇门 
don't make a door.

591
00:29:54,250 --> 00:29:56,710
如果它确实存在 就做一扇门 
If it does exist, make a door.

592
00:29:56,710 --> 00:29:59,350
然后确保当你过渡的时候
And then make sure that when you transition

593
00:29:59,350 --> 00:30:05,140
从右到左 或者从下到上 
between from the right to the left, or from the bottom to the top,

594
00:30:05,140 --> 00:30:11,770
您可以在2D房间阵列中以正确的索引进入正确的房间 
that you go to the correct rooms at the correct indices in your 2D room array.

595
00:30:11,770 --> 00:30:12,834
这说得通吗？
Does that make sense?

596
00:30:12,834 --> 00:30:16,000
到目前为止 有没有人有什么问题想知道这是如何在高层运作的？
Anybody have any questions so far as to like how this works at a high level?

597
00:30:18,660 --> 00:30:19,530
好的?
OK?

598
00:30:19,530 --> 00:30:20,380
太棒了 
Awesome.

599
00:30:20,380 --> 00:30:23,300
所以这里的这些门道都是因为这座地牢
So these doorways here are all because of this dungeon

600
00:30:23,300 --> 00:30:29,000
是完全随机的 每次它总是有通向顶部和底部的门 
is completely random, and every time it always has doorways going top, bottom,

601
00:30:29,000 --> 00:30:29,726
左手和右手 
left and right.

602
00:30:29,726 --> 00:30:31,600
我们总是要放四扇门 
We're always just going to put four doorways,

603
00:30:31,600 --> 00:30:32,900
从上 下 左 右 
going top, bottom, left and right.

604
00:30:32,900 --> 00:30:34,691
请注意 它们接受一个字符串 表示
Note that they take a string denoting which

605
00:30:34,691 --> 00:30:36,820
它们是方向 这将变得重要
direction they are, and this will become important

606
00:30:36,820 --> 00:30:40,390
稍后在Doorway课程中 我们在这里看到
later on in the doorway class, which we see here

607
00:30:40,390 --> 00:30:42,880
被建模为单独的类 
is modeled as a separate class.

608
00:30:42,880 --> 00:30:45,160
这里的FALSE只是意味着门是开着的吗？
False here just means is the door open?

609
00:30:45,160 --> 00:30:48,310
因此 默认情况下 我们将关闭门 
So by default, we're going to close the door.

610
00:30:48,310 --> 00:30:51,790
然后是自己 这样我们就可以从门口进入房间 
And then self, so that we have access to the room from the doorway.

611
00:30:54,632 --> 00:30:56,590
房间里应该有球员的名字 
The room should have a reference to the player,

612
00:30:56,590 --> 00:31:00,940
这样它就可以对实体和玩家之间的交互进行建模 
so that it can model interactions between the entities and the player,

613
00:31:00,940 --> 00:31:04,030
以及物品和球员 
as well as the objects and the player.

614
00:31:04,030 --> 00:31:05,890
请注意 它具有渲染偏移 
Notice that it has a render offset.

615
00:31:05,890 --> 00:31:14,230
所以如果我们看看这个游戏 瓷砖
So if we look at the game here, the tiles

616
00:31:14,230 --> 00:31:17,920
不要与屏幕的宽度和高度完全匹配 
don't completely match up to the width and height of the screen.

617
00:31:17,920 --> 00:31:21,340
这主要是虚拟高度的函数
And that's mainly a function of the virtual height

618
00:31:21,340 --> 00:31:26,710
没有完美地映射到16个瓷砖 由16个瓷砖均匀划分 
not mapping perfectly to 16 tiles, divided evenly by 16 tiles.

619
00:31:26,710 --> 00:31:29,750
所以我所做的就是把地牢变小了一点 
So what I've done is I've made the dungeon a little bit smaller.

620
00:31:29,750 --> 00:31:36,160
还有一个事实是 门口占据了几块额外的衬垫
And also the fact that the doorways take up a couple of extra tiles of padding

621
00:31:36,160 --> 00:31:39,610
在他们的一侧 这里就像是一片空白 
on their sides, it's like sort of blank space up here.

622
00:31:39,610 --> 00:31:41,830
我们已经将所有东西都稍微向内移动了一点 
We've shifted everything inwards a little bit.

623
00:31:41,830 --> 00:31:47,410
我们已经把地牢做了两块 宽度和高度都比屏幕小 
We've made the dungeon two tiles smaller width and height wise than the screen.

624
00:31:47,410 --> 00:31:50,080
然后我们呈现了一定数量的偏移量
And then we've just rendered offset by a certain amount

625
00:31:50,080 --> 00:31:51,640
使其完全居中 
such that it's completely centered.

626
00:31:51,640 --> 00:31:56,890
我们计算在完全渲染的地下城之间存在多少填充
We calculate how much padding exists between the fully rendered dungeon

627
00:31:56,890 --> 00:32:00,190
不管剩下什么空格 只要移动一半就行了 
and whatever blank space is left, and just shift by half of that amount,

628
00:32:00,190 --> 00:32:01,780
这是我们的渲染偏移量 
and that's our render offset.

629
00:32:01,780 --> 00:32:05,164
因此 这就是渲染偏移在这种情况下很重要的原因 
So that's why render offset is important in this case.

630
00:32:05,164 --> 00:32:07,330
当你试图将任何东西放在中心时 你通常会
When you're trying to center anything, you typically

631
00:32:07,330 --> 00:32:08,852
只需计算一个偏移量即可 
do it just by calculating an offset.

632
00:32:08,852 --> 00:32:11,560
计算你想要画的任何东西的宽度和高度 
Calculate the width and height of whatever you're trying to draw,

633
00:32:11,560 --> 00:32:14,920
计算屏幕的宽度和高度减去它 
calculate whatever your width and height of your screen is minus that,

634
00:32:14,920 --> 00:32:18,040
将其除以2 这就是渲染偏移 
divide it by 2, that's your render offset.

635
00:32:18,040 --> 00:32:22,570
这里的这两个领域很有趣 自邻接偏移X 
And then these two fields here are interesting. self.adjacentoffsetX,

636
00:32:22,570 --> 00:32:24,610
Self.adjectoffsetY 
self.adjectentoffsetY.

637
00:32:24,610 --> 00:32:30,284
有没有人猜到这是用来做什么的？
Does anybody have a guess as to what this is used for?

638
00:32:30,284 --> 00:32:31,226
嗯 
Yeah.

639
00:32:31,226 --> 00:32:33,110
当它在隔壁房间的时候画自己 
Drawing itself when it's the adjacent room.

640
00:32:33,110 --> 00:32:34,550
是的 没错 
Yes, exactly.

641
00:32:34,550 --> 00:32:37,160
所以当它在隔壁房间的时候画自己 
So drawing itself when it's the adjacent room.

642
00:32:37,160 --> 00:32:39,950
所以当你装上下一个房间的时候 你要
So when you load the next room, you're going

643
00:32:39,950 --> 00:32:41,900
实例化一个房间 就像这样 
to instantiate a room just like this.

644
00:32:41,900 --> 00:32:44,790
但默认情况下 它将绘制为0.0 
But by default it's going to draw at 0.0.

645
00:32:44,790 --> 00:32:49,049
然而 如果我们想要那个房间画在我们不合适的地方 
However, if we want that room to draw not right where we are.

646
00:32:49,049 --> 00:32:50,840
显然 如果我们在现在的房间里 我们
Obviously, if we're in the current room, we

647
00:32:50,840 --> 00:32:52,220
我不想让隔壁的房间画在最上面
don't want the next room drawing right on top

648
00:32:52,220 --> 00:32:54,724
我们所处的位置 因为那样它就会层次分明
of where we are, because then it's just going to layer right

649
00:32:54,724 --> 00:32:55,890
在我们所在的房间顶端 
on top of the room we're in.

650
00:32:55,890 --> 00:32:56,960
我们想把它画出来--
And we want to draw it--

651
00:32:56,960 --> 00:32:59,450
如果我们要向右转 则需要向右绘制屏幕宽度 
if we're going to the right, we want to draw a screen width to the right.

652
00:32:59,450 --> 00:33:02,870
如果我们将其绘制到左侧 我们希望将其绘制为左侧的屏幕宽度 
If we're drawing it to the left, we want to draw it a screen width to the left.

653
00:33:02,870 --> 00:33:04,700
在y轴上也是一样的 
And same thing on the y-axis.

654
00:33:04,700 --> 00:33:06,480
上方或下方的屏幕高度 
A screen height above, or below it.

655
00:33:06,480 --> 00:33:10,790
所以相邻的偏移量X或y 我们在画房间的时候加进去就行了 
So adjacentoffsetX or y, we just add to when we draw the room.

656
00:33:10,790 --> 00:33:16,210
这将产生与房间分开渲染的效果
And that'll have the effect of rendering it separately from the room

657
00:33:16,210 --> 00:33:17,210
我们目前所处的位置 
that we're currently in.

658
00:33:17,210 --> 00:33:19,140
我可以试着在这里画一个插图 
I can try and draw an illustration here.

659
00:33:19,140 --> 00:33:24,080
所以 如果我们有我们的房间 这就是我们现在的房间 
So if we have our room here, this is our current room.

660
00:33:24,080 --> 00:33:25,310
太自私了 房间里 
So self.currentroom.

661
00:33:32,040 --> 00:33:35,741
假设我们在这里有一扇门 
And let's say we have a doorway here.

662
00:33:35,741 --> 00:33:36,240
对吗？
Right?

663
00:33:36,240 --> 00:33:38,520
那是一个门口的物体 玩家在这里 
That's a doorway object, the player is here.

664
00:33:38,520 --> 00:33:40,230
他撞上了那个物体 
He collides with that object.

665
00:33:40,230 --> 00:33:43,480
它会触发一个过渡到上面的房间 
It's going to trigger a transition to a room up above.

666
00:33:43,480 --> 00:33:46,980
所以我们要做的就是马上搬进一个新房间 
So what we do is we load in a new room right away.

667
00:33:46,980 --> 00:33:53,460
我们总是有一个名为self.nextroom的指针 
We always have a pointer called self.nextroom.

668
00:33:53,460 --> 00:33:56,850
这些都记录在dungeod.lua文件中 
And this is all kept track of in the dungeod.lua file.

669
00:33:56,850 --> 00:34:01,740
但在默认情况下 self.nextroom将为零 
But self.nextroom by default is going to be nil.

670
00:34:01,740 --> 00:34:06,810
但是当我们从现在的房间过渡到下一个房间的时候 对吗？
But when we transition from the current room to the next room, right?

671
00:34:06,810 --> 00:34:08,460
我们应该把它设置成某种东西 
We should set that to something.

672
00:34:08,460 --> 00:34:12,909
因此 self.Curentroom将是相同的 
So self.currentroom is going to be the same.

673
00:34:12,909 --> 00:34:19,230
但当我们触发这场碰撞时 
But when we trigger this collision, self.nextroom,

674
00:34:19,230 --> 00:34:24,090
这将只相当于一个新房间 
this is going to be equal to just a new room.

675
00:34:24,090 --> 00:34:26,310
然后我们就知道我们在哪个门口了 
And then we get which doorway we're in.

676
00:34:26,310 --> 00:34:27,159
我们会想办法的 
We figure it out.

677
00:34:27,159 --> 00:34:29,940
从技术上讲 我们会弄清楚我们要朝哪个方向前进 
We figure out which direction we're moving in, technically.

678
00:34:29,940 --> 00:34:35,150
然后如果我们往上走 我们就会通过一个--
And then if we're moving up, then we just pass in a--

679
00:34:35,150 --> 00:34:41,790
在这种情况下 我们说它与负屏幕高度的偏移量y相邻 
we said it's adjacent offset y in this case, to negative screen height.

680
00:34:41,790 --> 00:34:45,080
如果它低于屏幕高度 则将其设置为正屏幕高度 
If it's below, we set it to positive screen height.

681
00:34:45,080 --> 00:34:50,580
如果我们到这里 它将是负屏 与相邻的x 
If we go here, it's going to be negative screen with the adjacent x,

682
00:34:50,580 --> 00:34:52,260
将为负屏宽 
will be negative screen width.

683
00:34:52,260 --> 00:34:56,909
如果我们向右移动 那么x上的正屏幕宽度 
And then positive screen width on the x if we're moving to the right.

684
00:34:56,909 --> 00:35:04,710
所以我们可以看到这种相邻的 如果是XY 
And so this sort of adjacent we could see, if do xy,

685
00:35:04,710 --> 00:35:07,810
这基本上就是相邻的偏移量 
it will be that's basically the adjacent offset.

686
00:35:07,810 --> 00:35:14,955
最后我们画出了从底部到
And so we end up when we draw our transition going from bottom to

687
00:35:14,955 --> 00:35:21,160
在这种情况下 我们只是补间相机到这个值 
up in this case, we just tween the camera to this value.

688
00:35:21,160 --> 00:35:23,550
我们有摄像头 对吧？
So we have a camera, right?

689
00:35:23,550 --> 00:35:24,750
这是我们的相机
This is our camera.

690
00:35:24,750 --> 00:35:30,390
默认情况下它会看这里 摄像机x和摄像机y 
And it's going to be looking here by default. So camera x and camera y,

691
00:35:30,390 --> 00:35:33,600
这些也是我们代码中的价值观 
those are values in our code as well.

692
00:35:33,600 --> 00:35:37,080
当我们在门口触发碰撞时 
When we trigger this collision on the doorway,

693
00:35:37,080 --> 00:35:40,110
这里有当前的空间 它是0.0
and we have current room here, which is at 0.0,

694
00:35:40,110 --> 00:35:45,870
这里有一个房间 它的位置是0加上相邻的
and then we have this room here, which is at 0 plus our adjacent

695
00:35:45,870 --> 00:35:48,120
偏移y 这是负的屏幕高度 
offset y, which is negative screen height.

696
00:35:48,120 --> 00:35:53,790
所以它的作用是使屏幕高度在y轴上为负 
So it has the effect of making it negative screen height on the y.

697
00:35:53,790 --> 00:35:57,840
我们的相机x回忆爱 图形 翻译是我们的相机 
Our camera x recall love.graphics.Translate is our camera.

698
00:35:57,840 --> 00:35:59,580
所以我们要做的就是在两者之间 
So all we do is we just tween that.

699
00:35:59,580 --> 00:36:00,970
我们说 好的 
We say, OK.

700
00:36:00,970 --> 00:36:05,020
这是我们的X号摄像机会在这里.
Here's our Cam x is going to be here.

701
00:36:05,020 --> 00:36:07,210
小卡 有点乱了 
And Cam y, it's getting a little bit messy.

702
00:36:07,210 --> 00:36:07,920
我道歉
I apologize.

703
00:36:07,920 --> 00:36:10,230
但是我们的x和y摄像头在这里 
But our camera x and y are here.

704
00:36:10,230 --> 00:36:17,070
随着时间的推移 我们会把它放到下一个房间
And then over time, we're going to tween that up into the next rooms

705
00:36:17,070 --> 00:36:23,790
x和y 即x加上相邻偏移x y加上相邻偏移y 
x and y, which is a just x plus adjacent offset x, y plus adjacent offset y.

706
00:36:23,790 --> 00:36:29,040
一旦摄像机从这里移到这里 
And then once this camera has shifted from here up to here,

707
00:36:29,040 --> 00:36:32,620
或者我们要去的任何方向 无论是上 下 左还是右 
or whichever direction we're going, whether it's up, down, left or right.

708
00:36:32,620 --> 00:36:39,090
一旦我们完成了这一点 我们可以再次将所有内容标准化为0.0
Once we've completed that, we can normalize everything again back to 0.0

709
00:36:39,090 --> 00:36:45,210
我们需要做的是 
by doing self.currentroom equals, what do we need to do,

710
00:36:45,210 --> 00:36:48,570
如果我们要把所有东西都放回去
if we're going to put everything back to?

711
00:36:48,570 --> 00:36:51,505
假设我想把这个房间设为新的当前房间 
Let's say I want to make this room the new current room.

712
00:36:51,505 --> 00:36:52,380
我需要做什么？
What do I need to do?

713
00:36:55,840 --> 00:36:58,870
我们有当前房间 还有下一个房间 
So we have current room, and we have next room.

714
00:36:58,870 --> 00:37:01,600
如果我想让当前房间变成下一个房间 
If I want the current room to become the next room,

715
00:37:01,600 --> 00:37:08,440
我只需要说self.currencial等于self.nextreme 对吧？
all I need to do is say self.currentroom equals self.nextroom, right?

716
00:37:12,610 --> 00:37:16,300
一旦发生这种情况 
And then once that happens, what happens to the adjacent

717
00:37:16,300 --> 00:37:18,190
下一个房间的x和y偏移量
offset x and y of the next room?

718
00:37:22,200 --> 00:37:23,830
他们被设置为0 对吧？
They get set to 0, right?

719
00:37:23,830 --> 00:37:27,157
我想把这个房间 我们已经抵消了这里 
I want to take this room that we've offset up here,

720
00:37:27,157 --> 00:37:29,740
我只想让它再次成为游戏世界的中心 
and I just want to make it the center of the game world again.

721
00:37:29,740 --> 00:37:34,360
我只想把它设置为0.0 这样我们就可以进行完全相同的计算
I want to just put it as 0.0, so we can do this exact same calculation

722
00:37:34,360 --> 00:37:39,230
只需将相邻的偏移量x或y设置为负或正屏幕高度
by just setting adjacent offset x or y to a negative or positive screen height

723
00:37:39,230 --> 00:37:41,770
或相对于0.9的屏幕宽度 
or screen width relative to 0.9.

724
00:37:41,770 --> 00:37:45,910
所以我要做的就是设置相邻的偏移量
So what I'm going to do is just set the adjacent offset

725
00:37:45,910 --> 00:37:50,600
将下一个房间(即当前房间)的x和y设置为0 
of x and y of the next room, which is now current room, to 0.

726
00:37:50,600 --> 00:37:53,320
它会把它拉回到0.0 
And it's going to draw it right back at 0.0.

727
00:37:53,320 --> 00:37:57,430
然后 相机x和相机y也将设置为0.0 
And then camera x and camera y are also going to be set to 0.0.

728
00:37:57,430 --> 00:38:00,700
这将会产生一种效果 看起来就像我们正在上升
And this is going to have the effect of looking as if we're going up

729
00:38:00,700 --> 00:38:01,720
并留在那里 
and staying there.

730
00:38:01,720 --> 00:38:03,880
但在现实中 我们只是往上走 然后
But in reality, we're just going up, and then

731
00:38:03,880 --> 00:38:05,710
立刻把一切都调回到了0度 
instantly shifting everything back to 0.0,

732
00:38:05,710 --> 00:38:09,370
包括那个房间的玩家、实体和开关 
including the player, entities, and switches of that room.

733
00:38:09,370 --> 00:38:11,020
所以这纯粹是一种错觉 
So it's purely an illusion.

734
00:38:11,020 --> 00:38:15,755
但它允许我们模拟这种无限探索地牢效应的过程 
But it allows us to simulate this sort of infinite exploring a dungeon effect.

735
00:38:15,755 --> 00:38:16,630
这说得通吗？
Does that make sense?

736
00:38:16,630 --> 00:38:20,110
这种工作方式的整体流程是否有意义？
Does the overall flow of how this works makes sense?

737
00:38:20,110 --> 00:38:20,656
好的 
OK.

738
00:38:20,656 --> 00:38:22,030
所以那里有点乱 
So it's a little bit messy there.

739
00:38:22,030 --> 00:38:27,250
希望我能够说明整个算法是如何
Hopefully I was able to illustrate the overall algorithm for how

740
00:38:27,250 --> 00:38:29,230
无限地牢发电机起作用了 
the infinite dungeon generator works.

741
00:38:32,050 --> 00:38:33,610
我们在哪里停下来了？
Where did we leave off?

742
00:38:33,610 --> 00:38:37,460
我们在房间的初始功能中 
We were in the init function of the room.

743
00:38:37,460 --> 00:38:42,160
因此 让我们来看看组成它的几个函数 
So let's take a look at a few of the functions that comprise that.

744
00:38:42,160 --> 00:38:45,180
因此 生成墙和地板 
So generate walls and floors.

745
00:38:45,180 --> 00:38:47,560
这与我们所看到的非常相似
This is very similar to what we've looked

746
00:38:47,560 --> 00:38:52,360
以马里奥的瓷砖地图为例 我们只需从y到x 
at before with tile maps in Mario for example, where we just go from y to x.

747
00:38:52,360 --> 00:38:55,210
然后我们只需要选择一个随机的ID 或者我们的随机ID 
And then we just pick a random ID, or our random ID.

748
00:38:55,210 --> 00:38:56,800
嗯 其中一些是随机的身份证 
Well, it is random ID for some of it.

749
00:38:56,800 --> 00:38:58,760
但有时我们需要一个明确的身份证明 
But sometimes we need an explicit ID.

750
00:38:58,760 --> 00:39:04,960
所以提醒我 ID实际上映射到什么时候
So remind me, what does the ID actually map to when

751
00:39:04,960 --> 00:39:07,700
我们要把瓷砖画到屏幕上吗？
we're you drawing tiles to the screen?

752
00:39:07,700 --> 00:39:11,178
如果我们想给一块瓷砖一个ID 那是什么 它应该映射到什么？
If we want to give a tile an ID, what does that, what should that map to?

753
00:39:11,178 --> 00:39:12,146
嗯?
Yeah?

754
00:39:12,146 --> 00:39:14,570
观众：精灵纸上的画框 
AUDIENCE: The frame in the sprite sheet.

755
00:39:14,570 --> 00:39:17,590
科尔顿·奥格登：精灵图中的画框 没错 
COLTON OGDEN: The frame in the sprite sheet, that's correct.

756
00:39:17,590 --> 00:39:20,770
并不是所有的游戏引擎、所有的实现都必须如此 
It doesn't have to for all game engines, for all implementations.

757
00:39:20,770 --> 00:39:24,580
但这是最容易做的事情 只需给您的切片一个ID
But it's the easiest thing to do, is just to give your tile an ID

758
00:39:24,580 --> 00:39:26,740
然后你就可以画出来 你可以编制索引
that you can then just draw, you can index

759
00:39:26,740 --> 00:39:29,560
在你的精灵单子上用那个ID 
into your sprite sheet at that ID.

760
00:39:29,560 --> 00:39:32,680
这是一种非常、非常简单、轻巧、干净的建模方法 
It's just very, very simple, lightweight clean approach to modeling.

761
00:39:32,680 --> 00:39:36,250
我们可以在这里看到 ID得到了ID 
And we can see here, ID gets ID.

762
00:39:36,250 --> 00:39:39,520
在我们弄清楚我们想要什么ID之后 现在如何
After we've figured out what ID we want, now how

763
00:39:39,520 --> 00:39:43,030
我们是不是决定了 比如说我想画--
do we determine like let's say I want to draw--

764
00:39:49,430 --> 00:39:52,736
比方说 就像这块瓷砖 
let's say, for example, like this tile here.

765
00:39:52,736 --> 00:39:56,660
请注意 这是一块角瓷砖 
Notice it's a corner tile.

766
00:39:56,660 --> 00:39:59,080
我需要做什么才能基本上分配--
What do I need to do to basically assign--

767
00:39:59,080 --> 00:40:02,810
我甚至在有机会给你看之前就要死了 
I'm going to die before I even have the chance to show you.

768
00:40:02,810 --> 00:40:08,020
在我躲避敌人的同时 如果我想画左上角 
While I avoid enemies, if I wanted to draw that top left corner,

769
00:40:08,020 --> 00:40:09,270
我要找的是什么？
what am I sort of looking for?

770
00:40:09,270 --> 00:40:12,620
不管怎么说 我还在承受损失 
I'm still taking damage anyway.

771
00:40:12,620 --> 00:40:14,480
相对于x和y 我要找的是什么？
Relative to x and y, what am I looking for?

772
00:40:17,770 --> 00:40:21,300
假设那块瓷砖需要多少x和y
What x and y does that tile need, assuming

773
00:40:21,300 --> 00:40:24,240
一切从左上角的1.1开始 然后向下
everything starts 1.1 on the top left, and goes down

774
00:40:24,240 --> 00:40:27,257
整个地牢的高度和宽度？
to height and width of the overall dungeon?

775
00:40:27,257 --> 00:40:29,340
左上角的XY需要是什么？
What is the xy need to be of that top left corner?

776
00:40:33,920 --> 00:40:35,060
它应该是1 对吗？
It needs to be 1, right?

777
00:40:35,060 --> 00:40:38,060
所以如果是1.1 基本上就是左上角 
So if that's 1.1, basically the top left corner,

778
00:40:38,060 --> 00:40:41,080
该ID应等于角子画面 
that ID should be equal to the corner sprite.

779
00:40:41,080 --> 00:40:42,815
特别是左上角的精灵 
The top left corner sprite, specifically.

780
00:40:42,815 --> 00:40:44,440
那右上角的精灵呢？
What about the top right corner sprite?

781
00:40:47,295 --> 00:40:48,170
X应该是多少？
What should the x be?

782
00:40:50,920 --> 00:40:51,595
抱歉的?
Sorry?

783
00:40:51,595 --> 00:40:52,010
观众：宽度 
AUDIENCE: Width.

784
00:40:52,010 --> 00:40:52,850
科尔顿·奥格登：是的 宽度 
COLTON OGDEN: Yes, width.

785
00:40:52,850 --> 00:40:53,370
一点儿没错 
Exactly.

786
00:40:53,370 --> 00:40:56,000
Y是多少？
What's the y?

787
00:40:56,000 --> 00:40:56,890
仍然是1 
Still going to be 1.

788
00:40:56,890 --> 00:40:58,015
左下角呢？
What about the bottom left?

789
00:41:00,327 --> 00:41:01,160
宽度、逗号高度 
Width, comma height.

790
00:41:01,160 --> 00:41:02,243
然后是右下角？
And then the bottom right?

791
00:41:04,800 --> 00:41:08,560
观众：但这是[INAUDIBLE]
AUDIENCE: But it's [INAUDIBLE]

792
00:41:08,560 --> 00:41:11,270
科尔顿·奥格登：对不起 左下角应该是1 逗号高度 
COLTON OGDEN: Sorry, bottom left should be 1, comma height.

793
00:41:11,270 --> 00:41:16,310
右下角应为宽度、高度 
Bottom right should be width, height.

794
00:41:16,310 --> 00:41:20,390
所以基本上是检查每一块瓷砖的位置
And so basically checking the position of each tile

795
00:41:20,390 --> 00:41:24,721
是我们如何推断它的ID 这就是我们在源代码中所做的
is how we can infer its ID, which is what we're doing in the source code

796
00:41:24,721 --> 00:41:25,220
这里 
here.

797
00:41:25,220 --> 00:41:28,370
如果x是1 y是1 好的 左上角 
If x is 1 and y is 1, OK, top left corner.

798
00:41:28,370 --> 00:41:30,590
注意 我们已经将它们放入常量中 
And notice that we've put these into constants,

799
00:41:30,590 --> 00:41:33,380
我们放在常量.lua中 只是为了可读性 
that we've put in the constant.lua, just for readability.

800
00:41:33,380 --> 00:41:37,100
所以我们可以立即看到OK 我应该将ID磁贴设置在左上方
So we can instantly see OK, I should set ID tile top left

801
00:41:37,100 --> 00:41:40,820
角 而不是某个任意的数字 这是我们对瓷砖的索引 
corner, not some arbitrary number that's our index into the tile sheet.

802
00:41:40,820 --> 00:41:43,370
大概40多岁 或者其他什么年龄 
At maybe like 40 something, or whatever it is.

803
00:41:43,370 --> 00:41:46,820
左下角是1和高度 
Bottom left is 1 and height.

804
00:41:46,820 --> 00:41:53,280
右上角是宽度和1 然后右下角是宽度和高度 
Top right is width and 1, and then bottom right is width and height.

805
00:41:53,280 --> 00:41:54,560
我们可以看到 它是可读的 
And we can see, it's readable.

806
00:41:54,560 --> 00:41:57,684
我们可以一目了然地看到我们在做什么 你有条件地在哪里
We can sort of see at a glance what we're doing, where you're conditionally

807
00:41:57,684 --> 00:41:58,970
生成我们所有的瓷砖 
generating all of our tiles.

808
00:42:02,480 --> 00:42:09,890
如果这些都不是真的 那么x是1 那么这个瓦片是什么？
If none of those are true, and then x is 1, what's that tile?

809
00:42:09,890 --> 00:42:11,450
如果x是1 但它不是一个角？
If x is 1, but it's not a corner?

810
00:42:19,230 --> 00:42:20,950
这是一面左手边的墙 
It's a left hand wall.

811
00:42:20,950 --> 00:42:24,450
同样的事情是 如果它是宽度 它就是右手边的墙 
And the same thing is if it's the width, it's a right hand wall.

812
00:42:24,450 --> 00:42:27,300
如果y是1 它就是一面墙 
And if y is 1, it's a top wall.

813
00:42:27,300 --> 00:42:29,580
如果y是高度 那么它就是底部的墙 
If y is height, it's a bottom wall.

814
00:42:29,580 --> 00:42:36,240
如果不是这些 那就一定是一层楼 
And then if it's none of those, it's got to be a floor, exactly.

815
00:42:36,240 --> 00:42:39,060
所以这基本上就是我们如何产生整体的--
So that's basically how we generate the overall--

816
00:42:39,060 --> 00:42:43,770
这是一个非常简单的生成算法 
it's a very easy, simple generation algorithm.

817
00:42:43,770 --> 00:42:48,180
我在这里所做的是随机化 
What I've done is for randomization here,

818
00:42:48,180 --> 00:42:52,860
我们实际上有一张桌子 上面有潜在的左墙 潜在的右墙 
we have actually a table of potential left walls, potential right walls,

819
00:42:52,860 --> 00:42:54,240
潜在的顶部和底部 
potential top and bottom.

820
00:42:54,240 --> 00:42:58,500
然后我们只需在其中指定一个随机值 
And then we just ascribe it a random value within there,

821
00:42:58,500 --> 00:43:00,300
基于它的规模有多大 
based on however large that is.

822
00:43:00,300 --> 00:43:02,700
这给了我们变量 我们可以看到它 
And that gives us variable, we can see it.

823
00:43:02,700 --> 00:43:06,630
我们有随机性--每次我产生它 
We have random-- every time I generate it.

824
00:43:06,630 --> 00:43:08,894
所以请注意视觉上的一些瓷砖
So take note of maybe some of the tiles visually

825
00:43:08,894 --> 00:43:10,310
你可以在地图上看到 
that you can see there on the map.

826
00:43:13,750 --> 00:43:15,200
请注意 它们会发生变化 
Notice that they change.

827
00:43:15,200 --> 00:43:18,270
请注意 交换机也已更改 
Notice that the switch has also changed.

828
00:43:18,270 --> 00:43:19,780
请注意 它们再次更改 
Notice that they changed again.

829
00:43:19,780 --> 00:43:21,230
因此 一切都是可变的 
So everything is variable.

830
00:43:21,230 --> 00:43:22,380
我们有一点视觉上的多样性 
We have a little bit of visual variety.

831
00:43:22,380 --> 00:43:24,254
基本上 这就是我们对马里奥所做的 
This is what we did, essentially, with Mario.

832
00:43:24,254 --> 00:43:26,594
我们换了瓷砖套装和顶层套装 
We changed the tile set, and the topper set.

833
00:43:26,594 --> 00:43:29,010
只是现在我们只是在改变 我们只有一张瓷砖 
Only now we're just changing, we have only one tile sheet,

834
00:43:29,010 --> 00:43:31,470
但在同一块瓷砖上有几种不同的变化 
but several variations at the same tile they're in.

835
00:43:31,470 --> 00:43:34,560
所以我们所要做的就是随机选择任何瓷砖的变体 
So all we need to do is pick a random variation of whatever tile.

836
00:43:34,560 --> 00:43:36,870
这涉及到我们查看精灵薄片 
And that involves us looking at the sprite sheet,

837
00:43:36,870 --> 00:43:40,890
挑选出哪些单独的瓷砖 哪些瓷砖分开 
picking out which individual tiles, which separate tiles,

838
00:43:40,890 --> 00:43:45,780
映射到特定类型的切片 然后只需选取一个随机值
map to the specific type of tile, and then just picking a random value

839
00:43:45,780 --> 00:43:47,580
从那张桌子上
from that table

840
00:43:47,580 --> 00:43:49,210
这就是它的工作原理 
That's how that works.

841
00:43:49,210 --> 00:43:54,570
所以 我认为 有几件事需要向亲人展示
So a couple of things, I think, left to show relative

842
00:43:54,570 --> 00:43:56,510
敬地牢一代 
to the dungeon generation.

843
00:43:56,510 --> 00:44:02,010
因此 我们已经生成了48个实体 
So 48, we have generate entities.

844
00:44:02,010 --> 00:44:04,950
因此 实体在这里 
So entities are here.

845
00:44:04,950 --> 00:44:07,800
我们知道他们的名字 对吧？
We have their names, right?

846
00:44:07,800 --> 00:44:12,930
我们看到的一些实体 骷髅 蝙蝠 粘液 鬼魂 蜘蛛 
Some of the entities we saw, skeletons, bats, slimes, ghosts, spiders.

847
00:44:12,930 --> 00:44:16,560
这是一个非常轻量级的功能 
It's a very lightweight function.

848
00:44:16,560 --> 00:44:19,380
它不像15或20行 但我们正在生成
It's not like 15 or 20 lines, but we're generating

849
00:44:19,380 --> 00:44:21,780
a bunch束of different不同kinds种类of entities实体.
a bunch of different kinds of entities.

850
00:44:21,780 --> 00:44:24,900
因为我们所做的 我们基本上
Because what we've done, we take, we basically

851
00:44:24,900 --> 00:44:27,270
从表中随机选择一种类型 
take a random type from that table.

852
00:44:27,270 --> 00:44:30,930
我们创建一个实体 然后使用我们所拥有的
We create an entity, and then using what we've

853
00:44:30,930 --> 00:44:34,740
定义在一个叫做实体定义的全局表中 
defined in a global table called Entity Defs,

854
00:44:34,740 --> 00:44:37,980
我们把重要的东西
we take out what sort of matters in terms

855
00:44:37,980 --> 00:44:41,490
每一个个体的产生 其特征 
of generating each individual entity, the characteristics thereof,

856
00:44:41,490 --> 00:44:43,620
我们把它转换成简单的数据形式 
and we just put it in simple data form.

857
00:44:43,620 --> 00:44:49,530
这有点像游戏的数据驱动设计 
This is sort of like the segue into data driven design for your game.

858
00:44:49,530 --> 00:44:54,990
如果你看这里的实体定义 我们可以看到所有的实体
If you look at Entity Defs here, we can just see that all of our entities

859
00:44:54,990 --> 00:44:56,730
是一系列数据 
are a sequence of data.

860
00:44:56,730 --> 00:44:59,490
这里有一个参与人 在第10行.
So up here we have player, on line 10.

861
00:44:59,490 --> 00:45:01,140
玩家得到一张桌子 
Player gets a table.

862
00:45:01,140 --> 00:45:02,670
我们给他步行速度 
We give him walk speed.

863
00:45:02,670 --> 00:45:04,590
我们有一个动画表 
We have a table of animations.

864
00:45:04,590 --> 00:45:07,020
所以他有一个向左走的动画 一个向右走的动画 
So he's got a walk left animation, a walk right animation,

865
00:45:07,020 --> 00:45:08,550
走下动画 
a walk down animation.

866
00:45:08,550 --> 00:45:11,840
所有这些都有它们的框架 它们的间隔 它们的纹理 一切
All of those have their frames, their interval, their texture, everything

867
00:45:11,840 --> 00:45:14,850
就是干净的数据对吧
is just clean data, right?

868
00:45:14,850 --> 00:45:16,740
这里没有逻辑 真的 
There's no logic here, really.

869
00:45:16,740 --> 00:45:20,430
只是一些标志 或者值 简单的东西 
It's just flags, or values, simple things.

870
00:45:20,430 --> 00:45:25,380
你可以给任何对我们的基本知识有一定了解的人
You could give anybody who has sort of the basic knowledge of what we're

871
00:45:25,380 --> 00:45:29,470
做这个文件 也许还有一些纹理 然后说 嘿 
doing this file, and maybe some textures, and say, hey,

872
00:45:29,470 --> 00:45:30,840
我想让你设计
I want you to design--

873
00:45:30,840 --> 00:45:33,150
我要你把所有的东西
I want you to lay out basically all of that's

874
00:45:33,150 --> 00:45:38,220
参与了骨架在屏幕上的渲染 
involved in what makes a skeleton render to the screen.

875
00:45:38,220 --> 00:45:40,770
为他们制作所有的动画 
Create all the animations for them.

876
00:45:40,770 --> 00:45:43,530
给这些动画计时 
Give those animations their timing.

877
00:45:43,530 --> 00:45:44,900
给他们准确的框架 
Give them the exact frames.

878
00:45:44,900 --> 00:45:48,600
也许骨架应该有健康值 也许健康值应该等于10
Maybe skeletons should have health, and maybe health should be equal to 10

879
00:45:48,600 --> 00:45:50,620
在一具骨架上 或者类似的东西上 
on a skeleton, or something like that.

880
00:45:50,620 --> 00:45:53,484
实际上这里没有任何编程 
There's not really any programming going on here.

881
00:45:53,484 --> 00:45:55,650
但我们把游戏中的一切都描述成数据 
But we're describing everything in our game as data.

882
00:45:55,650 --> 00:46:01,500
这在复杂的游戏中是很重要的 因为游戏系统相当复杂 
And that's important thing in complex games that have fairly complex systems,

883
00:46:01,500 --> 00:46:04,440
但是可以通过一些属性来建模 
but that can be modeled via some attributes.

884
00:46:04,440 --> 00:46:07,890
您可以只归属于实体和数据 然后让引擎解析
You can just ascribe your entities and data, and then let your engine parse

885
00:46:07,890 --> 00:46:12,720
此信息 然后以编程方式创建您的实体 
this information, and then create your entities programmatically.

886
00:46:12,720 --> 00:46:17,400
稍微把负担从程序员转移到设计者身上 
You shift the burden from the programmer to the designer, a little bit.

887
00:46:17,400 --> 00:46:21,540
你请得起你的设计团队 你 也许还有其他人
And you afford your design team, you and maybe other people

888
00:46:21,540 --> 00:46:23,400
对编程不太熟悉的人 
who aren't as comfortable with programming,

889
00:46:23,400 --> 00:46:27,326
能够修改游戏引擎 向游戏中添加内容 
the ability to modify the game engine, add things to the game,

890
00:46:27,326 --> 00:46:29,700
而不必查看大量的引擎代码
without having to go through the bulk of your engine code

891
00:46:29,700 --> 00:46:31,107
做任何太花哨的事 
and do anything too fancy.

892
00:46:31,107 --> 00:46:32,190
在这种情况下 它很简单 
In this case, it's simple.

893
00:46:32,190 --> 00:46:37,662
我们所做的只是创建动画 并指定一个纹理
All we're doing is just we're creating animations, and assigning a texture

894
00:46:37,662 --> 00:46:39,120
这些个体中的每一种 
to each of these individual things.

895
00:46:39,120 --> 00:46:41,340
但我上周曾暗示过这一点 
But I alluded to this last week.

896
00:46:41,340 --> 00:46:44,190
你可以有一个文件 它可能描述了一些类似地精的东西 
You can have a file that maybe describes something like a goblin.

897
00:46:44,190 --> 00:46:47,280
我们会在一堂课的最后看到这一点 它可能像一面旗帜
We'll see this at the end of a lecture, which has maybe like a flag

898
00:46:47,280 --> 00:46:48,412
因为它是易燃的吗？
for is it flammable?

899
00:46:48,412 --> 00:46:49,620
它的生命力有多强？
How much health does it have?

900
00:46:49,620 --> 00:46:51,510
它的动画是什么？
What are its animations?

901
00:46:51,510 --> 00:46:53,516
它有什么技能？
What skills does it have?

902
00:46:53,516 --> 00:46:54,640
它的进攻强度有多大？
What's its attack strength?

903
00:46:54,640 --> 00:46:55,470
它的辩护理由是什么？
What's its defense?

904
00:46:55,470 --> 00:46:58,232
它通常在哪里产卵？
Where does it spawn typically?

905
00:46:58,232 --> 00:47:01,440
通过将所有这些属性放在一起并让您的引擎进行某种解析
By putting all these attributes together and having your engine sort of parse

906
00:47:01,440 --> 00:47:04,950
这个 你可以创建 取决于你有多少个字段 
this, you can create, depending on how many fields you have,

907
00:47:04,950 --> 00:47:12,169
你可以在你的游戏中创建非常复杂的潜在清单 
you can create very complex potential list of things in your game.

908
00:47:12,169 --> 00:47:15,210
无论他们是实体 无论是武器 还是物品 
Whether they're entities, whether they're weapons, whether they're items,

909
00:47:15,210 --> 00:47:16,135
超能力 
abilities.

910
00:47:16,135 --> 00:47:17,010
任何你想做的事 
Anything you want to.

911
00:47:17,010 --> 00:47:20,970
不管它们是不是水平 
Whether they're levels, even.

912
00:47:20,970 --> 00:47:23,020
仅仅基于数据 
Based solely on just data.

913
00:47:23,020 --> 00:47:26,800
因此 这是设计和开发的圣杯
So this is a holy grail of design and development

914
00:47:26,800 --> 00:47:30,180
当你进入像RPG这样特别复杂的游戏时 
when you get into especially very complex games like RPGs,

915
00:47:30,180 --> 00:47:34,647
在那里你可以拥有具有粒子效果的技能
where you can have skills that have particle effects

916
00:47:34,647 --> 00:47:36,480
对不同的东西造成不同的伤害 
and do different damage to different things.

917
00:47:36,480 --> 00:47:39,600
你有一些实体--也许你想让它们被烧毁 
And you have entities that are-- maybe you want them some to set on fire,

918
00:47:39,600 --> 00:47:40,620
有些人会触电身亡 
some to be electrocuted.

919
00:47:40,620 --> 00:47:41,760
也许有些你不知道 
Maybe some you don't.

920
00:47:41,760 --> 00:47:45,570
也许当他们接触到什么东西时 一些会融化 
Maybe some melt when they touch something.

921
00:47:45,570 --> 00:47:47,670
创建一串旗帜 创建一个函数
Create a bunch of flags, create a function

922
00:47:47,670 --> 00:47:50,970
它对此进行解析 并生成结果实体 
that parses this, and generates entities as a result.

923
00:47:50,970 --> 00:47:55,710
你只需要让你自己的工作效率得到令人难以置信的提升 
And you just allow yourself an incredible boost in productivity.

924
00:47:55,710 --> 00:48:02,650
您不再需要创建蜘蛛类、幽灵类、蝙蝠类 
No longer do you need to create a spider class, a ghost class, a bat class.

925
00:48:02,650 --> 00:48:04,110
这都是不必要的 
It's all unnecessary.

926
00:48:04,110 --> 00:48:07,854
你所需要做的就是定义蝙蝠有哪些属性？
All you need to do is define what sort of attributes does a bat have?

927
00:48:07,854 --> 00:48:09,270
幽灵有什么属性？
What attributes does a ghost have?

928
00:48:09,270 --> 00:48:12,030
骨架有哪些属性？
What attributes does a skeleton have?

929
00:48:12,030 --> 00:48:16,460
因此 任何人都可以因此修改您的游戏 
And anybody can therefore mod your game as a result of this.

930
00:48:16,460 --> 00:48:20,360
他们所需要做的就是知道一个潜在实体可以具有哪些属性 
All they need to do is know what attributes a potential entity can have.

931
00:48:20,360 --> 00:48:24,330
因此 您的设计团队的工作效率会更高 
And your design team is all the more productive as a result.

932
00:48:24,330 --> 00:48:28,580
所以这就是为什么这是一个相关的说辞 
So that's a spiel on why this is relevant.

933
00:48:28,580 --> 00:48:30,560
我们已经实现了一个非常基本的版本
We've implemented a very basic version of this

934
00:48:30,560 --> 00:48:33,120
只是为了制作动画模型 
just for the sake of modeling animations.

935
00:48:33,120 --> 00:48:36,751
但我们不需要为游戏中的所有不同实体创建单独的类
But we don't need a separate class for all the different entities in our game

936
00:48:36,751 --> 00:48:37,250
世界 
world.

937
00:48:37,250 --> 00:48:41,180
我们只需要 基本上 在这个游戏的背景下 
We just need, basically, and in the context of this game,

938
00:48:41,180 --> 00:48:43,640
他们的动画是什么？
what are their animations?

939
00:48:43,640 --> 00:48:46,490
这就是实体定义 这就是它的工作方式 如果我们
So that's entity defs, that's how it's working if we're

940
00:48:46,490 --> 00:48:51,450
看看第48行的room.lua 
looking at room.lua at line 48.

941
00:48:51,450 --> 00:48:53,510
它所做的一切就是制作动画 
All its doing is getting animations.

942
00:48:53,510 --> 00:48:56,840
顺便说一句 这是您的函数 它接受这些定义
This is, by the way, your function that takes in these definitions

943
00:48:56,840 --> 00:48:58,670
并创建你的实体 
and creates your entities.

944
00:48:58,670 --> 00:49:00,560
他们应该寻找--
They should be looking for--

945
00:49:00,560 --> 00:49:01,790
正在调查这件事 
looking into that.

946
00:49:01,790 --> 00:49:03,920
他们提取该定义 然后解析出
They pull that definition and then just parse out

947
00:49:03,920 --> 00:49:07,100
每一条相关的数据 
each individual relevant piece of data.

948
00:49:07,100 --> 00:49:09,980
然后只需构建一些相关信息
And then just construct some relevant information

949
00:49:09,980 --> 00:49:13,640
或将相关标志附加到该实体 以便您的游戏引擎稍后可以
or attach a relevant flag to that entity that your game engine can then later

950
00:49:13,640 --> 00:49:15,560
解析 
parse.

951
00:49:15,560 --> 00:49:19,850
举个易燃的例子 如果你进行攻击 而攻击是火力类型的 
The flammable example, if you do an attack and that attack is of type fire,

952
00:49:19,850 --> 00:49:24,410
它与一个实体相撞 这个实体 易燃是真的 
and it collides with an entity, and that entity.flammable is true,

953
00:49:24,410 --> 00:49:25,940
这应该会引发一些行为 
that should trigger some behavior.

954
00:49:25,940 --> 00:49:28,065
但你不需要做任何非常复杂的事情 
But you don't need to do anything terribly complex.

955
00:49:28,065 --> 00:49:33,420
此后 您可以将其分配给任何任意实体 
And you can assign this to any arbitrary entity thereafter.

956
00:49:33,420 --> 00:49:37,910
所以 这只是一种简单的方法来获取游戏中非常复杂的行为
So just a simple way of getting very complex behavior for your game

957
00:49:37,910 --> 00:49:40,520
对象 实体 任何你想要的东西 
objects, entities, whatever you want.

958
00:49:40,520 --> 00:49:45,980
将它们建模为数据 而不是从类的角度考虑 
Modeling them as data rather than thinking about it in terms of classes.

959
00:49:45,980 --> 00:49:47,060
就是这样 
So that's that.

960
00:49:47,060 --> 00:49:49,768
有没有人有任何问题 比如它是如何工作的 
Does anybody have any questions just like sort of how that works,

961
00:49:49,768 --> 00:49:50,889
或者为什么它是可行的？
or why it's viable?

962
00:49:50,889 --> 00:49:51,680
或者为什么它有用？
Or why it's useful?

963
00:49:55,550 --> 00:49:56,897
好的 
OK.

964
00:49:56,897 --> 00:49:59,230
最后几件事 我们会在房间里快速看一看 
Couple of last things we'll look at really fast in room.

965
00:49:59,230 --> 00:50:02,680
所以上网82 
So online 82.

966
00:50:02,680 --> 00:50:04,060
生成对象 
Generate objects.

967
00:50:04,060 --> 00:50:07,510
所以我们上周做了非常非常相似的事情 
So we did this very, very similarly last week.

968
00:50:07,510 --> 00:50:09,990
在那里我们刚刚有了一个游戏对象类 
Where we just had a game object class.

969
00:50:09,990 --> 00:50:13,660
请注意 它本身就是一个交换机的定义 
Notice that it takes itself a definition for a switch.

970
00:50:13,660 --> 00:50:17,040
这个定义在游戏对象.lua中 
That definition is in gameobjects.lua.

971
00:50:17,040 --> 00:50:18,380
换个位置 
Switch.

972
00:50:18,380 --> 00:50:22,140
这是一种更类似于开关的数据建模 
Here's a little bit more sort of data modeling something like a switch.

973
00:50:22,140 --> 00:50:27,820
它有一种类型的开关 默认的帧是2 所以宽度和高度都是16 
It's got a type of switch, frame is 2 by default. So width and height of 16.

974
00:50:27,820 --> 00:50:28,720
它并不结实 
It's not solid.

975
00:50:28,720 --> 00:50:30,280
玩家可以走过去 
Player can walk over it.

976
00:50:30,280 --> 00:50:31,930
其默认状态为抑制 
Its default state is upressed.

977
00:50:31,930 --> 00:50:34,840
因此 当它被催生到游戏中时 它是不受压力的 
So when it gets spawned into the game, it's unpressed.

978
00:50:34,840 --> 00:50:37,960
它有两种潜在的状态 史无前例的和紧迫的 
And it's got two potential states, unprecedented and pressed.

979
00:50:37,960 --> 00:50:39,940
这些州中的每一个都有一个框架 
And each of those states have a frame.

980
00:50:39,940 --> 00:50:43,330
所以我们要做的就是呈现它 它的当前状态是什么？
So all we need to do to render it is say, what's its current state?

981
00:50:43,330 --> 00:50:45,380
呈现此状态 帧 
Render this state.frame.

982
00:50:45,380 --> 00:50:47,260
然后现在 我们不需要做任何事情--
And then now, we don't need to do anything--

983
00:50:47,260 --> 00:50:50,590
这基本上就是我们所需要做的 以便在正确的点上呈现它 
that's basically all we need to do in order to render it at the right point.

984
00:50:50,590 --> 00:50:54,010
因此 您的游戏引擎需要查看对象 
Your game engine, therefore, needs to look at your object,

985
00:50:54,010 --> 00:50:59,290
并查看其状态和潜在状态 索引到该状态
and look at its state and look at its potential states, index into that state

986
00:50:59,290 --> 00:51:02,709
然后从那里拉出框架 
and then pull the frame from that.

987
00:51:02,709 --> 00:51:04,750
但它为你提供了一种无限的灵活性 
But it forwards you sort of infinite flexibility.

988
00:51:04,750 --> 00:51:09,010
你现在可以有一个发光的状态 
You can now have maybe of a glowing state,

989
00:51:09,010 --> 00:51:12,744
也许在那张精灵纸上有一个框架让它发光 
and maybe there's a frame in that sprite sheet that allows it to glow.

990
00:51:12,744 --> 00:51:15,160
你可以随时随地把它换成发光 
And you could just change it to glowing whenever you want,

991
00:51:15,160 --> 00:51:17,080
它会恰到好处地渲染 
and it'll just render appropriately.

992
00:51:17,080 --> 00:51:22,610
所以对数据建模的方法非常灵活 
So very flexible approach to modeling data.

993
00:51:22,610 --> 00:51:24,100
房间有149个房间 
149 in room.

994
00:51:24,100 --> 00:51:25,960
所以我们快完成这里的地牢了 
So we're almost done with the dungeon here.

995
00:51:25,960 --> 00:51:30,760
所以149是我们的更新功能 
So 149 is our update function.

996
00:51:30,760 --> 00:51:34,180
它所做的基本上就是遍历所有内容
All it does basically is iterate through everything

997
00:51:34,180 --> 00:51:38,990
并更新它 基本上包括所有实体 
and update it, including basically all the entities.

998
00:51:38,990 --> 00:51:45,670
所以对于每个实体来说 如果它的生命值小于或等于0 它就是死的 
So for every entity if its health is less than or equal to 0, it's dead.

999
00:51:45,670 --> 00:51:50,630
如果它是死的 那么不要渲染它 我们在渲染中看到了这一点 
If it's dead, then don't render it, which we see down in render.

1000
00:51:50,630 --> 00:51:57,510
但如果它没有死 而且玩家自己撞到了它 
But if it's not dead, and self.player player collides with it,

1001
00:51:57,510 --> 00:52:01,930
而且玩家并不脆弱 那么我们就应该伤害玩家 
and the player's not vulnerable, then we should damage the player,

1002
00:52:01,930 --> 00:52:03,370
变得无懈可击 
go invulnerable.

1003
00:52:03,370 --> 00:52:06,110
如果玩家的健康状况为零 则切换到游戏结束 
And if the player's health is zero, change to game over.

1004
00:52:06,110 --> 00:52:09,070
所以请注意这是多么的可读性 
So notice how readable this is.

1005
00:52:09,070 --> 00:52:12,970
当您也像这样对实体建模时 您真正需要做的就是
When you model your entities like this as well, all you really need to do

1006
00:52:12,970 --> 00:52:15,160
只是检查某些标志或函数 
is just check for certain flags or functions,

1007
00:52:15,160 --> 00:52:18,190
你可以像这样做任意复杂的测试 
and you can do arbitrarily complex tests like this.

1008
00:52:18,190 --> 00:52:20,500
因为实体可能是死的 也可能不是 
Because entities can be dead, or not.

1009
00:52:20,500 --> 00:52:23,800
因为实体可以是无懈可击的 也可以不是 
Because entities can be invulnerable, or not.

1010
00:52:23,800 --> 00:52:28,690
然后因为实体都是XY的 在我们的游戏中基于高度的东西 
And then because entities are all xy, with height based things in our game,

1011
00:52:28,690 --> 00:52:32,440
而碰撞只是希望他们拥有这一点 
and collide just expects them to have that.

1012
00:52:32,440 --> 00:52:35,800
我们所做的只是播放声音 伤害玩家 
All we just do is play sound, damage the player.

1013
00:52:35,800 --> 00:52:38,160
伤害在即刻会造成什么影响？
What does damage do offhand?

1014
00:52:38,160 --> 00:52:39,265
你觉得它能做什么？
What do you think it does?

1015
00:52:39,265 --> 00:52:41,740
观众：我会胡乱猜测 然后说减去你的健康 
AUDIENCE: I'll take a wild guess and say subtracts from your health.

1016
00:52:41,740 --> 00:52:42,440
科尔顿·奥格登：没错 
COLTON OGDEN: Exactly.

1017
00:52:42,440 --> 00:52:44,190
随便猜一猜 就会说它有损健康 
Just take a wild guess and say it subtracts from health.

1018
00:52:44,190 --> 00:52:44,950
确实如此 
It does.

1019
00:52:44,950 --> 00:52:49,330
所以实体伤害只是一个数字 然后从生命值中减去这个数字 
So entity damage just takes in a number, and subtracts that from health.

1020
00:52:49,330 --> 00:52:50,440
这就是它的全部功能 
That's all it does.

1021
00:52:50,440 --> 00:52:51,250
变得无懈可击 
Go invulnerable.

1022
00:52:51,250 --> 00:52:52,000
那是做什么的 
What does that do.

1023
00:52:53,724 --> 00:52:56,390
观众：这意味着你已经遭受了那么多秒的伤害？
AUDIENCE: Means you've been taking damage for that many seconds?

1024
00:52:56,390 --> 00:52:57,306
科尔顿·奥格登：的确如此 
COLTON OGDEN: It does.

1025
00:52:57,306 --> 00:52:59,890
它可以防止你在那么长的时间内受到伤害 
It prevents you from taking damage for that many seconds.

1026
00:52:59,890 --> 00:53:04,990
所有这些实际上只是设置了一个标志 我已经提到了很多
All that really does is just set a flag, which I've alluded to quite a bit

1027
00:53:04,990 --> 00:53:09,610
已经是一个任意的标志 您可以通过数据或其他方式进行建模 
already, an arbitrary flag that you can model via data or some other means.

1028
00:53:09,610 --> 00:53:11,770
每个实体都有一面坚不可摧的旗帜 
Every entity has an invulnerable flag.

1029
00:53:11,770 --> 00:53:14,920
如果它是无懈可击的 那么引擎应该寻找它 
And if it's invulnerable, then the engine should look for that,

1030
00:53:14,920 --> 00:53:19,940
并相应地更改渲染和实体的机制 
and change the rendering, and the mechanics of the entity accordingly.

1031
00:53:19,940 --> 00:53:22,990
最后这里 很简单 如果玩家的健康等于0 
And then lastly here, just simple if the player health is equal to 0,

1032
00:53:22,990 --> 00:53:27,040
这可能是在我们受到足够的伤害后 更改为游戏结束 
which it might be after we take sufficient damage, change to Game Over.

1033
00:53:27,040 --> 00:53:28,210
这就是它的全部功能 
That's all it does.

1034
00:53:28,210 --> 00:53:33,280
然后 对于每个对象 就像我们对每个实体所做的那样 更新对象
And then for every object, just as we do with every entity, update the object

1035
00:53:33,280 --> 00:53:37,450
如果玩家与其相撞 则触发其碰撞功能 
and if the player collides with it, then trigger its On Collide function.

1036
00:53:37,450 --> 00:53:40,667
这可以是你任意创建的函数 
And this can be a function that you arbitrarily create,

1037
00:53:40,667 --> 00:53:42,250
取决于您的对象的需求 
depending on the needs of your object.

1038
00:53:44,920 --> 00:53:48,550
例如 如果你抬头看这里 每次我们创建一个房间 
If you look up here, for example, every time we create a room,

1039
00:53:48,550 --> 00:53:51,400
我们在房间里生成对象 
we generate objects in the room.

1040
00:53:51,400 --> 00:53:55,570
我们在对象中插入了一个开关 这是我们在前面看到的 在gameobjects.lua中 
We insert into objects a switch, which we saw before, in gameobjects.lua.

1041
00:53:55,570 --> 00:53:57,830
取x和y 
And takes an x and a y.

1042
00:53:57,830 --> 00:53:59,830
在这种情况下 我们只需确保x和y
In this case, we just make sure that the x and y

1043
00:53:59,830 --> 00:54:01,950
是地图左上角之间的一个随机数
is a random number between the top left of the map

1044
00:54:01,950 --> 00:54:06,610
和地图的右下角 在它所具有的填充内 
and the bottom right of the map, within the padding that it has.

1045
00:54:06,610 --> 00:54:09,200
我们得到了对该对象的引用 
We get a reference to that object.

1046
00:54:09,200 --> 00:54:11,930
然后定义了Are on Collide函数 
And then we define are On Collide function.

1047
00:54:11,930 --> 00:54:14,620
所以我们要做的就是说如果它被压制了 
So what we do is we say if it's upressed,

1048
00:54:14,620 --> 00:54:19,030
回想一下 我们在游戏对象定义中有一个状态 
so recall that we have a state in the game object definition.

1049
00:54:19,030 --> 00:54:21,810
如果是未熨烫的 就改成熨烫 
If it's unpressed, change it to pressed.

1050
00:54:21,810 --> 00:54:23,410
这就是我们真正需要做的 
It's all we really need to do.

1051
00:54:23,410 --> 00:54:26,410
然后注意这里 比如k 有一扇门 
And then notice here, for k, a doorway.

1052
00:54:26,410 --> 00:54:31,720
因此 对于每一扇门 无论是自己的门 都要把门敞开
So for every doorway in doorways, self.doorways, set that doorway open

1053
00:54:31,720 --> 00:54:33,460
是真的 
is true.

1054
00:54:33,460 --> 00:54:35,020
然后播放一声门声 
And then play a door sound.

1055
00:54:35,020 --> 00:54:38,260
所以我们的On Collide函数只是相互作用
So our On Collide function just interacts

1056
00:54:38,260 --> 00:54:41,080
与游戏世界中的其他东西 以及非常简单的东西
with other things in the game world, and just very simple things

1057
00:54:41,080 --> 00:54:46,180
但有一种非常有趣的机械师 
but has a pretty interesting sort of mechanic.

1058
00:54:46,180 --> 00:54:46,989
就像我们有一个...
Like we have a--

1059
00:54:46,989 --> 00:54:49,780
我从蝙蝠那里得到了伤害 因为我的产卵并不完美 
I took damage off the bat there, because my spawning isn't perfect.

1060
00:54:49,780 --> 00:54:55,250
但它从--请注意 它的状态从未按下更改
But it changed from-- notice that it changed its state from unpressed

1061
00:54:55,250 --> 00:54:56,310
按下 
to pressed.

1062
00:54:56,310 --> 00:54:57,995
因为它从唯一的精灵变成了--
Because it went from the one sprite to--

1063
00:54:57,995 --> 00:54:59,870
我去另一个房间 这样我们就能看到了 
I'll go into another room so we can see that.

1064
00:54:59,870 --> 00:55:01,050
我会在路上弄坏一些东西 
I'll take some damage on the way.

1065
00:55:01,050 --> 00:55:01,841
去另一个房间 
Go to another room.

1066
00:55:01,841 --> 00:55:03,180
请注意精灵 
Notice the sprite.

1067
00:55:03,180 --> 00:55:06,110
它看起来像是没有被压住的 对吗？
It sort of looks like it's unpressed, right?

1068
00:55:06,110 --> 00:55:08,520
因为游戏对象的默认状态是未按下的 
Because the game object's default state is unpressed.

1069
00:55:08,520 --> 00:55:13,050
然后当我在它上面的时候就会触发碰撞 
And then On Collide triggers when I go on top of it.

1070
00:55:13,050 --> 00:55:16,530
它会更改状态 这会对渲染的内容产生影响 
It changes state, which has an effect on what gets rendered.

1071
00:55:16,530 --> 00:55:18,960
它是关于Collide函数的调用 该函数
And it's On Collide function is called, which

1072
00:55:18,960 --> 00:55:21,210
把房间的每一扇门都打开了 
opened up every doorway in the room.

1073
00:55:21,210 --> 00:55:25,230
如此简单 就像15行代码 
So simple like 15 lines of code.

1074
00:55:25,230 --> 00:55:29,160
但为了我们的地牢 我们的行为很吸引人 很有趣 
But pretty compelling, interesting behavior for the sake of our dungeon.

1075
00:55:29,160 --> 00:55:31,310
就像 它增加了很多东西 就这么简单 
Like, it adds a lot, as simple as that is.

1076
00:55:31,310 --> 00:55:33,060
现在我们感觉就像是在互动
Now we sort of feel like we're interacting

1077
00:55:33,060 --> 00:55:35,400
和我们的游戏世界有一点关系 
with our game world a little bit.

1078
00:55:35,400 --> 00:55:38,970
这就是它的工作原理 
So that's how that works.

1079
00:55:38,970 --> 00:55:42,750
最后 在第188行上进行渲染 
And then lastly, rendering on line 188.

1080
00:55:42,750 --> 00:55:45,660
只需检查我们所有的瓷砖 渲染所有瓷砖 
Just go through all of our tiles, render all the tiles.

1081
00:55:45,660 --> 00:55:47,190
我们以前见过这种情况 
We've seen this before.

1082
00:55:47,190 --> 00:55:49,380
渲染所有的门口 渲染所有的物体 
Render all the doorways, render all the objects,

1083
00:55:49,380 --> 00:55:52,270
渲染所有实体 如果它们没有死的话 
render all the entities, if they're not dead.

1084
00:55:52,270 --> 00:55:52,770
对吗？
Right?

1085
00:55:52,770 --> 00:55:55,980
如果它们已经死了 那么就不要渲染它们 
If they're dead, then don't render them.

1086
00:55:55,980 --> 00:55:59,820
然后这一点 我们将看看结尾 这是模版 
And then this bit here, we'll take a look at the end, which is stenciling.

1087
00:55:59,820 --> 00:56:03,794
所以请注意当我走进门的时候 
So notice that when I walk through doors.

1088
00:56:03,794 --> 00:56:06,960
首先 请注意 如果门是关着的 我是不能走进去的 
Well first of all, notice that I can't walk through doors if they're closed,

1089
00:56:06,960 --> 00:56:07,751
这一点很重要 
which is important.

1090
00:56:07,751 --> 00:56:13,380
因此 当你与门口的物体碰撞时 如果Doorway.Open为False 
So when you collide with your doorway objects, if doorway.Open is false,

1091
00:56:13,380 --> 00:56:16,080
它不应该触发房间开关 对吗？
it shouldn't trigger the room switch, right?

1092
00:56:16,080 --> 00:56:19,440
但如果我打开门 它们现在都会被召回 
But if I open the doors they're now all set to recall.

1093
00:56:19,440 --> 00:56:21,120
Door.open现在等于True 
Door.open is now equal to true.

1094
00:56:21,120 --> 00:56:25,200
所以他们改变了他们的渲染 现在他们正在渲染开放的门口 
So they've changed their renderings, and now they're rendering open doorways.

1095
00:56:25,200 --> 00:56:27,960
如果我穿过它 注意到它看起来像是玩家走的
If I walk through it, notice that it looks as if the player walks

1096
00:56:27,960 --> 00:56:29,580
在瓷砖下面 
underneath the tiles.

1097
00:56:29,580 --> 00:56:33,480
但我是在玩家面前画牌 
But I'm drawing the tiles before the player.

1098
00:56:33,480 --> 00:56:38,430
还有一种你可能认为应该做的方法
And one approach that you might think to do

1099
00:56:38,430 --> 00:56:43,740
当创造出这种令人信服的行走外观时
when sort of creating this believable appearance of walking

1100
00:56:43,740 --> 00:56:45,420
穿过一扇门 就是说好 
through a doorway, is say OK.

1101
00:56:45,420 --> 00:56:51,130
我只会在渲染之后渲染播放器 然后再渲染门口 
I'll just render the player after I render before I render the doorways.

1102
00:56:51,130 --> 00:56:51,630
对吗？
Right?

1103
00:56:51,630 --> 00:56:53,670
所以最后渲染所有的门 
So render all the doorways last.

1104
00:56:53,670 --> 00:57:00,270
但这并不是很有效 因为精灵实际上就是从这里开始的 
But it doesn't quite work out, because the sprite actually starts right here.

1105
00:57:00,270 --> 00:57:02,880
所以有人会认为如果我是
So what does somebody think is going to happen if I were

1106
00:57:02,880 --> 00:57:07,340
在玩家身后画门口吗？
to draw the doorway after the player?

1107
00:57:07,340 --> 00:57:11,020
观众：如果你越过这条线或[INAUDIBLE] 你的默认玩家就会消失
AUDIENCE: Your default player disappears if you cross that line or [INAUDIBLE]

1108
00:57:11,020 --> 00:57:11,645
越过那条线 
over that line.

1109
00:57:11,645 --> 00:57:12,561
科尔顿·奥格登：没错 
COLTON OGDEN: Exactly.

1110
00:57:12,561 --> 00:57:15,840
球员一走到这一小段线就会消失 
The player would disappear as soon as he gets to this little bit of line right

1111
00:57:15,840 --> 00:57:17,298
在这里 这不是很有说服力 
here, which is not very convincing.

1112
00:57:17,298 --> 00:57:21,180
实际上 我现在就试着去掉模版 
And actually I'll try right now to take away the stenciling,

1113
00:57:21,180 --> 00:57:23,110
这样我们就能看到那是什么样子了 
so we can see what that looks like.

1114
00:57:23,110 --> 00:57:29,050
所以如果我去掉这里的模板 然后我只需要渲染 
So if I just take away the stenciling here, and then I just render.

1115
00:57:33,490 --> 00:57:36,030
今天不能打字 
Can't type today.

1116
00:57:36,030 --> 00:57:37,890
所以我要继续了 
So I'm going to go ahead.

1117
00:57:37,890 --> 00:57:38,500
那就去吧 
Do that.

1118
00:57:42,410 --> 00:57:47,530
首先 渲染顺序是这样的 现在门口渲染
Well, first of all, the rendering order is such that now the doorways render

1119
00:57:47,530 --> 00:57:49,120
在球员之前 
after before the player.

1120
00:57:49,120 --> 00:57:51,220
所以他就直接从他们身上走过去 对吗？
So he just walks right over them, right?

1121
00:57:51,220 --> 00:57:53,560
所以我只是在走 我是在跨过墙 
So I'm just walking, I was walking over the walls.

1122
00:57:53,560 --> 00:57:54,730
这并不令人信服 
That's not compelling.

1123
00:57:54,730 --> 00:57:58,970
如果我要做一些简单的事情 比如改变渲染顺序 
And if I were to do something as simple as change the rendering order.

1124
00:57:58,970 --> 00:58:00,990
因此 现在 门口首先进行渲染 
So right now, the doorways render first.

1125
00:58:00,990 --> 00:58:03,490
我将在玩家之后渲染门口 
I'll just render the doorways after the player.

1126
00:58:03,490 --> 00:58:09,137
所以就在这里 我把它拿出来了 对吗？
So right here, I took that out, right?

1127
00:58:09,137 --> 00:58:10,510
不是的 
No.

1128
00:58:10,510 --> 00:58:12,376
所以现在 他们在玩家面前进行渲染 
So right now, they render before the player.

1129
00:58:12,376 --> 00:58:14,000
我想按照玩家的名字来渲染它们 
I want to render them after the player.

1130
00:58:14,000 --> 00:58:18,100
我要把它运行起来 
And I'm going to just run it.

1131
00:58:18,100 --> 00:58:21,070
然后踩下开关 
And then going to step on the switch.

1132
00:58:21,070 --> 00:58:22,960
然后 是的 
And then, yep.

1133
00:58:22,960 --> 00:58:24,700
请注意 我们也会遇到一些奇怪的行为 
Notice we get some weird behavior, too.

1134
00:58:27,400 --> 00:58:32,170
就像看到他的头被砍掉一样？
Like sees his head is getting cut off?

1135
00:58:32,170 --> 00:58:36,790
以及其他实体也是如此 对吗？
And other entities as well, right?

1136
00:58:36,790 --> 00:58:39,550
在这种情况下 我真的看不出来 
In that case, I couldn't really tell.

1137
00:58:39,550 --> 00:58:41,830
不过 是的 
But yeah.

1138
00:58:41,830 --> 00:58:43,330
非常奇怪的撕裂行为 
Very weird rending behavior.

1139
00:58:43,330 --> 00:58:47,590
我们要做的就是创造一种被称为模板的东西 
And what we do to fix that is we create what's called a stencil.

1140
00:58:47,590 --> 00:58:51,490
因此 基本上我会尝试获得一个屏幕截图 我可以在这里展示 
So basically I'll try and get a screenshot here I can show.

1141
00:58:51,490 --> 00:58:55,880
首先 让我修改一下我刚才所做的更改 
First let me fix the changes that I just made.

1142
00:58:55,880 --> 00:58:57,230
正确的 
Right.

1143
00:58:57,230 --> 00:59:01,645
然后如果我回到这里的代码 
And then if I go back into the code here.

1144
00:59:01,645 --> 00:59:04,520
所以模板只是--我们稍后会看到一张幻灯片 
So a stencil is just-- and we'll see a slide on this in a little bit.

1145
00:59:04,520 --> 00:59:10,310
但模板基本上是任何类型的任意形状 
But a stencil is just basically any sort of arbitrary shape that want,

1146
00:59:10,310 --> 00:59:12,080
你画在屏幕上的 
that you draw onto the screen.

1147
00:59:12,080 --> 00:59:17,690
它是看不见的 但它决定了
It's invisible, but it determines whatever

1148
00:59:17,690 --> 00:59:20,330
在该模板上绘制 它确定是否
gets drawn on top of that stencil, it determines whether or not

1149
00:59:20,330 --> 00:59:21,830
那东西就会被渲染 
that thing gets rendered.

1150
00:59:21,830 --> 00:59:28,260
所以我有一个模板 基本上是从这里一直到下一个房间 
So I have a stencil going basically from here onwards to the next room.

1151
00:59:28,260 --> 00:59:30,344
所以就在门口撞到拱门的地方 
So right about where the doorway hits the archway,

1152
00:59:30,344 --> 00:59:32,260
因为这就是我们想要玩家的头
because that's where we want the player's head

1153
00:59:32,260 --> 00:59:33,410
让它看起来像是消失了 
to look like it disappears.

1154
00:59:33,410 --> 00:59:34,850
模板放在这里 
Stencil going here.

1155
00:59:34,850 --> 00:59:37,340
我这里有一支钢笔 
I have a stencil going right here.

1156
00:59:37,340 --> 00:59:38,370
就在这里 
And right here.

1157
00:59:38,370 --> 00:59:40,290
在右边也是如此 
And on the right side as well.

1158
00:59:40,290 --> 00:59:42,230
这样做的目的是我已经设置了模板
And what that does is I've set the stencil

1159
00:59:42,230 --> 00:59:47,120
说出在分类过程中通过这个模板的任何东西
to say whatever passes through this stencil during the sort

1160
00:59:47,120 --> 00:59:50,480
模板测试期 我们所做的只是
of stencil testing period which is, well all we do is we just

1161
00:59:50,480 --> 00:59:52,130
在这段时间内画出玩家 
draw the player during that time.

1162
00:59:52,130 --> 00:59:55,820
但基本上 如果它在模板上 就不会呈现它 
But basically if it's on the stencil, don't render it.

1163
00:59:55,820 --> 00:59:58,190
所以它的影响是我们仍然
And so it what that has the effect of is we still

1164
00:59:58,190 --> 01:00:00,170
在玩家面前画出门道 
draw the doorways before the player.

1165
01:00:00,170 --> 01:00:03,210
所以球员走进来 他被拉到了这一部分的上方 
So the player walks in and he's drawn above this part.

1166
01:00:03,210 --> 01:00:05,900
但一旦他打到模板 他就没有被画出来 
But as soon as he hits the stencil, he's not drawn.

1167
01:00:05,900 --> 01:00:07,970
它只是--所有这些 基本上它所做的
It just-- all those, basically what it does

1168
01:00:07,970 --> 01:00:15,290
它将字符绘制到模具上 而不是实际的画布上 
is it draws the character to the stencil, and not to the actual canvas.

1169
01:00:15,290 --> 01:00:19,700
因此 如果你想要令人信服的分层、怪异的视觉效果
And so we get if you want convincing layered, weird, visual effects

1170
01:00:19,700 --> 01:00:23,070
就像这样 模版是一种方法 
like that, stenciling is an approach.

1171
01:00:23,070 --> 01:00:23,570
好的 
OK.

1172
01:00:23,570 --> 01:00:24,830
然后就是这一切 
And then that's all this.

1173
01:00:24,830 --> 01:00:28,040
所以这个模板函数 love.graph 模板 
So this stencil function, love.graphics.stencil,

1174
01:00:28,040 --> 01:00:29,450
接受一个函数 
takes in a function.

1175
01:00:29,450 --> 01:00:32,442
这是在实际的模版过程中要运行的内容 
This is what's going to run during the actual stenciling process.

1176
01:00:32,442 --> 01:00:33,275
它将会抽签--
It's going to draw--

1177
01:00:33,275 --> 01:00:34,550
我画了四个矩形 
I draw four rectangles.

1178
01:00:34,550 --> 01:00:39,061
所有那些矩形就是那些拱门 
All those rectangles are just those archways.

1179
01:00:39,061 --> 01:00:39,560
对吗？
Right?

1180
01:00:39,560 --> 01:00:43,970
完美地覆盖在它们上面 这样它就可以进入隔壁的房间 
Perfectly layered over them such that it goes into the next room.

1181
01:00:43,970 --> 01:00:47,560
然后我们就这么做了 
And then we do.

1182
01:00:47,560 --> 01:00:49,610
请注意 它显示的是替换 然后是1 
Notice that it says Replace, and then 1.

1183
01:00:49,610 --> 01:00:53,630
因此 我们替换绘制到该模板上的任何像素
So we replace any pixel that gets drawn to that stencil

1184
01:00:53,630 --> 01:00:55,610
模板值为1 
with the stencil value of 1.

1185
01:00:55,610 --> 01:01:00,931
然后我们只在模具测试中画小于1的东西 
And then we only draw things that are less than 1 during the stencil test.

1186
01:01:00,931 --> 01:01:03,680
这意味着任何没有被归因于值1的东西 
Which means anything that didn't get ascribed to value of 1, which

1187
01:01:03,680 --> 01:01:05,900
也就是说 如果玩家翻阅了模板 
means that if the player went over the stencil,

1188
01:01:05,900 --> 01:01:07,972
得到的像素值为1 则为假 
got a pixel value of 1, that's going to be false.

1189
01:01:07,972 --> 01:01:09,680
他不会被屏幕所吸引 
He's not going to be drawn to the screen.

1190
01:01:09,680 --> 01:01:10,648
是?
Yes?

1191
01:01:10,648 --> 01:01:15,488
观众：所以你是在刻版 如果你创造了一个不同的形状 
AUDIENCE: So you are stenciling, if you created a different shape,

1192
01:01:15,488 --> 01:01:20,417
你可以利用这一点 比如说 像灯光系统一样 一些区域是黑暗的 
you could use that, for say, like a light system, some areas are dark,

1193
01:01:20,417 --> 01:01:21,292
有些区域是亮的吗？
some areas are light?

1194
01:01:21,292 --> 01:01:26,392
科尔顿·奥格登：很好的问题是 如果你有一个模板 因为你
COLTON OGDEN: Good question was if you have a stencil, because you

1195
01:01:26,392 --> 01:01:28,100
可以使用任意形状 您可以
can do with an arbitrary shape, you could

1196
01:01:28,100 --> 01:01:32,240
在某些区域为暗区域 而某些区域为亮区域的情况下创建照明系统 
create lighting systems where some areas are dark, and some areas are light.

1197
01:01:32,240 --> 01:01:34,600
我想说有可能 
I want to say possibly.

1198
01:01:34,600 --> 01:01:38,990
问题是 我不能100%确定模板是否允许你这样做 
The thing is, I'm not 100% sure whether stenciling allows you to do,

1199
01:01:38,990 --> 01:01:44,940
爱2D模板是否允许你做任意的数字 
whether love 2D stenciling allows you to do arbitrary numbers.

1200
01:01:44,940 --> 01:01:48,320
我基本上不确定它是开着还是关着 还是渐变 
I basically am not sure if it's on or off, or a gradient.

1201
01:01:48,320 --> 01:01:51,110
通常 如果我这样做我们的照明系统 
Typically, if I were to do our lighting system like that,

1202
01:01:51,110 --> 01:01:54,560
我可能会画一个假的照明系统 
I would probably draw a faux lighting system.

1203
01:01:54,560 --> 01:01:57,830
第一 你可以使用照明套件 比如盒子
One, you can use a lighting kit, like box

1204
01:01:57,830 --> 01:02:01,310
2D灯光 这对你来说真的很吸引人 很酷的灯光 
2D lights, which does really compelling, cool lights for you.

1205
01:02:01,310 --> 01:02:05,150
或者是一种更粗鲁的方式 但也可能是现实的 
Or sort of a cruder way to do it, but possibly realistic,

1206
01:02:05,150 --> 01:02:12,020
就是画一个形状 适合你想要成为黑暗的任何东西 
would be to draw a shape that fits whatever you want to be your darkness,

1207
01:02:12,020 --> 01:02:16,330
然后以低于100%的不透明度进行渲染 
and then render it at an opacity that's less than 100%.

1208
01:02:16,330 --> 01:02:20,240
所以你会有一个房间 比方说可能在它的两边
So you'd have a room, and let's say maybe to sides of it

1209
01:02:20,240 --> 01:02:21,950
都有些模糊 
are kind of shadowy.

1210
01:02:21,950 --> 01:02:24,320
你在那里画黑色的矩形 对吗？
You draw black rectangles there, right?

1211
01:02:24,320 --> 01:02:28,250
但是 这些黑色矩形不是以255阿尔法绘制的 
But instead of drawing those black rectangles at 255 alpha,

1212
01:02:28,250 --> 01:02:31,950
你把它们画在200或150 或者类似的地方 
you draw them at 200 or 150, or something like that.

1213
01:02:31,950 --> 01:02:33,950
所以你仍然可以看到它们下面是什么 
And so you can still see what's underneath them,

1214
01:02:33,950 --> 01:02:37,790
但看起来它们似乎是一个影子 
but it looks as if they are a shadow.

1215
01:02:37,790 --> 01:02:40,040
你可以使用渐变效果来做同样的事情 
And you can use gradient effects to do the same thing.

1216
01:02:40,040 --> 01:02:44,240
如果你想要更深更浅的阴影 
If you want to have shadow that's darker going lighter,

1217
01:02:44,240 --> 01:02:47,494
我相信你可以在Love 2D中画出带有渐变效果的矩形 
I believe you can draw rectangles with a gradient effect in Love 2D.

1218
01:02:47,494 --> 01:02:49,160
我还得再深入调查一下 
I'd have to look into a little bit more.

1219
01:02:49,160 --> 01:02:51,080
但你会想要做这样的事 
But you would look to do something like that.

1220
01:02:51,080 --> 01:02:55,280
通过某个矩形或任意形状绘制阴影的渐变 
Draw a gradient of shadow via some rectangle, or some arbitrary shape,

1221
01:02:55,280 --> 01:02:56,930
在这种情况下模拟照明 
to simulate lighting in that case.

1222
01:02:56,930 --> 01:02:59,110
你可以完成类似的事情 
And you could accomplish something similar to that.

1223
01:02:59,110 --> 01:03:02,359
还有很多其他疯狂的很酷的方式 我在2D中看到过闪电 
And there are a lot of other crazy cool ways I've seeing lightning done in 2D.

1224
01:03:02,359 --> 01:03:05,759
但这可能是我能想到的最简单的方法了 
But that's probably offhand the simplest way that I could think of doing it.

1225
01:03:05,759 --> 01:03:06,258
凉爽的 
Cool.

1226
01:03:09,440 --> 01:03:12,440
所以这就是模版 基本上就是这样
So that's stenciling, and that's basically it

1227
01:03:12,440 --> 01:03:16,400
对于地牢一代来说 这可以说是最重要的部分 
for the dungeon generation, which is arguably the most important part.

1228
01:03:16,400 --> 01:03:19,790
我们之前也看过这种过渡机制 
And also we looked earlier at the sort of transition mechanic.

1229
01:03:19,790 --> 01:03:23,154
我们将更多地了解过渡机械师
And we'll look at the transition mechanic a little bit more

1230
01:03:23,154 --> 01:03:23,820
稍等片刻 
in a little bit.

1231
01:03:23,820 --> 01:03:27,260
但让我们现在花五分钟 然后回到那个问题上
But let's take a five minute for right now, and then come back to that

1232
01:03:27,260 --> 01:03:29,820
再看看更多的东西 
and see some more stuff.

1233
01:03:29,820 --> 01:03:30,320
好的 
All right.

1234
01:03:30,320 --> 01:03:32,717
欢迎回到第五讲 塞尔达传奇 
Welcome back to Lecture 5, Legend of Zelda.

1235
01:03:32,717 --> 01:03:34,550
所以在休息之前 我们谈到了一些
So before the break, we talked about a bunch

1236
01:03:34,550 --> 01:03:38,880
在不同的事物中 地牢一代是其中最重要的 
of different things, dungeon generation being foremost among them.

1237
01:03:38,880 --> 01:03:42,930
现在我们将真正开始谈论像Hitbox和Hurtbox这样的东西 
Now we'll actually start talking about things like hitboxes and hurtboxes,

1238
01:03:42,930 --> 01:03:44,420
正如我们在屏幕上看到的那样 
as we can see here on the screen.

1239
01:03:44,420 --> 01:03:47,790
因此 Hitbox基本上是一个长方形 
So a hitbox is a rectangle, basically.

1240
01:03:47,790 --> 01:03:50,540
这就是我们在发行版中实现它的方式 
And it's how we've implemented it in the distro.

1241
01:03:50,540 --> 01:03:52,820
但我们在这里可以看到有几种不同的
But we can see here there's a few different sort

1242
01:03:52,820 --> 01:03:53,940
矩形重叠的部分 
of rectangles overlapping.

1243
01:03:53,940 --> 01:03:55,650
我们这里有绿色的长方形 
We have the green rectangles here.

1244
01:03:55,650 --> 01:03:56,890
这些都是伤害箱 
These are hurtboxes.

1245
01:03:56,890 --> 01:03:58,440
这就是你可能受伤的地方 
These are where you can get hurt.

1246
01:03:58,440 --> 01:03:59,640
然后这是一个Hitbox 
And then this is a hitbox.

1247
01:03:59,640 --> 01:04:01,920
这是你可以击球的地方 
This is where you can hit something.

1248
01:04:01,920 --> 01:04:04,380
所以游戏 特别是格斗游戏 
And so games, like especially with fighting games,

1249
01:04:04,380 --> 01:04:06,900
在许多相当复杂的互动游戏中 
in a lot of games of fairly complex interactions,

1250
01:04:06,900 --> 01:04:10,020
以及拥有武器或粒子的复杂实体 
and complex entities that have weapons or particles,

1251
01:04:10,020 --> 01:04:11,610
诸如此类的事情都会造成损害 
things like that all do damage.

1252
01:04:11,610 --> 01:04:15,180
你会看到很多复杂的重叠 
You'll see a lot of complicated overlapping,

1253
01:04:15,180 --> 01:04:18,974
以及这些矩形的排列 这就带来了
and arrangement of these rectangles that sort of bring about

1254
01:04:18,974 --> 01:04:21,390
物体如何在碰撞方面相互作用 
how things interact with each other in terms of collision,

1255
01:04:21,390 --> 01:04:24,450
造成损害 并影响到其他实体 
and doing damage, and affecting other entities.

1256
01:04:24,450 --> 01:04:29,220
在这种情况下 他正在进行从左到右的攻击 
In this case, he's doing an attack that goes from the left to the right.

1257
01:04:29,220 --> 01:04:30,390
这是一次低位进攻 
It's a low attack.

1258
01:04:30,390 --> 01:04:33,104
只是他的脚 从本质上讲 有点向内 
Only his foot, essentially, a little bit inwards.

1259
01:04:33,104 --> 01:04:36,270
但从本质上说 他的脚是有损伤的 而他的其余部分是脆弱的 
But essentially his foot does damage, whereas the rest of him is vulnerable.

1260
01:04:36,270 --> 01:04:39,520
如果有人从上面走到他跟前攻击他 
If someone were to come up to him from up above and attack him,

1261
01:04:39,520 --> 01:04:41,440
这会造成一些损害 
it would do some damage.

1262
01:04:41,440 --> 01:04:45,600
还有《我的世界》 它向你展示了同样的原则
And there's Minecraft, and it shows you how the same sort of principle

1263
01:04:45,600 --> 01:04:48,130
同样适用于3D游戏 
applies to 3D games as well.

1264
01:04:48,130 --> 01:04:53,070
在这种情况下 你看到的都是伤害箱 
In this case, what you see there are all hurtboxes.

1265
01:04:53,070 --> 01:04:54,750
这些人都意识到事情可能会受到伤害 
Those are all aware things can get hurt.

1266
01:04:54,750 --> 01:04:57,301
尽管这些东西很少是物品 
Even though those are few of those things are items,

1267
01:04:57,301 --> 01:05:00,300
因此 这只会真正影响玩家是否与它们相撞
so that only really affects whether or not the player collides with them

1268
01:05:00,300 --> 01:05:01,860
然后把它们捡起来 
and picks them up.

1269
01:05:01,860 --> 01:05:07,380
但这基本上就是Hitbox和Hurtbox之间的区别 
But that's basically the difference between hitboxes and hurtboxes.

1270
01:05:07,380 --> 01:05:10,410
我想我不小心把这个文件命名为hurtbox的发行版 
The distro I think I accidentally called the file hurtbox.

1271
01:05:10,410 --> 01:05:13,380
所以当我把它往上推时 它会被重新命名为Hitbox 
So when I push it up, it's going to be renamed hitbox,

1272
01:05:13,380 --> 01:05:15,070
因为这就是我们使用它的目的 
because that's what we use it for.

1273
01:05:15,070 --> 01:05:22,354
但在这场比赛中有什么是即兴的 我们需要Hitbox做什么？
But what is offhand in this game, what do we need a hitbox for?

1274
01:05:22,354 --> 01:05:24,270
观众：[听不见]呼啸而来的攻击 
AUDIENCE: [INAUDIBLE] attacks from the swoord.

1275
01:05:24,270 --> 01:05:25,728
科尔顿·奥格登：用剑攻击 
COLTON OGDEN: Attacks with a sword.

1276
01:05:25,728 --> 01:05:28,550
我们需要Hitbox的原因是什么？
And the reason that we need a hitbox for that is why?

1277
01:05:28,550 --> 01:05:30,540
观众：致[INAUDIBLE]大热 
AUDIENCE: To [INAUDIBLE] the hit.

1278
01:05:30,540 --> 01:05:31,290
科尔顿·奥格登：是的 
COLTON OGDEN: Yes.

1279
01:05:31,290 --> 01:05:35,476
为什么我们不能只使用球员的位置x-y宽度和高度？
And why can't we just use the player's position x-y width and height?

1280
01:05:35,476 --> 01:05:37,350
观众：因为它也有一个方向 
AUDIENCE: Because it has a direction as well.

1281
01:05:37,350 --> 01:05:40,225
科尔顿·奥格登：因为它也有方向 也需要--
COLTON OGDEN: Because it has a direction as well, and also it needs--

1282
01:05:40,225 --> 01:05:41,610
这基本上就是它的伤害性武器 
that's essentially its hurtbox.

1283
01:05:41,610 --> 01:05:42,270
对吗？
Right?

1284
01:05:42,270 --> 01:05:44,170
所以这两个原因 
So those two reasons.

1285
01:05:44,170 --> 01:05:50,310
它有我们需要作为它参考点的方向
It has that direction that we need to sort of act as its reference point

1286
01:05:50,310 --> 01:05:54,030
用于生成命中框 对其他实体造成伤害 
for generating a hit box, to inflict damage on other entities.

1287
01:05:54,030 --> 01:05:56,280
我们需要使用玩家的主Hitbox
And we need to use the player's main hitbox

1288
01:05:56,280 --> 01:05:58,800
以及伤害盒 它已经必须看看是否有什么东西
and hurtbox that it already has to see if something

1289
01:05:58,800 --> 01:06:04,030
击球 球员 也许是从另一边 或者类似的东西 
hit it, the player, maybe from another side, or something like that.

1290
01:06:04,030 --> 01:06:05,670
那么 让我们继续下去 看看这里 
So let's go ahead and take a look here.

1291
01:06:05,670 --> 01:06:09,090
处理Hitbox的主要代码 在本例中 
The main bit of code that deals with the hitbox, in this case,

1292
01:06:09,090 --> 01:06:11,100
其中一个将会成为伤害盒 
is one going to be hurtbox.

1293
01:06:11,100 --> 01:06:11,940
应该是希特波斯 
Should be hitbox.

1294
01:06:11,940 --> 01:06:15,390
但我们可以看到 这实际上只是一个矩形类 
But we can see this is literally just a rectangle class.

1295
01:06:15,390 --> 01:06:16,790
XY 宽度和高度 
xy, a width and a height.

1296
01:06:16,790 --> 01:06:20,490
自学 自学 
self.x, self.y, self-taught, self.width, self.height equals all those things.

1297
01:06:20,490 --> 01:06:22,860
这就是你对Hitbox所需要的一切 
That's all you need for a hitbox.

1298
01:06:22,860 --> 01:06:26,370
字面意思就是盒子 你所需要的就是那些字段 
Literally box, just all you need are those fields.

1299
01:06:26,370 --> 01:06:29,051
然后你可以做简单的碰撞 
And then you can do simply collides.

1300
01:06:29,051 --> 01:06:30,050
就像你做实体一样 
Just like you do entity.

1301
01:06:30,050 --> 01:06:32,220
实体碰撞伤害箱 
Entity collides hurtbox.

1302
01:06:32,220 --> 01:06:33,300
是 不 对或错 
Yes, no, true or false.

1303
01:06:33,300 --> 01:06:38,220
因为回想起来 碰撞预期XY宽度或高度 
Because recall, collides expects xy width or height.

1304
01:06:38,220 --> 01:06:41,610
它定义了一个整体Lua 
And it's defined an entity.lua.

1305
01:06:41,610 --> 01:06:45,180
因此 如果我们上升到玩家状态 
So if we go up to the player states.

1306
01:06:45,180 --> 01:06:48,240
回想一下 上周我们介绍了这个想法
So recall, last week we introduced the idea

1307
01:06:48,240 --> 01:06:51,240
让玩家维护自己的状态集合 
of having the player maintain its own collection of states,

1308
01:06:51,240 --> 01:06:52,350
在状态机中 
in a state machine.

1309
01:06:52,350 --> 01:06:55,740
而不仅仅是游戏世界有一个状态机
As opposed to just the game world having a state machine that

1310
01:06:55,740 --> 01:06:57,960
影响我们是否在开始屏幕上 
influences whether we're at the Start screen,

1311
01:06:57,960 --> 01:07:03,750
Play State屏幕 无论我们想要将游戏划分成什么 
the Play State screen, whatever we want to divide our game up into.

1312
01:07:03,750 --> 01:07:06,190
我们也有实体国家 
We have entities states as well.

1313
01:07:06,190 --> 01:07:09,660
其中之一是--所以我们在行走状态下有空闲的 
Now one of those is the-- so we have the idle in the walk state.

1314
01:07:09,660 --> 01:07:14,467
这些与上周的非常相似 空闲状态 他们是
Those are so very similar to last week's, where the idle state, they're

1315
01:07:14,467 --> 01:07:15,300
只是站着不动 
just standing still.

1316
01:07:15,300 --> 01:07:19,020
以及它们正在移动的行走状态 它们的动画也会相应地改变 
And the walking state they're moving and their animation changes accordingly.

1317
01:07:19,020 --> 01:07:23,520
摆剑状态是一个新的状态 而这个状态的作用是
The swing sword state is a new state, and what this does

1318
01:07:23,520 --> 01:07:26,190
是玩家按空格键 
is the player presses spacebar.

1319
01:07:26,190 --> 01:07:28,620
它会触发这种摇摆的剑状态 
It triggers this swing sword state.

1320
01:07:28,620 --> 01:07:29,880
有一部新的动画 
There's a new animation.

1321
01:07:29,880 --> 01:07:34,290
因此 我们进入摆动剑动画 相对于我们所处的方向 
So we go into the swing sword animation, relative to which direction we're in.

1322
01:07:34,290 --> 01:07:40,680
我们得到那个方向 然后我们计算xy的宽度和高度
And we get that direction and then we calculate the xy width and height

1323
01:07:40,680 --> 01:07:42,310
不管我们的伤害箱是什么 
of whatever our hurtbox.

1324
01:07:42,310 --> 01:07:46,110
应该是Hitbox 是要换剑的 
Should be hitbox, is going to be for the sword.

1325
01:07:46,110 --> 01:07:47,880
当剑射中某物时 
When the sword hits something.

1326
01:07:47,880 --> 01:07:51,990
所以Hitbox 如果它朝向左边 它是
So that hitbox, if it's facing the left, it's

1327
01:07:51,990 --> 01:07:54,540
将是8像素宽乘16高 这
going to be 8 pixels wide by 16 tall, which

1328
01:07:54,540 --> 01:07:57,090
大致在球员的左侧 
is roughly the left side of the player.

1329
01:07:57,090 --> 01:08:00,870
然后我们只计算x和y 取决于我们所处的位置 
And then we just calculate the x and y depending on which position we're in.

1330
01:08:00,870 --> 01:08:05,520
它应该大致居中 基于球员的方向 
It should be roughly centered based on whatever direction the player is

1331
01:08:05,520 --> 01:08:06,940
看着 
looking at.

1332
01:08:06,940 --> 01:08:10,230
然后我们在这里实例化这个伤害框 
And so we then instantiate that hurtbox here.

1333
01:08:10,230 --> 01:08:13,590
我们管它叫自助式剑术保镖 
We call it a self.swordhurtbox.

1334
01:08:13,590 --> 01:08:16,430
然后我们真正需要做的是什么？
And then all we really need to do is what?

1335
01:08:16,430 --> 01:08:20,357
在我们的游戏循环中检查我们是否击中了实体？
In our game loop to check to see if we've hit an entity?

1336
01:08:26,430 --> 01:08:32,340
我们只需要循环我们房间中的实体 当前房间 对吗？
We just need to loop over the entities in our room, the current room right?

1337
01:08:32,340 --> 01:08:32,970
这里 
Here.

1338
01:08:32,970 --> 01:08:37,319
所以地牢当前房间里的每一个实体 实体 
So every entity in the dungeon's current room.entities.

1339
01:08:37,319 --> 01:08:40,859
如果实体与我们的利剑伤害箱、利剑希特箱相撞 
If the entity collides with our sword hurtbox, sword hitbox,

1340
01:08:40,859 --> 01:08:45,420
然后 我们以前见过这种方法 实体破坏一次 
then, we saw this method before, entity damage one.

1341
01:08:45,420 --> 01:08:47,247
然后击打敌人的游戏 
And then hit enemy play.

1342
01:08:47,247 --> 01:08:48,330
事情就是这么简单 
That's as simple as it is.

1343
01:08:48,330 --> 01:08:54,540
回想一下 在房间里 Lua 如果一个实体的生命值降到1以下 降到0 
And recall, in room.Lua, if an entity's health dropped below one, dropped to 0,

1344
01:08:54,540 --> 01:08:56,640
它只会触发它变得死亡 
it would just trigger it to become dead.

1345
01:08:56,640 --> 01:08:57,689
对吗？
Right?

1346
01:08:57,689 --> 01:09:00,430
这就是我们有效地需要的一切 
And so that's all we need effectively.

1347
01:09:00,430 --> 01:09:02,910
然后我们有一些额外的逻辑来确保
And then we have some additional logic to make sure

1348
01:09:02,910 --> 01:09:04,890
动画只播放一次 
that the animation only plays one time.

1349
01:09:04,890 --> 01:09:10,290
然后 一旦它播放了一次 将其状态更改为空闲 
And then once it has played one time, change its state to idle.

1350
01:09:10,290 --> 01:09:13,500
然后我们可以在相同的状态下重复按空格键 
And then we can press spacebar repeatedly within that same state,

1351
01:09:13,500 --> 01:09:15,300
如果我们想的话就继续摇摆 
just to keep swinging if we want to.

1352
01:09:15,300 --> 01:09:18,540
它将重新启动动画 然后重新启动
And it will just restart the animation, and restart

1353
01:09:18,540 --> 01:09:20,399
正在实例化的Hitbox 
the hitbox being instantiated.

1354
01:09:20,399 --> 01:09:23,519
这就是我们真正需要做的一切 
And so that's all we really need to do for that.

1355
01:09:23,519 --> 01:09:26,310
现在我在挥剑的底部有几行代码
Now I have some lines of code here at the bottom of the sword swing

1356
01:09:26,310 --> 01:09:27,569
国家 卢阿 
state.lua.

1357
01:09:27,569 --> 01:09:30,029
和选手佩剑 摆剑状态 
And player swords, swings swords state.

1358
01:09:30,029 --> 01:09:32,939
而它们所做的是有时它是有用的
And what these do is sometimes it's useful

1359
01:09:32,939 --> 01:09:36,563
当你编程来查看你的碰撞框在哪里时 对吗？
when you're programming to sort of see where your collision boxes are, right?

1360
01:09:36,563 --> 01:09:39,479
因为你不一定知道一切是否都完美地排列在一起 
Because you don't necessarily know if everything's lined up perfectly.

1361
01:09:39,479 --> 01:09:41,937
当您检测不同实体之间的冲突时 
When you're detecting collision between different entities,

1362
01:09:41,937 --> 01:09:44,939
您只需要检查一下这些矩形是否确实重叠
you want to just check to see are the rectangles actually overlapping

1363
01:09:44,939 --> 01:09:46,229
这是什么时候触发的？
when this triggers?

1364
01:09:46,229 --> 01:09:50,189
所以你所需要做的就是一目了然地看到它 
So all you need to do in order to visually see this at a glance,

1365
01:09:50,189 --> 01:09:54,690
你可能以前在其他游戏或调试模式的游戏中见过这种情况 
and you may have seen this before, in other games or debug modes of games,

1366
01:09:54,690 --> 01:09:57,357
就是画一条长方形的线 
is just draw a line rectangles.

1367
01:09:57,357 --> 01:10:00,690
然后给他们你想看的XY宽度和高度 对吗？
And then just give them the xy width and height that you want to look at, right?

1368
01:10:00,690 --> 01:10:04,710
所以 在这里 我将继续并保存这个 
So here, I'm going to go ahead and save this.

1369
01:10:04,710 --> 01:10:06,225
然后我要运行--
And then I'm going to run the--

1370
01:10:06,225 --> 01:10:08,640
我基本上没有评论过它 
I've basically uncommented it.

1371
01:10:08,640 --> 01:10:10,800
因为默认情况下 我不想让它显示出来 
Because by default, I don't want it showing.

1372
01:10:10,800 --> 01:10:13,440
它们是粉红色的矩形 我不想让它们显示在屏幕上 
They're pink rectangles, I don't want them displayed on screen,

1373
01:10:13,440 --> 01:10:14,880
除非我想做调试 
unless I want to do debugging.

1374
01:10:14,880 --> 01:10:18,030
因此 我将在这里取消对它们的注释 
So I'm going to uncomment them down here.

1375
01:10:18,030 --> 01:10:20,460
请注意 它将颜色设置为255 0 255 
Notice it sets the color to 255, 0 255.

1376
01:10:20,460 --> 01:10:22,170
那是洋红色 
That's magenta.

1377
01:10:22,170 --> 01:10:23,914
我来负责这件事 
I'm going to run this.

1378
01:10:23,914 --> 01:10:25,225
[音乐播放]
[MUSIC PLAYING]

1379
01:10:25,225 --> 01:10:26,790
把音量调小一点 
Turn that down a little bit.

1380
01:10:26,790 --> 01:10:28,980
看起来没有什么特别的不同 
Nothing looks particularly different.

1381
01:10:28,980 --> 01:10:34,170
但当我挥动我的剑时 注意到有一个小矩形 
But when I swing my sword, notice that there's a little rectangle.

1382
01:10:34,170 --> 01:10:37,170
长方形也不一定是100%完美的 
And the rectangles aren't 100% perfect necessarily.

1383
01:10:37,170 --> 01:10:39,630
他们给了球员一点优势 
They give the player little bit of an advantage.

1384
01:10:39,630 --> 01:10:42,930
就像上面一样 就像他的Hitbox几乎什么都不是 
Like up above, like his hitbox is barely anything.

1385
01:10:42,930 --> 01:10:47,370
在上面 在实际动画中 但在碰撞中 
Up above, in the actual animation, but in the collision,

1386
01:10:47,370 --> 01:10:52,310
我对它敬而远之 
I give it quite a wide berth.

1387
01:10:52,310 --> 01:10:54,270
所以这就是为什么你可以 在某种程度上 
And so that's how you can, at a glance, sort of

1388
01:10:54,270 --> 01:10:57,400
看看你的东西是否有适当的相互作用 
see whether your things are interacting appropriately.

1389
01:10:57,400 --> 01:10:58,330
有几行代码 
There's lines of code.

1390
01:10:58,330 --> 01:11:01,170
我为其他州做了同样的事情 实体 步行 
I did the same thing for the other states, the entity, walking,

1391
01:11:01,170 --> 01:11:02,100
和空闲状态 
and idle states.

1392
01:11:02,100 --> 01:11:05,222
如果你想看看这些 不仅能看到球员
If you want to sort of look at those, and see not only the player

1393
01:11:05,222 --> 01:11:08,430
挥舞着剑 还有其他实体 以及他们的碰撞框
swinging the sword, but also the other entities, and the collision boxes they

1394
01:11:08,430 --> 01:11:11,820
有 只是为了检查它们是否适当地重叠 
have, and just to check whether or not they're overlapping appropriately,

1395
01:11:11,820 --> 01:11:14,040
或者改变它们 或者随心所欲地处理它们 
or to change them, or do whatever you want with them.

1396
01:11:14,040 --> 01:11:15,345
但这是一种很好的方式--
But that's a nice way to do--

1397
01:11:15,345 --> 01:11:17,220
有时很难调试冲突 如果您
sometimes it's hard to debug collision if you

1398
01:11:17,220 --> 01:11:18,930
我看不清到底是怎么回事 
can't see exactly what's going on.

1399
01:11:18,930 --> 01:11:22,500
因为它通常只是XY的宽度和高度 等等 
Because it's often just in terms of xy width and height, so on and so forth,

1400
01:11:22,500 --> 01:11:23,950
有偏移量之类的 
with offsets and such.

1401
01:11:23,950 --> 01:11:27,180
这可能是一种痛苦和/或一种困难
It can be kind of a pain and/or sort of difficult

1402
01:11:27,180 --> 01:11:28,680
以这种方式追踪特定的虫子 
to track down certain bugs that way.

1403
01:11:28,680 --> 01:11:31,229
所以只要画到屏幕上就行了 
So just draw to the screen.

1404
01:11:31,229 --> 01:11:34,020
你可以将同样的逻辑应用到你的游戏世界中的许多事情上
You can apply that same logic to a lot of things in your game world

1405
01:11:34,020 --> 01:11:38,970
这可能是隐藏的 但您希望看到某种视觉上的只是绘制形状
that may be hidden, but you want to see sort of visually just draw shapes

1406
01:11:38,970 --> 01:11:40,440
或者为他们画不同的东西 
or draw different things for them.

1407
01:11:40,440 --> 01:11:42,310
这样你就能看到发生了什么 
So you can see what's going on.

1408
01:11:42,310 --> 01:11:47,160
对于我们的球员来说 这就是Hitbox和Hurtbox的工作方式 
So that's how the hitbox and hurtbox work for our player.

1409
01:11:47,160 --> 01:11:50,706
你可以很容易地为其他实体产生更多的点击率
And you can easily just spawn more hitboxes for other entities

1410
01:11:50,706 --> 01:11:51,330
如果你想的话 
if you want to.

1411
01:11:51,330 --> 01:11:53,940
如果你想给他们州 或者
If you wanted to give them states, or maybe

1412
01:11:53,940 --> 01:11:57,750
你想制造具有攻击性的投射物 
you want to create projectiles that are offensive.

1413
01:11:57,750 --> 01:12:01,680
也许只是制造炮弹 然后发射炮弹
Maybe just create projectiles, and then shoot projectiles

1414
01:12:01,680 --> 01:12:06,360
在特定方向上 但将Hitbox分配给该射弹 
in a specific direction, but assign a hitbox to that projectile,

1415
01:12:06,360 --> 01:12:07,660
如果你想的话 
if you want to.

1416
01:12:07,660 --> 01:12:10,200
或者只使用XY宽度和高度投射物 
Or just use the projectiles xy width and height,

1417
01:12:10,200 --> 01:12:12,270
然后你就可以这样计算碰撞了 
and then you can calculate a collision that way.

1418
01:12:12,270 --> 01:12:14,550
只需将其视为游戏对象或实体即可 
Just treat it like a game object, or an entity.

1419
01:12:14,550 --> 01:12:15,780
由你决定 
It's up to you.

1420
01:12:15,780 --> 01:12:18,700
或者一起上一个单独的班级 
Or a separate class all together.

1421
01:12:18,700 --> 01:12:21,000
但简而言之 这就是打击手和伤害者 
But that's hitboxes and hurtboxes in a nutshell.

1422
01:12:21,000 --> 01:12:23,400
有没有人对这些工作原理有任何疑问？
Anybody have any questions as to how those sort of work?

1423
01:12:25,950 --> 01:12:27,490
好的 酷 
OK, cool.

1424
01:12:27,490 --> 01:12:29,360
那么 让我们继续下一个话题 
So let's go on to the next topic.

1425
01:12:29,360 --> 01:12:30,490
所以就是这些事件 
So events.

1426
01:12:30,490 --> 01:12:32,260
我早些时候谈到了这一点 
So I spoke of this earlier.

1427
01:12:32,260 --> 01:12:35,860
事件只是一种很好的方式 可以说
Events are just a nice way to sort of say when something

1428
01:12:35,860 --> 01:12:39,550
如果发生这种情况 请执行此代码块 
happens, do this block of code.

1429
01:12:39,550 --> 01:12:40,910
你可以在任何地方做到这一点 
And you can do this anywhere.

1430
01:12:40,910 --> 01:12:44,290
你可以把它从两个不同的物体中分离出来
And you can decouple it from like maybe two different objects

1431
01:12:44,290 --> 01:12:45,430
彼此互动 
interact with each other.

1432
01:12:45,430 --> 01:12:48,130
但您不希望它们传递引用
But you don't want them to sort of pass references

1433
01:12:48,130 --> 01:12:51,130
在彼此之间来回移动 并膨胀您的代码 
back and forth between each other, and bloat your code.

1434
01:12:51,130 --> 01:12:55,660
也许您希望该检查的代码发生在您的主循环中 
Maybe you want the code for that check to happen not inside your main loop.

1435
01:12:55,660 --> 01:12:58,870
你想把它抽象成某种其他函数 
You want to sort of abstract it out to some sort of other function,

1436
01:12:58,870 --> 01:13:00,640
就像实例化的事件 
like instantiated events.

1437
01:13:00,640 --> 01:13:02,950
然后让您的主呈现和更新逻辑
And then have your main rendering and update logic

1438
01:13:02,950 --> 01:13:06,077
摆脱所有这些有条件的东西 
be free of all this conditional stuff.

1439
01:13:06,077 --> 01:13:06,910
所以你创造了事件 
So you create event.

1440
01:13:06,910 --> 01:13:12,400
你说在一些活动上 所以可能就像在运动员竞走上 
You say on some event, so maybe like on player walk,

1441
01:13:12,400 --> 01:13:14,592
然后你只需要更新一些 也许是一个标签
and then you just update some, maybe a label

1442
01:13:14,592 --> 01:13:17,050
在屏幕的右上角 这给出了玩家的XY 
on the top right of the screen, that gives the player's xy.

1443
01:13:17,050 --> 01:13:20,286
你就说XY等于那个玩家的XY 
And you just say that xy is equal to that player's xy.

1444
01:13:20,286 --> 01:13:22,660
我的意思是 除了你可以从字面上
I mean, aside from the fact that you could just literally

1445
01:13:22,660 --> 01:13:24,144
画出玩家的XY 
draw the player's xy.

1446
01:13:24,144 --> 01:13:25,310
但这是相同的原则 
But it's the same principle.

1447
01:13:25,310 --> 01:13:30,370
您可以在独立于另一个实体的某个位置更新一些值 
You can update some value somewhere separate from another entity.

1448
01:13:30,370 --> 01:13:34,750
然后等待一个事件 任意定义的事件 
And then just wait for an event, arbitrarily defined event,

1449
01:13:34,750 --> 01:13:37,100
然后你再播出 
that you then broadcast later.

1450
01:13:37,100 --> 01:13:39,460
比方说我想要一把广播摇摆剑 
So let's say I want a broadcast swing sword.

1451
01:13:39,460 --> 01:13:40,840
我有一场挥杆剑比赛 
I have a swing sword event.

1452
01:13:40,840 --> 01:13:42,790
因此 每当玩家按空格键时 不仅
So whenever the player presses space, not only

1453
01:13:42,790 --> 01:13:46,120
他们做了我们之前看到的所有代码 但他们挥舞着剑 
do they do all the code that we saw before, but they swing sword.

1454
01:13:46,120 --> 01:13:50,035
然后我们说 当你挥舞剑时 传递他们挥舞的地方的XY
And then we say when you swing sword, pass in the xy of wherever they swung

1455
01:13:50,035 --> 01:13:51,010
那把剑 
the sword.

1456
01:13:51,010 --> 01:13:55,300
然后你就可以说好了 在摇摆剑上 看看所有的实体 
And so then you can say OK, on swing sword, look at all the entities,

1457
01:13:55,300 --> 01:13:58,344
看看XY上的Hitbox是否与它们相撞 
and see whether or not the hitbox at xy collides with them.

1458
01:13:58,344 --> 01:14:01,510
你可以从以前的逻辑中提取出来 然后把它
And you can sort of take out the logic from where you had it before, and put

1459
01:14:01,510 --> 01:14:03,370
把它放在其他集中的地方 
it in some other centralized location.

1460
01:14:03,370 --> 01:14:04,690
如果你想的话 
If you want to.

1461
01:14:04,690 --> 01:14:09,760
这种模式更具代表性的是成就系统的理念 
More representative of this model is the idea of an achievement system,

1462
01:14:09,760 --> 01:14:11,920
而不是每一帧 你可以
where instead of every frame, and you can

1463
01:14:11,920 --> 01:14:14,600
有--游戏有许多令人难以置信的成就 
have-- games have a ridiculous number of achievements.

1464
01:14:14,600 --> 01:14:16,510
有些游戏有1000个这样的成绩 
Some games have like 1,000 achievements.

1465
01:14:16,510 --> 01:14:19,210
你不会想让这1000个人中的每一个
You don't want to put the test for every one of those 1,000

1466
01:14:19,210 --> 01:14:23,110
成就必然在你的更新逻辑之内 对吗？
achievements necessarily inside of your update logic, right?

1467
01:14:23,110 --> 01:14:26,297
相反 您可以只为所有人广播一项活动
You can instead just broadcast an event for all

1468
01:14:26,297 --> 01:14:29,380
影响这些成就能否实现的不同因素 
of the different things that influence whether those achievements are met.

1469
01:14:29,380 --> 01:14:34,210
因此 无论一个玩家在一场比赛中需要杀死100个 还是需要100个硬币 
So whether a player needs to get 100 kills in a game, or 100 coins.

1470
01:14:34,210 --> 01:14:36,460
他们是否需要从悬崖上跳下来 
Whether they need to jump off some ledge.

1471
01:14:36,460 --> 01:14:38,770
你只是有一些事件来模拟所有这些互动 
You just have events that model all these interactions.

1472
01:14:38,770 --> 01:14:41,350
活动开始 拿起硬币 做这件事 
Event on, pick-up coin, do this.

1473
01:14:41,350 --> 01:14:45,820
增加一些时间 一些存储在其他地方的计数器 
Increment some time, some counter that's stored somewhere else.

1474
01:14:45,820 --> 01:14:47,965
Event.On 杀死生物 
Event.on, kill creature.

1475
01:14:47,965 --> 01:14:51,250
或者每次你杀生物的时候 
Or kill creature triggers every time you,

1476
01:14:51,250 --> 01:14:56,170
从字面上讲 一个生物从虚假到死亡都是真实的 
literally a creature is sent from as false to dead as true.

1477
01:14:58,690 --> 01:15:03,550
也许每当玩家跳跃时 你就会做一个跳跃功能 
Maybe whenever the player jumps, you do an on jump function.

1478
01:15:03,550 --> 01:15:06,040
然后你可以测试一下--在这段代码中 
And then you can test to see whether or not-- in that code,

1479
01:15:06,040 --> 01:15:08,350
你可以测试一下他们是否从悬崖上跳了下来 
you can test to see whether they jumped off that ledge.

1480
01:15:08,350 --> 01:15:11,149
如果发生这种情况 你就有了你的成就系统 
And then if that happens, you have your achievement system,

1481
01:15:11,149 --> 01:15:12,940
但您并没有所有这些if语句 
but you don't have all these if statements,

1482
01:15:12,940 --> 01:15:18,040
所有这些测试都发生在你的强制游戏循环中 
and all these tests happening inside your sort of imperative game loop.

1483
01:15:18,040 --> 01:15:22,900
您只需伪异步地检查所有它们 
You can just pseudo asynchronously check for all of them,

1484
01:15:22,900 --> 01:15:26,590
在你的游戏中有一个足够详细的事件系统 
given a sufficiently detailed event system in your game.

1485
01:15:26,590 --> 01:15:30,430
因此 我们将使用的库只是为了展示一点
And so the library that we'll use just to show this a little bit

1486
01:15:30,430 --> 01:15:34,030
在刀库里 我们之前用计时器见过 
is in the knife library, that we saw before with timer.

1487
01:15:34,030 --> 01:15:36,760
Timer.On、Timer.Every、Timer.Tweet 
Timer.on, timer.every, timer.tween.

1488
01:15:36,760 --> 01:15:38,800
在刀库中 有一个子模块
In the knife library, there's a submodule

1489
01:15:38,800 --> 01:15:44,320
名为Event 它允许您调用Event.on 
called Event, which allows you to call event.on.

1490
01:15:44,320 --> 01:15:45,580
给它一个名称和一个函数 
Give it a name and a function.

1491
01:15:45,580 --> 01:15:49,420
所以在运动员跳跃上 在运动员跳跃下 
So on player jump, off player jump.

1492
01:15:49,420 --> 01:15:50,130
你知道?
You know?

1493
01:15:50,130 --> 01:15:50,890
功能 
Function.

1494
01:15:50,890 --> 01:15:56,830
如果Player.Position位于某个悬崖边 或某个相关的区域 
If Player.Position is by some cliff, or some area that's relevant,

1495
01:15:56,830 --> 01:15:58,630
然后调用这段代码 
then call this block of code.

1496
01:15:58,630 --> 01:16:03,040
并递增 或将成就设置为真 
And increment, or set the achievement to true.

1497
01:16:03,040 --> 01:16:04,470
事件 快递 
Event.dispatch.

1498
01:16:04,470 --> 01:16:06,380
当有事情发生时调度事件 
Dispatch an event when something happens.

1499
01:16:06,380 --> 01:16:13,150
因此 如果玩家跳跃 那么当他们按空格键时 事件 调度跳跃 
So if a player jumps, so when they press the spacebar, event.Dispatch jump.

1500
01:16:13,150 --> 01:16:17,027
然后就是您的回调函数需要的任何值 
And then just whatever values that your callback function needs.

1501
01:16:17,027 --> 01:16:19,360
假设您想要查看悬崖上有什么 
Let's say you want to check to see what is on the cliff.

1502
01:16:19,360 --> 01:16:21,730
嗯 如果你想看看他们是不是跳下
Well, if you want to check to see whether they jump off

1503
01:16:21,730 --> 01:16:25,540
那个特定的悬崖 你需要检查他们的XY位置 想必 
that specific cliff, you need to check their xy position, presumably,

1504
01:16:25,540 --> 01:16:28,980
因此 只需通过Event.Dispatch传递可选参数即可 
so you can just pass in optional parameters via event.dispatch.

1505
01:16:28,980 --> 01:16:32,380
你可以说OK 调度运动员跳跃的事件 
You can say OK, dispatch the event that the player jumped,

1506
01:16:32,380 --> 01:16:34,810
然后说这名球员跳到了XY 
and say that the player jumped at xy.

1507
01:16:34,810 --> 01:16:37,990
所以这个函数回调将访问xy 
And so this function call back is going to have access to the xy.

1508
01:16:37,990 --> 01:16:41,230
它会说好的 一跳 我说我得到了 
It's going to say OK, on jump, I say I got,

1509
01:16:41,230 --> 01:16:45,730
我的回调是由player.x player.y调用的 它碰巧--
I'm getting my callback called with player.x player.Y. And it happens to--

1510
01:16:45,730 --> 01:16:46,990
哦 它不在悬崖上 
oh, it's not at the cliff.

1511
01:16:46,990 --> 01:16:48,030
所以什么都没发生 
So nothing happens.

1512
01:16:48,030 --> 01:16:54,400
或者是悬崖 所以成就 跳下悬崖 解锁才是真的 
Or it is the cliff, so the achievement, jump off cliff, unlocked is true.

1513
01:16:54,400 --> 01:16:57,304
现在的测试并不是每一帧都在进行 
And test now is not happening every single frame,

1514
01:16:57,304 --> 01:16:58,720
否则就有可能
which otherwise would potentially.

1515
01:16:58,720 --> 01:17:03,380
而且它不会阻止你的更新逻辑为您的球员跳跃 
And it's not blocking up your update logic for your player jumping.

1516
01:17:03,380 --> 01:17:03,880
对吧？
Right?

1517
01:17:03,880 --> 01:17:08,790
播放器 播放器内的跳转逻辑 播放器跳转状态 
The player, the jumping logic inside player, the player jumps state,

1518
01:17:08,790 --> 01:17:10,420
不需要知道
doesn't need to know--

1519
01:17:10,420 --> 01:17:13,420
不需要问我们是不是从悬崖上跳下去了 
doesn't need to ask whether or not we've jumped off a cliff.

1520
01:17:13,420 --> 01:17:17,400
我们应该把它写进成就档案里 
That's something that we should just delegate to our achievement file,

1521
01:17:17,400 --> 01:17:18,410
或者随便你怎么说
or whatever you want.

1522
01:17:18,410 --> 01:17:21,070
这就是事件给你的灵活性 
And that's sort of the flexibility that events afford you.

1523
01:17:21,070 --> 01:17:22,570
所以我们使用事件 
So we use event.

1524
01:17:22,570 --> 01:17:24,640
我会在这里简单地讲一下 
I'll touch on this a little bit briefly here.

1525
01:17:24,640 --> 01:17:38,610
但基本上 如果我们在第21.39行进入参与人步行状态 
But basically, if we go to the player walk state on line 21.39, first of all

1526
01:17:38,610 --> 01:17:41,260
我们在检查输入
we're checking for input here.

1527
01:17:41,260 --> 01:17:41,760
对吧？
Right?

1528
01:17:41,760 --> 01:17:44,790
我们只是说如果我们按左 右 上 下 
We're just saying if we press the left, right, up, or down.

1529
01:17:44,790 --> 01:17:50,770
方向是向左走 向右走 等等 
The direction is that walk left, walk right, so on and so forth.

1530
01:17:50,770 --> 01:17:56,530
然后我们调用实体walk state. update 
And then what we do is we call entity walk state.update.

1531
01:17:56,530 --> 01:18:00,790
所以这个存在于实体中的基本状态代码 这样我们就可以
So this base walk state code that exists in entity, so that we can

1532
01:18:00,790 --> 01:18:04,107
让每个实体都有这个代码 
let every single entity have this code.

1533
01:18:04,107 --> 01:18:05,940
它所做的只是检查
All it does just check to see whether or not

1534
01:18:05,940 --> 01:18:09,010
它所属的玩家或实体撞墙 
the player or entity that it belongs to hit a wall.

1535
01:18:09,010 --> 01:18:12,460
如果是这样 那么set there bumped等于true 
And if it did, then set there bumped equals true.

1536
01:18:12,460 --> 01:18:17,160
它所做的只是一面旗帜 上面写着 好吧 玩家撞到了一堵墙 
And what it does is just a flag that says, OK, the player bumped a wall.

1537
01:18:17,160 --> 01:18:17,790
好吗？
OK?

1538
01:18:17,790 --> 01:18:18,900
这有什么关系
Why is that relevant?

1539
01:18:18,900 --> 01:18:23,280
因为在我们打完电话之后 我们可以说 好吧 如果我们撞到了一堵墙 
Because then, after we call that, we can say, OK, if we bumped a wall,

1540
01:18:23,280 --> 01:18:26,340
并且这仅在玩家处于行走状态时发生 
and this only happens when the player walk state,

1541
01:18:26,340 --> 01:18:29,550
如果我们在看左边 暂时调整一下我们的位置 
if we're looking to the left, temporarily adjust our position.

1542
01:18:29,550 --> 01:18:34,590
因为当它撞到你的时候 它会把你打回原来的世界 
Because when it bumps you, it knocks you back out back into the world.

1543
01:18:34,590 --> 01:18:39,030
但我们要重新调整位置到我们相撞的地方 
But we're going to re-bump our position into wherever we collided.

1544
01:18:39,030 --> 01:18:41,820
我们要检查每一个入口 然后
We're going to look at every doorway, and then

1545
01:18:41,820 --> 01:18:46,230
假设我们撞上了门 门开着
we're going to say if we collided with that doorway, and it's open,

1546
01:18:46,230 --> 01:18:48,845
然后我们把它移到门口的中央
then we're going to shift it to the center of the doorway

1547
01:18:48,845 --> 01:18:51,720
这样看起来就不会像玩家在穿墙而过 
so that it doesn't look as if the player is walking through the wall.

1548
01:18:51,720 --> 01:18:54,320
我们要把它设置到墙所在的地方 
We're going to set it to wherever the wall is,

1549
01:18:54,320 --> 01:18:57,510
或者门在哪里 门口的正中央
or wherever the door is, the very center of the doorway.

1550
01:18:57,510 --> 01:19:00,525
然后我们要召集行动调度班
And then we're going to call event.Dispatch shift,

1551
01:19:00,525 --> 01:19:02,010
朝那个方向
and in that direction.

1552
01:19:02,010 --> 01:19:06,280
所以左移 右移 上移 下移 
So shift left, shift right, shift up, and shift down.

1553
01:19:06,280 --> 01:19:10,710
所以这四个不同的例子都会说好的 
And so all of these four different cases are going to say OK,

1554
01:19:10,710 --> 01:19:12,480
玩家撞到了一个门 
the player has hit a doorway.

1555
01:19:12,480 --> 01:19:15,510
我在某个地方有一个功能 
I have a function somewhere.

1556
01:19:15,510 --> 01:19:18,920
事件 打开 向下移动 向左移动 向右移动 向上移动 
Event.on, shift down, shift left, shift right, shift up.

1557
01:19:18,920 --> 01:19:20,312
会触发什么？
That's going to trigger what?

1558
01:19:27,070 --> 01:19:27,990
隔壁房间
The next room.

1559
01:19:27,990 --> 01:19:31,210
它会触发我们移动到下一个房间 也是下一个房间
It's going to trigger us moving to the next room, and also the next room

1560
01:19:31,210 --> 01:19:34,120
产卵 摄像机也在移动位置 
spawning, and the camera sort of shifting position.

1561
01:19:38,830 --> 01:19:43,480
密码在地牢里 
So the code for this is in dungeon.

1562
01:19:43,480 --> 01:19:45,982
所以我们继续看地牢 
So we're going to go ahead and look at dungeon.

1563
01:19:45,982 --> 01:19:50,620
所以就在这里 第29到43行 事件 
So right here, on line 29 through 43, event.on,

1564
01:19:50,620 --> 01:19:54,185
左移 右移 上移 下移 
shift left, shift right, shift up, shift down.

1565
01:19:54,185 --> 01:19:57,320
它所做的是我们有另一个函数 叫做开始转移 
And what that does is we have another function called begin shifting,

1566
01:19:57,320 --> 01:19:58,930
它接受x和y 
which takes in an x and y.

1567
01:19:58,930 --> 01:20:01,786
负虚拟宽度 虚拟宽度 负虚拟高度 
Negative virtual width, virtual width, negative virtual height,

1568
01:20:01,786 --> 01:20:02,410
虚拟高度
virtual height.

1569
01:20:02,410 --> 01:20:06,910
有人记得为什么要把这些数字传进去吗？
Does anybody recall why we need to pass those numbers in there?

1570
01:20:06,910 --> 01:20:11,560
如果我们向左移动 传递一个负的虚拟宽度 
If we're shifting left, and we're passing a negative virtual width,

1571
01:20:11,560 --> 01:20:16,000
你觉得会是多少
what do you think that number is going to be?

1572
01:20:16,000 --> 01:20:19,350
记住每个房间都有相邻的偏移量x和y
So recall every room has an adjacent offset x and y

1573
01:20:19,350 --> 01:20:23,970
它渲染了这个房间 基本上添加了偏移量 
that renders that room with that offset basically added to it.

1574
01:20:23,970 --> 01:20:25,110
它的x和y 
Its x and y.

1575
01:20:25,110 --> 01:20:28,170
如果我们开始向左移动 
So if we begin shifting to the left, negative virtual width

1576
01:20:28,170 --> 01:20:29,340
就是x偏移量 
is going to be the x offset.

1577
01:20:29,340 --> 01:20:35,130
因为那个房间需要向左渲染一个屏幕宽度 对吗？
Because that room needs to be rendered a screen width to the left, right?

1578
01:20:35,130 --> 01:20:37,440
以此类推 以获得正确的虚拟宽度 
And so on for the right, virtual width.

1579
01:20:37,440 --> 01:20:39,180
它将虚拟宽度添加到x偏移 
It adds a virtual width to the x offset.

1580
01:20:39,180 --> 01:20:41,160
相邻的x偏移 
The adjacent x offset.

1581
01:20:41,160 --> 01:20:45,780
然后是虚拟高度 负数和正数表示上移和下移 
And then virtual height, negative and positive for shift up, and shift down.

1582
01:20:45,780 --> 01:20:53,910
所以开始切换 基本上这是一个补间操作 
So begin shifting, basically the gist of this is it's a tween operation.

1583
01:20:53,910 --> 01:21:00,540
所以我们从这里开始 调用timer.tween 只需要取一个值并插值 
So we start here, recall timer.tween, just takes a value and interpolates it.

1584
01:21:00,540 --> 01:21:04,190
self 我们有一个摄像机和一个摄像机y 对吧？
So self, we have a camera and a camera y, right?

1585
01:21:04,190 --> 01:21:06,180
等于x和y的位移 
Going to equal shift x and shift y.

1586
01:21:06,180 --> 01:21:07,320
最终会的
Eventually.

1587
01:21:07,320 --> 01:21:10,020
所以移位x和移位y是相邻的偏移量 所以我们
So shift x and shift y being the adjacent offset, that we're

1588
01:21:10,020 --> 01:21:12,420
需要把相机移开 
going to need to shift the camera by.

1589
01:21:12,420 --> 01:21:17,130
所以X相机和Y相机 它们都是零 总是 
So camera x and camera y, they both sort of zero, always.

1590
01:21:17,130 --> 01:21:20,400
当房间完全完工的时候 
When the room gets completely finalized.

1591
01:21:20,400 --> 01:21:23,870
所以如果移位x是虚拟宽度 负虚拟宽度 
So if the shift x is virtual width, negative virtual width,

1592
01:21:23,870 --> 01:21:25,620
因为我们在向左移动 然后它就会
cause we're shifting left, then it's going

1593
01:21:25,620 --> 01:21:30,750
让摄像机在一秒钟内从右向左移动 对吗？
to tween the camera going from right to left over the span of a second, right?

1594
01:21:30,750 --> 01:21:34,620
然后玩家 玩家x和玩家y 
And then the player, the player x and player y,

1595
01:21:34,620 --> 01:21:39,000
这些基本上都是在这里设置在另一端
those are basically set up here to the opposite end

1596
01:21:39,000 --> 01:21:41,110
房间的另一个房间 
of the room, the next room.

1597
01:21:41,110 --> 01:21:43,230
因此 如果玩家从房间的顶端出发
So if the player is going from the top of the room

1598
01:21:43,230 --> 01:21:47,820
到隔壁房间的底部 它需要得到它的x和y
to the bottom of the next room, it needs to get its x and y

1599
01:21:47,820 --> 01:21:51,360
放在那个位置 隔壁房间的底部 
put in that position, the bottom part of the next room.

1600
01:21:51,360 --> 01:21:57,977
或者隔壁房间的左边部分 如果它们是从右边移动的 对吗？
Or the left part of the next room, if they're moving from the right, right?

1601
01:21:57,977 --> 01:22:00,060
或者它们的右边部分是从左边移动的 
Or the right part of they're moving from the left.

1602
01:22:00,060 --> 01:22:01,768
最下面的部分 如果他们向上移动的话 
And the bottom part if they're moving up.

1603
01:22:01,768 --> 01:22:03,393
如果他们向下移动 则是向上的部分 
And the up part if they're moving down.

1604
01:22:03,393 --> 01:22:04,392
所以这就是所有的作用 
So that's all that does.

1605
01:22:04,392 --> 01:22:06,510
把他们放在正确的位置 在隔壁房间 
Puts them in the right position, on the next room.

1606
01:22:06,510 --> 01:22:08,940
他们两个人 摄像机和播放器 
Tweens both of them, the camera and the player,

1607
01:22:08,940 --> 01:22:11,370
因为球员需要不停地移动到隔壁房间 
because the player needs to keep moving to the next room.

1608
01:22:11,370 --> 01:22:15,390
而且相机需要向上移动 
And the camera needs to shift up.

1609
01:22:15,390 --> 01:22:17,529
当它完成时 我们称其为完成移位 
When it's finished, we call finished shifting,

1610
01:22:17,529 --> 01:22:20,070
这只是一个函数 基本上所有的东西都是0 
which is just a function that says basically everything to 0.

1611
01:22:20,070 --> 01:22:23,040
它将当前房间设置为下一个房间 
It sets the current room to the next room.

1612
01:22:23,040 --> 01:22:26,130
它将摄像机x和所有这些东西都设置为0 
It sets the camera x and all that stuff all to 0,

1613
01:22:26,130 --> 01:22:28,950
然后所有实体和对象都设置为0 
and then all the entities and objects there, it all gets set to 0.

1614
01:22:28,950 --> 01:22:31,170
因此 它们的偏移量为0 
So they are offset to 0.

1615
01:22:31,170 --> 01:22:33,570
所以一切基本上都是正确的 在0.0
So that everything is basically right at 0.0

1616
01:22:33,570 --> 01:22:35,700
再一次 就像一开始一样 
again, just like it was at the very beginning.

1617
01:22:38,400 --> 01:22:40,890
最后但同样重要的是 当我们进入新房间时 
And then last but not least, when we get into the new room,

1618
01:22:40,890 --> 01:22:42,840
我们一开始就把所有的门都打开 
we start with the doors all open.

1619
01:22:42,840 --> 01:22:45,810
然后当我们走进这里的房间时 因为这就是
And then when we get into the room here, because this is all

1620
01:22:45,810 --> 01:22:48,330
在完成的函数中完成 调用 这
done in the finished function, recall, this

1621
01:22:48,330 --> 01:22:52,080
只有在补间结束后才会发生 
will only happen after the tween is completed.

1622
01:22:52,080 --> 01:22:54,120
每个入口都将被设置为False 
Every doorway is going to get set to false.

1623
01:22:54,120 --> 01:22:55,300
打开等于假 
Open equals false.

1624
01:22:55,300 --> 01:22:58,220
所以我们一进隔壁房间所有的门都会关上 
So all the doors will close as soon as we get into the next room,

1625
01:22:58,220 --> 01:22:59,970
在我们做完补丁手术之后 
after we've performed the tween operation.

1626
01:22:59,970 --> 01:23:01,560
然后我们将播放一段门声 
And then we'll play a door sound.

1627
01:23:01,560 --> 01:23:06,540
这就是实际执行移位操作所涉及的代码 
So that's the code involved in actually doing the shift operation.

1628
01:23:06,540 --> 01:23:08,610
所以我们能够触发它 
So we were able to trigger it.

1629
01:23:08,610 --> 01:23:12,390
我们不一定要在玩家漫游状态下执行该代码 
We don't have to necessarily do that code from the player walk state.

1630
01:23:12,390 --> 01:23:16,800
我们只是说 如果球员撞到门口 
We just say if the players collide with the doorway,

1631
01:23:16,800 --> 01:23:20,730
然后调度一个由地牢处理的事件 
then dispatch an event that is handled by dungeon.

1632
01:23:20,730 --> 01:23:25,890
因为地牢有权进入现在的房间 隔壁的房间 以及所有的东西
Because dungeon has access to current room, next room, and all the stuff

1633
01:23:25,890 --> 01:23:28,110
它需要真正地进行这种转变 
that it needs to actually perform that transition.

1634
01:23:28,110 --> 01:23:31,200
所以我们有两个分离的 但它们工作得很好
So we have the two that are sort of decoupled but they work well

1635
01:23:31,200 --> 01:23:32,640
彼此齐头并进 
in tandem with one another.

1636
01:23:32,640 --> 01:23:35,578
那么 有谁对这是如何运作的有疑问吗？
So anybody have questions as to sort of how this works?

1637
01:23:38,970 --> 01:23:40,400
好的 
OK.

1638
01:23:40,400 --> 01:23:42,330
这基本上就是地下城的滚动 
That's essentially the dungeon scrolling.

1639
01:23:42,330 --> 01:23:43,760
这是一次青少年行动 
It's a tween operation.

1640
01:23:43,760 --> 01:23:46,290
这是一个摄像头 一个临时的房间被渲染 
It's a camera, a temporary room gets rendered.

1641
01:23:46,290 --> 01:23:49,130
我们搬到一个临时房间 一切都恢复到0 
We move to a temporary room, everything gets set back to 0.

1642
01:23:49,130 --> 01:23:54,080
然后 这实际上就是那种行为的疯狂循环 
And then it's just a wild loop of that sort of behavior, effectively.

1643
01:23:54,080 --> 01:23:58,190
我们使用事件库在某种程度上清理了整个方面 
And we use the event library to sort of clean up that whole aspect.

1644
01:23:58,190 --> 01:24:01,820
屏幕在这里滚动 这是另一个演示 
And sort of screen scrolling here, just another demonstration.

1645
01:24:01,820 --> 01:24:04,070
我们详细地看过了 但这是一个很好的GIF
We went over it in detail, but this is a nice GIF

1646
01:24:04,070 --> 01:24:07,160
我发现这在某种程度上概括了这意味着什么 
I found that sort of encapsulates what that means.

1647
01:24:07,160 --> 01:24:09,900
模版是我们之前看到的东西 
Stenciling is something that we saw earlier.

1648
01:24:09,900 --> 01:24:14,906
如果我们把它看作一张模板 那么我们
And if we look at this as a stencil, so we

1649
01:24:14,906 --> 01:24:17,030
可以假装这些是心脏的圆圈 
can pretend that these are the circle of the heart,

1650
01:24:17,030 --> 01:24:20,600
而那个长方形是一张模板 
and that rectangle are a stencil.

1651
01:24:20,600 --> 01:24:26,630
然后我们想在这些模板上画一个灰色的矩形 
And then we want to draw this gray rectangle on top of those stencils.

1652
01:24:26,630 --> 01:24:30,330
我们可以使用模板来遮盖特定的部分 这
We can use the stencil to mask out specific parts, which

1653
01:24:30,330 --> 01:24:33,650
否则很难做到这一点 
would otherwise be pretty tough to do.

1654
01:24:33,650 --> 01:24:36,740
我是说 很难有必要 也许是个别
I mean, it's hard to necessarily, maybe individually

1655
01:24:36,740 --> 01:24:41,030
渲染像素 或创建类似如下的形状 
render pixels, or create a shape that sort of looks like this.

1656
01:24:41,030 --> 01:24:43,910
对于许多非常有趣的视觉效果来说要容易得多
Much easier for a lot of very interesting visual effects

1657
01:24:43,910 --> 01:24:46,970
使用任意形状和大小的模板 
to use a stencil of arbitrary shape and size.

1658
01:24:46,970 --> 01:24:48,530
你也可以使用图像 
And you can use images, too.

1659
01:24:48,530 --> 01:24:51,717
你可以使用模具的图像 来创造一些非常酷的效果 
You can use images of stencils, to create some pretty cool effects.

1660
01:24:51,717 --> 01:24:54,050
我们以前讨论过它 当我谈到拱门的时候 
We went over it before, when I talked about the archway.

1661
01:24:54,050 --> 01:24:56,550
所以我不会过多地详述 
So I won't go over into much more detail.

1662
01:24:56,550 --> 01:25:00,260
但是 你可以再一次看到 它到底在哪里？
But again, you can look at that in the, where was it exactly?

1663
01:25:00,260 --> 01:25:04,070
它在房间的功能里 房间里 对不起 
It was in the room function, room class, sorry.

1664
01:25:04,070 --> 01:25:05,410
就在这下面的底部 
Down here at the bottom.

1665
01:25:05,410 --> 01:25:11,870
所以从213行到229行 记住它们是模板函数 
So lines to 213 to 229 recall they're a stencil function.

1666
01:25:11,870 --> 01:25:14,600
这两个函数尤其是您需要使用的
The couple functions in particular that you need to use

1667
01:25:14,600 --> 01:25:18,650
是love.graph 绘制模板的模板 然后
are love.graphics.stencil which draws the stencils, and then

1668
01:25:18,650 --> 01:25:21,830
Love.graph ics.setstenciltest 比较
love.graphics.setstenciltest which compares

1669
01:25:21,830 --> 01:25:25,400
模板将值设置为某个值 并绘制它们
the stencil values to some value, and draws them

1670
01:25:25,400 --> 01:25:27,210
无论该条件是否为真 
whether or not that condition is true.

1671
01:25:27,210 --> 01:25:31,730
所以我们在这里有我们的函数 画四个矩形 
So we have our function here, which draws four rectangles.

1672
01:25:31,730 --> 01:25:33,410
这些都是拱门 
Those are all the archways.

1673
01:25:33,410 --> 01:25:37,220
它将绘制到这些矩形的所有像素替换为值1 
It replaces any pixels that get drawn to those rectangles with the value 1.

1674
01:25:37,220 --> 01:25:39,620
模板值为1 因此模板值为
The stencil value 1, so stencil value is just

1675
01:25:39,620 --> 01:25:44,870
类似于一个隐藏值 它确定图像是否将
like a hidden value that determines whether a image will get

1676
01:25:44,870 --> 01:25:47,210
不管它是不是被模压过的 
drawn if it's being stenciled or not.

1677
01:25:47,210 --> 01:25:52,940
设定模板测试意味着我们正在寻找小于1的任何值 
Set stencil test means that we're looking for anything less than 1.

1678
01:25:52,940 --> 01:25:54,222
我们会画出来的 
And we'll draw that.

1679
01:25:54,222 --> 01:25:56,180
因为玩家将会是1 如果它是
And because the player is going to be 1 if it's

1680
01:25:56,180 --> 01:26:00,530
在任何这些模板矩形上 它都不会
on any of those stencil rectangles, it will not

1681
01:26:00,530 --> 01:26:03,270
如果球员与这些模板矩形重叠 请绘制该球员 
draw the player if it overlaps with those stencil rectangles.

1682
01:26:03,270 --> 01:26:05,150
这就是它通常的工作原理 
And so that's in general how it works.

1683
01:26:05,150 --> 01:26:07,316
你可以这样做 有很多不同的比较 
And you can do, there's a lot different comparisons.

1684
01:26:07,316 --> 01:26:09,650
您可以执行大于1的操作 
You can do greater than 1.

1685
01:26:09,650 --> 01:26:14,750
你可以做迭代模版 这样你就可以增加价值 
You can do iterative stenciling so that you can increment of value.

1686
01:26:14,750 --> 01:26:18,362
您可以使用介于0和255之间的简单值 
You can have simple values go between 0 and 255.

1687
01:26:18,362 --> 01:26:20,820
有很多有趣的效果 你可以用它 
There's a lot of interesting effects you can get with that.

1688
01:26:20,820 --> 01:26:25,292
但我们刚才看到的一般用法是将值设置为1 
But the general use that we just saw is set the values to one,

1689
01:26:25,292 --> 01:26:28,250
如果要绘制它们 请检查它们是否小于1 
and check to see whether they're less than 1, if you want to draw them.

1690
01:26:28,250 --> 01:26:29,795
如果你不想画它们的话 
If you want to not draw them.

1691
01:26:29,795 --> 01:26:32,000
有没有人对模版制作有疑问 
Does anybody have questions how stenciling works,

1692
01:26:32,000 --> 01:26:35,480
以及这些功能是如何工作的？
and how these functions work?

1693
01:26:35,480 --> 01:26:36,412
嗯?
Yeah?

1694
01:26:36,412 --> 01:26:40,195
观众：所以就像用Stat模具把门遮住一样？
AUDIENCE: So like having stat stencil cover up the door?

1695
01:26:40,195 --> 01:26:43,688
所以当你画玩家的时候 你不会真的
So when you draw the player, you won't actually

1696
01:26:43,688 --> 01:26:45,190
在模板上画 [INAUDIBLE] 
draw on the stencil, [INAUDIBLE].

1697
01:26:45,190 --> 01:26:46,300
科尔顿·奥格登：是的 
COLTON OGDEN: Yes.

1698
01:26:46,300 --> 01:26:52,240
所以这就像是让模板矩形越过门口 
So it's like having the stencil rectangles go over the doorway,

1699
01:26:52,240 --> 01:26:57,625
这样当球在他们下面时 球员就不会被抽到 
so that the player will not get drawn when it's underneath them.

1700
01:26:57,625 --> 01:27:01,290
如果我回到有它的幻灯片上 
If I go back to a slide that has it.

1701
01:27:01,290 --> 01:27:03,670
模板在这里 
The stencils are here.

1702
01:27:03,670 --> 01:27:04,870
对吗？
Right?

1703
01:27:04,870 --> 01:27:08,830
我必须通过并弄清楚我需要的确切的XY 
I had to go through and figure out the exact xy that I needed for them.

1704
01:27:08,830 --> 01:27:09,880
而且还有一个--
And there is a--

1705
01:27:09,880 --> 01:27:12,400
您可以做的是 您可以将模板函数
what you can do is you can take that stencil function that

1706
01:27:12,400 --> 01:27:16,291
画出矩形 然后你就可以把它从模具测试中拿出来 
draws the rectangles, and you can just take it out of the stencil test,

1707
01:27:16,291 --> 01:27:16,790
然后你看 
and see.

1708
01:27:16,790 --> 01:27:19,456
实际上 您将能够看到确切的矩形在哪里 
You will actually be able to see where the exact rectangles are.

1709
01:27:19,456 --> 01:27:22,390
因为那样它就会直接画出长方形 
Because then it will just literally draw the rectangles.

1710
01:27:22,390 --> 01:27:26,714
但在这里 基本上就在这里和隔壁房间的位置之间 
But here, basically right between here and where it would be on the next room.

1711
01:27:26,714 --> 01:27:29,380
所以当我们从这里走到隔壁房间时 它仍然是
So that when we go from here over into the next room, it's still

1712
01:27:29,380 --> 01:27:31,240
用模板来刻印它们 
stencils them.

1713
01:27:31,240 --> 01:27:33,670
就在这里 球员要检查他们 
Right here, the player is going to go over them.

1714
01:27:33,670 --> 01:27:35,740
它会将其模板值设置为1 
It's going to set its stencil value to 1.

1715
01:27:35,740 --> 01:27:40,004
它正在检查要呈现的任何小于1的值 
It's checking for anything less than 1 to render.

1716
01:27:40,004 --> 01:27:41,920
所以它不会通过测试 它会
So it's going to fail the test, and it's going

1717
01:27:41,920 --> 01:27:46,370
在这一点上不会抽到那个球员 
to not draw that player at that point.

1718
01:27:46,370 --> 01:27:48,490
因此 它实际上只是掩盖了玩家 
So it's effectively just masking out the player,

1719
01:27:48,490 --> 01:27:50,740
因为我们给它分配了正确的模板值 
because we're assigning it to the right stencil value,

1720
01:27:50,740 --> 01:27:52,617
我们对此进行了正确的比较 
and we're doing the right comparison for it.

1721
01:27:52,617 --> 01:27:53,950
但是 是的 实际上就是这样 
But yeah, that's effectively it.

1722
01:27:53,950 --> 01:27:57,700
只是用它来 因为我们处于一种情况
Just using it to, because we were in a situation

1723
01:27:57,700 --> 01:28:01,690
我们的瓷砖不能干净利落地画出来
where our tiles didn't cleanly lend themselves to drawing over

1724
01:28:01,690 --> 01:28:03,430
球员 你可以做到的 
the player, which you could do.

1725
01:28:03,430 --> 01:28:06,670
你可以在拱门下面画阴影部分 
You could draw the shadow part underneath the archway part,

1726
01:28:06,670 --> 01:28:08,380
然后只需更改渲染顺序 
and then just change the rendering order.

1727
01:28:08,380 --> 01:28:11,560
但我们拥有的电子表格并没有为我们提供这种灵活性 
But the spreadsheet that we had didn't afford us that flexibility.

1728
01:28:11,560 --> 01:28:17,140
因此 我们采用了更有趣的模版方法
So we went with a little more interesting stenciling approach

1729
01:28:17,140 --> 01:28:20,120
为完成任务干杯 
to getting it done.

1730
01:28:20,120 --> 01:28:21,440
我们之前看过这个 
We looked at this earlier.

1731
01:28:21,440 --> 01:28:26,870
所以游戏设计靠的是数据 而不是一堆逻辑 
So game design via data, rather than a bunch of logic.

1732
01:28:26,870 --> 01:28:32,140
所以你越能在游戏中对你的任何东西进行建模
So the more you can sort of get towards modeling your anything in your game

1733
01:28:32,140 --> 01:28:35,005
像这样的数据 你的引擎越灵活 
like data, like this, the more flexible your engine is,

1734
01:28:35,005 --> 01:28:36,880
人们就越容易修改你的游戏 
the easier it is for people to mod your game.

1735
01:28:36,880 --> 01:28:38,290
这一点非常重要 
Which is hugely important.

1736
01:28:38,290 --> 01:28:40,270
你越容易让设计师
And the easier it is for you to let designers

1737
01:28:40,270 --> 01:28:43,160
负责为你的游戏创造资产 
take charge of actually creating assets for your game.

1738
01:28:43,160 --> 01:28:45,880
所以这里我们创建了一个任意的数据集合 
So here we've created an arbitrary collection of data,

1739
01:28:45,880 --> 01:28:48,640
你可以想怎么复杂就怎么复杂
and you can get as complex with this as you want to.

1740
01:28:48,640 --> 01:28:51,400
唯一真正重要的是你的游戏引擎
The only thing that really matters is whether your game engine

1741
01:28:51,400 --> 01:28:54,800
支持这些字段 并相应地对这些字段进行操作 
supports those fields, and acts on those fields accordingly.

1742
01:28:54,800 --> 01:28:56,590
但一旦发生 我是说 
But once it does, I mean, the more things

1743
01:28:56,590 --> 01:29:00,070
你就越有可能添加新的东西 
you add, the more possibilities you have for adding new things.

1744
01:29:00,070 --> 01:29:02,470
所以地精 我们有健康 力量 
So goblin, we have health, strength.

1745
01:29:02,470 --> 01:29:05,330
因此 我们的游戏引擎应该考虑到强度 
So strength should be accounted for in our game engine.

1746
01:29:05,330 --> 01:29:08,080
这是 我们现在谈论的只是一般的抽象意义 
And this is, we're talking in just the general abstract sense now.

1747
01:29:08,080 --> 01:29:10,180
比如说我们在做一个RPG什么的
Let's say we're like making an RPG or something.

1748
01:29:10,180 --> 01:29:12,325
或许这是我们塞尔达游戏的一部分
Or maybe this is part of our Zelda game.

1749
01:29:12,325 --> 01:29:14,200
如果我们再详细一点 
If we got a little bit more detailed with it.

1750
01:29:14,200 --> 01:29:18,379
但是地精将是一个有10点生命的生物 
But goblin is going to be a creature that has 10 health.

1751
01:29:18,379 --> 01:29:20,170
它有两个强度 所以这些值
It's got two strength, so these values will

1752
01:29:20,170 --> 01:29:21,970
当它被创建为一个实体时被加载 
get loaded when it's created as an entity,

1753
01:29:21,970 --> 01:29:24,010
力量是我们的引擎
and strength is some value that our engine

1754
01:29:24,010 --> 01:29:27,130
需要适用于它决定攻击的任何东西 
needs to apply to anything that it decides to attack.

1755
01:29:27,130 --> 01:29:27,630
对吧？
Right?

1756
01:29:27,630 --> 01:29:29,338
你可以在防守上做同样的事情 
You could do the same thing with defense.

1757
01:29:29,338 --> 01:29:30,880
你可以创造任意的东西 
You could create arbitrary things.

1758
01:29:30,880 --> 01:29:32,270
有妖精的质感 
It's got a goblin texture.

1759
01:29:32,270 --> 01:29:33,820
这就是雪碧
So that's the sprite.

1760
01:29:33,820 --> 01:29:36,250
我们在这里定义了一些动画 
We've defined some animations here, which

1761
01:29:36,250 --> 01:29:39,550
你已经看到了如何在我们的游戏引擎中实例化它们 
you've already seen how to instantiate those in our game engine.

1762
01:29:39,550 --> 01:29:43,760
可能是从棍棒开始的 
Maybe it starts off with a club weapon.

1763
01:29:43,760 --> 01:29:49,300
你也可以参考其他类型的Lua文件
And you can also reference other sort of Lua files

1764
01:29:49,300 --> 01:29:54,010
如果你有武器定义文件的话 
that have these definitions, if you have maybe a weapons defs file.

1765
01:29:54,010 --> 01:29:58,030
你可以索引到武器defs俱乐部 然后那个俱乐部项目
You could index into weapons defs club, and then that club item

1766
01:29:58,030 --> 01:30:00,340
也许会有一些自己的特点
will maybe have a bunch of its own characteristics

1767
01:30:00,340 --> 01:30:04,770
当你的游戏引擎加载这个地精def时 
that when your game engine is loading this goblin def,

1768
01:30:04,770 --> 01:30:09,580
它也会加载club def 并实例化一堆特性
it loads in the club def as well, and instantiates a bunch of qualities

1769
01:30:09,580 --> 01:30:13,510
到那个实体上 或者那个项目上 
onto that entity, or that item, that then have

1770
01:30:13,510 --> 01:30:16,600
与游戏引擎相关的行为 
behavior relevant to your game engine.

1771
01:30:16,600 --> 01:30:17,570
侵略性是真的 
Aggressive is true.

1772
01:30:17,570 --> 01:30:21,730
所以如果某个东西是实体的 侵略性的 那么它可能就是人工智能
So if something is entity.Aggressive, then maybe it's AI

1773
01:30:21,730 --> 01:30:23,180
会去找玩家 
will seek out the player.

1774
01:30:23,180 --> 01:30:23,680
对吧？
Right?

1775
01:30:23,680 --> 01:30:24,846
您可以将其设置为False 
And you can set it to false.

1776
01:30:24,846 --> 01:30:27,730
所以现在你可以区分追逐玩家的实体 
So now you can differentiate between entities that chase the player,

1777
01:30:27,730 --> 01:30:31,420
和一些温顺的实体 只是做他们自己随机的事情 
and entities that are sort of docile, and just do their own random thing.

1778
01:30:31,420 --> 01:30:32,127
晚上睡觉 
Sleeps at night.

1779
01:30:32,127 --> 01:30:33,710
也许你的游戏有一个昼夜循环 
Maybe your game has a day/night cycle.

1780
01:30:33,710 --> 01:30:38,080
也许有些实体保持清醒 有些进入睡眠状态 对吗？
Maybe some entities stay awake, and some go into a sleep state, right?

1781
01:30:38,080 --> 01:30:40,630
所以它看起来会说好的 现在是晚上 
So it will look and say OK, it's nighttime,

1782
01:30:40,630 --> 01:30:42,520
这个实体在晚上睡觉吗？
does the entity sleep at night?

1783
01:30:42,520 --> 01:30:43,890
如果是这样的话 没问题 
If it does, OK.

1784
01:30:43,890 --> 01:30:47,500
然后实体改变状态 休眠 对吗？
Then entity change state, sleep, right?

1785
01:30:47,500 --> 01:30:51,131
然后在白天 当白天发生的时候 
And then during the day, when the day happens,

1786
01:30:51,131 --> 01:30:52,630
您将以相反的方式做同样的事情 
you'll do the same thing in reverse.

1787
01:30:52,630 --> 01:30:55,560
你会说如果实体在晚上睡觉 
You'll say if the entity sleeps at night,

1788
01:30:55,560 --> 01:30:57,670
然后你说实体 觉醒是真的 
then you say entity.awake is true.

1789
01:30:57,670 --> 01:30:59,650
或者什么都行 
Or whatever it is.

1790
01:30:59,650 --> 01:31:02,549
将状态更改为清醒、空闲或行走 
Change state awake, or idle, or walking.

1791
01:31:02,549 --> 01:31:03,340
然后是易燃物 
And then flammable.

1792
01:31:03,340 --> 01:31:06,880
也许你有武器可以造成伤害 或者开火 
Maybe you have weapons that shoot damage, or shoot fire.

1793
01:31:06,880 --> 01:31:10,000
或者你有可以发射火焰的手电筒 或者一些--
Or maybe you have torches that shoot fire, or some--

1794
01:31:10,000 --> 01:31:12,220
也许你处在像熔岩一样的水平 
maybe you're in a level that's like lava.

1795
01:31:12,220 --> 01:31:16,900
你知道 如果你触摸其中一块瓷砖 它就会产生易燃效果 
And you know, if you touch one of the tiles, it has a flammable effect.

1796
01:31:16,900 --> 01:31:19,870
如果它是易燃的 可能你的状态也是易燃的 
And if it's flammable, may be your status equals flammable.

1797
01:31:19,870 --> 01:31:21,320
随着时间的推移 你会受到伤害 
You take damage over time.

1798
01:31:21,320 --> 01:31:22,570
然后你改变你的动画 
And you change your animation.

1799
01:31:22,570 --> 01:31:25,090
也许你会被染成红色 或者类似的颜色 
Maybe you'd get tinted red, or something like that.

1800
01:31:25,090 --> 01:31:27,530
但考虑到所有这些不同的可能性 
But thinking about all these different possibilities,

1801
01:31:27,530 --> 01:31:31,030
就像你的引擎所能做的一样 你几乎可以任意地创造
like what your engine is capable of, you can create pretty much arbitrarily

1802
01:31:31,030 --> 01:31:34,390
复杂的数据结构和实体 以及项 
complex data structures and entities, and items,

1803
01:31:34,390 --> 01:31:36,790
和你想要的任何东西 而不是
and whatever you want in your game, without having

1804
01:31:36,790 --> 01:31:38,290
来创建一个妖精职业 
to create a goblin class.

1805
01:31:38,290 --> 01:31:39,850
或者是一个骨架类 
Or a skeleton class.

1806
01:31:39,850 --> 01:31:43,180
或者是一个任意复杂的生物类别 
Or a arbitrarily complex creature class.

1807
01:31:43,180 --> 01:31:48,310
你只需要用属性和模型组合你的生物
You just compose your creature with attributes and model

1808
01:31:48,310 --> 01:31:49,227
它的行为就是这样的 
its behavior that way.

1809
01:31:49,227 --> 01:31:51,810
组成重于继承 我们上周谈到了 
Composition over inheritance, which we talked about last week,

1810
01:31:51,810 --> 01:31:53,180
在游戏设计中非常有价值 
is very valuable in game design.

1811
01:31:53,180 --> 01:31:56,020
这就是Unity的游戏引擎所采用的方法 
And that's what Unity's game engine sort of approaches.

1812
01:31:56,020 --> 01:31:58,840
由于实体是纯实体组件系统 
Because entity is a purely entity component system,

1813
01:31:58,840 --> 01:32:03,940
其中实体被建模为组件的集合
whereby entities are modeled as collections of components

1814
01:32:03,940 --> 01:32:05,290
每个人都做了一些事情 
that each do something.

1815
01:32:05,290 --> 01:32:08,380
我们也几乎可以把它们看作是组件 
And we can sort of almost think of these as components, too.

1816
01:32:08,380 --> 01:32:11,500
尽管是在一种简单得多的表现形式中 
Albeit in a much simpler sort of representation.

1817
01:32:11,500 --> 01:32:14,740
有没有人对此有疑问 或者为什么它有用 
Does anybody have questions of this, or like why it's useful,

1818
01:32:14,740 --> 01:32:18,670
或诸如此类的事？
or anything like that?

1819
01:32:18,670 --> 01:32:20,330
好的 
OK.

1820
01:32:20,330 --> 01:32:24,560
所以我今天最不想谈的就是 我看到了一两个学生
So the last thing I wanted to talk about today, and I saw one or two students

1821
01:32:24,560 --> 01:32:27,440
提到他们多么希望自己知道 或者多么希望我们
were mentioning how they wished they knew, or wish we

1822
01:32:27,440 --> 01:32:31,670
更多地谈了一下当时是如何进行编程的 
talked about a little bit more how programming was done back in the day.

1823
01:32:31,670 --> 01:32:38,220
所以我不一定是6502汇编编程方面的专家 
So I'm not an expert, necessarily, in programming 6502 assembly,

1824
01:32:38,220 --> 01:32:39,786
这就是NES是用来写的 
which is what the NES is written in.

1825
01:32:39,786 --> 01:32:41,910
有很多人在这方面做得很好 
There are a lot of people that are very good at it.

1826
01:32:41,910 --> 01:32:43,118
但这里有一些联系 
But there's a few links here.

1827
01:32:43,118 --> 01:32:47,510
所以在幻灯片中 如果你想看网站上的幻灯片 
So in the slides, if you wanted to look at the slides on the website,

1828
01:32:47,510 --> 01:32:52,160
实际上 自制酒在某些社区中相当受欢迎
Homebrew is actually quite a popular thing amongst certain communities

1829
01:32:52,160 --> 01:32:52,970
上网 
online.

1830
01:32:52,970 --> 01:32:56,180
以及它本质上为编译器带来了什么
And what it is essentially getting compilers

1831
01:32:56,180 --> 01:33:00,770
这将为某些任意处理器或开发编译源代码
that will compile source code for some arbitrary processor, or development

1832
01:33:00,770 --> 01:33:04,040
来自某个任意计算机系统的环境 
environment from some arbitrary computer system.

1833
01:33:04,040 --> 01:33:08,360
像NES一样 它是一台基于8位微处理器的机器
Like the NES, which was a 8-bit microprocessor based machine

1834
01:33:08,360 --> 01:33:11,412
拥有自己的一套有趣的硬件 
with its own set of interesting hardware.

1835
01:33:11,412 --> 01:33:13,370
它允许您为此编译程序集
It allowed you to compile the assembly for that

1836
01:33:13,370 --> 01:33:16,060
并通过一个名为模拟器的程序实际运行它 
and actually run it via a program called an emulator.

1837
01:33:16,060 --> 01:33:21,020
而仿真器只允许您运行ROM映像 或者只运行任意数据
And an emulator just allows you to run ROM images, or just arbitrary data

1838
01:33:21,020 --> 01:33:26,930
它映射到某个系统的机器指令
that maps to the machine instructions of some system

1839
01:33:26,930 --> 01:33:30,980
仿真器已经通过虚拟机进行了仿真 
that the emulator has emulated via virtual machine.

1840
01:33:30,980 --> 01:33:35,539
因此 如果你想更详细地研究它 
And so if you wanted to look into it a little bit more in detail,

1841
01:33:35,539 --> 01:33:36,830
这里有几个链接 
there's a couple of links here.

1842
01:33:36,830 --> 01:33:39,696
所以 NES.wiki有很多很棒的链接 
So NES.wiki has got a bunch of great links.

1843
01:33:39,696 --> 01:33:41,570
有一本编程指南是这样写的
There's a Programming Guide that kind of goes

1844
01:33:41,570 --> 01:33:45,980
关于如何进行一些6502组装以及如何使用NES的基础知识 
over the basics of how to do some 6502 assembly as well as with the NES,

1845
01:33:45,980 --> 01:33:47,810
以及它的特殊硬件 
and its particular hardware.

1846
01:33:47,810 --> 01:33:54,140
然后大多数人使用的编译器被称为CC 65 
And then the compiler that most people use for this is called CC 65,

1847
01:33:54,140 --> 01:33:58,160
它是一个65 02汇编语言编译器 
which is a 65 02 assembly compiler.

1848
01:33:58,160 --> 01:34:02,460
这是一些源代码的一个例子 
And so this is an example of some source code.

1849
01:34:02,460 --> 01:34:04,130
这本书读起来有点难 
It's a little bit tough to read.

1850
01:34:04,130 --> 01:34:07,760
但我不能放大 我想不是 
But I can't zoom in, I don't think.

1851
01:34:07,760 --> 01:34:11,180
但大意是你有很多--
But the gist of it is you have a lot of--

1852
01:34:11,180 --> 01:34:13,305
在这里 实际上我可以在网上调出它 
and here, actually I could pull it up online.

1853
01:34:13,305 --> 01:34:14,110
让我试试看 
Le me try.

1854
01:34:17,270 --> 01:34:20,280
超级马里奥反汇编 
Super Mario disassembly.

1855
01:34:20,280 --> 01:34:23,630
那就去这里吧 
So go here.

1856
01:34:23,630 --> 01:34:24,380
这是在Github上 
This is on Github.

1857
01:34:24,380 --> 01:34:29,930
所以有人反编译 基本上 或者说反汇编 
So somebody decompiled, basically, or disassembled rather,

1858
01:34:29,930 --> 01:34:34,400
获取代表Super的所有机器代码和ROM镜像的字节
took the bytes that represent all the machine code and the ROM image of Super

1859
01:34:34,400 --> 01:34:38,300
Mario Bros 然后将其转换回汇编语言 
Mario Bros and then just converted it back to assembly language,

1860
01:34:38,300 --> 01:34:40,220
然后给它添加了评论 
and then added comments to it.

1861
01:34:40,220 --> 01:34:43,910
因为我不会太详细地讲什么是组装 
Because I won't go into too much detail about what assembly is,

1862
01:34:43,910 --> 01:34:46,190
以及它是如何工作的 但本质上说 它只是
and how it works, but essentially it's just

1863
01:34:46,190 --> 01:34:50,750
直接位于机器代码上方的一层 其中关键字
a layer directly above machine code where the keywords

1864
01:34:50,750 --> 01:34:54,170
映射到内存中的基本字节数
map to essentially what are bytes in memory

1865
01:34:54,170 --> 01:34:55,850
它们实际上是程序指令 
that are actually program instructions.

1866
01:34:55,850 --> 01:34:59,810
这会影响你的CPU的行为 这样你就可以得到程序 
And that influence the behavior of your CPU such that you get programs.

1867
01:34:59,810 --> 01:35:05,000
而这就是c语言的基础 在它的每一种语言中 
And that's what c is layered on top of, an in every language thereof,

1868
01:35:05,000 --> 01:35:06,390
之后 
thereafter.

1869
01:35:06,390 --> 01:35:10,709
所以如果我放大这里 看看我能不能 
So if I zoom in here, see if I can.

1870
01:35:10,709 --> 01:35:11,750
它有点慢了 
It's being a little slow.

1871
01:35:11,750 --> 01:35:15,740
但它让我--
But it's letting me--

1872
01:35:15,740 --> 01:35:18,020
所以我们可以在这里看到 
so here we can see.

1873
01:35:20,840 --> 01:35:23,240
我认为它滞后是因为文件太大了 
I think it's lagging because the file is just so large.

1874
01:35:23,240 --> 01:35:25,960
这就像是14000行代码 
It's like 14,000 lines of code.

1875
01:35:25,960 --> 01:35:30,050
因为组装是一件很长很长的事情 
Because the thing about assembly is assembly is a very, very long.

1876
01:35:30,050 --> 01:35:31,730
因为有太多的--
Because there are so many--

1877
01:35:31,730 --> 01:35:33,980
你需要有 就像真的很慢 
you need to have, just like really slowly.

1878
01:35:33,980 --> 01:35:36,380
无限放大 
Zooming in infinitely.

1879
01:35:36,380 --> 01:35:39,950
你需要做的步骤太多了
There are just so many steps you need to do in order

1880
01:35:39,950 --> 01:35:43,730
为了实现像C这样的高级语言所实现的相同功能 
to achieve the same thing that you get in a high level language like C,

1881
01:35:43,730 --> 01:35:47,270
甚至比这更高的语言 
or even languages higher than that.

1882
01:35:47,270 --> 01:35:50,810
认为很多事情都是理所当然的 特别是像加载这样的事情
Taking a lot of things for granted, especially things like loading

1883
01:35:50,810 --> 01:35:51,320
寄存器 
registers.

1884
01:35:51,320 --> 01:35:54,620
所以每个CPU都有一系列可以存储数值的寄存器 
So every CPU has got a series of registers that can store values,

1885
01:35:54,620 --> 01:35:58,190
然后CPU有逻辑 你基本上可以
and then the CPU has logic that you can basically

1886
01:35:58,190 --> 01:36:02,520
说OK 如果寄存器A中的值大于或等于某个值 
say OK, if the value in register a is greater than or equal to some value,

1887
01:36:02,520 --> 01:36:06,770
然后转移到汇编代码的这个序列 
then branch to this sequence of the assembly code.

1888
01:36:06,770 --> 01:36:12,547
通常 您必须在字节级执行和/或操作 
And often you'll have to do things like and/or operations on byte level,

1889
01:36:12,547 --> 01:36:13,130
仅以字节为单位 
just on bytes.

1890
01:36:13,130 --> 01:36:18,130
就像这里 我们可以看到我们正在结束值3
Like right here, we can see we're ending the value 3 on whatever

1891
01:36:18,130 --> 01:36:20,300
在登记簿a中 
is in register a.

1892
01:36:20,300 --> 01:36:23,930
就像我说的 不要太过沉迷于什么是组装 
Like I said, don't intend to get too much into what assembly is.

1893
01:36:23,930 --> 01:36:28,760
但对于那些好奇游戏是如何在80年代实现的 甚至
But for those curious as to how games were implemented in the '80s, and even

1894
01:36:28,760 --> 01:36:31,400
90年代早期 都是用汇编语言
the early '90s, it was all in assembly language.

1895
01:36:31,400 --> 01:36:33,920
因为汇编语言就是你
Because assembly language is you're literally

1896
01:36:33,920 --> 01:36:37,880
对你要编程的机器的CPU进行编程 
programming the CPU of whatever machine you're trying to program.

1897
01:36:37,880 --> 01:36:41,660
这就是你如何获得尽可能多的效率 
And that's how you get as much efficiency as possible.

1898
01:36:41,660 --> 01:36:46,040
如果你了解你的计算环境 你就知道你的CPU能做什么 
If you know your computing, environment you know what your CPU is capable of.

1899
01:36:46,040 --> 01:36:51,110
关于编译像C C++ 或Java这样的语言 
The thing about compiling a language like C, or C++, or Java,

1900
01:36:51,110 --> 01:36:53,480
这是一个比那些更高的抽象 
which is even higher of an abstraction than those,

1901
01:36:53,480 --> 01:36:57,160
就是你允许某种算法为你做这些工作 
is you're allowing sort of algorithms to do the work for you.

1902
01:36:57,160 --> 01:37:01,310
你允许算法把你的源代码
You're allowing algorithms to take your source code

1903
01:37:01,310 --> 01:37:03,800
然后把它变成这样
and turn it into this, basically.

1904
01:37:03,800 --> 01:37:05,810
比这层低一层 有效 
A layer lower than this, effectively.

1905
01:37:05,810 --> 01:37:08,210
这是它所产生的一个中间层次 
This is an intermediary level that it does generate.

1906
01:37:08,210 --> 01:37:12,320
但可以说 在80年代和90年代 
But suffice to say, in the '80s and '90s,

1907
01:37:12,320 --> 01:37:17,059
C编译器在创建游戏方面不如人类 
C compilers were not as good as humans were in creating games,

1908
01:37:17,059 --> 01:37:19,850
特别是做很多他们需要做的棘手的事情 
especially to do a lot of the tricky things that they needed to do,

1909
01:37:19,850 --> 01:37:24,980
为了让它们在处理器上高效地工作 在当时 
in order to get them working efficiently on processors that were, at the time,

1910
01:37:24,980 --> 01:37:26,750
1到3兆赫的速度 
one to three megahertz in speed.

1911
01:37:26,750 --> 01:37:31,070
现在我们有三个千兆赫的处理器 这没什么大不了的 
Which now we have like three gigahertz processors, and it's no big deal.

1912
01:37:31,070 --> 01:37:35,990
但这实际上是一个窗口 
But that is effectively, that's sort of a window

1913
01:37:35,990 --> 01:37:40,160
80年代和90年代开发游戏的情况 
into what it was like developing games in the '80s and '90s.

1914
01:37:40,160 --> 01:37:43,130
然后在90年代 像N64 Playstation 1这样的东西 
And then in the '90s, with like things like N64 Playstation 1,

1915
01:37:43,130 --> 01:37:49,190
在Playstation 2上 等等 它通常是用一种语言完成的 
going onto Playstation 2, and so forth, it was typically done in a language

1916
01:37:49,190 --> 01:37:50,960
比如C或C++ 
like C or C++.

1917
01:37:50,960 --> 01:37:53,120
有时候有一些变种 
Sometimes with some variants.

1918
01:37:53,120 --> 01:37:55,970
某些游戏机 如PS3有一个臭名昭著的困难的图形
Certain consoles, like the PS3 has a notoriously difficult graphics

1919
01:37:55,970 --> 01:37:57,390
处理器编程 
processor to program.

1920
01:37:57,390 --> 01:38:01,070
所以很多PS3的三个团队需要在汇编中编程 
So a lot of PS3 three teams needed to program in assembly,

1921
01:38:01,070 --> 01:38:05,600
即使是在2007年 2009年 
even at the time, which was 2007, 2009.

1922
01:38:05,600 --> 01:38:11,240
但这就是 简而言之 它就像编程的65 02 
But that's, in a nutshell, what it's like programming the 65 02.

1923
01:38:11,240 --> 01:38:14,270
如果你想看上面的链接 
So if you want, those links up above, it's

1924
01:38:14,270 --> 01:38:16,550
一个很有启发性的经历
a pretty enlightening experience actually digging

1925
01:38:16,550 --> 01:38:19,820
并试图理解大会的工作 
into that sort of thing, and trying to make sense of what the assembly does.

1926
01:38:19,820 --> 01:38:25,310
这很困难 也很繁重 因为
It's quite difficult, and quite burdensome because of how long

1927
01:38:25,310 --> 01:38:28,820
这些程序是什么 每个指令是多么的微小 
these programs are, and just how minute each individual instruction is.

1928
01:38:28,820 --> 01:38:32,300
就像只是检查 只是把一个值加载到一个寄存器 
Like just checking, just loading a value into a register,

1929
01:38:32,300 --> 01:38:36,320
循环通常只是迭代地加载一个值
just to do a loop often will just be iteratively loading a value

1930
01:38:36,320 --> 01:38:37,220
到一个寄存器 
into a register.

1931
01:38:37,220 --> 01:38:41,030
然后像执行一些操作 或计算 从那里 
And then like performing some operation, or calculation, off of that.

1932
01:38:41,030 --> 01:38:43,100
然后分支到其他代码循环 
And then branching to some other loop of code.

1933
01:38:43,100 --> 01:38:46,230
很多内容都可以压缩成几行C语言 
A lot of that can be condensed into like just a couple of lines of C,

1934
01:38:46,230 --> 01:38:48,710
或者更少的Lua行 
or even fewer lines of Lua.

1935
01:38:48,710 --> 01:38:52,520
所以更多的负担 但有洞察力 
So a lot more of a burden but there is insight.

1936
01:38:52,520 --> 01:38:54,770
肯定是对深入调查的一些见解
Definitely some insight into digging a little deeper

1937
01:38:54,770 --> 01:38:56,250
看向那里
and sort of looking there.

1938
01:38:56,250 --> 01:38:59,300
这些都是NES开发wiki上的链接 
So once again, those are the links on the NES dev wiki.

1939
01:38:59,300 --> 01:39:02,330
Wiki.NESdev.com如果你有兴趣看的话 
Wiki.NESdev.com if you're interested in looking at that.

1940
01:39:02,330 --> 01:39:06,500
在作业5中 就像你在作业4中做的那样 
In Assignment 5, like you did in Assignment 4,

1941
01:39:06,500 --> 01:39:09,020
你可以创建一个可消耗的游戏对象 
you can create a game object that's consumable.

1942
01:39:09,020 --> 01:39:13,060
可以随意使用作业4中的代码来完成此任务 
And feel free to use code from Assignment 4 to do this.

1943
01:39:13,060 --> 01:39:16,890
当你定义你的消费函数时 
When like you define your on consume function,

1944
01:39:16,890 --> 01:39:21,550
如果你们打算采用和上次作业相同的模式 那么有什么想法吗
if you're going to adopt the same model as the last assignment, then any ideas

1945
01:39:21,550 --> 01:39:23,514
我们该怎么做
as to what we need to do?

1946
01:39:26,460 --> 01:39:31,030
可能只是增加了破坏实体的反义词 对吧？
Probably just add the opposite of damage the entity, right?

1947
01:39:31,030 --> 01:39:32,910
我们想添加心脏 
We want to add hearts.

1948
01:39:32,910 --> 01:39:35,760
我们希望将HP添加到其中 
We want to add HP to it.

1949
01:39:35,760 --> 01:39:41,100
你会看到在发行版中health被建模为偶数 
And you'll see in the distro that health is modeled as an even number,

1950
01:39:41,100 --> 01:39:43,970
因为每一个数字都是半颗心 
because every one digit is half a heart.

1951
01:39:43,970 --> 01:39:44,526
是的
Yes.

1952
01:39:44,526 --> 01:39:46,900
问：你能给一个负数吗？
AUDIENCE: Can you give a negative number to [INAUDIBLE]??

1953
01:39:46,900 --> 01:39:48,690
科尔顿·奥格登：你可以 
COLTON OGDEN: You can.

1954
01:39:48,690 --> 01:39:51,300
这实际上也是同样的事情 
And that will effectively be the same thing, too.

1955
01:39:51,300 --> 01:39:53,460
是的
So.

1956
01:39:53,460 --> 01:39:55,930
第二部分是包括锅 
The second part is including pots.

1957
01:39:55,930 --> 01:39:57,570
所以在精灵表中有罐子 
So there are pots in the sprite sheet.

1958
01:39:57,570 --> 01:39:58,791
所以这些应该是实心的 
So these should be solid.

1959
01:39:58,791 --> 01:40:00,540
当玩家与他们互动时 
So when the player interacts with them, he

1960
01:40:00,540 --> 01:40:04,870
应该把他赶出去
should be bumped out of where he was.

1961
01:40:04,870 --> 01:40:06,120
让玩家举起它们 
Allow the player to lift them.

1962
01:40:06,120 --> 01:40:09,036
所以在精灵表中有一个动画 它实际上允许--
So there's an animation in the sprite sheet that will actually allow--

1963
01:40:09,036 --> 01:40:11,730
显示玩家举起罐子
that shows the player lifting up the pot.

1964
01:40:11,730 --> 01:40:15,630
所以你可能需要一个新的状态 玩家举罐状态 
So you probably need a new state, player lift pot state.

1965
01:40:15,630 --> 01:40:16,710
与大麻州同行 
Walk with pot state.

1966
01:40:16,710 --> 01:40:18,330
不管你怎么定义它 
Whatever you want to define it as.

1967
01:40:18,330 --> 01:40:22,920
但你基本上需要有这两个人 才能让这件事起作用 
But you'll need basically to have those two in order to get this to work.

1968
01:40:22,920 --> 01:40:25,770
我们需要做的一件事是什么？
What's one thing that we'll need to do in order for the player

1969
01:40:25,770 --> 01:40:26,580
抬起锅来 
to lift the pot.

1970
01:40:26,580 --> 01:40:29,340
有什么主意吗？
Any ideas?

1971
01:40:29,340 --> 01:40:34,320
除了渲染方面 例如 当玩家四处走动时 
Besides the rendering aspect of it, when the player walks around, for example,

1972
01:40:34,320 --> 01:40:36,540
需要采取什么措施？
what needs to happen?

1973
01:40:36,540 --> 01:40:38,889
如果他拿着罐子的话 
If he's holding the pot.

1974
01:40:38,889 --> 01:40:40,577
观众：他比较慢 
AUDIENCE: He's slower.

1975
01:40:40,577 --> 01:40:42,160
科尔顿·奥格登：你可以让他慢一点 
COLTON OGDEN: You can make him slower.

1976
01:40:42,160 --> 01:40:43,170
是的 这是有可能的 
Yeah, that's possible.

1977
01:40:43,170 --> 01:40:45,240
这不是作业所必需的 
That's not required for the assignment.

1978
01:40:45,240 --> 01:40:46,890
比这更基本的 
More fundamental than that.

1979
01:40:49,674 --> 01:40:51,840
赌注需要追踪玩家的位置 对吗？
The pot needs to track the player's location, right?

1980
01:40:51,840 --> 01:40:53,881
它需要相对于球员的位置 
It needs to be relative to the player's location.

1981
01:40:53,881 --> 01:40:59,337
因此 保持赌注可能比玩家高出一小部分 
So keep the pot probably above the player by some amount.

1982
01:40:59,337 --> 01:41:01,420
对于如何实现这一点 我不会太挑剔 
I won't be too picky as to how you implement that.

1983
01:41:01,420 --> 01:41:04,680
但博彩需要跟踪玩家 
But the pot needs to track the player.

1984
01:41:04,680 --> 01:41:06,240
实际上 这就是下一点 
Which is this next point, actually.

1985
01:41:06,240 --> 01:41:07,770
行走的动画 就像我说的 应该
And the walking animations, like I said, should

1986
01:41:07,770 --> 01:41:09,420
在他们拿着的时候换衣服 
change while they're carrying it.

1987
01:41:09,420 --> 01:41:11,430
最后 允许玩家投掷水壶 
Allow the player, lastly, to throw the pot.

1988
01:41:11,430 --> 01:41:15,150
所以当你扔罐子的时候 基本上就是把罐子变成了抛射物 
So when you throw the pot, basically turn the pot into a projectile.

1989
01:41:15,150 --> 01:41:18,442
如果它撞到了其中一面墙 就把它打破 
If it hits one of the walls, break it.

1990
01:41:18,442 --> 01:41:21,150
您可以只是立即取消绘制 或有一些动画 
You can either just despawn it instantly, or have some animation.

1991
01:41:21,150 --> 01:41:21,960
由你决定 
It's up to you.

1992
01:41:21,960 --> 01:41:25,200
但是 如果它撞到了墙 就放弃它 
But just, if it hits a wall, despawn it.

1993
01:41:25,200 --> 01:41:28,140
触发它--可能只是触发它到一些值 假 
Trigger it to-- maybe just trigger it to some values, false.

1994
01:41:28,140 --> 01:41:31,140
渲染是假的 无论你想做什么 
Render is false, whatever you want to do.

1995
01:41:31,140 --> 01:41:35,640
如果它击中敌人 它应该会对敌人造成一次伤害 
If it hits an enemy, it should damage the enemy by one,

1996
01:41:35,640 --> 01:41:37,140
就像我们已经看到的一样 
just like we've seen already.

1997
01:41:37,140 --> 01:41:39,420
如果它运行的距离超过四块瓷砖 
And if it travels farther than four tiles,

1998
01:41:39,420 --> 01:41:43,390
除了还撞到其中一堵墙 然后把它也毁了 
in addition to also hitting one of the walls, then destroy it too.

1999
01:41:43,390 --> 01:41:47,430
这些都是作业5的主要组成部分 
So those are the main components for Assignment 5.

2000
01:41:47,430 --> 01:41:51,750
而你实现大部分目标的方式是相当灵活的 
And the ways that which you achieve most of it's fairly flexible.

2001
01:41:51,750 --> 01:41:55,170
但没错 这就是第五课 塞尔达传奇 
But yeah, that's Lecture 5, Legend of Zelda.

2002
01:41:55,170 --> 01:41:56,070
所以感谢你们的光临 
So thanks for coming.

2003
01:41:56,070 --> 01:41:58,235
下次见 
I'll see you next time.
