1
00:00:00,500 --> 00:00:04,374
[音乐播放]

2
00:00:16,540 --> 00:00:19,690
科尔顿·奥格登：好的 欢迎来到GD50 第5堂课 

3
00:00:19,690 --> 00:00:23,320
今天的主题是塞尔达的传说 正如你在屏幕上看到的那样 

4
00:00:23,320 --> 00:00:25,030
一款非常标志性的游戏 

5
00:00:25,030 --> 00:00:28,660
上周 我们制作了《超级马里奥兄弟》 它可以说是最具标志性的视频游戏

6
00:00:28,660 --> 00:00:29,200
史无前例的 

7
00:00:29,200 --> 00:00:31,162
塞尔达传奇是一个势均力敌的竞争者 

8
00:00:31,162 --> 00:00:34,120
即使是现在 就像马里奥一样 他们也在制作非常精彩的比赛 

9
00:00:34,120 --> 00:00:39,250
我想去年《野性的呼吸》夺走了所有的 我忘了是哪一个

10
00:00:39,250 --> 00:00:41,830
这是一场颁奖典礼 或者说颁奖典礼 

11
00:00:41,830 --> 00:00:44,470
但它几乎囊括了所有可能的奖项 

12
00:00:44,470 --> 00:00:46,960
就在去年 最新的塞尔达 野性的呼吸 

13
00:00:46,960 --> 00:00:50,650
因此 在这样的背景下谈论塞尔达传奇感觉有点不合时宜

14
00:00:50,650 --> 00:00:51,724
也是 

15
00:00:51,724 --> 00:00:53,890
以下是原版《塞尔达传奇》的截图 

16
00:00:53,890 --> 00:00:57,386
这是NES的头衔 就像超级马里奥兄弟一样--

17
00:00:57,386 --> 00:00:59,260
就像它那个时代的大多数游戏一样 以瓷砖为基础 

18
00:00:59,260 --> 00:01:04,269
你可以在某种程度上看到周围是如何一点点地分层的瓷砖 

19
00:01:04,269 --> 00:01:08,470
这个游戏的总体目标是探索这个开放的世界 这

20
00:01:08,470 --> 00:01:11,112
这在这方面还是头一回 

21
00:01:11,112 --> 00:01:13,650
您控制了Link 如最下面所示 

22
00:01:13,650 --> 00:01:16,360
你有剑 你有炸弹 你有箭 

23
00:01:16,360 --> 00:01:19,030
你想去找红宝石 你得穿过地牢 

24
00:01:19,030 --> 00:01:22,120
你杀死了怪物和头目 然后最终的目标

25
00:01:22,120 --> 00:01:25,930
是为了获得左上角和右上角所示的三重力

26
00:01:25,930 --> 00:01:27,690
在这里的幻灯片 

27
00:01:27,690 --> 00:01:30,190
这是一个截图 塞尔达传奇的另一个截图 

28
00:01:30,190 --> 00:01:32,770
在一个真正的地牢里 你可以在最上面看到 

29
00:01:32,770 --> 00:01:34,420
有一个类似于地图的布局 

30
00:01:34,420 --> 00:01:36,340
地图在某种程度上是在网格中排列的 

31
00:01:36,340 --> 00:01:40,960
你可以一个房间一个房间地进去 这样每个房间都是整个宽度

32
00:01:40,960 --> 00:01:45,160
和屏幕高度 寻找 解决谜题 寻找物品 

33
00:01:45,160 --> 00:01:46,390
这类事情 

34
00:01:46,390 --> 00:01:47,890
你可以看到那里有一个怪物 

35
00:01:47,890 --> 00:01:49,473
你们的心在最右上角 

36
00:01:49,473 --> 00:01:51,880
所以当你受到伤害时 心脏就会减少 

37
00:01:51,880 --> 00:01:55,990
会看到这两个方面 游戏的心和地牢的一面 

38
00:01:55,990 --> 00:02:00,460
今天的讲座 以及房间的宽度和高度

39
00:02:00,460 --> 00:02:01,630
成为一块地牢瓷砖 

40
00:02:01,630 --> 00:02:02,789
以及控制一个化身 

41
00:02:02,789 --> 00:02:05,080
但这是一个有代表性的屏幕截图 

42
00:02:05,080 --> 00:02:07,515
这场比赛看起来像是回到了过去 

43
00:02:07,515 --> 00:02:09,639
今天我们要讨论的一些话题

44
00:02:09,639 --> 00:02:12,760
来实现像这样的游戏引擎的基础

45
00:02:12,760 --> 00:02:15,500
可能看起来像是自上而下的透视法 

46
00:02:15,500 --> 00:02:17,410
如你所见 在这个截图中 我们

47
00:02:17,410 --> 00:02:20,650
在鸟瞰视图中从最高处俯瞰林肯 与之相反

48
00:02:20,650 --> 00:02:24,880
到我们过去看马里奥的方式 从侧面 在哪里

49
00:02:24,880 --> 00:02:28,360
它有点像侧滚轴 

50
00:02:28,360 --> 00:02:31,040
在这里 我们实际上是自上而下地看事情 

51
00:02:31,040 --> 00:02:36,850
所以我们以一种不同的视角来看待这个房间 

52
00:02:36,850 --> 00:02:39,155
从技术上讲 这并不是一个真正的z轴 

53
00:02:39,155 --> 00:02:40,030
但在某种程度上是有的 

54
00:02:40,030 --> 00:02:42,970
您可以在游戏引擎中实现像重力这样的东西 如下所示

55
00:02:42,970 --> 00:02:44,992
通过跳跃洞穴之类的方式 

56
00:02:44,992 --> 00:02:47,200
但没有像《超级马里奥》那样的重力 

57
00:02:47,200 --> 00:02:49,390
当你从左向右走的时候 你会跳过缝隙 

58
00:02:49,390 --> 00:02:51,950
从这个意义上来说 这是很容易看到的 

59
00:02:51,950 --> 00:02:54,860
我们将谈论无限的地牢世代 

60
00:02:54,860 --> 00:02:57,700
因此 在今天的例子中 我们将

61
00:02:57,700 --> 00:03:00,985
看看我们如何着手实施一个像你这样的地牢

62
00:03:00,985 --> 00:03:03,901
可以永远持续下去 以及如何对其进行建模

63
00:03:03,901 --> 00:03:07,150
让它看起来就像你一遍又一遍地穿过地牢 

64
00:03:07,150 --> 00:03:10,400
在不同的房间里通过不同的屏幕 这些房间都是不同的 

65
00:03:10,400 --> 00:03:13,210
但在现实中 我们会看到它实际上只是一个错觉 就像我们

66
00:03:13,210 --> 00:03:15,280
在以前的课程中见过 

67
00:03:15,280 --> 00:03:17,470
我们来谈谈打击手和伤兵手 还有什么？

68
00:03:17,470 --> 00:03:18,960
两者之间的区别在于 

69
00:03:18,960 --> 00:03:22,660
希特盒是屏幕上的矩形 造成伤害

70
00:03:22,660 --> 00:03:25,630
在您的游戏世界中的其他实体上 以及伤害盒

71
00:03:25,630 --> 00:03:29,020
某种程度上是一个矩形 用来模拟你的玩家 

72
00:03:29,020 --> 00:03:33,750
或者游戏中的实体可能被其他命中框伤害的地方 

73
00:03:33,750 --> 00:03:34,820
好的 看看这些事件 

74
00:03:34,820 --> 00:03:39,610
因此 事件是一种传播一些关键信息的方式 这些信息告诉

75
00:03:39,610 --> 00:03:41,650
游戏世界哦 这件事发生了 

76
00:03:41,650 --> 00:03:46,610
并让我注册一个函数 以便在处理该事件时调用 

77
00:03:46,610 --> 00:03:50,170
因此 在某些事件上 调度一个事件 然后

78
00:03:50,170 --> 00:03:53,210
在该事件被监听它的任何东西接收时 

79
00:03:53,210 --> 00:03:54,400
执行这段代码 

80
00:03:54,400 --> 00:03:56,740
它允许您在某种程度上分离游戏的各个方面

81
00:03:56,740 --> 00:03:59,710
对引擎进行了一点改进 并使代码更具可读性 

82
00:03:59,710 --> 00:04:02,334
并允许你用成就做一些有趣的事情 

83
00:04:02,334 --> 00:04:05,740
例如 您不一定要拉动每一帧 

84
00:04:05,740 --> 00:04:09,250
哦 我在这个框架里做了这种武断的事情清单吗？

85
00:04:09,250 --> 00:04:12,070
相反 你可以通过一个事件来处理所有这些事情 

86
00:04:12,070 --> 00:04:16,990
有一个监听器和一个功能 每次你播放捡硬币的时候 

87
00:04:16,990 --> 00:04:19,839
也许我的成就就像是 

88
00:04:19,839 --> 00:04:23,170
我是如何在这个关卡里捡到50枚硬币的 

89
00:04:23,170 --> 00:04:28,440
然后 您的事件中的成就回调函数可以查找它 

90
00:04:28,440 --> 00:04:31,130
在你的游戏循环中 你不必说每一帧 

91
00:04:31,130 --> 00:04:34,690
如果一名玩家有850枚硬币 你可以说

92
00:04:34,690 --> 00:04:39,010
通过这种方式去掉你整个游戏循环中可能存在的臃肿 

93
00:04:39,010 --> 00:04:41,979
在今天的课程中 我们将看到一个如何使用它的例子 

94
00:04:41,979 --> 00:04:43,270
我们将查看屏幕滚动 

95
00:04:43,270 --> 00:04:47,230
所以《塞尔达传奇》的一个非常标志性的方面

96
00:04:47,230 --> 00:04:49,720
就是当你从一个屏幕转到另一个屏幕时 

97
00:04:49,720 --> 00:04:53,500
当一个屏幕加载而另一个屏幕加载时 会有一种过渡期

98
00:04:53,500 --> 00:04:54,730
就会消失 

99
00:04:54,730 --> 00:04:59,620
在硬件上 在NES中 这是唯一的方法

100
00:04:59,620 --> 00:05:04,840
您实际上可以渲染超过一个屏幕宽度的瓷砖 

101
00:05:04,840 --> 00:05:07,180
实际上 您必须动态加载切片并进行排序

102
00:05:07,180 --> 00:05:09,790
覆盖在此之前存在于内存中的磁贴 

103
00:05:09,790 --> 00:05:12,220
但今天 我们将看看如何创造出

104
00:05:12,220 --> 00:05:15,340
只要画一间房间就能做到这一点的错觉

105
00:05:15,340 --> 00:05:18,240
然后有了我们的主房间 然后就像是补丁一样 

106
00:05:18,240 --> 00:05:21,360
然后将所有内容设置回原点为0.0 

107
00:05:21,360 --> 00:05:24,120
这让我们看起来就像是在

108
00:05:24,120 --> 00:05:26,911
这些房间 而实际上我们所做的只是换班 

109
00:05:26,911 --> 00:05:28,680
然后把一切都恢复到0.0 

110
00:05:28,680 --> 00:05:32,655
所以 如果可以的话 我会在屏幕上说明这一点 

111
00:05:32,655 --> 00:05:35,280
我们最后要讨论的一件事是数据驱动设计 

112
00:05:35,280 --> 00:05:39,240
在许多类型的游戏的背景下 特别是RPG和动作

113
00:05:39,240 --> 00:05:44,010
在游戏中 能够为你所有的物品建模通常是非常有价值的 

114
00:05:44,010 --> 00:05:46,440
实体 某种能力 任何你真正想要的东西

115
00:05:46,440 --> 00:05:51,780
可以 作为数据而不是逻辑 为了让你更容易写一个 

116
00:05:51,780 --> 00:05:55,530
第二 你可以分配你游戏的设计方面

117
00:05:55,530 --> 00:05:57,630
给其他人 而不仅仅是程序员 

118
00:05:57,630 --> 00:05:59,670
并有一个非常通用的发动机 

119
00:05:59,670 --> 00:06:02,370
和模型 我们将看看我们是如何实现

120
00:06:02,370 --> 00:06:05,410
这在某种程度上为以后的研究奠定了基础 

121
00:06:05,410 --> 00:06:09,540
但首先 我想为今天的课程演示一个演示 

122
00:06:09,540 --> 00:06:11,982
这是塞尔达传奇的一种实现 

123
00:06:11,982 --> 00:06:14,940
今天有没有人愿意来演示一下这个

124
00:06:14,940 --> 00:06:15,480
在课堂上？

125
00:06:19,232 --> 00:06:21,580
太棒了 

126
00:06:21,580 --> 00:06:24,460
非常感谢 

127
00:06:24,460 --> 00:06:29,274
所以 只要你准备好了 就继续按那里的Return键 

128
00:06:29,274 --> 00:06:30,770
[音乐播放]

129
00:06:30,770 --> 00:06:34,560
所以我们在屏幕上看到 50岁的传奇 这是我们的塞尔达传奇

130
00:06:34,560 --> 00:06:35,370
你敲竹杠 

131
00:06:35,370 --> 00:06:36,720
因此 您按Enter键 

132
00:06:36,720 --> 00:06:39,000
你进入 这就是游戏的发挥状态 

133
00:06:39,000 --> 00:06:40,880
所以你控制了一个化身 

134
00:06:40,880 --> 00:06:42,040
你可以四处走走 

135
00:06:42,040 --> 00:06:44,520
他可以与开关互动 就像我们在这里看到的那样 

136
00:06:44,520 --> 00:06:47,240
当他按下开关时 门就会打开 

137
00:06:47,240 --> 00:06:51,000
一旦门打开了 你就可以走进去了

138
00:06:51,000 --> 00:06:54,720
而且 正如我之前提到的 它将屏幕转换为

139
00:06:54,720 --> 00:06:59,320
整个屏幕的高度或宽度取决于向上和向下的方向 

140
00:06:59,320 --> 00:07:02,790
我们现在看到 我们按空格键实际上是在挥舞我们的剑 

141
00:07:02,790 --> 00:07:05,830
它正在摧毁游戏空间中的实体 

142
00:07:05,830 --> 00:07:10,170
所以当你按下碰撞的空格键时会触发Hitbox

143
00:07:10,170 --> 00:07:11,940
与游戏世界中的其他实体 

144
00:07:11,940 --> 00:07:15,720
如果希特箱击中了他们的伤害箱 那么他们就会被标记为死亡 

145
00:07:15,720 --> 00:07:17,890
他们从游戏世界中消失了 

146
00:07:17,890 --> 00:07:19,510
所以这就是无止境的 

147
00:07:19,510 --> 00:07:20,760
这只是一个无尽的地牢 

148
00:07:20,760 --> 00:07:24,600
这样他就可以进入我们想要的楼层之间 

149
00:07:24,600 --> 00:07:27,667
我们所做的就是每次我们穿过一扇门 生出一个新房间 

150
00:07:27,667 --> 00:07:30,500
删除旧的 然后继续下去 永远 

151
00:07:30,500 --> 00:07:33,333
在像塞尔达传奇这样的游戏中 它通常不会像这样工作 

152
00:07:33,333 --> 00:07:38,220
有固定数量的房间 它们都以一种2D阵列的形式存在 

153
00:07:38,220 --> 00:07:40,590
当你产生你的地牢时 你可以说

154
00:07:40,590 --> 00:07:43,460
必须考虑到我把钥匙放在哪里之类的事情 

155
00:07:43,460 --> 00:07:44,460
我该把老板放在哪里？

156
00:07:44,460 --> 00:07:45,590
我该把宝藏放在哪里？

157
00:07:45,590 --> 00:07:46,381
这类事情 

158
00:07:46,381 --> 00:07:51,000
我们不会太深入地讨论如何实现像这样的复杂算法 

159
00:07:51,000 --> 00:07:54,120
但我们会稍微谈一谈 也许会谈到一些想法

160
00:07:54,120 --> 00:07:55,230
这是我们拥有的 

161
00:07:55,230 --> 00:07:58,150
最后 如果我们只是--如果我们想演示--

162
00:07:58,150 --> 00:08:00,540
如果我们能看到左上角 我们的心就在那里 

163
00:08:00,540 --> 00:08:02,580
这是塞尔达的标志性作品 

164
00:08:02,580 --> 00:08:05,810
当我们确实受到敌人的伤害时 注意到我们会有一点闪烁 

165
00:08:05,810 --> 00:08:07,800
所以有一些渲染行为被触发 

166
00:08:07,800 --> 00:08:09,759
当我们受到伤害时 我们就变得无懈可击 

167
00:08:09,759 --> 00:08:11,883
最后 当我们终于接受最后一击的时候 

168
00:08:11,883 --> 00:08:14,190
我们在屏幕上看到一个小游戏 使用的是塞尔达字体 

169
00:08:14,190 --> 00:08:15,320
简而言之 这就是游戏 

170
00:08:15,320 --> 00:08:16,780
我们按Enter键并循环返回 

171
00:08:16,780 --> 00:08:19,364
总体来说很简单 但有很多片段

172
00:08:19,364 --> 00:08:21,030
在这里 我们从来没有真正看到过 

173
00:08:21,030 --> 00:08:24,910
因此 非常感谢你们前来演示这款游戏 

174
00:08:24,910 --> 00:08:25,410
好的 

175
00:08:25,410 --> 00:08:31,320
这就是《50岁的传奇》、《塞尔达传奇》的演示 

176
00:08:31,320 --> 00:08:33,419
它有很多塞尔达拥有的东西 

177
00:08:33,419 --> 00:08:35,220
当然 它还没有完全充实起来 

178
00:08:35,220 --> 00:08:38,368
作为像塞尔达这样的完整游戏 这将是一个巨大的游戏 

179
00:08:38,368 --> 00:08:40,409
我们还需要考虑很多因素 

180
00:08:40,409 --> 00:08:42,210
但基础就在那里 

181
00:08:42,210 --> 00:08:46,290
我们有地牢的基础 我们可以在上面建造一个真正的发电机 

182
00:08:46,290 --> 00:08:47,370
如果我们想的话 

183
00:08:47,370 --> 00:08:48,240
我们有实体 

184
00:08:48,240 --> 00:08:49,140
我们有命中率高的 

185
00:08:49,140 --> 00:08:51,970
我们可以很容易地建模 因为我们在游戏中有开关 

186
00:08:51,970 --> 00:08:53,995
我们可以对宝物箱这样的东西进行建模

187
00:08:53,995 --> 00:08:57,120
打开有不同的状态 就像开关有不同的状态一样 

188
00:08:57,120 --> 00:09:00,690
并让我们游戏空间中的不同对象与其他对象互动 

189
00:09:00,690 --> 00:09:04,270
我们在这里有很多东西 今天我们将讨论所有的东西 

190
00:09:04,270 --> 00:09:07,440
这里有几个截图 只是为了展示我们刚刚看到的东西 

191
00:09:07,440 --> 00:09:10,170
我们的目标主要是第二个截图 

192
00:09:10,170 --> 00:09:12,690
在右上角 这是播放状态 它具有

193
00:09:12,690 --> 00:09:14,560
我们刚刚看到的所有小碎片 

194
00:09:14,560 --> 00:09:17,429
但为了把这一切联系起来 我们这里确实有一个开始状态 

195
00:09:17,429 --> 00:09:19,470
以及一场与国家相关的博弈

196
00:09:19,470 --> 00:09:22,390
传到左上角的心脏 

197
00:09:22,390 --> 00:09:27,300
所以我要谈的第一件事是 我们把发动机组装好了

198
00:09:27,300 --> 00:09:30,970
是 我们要把我们的资产投入到游戏中去吗？

199
00:09:30,970 --> 00:09:33,960
就像之前的课程一样 在今天之前 

200
00:09:33,960 --> 00:09:36,210
我们只有一个精灵床单 就像我们对马里奥所做的那样 

201
00:09:36,210 --> 00:09:40,560
其中所有内容都以相当均匀的瓷砖分段顺序进行布局 

202
00:09:40,560 --> 00:09:43,710
在本例中 线段为16x16像素 

203
00:09:43,710 --> 00:09:48,270
在这里 我叠加了一个网格 只是为了显示图片确实是完美的16

204
00:09:48,270 --> 00:09:48,930
到16岁 

205
00:09:48,930 --> 00:09:51,790
这是你应该考虑的事情 

206
00:09:51,790 --> 00:09:54,439
当你构建你的游戏资产时 你会有意识地这样做 

207
00:09:54,439 --> 00:09:56,230
让它很容易被切成小块 

208
00:09:56,230 --> 00:10:01,800
这样你就可以通过一些四边形的表格来索引这个精灵了 

209
00:10:01,800 --> 00:10:04,260
然后为任何对象分配ID 

210
00:10:04,260 --> 00:10:07,410
或要渲染到屏幕上的平铺 

211
00:10:07,410 --> 00:10:11,130
所以我们看到 如果你看这里 像门这样的东西 

212
00:10:11,130 --> 00:10:14,640
它们并不是由一块瓷砖完美地塑造出来的 

213
00:10:14,640 --> 00:10:18,270
所以当你有大于16乘以16的东西时 

214
00:10:18,270 --> 00:10:23,820
这并不像拥有具有该帧ID实体或对象那样简单 

215
00:10:23,820 --> 00:10:25,110
并将其绘制到屏幕上 

216
00:10:25,110 --> 00:10:27,776
您实际上需要稍微复杂一点的呈现逻辑 

217
00:10:27,776 --> 00:10:30,150
所以随便说说 如果我想画一扇门 

218
00:10:30,150 --> 00:10:32,780
有没有人对我如何建模有什么建议？

219
00:10:32,780 --> 00:10:33,988
或者把它画到屏幕上？

220
00:10:39,310 --> 00:10:49,870
因此 如果我们的门不是16x16像素的瓷砖 

221
00:10:49,870 --> 00:10:54,540
现在 我们需要做的就是存储所有四个

222
00:10:54,540 --> 00:10:57,810
在这种情况下 这些瓷砖 或至少跟踪有多少瓷砖

223
00:10:57,810 --> 00:11:01,260
你的目标是 

224
00:11:01,260 --> 00:11:03,290
然后只需根据一些偏移量绘制它们 

225
00:11:03,290 --> 00:11:06,940
具有表示该对象左上角的XY 

226
00:11:06,940 --> 00:11:09,870
把它放在正确的位置 而不是只画一个瓷砖 

227
00:11:09,870 --> 00:11:11,430
我们画了四块瓷砖 

228
00:11:11,430 --> 00:11:15,831
然后 不是只有一个16乘16瓦的碰撞凸起 

229
00:11:15,831 --> 00:11:17,080
你可以做几件事 

230
00:11:17,080 --> 00:11:20,340
您可以检查所有四个瓷砖上的碰撞 

231
00:11:20,340 --> 00:11:24,180
或者至少是所有的两块门砖 或者是你自己定制的打印件

232
00:11:24,180 --> 00:11:28,230
然后 可能代表门口的对象可以控制的框 

233
00:11:28,230 --> 00:11:31,860
所以你可以说门口撞到了玩家 然后门口

234
00:11:31,860 --> 00:11:37,890
它的高度和宽度是多少像素 它在这里是宽是高 

235
00:11:37,890 --> 00:11:39,030
只有门的这一部分 

236
00:11:39,030 --> 00:11:44,310
然后 您可以在不只有一块瓷砖的基础上构建

237
00:11:44,310 --> 00:11:46,710
在您的游戏空间中为对象或实体建模 

238
00:11:46,710 --> 00:11:48,700
但现在你有了更多的艺术灵活性 

239
00:11:48,700 --> 00:11:52,710
你可以做一些事情 比如有超过一个像素宽的门口 

240
00:11:52,710 --> 00:11:55,699
因此 游戏世界变得更有说服力了 

241
00:11:55,699 --> 00:11:57,990
你会在RPG这样的游戏中看到很多类似的东西

242
00:11:57,990 --> 00:12:02,880
在那里 你有满座的房子 显然不仅仅是一块瓷砖 

243
00:12:02,880 --> 00:12:06,360
如果你愿意 你可以用一块瓷砖来建模 

244
00:12:06,360 --> 00:12:10,540
但从艺术的角度 从游戏引擎的角度来看 

245
00:12:10,540 --> 00:12:13,020
它以编程方式更容易一些

246
00:12:13,020 --> 00:12:18,190
能够将你所有的资产切成瓷砖 然后这样画出来 

247
00:12:18,190 --> 00:12:22,500
所以能够在单人精灵的基础上

248
00:12:22,500 --> 00:12:24,930
并且能够用多个精灵来表示

249
00:12:24,930 --> 00:12:30,480
物体是房屋、大树等事物的关键 

250
00:12:30,480 --> 00:12:34,710
比我们在这里看到的单一瓷砖更复杂的东西 

251
00:12:34,710 --> 00:12:39,160
正如你所看到的 角色的精灵工作表有点复杂 

252
00:12:39,160 --> 00:12:42,000
这是一个带有填充的精灵工作表的示例 

253
00:12:42,000 --> 00:12:45,630
有时你会得到没有被整齐分割的精灵床单

254
00:12:45,630 --> 00:12:46,657
分成偶数段 

255
00:12:46,657 --> 00:12:47,490
这是有充分理由的 

256
00:12:47,490 --> 00:12:50,850
因为有时候你的瓷砖不是很完美

257
00:12:50,850 --> 00:12:53,850
游戏引擎的瓷砖的宽度和高度 

258
00:12:53,850 --> 00:12:57,692
在这种情况下 播放器实际上是20像素高 16像素宽 

259
00:12:57,692 --> 00:13:00,150
最重要的是 他有不同的动画画面 

260
00:13:00,150 --> 00:13:03,330
我们可以在左下角看到 他有一个挥剑的动画 

261
00:13:03,330 --> 00:13:06,930
挥剑动画实际上存储在32×32像素的帧中 

262
00:13:06,930 --> 00:13:10,590
因为有时取决于他看的角度 

263
00:13:10,590 --> 00:13:12,820
他的精灵可以变大一点 也可以变小一点 

264
00:13:12,820 --> 00:13:16,350
所以当你有一个带衬垫的精灵 什么是一种

265
00:13:16,350 --> 00:13:19,740
我们可以可靠地把这个画到屏幕上吗？

266
00:13:19,740 --> 00:13:22,170
我们该如何考虑这一点呢？

267
00:13:22,170 --> 00:13:24,360
我们将如何呈现带有填充的屏幕精灵？

268
00:13:28,150 --> 00:13:32,560
所以让我们假设这个精灵 我们的角色挥舞着一把剑 是在32

269
00:13:32,560 --> 00:13:34,670
乘以32像素框 

270
00:13:34,670 --> 00:13:35,200
对吗？

271
00:13:35,200 --> 00:13:37,810
在这附近的这个盒子 这个空白空间 

272
00:13:37,810 --> 00:13:40,810
但他仍然可能只有16个像素宽乘20个像素高 

273
00:13:40,810 --> 00:13:43,994
或者 也许他在某种程度上与此类似 

274
00:13:43,994 --> 00:13:46,910
为了把他吸引到屏幕上 你可以在代码中看到 

275
00:13:46,910 --> 00:13:50,170
我们真正需要做的就是为那个精灵分配一个偏移量 

276
00:13:50,170 --> 00:13:52,315
只要说 好的 这个精灵的偏移量x和偏移量

277
00:13:52,315 --> 00:13:57,670
Y是一些值 基本上可以让我们绘制精灵

278
00:13:57,670 --> 00:14:00,940
为负的x和负的y值 

279
00:14:00,940 --> 00:14:03,910
这将使精灵向上移动 使其完美地对齐

280
00:14:03,910 --> 00:14:05,650
无论他的XY在哪里 

281
00:14:05,650 --> 00:14:09,490
您可以查看代码以了解它到底是如何工作的 

282
00:14:09,490 --> 00:14:13,079
最后 我们游戏世界的实际实体是不同的生物 

283
00:14:13,079 --> 00:14:16,120
这是一张精灵图--这是一张更理想的精灵图

284
00:14:16,120 --> 00:14:18,792
是16x16像素宽和高 

285
00:14:18,792 --> 00:14:21,250
我们在这里真正做的就是分好精灵床单

286
00:14:21,250 --> 00:14:26,470
使用常规实用函数生成16个16的四边形 

287
00:14:26,470 --> 00:14:30,640
我们不必担心所有东西都有不同的宽度和高度 

288
00:14:30,640 --> 00:14:34,570
正因为如此 我们才能非常简单地制作动画 

289
00:14:34,570 --> 00:14:38,260
顺便说一句 当我在解析时 我喜欢做的事情

290
00:14:38,260 --> 00:14:42,870
或者当我拼接一张有很多单独框架的精灵纸时 

291
00:14:42,870 --> 00:14:45,130
尤其是在我创作动画的时候 或者我只是

292
00:14:45,130 --> 00:14:49,120
需要知道对于一个瓷砖 一个特定的瓷砖要画到屏幕上 

293
00:14:49,120 --> 00:14:52,311
手动查看每一块瓷砖是一种痛苦 

294
00:14:52,311 --> 00:14:52,810
差一分 

295
00:14:52,810 --> 00:14:54,580
然后说好的 这是一个 但是好的 

296
00:14:54,580 --> 00:14:57,040
但如果我想找出粘液是哪一种 

297
00:14:57,040 --> 00:14:59,630
我数了一下 好的 这个有多少像素宽？

298
00:14:59,630 --> 00:15:02,330
好的 然后是4乘以12 

299
00:15:02,330 --> 00:15:07,030
然后它在第五排 所以12乘以4加1会得到 好的 

300
00:15:07,030 --> 00:15:09,520
所以它的指数是49 

301
00:15:09,520 --> 00:15:12,940
所以我花了相当多的时间

302
00:15:12,940 --> 00:15:14,920
计算所有这些都做了什么 

303
00:15:14,920 --> 00:15:18,820
我编写了一个简单的Python脚本 它只会遍历一个文件 

304
00:15:18,820 --> 00:15:23,290
只需在每个单独的四元组中添加一个数字 

305
00:15:23,290 --> 00:15:26,650
让你一目了然地看到每个精灵是什么 

306
00:15:26,650 --> 00:15:30,460
这包括发行版 所以你可以看到它是什么样子的 

307
00:15:30,460 --> 00:15:31,660
节省了很多时间 

308
00:15:31,660 --> 00:15:34,840
我建议尝试一下 当你在处理资产的时候

309
00:15:34,840 --> 00:15:37,484
你发现自己在做一件需要很长时间的事情 

310
00:15:37,484 --> 00:15:39,400
这可能有点繁琐和机械

311
00:15:39,400 --> 00:15:41,691
试着找到一种自动化的方法 或者至少

312
00:15:41,691 --> 00:15:43,420
让事情变得更容易一目了然 

313
00:15:43,420 --> 00:15:47,187
在这种情况下 只需简单地施加一个数字网格就可以解决这个问题 

314
00:15:47,187 --> 00:15:49,270
我不需要花很多时间

315
00:15:49,270 --> 00:15:52,930
找出幽灵面向左侧的动画的哪一帧 

316
00:15:52,930 --> 00:15:58,120
我立刻就知道它是67、68和69 这让我可以把事情搞砸

317
00:15:58,120 --> 00:16:00,350
升得快得多 

318
00:16:00,350 --> 00:16:04,870
所以我们首先要看的是一种自上而下的视角 

319
00:16:04,870 --> 00:16:07,840
我们之前主要讨论过这个问题 早些时候 

320
00:16:07,840 --> 00:16:12,500
但它实际上只是一张我们以前见过的瓷砖地图 

321
00:16:12,500 --> 00:16:16,120
唯一的不同是 现在不是从侧面看事情 

322
00:16:16,120 --> 00:16:18,290
我们只是从上面看事情 

323
00:16:18,290 --> 00:16:21,880
那么最明显的考虑可能是什么呢？

324
00:16:21,880 --> 00:16:27,460
在设计自上而下的透视图而不是侧边滚动时

325
00:16:27,460 --> 00:16:29,860
观点是什么？

326
00:16:29,860 --> 00:16:32,620
特别关注瓷砖是如何绘制的？

327
00:16:32,620 --> 00:16:33,696
最突出的是什么？

328
00:16:37,030 --> 00:16:39,250
所以对我来说最突出的是我们

329
00:16:39,250 --> 00:16:42,790
这里的墙壁上有影子之类的东西 

330
00:16:42,790 --> 00:16:46,960
我们也有角落 和所有的东西

331
00:16:46,960 --> 00:16:51,220
是倾斜的 以至于它们几乎像是稍微旋转了一下 就好像它们

332
00:16:51,220 --> 00:16:56,890
模拟相对于相机从上方朝上的旋转角度 

333
00:16:56,890 --> 00:16:58,970
例如 你可以在播放器上看到这一点 

334
00:16:58,970 --> 00:17:01,960
看起来你是在上下打量他 

335
00:17:01,960 --> 00:17:07,150
当你以这种方式为你的资产建模时 它更有说服力 

336
00:17:07,150 --> 00:17:10,030
泽尔达总是这样做 让你的资产看起来

337
00:17:10,030 --> 00:17:13,004
就好像它们略微倾斜 你抬头看着上面 

338
00:17:13,004 --> 00:17:14,920
所以当你设计一个自上而下的游戏时 只要

339
00:17:14,920 --> 00:17:20,200
为了令人信服 为了更有说服力 试着效仿一下 

340
00:17:20,200 --> 00:17:23,650
这里的实体 比如骨架 等等 

341
00:17:23,650 --> 00:17:25,690
更直截了当一点 

342
00:17:25,690 --> 00:17:28,259
蝙蝠和泥巴之类的东西 尽管他们仍然

343
00:17:28,259 --> 00:17:29,800
有一点那样的外表 

344
00:17:29,800 --> 00:17:33,250
就像蜘蛛一样 它看起来有点像是从上到后的 

345
00:17:33,250 --> 00:17:37,600
但从自上而下的角度对你的资产进行建模 主要是这件事 

346
00:17:37,600 --> 00:17:39,910
注意阴影和高光 它们

347
00:17:39,910 --> 00:17:43,930
增加了很多方面 让我们相信我们是在这个有灯光的房间里 

348
00:17:43,930 --> 00:17:48,850
还要确保你做的事情像是拐角之类的

349
00:17:48,850 --> 00:17:54,490
而且 它看起来似乎是稍微倾斜的旋转方向 

350
00:17:54,490 --> 00:17:58,090
我们要看的第一件事是发行版中的代码

351
00:17:58,090 --> 00:18:00,170
就是地牢一代 

352
00:18:00,170 --> 00:18:05,180
所以在塞尔达传说中 地下城是固定的 

353
00:18:05,180 --> 00:18:08,500
它们完全是设计师事先设定的 

354
00:18:08,500 --> 00:18:10,960
在大多数游戏中 实际情况就是这样 

355
00:18:10,960 --> 00:18:13,600
在我们的例子中 以及其他几个例子中 

356
00:18:13,600 --> 00:18:16,210
其中一个主要的例子是我能想到的 

357
00:18:16,210 --> 00:18:19,750
我在幻灯片中看到了一个著名的游戏 叫做《艾萨克的装订》 

358
00:18:19,750 --> 00:18:23,000
也可以生成地下城 

359
00:18:23,000 --> 00:18:27,280
那么 地下城的主单元是什么样的呢？

360
00:18:27,280 --> 00:18:29,080
至少在《塞尔达传奇》的背景下是这样？

361
00:18:29,080 --> 00:18:32,350
如果你必须提炼出地下城的组成成分 

362
00:18:32,350 --> 00:18:34,000
最基本的单位是什么？

363
00:18:36,811 --> 00:18:37,311
托尼 

364
00:18:37,311 --> 00:18:37,811
一个房间 

365
00:18:37,811 --> 00:18:38,500
是 

366
00:18:38,500 --> 00:18:39,680
一个房间 

367
00:18:39,680 --> 00:18:43,940
所以我们几乎可以看到这一点 如果我们用2D阵列来描述它 

368
00:18:43,940 --> 00:18:44,570
对吗？

369
00:18:44,570 --> 00:18:47,650
我们有 假设这类似于指数1.1

370
00:18:47,650 --> 00:18:52,580
在Lua中是0.0 在其他语言中是从左到右、从上到下 

371
00:18:52,580 --> 00:18:56,100
基本上 我们有开或关 相对于每一个 

372
00:18:56,100 --> 00:18:59,030
关 开 关 

373
00:18:59,030 --> 00:19:03,320
这个2D数组中的每个索引都有一个空间 

374
00:19:03,320 --> 00:19:08,810
因此 这个房间在其他房间之间有隐含的联系 

375
00:19:08,810 --> 00:19:12,290
如果你想去 比方说 从这个房间到这个房间

376
00:19:12,290 --> 00:19:16,670
在它上面 就2D数组而言 偏移量是多少？

377
00:19:16,670 --> 00:19:18,860
我们要怎么从这个房间走到这个房间？

378
00:19:23,420 --> 00:19:25,490
所以我们只是上升了一级 对吗？

379
00:19:25,490 --> 00:19:27,920
这是x级3 y级3 

380
00:19:27,920 --> 00:19:31,636
如果我们想上到隔壁房间 我们需要上车 

381
00:19:31,636 --> 00:19:33,260
如果我们用泽尔达的方式来做 对吗？

382
00:19:33,260 --> 00:19:34,310
我们只是要去--

383
00:19:34,310 --> 00:19:36,500
我们在一个房间和一个房间之间做过渡

384
00:19:36,500 --> 00:19:42,410
对另一个人来说 我们需要做的就是在这个房间里装东西 

385
00:19:42,410 --> 00:19:45,809
在y上减去1 然后执行转换 

386
00:19:45,809 --> 00:19:47,600
然后将其设置为当前房间 例如

387
00:19:47,600 --> 00:19:51,200
现在我们知道我们处于y水平2 x水平3 

388
00:19:51,200 --> 00:19:52,220
那是我们的地牢 

389
00:19:52,220 --> 00:19:56,810
在塞尔达传说中的2D地下城的背景下 

390
00:19:56,810 --> 00:19:58,430
这就像它的实际情况一样简单 

391
00:19:58,430 --> 00:20:00,980
你有一个由地牢房间组成的2D网格 

392
00:20:00,980 --> 00:20:04,100
每个房间都有自己的实体和对象集合

393
00:20:04,100 --> 00:20:06,650
以及与其他房间的联系 

394
00:20:06,650 --> 00:20:12,020
但实际上 填充地牢所要做的就是以一种智能的方式填充数组

395
00:20:12,020 --> 00:20:15,372
使得不存在例如它们自己留下的房间 

396
00:20:15,372 --> 00:20:18,080
请注意 地牢中的每个房间都至少有一个连接

397
00:20:18,080 --> 00:20:21,110
去另一个房间 

398
00:20:21,110 --> 00:20:23,690
当你在做你的算法时

399
00:20:23,690 --> 00:20:27,470
为了创造一个令人信服的地下城 让我们假设这里的这个房间有

400
00:20:27,470 --> 00:20:31,710
右边有一扇门 门上有锁 

401
00:20:31,710 --> 00:20:32,870
对吗？

402
00:20:32,870 --> 00:20:36,312
我们要确保钥匙不在那个房间里 

403
00:20:36,312 --> 00:20:38,020
因为如果是的话 我们永远都不会是

404
00:20:38,020 --> 00:20:41,010
能够到达它 假设我们来自另一个方向 

405
00:20:41,010 --> 00:20:43,880
所以当你按程序设计地牢时 

406
00:20:43,880 --> 00:20:46,350
你想把这些事情都考虑进去 

407
00:20:46,350 --> 00:20:47,850
然后 例如 老板的房间 

408
00:20:47,850 --> 00:20:49,880
假设这是老板的房间 老板的房间

409
00:20:49,880 --> 00:20:52,970
应该有一把老板的钥匙之类的 

410
00:20:52,970 --> 00:20:57,300
但显然 老板的钥匙不应该在那个房间里 

411
00:20:57,300 --> 00:21:01,840
它应该在某个地方 也许前面还有几个房间

412
00:21:01,840 --> 00:21:06,260
有一把锁或一把钥匙 这样你就知道有某种挑战

413
00:21:06,260 --> 00:21:07,520
卷入了你的地牢 

414
00:21:07,520 --> 00:21:11,460
这不是像我们以前做的那样只是随机的 

415
00:21:11,460 --> 00:21:14,960
必须有一些有意识的设计来代表

416
00:21:14,960 --> 00:21:16,640
你的算法 

417
00:21:16,640 --> 00:21:19,370
今天我们做的事情完全是随机的

418
00:21:19,370 --> 00:21:22,760
作为说明 仅仅因为像这样的系统是相当健壮和复杂的 

419
00:21:22,760 --> 00:21:26,504
但只要付出一些努力 您就可以创建一个简单的地下城生成器

420
00:21:26,504 --> 00:21:27,170
那些机械师 

421
00:21:27,170 --> 00:21:29,140
只要确保你锁上门就行了 

422
00:21:29,140 --> 00:21:31,265
只有当你有钥匙时 锁着的门才能打开 

423
00:21:31,265 --> 00:21:33,800
确保钥匙放在可以接近的地方 

424
00:21:33,800 --> 00:21:38,090
并在某种程度上创建了一个控制流的链 

425
00:21:38,090 --> 00:21:42,830
模型可以通过某种图形来表示你的地牢 

426
00:21:42,830 --> 00:21:45,950
以及它的进程 

427
00:21:45,950 --> 00:21:48,600
这就是塞尔达地牢的样子 

428
00:21:48,600 --> 00:21:52,430
这就是2D地牢在这种视角下的样子 

429
00:21:52,430 --> 00:21:55,490
而且它看起来--它看起来会和其他游戏引擎中的类似 

430
00:21:55,490 --> 00:21:57,890
它不一定要被完美地建模

431
00:21:57,890 --> 00:22:01,860
作为一个屏幕宽度 屏幕高度空间变成另一个屏幕宽度 屏幕

432
00:22:01,860 --> 00:22:02,360
房间很宽敞 

433
00:22:02,360 --> 00:22:07,610
您可以拥有任意复杂的房间 这些房间的大小可以任意复杂

434
00:22:07,610 --> 00:22:10,590
和形状 

435
00:22:10,590 --> 00:22:14,180
但你仍然需要确保房间外的连接 

436
00:22:14,180 --> 00:22:18,110
如果你还能做左、右、上、下的模型 如果你想的话 

437
00:22:18,110 --> 00:22:21,140
您可以对房间之间的任意数量的连接进行建模 

438
00:22:21,140 --> 00:22:24,230
只要确保你有可以解决的谜题 

439
00:22:24,230 --> 00:22:28,610
这是产生你的地下城的主要障碍 

440
00:22:28,610 --> 00:22:32,360
这是一款我非常喜欢的游戏 它使用了塞尔达传奇的古老公式

441
00:22:32,360 --> 00:22:33,890
现在效果非常好 

442
00:22:33,890 --> 00:22:35,300
这叫做《以撒的捆绑》 

443
00:22:35,300 --> 00:22:38,840
请注意 我们已经可以立即看到它是自上而下的透视图 

444
00:22:38,840 --> 00:22:42,740
整个房间的宽度和高度都是--

445
00:22:42,740 --> 00:22:46,700
整个屏幕的宽度和高度都是地下城的房间 

446
00:22:46,700 --> 00:22:51,140
这里有一张地图 上面显示 好的 我就在这个房间里 

447
00:22:51,140 --> 00:22:52,850
我可以上去 我可以往左走 

448
00:22:52,850 --> 00:22:54,590
我可以向右走 我可以往下走 

449
00:22:54,590 --> 00:22:56,680
上面这个黄色皇冠的房间 那是

450
00:22:56,680 --> 00:22:58,880
会被锁在某个门后面 拿着钥匙 

451
00:22:58,880 --> 00:23:02,840
所以我们需要有在这些房间里产生的钥匙

452
00:23:02,840 --> 00:23:05,635
只是盲目地接近而已 

453
00:23:05,635 --> 00:23:07,760
艾萨克做事情的方式也有点不同

454
00:23:07,760 --> 00:23:09,980
因为它随机生成密钥和炸弹 

455
00:23:09,980 --> 00:23:11,600
这样你就可以真正得到--

456
00:23:11,600 --> 00:23:15,860
你不一定要把钥匙放在非常特定的位置 

457
00:23:15,860 --> 00:23:19,100
如果您的算法足够灵活和足够复杂 

458
00:23:19,100 --> 00:23:22,970
你可以在每个房间的尽头 有机会随机产生一把钥匙 

459
00:23:22,970 --> 00:23:25,520
如果你幸运 或者如果你不幸运 假设

460
00:23:25,520 --> 00:23:29,540
地牢的尽头并不存在于你锁着的门后面 

461
00:23:29,540 --> 00:23:33,500
你有机会拖延并锁上那些门 或者不 

462
00:23:33,500 --> 00:23:36,570
并在需要的时候穿过你的地牢 

463
00:23:36,570 --> 00:23:39,260
在这种情况下 他们不会锁上老板的门 

464
00:23:39,260 --> 00:23:42,500
这样 无论你有没有钥匙 你都可以通过老板的门 

465
00:23:42,500 --> 00:23:45,980
所以他们已经适应了这种纯粹随机的方法 

466
00:23:45,980 --> 00:23:49,940
这正好说明了你如何仍然可以采取随机化

467
00:23:49,940 --> 00:23:53,240
使用非常复杂的原理 并制作游戏

468
00:23:53,240 --> 00:23:55,520
非常令人上瘾和有趣的东西 

469
00:23:55,520 --> 00:24:00,380
而且你也不一定要非常详细 

470
00:24:00,380 --> 00:24:01,700
第一件事 好的 

471
00:24:01,700 --> 00:24:03,840
因此 热门话题和伤害性话题将成为下一个话题 

472
00:24:03,840 --> 00:24:07,430
所以 我想在代码中谈一谈 我们是如何在地下城

473
00:24:07,430 --> 00:24:09,610
这是游戏引擎中的一代 

474
00:24:09,610 --> 00:24:11,000
所以我要敞开心扉 

475
00:24:11,000 --> 00:24:12,110
有几份文件 

476
00:24:12,110 --> 00:24:17,580
请注意 在源代码发行版中 有一个World文件夹 

477
00:24:17,580 --> 00:24:20,120
我们已经对所有的文件进行了分类

478
00:24:20,120 --> 00:24:24,410
与那个World文件夹中的世界一代有关 

479
00:24:24,410 --> 00:24:29,500
我们有一份门口档案 一份地牢档案 还有一份房间档案 

480
00:24:29,500 --> 00:24:34,030
因此 地牢文件对地牢进行了建模 

481
00:24:34,030 --> 00:24:38,740
所有形成我们地牢的房间 就像一个非常高的 水平的顶层

482
00:24:38,740 --> 00:24:39,850
级别、数据结构 

483
00:24:39,850 --> 00:24:42,100
其实很简单 

484
00:24:42,100 --> 00:24:46,120
正如我们之前看到的 这个房间是地牢的个体单位 

485
00:24:46,120 --> 00:24:49,900
因此 地牢实际上就像一张房间的桌子 

486
00:24:49,900 --> 00:24:55,086
然后它保存着我们如何在它们之间转换的代码 

487
00:24:55,086 --> 00:24:56,960
但这在某种程度上是我们可以思考的 

488
00:24:56,960 --> 00:24:59,890
当你的游戏水平一般时 在这种情况下是地下城

489
00:24:59,890 --> 00:25:01,510
在某种程度上是我们的比赛水平 

490
00:25:01,510 --> 00:25:04,210
您可以对不同的子集方面建模

491
00:25:04,210 --> 00:25:06,187
通过某种数据结构来了解你的水平 

492
00:25:06,187 --> 00:25:08,020
在这种情况下 我们决定把它腾出空间 

493
00:25:08,020 --> 00:25:09,728
但如果你只有一个平台或关卡 

494
00:25:09,728 --> 00:25:12,460
也许你有区域或区域 或任何东西 

495
00:25:12,460 --> 00:25:16,120
只是你所在级别的一些小部分 你可以在它们之间过渡 

496
00:25:16,120 --> 00:25:19,150
从这个角度考虑是很有用的 因为从效率来看

497
00:25:19,150 --> 00:25:22,840
从性能的角度来看 您希望动态加载

498
00:25:22,840 --> 00:25:24,760
特定的级别 一次一个 

499
00:25:24,760 --> 00:25:29,500
某些方面 某些部分 你所在水平的子领域 一次一个 

500
00:25:29,500 --> 00:25:31,540
而不是一次只有整个级别 

501
00:25:31,540 --> 00:25:35,170
因为这取决于你的关卡有多复杂和多大 

502
00:25:35,170 --> 00:25:38,650
您可以开始练习您的计算机的内存限制 

503
00:25:38,650 --> 00:25:40,550
所以我不想这么做 

504
00:25:40,550 --> 00:25:45,160
所以在这种情况下 我们的算法是我们有一个地牢 我们有房间 

505
00:25:45,160 --> 00:25:48,130
我们有一个活动房间 只能在同一时间看到 那是

506
00:25:48,130 --> 00:25:49,300
加载到内存中 

507
00:25:49,300 --> 00:25:51,580
然后每当我们在不同房间之间转换时 

508
00:25:51,580 --> 00:25:55,280
我们想要另一间临时入住的房间 

509
00:25:55,280 --> 00:25:57,670
那么让我们来看看这里的地下城班级 

510
00:25:57,670 --> 00:25:59,290
地下城 卢亚 

511
00:25:59,290 --> 00:26:03,200
所以14间自学的房间 空着桌子 

512
00:26:03,200 --> 00:26:06,130
我们要在里面放满房间 就是房间里的东西 

513
00:26:06,130 --> 00:26:07,550
自助室 

514
00:26:07,550 --> 00:26:11,230
房间 我们要把它传给球员 

515
00:26:11,230 --> 00:26:15,760
从而玩家可以访问其中的所有实体和对象 

516
00:26:15,760 --> 00:26:19,630
可以做碰撞检测之类的事情 这是非常重要的 

517
00:26:19,630 --> 00:26:26,680
也是为了让房间里的实体可以看到玩家

518
00:26:26,680 --> 00:26:30,370
然后决定他们想要对他们的人工智能做什么 

519
00:26:30,370 --> 00:26:34,270
您可以对任意复杂的模型进行建模 

520
00:26:34,270 --> 00:26:39,140
Room.lua的整个初始化函数都在运行 我们将在这里展示它 

521
00:26:39,140 --> 00:26:42,590
所以在room.lua中 在同一个World文件夹中 

522
00:26:42,590 --> 00:26:44,680
我们已经在高级别实例化了地牢 

523
00:26:44,680 --> 00:26:47,860
我们知道地牢 它基本上是一张桌子的房间 

524
00:26:47,860 --> 00:26:51,190
那么房间是什么样子的呢？

525
00:26:51,190 --> 00:26:54,130
嗯 一个房间 就像我们以前看到的 有哪些部分

526
00:26:54,130 --> 00:26:56,595
一个房间需要什么才能发挥作用？

527
00:26:56,595 --> 00:26:58,720
在某种程度上 房间需要控制什么？

528
00:27:02,064 --> 00:27:02,730
观众：门 

529
00:27:02,730 --> 00:27:03,563
科尔顿·奥格登：门 

530
00:27:06,287 --> 00:27:06,870
还要别的吗？

531
00:27:09,640 --> 00:27:11,620
所以它必须跟踪门 对吗？

532
00:27:11,620 --> 00:27:14,590
因为当我们触摸一扇门时 我们应该过渡到另一个房间 

533
00:27:14,590 --> 00:27:16,720
它应该跟踪玩家 

534
00:27:16,720 --> 00:27:18,330
这样玩家就可以更新了 

535
00:27:18,330 --> 00:27:21,500
它应该跟踪房间里的物体 比如开关 

536
00:27:21,500 --> 00:27:25,556
正如我们在示例中看到的 这样他们就可以更新那些 

537
00:27:25,556 --> 00:27:27,430
看看这位选手踩到开关了吗？

538
00:27:27,430 --> 00:27:30,070
如果他有 就把门打开 

539
00:27:30,070 --> 00:27:31,830
然后是实体 对吗？

540
00:27:31,830 --> 00:27:34,750
它应该跟踪房间里的所有生物

541
00:27:34,750 --> 00:27:37,240
这样他们就可以更新 他们可以相互互动 

542
00:27:37,240 --> 00:27:40,660
球员可以打他们 或者他们可以打球员 

543
00:27:40,660 --> 00:27:44,890
您可以对任何您想要的交互进行建模 

544
00:27:44,890 --> 00:27:45,820
所以我们可以在这里看到 

545
00:27:45,820 --> 00:27:47,190
哦 还有一件事 

546
00:27:47,190 --> 00:27:50,830
可能是它更重要的视觉方面之一 

547
00:27:50,830 --> 00:27:54,640
我们还需要一套瓷砖来模拟房间的样子 

548
00:27:54,640 --> 00:27:55,850
这是一个集装箱 

549
00:27:55,850 --> 00:28:00,550
所以我们要画 我们有一个角 一个角 

550
00:28:00,550 --> 00:28:01,630
两边都是墙 

551
00:28:01,630 --> 00:28:02,830
顶部和底部的墙 

552
00:28:02,830 --> 00:28:03,910
然后是一层楼 

553
00:28:03,910 --> 00:28:06,040
所以我们显然需要画出房间

554
00:28:06,040 --> 00:28:09,039
在我们画出所有其他的东西之前 更新所有其他的东西 

555
00:28:09,039 --> 00:28:14,550
因此 瓷砖、门口、实体和对象 

556
00:28:14,550 --> 00:28:16,151
所以我们可以在这里看到 

557
00:28:16,151 --> 00:28:18,400
你有瓷砖 柔和的瓷砖靠在一张空桌子上 

558
00:28:18,400 --> 00:28:21,040
我们有一个叫做生成墙和楼板的功能 

559
00:28:21,040 --> 00:28:22,330
实体、空表 

560
00:28:22,330 --> 00:28:24,520
我们有一个名为生成实体的函数 

561
00:28:24,520 --> 00:28:26,425
然后对象就等于空桌了 

562
00:28:26,425 --> 00:28:28,720
我们有一个名为生成对象的函数 

563
00:28:28,720 --> 00:28:29,980
最后是门口 

564
00:28:29,980 --> 00:28:33,100
然后是这里 因为它不一定

565
00:28:33,100 --> 00:28:38,740
就像我们需要一个完整的功能一样复杂 我们只有四个门 

566
00:28:38,740 --> 00:28:40,090
这是静态的 

567
00:28:40,090 --> 00:28:43,300
在本例中 我选择始终保留所有的门口

568
00:28:43,300 --> 00:28:46,210
处于相同的位置 并以相同的方式行事 

569
00:28:46,210 --> 00:28:50,710
但您可以创建一个更复杂的系统 特别是

570
00:28:50,710 --> 00:28:54,310
如果你有一个动态生成地牢的算法 

571
00:28:54,310 --> 00:28:56,660
也许你的房间不一定是硬性的 

572
00:28:56,660 --> 00:28:58,660
也许你有一把扫帚 对吧？

573
00:28:58,660 --> 00:29:02,162
如果我们早点回到我们的幻灯片 

574
00:29:02,162 --> 00:29:05,120
让我们假设我们看的是这个房间 就在这个最中间的地方 

575
00:29:05,120 --> 00:29:08,470
我们可以看到它的左边有一个门 上面有一个门 

576
00:29:08,470 --> 00:29:10,000
右手边还有一扇门 

577
00:29:10,000 --> 00:29:13,510
但它的底部没有通道 

578
00:29:13,510 --> 00:29:17,200
这看起来像是代表设计师的一个武断的设计决定 

579
00:29:17,200 --> 00:29:21,820
但如果我们看看上面的这个房间 我们

580
00:29:21,820 --> 00:29:24,286
可以看到它在某种程度上是以同样的方式运行的 

581
00:29:24,286 --> 00:29:26,410
左边有一扇门通往这个房间 

582
00:29:26,410 --> 00:29:28,780
下面有一个通往这个房间的门道 

583
00:29:28,780 --> 00:29:31,446
但上面没有门 右边也没有门 

584
00:29:31,446 --> 00:29:35,390
因为那个房间和那些方向之间没有房间 

585
00:29:35,390 --> 00:29:38,770
所以当你有一个二维地牢房间阵列时 

586
00:29:38,770 --> 00:29:42,220
你想要为你的门口建模 它可以很简单

587
00:29:42,220 --> 00:29:45,130
那么 那个方向还有空间吗？

588
00:29:45,130 --> 00:29:48,160
如果有 您将拥有您的数据结构

589
00:29:48,160 --> 00:29:53,420
在生成这些门口之前预先布置好 如果它不存在 

590
00:29:53,420 --> 00:29:54,250
不要做一扇门 

591
00:29:54,250 --> 00:29:56,710
如果它确实存在 就做一扇门 

592
00:29:56,710 --> 00:29:59,350
然后确保当你过渡的时候

593
00:29:59,350 --> 00:30:05,140
从右到左 或者从下到上 

594
00:30:05,140 --> 00:30:11,770
您可以在2D房间阵列中以正确的索引进入正确的房间 

595
00:30:11,770 --> 00:30:12,834
这说得通吗？

596
00:30:12,834 --> 00:30:16,000
到目前为止 有没有人有什么问题想知道这是如何在高层运作的？

597
00:30:18,660 --> 00:30:19,530
好的?

598
00:30:19,530 --> 00:30:20,380
太棒了 

599
00:30:20,380 --> 00:30:23,300
所以这里的这些门道都是因为这座地牢

600
00:30:23,300 --> 00:30:29,000
是完全随机的 每次它总是有通向顶部和底部的门 

601
00:30:29,000 --> 00:30:29,726
左手和右手 

602
00:30:29,726 --> 00:30:31,600
我们总是要放四扇门 

603
00:30:31,600 --> 00:30:32,900
从上 下 左 右 

604
00:30:32,900 --> 00:30:34,691
请注意 它们接受一个字符串 表示

605
00:30:34,691 --> 00:30:36,820
它们是方向 这将变得重要

606
00:30:36,820 --> 00:30:40,390
稍后在Doorway课程中 我们在这里看到

607
00:30:40,390 --> 00:30:42,880
被建模为单独的类 

608
00:30:42,880 --> 00:30:45,160
这里的FALSE只是意味着门是开着的吗？

609
00:30:45,160 --> 00:30:48,310
因此 默认情况下 我们将关闭门 

610
00:30:48,310 --> 00:30:51,790
然后是自己 这样我们就可以从门口进入房间 

611
00:30:54,632 --> 00:30:56,590
房间里应该有球员的名字 

612
00:30:56,590 --> 00:31:00,940
这样它就可以对实体和玩家之间的交互进行建模 

613
00:31:00,940 --> 00:31:04,030
以及物品和球员 

614
00:31:04,030 --> 00:31:05,890
请注意 它具有渲染偏移 

615
00:31:05,890 --> 00:31:14,230
所以如果我们看看这个游戏 瓷砖

616
00:31:14,230 --> 00:31:17,920
不要与屏幕的宽度和高度完全匹配 

617
00:31:17,920 --> 00:31:21,340
这主要是虚拟高度的函数

618
00:31:21,340 --> 00:31:26,710
没有完美地映射到16个瓷砖 由16个瓷砖均匀划分 

619
00:31:26,710 --> 00:31:29,750
所以我所做的就是把地牢变小了一点 

620
00:31:29,750 --> 00:31:36,160
还有一个事实是 门口占据了几块额外的衬垫

621
00:31:36,160 --> 00:31:39,610
在他们的一侧 这里就像是一片空白 

622
00:31:39,610 --> 00:31:41,830
我们已经将所有东西都稍微向内移动了一点 

623
00:31:41,830 --> 00:31:47,410
我们已经把地牢做了两块 宽度和高度都比屏幕小 

624
00:31:47,410 --> 00:31:50,080
然后我们呈现了一定数量的偏移量

625
00:31:50,080 --> 00:31:51,640
使其完全居中 

626
00:31:51,640 --> 00:31:56,890
我们计算在完全渲染的地下城之间存在多少填充

627
00:31:56,890 --> 00:32:00,190
不管剩下什么空格 只要移动一半就行了 

628
00:32:00,190 --> 00:32:01,780
这是我们的渲染偏移量 

629
00:32:01,780 --> 00:32:05,164
因此 这就是渲染偏移在这种情况下很重要的原因 

630
00:32:05,164 --> 00:32:07,330
当你试图将任何东西放在中心时 你通常会

631
00:32:07,330 --> 00:32:08,852
只需计算一个偏移量即可 

632
00:32:08,852 --> 00:32:11,560
计算你想要画的任何东西的宽度和高度 

633
00:32:11,560 --> 00:32:14,920
计算屏幕的宽度和高度减去它 

634
00:32:14,920 --> 00:32:18,040
将其除以2 这就是渲染偏移 

635
00:32:18,040 --> 00:32:22,570
这里的这两个领域很有趣 自邻接偏移X 

636
00:32:22,570 --> 00:32:24,610
Self.adjectoffsetY 

637
00:32:24,610 --> 00:32:30,284
有没有人猜到这是用来做什么的？

638
00:32:30,284 --> 00:32:31,226
嗯 

639
00:32:31,226 --> 00:32:33,110
当它在隔壁房间的时候画自己 

640
00:32:33,110 --> 00:32:34,550
是的 没错 

641
00:32:34,550 --> 00:32:37,160
所以当它在隔壁房间的时候画自己 

642
00:32:37,160 --> 00:32:39,950
所以当你装上下一个房间的时候 你要

643
00:32:39,950 --> 00:32:41,900
实例化一个房间 就像这样 

644
00:32:41,900 --> 00:32:44,790
但默认情况下 它将绘制为0.0 

645
00:32:44,790 --> 00:32:49,049
然而 如果我们想要那个房间画在我们不合适的地方 

646
00:32:49,049 --> 00:32:50,840
显然 如果我们在现在的房间里 我们

647
00:32:50,840 --> 00:32:52,220
我不想让隔壁的房间画在最上面

648
00:32:52,220 --> 00:32:54,724
我们所处的位置 因为那样它就会层次分明

649
00:32:54,724 --> 00:32:55,890
在我们所在的房间顶端 

650
00:32:55,890 --> 00:32:56,960
我们想把它画出来--

651
00:32:56,960 --> 00:32:59,450
如果我们要向右转 则需要向右绘制屏幕宽度 

652
00:32:59,450 --> 00:33:02,870
如果我们将其绘制到左侧 我们希望将其绘制为左侧的屏幕宽度 

653
00:33:02,870 --> 00:33:04,700
在y轴上也是一样的 

654
00:33:04,700 --> 00:33:06,480
上方或下方的屏幕高度 

655
00:33:06,480 --> 00:33:10,790
所以相邻的偏移量X或y 我们在画房间的时候加进去就行了 

656
00:33:10,790 --> 00:33:16,210
这将产生与房间分开渲染的效果

657
00:33:16,210 --> 00:33:17,210
我们目前所处的位置 

658
00:33:17,210 --> 00:33:19,140
我可以试着在这里画一个插图 

659
00:33:19,140 --> 00:33:24,080
所以 如果我们有我们的房间 这就是我们现在的房间 

660
00:33:24,080 --> 00:33:25,310
太自私了 房间里 

661
00:33:32,040 --> 00:33:35,741
假设我们在这里有一扇门 

662
00:33:35,741 --> 00:33:36,240
对吗？

663
00:33:36,240 --> 00:33:38,520
那是一个门口的物体 玩家在这里 

664
00:33:38,520 --> 00:33:40,230
他撞上了那个物体 

665
00:33:40,230 --> 00:33:43,480
它会触发一个过渡到上面的房间 

666
00:33:43,480 --> 00:33:46,980
所以我们要做的就是马上搬进一个新房间 

667
00:33:46,980 --> 00:33:53,460
我们总是有一个名为self.nextroom的指针 

668
00:33:53,460 --> 00:33:56,850
这些都记录在dungeod.lua文件中 

669
00:33:56,850 --> 00:34:01,740
但在默认情况下 self.nextroom将为零 

670
00:34:01,740 --> 00:34:06,810
但是当我们从现在的房间过渡到下一个房间的时候 对吗？

671
00:34:06,810 --> 00:34:08,460
我们应该把它设置成某种东西 

672
00:34:08,460 --> 00:34:12,909
因此 self.Curentroom将是相同的 

673
00:34:12,909 --> 00:34:19,230
但当我们触发这场碰撞时 

674
00:34:19,230 --> 00:34:24,090
这将只相当于一个新房间 

675
00:34:24,090 --> 00:34:26,310
然后我们就知道我们在哪个门口了 

676
00:34:26,310 --> 00:34:27,159
我们会想办法的 

677
00:34:27,159 --> 00:34:29,940
从技术上讲 我们会弄清楚我们要朝哪个方向前进 

678
00:34:29,940 --> 00:34:35,150
然后如果我们往上走 我们就会通过一个--

679
00:34:35,150 --> 00:34:41,790
在这种情况下 我们说它与负屏幕高度的偏移量y相邻 

680
00:34:41,790 --> 00:34:45,080
如果它低于屏幕高度 则将其设置为正屏幕高度 

681
00:34:45,080 --> 00:34:50,580
如果我们到这里 它将是负屏 与相邻的x 

682
00:34:50,580 --> 00:34:52,260
将为负屏宽 

683
00:34:52,260 --> 00:34:56,909
如果我们向右移动 那么x上的正屏幕宽度 

684
00:34:56,909 --> 00:35:04,710
所以我们可以看到这种相邻的 如果是XY 

685
00:35:04,710 --> 00:35:07,810
这基本上就是相邻的偏移量 

686
00:35:07,810 --> 00:35:14,955
最后我们画出了从底部到

687
00:35:14,955 --> 00:35:21,160
在这种情况下 我们只是补间相机到这个值 

688
00:35:21,160 --> 00:35:23,550
我们有摄像头 对吧？

689
00:35:23,550 --> 00:35:24,750
这是我们的相机

690
00:35:24,750 --> 00:35:30,390
默认情况下它会看这里 摄像机x和摄像机y 

691
00:35:30,390 --> 00:35:33,600
这些也是我们代码中的价值观 

692
00:35:33,600 --> 00:35:37,080
当我们在门口触发碰撞时 

693
00:35:37,080 --> 00:35:40,110
这里有当前的空间 它是0.0

694
00:35:40,110 --> 00:35:45,870
这里有一个房间 它的位置是0加上相邻的

695
00:35:45,870 --> 00:35:48,120
偏移y 这是负的屏幕高度 

696
00:35:48,120 --> 00:35:53,790
所以它的作用是使屏幕高度在y轴上为负 

697
00:35:53,790 --> 00:35:57,840
我们的相机x回忆爱 图形 翻译是我们的相机 

698
00:35:57,840 --> 00:35:59,580
所以我们要做的就是在两者之间 

699
00:35:59,580 --> 00:36:00,970
我们说 好的 

700
00:36:00,970 --> 00:36:05,020
这是我们的X号摄像机会在这里.

701
00:36:05,020 --> 00:36:07,210
小卡 有点乱了 

702
00:36:07,210 --> 00:36:07,920
我道歉

703
00:36:07,920 --> 00:36:10,230
但是我们的x和y摄像头在这里 

704
00:36:10,230 --> 00:36:17,070
随着时间的推移 我们会把它放到下一个房间

705
00:36:17,070 --> 00:36:23,790
x和y 即x加上相邻偏移x y加上相邻偏移y 

706
00:36:23,790 --> 00:36:29,040
一旦摄像机从这里移到这里 

707
00:36:29,040 --> 00:36:32,620
或者我们要去的任何方向 无论是上 下 左还是右 

708
00:36:32,620 --> 00:36:39,090
一旦我们完成了这一点 我们可以再次将所有内容标准化为0.0

709
00:36:39,090 --> 00:36:45,210
我们需要做的是 

710
00:36:45,210 --> 00:36:48,570
如果我们要把所有东西都放回去

711
00:36:48,570 --> 00:36:51,505
假设我想把这个房间设为新的当前房间 

712
00:36:51,505 --> 00:36:52,380
我需要做什么？

713
00:36:55,840 --> 00:36:58,870
我们有当前房间 还有下一个房间 

714
00:36:58,870 --> 00:37:01,600
如果我想让当前房间变成下一个房间 

715
00:37:01,600 --> 00:37:08,440
我只需要说self.currencial等于self.nextreme 对吧？

716
00:37:12,610 --> 00:37:16,300
一旦发生这种情况 

717
00:37:16,300 --> 00:37:18,190
下一个房间的x和y偏移量

718
00:37:22,200 --> 00:37:23,830
他们被设置为0 对吧？

719
00:37:23,830 --> 00:37:27,157
我想把这个房间 我们已经抵消了这里 

720
00:37:27,157 --> 00:37:29,740
我只想让它再次成为游戏世界的中心 

721
00:37:29,740 --> 00:37:34,360
我只想把它设置为0.0 这样我们就可以进行完全相同的计算

722
00:37:34,360 --> 00:37:39,230
只需将相邻的偏移量x或y设置为负或正屏幕高度

723
00:37:39,230 --> 00:37:41,770
或相对于0.9的屏幕宽度 

724
00:37:41,770 --> 00:37:45,910
所以我要做的就是设置相邻的偏移量

725
00:37:45,910 --> 00:37:50,600
将下一个房间(即当前房间)的x和y设置为0 

726
00:37:50,600 --> 00:37:53,320
它会把它拉回到0.0 

727
00:37:53,320 --> 00:37:57,430
然后 相机x和相机y也将设置为0.0 

728
00:37:57,430 --> 00:38:00,700
这将会产生一种效果 看起来就像我们正在上升

729
00:38:00,700 --> 00:38:01,720
并留在那里 

730
00:38:01,720 --> 00:38:03,880
但在现实中 我们只是往上走 然后

731
00:38:03,880 --> 00:38:05,710
立刻把一切都调回到了0度 

732
00:38:05,710 --> 00:38:09,370
包括那个房间的玩家、实体和开关 

733
00:38:09,370 --> 00:38:11,020
所以这纯粹是一种错觉 

734
00:38:11,020 --> 00:38:15,755
但它允许我们模拟这种无限探索地牢效应的过程 

735
00:38:15,755 --> 00:38:16,630
这说得通吗？

736
00:38:16,630 --> 00:38:20,110
这种工作方式的整体流程是否有意义？

737
00:38:20,110 --> 00:38:20,656
好的 

738
00:38:20,656 --> 00:38:22,030
所以那里有点乱 

739
00:38:22,030 --> 00:38:27,250
希望我能够说明整个算法是如何

740
00:38:27,250 --> 00:38:29,230
无限地牢发电机起作用了 

741
00:38:32,050 --> 00:38:33,610
我们在哪里停下来了？

742
00:38:33,610 --> 00:38:37,460
我们在房间的初始功能中 

743
00:38:37,460 --> 00:38:42,160
因此 让我们来看看组成它的几个函数 

744
00:38:42,160 --> 00:38:45,180
因此 生成墙和地板 

745
00:38:45,180 --> 00:38:47,560
这与我们所看到的非常相似

746
00:38:47,560 --> 00:38:52,360
以马里奥的瓷砖地图为例 我们只需从y到x 

747
00:38:52,360 --> 00:38:55,210
然后我们只需要选择一个随机的ID 或者我们的随机ID 

748
00:38:55,210 --> 00:38:56,800
嗯 其中一些是随机的身份证 

749
00:38:56,800 --> 00:38:58,760
但有时我们需要一个明确的身份证明 

750
00:38:58,760 --> 00:39:04,960
所以提醒我 ID实际上映射到什么时候

751
00:39:04,960 --> 00:39:07,700
我们要把瓷砖画到屏幕上吗？

752
00:39:07,700 --> 00:39:11,178
如果我们想给一块瓷砖一个ID 那是什么 它应该映射到什么？

753
00:39:11,178 --> 00:39:12,146
嗯?

754
00:39:12,146 --> 00:39:14,570
观众：精灵纸上的画框 

755
00:39:14,570 --> 00:39:17,590
科尔顿·奥格登：精灵图中的画框 没错 

756
00:39:17,590 --> 00:39:20,770
并不是所有的游戏引擎、所有的实现都必须如此 

757
00:39:20,770 --> 00:39:24,580
但这是最容易做的事情 只需给您的切片一个ID

758
00:39:24,580 --> 00:39:26,740
然后你就可以画出来 你可以编制索引

759
00:39:26,740 --> 00:39:29,560
在你的精灵单子上用那个ID 

760
00:39:29,560 --> 00:39:32,680
这是一种非常、非常简单、轻巧、干净的建模方法 

761
00:39:32,680 --> 00:39:36,250
我们可以在这里看到 ID得到了ID 

762
00:39:36,250 --> 00:39:39,520
在我们弄清楚我们想要什么ID之后 现在如何

763
00:39:39,520 --> 00:39:43,030
我们是不是决定了 比如说我想画--

764
00:39:49,430 --> 00:39:52,736
比方说 就像这块瓷砖 

765
00:39:52,736 --> 00:39:56,660
请注意 这是一块角瓷砖 

766
00:39:56,660 --> 00:39:59,080
我需要做什么才能基本上分配--

767
00:39:59,080 --> 00:40:02,810
我甚至在有机会给你看之前就要死了 

768
00:40:02,810 --> 00:40:08,020
在我躲避敌人的同时 如果我想画左上角 

769
00:40:08,020 --> 00:40:09,270
我要找的是什么？

770
00:40:09,270 --> 00:40:12,620
不管怎么说 我还在承受损失 

771
00:40:12,620 --> 00:40:14,480
相对于x和y 我要找的是什么？

772
00:40:17,770 --> 00:40:21,300
假设那块瓷砖需要多少x和y

773
00:40:21,300 --> 00:40:24,240
一切从左上角的1.1开始 然后向下

774
00:40:24,240 --> 00:40:27,257
整个地牢的高度和宽度？

775
00:40:27,257 --> 00:40:29,340
左上角的XY需要是什么？

776
00:40:33,920 --> 00:40:35,060
它应该是1 对吗？

777
00:40:35,060 --> 00:40:38,060
所以如果是1.1 基本上就是左上角 

778
00:40:38,060 --> 00:40:41,080
该ID应等于角子画面 

779
00:40:41,080 --> 00:40:42,815
特别是左上角的精灵 

780
00:40:42,815 --> 00:40:44,440
那右上角的精灵呢？

781
00:40:47,295 --> 00:40:48,170
X应该是多少？

782
00:40:50,920 --> 00:40:51,595
抱歉的?

783
00:40:51,595 --> 00:40:52,010
观众：宽度 

784
00:40:52,010 --> 00:40:52,850
科尔顿·奥格登：是的 宽度 

785
00:40:52,850 --> 00:40:53,370
一点儿没错 

786
00:40:53,370 --> 00:40:56,000
Y是多少？

787
00:40:56,000 --> 00:40:56,890
仍然是1 

788
00:40:56,890 --> 00:40:58,015
左下角呢？

789
00:41:00,327 --> 00:41:01,160
宽度、逗号高度 

790
00:41:01,160 --> 00:41:02,243
然后是右下角？

791
00:41:04,800 --> 00:41:08,560
观众：但这是[INAUDIBLE]

792
00:41:08,560 --> 00:41:11,270
科尔顿·奥格登：对不起 左下角应该是1 逗号高度 

793
00:41:11,270 --> 00:41:16,310
右下角应为宽度、高度 

794
00:41:16,310 --> 00:41:20,390
所以基本上是检查每一块瓷砖的位置

795
00:41:20,390 --> 00:41:24,721
是我们如何推断它的ID 这就是我们在源代码中所做的

796
00:41:24,721 --> 00:41:25,220
这里 

797
00:41:25,220 --> 00:41:28,370
如果x是1 y是1 好的 左上角 

798
00:41:28,370 --> 00:41:30,590
注意 我们已经将它们放入常量中 

799
00:41:30,590 --> 00:41:33,380
我们放在常量.lua中 只是为了可读性 

800
00:41:33,380 --> 00:41:37,100
所以我们可以立即看到OK 我应该将ID磁贴设置在左上方

801
00:41:37,100 --> 00:41:40,820
角 而不是某个任意的数字 这是我们对瓷砖的索引 

802
00:41:40,820 --> 00:41:43,370
大概40多岁 或者其他什么年龄 

803
00:41:43,370 --> 00:41:46,820
左下角是1和高度 

804
00:41:46,820 --> 00:41:53,280
右上角是宽度和1 然后右下角是宽度和高度 

805
00:41:53,280 --> 00:41:54,560
我们可以看到 它是可读的 

806
00:41:54,560 --> 00:41:57,684
我们可以一目了然地看到我们在做什么 你有条件地在哪里

807
00:41:57,684 --> 00:41:58,970
生成我们所有的瓷砖 

808
00:42:02,480 --> 00:42:09,890
如果这些都不是真的 那么x是1 那么这个瓦片是什么？

809
00:42:09,890 --> 00:42:11,450
如果x是1 但它不是一个角？

810
00:42:19,230 --> 00:42:20,950
这是一面左手边的墙 

811
00:42:20,950 --> 00:42:24,450
同样的事情是 如果它是宽度 它就是右手边的墙 

812
00:42:24,450 --> 00:42:27,300
如果y是1 它就是一面墙 

813
00:42:27,300 --> 00:42:29,580
如果y是高度 那么它就是底部的墙 

814
00:42:29,580 --> 00:42:36,240
如果不是这些 那就一定是一层楼 

815
00:42:36,240 --> 00:42:39,060
所以这基本上就是我们如何产生整体的--

816
00:42:39,060 --> 00:42:43,770
这是一个非常简单的生成算法 

817
00:42:43,770 --> 00:42:48,180
我在这里所做的是随机化 

818
00:42:48,180 --> 00:42:52,860
我们实际上有一张桌子 上面有潜在的左墙 潜在的右墙 

819
00:42:52,860 --> 00:42:54,240
潜在的顶部和底部 

820
00:42:54,240 --> 00:42:58,500
然后我们只需在其中指定一个随机值 

821
00:42:58,500 --> 00:43:00,300
基于它的规模有多大 

822
00:43:00,300 --> 00:43:02,700
这给了我们变量 我们可以看到它 

823
00:43:02,700 --> 00:43:06,630
我们有随机性--每次我产生它 

824
00:43:06,630 --> 00:43:08,894
所以请注意视觉上的一些瓷砖

825
00:43:08,894 --> 00:43:10,310
你可以在地图上看到 

826
00:43:13,750 --> 00:43:15,200
请注意 它们会发生变化 

827
00:43:15,200 --> 00:43:18,270
请注意 交换机也已更改 

828
00:43:18,270 --> 00:43:19,780
请注意 它们再次更改 

829
00:43:19,780 --> 00:43:21,230
因此 一切都是可变的 

830
00:43:21,230 --> 00:43:22,380
我们有一点视觉上的多样性 

831
00:43:22,380 --> 00:43:24,254
基本上 这就是我们对马里奥所做的 

832
00:43:24,254 --> 00:43:26,594
我们换了瓷砖套装和顶层套装 

833
00:43:26,594 --> 00:43:29,010
只是现在我们只是在改变 我们只有一张瓷砖 

834
00:43:29,010 --> 00:43:31,470
但在同一块瓷砖上有几种不同的变化 

835
00:43:31,470 --> 00:43:34,560
所以我们所要做的就是随机选择任何瓷砖的变体 

836
00:43:34,560 --> 00:43:36,870
这涉及到我们查看精灵薄片 

837
00:43:36,870 --> 00:43:40,890
挑选出哪些单独的瓷砖 哪些瓷砖分开 

838
00:43:40,890 --> 00:43:45,780
映射到特定类型的切片 然后只需选取一个随机值

839
00:43:45,780 --> 00:43:47,580
从那张桌子上

840
00:43:47,580 --> 00:43:49,210
这就是它的工作原理 

841
00:43:49,210 --> 00:43:54,570
所以 我认为 有几件事需要向亲人展示

842
00:43:54,570 --> 00:43:56,510
敬地牢一代 

843
00:43:56,510 --> 00:44:02,010
因此 我们已经生成了48个实体 

844
00:44:02,010 --> 00:44:04,950
因此 实体在这里 

845
00:44:04,950 --> 00:44:07,800
我们知道他们的名字 对吧？

846
00:44:07,800 --> 00:44:12,930
我们看到的一些实体 骷髅 蝙蝠 粘液 鬼魂 蜘蛛 

847
00:44:12,930 --> 00:44:16,560
这是一个非常轻量级的功能 

848
00:44:16,560 --> 00:44:19,380
它不像15或20行 但我们正在生成

849
00:44:19,380 --> 00:44:21,780
a bunch束of different不同kinds种类of entities实体.

850
00:44:21,780 --> 00:44:24,900
因为我们所做的 我们基本上

851
00:44:24,900 --> 00:44:27,270
从表中随机选择一种类型 

852
00:44:27,270 --> 00:44:30,930
我们创建一个实体 然后使用我们所拥有的

853
00:44:30,930 --> 00:44:34,740
定义在一个叫做实体定义的全局表中 

854
00:44:34,740 --> 00:44:37,980
我们把重要的东西

855
00:44:37,980 --> 00:44:41,490
每一个个体的产生 其特征 

856
00:44:41,490 --> 00:44:43,620
我们把它转换成简单的数据形式 

857
00:44:43,620 --> 00:44:49,530
这有点像游戏的数据驱动设计 

858
00:44:49,530 --> 00:44:54,990
如果你看这里的实体定义 我们可以看到所有的实体

859
00:44:54,990 --> 00:44:56,730
是一系列数据 

860
00:44:56,730 --> 00:44:59,490
这里有一个参与人 在第10行.

861
00:44:59,490 --> 00:45:01,140
玩家得到一张桌子 

862
00:45:01,140 --> 00:45:02,670
我们给他步行速度 

863
00:45:02,670 --> 00:45:04,590
我们有一个动画表 

864
00:45:04,590 --> 00:45:07,020
所以他有一个向左走的动画 一个向右走的动画 

865
00:45:07,020 --> 00:45:08,550
走下动画 

866
00:45:08,550 --> 00:45:11,840
所有这些都有它们的框架 它们的间隔 它们的纹理 一切

867
00:45:11,840 --> 00:45:14,850
就是干净的数据对吧

868
00:45:14,850 --> 00:45:16,740
这里没有逻辑 真的 

869
00:45:16,740 --> 00:45:20,430
只是一些标志 或者值 简单的东西 

870
00:45:20,430 --> 00:45:25,380
你可以给任何对我们的基本知识有一定了解的人

871
00:45:25,380 --> 00:45:29,470
做这个文件 也许还有一些纹理 然后说 嘿 

872
00:45:29,470 --> 00:45:30,840
我想让你设计

873
00:45:30,840 --> 00:45:33,150
我要你把所有的东西

874
00:45:33,150 --> 00:45:38,220
参与了骨架在屏幕上的渲染 

875
00:45:38,220 --> 00:45:40,770
为他们制作所有的动画 

876
00:45:40,770 --> 00:45:43,530
给这些动画计时 

877
00:45:43,530 --> 00:45:44,900
给他们准确的框架 

878
00:45:44,900 --> 00:45:48,600
也许骨架应该有健康值 也许健康值应该等于10

879
00:45:48,600 --> 00:45:50,620
在一具骨架上 或者类似的东西上 

880
00:45:50,620 --> 00:45:53,484
实际上这里没有任何编程 

881
00:45:53,484 --> 00:45:55,650
但我们把游戏中的一切都描述成数据 

882
00:45:55,650 --> 00:46:01,500
这在复杂的游戏中是很重要的 因为游戏系统相当复杂 

883
00:46:01,500 --> 00:46:04,440
但是可以通过一些属性来建模 

884
00:46:04,440 --> 00:46:07,890
您可以只归属于实体和数据 然后让引擎解析

885
00:46:07,890 --> 00:46:12,720
此信息 然后以编程方式创建您的实体 

886
00:46:12,720 --> 00:46:17,400
稍微把负担从程序员转移到设计者身上 

887
00:46:17,400 --> 00:46:21,540
你请得起你的设计团队 你 也许还有其他人

888
00:46:21,540 --> 00:46:23,400
对编程不太熟悉的人 

889
00:46:23,400 --> 00:46:27,326
能够修改游戏引擎 向游戏中添加内容 

890
00:46:27,326 --> 00:46:29,700
而不必查看大量的引擎代码

891
00:46:29,700 --> 00:46:31,107
做任何太花哨的事 

892
00:46:31,107 --> 00:46:32,190
在这种情况下 它很简单 

893
00:46:32,190 --> 00:46:37,662
我们所做的只是创建动画 并指定一个纹理

894
00:46:37,662 --> 00:46:39,120
这些个体中的每一种 

895
00:46:39,120 --> 00:46:41,340
但我上周曾暗示过这一点 

896
00:46:41,340 --> 00:46:44,190
你可以有一个文件 它可能描述了一些类似地精的东西 

897
00:46:44,190 --> 00:46:47,280
我们会在一堂课的最后看到这一点 它可能像一面旗帜

898
00:46:47,280 --> 00:46:48,412
因为它是易燃的吗？

899
00:46:48,412 --> 00:46:49,620
它的生命力有多强？

900
00:46:49,620 --> 00:46:51,510
它的动画是什么？

901
00:46:51,510 --> 00:46:53,516
它有什么技能？

902
00:46:53,516 --> 00:46:54,640
它的进攻强度有多大？

903
00:46:54,640 --> 00:46:55,470
它的辩护理由是什么？

904
00:46:55,470 --> 00:46:58,232
它通常在哪里产卵？

905
00:46:58,232 --> 00:47:01,440
通过将所有这些属性放在一起并让您的引擎进行某种解析

906
00:47:01,440 --> 00:47:04,950
这个 你可以创建 取决于你有多少个字段 

907
00:47:04,950 --> 00:47:12,169
你可以在你的游戏中创建非常复杂的潜在清单 

908
00:47:12,169 --> 00:47:15,210
无论他们是实体 无论是武器 还是物品 

909
00:47:15,210 --> 00:47:16,135
超能力 

910
00:47:16,135 --> 00:47:17,010
任何你想做的事 

911
00:47:17,010 --> 00:47:20,970
不管它们是不是水平 

912
00:47:20,970 --> 00:47:23,020
仅仅基于数据 

913
00:47:23,020 --> 00:47:26,800
因此 这是设计和开发的圣杯

914
00:47:26,800 --> 00:47:30,180
当你进入像RPG这样特别复杂的游戏时 

915
00:47:30,180 --> 00:47:34,647
在那里你可以拥有具有粒子效果的技能

916
00:47:34,647 --> 00:47:36,480
对不同的东西造成不同的伤害 

917
00:47:36,480 --> 00:47:39,600
你有一些实体--也许你想让它们被烧毁 

918
00:47:39,600 --> 00:47:40,620
有些人会触电身亡 

919
00:47:40,620 --> 00:47:41,760
也许有些你不知道 

920
00:47:41,760 --> 00:47:45,570
也许当他们接触到什么东西时 一些会融化 

921
00:47:45,570 --> 00:47:47,670
创建一串旗帜 创建一个函数

922
00:47:47,670 --> 00:47:50,970
它对此进行解析 并生成结果实体 

923
00:47:50,970 --> 00:47:55,710
你只需要让你自己的工作效率得到令人难以置信的提升 

924
00:47:55,710 --> 00:48:02,650
您不再需要创建蜘蛛类、幽灵类、蝙蝠类 

925
00:48:02,650 --> 00:48:04,110
这都是不必要的 

926
00:48:04,110 --> 00:48:07,854
你所需要做的就是定义蝙蝠有哪些属性？

927
00:48:07,854 --> 00:48:09,270
幽灵有什么属性？

928
00:48:09,270 --> 00:48:12,030
骨架有哪些属性？

929
00:48:12,030 --> 00:48:16,460
因此 任何人都可以因此修改您的游戏 

930
00:48:16,460 --> 00:48:20,360
他们所需要做的就是知道一个潜在实体可以具有哪些属性 

931
00:48:20,360 --> 00:48:24,330
因此 您的设计团队的工作效率会更高 

932
00:48:24,330 --> 00:48:28,580
所以这就是为什么这是一个相关的说辞 

933
00:48:28,580 --> 00:48:30,560
我们已经实现了一个非常基本的版本

934
00:48:30,560 --> 00:48:33,120
只是为了制作动画模型 

935
00:48:33,120 --> 00:48:36,751
但我们不需要为游戏中的所有不同实体创建单独的类

936
00:48:36,751 --> 00:48:37,250
世界 

937
00:48:37,250 --> 00:48:41,180
我们只需要 基本上 在这个游戏的背景下 

938
00:48:41,180 --> 00:48:43,640
他们的动画是什么？

939
00:48:43,640 --> 00:48:46,490
这就是实体定义 这就是它的工作方式 如果我们

940
00:48:46,490 --> 00:48:51,450
看看第48行的room.lua 

941
00:48:51,450 --> 00:48:53,510
它所做的一切就是制作动画 

942
00:48:53,510 --> 00:48:56,840
顺便说一句 这是您的函数 它接受这些定义

943
00:48:56,840 --> 00:48:58,670
并创建你的实体 

944
00:48:58,670 --> 00:49:00,560
他们应该寻找--

945
00:49:00,560 --> 00:49:01,790
正在调查这件事 

946
00:49:01,790 --> 00:49:03,920
他们提取该定义 然后解析出

947
00:49:03,920 --> 00:49:07,100
每一条相关的数据 

948
00:49:07,100 --> 00:49:09,980
然后只需构建一些相关信息

949
00:49:09,980 --> 00:49:13,640
或将相关标志附加到该实体 以便您的游戏引擎稍后可以

950
00:49:13,640 --> 00:49:15,560
解析 

951
00:49:15,560 --> 00:49:19,850
举个易燃的例子 如果你进行攻击 而攻击是火力类型的 

952
00:49:19,850 --> 00:49:24,410
它与一个实体相撞 这个实体 易燃是真的 

953
00:49:24,410 --> 00:49:25,940
这应该会引发一些行为 

954
00:49:25,940 --> 00:49:28,065
但你不需要做任何非常复杂的事情 

955
00:49:28,065 --> 00:49:33,420
此后 您可以将其分配给任何任意实体 

956
00:49:33,420 --> 00:49:37,910
所以 这只是一种简单的方法来获取游戏中非常复杂的行为

957
00:49:37,910 --> 00:49:40,520
对象 实体 任何你想要的东西 

958
00:49:40,520 --> 00:49:45,980
将它们建模为数据 而不是从类的角度考虑 

959
00:49:45,980 --> 00:49:47,060
就是这样 

960
00:49:47,060 --> 00:49:49,768
有没有人有任何问题 比如它是如何工作的 

961
00:49:49,768 --> 00:49:50,889
或者为什么它是可行的？

962
00:49:50,889 --> 00:49:51,680
或者为什么它有用？

963
00:49:55,550 --> 00:49:56,897
好的 

964
00:49:56,897 --> 00:49:59,230
最后几件事 我们会在房间里快速看一看 

965
00:49:59,230 --> 00:50:02,680
所以上网82 

966
00:50:02,680 --> 00:50:04,060
生成对象 

967
00:50:04,060 --> 00:50:07,510
所以我们上周做了非常非常相似的事情 

968
00:50:07,510 --> 00:50:09,990
在那里我们刚刚有了一个游戏对象类 

969
00:50:09,990 --> 00:50:13,660
请注意 它本身就是一个交换机的定义 

970
00:50:13,660 --> 00:50:17,040
这个定义在游戏对象.lua中 

971
00:50:17,040 --> 00:50:18,380
换个位置 

972
00:50:18,380 --> 00:50:22,140
这是一种更类似于开关的数据建模 

973
00:50:22,140 --> 00:50:27,820
它有一种类型的开关 默认的帧是2 所以宽度和高度都是16 

974
00:50:27,820 --> 00:50:28,720
它并不结实 

975
00:50:28,720 --> 00:50:30,280
玩家可以走过去 

976
00:50:30,280 --> 00:50:31,930
其默认状态为抑制 

977
00:50:31,930 --> 00:50:34,840
因此 当它被催生到游戏中时 它是不受压力的 

978
00:50:34,840 --> 00:50:37,960
它有两种潜在的状态 史无前例的和紧迫的 

979
00:50:37,960 --> 00:50:39,940
这些州中的每一个都有一个框架 

980
00:50:39,940 --> 00:50:43,330
所以我们要做的就是呈现它 它的当前状态是什么？

981
00:50:43,330 --> 00:50:45,380
呈现此状态 帧 

982
00:50:45,380 --> 00:50:47,260
然后现在 我们不需要做任何事情--

983
00:50:47,260 --> 00:50:50,590
这基本上就是我们所需要做的 以便在正确的点上呈现它 

984
00:50:50,590 --> 00:50:54,010
因此 您的游戏引擎需要查看对象 

985
00:50:54,010 --> 00:50:59,290
并查看其状态和潜在状态 索引到该状态

986
00:50:59,290 --> 00:51:02,709
然后从那里拉出框架 

987
00:51:02,709 --> 00:51:04,750
但它为你提供了一种无限的灵活性 

988
00:51:04,750 --> 00:51:09,010
你现在可以有一个发光的状态 

989
00:51:09,010 --> 00:51:12,744
也许在那张精灵纸上有一个框架让它发光 

990
00:51:12,744 --> 00:51:15,160
你可以随时随地把它换成发光 

991
00:51:15,160 --> 00:51:17,080
它会恰到好处地渲染 

992
00:51:17,080 --> 00:51:22,610
所以对数据建模的方法非常灵活 

993
00:51:22,610 --> 00:51:24,100
房间有149个房间 

994
00:51:24,100 --> 00:51:25,960
所以我们快完成这里的地牢了 

995
00:51:25,960 --> 00:51:30,760
所以149是我们的更新功能 

996
00:51:30,760 --> 00:51:34,180
它所做的基本上就是遍历所有内容

997
00:51:34,180 --> 00:51:38,990
并更新它 基本上包括所有实体 

998
00:51:38,990 --> 00:51:45,670
所以对于每个实体来说 如果它的生命值小于或等于0 它就是死的 

999
00:51:45,670 --> 00:51:50,630
如果它是死的 那么不要渲染它 我们在渲染中看到了这一点 

1000
00:51:50,630 --> 00:51:57,510
但如果它没有死 而且玩家自己撞到了它 

1001
00:51:57,510 --> 00:52:01,930
而且玩家并不脆弱 那么我们就应该伤害玩家 

1002
00:52:01,930 --> 00:52:03,370
变得无懈可击 

1003
00:52:03,370 --> 00:52:06,110
如果玩家的健康状况为零 则切换到游戏结束 

1004
00:52:06,110 --> 00:52:09,070
所以请注意这是多么的可读性 

1005
00:52:09,070 --> 00:52:12,970
当您也像这样对实体建模时 您真正需要做的就是

1006
00:52:12,970 --> 00:52:15,160
只是检查某些标志或函数 

1007
00:52:15,160 --> 00:52:18,190
你可以像这样做任意复杂的测试 

1008
00:52:18,190 --> 00:52:20,500
因为实体可能是死的 也可能不是 

1009
00:52:20,500 --> 00:52:23,800
因为实体可以是无懈可击的 也可以不是 

1010
00:52:23,800 --> 00:52:28,690
然后因为实体都是XY的 在我们的游戏中基于高度的东西 

1011
00:52:28,690 --> 00:52:32,440
而碰撞只是希望他们拥有这一点 

1012
00:52:32,440 --> 00:52:35,800
我们所做的只是播放声音 伤害玩家 

1013
00:52:35,800 --> 00:52:38,160
伤害在即刻会造成什么影响？

1014
00:52:38,160 --> 00:52:39,265
你觉得它能做什么？

1015
00:52:39,265 --> 00:52:41,740
观众：我会胡乱猜测 然后说减去你的健康 

1016
00:52:41,740 --> 00:52:42,440
科尔顿·奥格登：没错 

1017
00:52:42,440 --> 00:52:44,190
随便猜一猜 就会说它有损健康 

1018
00:52:44,190 --> 00:52:44,950
确实如此 

1019
00:52:44,950 --> 00:52:49,330
所以实体伤害只是一个数字 然后从生命值中减去这个数字 

1020
00:52:49,330 --> 00:52:50,440
这就是它的全部功能 

1021
00:52:50,440 --> 00:52:51,250
变得无懈可击 

1022
00:52:51,250 --> 00:52:52,000
那是做什么的 

1023
00:52:53,724 --> 00:52:56,390
观众：这意味着你已经遭受了那么多秒的伤害？

1024
00:52:56,390 --> 00:52:57,306
科尔顿·奥格登：的确如此 

1025
00:52:57,306 --> 00:52:59,890
它可以防止你在那么长的时间内受到伤害 

1026
00:52:59,890 --> 00:53:04,990
所有这些实际上只是设置了一个标志 我已经提到了很多

1027
00:53:04,990 --> 00:53:09,610
已经是一个任意的标志 您可以通过数据或其他方式进行建模 

1028
00:53:09,610 --> 00:53:11,770
每个实体都有一面坚不可摧的旗帜 

1029
00:53:11,770 --> 00:53:14,920
如果它是无懈可击的 那么引擎应该寻找它 

1030
00:53:14,920 --> 00:53:19,940
并相应地更改渲染和实体的机制 

1031
00:53:19,940 --> 00:53:22,990
最后这里 很简单 如果玩家的健康等于0 

1032
00:53:22,990 --> 00:53:27,040
这可能是在我们受到足够的伤害后 更改为游戏结束 

1033
00:53:27,040 --> 00:53:28,210
这就是它的全部功能 

1034
00:53:28,210 --> 00:53:33,280
然后 对于每个对象 就像我们对每个实体所做的那样 更新对象

1035
00:53:33,280 --> 00:53:37,450
如果玩家与其相撞 则触发其碰撞功能 

1036
00:53:37,450 --> 00:53:40,667
这可以是你任意创建的函数 

1037
00:53:40,667 --> 00:53:42,250
取决于您的对象的需求 

1038
00:53:44,920 --> 00:53:48,550
例如 如果你抬头看这里 每次我们创建一个房间 

1039
00:53:48,550 --> 00:53:51,400
我们在房间里生成对象 

1040
00:53:51,400 --> 00:53:55,570
我们在对象中插入了一个开关 这是我们在前面看到的 在gameobjects.lua中 

1041
00:53:55,570 --> 00:53:57,830
取x和y 

1042
00:53:57,830 --> 00:53:59,830
在这种情况下 我们只需确保x和y

1043
00:53:59,830 --> 00:54:01,950
是地图左上角之间的一个随机数

1044
00:54:01,950 --> 00:54:06,610
和地图的右下角 在它所具有的填充内 

1045
00:54:06,610 --> 00:54:09,200
我们得到了对该对象的引用 

1046
00:54:09,200 --> 00:54:11,930
然后定义了Are on Collide函数 

1047
00:54:11,930 --> 00:54:14,620
所以我们要做的就是说如果它被压制了 

1048
00:54:14,620 --> 00:54:19,030
回想一下 我们在游戏对象定义中有一个状态 

1049
00:54:19,030 --> 00:54:21,810
如果是未熨烫的 就改成熨烫 

1050
00:54:21,810 --> 00:54:23,410
这就是我们真正需要做的 

1051
00:54:23,410 --> 00:54:26,410
然后注意这里 比如k 有一扇门 

1052
00:54:26,410 --> 00:54:31,720
因此 对于每一扇门 无论是自己的门 都要把门敞开

1053
00:54:31,720 --> 00:54:33,460
是真的 

1054
00:54:33,460 --> 00:54:35,020
然后播放一声门声 

1055
00:54:35,020 --> 00:54:38,260
所以我们的On Collide函数只是相互作用

1056
00:54:38,260 --> 00:54:41,080
与游戏世界中的其他东西 以及非常简单的东西

1057
00:54:41,080 --> 00:54:46,180
但有一种非常有趣的机械师 

1058
00:54:46,180 --> 00:54:46,989
就像我们有一个...

1059
00:54:46,989 --> 00:54:49,780
我从蝙蝠那里得到了伤害 因为我的产卵并不完美 

1060
00:54:49,780 --> 00:54:55,250
但它从--请注意 它的状态从未按下更改

1061
00:54:55,250 --> 00:54:56,310
按下 

1062
00:54:56,310 --> 00:54:57,995
因为它从唯一的精灵变成了--

1063
00:54:57,995 --> 00:54:59,870
我去另一个房间 这样我们就能看到了 

1064
00:54:59,870 --> 00:55:01,050
我会在路上弄坏一些东西 

1065
00:55:01,050 --> 00:55:01,841
去另一个房间 

1066
00:55:01,841 --> 00:55:03,180
请注意精灵 

1067
00:55:03,180 --> 00:55:06,110
它看起来像是没有被压住的 对吗？

1068
00:55:06,110 --> 00:55:08,520
因为游戏对象的默认状态是未按下的 

1069
00:55:08,520 --> 00:55:13,050
然后当我在它上面的时候就会触发碰撞 

1070
00:55:13,050 --> 00:55:16,530
它会更改状态 这会对渲染的内容产生影响 

1071
00:55:16,530 --> 00:55:18,960
它是关于Collide函数的调用 该函数

1072
00:55:18,960 --> 00:55:21,210
把房间的每一扇门都打开了 

1073
00:55:21,210 --> 00:55:25,230
如此简单 就像15行代码 

1074
00:55:25,230 --> 00:55:29,160
但为了我们的地牢 我们的行为很吸引人 很有趣 

1075
00:55:29,160 --> 00:55:31,310
就像 它增加了很多东西 就这么简单 

1076
00:55:31,310 --> 00:55:33,060
现在我们感觉就像是在互动

1077
00:55:33,060 --> 00:55:35,400
和我们的游戏世界有一点关系 

1078
00:55:35,400 --> 00:55:38,970
这就是它的工作原理 

1079
00:55:38,970 --> 00:55:42,750
最后 在第188行上进行渲染 

1080
00:55:42,750 --> 00:55:45,660
只需检查我们所有的瓷砖 渲染所有瓷砖 

1081
00:55:45,660 --> 00:55:47,190
我们以前见过这种情况 

1082
00:55:47,190 --> 00:55:49,380
渲染所有的门口 渲染所有的物体 

1083
00:55:49,380 --> 00:55:52,270
渲染所有实体 如果它们没有死的话 

1084
00:55:52,270 --> 00:55:52,770
对吗？

1085
00:55:52,770 --> 00:55:55,980
如果它们已经死了 那么就不要渲染它们 

1086
00:55:55,980 --> 00:55:59,820
然后这一点 我们将看看结尾 这是模版 

1087
00:55:59,820 --> 00:56:03,794
所以请注意当我走进门的时候 

1088
00:56:03,794 --> 00:56:06,960
首先 请注意 如果门是关着的 我是不能走进去的 

1089
00:56:06,960 --> 00:56:07,751
这一点很重要 

1090
00:56:07,751 --> 00:56:13,380
因此 当你与门口的物体碰撞时 如果Doorway.Open为False 

1091
00:56:13,380 --> 00:56:16,080
它不应该触发房间开关 对吗？

1092
00:56:16,080 --> 00:56:19,440
但如果我打开门 它们现在都会被召回 

1093
00:56:19,440 --> 00:56:21,120
Door.open现在等于True 

1094
00:56:21,120 --> 00:56:25,200
所以他们改变了他们的渲染 现在他们正在渲染开放的门口 

1095
00:56:25,200 --> 00:56:27,960
如果我穿过它 注意到它看起来像是玩家走的

1096
00:56:27,960 --> 00:56:29,580
在瓷砖下面 

1097
00:56:29,580 --> 00:56:33,480
但我是在玩家面前画牌 

1098
00:56:33,480 --> 00:56:38,430
还有一种你可能认为应该做的方法

1099
00:56:38,430 --> 00:56:43,740
当创造出这种令人信服的行走外观时

1100
00:56:43,740 --> 00:56:45,420
穿过一扇门 就是说好 

1101
00:56:45,420 --> 00:56:51,130
我只会在渲染之后渲染播放器 然后再渲染门口 

1102
00:56:51,130 --> 00:56:51,630
对吗？

1103
00:56:51,630 --> 00:56:53,670
所以最后渲染所有的门 

1104
00:56:53,670 --> 00:57:00,270
但这并不是很有效 因为精灵实际上就是从这里开始的 

1105
00:57:00,270 --> 00:57:02,880
所以有人会认为如果我是

1106
00:57:02,880 --> 00:57:07,340
在玩家身后画门口吗？

1107
00:57:07,340 --> 00:57:11,020
观众：如果你越过这条线或[INAUDIBLE] 你的默认玩家就会消失

1108
00:57:11,020 --> 00:57:11,645
越过那条线 

1109
00:57:11,645 --> 00:57:12,561
科尔顿·奥格登：没错 

1110
00:57:12,561 --> 00:57:15,840
球员一走到这一小段线就会消失 

1111
00:57:15,840 --> 00:57:17,298
在这里 这不是很有说服力 

1112
00:57:17,298 --> 00:57:21,180
实际上 我现在就试着去掉模版 

1113
00:57:21,180 --> 00:57:23,110
这样我们就能看到那是什么样子了 

1114
00:57:23,110 --> 00:57:29,050
所以如果我去掉这里的模板 然后我只需要渲染 

1115
00:57:33,490 --> 00:57:36,030
今天不能打字 

1116
00:57:36,030 --> 00:57:37,890
所以我要继续了 

1117
00:57:37,890 --> 00:57:38,500
那就去吧 

1118
00:57:42,410 --> 00:57:47,530
首先 渲染顺序是这样的 现在门口渲染

1119
00:57:47,530 --> 00:57:49,120
在球员之前 

1120
00:57:49,120 --> 00:57:51,220
所以他就直接从他们身上走过去 对吗？

1121
00:57:51,220 --> 00:57:53,560
所以我只是在走 我是在跨过墙 

1122
00:57:53,560 --> 00:57:54,730
这并不令人信服 

1123
00:57:54,730 --> 00:57:58,970
如果我要做一些简单的事情 比如改变渲染顺序 

1124
00:57:58,970 --> 00:58:00,990
因此 现在 门口首先进行渲染 

1125
00:58:00,990 --> 00:58:03,490
我将在玩家之后渲染门口 

1126
00:58:03,490 --> 00:58:09,137
所以就在这里 我把它拿出来了 对吗？

1127
00:58:09,137 --> 00:58:10,510
不是的 

1128
00:58:10,510 --> 00:58:12,376
所以现在 他们在玩家面前进行渲染 

1129
00:58:12,376 --> 00:58:14,000
我想按照玩家的名字来渲染它们 

1130
00:58:14,000 --> 00:58:18,100
我要把它运行起来 

1131
00:58:18,100 --> 00:58:21,070
然后踩下开关 

1132
00:58:21,070 --> 00:58:22,960
然后 是的 

1133
00:58:22,960 --> 00:58:24,700
请注意 我们也会遇到一些奇怪的行为 

1134
00:58:27,400 --> 00:58:32,170
就像看到他的头被砍掉一样？

1135
00:58:32,170 --> 00:58:36,790
以及其他实体也是如此 对吗？

1136
00:58:36,790 --> 00:58:39,550
在这种情况下 我真的看不出来 

1137
00:58:39,550 --> 00:58:41,830
不过 是的 

1138
00:58:41,830 --> 00:58:43,330
非常奇怪的撕裂行为 

1139
00:58:43,330 --> 00:58:47,590
我们要做的就是创造一种被称为模板的东西 

1140
00:58:47,590 --> 00:58:51,490
因此 基本上我会尝试获得一个屏幕截图 我可以在这里展示 

1141
00:58:51,490 --> 00:58:55,880
首先 让我修改一下我刚才所做的更改 

1142
00:58:55,880 --> 00:58:57,230
正确的 

1143
00:58:57,230 --> 00:59:01,645
然后如果我回到这里的代码 

1144
00:59:01,645 --> 00:59:04,520
所以模板只是--我们稍后会看到一张幻灯片 

1145
00:59:04,520 --> 00:59:10,310
但模板基本上是任何类型的任意形状 

1146
00:59:10,310 --> 00:59:12,080
你画在屏幕上的 

1147
00:59:12,080 --> 00:59:17,690
它是看不见的 但它决定了

1148
00:59:17,690 --> 00:59:20,330
在该模板上绘制 它确定是否

1149
00:59:20,330 --> 00:59:21,830
那东西就会被渲染 

1150
00:59:21,830 --> 00:59:28,260
所以我有一个模板 基本上是从这里一直到下一个房间 

1151
00:59:28,260 --> 00:59:30,344
所以就在门口撞到拱门的地方 

1152
00:59:30,344 --> 00:59:32,260
因为这就是我们想要玩家的头

1153
00:59:32,260 --> 00:59:33,410
让它看起来像是消失了 

1154
00:59:33,410 --> 00:59:34,850
模板放在这里 

1155
00:59:34,850 --> 00:59:37,340
我这里有一支钢笔 

1156
00:59:37,340 --> 00:59:38,370
就在这里 

1157
00:59:38,370 --> 00:59:40,290
在右边也是如此 

1158
00:59:40,290 --> 00:59:42,230
这样做的目的是我已经设置了模板

1159
00:59:42,230 --> 00:59:47,120
说出在分类过程中通过这个模板的任何东西

1160
00:59:47,120 --> 00:59:50,480
模板测试期 我们所做的只是

1161
00:59:50,480 --> 00:59:52,130
在这段时间内画出玩家 

1162
00:59:52,130 --> 00:59:55,820
但基本上 如果它在模板上 就不会呈现它 

1163
00:59:55,820 --> 00:59:58,190
所以它的影响是我们仍然

1164
00:59:58,190 --> 01:00:00,170
在玩家面前画出门道 

1165
01:00:00,170 --> 01:00:03,210
所以球员走进来 他被拉到了这一部分的上方 

1166
01:00:03,210 --> 01:00:05,900
但一旦他打到模板 他就没有被画出来 

1167
01:00:05,900 --> 01:00:07,970
它只是--所有这些 基本上它所做的

1168
01:00:07,970 --> 01:00:15,290
它将字符绘制到模具上 而不是实际的画布上 

1169
01:00:15,290 --> 01:00:19,700
因此 如果你想要令人信服的分层、怪异的视觉效果

1170
01:00:19,700 --> 01:00:23,070
就像这样 模版是一种方法 

1171
01:00:23,070 --> 01:00:23,570
好的 

1172
01:00:23,570 --> 01:00:24,830
然后就是这一切 

1173
01:00:24,830 --> 01:00:28,040
所以这个模板函数 love.graph 模板 

1174
01:00:28,040 --> 01:00:29,450
接受一个函数 

1175
01:00:29,450 --> 01:00:32,442
这是在实际的模版过程中要运行的内容 

1176
01:00:32,442 --> 01:00:33,275
它将会抽签--

1177
01:00:33,275 --> 01:00:34,550
我画了四个矩形 

1178
01:00:34,550 --> 01:00:39,061
所有那些矩形就是那些拱门 

1179
01:00:39,061 --> 01:00:39,560
对吗？

1180
01:00:39,560 --> 01:00:43,970
完美地覆盖在它们上面 这样它就可以进入隔壁的房间 

1181
01:00:43,970 --> 01:00:47,560
然后我们就这么做了 

1182
01:00:47,560 --> 01:00:49,610
请注意 它显示的是替换 然后是1 

1183
01:00:49,610 --> 01:00:53,630
因此 我们替换绘制到该模板上的任何像素

1184
01:00:53,630 --> 01:00:55,610
模板值为1 

1185
01:00:55,610 --> 01:01:00,931
然后我们只在模具测试中画小于1的东西 

1186
01:01:00,931 --> 01:01:03,680
这意味着任何没有被归因于值1的东西 

1187
01:01:03,680 --> 01:01:05,900
也就是说 如果玩家翻阅了模板 

1188
01:01:05,900 --> 01:01:07,972
得到的像素值为1 则为假 

1189
01:01:07,972 --> 01:01:09,680
他不会被屏幕所吸引 

1190
01:01:09,680 --> 01:01:10,648
是?

1191
01:01:10,648 --> 01:01:15,488
观众：所以你是在刻版 如果你创造了一个不同的形状 

1192
01:01:15,488 --> 01:01:20,417
你可以利用这一点 比如说 像灯光系统一样 一些区域是黑暗的 

1193
01:01:20,417 --> 01:01:21,292
有些区域是亮的吗？

1194
01:01:21,292 --> 01:01:26,392
科尔顿·奥格登：很好的问题是 如果你有一个模板 因为你

1195
01:01:26,392 --> 01:01:28,100
可以使用任意形状 您可以

1196
01:01:28,100 --> 01:01:32,240
在某些区域为暗区域 而某些区域为亮区域的情况下创建照明系统 

1197
01:01:32,240 --> 01:01:34,600
我想说有可能 

1198
01:01:34,600 --> 01:01:38,990
问题是 我不能100%确定模板是否允许你这样做 

1199
01:01:38,990 --> 01:01:44,940
爱2D模板是否允许你做任意的数字 

1200
01:01:44,940 --> 01:01:48,320
我基本上不确定它是开着还是关着 还是渐变 

1201
01:01:48,320 --> 01:01:51,110
通常 如果我这样做我们的照明系统 

1202
01:01:51,110 --> 01:01:54,560
我可能会画一个假的照明系统 

1203
01:01:54,560 --> 01:01:57,830
第一 你可以使用照明套件 比如盒子

1204
01:01:57,830 --> 01:02:01,310
2D灯光 这对你来说真的很吸引人 很酷的灯光 

1205
01:02:01,310 --> 01:02:05,150
或者是一种更粗鲁的方式 但也可能是现实的 

1206
01:02:05,150 --> 01:02:12,020
就是画一个形状 适合你想要成为黑暗的任何东西 

1207
01:02:12,020 --> 01:02:16,330
然后以低于100%的不透明度进行渲染 

1208
01:02:16,330 --> 01:02:20,240
所以你会有一个房间 比方说可能在它的两边

1209
01:02:20,240 --> 01:02:21,950
都有些模糊 

1210
01:02:21,950 --> 01:02:24,320
你在那里画黑色的矩形 对吗？

1211
01:02:24,320 --> 01:02:28,250
但是 这些黑色矩形不是以255阿尔法绘制的 

1212
01:02:28,250 --> 01:02:31,950
你把它们画在200或150 或者类似的地方 

1213
01:02:31,950 --> 01:02:33,950
所以你仍然可以看到它们下面是什么 

1214
01:02:33,950 --> 01:02:37,790
但看起来它们似乎是一个影子 

1215
01:02:37,790 --> 01:02:40,040
你可以使用渐变效果来做同样的事情 

1216
01:02:40,040 --> 01:02:44,240
如果你想要更深更浅的阴影 

1217
01:02:44,240 --> 01:02:47,494
我相信你可以在Love 2D中画出带有渐变效果的矩形 

1218
01:02:47,494 --> 01:02:49,160
我还得再深入调查一下 

1219
01:02:49,160 --> 01:02:51,080
但你会想要做这样的事 

1220
01:02:51,080 --> 01:02:55,280
通过某个矩形或任意形状绘制阴影的渐变 

1221
01:02:55,280 --> 01:02:56,930
在这种情况下模拟照明 

1222
01:02:56,930 --> 01:02:59,110
你可以完成类似的事情 

1223
01:02:59,110 --> 01:03:02,359
还有很多其他疯狂的很酷的方式 我在2D中看到过闪电 

1224
01:03:02,359 --> 01:03:05,759
但这可能是我能想到的最简单的方法了 

1225
01:03:05,759 --> 01:03:06,258
凉爽的 

1226
01:03:09,440 --> 01:03:12,440
所以这就是模版 基本上就是这样

1227
01:03:12,440 --> 01:03:16,400
对于地牢一代来说 这可以说是最重要的部分 

1228
01:03:16,400 --> 01:03:19,790
我们之前也看过这种过渡机制 

1229
01:03:19,790 --> 01:03:23,154
我们将更多地了解过渡机械师

1230
01:03:23,154 --> 01:03:23,820
稍等片刻 

1231
01:03:23,820 --> 01:03:27,260
但让我们现在花五分钟 然后回到那个问题上

1232
01:03:27,260 --> 01:03:29,820
再看看更多的东西 

1233
01:03:29,820 --> 01:03:30,320
好的 

1234
01:03:30,320 --> 01:03:32,717
欢迎回到第五讲 塞尔达传奇 

1235
01:03:32,717 --> 01:03:34,550
所以在休息之前 我们谈到了一些

1236
01:03:34,550 --> 01:03:38,880
在不同的事物中 地牢一代是其中最重要的 

1237
01:03:38,880 --> 01:03:42,930
现在我们将真正开始谈论像Hitbox和Hurtbox这样的东西 

1238
01:03:42,930 --> 01:03:44,420
正如我们在屏幕上看到的那样 

1239
01:03:44,420 --> 01:03:47,790
因此 Hitbox基本上是一个长方形 

1240
01:03:47,790 --> 01:03:50,540
这就是我们在发行版中实现它的方式 

1241
01:03:50,540 --> 01:03:52,820
但我们在这里可以看到有几种不同的

1242
01:03:52,820 --> 01:03:53,940
矩形重叠的部分 

1243
01:03:53,940 --> 01:03:55,650
我们这里有绿色的长方形 

1244
01:03:55,650 --> 01:03:56,890
这些都是伤害箱 

1245
01:03:56,890 --> 01:03:58,440
这就是你可能受伤的地方 

1246
01:03:58,440 --> 01:03:59,640
然后这是一个Hitbox 

1247
01:03:59,640 --> 01:04:01,920
这是你可以击球的地方 

1248
01:04:01,920 --> 01:04:04,380
所以游戏 特别是格斗游戏 

1249
01:04:04,380 --> 01:04:06,900
在许多相当复杂的互动游戏中 

1250
01:04:06,900 --> 01:04:10,020
以及拥有武器或粒子的复杂实体 

1251
01:04:10,020 --> 01:04:11,610
诸如此类的事情都会造成损害 

1252
01:04:11,610 --> 01:04:15,180
你会看到很多复杂的重叠 

1253
01:04:15,180 --> 01:04:18,974
以及这些矩形的排列 这就带来了

1254
01:04:18,974 --> 01:04:21,390
物体如何在碰撞方面相互作用 

1255
01:04:21,390 --> 01:04:24,450
造成损害 并影响到其他实体 

1256
01:04:24,450 --> 01:04:29,220
在这种情况下 他正在进行从左到右的攻击 

1257
01:04:29,220 --> 01:04:30,390
这是一次低位进攻 

1258
01:04:30,390 --> 01:04:33,104
只是他的脚 从本质上讲 有点向内 

1259
01:04:33,104 --> 01:04:36,270
但从本质上说 他的脚是有损伤的 而他的其余部分是脆弱的 

1260
01:04:36,270 --> 01:04:39,520
如果有人从上面走到他跟前攻击他 

1261
01:04:39,520 --> 01:04:41,440
这会造成一些损害 

1262
01:04:41,440 --> 01:04:45,600
还有《我的世界》 它向你展示了同样的原则

1263
01:04:45,600 --> 01:04:48,130
同样适用于3D游戏 

1264
01:04:48,130 --> 01:04:53,070
在这种情况下 你看到的都是伤害箱 

1265
01:04:53,070 --> 01:04:54,750
这些人都意识到事情可能会受到伤害 

1266
01:04:54,750 --> 01:04:57,301
尽管这些东西很少是物品 

1267
01:04:57,301 --> 01:05:00,300
因此 这只会真正影响玩家是否与它们相撞

1268
01:05:00,300 --> 01:05:01,860
然后把它们捡起来 

1269
01:05:01,860 --> 01:05:07,380
但这基本上就是Hitbox和Hurtbox之间的区别 

1270
01:05:07,380 --> 01:05:10,410
我想我不小心把这个文件命名为hurtbox的发行版 

1271
01:05:10,410 --> 01:05:13,380
所以当我把它往上推时 它会被重新命名为Hitbox 

1272
01:05:13,380 --> 01:05:15,070
因为这就是我们使用它的目的 

1273
01:05:15,070 --> 01:05:22,354
但在这场比赛中有什么是即兴的 我们需要Hitbox做什么？

1274
01:05:22,354 --> 01:05:24,270
观众：[听不见]呼啸而来的攻击 

1275
01:05:24,270 --> 01:05:25,728
科尔顿·奥格登：用剑攻击 

1276
01:05:25,728 --> 01:05:28,550
我们需要Hitbox的原因是什么？

1277
01:05:28,550 --> 01:05:30,540
观众：致[INAUDIBLE]大热 

1278
01:05:30,540 --> 01:05:31,290
科尔顿·奥格登：是的 

1279
01:05:31,290 --> 01:05:35,476
为什么我们不能只使用球员的位置x-y宽度和高度？

1280
01:05:35,476 --> 01:05:37,350
观众：因为它也有一个方向 

1281
01:05:37,350 --> 01:05:40,225
科尔顿·奥格登：因为它也有方向 也需要--

1282
01:05:40,225 --> 01:05:41,610
这基本上就是它的伤害性武器 

1283
01:05:41,610 --> 01:05:42,270
对吗？

1284
01:05:42,270 --> 01:05:44,170
所以这两个原因 

1285
01:05:44,170 --> 01:05:50,310
它有我们需要作为它参考点的方向

1286
01:05:50,310 --> 01:05:54,030
用于生成命中框 对其他实体造成伤害 

1287
01:05:54,030 --> 01:05:56,280
我们需要使用玩家的主Hitbox

1288
01:05:56,280 --> 01:05:58,800
以及伤害盒 它已经必须看看是否有什么东西

1289
01:05:58,800 --> 01:06:04,030
击球 球员 也许是从另一边 或者类似的东西 

1290
01:06:04,030 --> 01:06:05,670
那么 让我们继续下去 看看这里 

1291
01:06:05,670 --> 01:06:09,090
处理Hitbox的主要代码 在本例中 

1292
01:06:09,090 --> 01:06:11,100
其中一个将会成为伤害盒 

1293
01:06:11,100 --> 01:06:11,940
应该是希特波斯 

1294
01:06:11,940 --> 01:06:15,390
但我们可以看到 这实际上只是一个矩形类 

1295
01:06:15,390 --> 01:06:16,790
XY 宽度和高度 

1296
01:06:16,790 --> 01:06:20,490
自学 自学 

1297
01:06:20,490 --> 01:06:22,860
这就是你对Hitbox所需要的一切 

1298
01:06:22,860 --> 01:06:26,370
字面意思就是盒子 你所需要的就是那些字段 

1299
01:06:26,370 --> 01:06:29,051
然后你可以做简单的碰撞 

1300
01:06:29,051 --> 01:06:30,050
就像你做实体一样 

1301
01:06:30,050 --> 01:06:32,220
实体碰撞伤害箱 

1302
01:06:32,220 --> 01:06:33,300
是 不 对或错 

1303
01:06:33,300 --> 01:06:38,220
因为回想起来 碰撞预期XY宽度或高度 

1304
01:06:38,220 --> 01:06:41,610
它定义了一个整体Lua 

1305
01:06:41,610 --> 01:06:45,180
因此 如果我们上升到玩家状态 

1306
01:06:45,180 --> 01:06:48,240
回想一下 上周我们介绍了这个想法

1307
01:06:48,240 --> 01:06:51,240
让玩家维护自己的状态集合 

1308
01:06:51,240 --> 01:06:52,350
在状态机中 

1309
01:06:52,350 --> 01:06:55,740
而不仅仅是游戏世界有一个状态机

1310
01:06:55,740 --> 01:06:57,960
影响我们是否在开始屏幕上 

1311
01:06:57,960 --> 01:07:03,750
Play State屏幕 无论我们想要将游戏划分成什么 

1312
01:07:03,750 --> 01:07:06,190
我们也有实体国家 

1313
01:07:06,190 --> 01:07:09,660
其中之一是--所以我们在行走状态下有空闲的 

1314
01:07:09,660 --> 01:07:14,467
这些与上周的非常相似 空闲状态 他们是

1315
01:07:14,467 --> 01:07:15,300
只是站着不动 

1316
01:07:15,300 --> 01:07:19,020
以及它们正在移动的行走状态 它们的动画也会相应地改变 

1317
01:07:19,020 --> 01:07:23,520
摆剑状态是一个新的状态 而这个状态的作用是

1318
01:07:23,520 --> 01:07:26,190
是玩家按空格键 

1319
01:07:26,190 --> 01:07:28,620
它会触发这种摇摆的剑状态 

1320
01:07:28,620 --> 01:07:29,880
有一部新的动画 

1321
01:07:29,880 --> 01:07:34,290
因此 我们进入摆动剑动画 相对于我们所处的方向 

1322
01:07:34,290 --> 01:07:40,680
我们得到那个方向 然后我们计算xy的宽度和高度

1323
01:07:40,680 --> 01:07:42,310
不管我们的伤害箱是什么 

1324
01:07:42,310 --> 01:07:46,110
应该是Hitbox 是要换剑的 

1325
01:07:46,110 --> 01:07:47,880
当剑射中某物时 

1326
01:07:47,880 --> 01:07:51,990
所以Hitbox 如果它朝向左边 它是

1327
01:07:51,990 --> 01:07:54,540
将是8像素宽乘16高 这

1328
01:07:54,540 --> 01:07:57,090
大致在球员的左侧 

1329
01:07:57,090 --> 01:08:00,870
然后我们只计算x和y 取决于我们所处的位置 

1330
01:08:00,870 --> 01:08:05,520
它应该大致居中 基于球员的方向 

1331
01:08:05,520 --> 01:08:06,940
看着 

1332
01:08:06,940 --> 01:08:10,230
然后我们在这里实例化这个伤害框 

1333
01:08:10,230 --> 01:08:13,590
我们管它叫自助式剑术保镖 

1334
01:08:13,590 --> 01:08:16,430
然后我们真正需要做的是什么？

1335
01:08:16,430 --> 01:08:20,357
在我们的游戏循环中检查我们是否击中了实体？

1336
01:08:26,430 --> 01:08:32,340
我们只需要循环我们房间中的实体 当前房间 对吗？

1337
01:08:32,340 --> 01:08:32,970
这里 

1338
01:08:32,970 --> 01:08:37,319
所以地牢当前房间里的每一个实体 实体 

1339
01:08:37,319 --> 01:08:40,859
如果实体与我们的利剑伤害箱、利剑希特箱相撞 

1340
01:08:40,859 --> 01:08:45,420
然后 我们以前见过这种方法 实体破坏一次 

1341
01:08:45,420 --> 01:08:47,247
然后击打敌人的游戏 

1342
01:08:47,247 --> 01:08:48,330
事情就是这么简单 

1343
01:08:48,330 --> 01:08:54,540
回想一下 在房间里 Lua 如果一个实体的生命值降到1以下 降到0 

1344
01:08:54,540 --> 01:08:56,640
它只会触发它变得死亡 

1345
01:08:56,640 --> 01:08:57,689
对吗？

1346
01:08:57,689 --> 01:09:00,430
这就是我们有效地需要的一切 

1347
01:09:00,430 --> 01:09:02,910
然后我们有一些额外的逻辑来确保

1348
01:09:02,910 --> 01:09:04,890
动画只播放一次 

1349
01:09:04,890 --> 01:09:10,290
然后 一旦它播放了一次 将其状态更改为空闲 

1350
01:09:10,290 --> 01:09:13,500
然后我们可以在相同的状态下重复按空格键 

1351
01:09:13,500 --> 01:09:15,300
如果我们想的话就继续摇摆 

1352
01:09:15,300 --> 01:09:18,540
它将重新启动动画 然后重新启动

1353
01:09:18,540 --> 01:09:20,399
正在实例化的Hitbox 

1354
01:09:20,399 --> 01:09:23,519
这就是我们真正需要做的一切 

1355
01:09:23,519 --> 01:09:26,310
现在我在挥剑的底部有几行代码

1356
01:09:26,310 --> 01:09:27,569
国家 卢阿 

1357
01:09:27,569 --> 01:09:30,029
和选手佩剑 摆剑状态 

1358
01:09:30,029 --> 01:09:32,939
而它们所做的是有时它是有用的

1359
01:09:32,939 --> 01:09:36,563
当你编程来查看你的碰撞框在哪里时 对吗？

1360
01:09:36,563 --> 01:09:39,479
因为你不一定知道一切是否都完美地排列在一起 

1361
01:09:39,479 --> 01:09:41,937
当您检测不同实体之间的冲突时 

1362
01:09:41,937 --> 01:09:44,939
您只需要检查一下这些矩形是否确实重叠

1363
01:09:44,939 --> 01:09:46,229
这是什么时候触发的？

1364
01:09:46,229 --> 01:09:50,189
所以你所需要做的就是一目了然地看到它 

1365
01:09:50,189 --> 01:09:54,690
你可能以前在其他游戏或调试模式的游戏中见过这种情况 

1366
01:09:54,690 --> 01:09:57,357
就是画一条长方形的线 

1367
01:09:57,357 --> 01:10:00,690
然后给他们你想看的XY宽度和高度 对吗？

1368
01:10:00,690 --> 01:10:04,710
所以 在这里 我将继续并保存这个 

1369
01:10:04,710 --> 01:10:06,225
然后我要运行--

1370
01:10:06,225 --> 01:10:08,640
我基本上没有评论过它 

1371
01:10:08,640 --> 01:10:10,800
因为默认情况下 我不想让它显示出来 

1372
01:10:10,800 --> 01:10:13,440
它们是粉红色的矩形 我不想让它们显示在屏幕上 

1373
01:10:13,440 --> 01:10:14,880
除非我想做调试 

1374
01:10:14,880 --> 01:10:18,030
因此 我将在这里取消对它们的注释 

1375
01:10:18,030 --> 01:10:20,460
请注意 它将颜色设置为255 0 255 

1376
01:10:20,460 --> 01:10:22,170
那是洋红色 

1377
01:10:22,170 --> 01:10:23,914
我来负责这件事 

1378
01:10:23,914 --> 01:10:25,225
[音乐播放]

1379
01:10:25,225 --> 01:10:26,790
把音量调小一点 

1380
01:10:26,790 --> 01:10:28,980
看起来没有什么特别的不同 

1381
01:10:28,980 --> 01:10:34,170
但当我挥动我的剑时 注意到有一个小矩形 

1382
01:10:34,170 --> 01:10:37,170
长方形也不一定是100%完美的 

1383
01:10:37,170 --> 01:10:39,630
他们给了球员一点优势 

1384
01:10:39,630 --> 01:10:42,930
就像上面一样 就像他的Hitbox几乎什么都不是 

1385
01:10:42,930 --> 01:10:47,370
在上面 在实际动画中 但在碰撞中 

1386
01:10:47,370 --> 01:10:52,310
我对它敬而远之 

1387
01:10:52,310 --> 01:10:54,270
所以这就是为什么你可以 在某种程度上 

1388
01:10:54,270 --> 01:10:57,400
看看你的东西是否有适当的相互作用 

1389
01:10:57,400 --> 01:10:58,330
有几行代码 

1390
01:10:58,330 --> 01:11:01,170
我为其他州做了同样的事情 实体 步行 

1391
01:11:01,170 --> 01:11:02,100
和空闲状态 

1392
01:11:02,100 --> 01:11:05,222
如果你想看看这些 不仅能看到球员

1393
01:11:05,222 --> 01:11:08,430
挥舞着剑 还有其他实体 以及他们的碰撞框

1394
01:11:08,430 --> 01:11:11,820
有 只是为了检查它们是否适当地重叠 

1395
01:11:11,820 --> 01:11:14,040
或者改变它们 或者随心所欲地处理它们 

1396
01:11:14,040 --> 01:11:15,345
但这是一种很好的方式--

1397
01:11:15,345 --> 01:11:17,220
有时很难调试冲突 如果您

1398
01:11:17,220 --> 01:11:18,930
我看不清到底是怎么回事 

1399
01:11:18,930 --> 01:11:22,500
因为它通常只是XY的宽度和高度 等等 

1400
01:11:22,500 --> 01:11:23,950
有偏移量之类的 

1401
01:11:23,950 --> 01:11:27,180
这可能是一种痛苦和/或一种困难

1402
01:11:27,180 --> 01:11:28,680
以这种方式追踪特定的虫子 

1403
01:11:28,680 --> 01:11:31,229
所以只要画到屏幕上就行了 

1404
01:11:31,229 --> 01:11:34,020
你可以将同样的逻辑应用到你的游戏世界中的许多事情上

1405
01:11:34,020 --> 01:11:38,970
这可能是隐藏的 但您希望看到某种视觉上的只是绘制形状

1406
01:11:38,970 --> 01:11:40,440
或者为他们画不同的东西 

1407
01:11:40,440 --> 01:11:42,310
这样你就能看到发生了什么 

1408
01:11:42,310 --> 01:11:47,160
对于我们的球员来说 这就是Hitbox和Hurtbox的工作方式 

1409
01:11:47,160 --> 01:11:50,706
你可以很容易地为其他实体产生更多的点击率

1410
01:11:50,706 --> 01:11:51,330
如果你想的话 

1411
01:11:51,330 --> 01:11:53,940
如果你想给他们州 或者

1412
01:11:53,940 --> 01:11:57,750
你想制造具有攻击性的投射物 

1413
01:11:57,750 --> 01:12:01,680
也许只是制造炮弹 然后发射炮弹

1414
01:12:01,680 --> 01:12:06,360
在特定方向上 但将Hitbox分配给该射弹 

1415
01:12:06,360 --> 01:12:07,660
如果你想的话 

1416
01:12:07,660 --> 01:12:10,200
或者只使用XY宽度和高度投射物 

1417
01:12:10,200 --> 01:12:12,270
然后你就可以这样计算碰撞了 

1418
01:12:12,270 --> 01:12:14,550
只需将其视为游戏对象或实体即可 

1419
01:12:14,550 --> 01:12:15,780
由你决定 

1420
01:12:15,780 --> 01:12:18,700
或者一起上一个单独的班级 

1421
01:12:18,700 --> 01:12:21,000
但简而言之 这就是打击手和伤害者 

1422
01:12:21,000 --> 01:12:23,400
有没有人对这些工作原理有任何疑问？

1423
01:12:25,950 --> 01:12:27,490
好的 酷 

1424
01:12:27,490 --> 01:12:29,360
那么 让我们继续下一个话题 

1425
01:12:29,360 --> 01:12:30,490
所以就是这些事件 

1426
01:12:30,490 --> 01:12:32,260
我早些时候谈到了这一点 

1427
01:12:32,260 --> 01:12:35,860
事件只是一种很好的方式 可以说

1428
01:12:35,860 --> 01:12:39,550
如果发生这种情况 请执行此代码块 

1429
01:12:39,550 --> 01:12:40,910
你可以在任何地方做到这一点 

1430
01:12:40,910 --> 01:12:44,290
你可以把它从两个不同的物体中分离出来

1431
01:12:44,290 --> 01:12:45,430
彼此互动 

1432
01:12:45,430 --> 01:12:48,130
但您不希望它们传递引用

1433
01:12:48,130 --> 01:12:51,130
在彼此之间来回移动 并膨胀您的代码 

1434
01:12:51,130 --> 01:12:55,660
也许您希望该检查的代码发生在您的主循环中 

1435
01:12:55,660 --> 01:12:58,870
你想把它抽象成某种其他函数 

1436
01:12:58,870 --> 01:13:00,640
就像实例化的事件 

1437
01:13:00,640 --> 01:13:02,950
然后让您的主呈现和更新逻辑

1438
01:13:02,950 --> 01:13:06,077
摆脱所有这些有条件的东西 

1439
01:13:06,077 --> 01:13:06,910
所以你创造了事件 

1440
01:13:06,910 --> 01:13:12,400
你说在一些活动上 所以可能就像在运动员竞走上 

1441
01:13:12,400 --> 01:13:14,592
然后你只需要更新一些 也许是一个标签

1442
01:13:14,592 --> 01:13:17,050
在屏幕的右上角 这给出了玩家的XY 

1443
01:13:17,050 --> 01:13:20,286
你就说XY等于那个玩家的XY 

1444
01:13:20,286 --> 01:13:22,660
我的意思是 除了你可以从字面上

1445
01:13:22,660 --> 01:13:24,144
画出玩家的XY 

1446
01:13:24,144 --> 01:13:25,310
但这是相同的原则 

1447
01:13:25,310 --> 01:13:30,370
您可以在独立于另一个实体的某个位置更新一些值 

1448
01:13:30,370 --> 01:13:34,750
然后等待一个事件 任意定义的事件 

1449
01:13:34,750 --> 01:13:37,100
然后你再播出 

1450
01:13:37,100 --> 01:13:39,460
比方说我想要一把广播摇摆剑 

1451
01:13:39,460 --> 01:13:40,840
我有一场挥杆剑比赛 

1452
01:13:40,840 --> 01:13:42,790
因此 每当玩家按空格键时 不仅

1453
01:13:42,790 --> 01:13:46,120
他们做了我们之前看到的所有代码 但他们挥舞着剑 

1454
01:13:46,120 --> 01:13:50,035
然后我们说 当你挥舞剑时 传递他们挥舞的地方的XY

1455
01:13:50,035 --> 01:13:51,010
那把剑 

1456
01:13:51,010 --> 01:13:55,300
然后你就可以说好了 在摇摆剑上 看看所有的实体 

1457
01:13:55,300 --> 01:13:58,344
看看XY上的Hitbox是否与它们相撞 

1458
01:13:58,344 --> 01:14:01,510
你可以从以前的逻辑中提取出来 然后把它

1459
01:14:01,510 --> 01:14:03,370
把它放在其他集中的地方 

1460
01:14:03,370 --> 01:14:04,690
如果你想的话 

1461
01:14:04,690 --> 01:14:09,760
这种模式更具代表性的是成就系统的理念 

1462
01:14:09,760 --> 01:14:11,920
而不是每一帧 你可以

1463
01:14:11,920 --> 01:14:14,600
有--游戏有许多令人难以置信的成就 

1464
01:14:14,600 --> 01:14:16,510
有些游戏有1000个这样的成绩 

1465
01:14:16,510 --> 01:14:19,210
你不会想让这1000个人中的每一个

1466
01:14:19,210 --> 01:14:23,110
成就必然在你的更新逻辑之内 对吗？

1467
01:14:23,110 --> 01:14:26,297
相反 您可以只为所有人广播一项活动

1468
01:14:26,297 --> 01:14:29,380
影响这些成就能否实现的不同因素 

1469
01:14:29,380 --> 01:14:34,210
因此 无论一个玩家在一场比赛中需要杀死100个 还是需要100个硬币 

1470
01:14:34,210 --> 01:14:36,460
他们是否需要从悬崖上跳下来 

1471
01:14:36,460 --> 01:14:38,770
你只是有一些事件来模拟所有这些互动 

1472
01:14:38,770 --> 01:14:41,350
活动开始 拿起硬币 做这件事 

1473
01:14:41,350 --> 01:14:45,820
增加一些时间 一些存储在其他地方的计数器 

1474
01:14:45,820 --> 01:14:47,965
Event.On 杀死生物 

1475
01:14:47,965 --> 01:14:51,250
或者每次你杀生物的时候 

1476
01:14:51,250 --> 01:14:56,170
从字面上讲 一个生物从虚假到死亡都是真实的 

1477
01:14:58,690 --> 01:15:03,550
也许每当玩家跳跃时 你就会做一个跳跃功能 

1478
01:15:03,550 --> 01:15:06,040
然后你可以测试一下--在这段代码中 

1479
01:15:06,040 --> 01:15:08,350
你可以测试一下他们是否从悬崖上跳了下来 

1480
01:15:08,350 --> 01:15:11,149
如果发生这种情况 你就有了你的成就系统 

1481
01:15:11,149 --> 01:15:12,940
但您并没有所有这些if语句 

1482
01:15:12,940 --> 01:15:18,040
所有这些测试都发生在你的强制游戏循环中 

1483
01:15:18,040 --> 01:15:22,900
您只需伪异步地检查所有它们 

1484
01:15:22,900 --> 01:15:26,590
在你的游戏中有一个足够详细的事件系统 

1485
01:15:26,590 --> 01:15:30,430
因此 我们将使用的库只是为了展示一点

1486
01:15:30,430 --> 01:15:34,030
在刀库里 我们之前用计时器见过 

1487
01:15:34,030 --> 01:15:36,760
Timer.On、Timer.Every、Timer.Tweet 

1488
01:15:36,760 --> 01:15:38,800
在刀库中 有一个子模块

1489
01:15:38,800 --> 01:15:44,320
名为Event 它允许您调用Event.on 

1490
01:15:44,320 --> 01:15:45,580
给它一个名称和一个函数 

1491
01:15:45,580 --> 01:15:49,420
所以在运动员跳跃上 在运动员跳跃下 

1492
01:15:49,420 --> 01:15:50,130
你知道?

1493
01:15:50,130 --> 01:15:50,890
功能 

1494
01:15:50,890 --> 01:15:56,830
如果Player.Position位于某个悬崖边 或某个相关的区域 

1495
01:15:56,830 --> 01:15:58,630
然后调用这段代码 

1496
01:15:58,630 --> 01:16:03,040
并递增 或将成就设置为真 

1497
01:16:03,040 --> 01:16:04,470
事件 快递 

1498
01:16:04,470 --> 01:16:06,380
当有事情发生时调度事件 

1499
01:16:06,380 --> 01:16:13,150
因此 如果玩家跳跃 那么当他们按空格键时 事件 调度跳跃 

1500
01:16:13,150 --> 01:16:17,027
然后就是您的回调函数需要的任何值 

1501
01:16:17,027 --> 01:16:19,360
假设您想要查看悬崖上有什么 

1502
01:16:19,360 --> 01:16:21,730
嗯 如果你想看看他们是不是跳下

1503
01:16:21,730 --> 01:16:25,540
那个特定的悬崖 你需要检查他们的XY位置 想必 

1504
01:16:25,540 --> 01:16:28,980
因此 只需通过Event.Dispatch传递可选参数即可 

1505
01:16:28,980 --> 01:16:32,380
你可以说OK 调度运动员跳跃的事件 

1506
01:16:32,380 --> 01:16:34,810
然后说这名球员跳到了XY 

1507
01:16:34,810 --> 01:16:37,990
所以这个函数回调将访问xy 

1508
01:16:37,990 --> 01:16:41,230
它会说好的 一跳 我说我得到了 

1509
01:16:41,230 --> 01:16:45,730
我的回调是由player.x player.y调用的 它碰巧--

1510
01:16:45,730 --> 01:16:46,990
哦 它不在悬崖上 

1511
01:16:46,990 --> 01:16:48,030
所以什么都没发生 

1512
01:16:48,030 --> 01:16:54,400
或者是悬崖 所以成就 跳下悬崖 解锁才是真的 

1513
01:16:54,400 --> 01:16:57,304
现在的测试并不是每一帧都在进行 

1514
01:16:57,304 --> 01:16:58,720
否则就有可能

1515
01:16:58,720 --> 01:17:03,380
而且它不会阻止你的更新逻辑为您的球员跳跃 

1516
01:17:03,380 --> 01:17:03,880
对吧？

1517
01:17:03,880 --> 01:17:08,790
播放器 播放器内的跳转逻辑 播放器跳转状态 

1518
01:17:08,790 --> 01:17:10,420
不需要知道

1519
01:17:10,420 --> 01:17:13,420
不需要问我们是不是从悬崖上跳下去了 

1520
01:17:13,420 --> 01:17:17,400
我们应该把它写进成就档案里 

1521
01:17:17,400 --> 01:17:18,410
或者随便你怎么说

1522
01:17:18,410 --> 01:17:21,070
这就是事件给你的灵活性 

1523
01:17:21,070 --> 01:17:22,570
所以我们使用事件 

1524
01:17:22,570 --> 01:17:24,640
我会在这里简单地讲一下 

1525
01:17:24,640 --> 01:17:38,610
但基本上 如果我们在第21.39行进入参与人步行状态 

1526
01:17:38,610 --> 01:17:41,260
我们在检查输入

1527
01:17:41,260 --> 01:17:41,760
对吧？

1528
01:17:41,760 --> 01:17:44,790
我们只是说如果我们按左 右 上 下 

1529
01:17:44,790 --> 01:17:50,770
方向是向左走 向右走 等等 

1530
01:17:50,770 --> 01:17:56,530
然后我们调用实体walk state. update 

1531
01:17:56,530 --> 01:18:00,790
所以这个存在于实体中的基本状态代码 这样我们就可以

1532
01:18:00,790 --> 01:18:04,107
让每个实体都有这个代码 

1533
01:18:04,107 --> 01:18:05,940
它所做的只是检查

1534
01:18:05,940 --> 01:18:09,010
它所属的玩家或实体撞墙 

1535
01:18:09,010 --> 01:18:12,460
如果是这样 那么set there bumped等于true 

1536
01:18:12,460 --> 01:18:17,160
它所做的只是一面旗帜 上面写着 好吧 玩家撞到了一堵墙 

1537
01:18:17,160 --> 01:18:17,790
好吗？

1538
01:18:17,790 --> 01:18:18,900
这有什么关系

1539
01:18:18,900 --> 01:18:23,280
因为在我们打完电话之后 我们可以说 好吧 如果我们撞到了一堵墙 

1540
01:18:23,280 --> 01:18:26,340
并且这仅在玩家处于行走状态时发生 

1541
01:18:26,340 --> 01:18:29,550
如果我们在看左边 暂时调整一下我们的位置 

1542
01:18:29,550 --> 01:18:34,590
因为当它撞到你的时候 它会把你打回原来的世界 

1543
01:18:34,590 --> 01:18:39,030
但我们要重新调整位置到我们相撞的地方 

1544
01:18:39,030 --> 01:18:41,820
我们要检查每一个入口 然后

1545
01:18:41,820 --> 01:18:46,230
假设我们撞上了门 门开着

1546
01:18:46,230 --> 01:18:48,845
然后我们把它移到门口的中央

1547
01:18:48,845 --> 01:18:51,720
这样看起来就不会像玩家在穿墙而过 

1548
01:18:51,720 --> 01:18:54,320
我们要把它设置到墙所在的地方 

1549
01:18:54,320 --> 01:18:57,510
或者门在哪里 门口的正中央

1550
01:18:57,510 --> 01:19:00,525
然后我们要召集行动调度班

1551
01:19:00,525 --> 01:19:02,010
朝那个方向

1552
01:19:02,010 --> 01:19:06,280
所以左移 右移 上移 下移 

1553
01:19:06,280 --> 01:19:10,710
所以这四个不同的例子都会说好的 

1554
01:19:10,710 --> 01:19:12,480
玩家撞到了一个门 

1555
01:19:12,480 --> 01:19:15,510
我在某个地方有一个功能 

1556
01:19:15,510 --> 01:19:18,920
事件 打开 向下移动 向左移动 向右移动 向上移动 

1557
01:19:18,920 --> 01:19:20,312
会触发什么？

1558
01:19:27,070 --> 01:19:27,990
隔壁房间

1559
01:19:27,990 --> 01:19:31,210
它会触发我们移动到下一个房间 也是下一个房间

1560
01:19:31,210 --> 01:19:34,120
产卵 摄像机也在移动位置 

1561
01:19:38,830 --> 01:19:43,480
密码在地牢里 

1562
01:19:43,480 --> 01:19:45,982
所以我们继续看地牢 

1563
01:19:45,982 --> 01:19:50,620
所以就在这里 第29到43行 事件 

1564
01:19:50,620 --> 01:19:54,185
左移 右移 上移 下移 

1565
01:19:54,185 --> 01:19:57,320
它所做的是我们有另一个函数 叫做开始转移 

1566
01:19:57,320 --> 01:19:58,930
它接受x和y 

1567
01:19:58,930 --> 01:20:01,786
负虚拟宽度 虚拟宽度 负虚拟高度 

1568
01:20:01,786 --> 01:20:02,410
虚拟高度

1569
01:20:02,410 --> 01:20:06,910
有人记得为什么要把这些数字传进去吗？

1570
01:20:06,910 --> 01:20:11,560
如果我们向左移动 传递一个负的虚拟宽度 

1571
01:20:11,560 --> 01:20:16,000
你觉得会是多少

1572
01:20:16,000 --> 01:20:19,350
记住每个房间都有相邻的偏移量x和y

1573
01:20:19,350 --> 01:20:23,970
它渲染了这个房间 基本上添加了偏移量 

1574
01:20:23,970 --> 01:20:25,110
它的x和y 

1575
01:20:25,110 --> 01:20:28,170
如果我们开始向左移动 

1576
01:20:28,170 --> 01:20:29,340
就是x偏移量 

1577
01:20:29,340 --> 01:20:35,130
因为那个房间需要向左渲染一个屏幕宽度 对吗？

1578
01:20:35,130 --> 01:20:37,440
以此类推 以获得正确的虚拟宽度 

1579
01:20:37,440 --> 01:20:39,180
它将虚拟宽度添加到x偏移 

1580
01:20:39,180 --> 01:20:41,160
相邻的x偏移 

1581
01:20:41,160 --> 01:20:45,780
然后是虚拟高度 负数和正数表示上移和下移 

1582
01:20:45,780 --> 01:20:53,910
所以开始切换 基本上这是一个补间操作 

1583
01:20:53,910 --> 01:21:00,540
所以我们从这里开始 调用timer.tween 只需要取一个值并插值 

1584
01:21:00,540 --> 01:21:04,190
self 我们有一个摄像机和一个摄像机y 对吧？

1585
01:21:04,190 --> 01:21:06,180
等于x和y的位移 

1586
01:21:06,180 --> 01:21:07,320
最终会的

1587
01:21:07,320 --> 01:21:10,020
所以移位x和移位y是相邻的偏移量 所以我们

1588
01:21:10,020 --> 01:21:12,420
需要把相机移开 

1589
01:21:12,420 --> 01:21:17,130
所以X相机和Y相机 它们都是零 总是 

1590
01:21:17,130 --> 01:21:20,400
当房间完全完工的时候 

1591
01:21:20,400 --> 01:21:23,870
所以如果移位x是虚拟宽度 负虚拟宽度 

1592
01:21:23,870 --> 01:21:25,620
因为我们在向左移动 然后它就会

1593
01:21:25,620 --> 01:21:30,750
让摄像机在一秒钟内从右向左移动 对吗？

1594
01:21:30,750 --> 01:21:34,620
然后玩家 玩家x和玩家y 

1595
01:21:34,620 --> 01:21:39,000
这些基本上都是在这里设置在另一端

1596
01:21:39,000 --> 01:21:41,110
房间的另一个房间 

1597
01:21:41,110 --> 01:21:43,230
因此 如果玩家从房间的顶端出发

1598
01:21:43,230 --> 01:21:47,820
到隔壁房间的底部 它需要得到它的x和y

1599
01:21:47,820 --> 01:21:51,360
放在那个位置 隔壁房间的底部 

1600
01:21:51,360 --> 01:21:57,977
或者隔壁房间的左边部分 如果它们是从右边移动的 对吗？

1601
01:21:57,977 --> 01:22:00,060
或者它们的右边部分是从左边移动的 

1602
01:22:00,060 --> 01:22:01,768
最下面的部分 如果他们向上移动的话 

1603
01:22:01,768 --> 01:22:03,393
如果他们向下移动 则是向上的部分 

1604
01:22:03,393 --> 01:22:04,392
所以这就是所有的作用 

1605
01:22:04,392 --> 01:22:06,510
把他们放在正确的位置 在隔壁房间 

1606
01:22:06,510 --> 01:22:08,940
他们两个人 摄像机和播放器 

1607
01:22:08,940 --> 01:22:11,370
因为球员需要不停地移动到隔壁房间 

1608
01:22:11,370 --> 01:22:15,390
而且相机需要向上移动 

1609
01:22:15,390 --> 01:22:17,529
当它完成时 我们称其为完成移位 

1610
01:22:17,529 --> 01:22:20,070
这只是一个函数 基本上所有的东西都是0 

1611
01:22:20,070 --> 01:22:23,040
它将当前房间设置为下一个房间 

1612
01:22:23,040 --> 01:22:26,130
它将摄像机x和所有这些东西都设置为0 

1613
01:22:26,130 --> 01:22:28,950
然后所有实体和对象都设置为0 

1614
01:22:28,950 --> 01:22:31,170
因此 它们的偏移量为0 

1615
01:22:31,170 --> 01:22:33,570
所以一切基本上都是正确的 在0.0

1616
01:22:33,570 --> 01:22:35,700
再一次 就像一开始一样 

1617
01:22:38,400 --> 01:22:40,890
最后但同样重要的是 当我们进入新房间时 

1618
01:22:40,890 --> 01:22:42,840
我们一开始就把所有的门都打开 

1619
01:22:42,840 --> 01:22:45,810
然后当我们走进这里的房间时 因为这就是

1620
01:22:45,810 --> 01:22:48,330
在完成的函数中完成 调用 这

1621
01:22:48,330 --> 01:22:52,080
只有在补间结束后才会发生 

1622
01:22:52,080 --> 01:22:54,120
每个入口都将被设置为False 

1623
01:22:54,120 --> 01:22:55,300
打开等于假 

1624
01:22:55,300 --> 01:22:58,220
所以我们一进隔壁房间所有的门都会关上 

1625
01:22:58,220 --> 01:22:59,970
在我们做完补丁手术之后 

1626
01:22:59,970 --> 01:23:01,560
然后我们将播放一段门声 

1627
01:23:01,560 --> 01:23:06,540
这就是实际执行移位操作所涉及的代码 

1628
01:23:06,540 --> 01:23:08,610
所以我们能够触发它 

1629
01:23:08,610 --> 01:23:12,390
我们不一定要在玩家漫游状态下执行该代码 

1630
01:23:12,390 --> 01:23:16,800
我们只是说 如果球员撞到门口 

1631
01:23:16,800 --> 01:23:20,730
然后调度一个由地牢处理的事件 

1632
01:23:20,730 --> 01:23:25,890
因为地牢有权进入现在的房间 隔壁的房间 以及所有的东西

1633
01:23:25,890 --> 01:23:28,110
它需要真正地进行这种转变 

1634
01:23:28,110 --> 01:23:31,200
所以我们有两个分离的 但它们工作得很好

1635
01:23:31,200 --> 01:23:32,640
彼此齐头并进 

1636
01:23:32,640 --> 01:23:35,578
那么 有谁对这是如何运作的有疑问吗？

1637
01:23:38,970 --> 01:23:40,400
好的 

1638
01:23:40,400 --> 01:23:42,330
这基本上就是地下城的滚动 

1639
01:23:42,330 --> 01:23:43,760
这是一次青少年行动 

1640
01:23:43,760 --> 01:23:46,290
这是一个摄像头 一个临时的房间被渲染 

1641
01:23:46,290 --> 01:23:49,130
我们搬到一个临时房间 一切都恢复到0 

1642
01:23:49,130 --> 01:23:54,080
然后 这实际上就是那种行为的疯狂循环 

1643
01:23:54,080 --> 01:23:58,190
我们使用事件库在某种程度上清理了整个方面 

1644
01:23:58,190 --> 01:24:01,820
屏幕在这里滚动 这是另一个演示 

1645
01:24:01,820 --> 01:24:04,070
我们详细地看过了 但这是一个很好的GIF

1646
01:24:04,070 --> 01:24:07,160
我发现这在某种程度上概括了这意味着什么 

1647
01:24:07,160 --> 01:24:09,900
模版是我们之前看到的东西 

1648
01:24:09,900 --> 01:24:14,906
如果我们把它看作一张模板 那么我们

1649
01:24:14,906 --> 01:24:17,030
可以假装这些是心脏的圆圈 

1650
01:24:17,030 --> 01:24:20,600
而那个长方形是一张模板 

1651
01:24:20,600 --> 01:24:26,630
然后我们想在这些模板上画一个灰色的矩形 

1652
01:24:26,630 --> 01:24:30,330
我们可以使用模板来遮盖特定的部分 这

1653
01:24:30,330 --> 01:24:33,650
否则很难做到这一点 

1654
01:24:33,650 --> 01:24:36,740
我是说 很难有必要 也许是个别

1655
01:24:36,740 --> 01:24:41,030
渲染像素 或创建类似如下的形状 

1656
01:24:41,030 --> 01:24:43,910
对于许多非常有趣的视觉效果来说要容易得多

1657
01:24:43,910 --> 01:24:46,970
使用任意形状和大小的模板 

1658
01:24:46,970 --> 01:24:48,530
你也可以使用图像 

1659
01:24:48,530 --> 01:24:51,717
你可以使用模具的图像 来创造一些非常酷的效果 

1660
01:24:51,717 --> 01:24:54,050
我们以前讨论过它 当我谈到拱门的时候 

1661
01:24:54,050 --> 01:24:56,550
所以我不会过多地详述 

1662
01:24:56,550 --> 01:25:00,260
但是 你可以再一次看到 它到底在哪里？

1663
01:25:00,260 --> 01:25:04,070
它在房间的功能里 房间里 对不起 

1664
01:25:04,070 --> 01:25:05,410
就在这下面的底部 

1665
01:25:05,410 --> 01:25:11,870
所以从213行到229行 记住它们是模板函数 

1666
01:25:11,870 --> 01:25:14,600
这两个函数尤其是您需要使用的

1667
01:25:14,600 --> 01:25:18,650
是love.graph 绘制模板的模板 然后

1668
01:25:18,650 --> 01:25:21,830
Love.graph ics.setstenciltest 比较

1669
01:25:21,830 --> 01:25:25,400
模板将值设置为某个值 并绘制它们

1670
01:25:25,400 --> 01:25:27,210
无论该条件是否为真 

1671
01:25:27,210 --> 01:25:31,730
所以我们在这里有我们的函数 画四个矩形 

1672
01:25:31,730 --> 01:25:33,410
这些都是拱门 

1673
01:25:33,410 --> 01:25:37,220
它将绘制到这些矩形的所有像素替换为值1 

1674
01:25:37,220 --> 01:25:39,620
模板值为1 因此模板值为

1675
01:25:39,620 --> 01:25:44,870
类似于一个隐藏值 它确定图像是否将

1676
01:25:44,870 --> 01:25:47,210
不管它是不是被模压过的 

1677
01:25:47,210 --> 01:25:52,940
设定模板测试意味着我们正在寻找小于1的任何值 

1678
01:25:52,940 --> 01:25:54,222
我们会画出来的 

1679
01:25:54,222 --> 01:25:56,180
因为玩家将会是1 如果它是

1680
01:25:56,180 --> 01:26:00,530
在任何这些模板矩形上 它都不会

1681
01:26:00,530 --> 01:26:03,270
如果球员与这些模板矩形重叠 请绘制该球员 

1682
01:26:03,270 --> 01:26:05,150
这就是它通常的工作原理 

1683
01:26:05,150 --> 01:26:07,316
你可以这样做 有很多不同的比较 

1684
01:26:07,316 --> 01:26:09,650
您可以执行大于1的操作 

1685
01:26:09,650 --> 01:26:14,750
你可以做迭代模版 这样你就可以增加价值 

1686
01:26:14,750 --> 01:26:18,362
您可以使用介于0和255之间的简单值 

1687
01:26:18,362 --> 01:26:20,820
有很多有趣的效果 你可以用它 

1688
01:26:20,820 --> 01:26:25,292
但我们刚才看到的一般用法是将值设置为1 

1689
01:26:25,292 --> 01:26:28,250
如果要绘制它们 请检查它们是否小于1 

1690
01:26:28,250 --> 01:26:29,795
如果你不想画它们的话 

1691
01:26:29,795 --> 01:26:32,000
有没有人对模版制作有疑问 

1692
01:26:32,000 --> 01:26:35,480
以及这些功能是如何工作的？

1693
01:26:35,480 --> 01:26:36,412
嗯?

1694
01:26:36,412 --> 01:26:40,195
观众：所以就像用Stat模具把门遮住一样？

1695
01:26:40,195 --> 01:26:43,688
所以当你画玩家的时候 你不会真的

1696
01:26:43,688 --> 01:26:45,190
在模板上画 [INAUDIBLE] 

1697
01:26:45,190 --> 01:26:46,300
科尔顿·奥格登：是的 

1698
01:26:46,300 --> 01:26:52,240
所以这就像是让模板矩形越过门口 

1699
01:26:52,240 --> 01:26:57,625
这样当球在他们下面时 球员就不会被抽到 

1700
01:26:57,625 --> 01:27:01,290
如果我回到有它的幻灯片上 

1701
01:27:01,290 --> 01:27:03,670
模板在这里 

1702
01:27:03,670 --> 01:27:04,870
对吗？

1703
01:27:04,870 --> 01:27:08,830
我必须通过并弄清楚我需要的确切的XY 

1704
01:27:08,830 --> 01:27:09,880
而且还有一个--

1705
01:27:09,880 --> 01:27:12,400
您可以做的是 您可以将模板函数

1706
01:27:12,400 --> 01:27:16,291
画出矩形 然后你就可以把它从模具测试中拿出来 

1707
01:27:16,291 --> 01:27:16,790
然后你看 

1708
01:27:16,790 --> 01:27:19,456
实际上 您将能够看到确切的矩形在哪里 

1709
01:27:19,456 --> 01:27:22,390
因为那样它就会直接画出长方形 

1710
01:27:22,390 --> 01:27:26,714
但在这里 基本上就在这里和隔壁房间的位置之间 

1711
01:27:26,714 --> 01:27:29,380
所以当我们从这里走到隔壁房间时 它仍然是

1712
01:27:29,380 --> 01:27:31,240
用模板来刻印它们 

1713
01:27:31,240 --> 01:27:33,670
就在这里 球员要检查他们 

1714
01:27:33,670 --> 01:27:35,740
它会将其模板值设置为1 

1715
01:27:35,740 --> 01:27:40,004
它正在检查要呈现的任何小于1的值 

1716
01:27:40,004 --> 01:27:41,920
所以它不会通过测试 它会

1717
01:27:41,920 --> 01:27:46,370
在这一点上不会抽到那个球员 

1718
01:27:46,370 --> 01:27:48,490
因此 它实际上只是掩盖了玩家 

1719
01:27:48,490 --> 01:27:50,740
因为我们给它分配了正确的模板值 

1720
01:27:50,740 --> 01:27:52,617
我们对此进行了正确的比较 

1721
01:27:52,617 --> 01:27:53,950
但是 是的 实际上就是这样 

1722
01:27:53,950 --> 01:27:57,700
只是用它来 因为我们处于一种情况

1723
01:27:57,700 --> 01:28:01,690
我们的瓷砖不能干净利落地画出来

1724
01:28:01,690 --> 01:28:03,430
球员 你可以做到的 

1725
01:28:03,430 --> 01:28:06,670
你可以在拱门下面画阴影部分 

1726
01:28:06,670 --> 01:28:08,380
然后只需更改渲染顺序 

1727
01:28:08,380 --> 01:28:11,560
但我们拥有的电子表格并没有为我们提供这种灵活性 

1728
01:28:11,560 --> 01:28:17,140
因此 我们采用了更有趣的模版方法

1729
01:28:17,140 --> 01:28:20,120
为完成任务干杯 

1730
01:28:20,120 --> 01:28:21,440
我们之前看过这个 

1731
01:28:21,440 --> 01:28:26,870
所以游戏设计靠的是数据 而不是一堆逻辑 

1732
01:28:26,870 --> 01:28:32,140
所以你越能在游戏中对你的任何东西进行建模

1733
01:28:32,140 --> 01:28:35,005
像这样的数据 你的引擎越灵活 

1734
01:28:35,005 --> 01:28:36,880
人们就越容易修改你的游戏 

1735
01:28:36,880 --> 01:28:38,290
这一点非常重要 

1736
01:28:38,290 --> 01:28:40,270
你越容易让设计师

1737
01:28:40,270 --> 01:28:43,160
负责为你的游戏创造资产 

1738
01:28:43,160 --> 01:28:45,880
所以这里我们创建了一个任意的数据集合 

1739
01:28:45,880 --> 01:28:48,640
你可以想怎么复杂就怎么复杂

1740
01:28:48,640 --> 01:28:51,400
唯一真正重要的是你的游戏引擎

1741
01:28:51,400 --> 01:28:54,800
支持这些字段 并相应地对这些字段进行操作 

1742
01:28:54,800 --> 01:28:56,590
但一旦发生 我是说 

1743
01:28:56,590 --> 01:29:00,070
你就越有可能添加新的东西 

1744
01:29:00,070 --> 01:29:02,470
所以地精 我们有健康 力量 

1745
01:29:02,470 --> 01:29:05,330
因此 我们的游戏引擎应该考虑到强度 

1746
01:29:05,330 --> 01:29:08,080
这是 我们现在谈论的只是一般的抽象意义 

1747
01:29:08,080 --> 01:29:10,180
比如说我们在做一个RPG什么的

1748
01:29:10,180 --> 01:29:12,325
或许这是我们塞尔达游戏的一部分

1749
01:29:12,325 --> 01:29:14,200
如果我们再详细一点 

1750
01:29:14,200 --> 01:29:18,379
但是地精将是一个有10点生命的生物 

1751
01:29:18,379 --> 01:29:20,170
它有两个强度 所以这些值

1752
01:29:20,170 --> 01:29:21,970
当它被创建为一个实体时被加载 

1753
01:29:21,970 --> 01:29:24,010
力量是我们的引擎

1754
01:29:24,010 --> 01:29:27,130
需要适用于它决定攻击的任何东西 

1755
01:29:27,130 --> 01:29:27,630
对吧？

1756
01:29:27,630 --> 01:29:29,338
你可以在防守上做同样的事情 

1757
01:29:29,338 --> 01:29:30,880
你可以创造任意的东西 

1758
01:29:30,880 --> 01:29:32,270
有妖精的质感 

1759
01:29:32,270 --> 01:29:33,820
这就是雪碧

1760
01:29:33,820 --> 01:29:36,250
我们在这里定义了一些动画 

1761
01:29:36,250 --> 01:29:39,550
你已经看到了如何在我们的游戏引擎中实例化它们 

1762
01:29:39,550 --> 01:29:43,760
可能是从棍棒开始的 

1763
01:29:43,760 --> 01:29:49,300
你也可以参考其他类型的Lua文件

1764
01:29:49,300 --> 01:29:54,010
如果你有武器定义文件的话 

1765
01:29:54,010 --> 01:29:58,030
你可以索引到武器defs俱乐部 然后那个俱乐部项目

1766
01:29:58,030 --> 01:30:00,340
也许会有一些自己的特点

1767
01:30:00,340 --> 01:30:04,770
当你的游戏引擎加载这个地精def时 

1768
01:30:04,770 --> 01:30:09,580
它也会加载club def 并实例化一堆特性

1769
01:30:09,580 --> 01:30:13,510
到那个实体上 或者那个项目上 

1770
01:30:13,510 --> 01:30:16,600
与游戏引擎相关的行为 

1771
01:30:16,600 --> 01:30:17,570
侵略性是真的 

1772
01:30:17,570 --> 01:30:21,730
所以如果某个东西是实体的 侵略性的 那么它可能就是人工智能

1773
01:30:21,730 --> 01:30:23,180
会去找玩家 

1774
01:30:23,180 --> 01:30:23,680
对吧？

1775
01:30:23,680 --> 01:30:24,846
您可以将其设置为False 

1776
01:30:24,846 --> 01:30:27,730
所以现在你可以区分追逐玩家的实体 

1777
01:30:27,730 --> 01:30:31,420
和一些温顺的实体 只是做他们自己随机的事情 

1778
01:30:31,420 --> 01:30:32,127
晚上睡觉 

1779
01:30:32,127 --> 01:30:33,710
也许你的游戏有一个昼夜循环 

1780
01:30:33,710 --> 01:30:38,080
也许有些实体保持清醒 有些进入睡眠状态 对吗？

1781
01:30:38,080 --> 01:30:40,630
所以它看起来会说好的 现在是晚上 

1782
01:30:40,630 --> 01:30:42,520
这个实体在晚上睡觉吗？

1783
01:30:42,520 --> 01:30:43,890
如果是这样的话 没问题 

1784
01:30:43,890 --> 01:30:47,500
然后实体改变状态 休眠 对吗？

1785
01:30:47,500 --> 01:30:51,131
然后在白天 当白天发生的时候 

1786
01:30:51,131 --> 01:30:52,630
您将以相反的方式做同样的事情 

1787
01:30:52,630 --> 01:30:55,560
你会说如果实体在晚上睡觉 

1788
01:30:55,560 --> 01:30:57,670
然后你说实体 觉醒是真的 

1789
01:30:57,670 --> 01:30:59,650
或者什么都行 

1790
01:30:59,650 --> 01:31:02,549
将状态更改为清醒、空闲或行走 

1791
01:31:02,549 --> 01:31:03,340
然后是易燃物 

1792
01:31:03,340 --> 01:31:06,880
也许你有武器可以造成伤害 或者开火 

1793
01:31:06,880 --> 01:31:10,000
或者你有可以发射火焰的手电筒 或者一些--

1794
01:31:10,000 --> 01:31:12,220
也许你处在像熔岩一样的水平 

1795
01:31:12,220 --> 01:31:16,900
你知道 如果你触摸其中一块瓷砖 它就会产生易燃效果 

1796
01:31:16,900 --> 01:31:19,870
如果它是易燃的 可能你的状态也是易燃的 

1797
01:31:19,870 --> 01:31:21,320
随着时间的推移 你会受到伤害 

1798
01:31:21,320 --> 01:31:22,570
然后你改变你的动画 

1799
01:31:22,570 --> 01:31:25,090
也许你会被染成红色 或者类似的颜色 

1800
01:31:25,090 --> 01:31:27,530
但考虑到所有这些不同的可能性 

1801
01:31:27,530 --> 01:31:31,030
就像你的引擎所能做的一样 你几乎可以任意地创造

1802
01:31:31,030 --> 01:31:34,390
复杂的数据结构和实体 以及项 

1803
01:31:34,390 --> 01:31:36,790
和你想要的任何东西 而不是

1804
01:31:36,790 --> 01:31:38,290
来创建一个妖精职业 

1805
01:31:38,290 --> 01:31:39,850
或者是一个骨架类 

1806
01:31:39,850 --> 01:31:43,180
或者是一个任意复杂的生物类别 

1807
01:31:43,180 --> 01:31:48,310
你只需要用属性和模型组合你的生物

1808
01:31:48,310 --> 01:31:49,227
它的行为就是这样的 

1809
01:31:49,227 --> 01:31:51,810
组成重于继承 我们上周谈到了 

1810
01:31:51,810 --> 01:31:53,180
在游戏设计中非常有价值 

1811
01:31:53,180 --> 01:31:56,020
这就是Unity的游戏引擎所采用的方法 

1812
01:31:56,020 --> 01:31:58,840
由于实体是纯实体组件系统 

1813
01:31:58,840 --> 01:32:03,940
其中实体被建模为组件的集合

1814
01:32:03,940 --> 01:32:05,290
每个人都做了一些事情 

1815
01:32:05,290 --> 01:32:08,380
我们也几乎可以把它们看作是组件 

1816
01:32:08,380 --> 01:32:11,500
尽管是在一种简单得多的表现形式中 

1817
01:32:11,500 --> 01:32:14,740
有没有人对此有疑问 或者为什么它有用 

1818
01:32:14,740 --> 01:32:18,670
或诸如此类的事？

1819
01:32:18,670 --> 01:32:20,330
好的 

1820
01:32:20,330 --> 01:32:24,560
所以我今天最不想谈的就是 我看到了一两个学生

1821
01:32:24,560 --> 01:32:27,440
提到他们多么希望自己知道 或者多么希望我们

1822
01:32:27,440 --> 01:32:31,670
更多地谈了一下当时是如何进行编程的 

1823
01:32:31,670 --> 01:32:38,220
所以我不一定是6502汇编编程方面的专家 

1824
01:32:38,220 --> 01:32:39,786
这就是NES是用来写的 

1825
01:32:39,786 --> 01:32:41,910
有很多人在这方面做得很好 

1826
01:32:41,910 --> 01:32:43,118
但这里有一些联系 

1827
01:32:43,118 --> 01:32:47,510
所以在幻灯片中 如果你想看网站上的幻灯片 

1828
01:32:47,510 --> 01:32:52,160
实际上 自制酒在某些社区中相当受欢迎

1829
01:32:52,160 --> 01:32:52,970
上网 

1830
01:32:52,970 --> 01:32:56,180
以及它本质上为编译器带来了什么

1831
01:32:56,180 --> 01:33:00,770
这将为某些任意处理器或开发编译源代码

1832
01:33:00,770 --> 01:33:04,040
来自某个任意计算机系统的环境 

1833
01:33:04,040 --> 01:33:08,360
像NES一样 它是一台基于8位微处理器的机器

1834
01:33:08,360 --> 01:33:11,412
拥有自己的一套有趣的硬件 

1835
01:33:11,412 --> 01:33:13,370
它允许您为此编译程序集

1836
01:33:13,370 --> 01:33:16,060
并通过一个名为模拟器的程序实际运行它 

1837
01:33:16,060 --> 01:33:21,020
而仿真器只允许您运行ROM映像 或者只运行任意数据

1838
01:33:21,020 --> 01:33:26,930
它映射到某个系统的机器指令

1839
01:33:26,930 --> 01:33:30,980
仿真器已经通过虚拟机进行了仿真 

1840
01:33:30,980 --> 01:33:35,539
因此 如果你想更详细地研究它 

1841
01:33:35,539 --> 01:33:36,830
这里有几个链接 

1842
01:33:36,830 --> 01:33:39,696
所以 NES.wiki有很多很棒的链接 

1843
01:33:39,696 --> 01:33:41,570
有一本编程指南是这样写的

1844
01:33:41,570 --> 01:33:45,980
关于如何进行一些6502组装以及如何使用NES的基础知识 

1845
01:33:45,980 --> 01:33:47,810
以及它的特殊硬件 

1846
01:33:47,810 --> 01:33:54,140
然后大多数人使用的编译器被称为CC 65 

1847
01:33:54,140 --> 01:33:58,160
它是一个65 02汇编语言编译器 

1848
01:33:58,160 --> 01:34:02,460
这是一些源代码的一个例子 

1849
01:34:02,460 --> 01:34:04,130
这本书读起来有点难 

1850
01:34:04,130 --> 01:34:07,760
但我不能放大 我想不是 

1851
01:34:07,760 --> 01:34:11,180
但大意是你有很多--

1852
01:34:11,180 --> 01:34:13,305
在这里 实际上我可以在网上调出它 

1853
01:34:13,305 --> 01:34:14,110
让我试试看 

1854
01:34:17,270 --> 01:34:20,280
超级马里奥反汇编 

1855
01:34:20,280 --> 01:34:23,630
那就去这里吧 

1856
01:34:23,630 --> 01:34:24,380
这是在Github上 

1857
01:34:24,380 --> 01:34:29,930
所以有人反编译 基本上 或者说反汇编 

1858
01:34:29,930 --> 01:34:34,400
获取代表Super的所有机器代码和ROM镜像的字节

1859
01:34:34,400 --> 01:34:38,300
Mario Bros 然后将其转换回汇编语言 

1860
01:34:38,300 --> 01:34:40,220
然后给它添加了评论 

1861
01:34:40,220 --> 01:34:43,910
因为我不会太详细地讲什么是组装 

1862
01:34:43,910 --> 01:34:46,190
以及它是如何工作的 但本质上说 它只是

1863
01:34:46,190 --> 01:34:50,750
直接位于机器代码上方的一层 其中关键字

1864
01:34:50,750 --> 01:34:54,170
映射到内存中的基本字节数

1865
01:34:54,170 --> 01:34:55,850
它们实际上是程序指令 

1866
01:34:55,850 --> 01:34:59,810
这会影响你的CPU的行为 这样你就可以得到程序 

1867
01:34:59,810 --> 01:35:05,000
而这就是c语言的基础 在它的每一种语言中 

1868
01:35:05,000 --> 01:35:06,390
之后 

1869
01:35:06,390 --> 01:35:10,709
所以如果我放大这里 看看我能不能 

1870
01:35:10,709 --> 01:35:11,750
它有点慢了 

1871
01:35:11,750 --> 01:35:15,740
但它让我--

1872
01:35:15,740 --> 01:35:18,020
所以我们可以在这里看到 

1873
01:35:20,840 --> 01:35:23,240
我认为它滞后是因为文件太大了 

1874
01:35:23,240 --> 01:35:25,960
这就像是14000行代码 

1875
01:35:25,960 --> 01:35:30,050
因为组装是一件很长很长的事情 

1876
01:35:30,050 --> 01:35:31,730
因为有太多的--

1877
01:35:31,730 --> 01:35:33,980
你需要有 就像真的很慢 

1878
01:35:33,980 --> 01:35:36,380
无限放大 

1879
01:35:36,380 --> 01:35:39,950
你需要做的步骤太多了

1880
01:35:39,950 --> 01:35:43,730
为了实现像C这样的高级语言所实现的相同功能 

1881
01:35:43,730 --> 01:35:47,270
甚至比这更高的语言 

1882
01:35:47,270 --> 01:35:50,810
认为很多事情都是理所当然的 特别是像加载这样的事情

1883
01:35:50,810 --> 01:35:51,320
寄存器 

1884
01:35:51,320 --> 01:35:54,620
所以每个CPU都有一系列可以存储数值的寄存器 

1885
01:35:54,620 --> 01:35:58,190
然后CPU有逻辑 你基本上可以

1886
01:35:58,190 --> 01:36:02,520
说OK 如果寄存器A中的值大于或等于某个值 

1887
01:36:02,520 --> 01:36:06,770
然后转移到汇编代码的这个序列 

1888
01:36:06,770 --> 01:36:12,547
通常 您必须在字节级执行和/或操作 

1889
01:36:12,547 --> 01:36:13,130
仅以字节为单位 

1890
01:36:13,130 --> 01:36:18,130
就像这里 我们可以看到我们正在结束值3

1891
01:36:18,130 --> 01:36:20,300
在登记簿a中 

1892
01:36:20,300 --> 01:36:23,930
就像我说的 不要太过沉迷于什么是组装 

1893
01:36:23,930 --> 01:36:28,760
但对于那些好奇游戏是如何在80年代实现的 甚至

1894
01:36:28,760 --> 01:36:31,400
90年代早期 都是用汇编语言

1895
01:36:31,400 --> 01:36:33,920
因为汇编语言就是你

1896
01:36:33,920 --> 01:36:37,880
对你要编程的机器的CPU进行编程 

1897
01:36:37,880 --> 01:36:41,660
这就是你如何获得尽可能多的效率 

1898
01:36:41,660 --> 01:36:46,040
如果你了解你的计算环境 你就知道你的CPU能做什么 

1899
01:36:46,040 --> 01:36:51,110
关于编译像C C++ 或Java这样的语言 

1900
01:36:51,110 --> 01:36:53,480
这是一个比那些更高的抽象 

1901
01:36:53,480 --> 01:36:57,160
就是你允许某种算法为你做这些工作 

1902
01:36:57,160 --> 01:37:01,310
你允许算法把你的源代码

1903
01:37:01,310 --> 01:37:03,800
然后把它变成这样

1904
01:37:03,800 --> 01:37:05,810
比这层低一层 有效 

1905
01:37:05,810 --> 01:37:08,210
这是它所产生的一个中间层次 

1906
01:37:08,210 --> 01:37:12,320
但可以说 在80年代和90年代 

1907
01:37:12,320 --> 01:37:17,059
C编译器在创建游戏方面不如人类 

1908
01:37:17,059 --> 01:37:19,850
特别是做很多他们需要做的棘手的事情 

1909
01:37:19,850 --> 01:37:24,980
为了让它们在处理器上高效地工作 在当时 

1910
01:37:24,980 --> 01:37:26,750
1到3兆赫的速度 

1911
01:37:26,750 --> 01:37:31,070
现在我们有三个千兆赫的处理器 这没什么大不了的 

1912
01:37:31,070 --> 01:37:35,990
但这实际上是一个窗口 

1913
01:37:35,990 --> 01:37:40,160
80年代和90年代开发游戏的情况 

1914
01:37:40,160 --> 01:37:43,130
然后在90年代 像N64 Playstation 1这样的东西 

1915
01:37:43,130 --> 01:37:49,190
在Playstation 2上 等等 它通常是用一种语言完成的 

1916
01:37:49,190 --> 01:37:50,960
比如C或C++ 

1917
01:37:50,960 --> 01:37:53,120
有时候有一些变种 

1918
01:37:53,120 --> 01:37:55,970
某些游戏机 如PS3有一个臭名昭著的困难的图形

1919
01:37:55,970 --> 01:37:57,390
处理器编程 

1920
01:37:57,390 --> 01:38:01,070
所以很多PS3的三个团队需要在汇编中编程 

1921
01:38:01,070 --> 01:38:05,600
即使是在2007年 2009年 

1922
01:38:05,600 --> 01:38:11,240
但这就是 简而言之 它就像编程的65 02 

1923
01:38:11,240 --> 01:38:14,270
如果你想看上面的链接 

1924
01:38:14,270 --> 01:38:16,550
一个很有启发性的经历

1925
01:38:16,550 --> 01:38:19,820
并试图理解大会的工作 

1926
01:38:19,820 --> 01:38:25,310
这很困难 也很繁重 因为

1927
01:38:25,310 --> 01:38:28,820
这些程序是什么 每个指令是多么的微小 

1928
01:38:28,820 --> 01:38:32,300
就像只是检查 只是把一个值加载到一个寄存器 

1929
01:38:32,300 --> 01:38:36,320
循环通常只是迭代地加载一个值

1930
01:38:36,320 --> 01:38:37,220
到一个寄存器 

1931
01:38:37,220 --> 01:38:41,030
然后像执行一些操作 或计算 从那里 

1932
01:38:41,030 --> 01:38:43,100
然后分支到其他代码循环 

1933
01:38:43,100 --> 01:38:46,230
很多内容都可以压缩成几行C语言 

1934
01:38:46,230 --> 01:38:48,710
或者更少的Lua行 

1935
01:38:48,710 --> 01:38:52,520
所以更多的负担 但有洞察力 

1936
01:38:52,520 --> 01:38:54,770
肯定是对深入调查的一些见解

1937
01:38:54,770 --> 01:38:56,250
看向那里

1938
01:38:56,250 --> 01:38:59,300
这些都是NES开发wiki上的链接 

1939
01:38:59,300 --> 01:39:02,330
Wiki.NESdev.com如果你有兴趣看的话 

1940
01:39:02,330 --> 01:39:06,500
在作业5中 就像你在作业4中做的那样 

1941
01:39:06,500 --> 01:39:09,020
你可以创建一个可消耗的游戏对象 

1942
01:39:09,020 --> 01:39:13,060
可以随意使用作业4中的代码来完成此任务 

1943
01:39:13,060 --> 01:39:16,890
当你定义你的消费函数时 

1944
01:39:16,890 --> 01:39:21,550
如果你们打算采用和上次作业相同的模式 那么有什么想法吗

1945
01:39:21,550 --> 01:39:23,514
我们该怎么做

1946
01:39:26,460 --> 01:39:31,030
可能只是增加了破坏实体的反义词 对吧？

1947
01:39:31,030 --> 01:39:32,910
我们想添加心脏 

1948
01:39:32,910 --> 01:39:35,760
我们希望将HP添加到其中 

1949
01:39:35,760 --> 01:39:41,100
你会看到在发行版中health被建模为偶数 

1950
01:39:41,100 --> 01:39:43,970
因为每一个数字都是半颗心 

1951
01:39:43,970 --> 01:39:44,526
是的

1952
01:39:44,526 --> 01:39:46,900
问：你能给一个负数吗？

1953
01:39:46,900 --> 01:39:48,690
科尔顿·奥格登：你可以 

1954
01:39:48,690 --> 01:39:51,300
这实际上也是同样的事情 

1955
01:39:51,300 --> 01:39:53,460
是的

1956
01:39:53,460 --> 01:39:55,930
第二部分是包括锅 

1957
01:39:55,930 --> 01:39:57,570
所以在精灵表中有罐子 

1958
01:39:57,570 --> 01:39:58,791
所以这些应该是实心的 

1959
01:39:58,791 --> 01:40:00,540
当玩家与他们互动时 

1960
01:40:00,540 --> 01:40:04,870
应该把他赶出去

1961
01:40:04,870 --> 01:40:06,120
让玩家举起它们 

1962
01:40:06,120 --> 01:40:09,036
所以在精灵表中有一个动画 它实际上允许--

1963
01:40:09,036 --> 01:40:11,730
显示玩家举起罐子

1964
01:40:11,730 --> 01:40:15,630
所以你可能需要一个新的状态 玩家举罐状态 

1965
01:40:15,630 --> 01:40:16,710
与大麻州同行 

1966
01:40:16,710 --> 01:40:18,330
不管你怎么定义它 

1967
01:40:18,330 --> 01:40:22,920
但你基本上需要有这两个人 才能让这件事起作用 

1968
01:40:22,920 --> 01:40:25,770
我们需要做的一件事是什么？

1969
01:40:25,770 --> 01:40:26,580
抬起锅来 

1970
01:40:26,580 --> 01:40:29,340
有什么主意吗？

1971
01:40:29,340 --> 01:40:34,320
除了渲染方面 例如 当玩家四处走动时 

1972
01:40:34,320 --> 01:40:36,540
需要采取什么措施？

1973
01:40:36,540 --> 01:40:38,889
如果他拿着罐子的话 

1974
01:40:38,889 --> 01:40:40,577
观众：他比较慢 

1975
01:40:40,577 --> 01:40:42,160
科尔顿·奥格登：你可以让他慢一点 

1976
01:40:42,160 --> 01:40:43,170
是的 这是有可能的 

1977
01:40:43,170 --> 01:40:45,240
这不是作业所必需的 

1978
01:40:45,240 --> 01:40:46,890
比这更基本的 

1979
01:40:49,674 --> 01:40:51,840
赌注需要追踪玩家的位置 对吗？

1980
01:40:51,840 --> 01:40:53,881
它需要相对于球员的位置 

1981
01:40:53,881 --> 01:40:59,337
因此 保持赌注可能比玩家高出一小部分 

1982
01:40:59,337 --> 01:41:01,420
对于如何实现这一点 我不会太挑剔 

1983
01:41:01,420 --> 01:41:04,680
但博彩需要跟踪玩家 

1984
01:41:04,680 --> 01:41:06,240
实际上 这就是下一点 

1985
01:41:06,240 --> 01:41:07,770
行走的动画 就像我说的 应该

1986
01:41:07,770 --> 01:41:09,420
在他们拿着的时候换衣服 

1987
01:41:09,420 --> 01:41:11,430
最后 允许玩家投掷水壶 

1988
01:41:11,430 --> 01:41:15,150
所以当你扔罐子的时候 基本上就是把罐子变成了抛射物 

1989
01:41:15,150 --> 01:41:18,442
如果它撞到了其中一面墙 就把它打破 

1990
01:41:18,442 --> 01:41:21,150
您可以只是立即取消绘制 或有一些动画 

1991
01:41:21,150 --> 01:41:21,960
由你决定 

1992
01:41:21,960 --> 01:41:25,200
但是 如果它撞到了墙 就放弃它 

1993
01:41:25,200 --> 01:41:28,140
触发它--可能只是触发它到一些值 假 

1994
01:41:28,140 --> 01:41:31,140
渲染是假的 无论你想做什么 

1995
01:41:31,140 --> 01:41:35,640
如果它击中敌人 它应该会对敌人造成一次伤害 

1996
01:41:35,640 --> 01:41:37,140
就像我们已经看到的一样 

1997
01:41:37,140 --> 01:41:39,420
如果它运行的距离超过四块瓷砖 

1998
01:41:39,420 --> 01:41:43,390
除了还撞到其中一堵墙 然后把它也毁了 

1999
01:41:43,390 --> 01:41:47,430
这些都是作业5的主要组成部分 

2000
01:41:47,430 --> 01:41:51,750
而你实现大部分目标的方式是相当灵活的 

2001
01:41:51,750 --> 01:41:55,170
但没错 这就是第五课 塞尔达传奇 

2002
01:41:55,170 --> 01:41:56,070
所以感谢你们的光临 

2003
01:41:56,070 --> 01:41:58,235
下次见 
