1
00:00:00,000 --> 00:00:02,976
[音乐播放]
[MUSIC PLAYING]

2
00:00:16,097 --> 00:00:17,430
科尔顿·奥格登：嗨 晚上好 
COLTON OGDEN: Hey, good evening.

3
00:00:17,430 --> 00:00:19,970
欢迎来到GD50第四讲 
Welcome to GD50 lecture four.

4
00:00:19,970 --> 00:00:22,140
这是超级马里奥兄弟 
This is Super Mario Bros.

5
00:00:22,140 --> 00:00:23,990
然而 正如这里的幻灯片所示 我们是
As seen on the slides here, though, we're

6
00:00:23,990 --> 00:00:26,220
而不是使用真正的超级马里奥兄弟精灵床单 
not using the actual Super Mario Bros. sprite sheet.

7
00:00:26,220 --> 00:00:27,260
这有点像敲竹杠 
This is sort of like a rip off.

8
00:00:27,260 --> 00:00:28,968
但我发现了一张非常棒的雪碧表
But I found a really awesome sprite sheet

9
00:00:28,968 --> 00:00:33,590
所有的基本瓷砖 我们需要让这件事工作 
that has all the basic tiles that we need to get this thing working.

10
00:00:33,590 --> 00:00:36,782
在发行版中有一个链接 可以在哪里在线找到它 
There's a link in the distro as to where you can find it online.

11
00:00:36,782 --> 00:00:38,240
我玩得很开心 
I had a lot of fun playing with it.

12
00:00:38,240 --> 00:00:40,040
所以希望 如果你好奇 也许你
So hopefully, maybe if you're curious, you

13
00:00:40,040 --> 00:00:43,100
可以用里面的一些精灵去做你自己的事情 
can use some of the sprites in there to go off and do your own thing.

14
00:00:43,100 --> 00:00:48,740
但超级马里奥兄弟--这堂课和作业的实际游戏
But Super Mario Bros.-- the actual game which this lecture and assignment are

15
00:00:48,740 --> 00:00:51,822
基于--这是这里显示的游戏 
based off of-- is the game shown here.

16
00:00:51,822 --> 00:00:53,280
我想每个人都知道这是什么 
I think everybody knows what it is.

17
00:00:53,280 --> 00:00:55,238
这可能是有史以来最著名的比赛 
It's probably the most famous game of all time.

18
00:00:55,238 --> 00:00:57,260
但这款游戏是1985年问世的--
But this game came out in 1985--

19
00:00:57,260 --> 00:00:59,720
在某种程度上给游戏行业带来了革命 
sort of revolutionized the gaming industry.

20
00:00:59,720 --> 00:01:03,890
正是这款游戏将游戏行业从崩溃中拯救出来
It was the game that brought the gaming industry from a crash

21
00:01:03,890 --> 00:01:08,530
在70年代 由于许多糟糕的游戏制作政策
in the '70s thanks to a lot of poor game making policies

22
00:01:08,530 --> 00:01:11,630
以及公司和低质量保证标准 
and companies and low QA standards.

23
00:01:11,630 --> 00:01:15,200
它基本上经历了70年代末80年代初的游戏崩盘
It basically took the gaming crash of the late '70s, early '80s

24
00:01:15,200 --> 00:01:19,340
并将游戏真正带回了人们意识的前沿 
and brought games really back to the forefront of people's consciousness.

25
00:01:19,340 --> 00:01:22,700
这款游戏和像塞尔达传奇这样的游戏以及许多其他NES游戏
This and games like Legend of Zelda and a lot of other NES titles

26
00:01:22,700 --> 00:01:25,280
使任天堂基本上成为视频游戏的霸主
made Nintendo basically the dominator of the video games

27
00:01:25,280 --> 00:01:27,346
80年代和90年代的工业 
industry in the '80s and '90s.

28
00:01:27,346 --> 00:01:29,470
即使在今天 有了像《野性呼吸》这样的游戏 
And even today, with games like Breath of the Wild,

29
00:01:29,470 --> 00:01:31,670
他们仍在做自己的事 
they're still doing their thing.

30
00:01:31,670 --> 00:01:32,900
这是超级马里奥兄弟 
This is Super Mario Bros.

31
00:01:32,900 --> 00:01:34,670
这是一个2D平台 
It's a 2D platformer.

32
00:01:34,670 --> 00:01:38,270
这基本上意味着你控制着马里奥 他是一名水管工 
And what this basically means is you control Mario, who's a plumber.

33
00:01:38,270 --> 00:01:41,570
他走来走去 站在一边看着他 
He goes around, walks sort of looking at him from the side.

34
00:01:41,570 --> 00:01:42,800
他从左走到右 
He walks left to right.

35
00:01:42,800 --> 00:01:44,130
他能跳上跳下 
He can jump up and down.

36
00:01:44,130 --> 00:01:45,240
他受到重力的影响 
He's affected by gravity.

37
00:01:45,240 --> 00:01:46,280
他能打出盖帽 
He can hit blocks.

38
00:01:46,280 --> 00:01:47,420
他能扑向敌人 
He can jump on enemies.

39
00:01:47,420 --> 00:01:50,450
他可以顺着管道往下走 有很多层 
He can go down pipes, and there's a bunch of levels.

40
00:01:50,450 --> 00:01:53,350
在当时 这是一场相当复杂的游戏 
It was, for its time, quite a complicated game,

41
00:01:53,350 --> 00:01:58,660
它催生了无数的分支和盗版以及其他优质产品
and it spawned numerous offshoots and rip offs and other good quality

42
00:01:58,660 --> 00:02:00,580
平台玩家
platformers.

43
00:02:00,580 --> 00:02:02,550
当我们今天谈论《超级马里奥兄弟》时 
While we talk about Super Mario Bros. today,

44
00:02:02,550 --> 00:02:05,840
我们将要讨论的一些主题是平铺地图--
some of the topics we'll actually be talking about are tile maps--

45
00:02:05,840 --> 00:02:10,130
所以我们可以用一系列的数字
so how we can take basically a series of numbers--

46
00:02:10,130 --> 00:02:13,640
把ID拼起来变成游戏世界
tile IDs-- and turn that into a game world.

47
00:02:13,640 --> 00:02:20,260
正如你在这里看到的 游戏被分成16乘16的方块 
As you can see here, the game is broken up into blocks of 16 by 16 tiles.

48
00:02:20,260 --> 00:02:22,460
你可以看到砖块和问号块 
You can see the bricks and the question mark blocks,

49
00:02:22,460 --> 00:02:26,630
管道甚至都是由简单的瓦片组成 
and the pipes are even all composed of simple tiles.

50
00:02:26,630 --> 00:02:28,610
它们映射到身份证 
And they map to IDs.

51
00:02:28,610 --> 00:02:34,100
当你有一个2D表格或数组 你只是把它全部覆盖起来 
And when you take a 2D table or array and you just iterate over all of it

52
00:02:34,100 --> 00:02:37,550
并在适当的x y 
and render the appropriate tile at the appropriate x, y,

53
00:02:37,550 --> 00:02:40,190
你会感觉自己存在于某个游戏世界中
you get the appearance of existing in some game world,

54
00:02:40,190 --> 00:02:43,769
尽管它只是由一堆小方块组成 
even though it's just composed of a bunch of tiny little blocks.

55
00:02:43,769 --> 00:02:45,560
2D动画是我们将要讨论的内容 
2D animation is something we'll talk about.

56
00:02:45,560 --> 00:02:47,393
到目前为止 我们还没有真正做任何动画
So far, we haven't really done any animation

57
00:02:47,393 --> 00:02:50,790
至少在性格方面是这样的 
at all in terms of at least characters.

58
00:02:50,790 --> 00:02:52,250
我们会和马里奥一起做的 
We'll do that with Mario.

59
00:02:52,250 --> 00:02:55,610
他会有我们版本的马里奥 外星人
He'll have-- our version of Mario, an alien--

60
00:02:55,610 --> 00:02:58,006
当他移动的时候 他会有两帧动画 
when he's moving, he'll have two frames of animation.

61
00:02:58,006 --> 00:03:00,380
动画的画面--有点像一本翻页书
The frames of animation-- that's sort of like a flip book

62
00:03:00,380 --> 00:03:03,005
如果你用过的话 你可以看到单独的图片 
if you've ever used one, where you can see individual pictures.

63
00:03:03,005 --> 00:03:05,180
当你快速地背靠背展示它们时 
And when you display them rapidly back to back,

64
00:03:05,180 --> 00:03:07,190
你会看到动画的外观 
you get the appearance of animation.

65
00:03:07,190 --> 00:03:08,480
我们会讨论的 
We'll be talking about that.

66
00:03:08,480 --> 00:03:11,300
程序化关卡生成--我们将把所有的关卡
Procedural level generation-- we'll be making all of our levels

67
00:03:11,300 --> 00:03:12,570
随机生成 
generate randomly.

68
00:03:12,570 --> 00:03:14,900
所以每次我们从头开始玩这个游戏 
So every time we play the game from the beginning,

69
00:03:14,900 --> 00:03:16,566
一切都会完全不同
everything will be completely different.

70
00:03:16,566 --> 00:03:19,370
我们不必硬编码一组有限的水平 
We don't have to hard code a finite set of levels.

71
00:03:19,370 --> 00:03:23,180
在我看来 一切都将是动态的 也是有趣的 
Everything will be dynamic and also interesting, in my opinion.

72
00:03:23,180 --> 00:03:25,820
我们会讨论一些平台物理学的基础知识
We'll talk about the basics of platformer physics

73
00:03:25,820 --> 00:03:27,740
以及如何将其应用到游戏世界中
and how we can apply that to our game world

74
00:03:27,740 --> 00:03:34,310
这里 因为我们只是使用一个瓷砖表 
here, because we are just using a table of tiles,

75
00:03:34,310 --> 00:03:37,730
每一个都有一个x y在游戏世界空间中被硬编码 
each with an x, y that's hard coded in the game world space.

76
00:03:37,730 --> 00:03:41,330
我们要做的就是拿马里奥的x y 
All we have to really do is take an x, y of Mario, for example,

77
00:03:41,330 --> 00:03:44,150
然后除以图块大小
and then just divide that by the tile size.

78
00:03:44,150 --> 00:03:46,670
然后我们基本上得到了
And then we get basically what tile that is

79
00:03:46,670 --> 00:03:48,960
在我们的阵列中 在世界的那个点 
in our array at that point in the world.

80
00:03:48,960 --> 00:03:53,750
因此可以很容易地进行任意的碰撞检测
And so it's really easy to do arbitrary collision detection based

81
00:03:53,750 --> 00:03:56,210
关于你要去的方向 而不是迭代
on what direction you're going and not have to iterate over

82
00:03:56,210 --> 00:03:57,860
你世界里的每一块瓷砖 
every single tile in your world.

83
00:03:57,860 --> 00:04:01,430
因为这只是一个简单的数学运算 就可以得到准确的切片
Because it's just a simple mathematical operation to get the exact tile

84
00:04:01,430 --> 00:04:05,000
给出两个坐标 因为世界在一个固定的空间里 
given two coordinates, since the world is in a fixed space.

85
00:04:05,000 --> 00:04:07,250
我们将在我们的游戏中有一个小蜗牛
We'll have a little snail in our game that

86
00:04:07,250 --> 00:04:09,680
四处走动 做几个随机的动画
walks around and does a couple of random animations

87
00:04:09,680 --> 00:04:13,070
它会追逐玩家 就像是人工智能的一个基本入门 
and will go after the player, sort of like a little basic intro to AI.

88
00:04:13,070 --> 00:04:16,250
最后 我们将讨论通电和游戏对象之类的东西
And then lastly, we'll touch on things like power ups and game objects

89
00:04:16,250 --> 00:04:19,200
以及我们可能如何影响马里奥并获得这些
and how we might be able to influence Mario and pick those up

90
00:04:19,200 --> 00:04:21,079
诸如此类的事情 
and that sort of thing.

91
00:04:21,079 --> 00:04:22,370
所以 首先 我们来看一段演示 
So first though, a demo.

92
00:04:22,370 --> 00:04:24,560
所以如果有谁愿意上台
So if anybody is willing to come up on stage

93
00:04:24,560 --> 00:04:29,660
要测试我的Mario实现 那将是非常棒的 
to test out my implementation of Mario, that would be awesome.

94
00:04:29,660 --> 00:04:31,440
詹姆斯?
James?

95
00:04:31,440 --> 00:04:35,970
我要进入这里 所以我们应该都准备好了 
I'm going to go ahead into here, so we should be all ready to go.

96
00:04:35,970 --> 00:04:39,360
所以一旦你准备好了 继续并点击那里的返回 
So as soon as you're ready, go ahead and hit Return there,

97
00:04:39,360 --> 00:04:42,510
而且你应该启动并运行它 
and you should be up and running.

98
00:04:42,510 --> 00:04:45,380
所以作为随机水平的一部分--
So as a part of having random levels--

99
00:04:45,380 --> 00:04:49,160
所以目前 我们有一个绿色外星人 
so currently, we have a green alien.

100
00:04:49,160 --> 00:04:53,270
在这种情况下 这些区块有一个随机的机会来产生宝石 
The blocks have a random chance in this case to spawn a gem.

101
00:04:53,270 --> 00:04:56,469
因此 一旦他们这样做了 你就可以拿起宝石了 
And so once they do, you can pick the gem up.

102
00:04:56,469 --> 00:04:58,010
要么他们有宝石 要么他们没有 
Either they have a gem or they don't.

103
00:04:58,010 --> 00:05:00,330
你可以拿起它 你会得到100分 
You can pick it up, and you get 100 points.

104
00:05:00,330 --> 00:05:02,180
正如我们所见 世界在某种程度上正在发生变化
As we can see, the world is sort of shifting

105
00:05:02,180 --> 00:05:07,537
基于詹姆斯的化身在哪里 所以它跟踪角色 
based on where James's avatar is, so it tracks the character.

106
00:05:07,537 --> 00:05:08,870
我们对相机有了一些概念 
We have some notion of a camera.

107
00:05:08,870 --> 00:05:11,430
到目前为止 你在积木上越来越不走运了 
You're getting unlucky with the blocks so far.

108
00:05:11,430 --> 00:05:15,810
所以你可能会从空间中掉下来 所以你可能会想要避免这种情况 
So you can fall down through the spaces, so you probably want to avoid that.

109
00:05:15,810 --> 00:05:18,314
但如果你想演示一下如何做到这一点 
But if you want to demonstrate doing it--

110
00:05:18,314 --> 00:05:20,730
因此 在这种情况下 我们与它下面的两个街区相撞 
so in that case, we collided with the two blocks below it.

111
00:05:20,730 --> 00:05:23,070
右边的那个有宝石 
The one on the right had the gem.

112
00:05:23,070 --> 00:05:26,160
所以请继续往下倒 这样我们就可以演示了 
So go ahead and just fall down so we can demonstrate.

113
00:05:26,160 --> 00:05:28,350
因此 当我们摔倒时 我们会检测玩家是否
So when we fall down, we detect whether the player

114
00:05:28,350 --> 00:05:31,312
低于世界极限 然后我们让他回来
has gone below the world limit, and then we start him back

115
00:05:31,312 --> 00:05:32,520
在比赛开始的时候 
at the beginning of the game.

116
00:05:32,520 --> 00:05:35,220
你可以按Enter键 它应该会重生一个全新的世界 
You can press Enter, it should regenerate a brand new world.

117
00:05:35,220 --> 00:05:38,400
注意我们是如何在地面上随机打洞的 
Notice how we have random holes in the ground.

118
00:05:38,400 --> 00:05:39,960
我们有随机的瓷砖 
We have random tiles.

119
00:05:39,960 --> 00:05:41,697
我们为他们准备了随机的头衔 
We have random toppers for them.

120
00:05:41,697 --> 00:05:42,780
所有的区块都是随机的 
All the blocks are random.

121
00:05:42,780 --> 00:05:44,220
我们现在有蜗牛了 
We have snails now.

122
00:05:44,220 --> 00:05:45,960
他们在追逐詹姆斯 
They're sort of chasing after James.

123
00:05:45,960 --> 00:05:47,469
他可以跳到它们上面 
He can jump on top of them.

124
00:05:47,469 --> 00:05:50,010
这里有很多移动的小棋子 但也有很多
There's a lot of little moving pieces here, but a lot of them

125
00:05:50,010 --> 00:05:51,270
实际上非常简单 
are actually pretty simple.

126
00:05:51,270 --> 00:05:54,610
我很快就会向你们展示 
And I'll show you very shortly.

127
00:05:54,610 --> 00:05:55,970
詹姆斯：我应该停下来吗？
JAMES: Should I stop?

128
00:05:55,970 --> 00:05:56,490
科尔顿·奥格登：是的 当然 
COLTON OGDEN: Yeah, sure.

129
00:05:56,490 --> 00:05:57,390
这将是一个很好的观点 
That would be a great point.

130
00:05:57,390 --> 00:05:58,098
所以谢谢你 詹姆斯 
So thanks, James.

131
00:05:58,098 --> 00:05:59,610
非常感激 
Appreciate it.

132
00:05:59,610 --> 00:06:04,470
目前 还没有水平结束的概念 
Currently, there is no notion of a level ending.

133
00:06:04,470 --> 00:06:06,300
这是这篇文章的一部分 实际上将
That's part of the piece that actually will

134
00:06:06,300 --> 00:06:09,600
产生一个玩家可以与之交互的对象 只是重新触发
spawn an object that the player can interact with to just sort of retrigger

135
00:06:09,600 --> 00:06:11,490
基本上是一个新的水平 
a new level, basically.

136
00:06:11,490 --> 00:06:18,670
但这个基本平台背后的整个引擎都在那里 而且都能正常工作 
But the whole engine behind this basic platformer is there, and it all works.

137
00:06:18,670 --> 00:06:22,410
所以我们的目标是在这里看到的 
And so our goal is seen here.

138
00:06:22,410 --> 00:06:24,300
我们在这堂课的目标是演示
Our goal in this lecture is to demonstrate

139
00:06:24,300 --> 00:06:27,960
我们怎样才能让角色在屏幕上四处移动 
how we can get things like a character that moves around on a screen,

140
00:06:27,960 --> 00:06:32,520
还有一个摄像头可以跟踪他们的位置 还有随机化的瓷砖 
and a camera that tracks their position, and tiles that are randomized.

141
00:06:32,520 --> 00:06:35,220
也许地上有柱子 地上有洞 
And maybe there are pillars in the ground, holes in the ground.

142
00:06:35,220 --> 00:06:36,640
所有这一切 再一次--
All of this, again--

143
00:06:36,640 --> 00:06:38,640
至少瓷砖--只是以数字的形式存储 
at least the tiles-- are stored as just numbers.

144
00:06:38,640 --> 00:06:42,960
所以我们真正需要做的就是对一系列数字进行转换 
So all we really need to do is perform a transformation on a series of numbers.

145
00:06:42,960 --> 00:06:48,150
也许1等于有一块瓷砖 0等于空白 
Maybe 1 is equal to a tile being there, 0 is equal to empty space.

146
00:06:48,150 --> 00:06:51,360
所以只要看看它 我们就会看到我们一列接一列地看 
And so just by looking at it, we'll see we go column by column.

147
00:06:51,360 --> 00:06:55,140
我们可以说 哦 也许有机会不会在Y方向上产生任何瓷砖
We can say, oh, maybe there's a chance to not spawn any tiles along the y

148
00:06:55,140 --> 00:06:58,890
在这张世界地图的第x栏上 
column on this x of the world map.

149
00:06:58,890 --> 00:07:02,670
或者在这个特殊的y上 也许不是产卵到地面 
Or on this particular y, maybe instead of spawning the ground level,

150
00:07:02,670 --> 00:07:05,972
我们在它上面和下面繁殖一对 这样我们就得到了一根柱子
we spawn a couple above it and down so that we get a pillar

151
00:07:05,972 --> 00:07:06,930
以此类推 
and so on and so forth.

152
00:07:06,930 --> 00:07:10,080
就是这些随机化的总和
And it's just this summation of these randomizations

153
00:07:10,080 --> 00:07:14,620
相当于游戏级别的一个不错的小变化 
equals a nice little variety of game levels.

154
00:07:14,620 --> 00:07:18,300
所以我们首先要讨论的是什么是平铺地图 
So the first thing we should talk about really is what a tile map is.

155
00:07:18,300 --> 00:07:21,720
到目前为止 我提到的是你真的可以想到一张瓷砖地图
And what I've alluded to so far is you can really think of a tile map

156
00:07:21,720 --> 00:07:27,030
作为有效的二维数组或数字表格 
as being effectively a 2D array or a table of numbers.

157
00:07:27,030 --> 00:07:30,180
它比这要复杂一点 这取决于它有多复杂
And it's a little more complicated than that depending on how complex

158
00:07:30,180 --> 00:07:35,610
你的平台是这样的 因为有些数字等于实心的瓷砖
your platformer is, because some numbers are equal to tiles that are solid

159
00:07:35,610 --> 00:07:36,670
或者不去 
or not.

160
00:07:36,670 --> 00:07:39,840
所以你应该能够检查瓷砖是否可碰撞 
So you should be able to check whether a tile is collidable,

161
00:07:39,840 --> 00:07:42,930
这意味着玩家或您要检查的任何实体
meaning that the player or whatever entity you want to check for

162
00:07:42,930 --> 00:07:44,930
可能真的会与它相撞 或者
can actually collide with it or

163
00:07:44,930 --> 00:07:45,430
不 
Not.

164
00:07:45,430 --> 00:07:48,400
因此 很明显 我们不想在空瓷砖上引发碰撞 
So obviously, we don't want to trigger a collision on empty tiles.

165
00:07:48,400 --> 00:07:50,400
我们希望球员能够在这些比赛中自由移动 
We want the player to move freely through those.

166
00:07:50,400 --> 00:07:53,280
但如果它们撞到墙上 或者重力在影响它们 
But if they run up against a wall or if gravity is affecting them,

167
00:07:53,280 --> 00:07:56,970
当它们击中它们下面或上面的瓷砖时 我们希望检测到碰撞
and they hit tiles below them or above them, we want to detect a collision

168
00:07:56,970 --> 00:07:59,627
然后根据它们的移动方向阻止它们 
and then stop them based on which direction they're moving.

169
00:07:59,627 --> 00:08:02,460
根据你使用平台的复杂程度 也许
And depending on how complicated you get with your platformer, maybe

170
00:08:02,460 --> 00:08:04,422
例如 你有动画瓷砖 
you have animated tiles, for instance.

171
00:08:04,422 --> 00:08:07,380
因此 如果对切片进行了动画处理 它将显示不同的动画帧
So if a tile's animated, it will display a different frame of animation

172
00:08:07,380 --> 00:08:09,330
根据你使用的定时器 
based on what timer you're on.

173
00:08:09,330 --> 00:08:10,590
真的 天空是无限的 
Really, the sky's the limit.

174
00:08:10,590 --> 00:08:12,630
在本例中 我们将相当简单 
In this case, we'll be fairly simple.

175
00:08:12,630 --> 00:08:17,520
我们的瓷砖将主要是带有几个其他特征的数字 这些
Our tiles will mostly just be numbers with a couple of other traits, which

176
00:08:17,520 --> 00:08:19,920
我们稍后会看到的 
we'll see later on.

177
00:08:19,920 --> 00:08:22,840
这只是一个非常简单的地图的例子--只是一张彩色的地图
And this is just an example here of a very simple map-- just a colored

178
00:08:22,840 --> 00:08:23,340
背景资料 
background.

179
00:08:23,340 --> 00:08:28,320
我们有自己的角色 然后我们可以把所有这些瓷砖可视化
We have our character, and then we can sort of visualize all of those tiles

180
00:08:28,320 --> 00:08:34,307
只是为了理论上的0或1 
as being just for the sake of theory 0s or 1s.

181
00:08:34,307 --> 00:08:37,140
Tables0--所以我将实际进入一点实现
So tiles0-- so I'll actually get into a little bit of implementation

182
00:08:37,140 --> 00:08:41,789
下面是我们如何开始画一些非常简单的瓷砖 
here as to how we can get drawing some very simple tiles.

183
00:08:41,789 --> 00:08:46,050
所以 如果你在看发行版 以磁贴0
So if you're looking at the distro, in tiles0

184
00:08:46,050 --> 00:08:47,990
将是我们从这里开始的地方 
is going to be where we start off here.

185
00:08:47,990 --> 00:08:53,200
我将继续运行磁贴图 这样我们就可以看到它是什么样子的 
And I'm going to go ahead and run tiles0 so we can see what that looks like.

186
00:08:53,200 --> 00:08:54,330
所以这就是瓷砖0 
So this is just tiles0.

187
00:08:54,330 --> 00:08:58,560
这是一个比我们刚才看到的简单得多的程序 但我们在这里所做的
It's a much simpler program than what we just saw, but all we're doing here

188
00:08:58,560 --> 00:09:01,560
只是背景中的一种颜色 然后是瓷砖 
is just a color in the background and then tiles.

189
00:09:05,567 --> 00:09:08,400
走出大门 有谁知道第一步会是什么
Off the gate, anybody have any ideas as to what the first step would

190
00:09:08,400 --> 00:09:10,520
如果我们想要实施这一点呢？
be if we wanted to implement this?

191
00:09:14,504 --> 00:09:19,304
观众：只要把瓷砖放在一个圈里 画出来 然后有一个背景就可以了？
AUDIENCE: Just put the tiles in a loop, draw them, and then have a background?

192
00:09:19,304 --> 00:09:21,470
科尔顿·奥格登：所以把瓷砖放在一个圈里 画出来 
COLTON OGDEN: So put the tiles in a loop, draw them,

193
00:09:21,470 --> 00:09:22,580
然后了解一下背景情况 
and then have a background.

194
00:09:22,580 --> 00:09:23,079
是 
Yes.

195
00:09:23,079 --> 00:09:29,600
因此 基本上 如果这是我们磁砖中的主要Lua 
So basically, if this is main.lua in our tiles0,

196
00:09:29,600 --> 00:09:33,590
我们首先需要一张瓷砖桌子来存放我们的--
first thing we're going to need is a tiles table to store our--

197
00:09:33,590 --> 00:09:35,990
我们不会只存储纯平的数字 
we're not going to be storing just flat numbers.

198
00:09:35,990 --> 00:09:39,350
我们将存储一些小桌子 里面有号码和身份证 
We'll be storing little mini tables that have a number in them and ID,

199
00:09:39,350 --> 00:09:45,432
所以如果我们有一个2D表格 我们可以说tile.id 
so we can say tile.ID if we have a 2D table.

200
00:09:45,432 --> 00:09:46,640
在这里 我们有一张空桌子 
Here, we have an empty table.

201
00:09:46,640 --> 00:09:47,848
我们要把它填满 
We're going to populate that.

202
00:09:50,780 --> 00:09:54,470
如果我们要画我们的瓷砖 我们需要某种精灵 
If we're going to draw our tiles, we are going to need a sprite of some kind.

203
00:09:54,470 --> 00:09:57,980
我所做的就是在这里切下一小段 
And what I did was I just chopped out a little segment here.

204
00:09:57,980 --> 00:10:00,230
这就是tiles.png 
So this is tiles.png.

205
00:10:00,230 --> 00:10:04,076
从字面上看 它只是主精灵的一块瓷砖
It's just literally one tile from the main sprite

206
00:10:04,076 --> 00:10:05,450
随发行版一起提供的床单 
sheet that comes with the distro.

207
00:10:05,450 --> 00:10:12,710
然后右边是透明的 所以我们可以抵消--
And then on the right side is just transparent so that we can offset--

208
00:10:12,710 --> 00:10:19,370
可能瓷砖ID%1等于实心块 然后瓷砖ID%2等于空 
maybe tile ID 1 is equal to solid block, and then tile ID 2 is equal to empty.

209
00:10:19,370 --> 00:10:24,050
因此 如果我们回忆一下生成四边形 我们可以拆分一个精灵薄片
And so if we recall generate quads, we can split up a sprite sheet

210
00:10:24,050 --> 00:10:26,560
分成我们想要的任何数量的四边形 
into however many quads we want to.

211
00:10:26,560 --> 00:10:29,300
假设这是16块高的瓷砖--
Let's say this is 16 tiles tall--

212
00:10:29,300 --> 00:10:33,080
每一块瓷砖--然后整个东西是两块瓷砖宽 
each tile-- and then the whole thing are two tiles wide.

213
00:10:33,080 --> 00:10:36,835
所以它需要被分成两块独立的瓷砖 
So it needs to be split into two separate tiles.

214
00:10:36,835 --> 00:10:41,330
我们只需要生成四元组 然后我们就会有一张桌子 
We'll just generate quads, and then we'll have, recall, a table.

215
00:10:41,330 --> 00:10:45,290
该表的每个索引都将是
Each of the indexes of that table will be

216
00:10:45,290 --> 00:10:47,560
映射到这些瓷砖之一的四边形 
a quad that maps to one of these tiles.

217
00:10:47,560 --> 00:10:50,270
所以1号是这块瓷砖 2号
So number 1 will be this tile here, number 2

218
00:10:50,270 --> 00:10:53,120
将是这里的透明部分 然后
will be the transparent bit over here, and then

219
00:10:53,120 --> 00:10:55,929
这就是我们的ID将如何有效地映射
that's how effectively our IDs are going to map

220
00:10:55,929 --> 00:10:57,470
绘制到屏幕上的内容 
into what gets drawn onto the screen.

221
00:10:57,470 --> 00:11:02,130
ID是我们的四元表的索引 
The ID is the index into our quad table.

222
00:11:02,130 --> 00:11:08,890
回到图块0 我们这里只有一个地图的宽度和高度 
So going back into tiles0, we have here just a map width and height.

223
00:11:08,890 --> 00:11:13,880
我们只是想说生成一张20乘以20的地图 
We're just going to say generate a map 20 by 20.

224
00:11:13,880 --> 00:11:15,860
RBG--我们只是将其设置为随机的
RBG-- we're just going to make it random,

225
00:11:15,860 --> 00:11:19,280
所以我们要用一种随机的颜色清除屏幕 
so we're going to clear the screen with a random color.

226
00:11:19,280 --> 00:11:24,020
然后这是Quads=GenerateQuads 
And then this is the quads = GenerateQuads.

227
00:11:24,020 --> 00:11:26,114
请注意 我们在这里传入了瓷砖大小 
And notice that we're passing in tile size here.

228
00:11:26,114 --> 00:11:28,530
这是一个很好的做法 只要让你的瓷砖大小恒定即可 
It's good practice just to make your tile size a constant.

229
00:11:28,530 --> 00:11:31,940
所以我们整堂课的瓷砖大小--
So our tile size in this entire lecture--

230
00:11:31,940 --> 00:11:33,710
他们都将是16岁乘16岁 
they're all going to be 16 by 16.

231
00:11:33,710 --> 00:11:36,950
所以因为它们是对称的 所以我们只需要传入瓷砖大小 
And so since they're symmetrical, we just pass in tile size TILE_SIZE.

232
00:11:36,950 --> 00:11:40,130
然后这就是我们最终产生地图的地方--
And then here is where we actually end up spawning the map--

233
00:11:40,130 --> 00:11:42,960
所以嵌套了for循环 
so nested for loop.

234
00:11:42,960 --> 00:11:47,290
Y表示贴图高度为1 x表示贴图宽度为1 
y gets 1 to map height, x gets 1 to map width.

235
00:11:47,290 --> 00:11:50,920
请记住 我们必须将一个空表插入到基表中
Remember, we have to insert a blank table into the base table that's

236
00:11:50,920 --> 00:11:52,700
将作为我们当前的行 
going to act as our current row.

237
00:11:52,700 --> 00:11:56,570
然后在那一行中 我们将在Tiles y添加一个小号 
And then in that row, we're going to add a small at tiles y,

238
00:11:56,570 --> 00:12:01,280
因为y将在这里--我们当前的行和ID 
because y is going to be up here-- our current row and ID.

239
00:12:01,280 --> 00:12:07,790
所以我们在这里做的是 如果y小于5-
And so what we're doing here is if y is less than 5--

240
00:12:07,790 --> 00:12:11,150
这意味着我们基本上只会为地面设置一个任意点 
meaning we'll just set an arbitrary point for the ground, basically.

241
00:12:11,150 --> 00:12:15,810
如果距离顶部少于5块 那么就让它成为天空 
If it's less than 5 tiles from the top, then just make it the sky.

242
00:12:15,810 --> 00:12:19,340
所以天空--在这里的24 25线--我们只是
And so sky-- up here on line 24, 25-- we just

243
00:12:19,340 --> 00:12:20,900
设置两个磁贴ID 正如我之前所说的 
set two tile IDs, as I said before.

244
00:12:20,900 --> 00:12:23,772
天空是2 所以它将在床单的右侧 
Sky is 2, so it's going to be on the right side of the sheet.

245
00:12:23,772 --> 00:12:24,730
然后 地面就是一个 
And then ground is one.

246
00:12:24,730 --> 00:12:28,230
这将是工作表中生成的第一个四元组 
It's going to be the very first quad generated in the sheet.

247
00:12:28,230 --> 00:12:33,200
因此 如果y小于5 则该ID应等于sky否则
So if y is less than 5, that ID should be equal to sky else

248
00:12:33,200 --> 00:12:35,420
它应该等于地面 
it should be equal to ground.

249
00:12:35,420 --> 00:12:38,850
因此 在这里 这就是它发挥作用的地方 
And so down here is where that comes into play.

250
00:12:38,850 --> 00:12:41,690
我们将用我们随机的颜色清除屏幕 
We're going to clear the screen with our random color.

251
00:12:41,690 --> 00:12:44,690
正如James所说 我们将迭代遍历循环 
We're going to iterate over the loop, as James said.

252
00:12:44,690 --> 00:12:47,990
我们要在瓦片y x处拿到瓷砖 
We're going to get the tile at tiles y x,

253
00:12:47,990 --> 00:12:53,630
然后我们只需在该瓷砖ID处绘制床单和四边形 
and then we're just going to draw the sheet and the quads at that tiles ID.

254
00:12:53,630 --> 00:12:58,850
然后回想一下 由于表是1索引的 而坐标是0索引的 
And then recall, since tables are 1 indexed but coordinates are 0 indexed,

255
00:12:58,850 --> 00:13:01,640
我们取x和y 减去1 
we take the x and the y, subtract 1 from them,

256
00:13:01,640 --> 00:13:03,680
然后我们只需将它们乘以瓷砖大小 
and then we just multiply them by tile size.

257
00:13:03,680 --> 00:13:07,280
它的效果是画出每一块瓷砖
And that has the effect of drawing each of those tiles

258
00:13:07,280 --> 00:13:10,190
在他们各自的世界节点上 并使
at their respective point in the world and making

259
00:13:10,190 --> 00:13:14,060
看起来好像我们有了这个世界--这堆砖
it seem as if we have this world-- this bunch of bricks

260
00:13:14,060 --> 00:13:17,010
每次都有一个随机的背景 
with a random background every time.

261
00:13:17,010 --> 00:13:20,550
这并不是很有趣 但只是稍微多样化了一点 
Which isn't all that interesting, but just a little bit more variety.

262
00:13:20,550 --> 00:13:22,910
这就是它背后的最基本的要点 
And so that's the very basic gist behind it.

263
00:13:22,910 --> 00:13:26,118
我的意思是 这基本上和我们在第三场比赛中做的差不多 
I mean, it's essentially almost the same thing as what we did in match three,

264
00:13:26,118 --> 00:13:29,210
我们只是把每一个小块
where we just mapped the individual tiles that

265
00:13:29,210 --> 00:13:38,090
分别在网格中以索引的方式在瓷砖板上按颜色和品种分类 
were in the grid to indexes in the tile sheet based on the color and variety.

266
00:13:38,090 --> 00:13:41,370
只是这次 他们会一直待在同一个地方 
Only this time, they're always going to be in the exact same place,

267
00:13:41,370 --> 00:13:43,760
所以我们不必担心它们的x和y
so we don't have to worry about whether their x and y are

268
00:13:43,760 --> 00:13:45,440
不同于y和x坐标
different from their grid y and grid x.

269
00:13:45,440 --> 00:13:48,710
我们不保留对这些的引用 
We're not maintaining a reference to those.

270
00:13:48,710 --> 00:13:49,999
这就是静态瓦片 
And so that's static tiles.

271
00:13:49,999 --> 00:13:52,040
有人对我们如何
Does anybody have any questions about how we just

272
00:13:52,040 --> 00:13:53,769
在屏幕上绘制静态图块？
draw static tiles to the screen?

273
00:13:53,769 --> 00:13:54,560
很基本的东西 
Pretty basic stuff.

274
00:13:58,440 --> 00:14:02,330
整个名称背后的侧滚动游戏
The whole name behind side scrolling game

275
00:14:02,330 --> 00:14:06,742
就是方块的滚动是基于我们在游戏中的动作 
is that the tiles scroll based on what we're doing in the game.

276
00:14:06,742 --> 00:14:08,450
它可以是一个自动滚动 在这种情况下 
It can be an auto scroller, in which case

277
00:14:08,450 --> 00:14:10,802
也许你是一架飞机
maybe you're an airplane that's sort of going

278
00:14:10,802 --> 00:14:12,760
通过自动滚动的关卡 
through a level that's scrolling automatically,

279
00:14:12,760 --> 00:14:14,080
而你在射击
and you're shooting things.

280
00:14:14,080 --> 00:14:16,121
你并不能真正控制你要去哪里 
And you're not really in control of where you go.

281
00:14:16,121 --> 00:14:18,549
或者它可以像马里奥 你控制一个化身 
Or it can be like Mario, where you control an avatar.

282
00:14:18,549 --> 00:14:20,340
你可以四处走动 跳跃之类的
And you can walk around and jump and stuff,

283
00:14:20,340 --> 00:14:22,560
摄像机会一直盯着你
and the camera will always be fixed on you.

284
00:14:22,560 --> 00:14:27,180
所以滚动只是相对于你的角色的x和y的位置 
And so the scrolling is just relative to where your character's x and y are.

285
00:14:27,180 --> 00:14:30,480
所以我将给你们展示一个例子
So I'm going to show you guys an example of how we can

286
00:14:30,480 --> 00:14:32,357
在我们的游戏中实现滚动 
get scrolling implemented in our game.

287
00:14:32,357 --> 00:14:35,190
为了做到这一点 我们真正要研究的函数--
And to do that, the function that we're really going to be looking--

288
00:14:35,190 --> 00:14:37,290
在一个新的功能--
at a new function--

289
00:14:37,290 --> 00:14:41,250
is love.graphics.translate（x y）.
is love.graphics.translate(x, y).

290
00:14:41,250 --> 00:14:45,240
所以它所做的就是有效地将
And so what that does is effectively just translates

291
00:14:45,240 --> 00:14:48,840
Love 2D的坐标系 这样每当我们画东西的时候 
Love2D's coordinate system so that whenever we draw something,

292
00:14:48,840 --> 00:14:52,190
它会自动移动x y
it gets automatically shifted by x, y.

293
00:14:52,190 --> 00:14:58,770
这就产生了所有东西都被扭曲的效果
And so that has the effect of the everything being sort of skewed

294
00:14:58,770 --> 00:15:00,630
基于我们传递的x y
based on the x, y that we pass it.

295
00:15:00,630 --> 00:15:05,100
所以如果我们保持一个字符所在位置的引用 
And so if we maintain a reference to where the character is,

296
00:15:05,100 --> 00:15:09,480
我们可以改变屏幕上所有东西的位置
we can just shift where everything gets drawn on the screen.

297
00:15:09,480 --> 00:15:13,020
这会让它看起来像是一个摄像头 但它不是 
And that will have the effect of it being a camera, but it's not.

298
00:15:13,020 --> 00:15:15,390
我们所做的只是移动坐标系
All we're doing is just shifting the coordinate system

299
00:15:15,390 --> 00:15:16,720
基于一些偏移量--
based on some offset--

300
00:15:16,720 --> 00:15:19,914
在这种情况下 玩家是有效的 
x being in this case where the players is effectively.

301
00:15:19,914 --> 00:15:22,080
观众：所以它改变了整个坐标系？
AUDIENCE: So it changes the whole coordinate system?

302
00:15:22,080 --> 00:15:22,996
科尔顿·奥格登：的确如此 
COLTON OGDEN: It does.

303
00:15:22,996 --> 00:15:27,210
它按x和y移动坐标系中绘制的所有对象 
It shifts everything in the coordinate system that you draw by the x and y.

304
00:15:27,210 --> 00:15:31,170
所以这基本上会影响所呈现的内容
And so that will basically affect what's getting rendered

305
00:15:31,170 --> 00:15:32,820
进入当时的活动窗口 
into the active window at that time.

306
00:15:35,710 --> 00:15:38,580
所以我要继续往下拉瓷砖1
So I'm going to go ahead and pull up tiles1 here

307
00:15:38,580 --> 00:15:40,696
所以我们可以看看这是如何运作的 
so we can see how this works.

308
00:15:40,696 --> 00:15:44,290
让我继续并首先运行程序 
Let me go ahead and first run the program.

309
00:15:44,290 --> 00:15:47,970
因此 如果我们要进入发行版的磁砖1 
So if we're going into tiles1 in the distro,

310
00:15:47,970 --> 00:15:49,980
目前它看起来几乎一模一样 
currently it looks almost identical.

311
00:15:49,980 --> 00:15:53,610
但是如果我只按向左或向右 我就可以移动它 
But I can move it if I just press left or right.

312
00:15:53,610 --> 00:15:57,810
所以我们可以在这里看到 这是2D瓷砖阵列
And so we can see here, this is where the 2D array of tiles

313
00:15:57,810 --> 00:15:59,140
在这里被切断 
gets cut off here.

314
00:15:59,140 --> 00:16:02,550
然后它也被切断了 因为我们只生成了一个20x20的级别 
And then it also cuts off, because we're only generating a 20 by 20 level.

315
00:16:02,550 --> 00:16:05,560
它的最右边也被切断了 
It also gets cut off at the very right side as well.

316
00:16:05,560 --> 00:16:08,310
这些是您通常会对用户隐藏的详细信息
And these are details you would normally hide from the user

317
00:16:08,310 --> 00:16:13,740
只需将x夹在0和右侧之间
by just clamping the x between 0 and the right side

318
00:16:13,740 --> 00:16:17,064
贴图的大小减去虚拟宽度 
of the map minus VIRTUAL_WIDTH.

319
00:16:17,064 --> 00:16:19,730
而这将会产生这样的效果 无论你何时到达这一点 
And that will have the effect of whenever you get to this point,

320
00:16:19,730 --> 00:16:22,599
它不会再让你向右转了 同样的事情也会发生在左边 
it won't let you go right anymore, and same thing for the left side.

321
00:16:22,599 --> 00:16:24,390
嗯 我们现在所做的--我们没有
Well, all we're doing right now-- we're not

322
00:16:24,390 --> 00:16:26,170
完全是根据角色来做的 
doing it based on the character at all.

323
00:16:26,170 --> 00:16:29,590
我们只是使用键盘输入 
We're just using keyboard input.

324
00:16:29,590 --> 00:16:32,100
因此 让我们继续讨论磁砖1 
So let's go ahead into tiles1.

325
00:16:35,280 --> 00:16:41,520
所以我们要看的重要的事情是--
And so the important thing that we're going to look at is--

326
00:16:41,520 --> 00:16:45,090
正如我刚才提到的 我们将调用love.graph
as I just alluded to, we're calling love.graphics.translate

327
00:16:45,090 --> 00:16:47,460
在名为CameraScroll的某个值上 
on some value called cameraScroll.

328
00:16:53,010 --> 00:16:56,930
它必须是负值 因为如果我们向右移动
It has to be a negative value, because if we're moving to the right

329
00:16:56,930 --> 00:16:59,246
在这上面还是在左边--
up here or to the left--

330
00:16:59,246 --> 00:17:02,370
如果我们向左移动 摄像机卷轴基本上会减少 
if we're moving to the left, camera scroll basically is going to decrement,

331
00:17:02,370 --> 00:17:03,453
所以它会变得更少 
so it's going to get less.

332
00:17:03,453 --> 00:17:05,339
所以我们可以说 当我们在
So we can say the camera scroll when we're

333
00:17:05,339 --> 00:17:08,470
如果我们从0开始 向左转将是0或更小 
going left is going to be 0 or less if we're starting at 0,

334
00:17:08,470 --> 00:17:10,170
否则它就会减少 
or it's going to decrement.

335
00:17:10,170 --> 00:17:14,760
如果我们按向右 摄像镜头应该会增加 
If we press right, camera roll should increase.

336
00:17:14,760 --> 00:17:19,480
如果我们想要向右移动或向左移动的外观 
If we want the appearance of moving to the right or moving to the left,

337
00:17:19,480 --> 00:17:22,829
实际上 你必须以相反的方向翻译 
you actually have to translate by the opposite direction.

338
00:17:22,829 --> 00:17:34,840
因为如果我们看这个 如果我们调用love.graph 转换为正的 
Because if we look at this, and if we call love.graphics.translate positive,

339
00:17:34,840 --> 00:17:36,810
所有这些都将向右移动 
all of this is going to get moved to the right.

340
00:17:36,810 --> 00:17:39,330
所以它看起来就像我们在向左移动 
So it's going to have the appearance of us moving left.

341
00:17:39,330 --> 00:17:41,690
如果我们把它向左平移负数 
And if we translate it to the left by a negative amount,

342
00:17:41,690 --> 00:17:44,370
它会有我们向右移动的样子 
it's going to have the appearance of us moving right.

343
00:17:44,370 --> 00:17:48,570
因此 如果我们的卷轴是正面的 并且我们想要向右移动 
So if our scroll is positive and we want to move to the right,

344
00:17:48,570 --> 00:17:52,330
我们实际上必须将其转换为负值 
we actually have to translate by a negative amount.

345
00:17:52,330 --> 00:18:00,660
这就是为什么我把它命名为Native Math.Floor 
And so that's why I'm calling negative math.floor(cameraScroll).

346
00:18:00,660 --> 00:18:04,710
有人知道为什么我们要在摄像机上叫Math.Floor吗？
Does anybody know why we're calling math.floor on cameraScroll

347
00:18:04,710 --> 00:18:09,980
而不是简单地调用底片相机滚动？
instead of just calling negative camera scroll?

348
00:18:09,980 --> 00:18:13,950
有人记得Math.Floor是做什么的吗？
Does anybody remember what math.floor does?

349
00:18:13,950 --> 00:18:17,560
所以数学 地板将返回--
So math.floor will return the--

350
00:18:17,560 --> 00:18:21,450
它基本上会将数字向下截断到最小整数 
it'll basically truncate the number down to the lowest integer.

351
00:18:21,450 --> 00:18:24,330
它基本上会去掉浮点值 
It will basically take off the floating point value.

352
00:18:24,330 --> 00:18:26,400
因为我们正在渲染到虚拟分辨率
Because we're rendering to a virtual resolution

353
00:18:26,400 --> 00:18:32,640
有了推力 如果我们基本上将平移偏移一小部分 
with push, if we basically offset the translation by a fractional amount,

354
00:18:32,640 --> 00:18:34,020
你会得到手工艺品 
you'll get artifacting.

355
00:18:34,020 --> 00:18:37,470
因为它夺走了你的窗户 只是冷凝
Because it's taking your window and just condensing

356
00:18:37,470 --> 00:18:42,280
你的图像放到虚拟画布上 你会得到奇怪的模糊之类的东西 
your image onto a virtual canvas, you'll get weird blur and stuff like that.

357
00:18:42,280 --> 00:18:48,330
所以当你画一些东西的时候 你有一个分数 
So whenever you draw something and you have a fractional number for something,

358
00:18:48,330 --> 00:18:51,840
你把它画到一张被放大的虚拟画布上
and you're drawing it to a virtual canvas that's been magnified

359
00:18:51,840 --> 00:18:55,410
或者它正在被浓缩 只要确保数学 平铺它
or it's being condensed, just make sure to math.floor it

360
00:18:55,410 --> 00:18:58,710
所以你不会得到任何奇怪的模糊伪装 
so you don't get any weird blur artifacting.

361
00:18:58,710 --> 00:19:02,056
如果你把它拿出来试一试 或者即使是在发行版中
If you take this out and experiment around, or even if in the distro

362
00:19:02,056 --> 00:19:04,680
你把它从球员的位置上拿出来 你就会看到球员
you take it out of the player's position, you'll see the player

363
00:19:04,680 --> 00:19:07,560
会得到奇怪的模糊的人工制品之类的东西 
will get weird blurry artifacting and stuff like that.

364
00:19:07,560 --> 00:19:10,912
这就是为什么它在那里 如果你好奇的话 
So that's why that's there, in case you're curious.

365
00:19:10,912 --> 00:19:12,870
所以我们在这里所做的一切--我们只是想说
And so all we're doing here-- we're just saying

366
00:19:12,870 --> 00:19:16,580
如果等于左 则向左滚动摄像机 向右滚动 
if it's equal to left, scroll the camera left, scroll it right,

367
00:19:16,580 --> 00:19:22,910
或者基本上减少我们的相机滚动 然后增加或相机滚动 
or basically decrement our camera scroll and then increment or camera scroll.

368
00:19:22,910 --> 00:19:25,970
然后在这里使用负面的版本 
And then just use the negative version of that here.

369
00:19:25,970 --> 00:19:30,344
您也可以将相机滚动指定为正数
You could also just assign camera scroll equal to positive

370
00:19:30,344 --> 00:19:32,510
当你向左移动 当你向右移动时 
when you move left and negative when you move right,

371
00:19:32,510 --> 00:19:35,690
然后你可以在这里给它正常的相机卷轴 
and then you could give it the regular camera scroll here.

372
00:19:35,690 --> 00:19:39,020
但就这一部分而言 这是一种精神上的颠覆 
But it's sort of mentally flipped in terms of this part.

373
00:19:39,020 --> 00:19:44,480
所以当我们按向左的时候 我决定在这里减少它 
So I just made the decision to decrement it here when we're pressing left,

374
00:19:44,480 --> 00:19:51,050
因为当我们按向右的时候 我们在x轴上做得更少 然后在x轴上做得更多 
because we're going less on the x and then more on the x when we press right.

375
00:19:51,050 --> 00:19:52,010
这有意义吗？
Does this make sense?

376
00:19:52,010 --> 00:19:52,665
有谁有问题吗？
Anybody have question?

377
00:19:52,665 --> 00:19:53,831
观众：我有一个问题 
AUDIENCE: I have a question.

378
00:19:53,831 --> 00:19:56,222
在JavaScript中有没有相应的函数
Is there a corresponding function in JavaScript

379
00:19:56,222 --> 00:20:01,672
而在像这样的其他语言中 你可以移动整个坐标吗？
and in other languages like this where you can shift a whole coordinate?

380
00:20:01,672 --> 00:20:04,130
Colton Ogden：在JavaScript中有类似的函数吗
COLTON OGDEN: Is there an equivalent function in JavaScript

381
00:20:04,130 --> 00:20:06,640
在那里你可以移动整个坐标系？
where you can shift the whole coordinate system?

382
00:20:06,640 --> 00:20:09,020
可能不是在基本的JavaScript中 
Not in base JavaScript, probably.

383
00:20:09,020 --> 00:20:10,760
我对css不是很熟悉 
I'm not too familiar with CSS.

384
00:20:10,760 --> 00:20:14,040
可能有一个css函数可以做到这一点 
There might be a CSS function that does it.

385
00:20:14,040 --> 00:20:18,120
在许多2D游戏引擎中 是的 我会说 
In a lot of 2D game engines, yes, I would say.

386
00:20:18,120 --> 00:20:22,310
许多实际的2D游戏引擎都会有一个摄像头对象 它
And a lot of actual 2D game engines will have a camera object, which

387
00:20:22,310 --> 00:20:24,110
这在某种程度上概括了这一行为 
sort of encapsulates this behavior.

388
00:20:24,110 --> 00:20:26,480
Love2D没有摄像头 所以这是排序
Love2D doesn't have a camera, so this is sort

389
00:20:26,480 --> 00:20:30,200
我们为什么要这样做--是因为这是一种较低级别的游戏
of why we're doing this-- is because it's kind of a lower level game

390
00:20:30,200 --> 00:20:30,952
框架 Love2D 
framework, Love2D.

391
00:20:30,952 --> 00:20:32,660
它不会给你带来那么多东西
It doesn't really give you as many things

392
00:20:32,660 --> 00:20:36,800
就在门口 这使得它非常适合教授这些概念 
right out the gate, which makes it great for teaching these concepts.

393
00:20:36,800 --> 00:20:41,180
但更强大的解决方案 如Unity或Phaser
But a more robust solution like Unity or Phaser

394
00:20:41,180 --> 00:20:45,350
或许多其他游戏框架 它们将只有一个摄像头对象 
or a lot of other game frameworks is that they'll just have a camera object.

395
00:20:45,350 --> 00:20:49,270
你只要给它你的x 然后你就移动它 
And you just basically give that your x, and then you just move that.

396
00:20:49,270 --> 00:20:51,170
你基本上是这样说的 以跟踪玩家--
You basically tell that to track the player--

397
00:20:51,170 --> 00:20:55,985
比如camera.trackPlayer或trackEntityPlayer--
like camera.trackPlayer or trackEntityPlayer--

398
00:20:55,985 --> 00:20:57,360
这也会产生同样的效果 
and that'll have the same effect.

399
00:20:57,360 --> 00:20:58,693
它稍微抽象了一点 
It's a little bit more abstract.

400
00:20:58,693 --> 00:21:00,800
这是一个比我们正在做的更高的水平 
It's a higher level than what we're doing,

401
00:21:00,800 --> 00:21:04,427
但这背后的原理是一样的 
but it's the same exact principle underlying.

402
00:21:04,427 --> 00:21:06,260
那么 关于这是如何运作的 还有其他问题吗？
So any other questions as to how this works?

403
00:21:09,780 --> 00:21:11,090
好的 太酷了 
All right, cool.

404
00:21:11,090 --> 00:21:13,610
这就是我们正在做的所有事情 
So that's all we're effectively doing.

405
00:21:13,610 --> 00:21:17,180
我们只是得到一个相机卷轴 递减和递增它 
We're just getting a camera scroll, decrementing it and incrementing it.

406
00:21:17,180 --> 00:21:19,970
然后每一帧 我们都在翻译
And then just every frame, we're translating everything

407
00:21:19,970 --> 00:21:21,350
在我们画完所有的画之前 
before we draw everything.

408
00:21:21,350 --> 00:21:25,010
你必须在画之前做平移 因为你做的每一件事
You have to do the translation before you draw, because everything that you

409
00:21:25,010 --> 00:21:30,260
在平移受新坐标系更改影响后绘制 
draw after the translation gets affected by the new coordinate system change.

410
00:21:30,260 --> 00:21:33,290
这就是滚动 
So that's scrolling.

411
00:21:33,290 --> 00:21:37,220
让我们真正开始讨论如何画一个人--一个化身--
Let's get to actually talking about drawing a person-- an avatar--

412
00:21:37,220 --> 00:21:46,280
不仅仅是一套瓷砖 因为这是游戏的核心 
more than just a set of tiles, since that's what the game revolves around.

413
00:21:46,280 --> 00:21:53,270
如果我们看一下Character 0 这将是我们这里的第一个示例 
If we look at character0, this would be our first example here.

414
00:21:53,270 --> 00:21:57,350
这只是一个非常简单的例子--
This is just going to be a very simple example--

415
00:21:57,350 --> 00:21:57,960
字符0 
charactr0.

416
00:22:00,800 --> 00:22:02,990
你们可能已经知道这是怎么回事了 
You guys probably know how this works already.

417
00:22:02,990 --> 00:22:07,120
我们所做的只是在屏幕上画一个精灵--
All we're doing is just drawing a sprite to the screen--

418
00:22:07,120 --> 00:22:09,680
所以就去爱吧 图画 
so just love.graphics.draw.

419
00:22:09,680 --> 00:22:13,070
我们从一块瓷砖上拿到了四边形 
We're getting quads from a tile sheet.

420
00:22:13,070 --> 00:22:15,470
我相信它就在幻灯片里 
I believe it's in the slides.

421
00:22:15,470 --> 00:22:18,260
实际的床单在这里 
The actual sheet is here.

422
00:22:18,260 --> 00:22:21,680
所以我们有一个小家伙--
So we have this little guy--

423
00:22:21,680 --> 00:22:22,970
几帧动画 
several frames of animation.

424
00:22:22,970 --> 00:22:26,080
它有16个宽 20个高 我们只有一个四边形 
It's 16 wide, 20 tall, and we just take a quad.

425
00:22:26,080 --> 00:22:27,420
我们先把它分成四个部分 
We split it up into quads first.

426
00:22:27,420 --> 00:22:32,240
所以我们知道它是16×20高的 所以我们只生成四边形
So we know that it's 16 wide by 20 tall, so we just generate quads

427
00:22:32,240 --> 00:22:35,690
在这张图上 16岁和20岁 
on this image by 16 and 20.

428
00:22:35,690 --> 00:22:38,000
在这个例子中 我们所做的就是
And then in this example, all we're doing

429
00:22:38,000 --> 00:22:42,796
取下第一帧 也就是1次方 然后画出来 
is taking the first frame, which is quads1, and just drawing that.

430
00:22:42,796 --> 00:22:45,170
正如你在这里看到的 我们有一堆不同的东西 
As you can see here, we have a bunch of different things.

431
00:22:45,170 --> 00:22:47,000
我们有一种蹲着的状态 我们会
We have like a crouching state, and we'll

432
00:22:47,000 --> 00:22:50,100
稍后我们将了解更多有关动画的内容 
get to more about animations in a little bit.

433
00:22:50,100 --> 00:22:53,160
但在这里 我们让他爬上了梯子 
But here, we have him climbing up a ladder.

434
00:22:53,160 --> 00:22:55,290
但你可以看到所有这些不同的框架 
But you can see all these different frames.

435
00:22:55,290 --> 00:22:57,800
我们将向您展示如何背靠背播放它们
We'll end up showing how you can play them back to back

436
00:22:57,800 --> 00:22:59,430
并得到不同的动画 
and get different animations.

437
00:22:59,430 --> 00:23:01,970
但为了这个基本的例子 我们所做的一切
But for the sake of this basic example, all we're doing

438
00:23:01,970 --> 00:23:05,360
只是渲染了第一帧 
is just rendering the very first frame.

439
00:23:05,360 --> 00:23:08,200
我们可以看到--
And we can see that--

440
00:23:08,200 --> 00:23:11,240
让我确保我在正确的文件中 我是--
let me make sure I'm in the right file, which I am--

441
00:23:11,240 --> 00:23:17,790
我们在第43行和第44行得到了角色表 
we are getting the character sheet here on line 43 and 44.

442
00:23:17,790 --> 00:23:21,820
然后我们必须给他一个X 所以CharacterX Charactery 
And then we have to give him an x, So characterX, characterY.

443
00:23:21,820 --> 00:23:24,360
在这种情况下 我们只是将他设置在7号瓷砖之上 
In this case, we're just setting him above tile 7,

444
00:23:24,360 --> 00:23:29,840
所以我们用7减去1乘以Tile_Size 因为切片是1索引的
so we do 7 minus 1 times TILE_SIZE because tiles are 1 indexed

445
00:23:29,840 --> 00:23:31,909
但是坐标是0索引的 
but coordinates are 0 indexed.

446
00:23:31,909 --> 00:23:33,950
然后我们只需减去高度 他就会
And then we just subtract the height so that he's

447
00:23:33,950 --> 00:23:38,450
就在瓷砖的上方 而不是瓷砖的右边 
right above the tile instead of right at the tile.

448
00:23:38,450 --> 00:23:44,120
然后在这里 我们做一个爱 画 画
And then down here, we do a love.graphics.draw

449
00:23:44,120 --> 00:23:46,460
就像我之前说的 就是角色Quads1 
on, as I said before, just characterQuads 1.

450
00:23:46,460 --> 00:23:49,660
这只是一个非常基本的硬编码示例 
Just a very basic hard coded example.

451
00:23:49,660 --> 00:23:51,410
对于这是如何工作的 有什么问题吗？
Any questions at all as to how this works?

452
00:23:58,270 --> 00:24:00,514
现在让我们假设我们想让他移动 
So now let's say we want him to move.

453
00:24:00,514 --> 00:24:01,180
我们需要什么？
What do we need?

454
00:24:01,180 --> 00:24:03,304
如果我们只是想让他搬走 下一步该怎么办？
What's the next step if we just wanted him to move?

455
00:24:08,984 --> 00:24:11,970
观众：给他一个x和y？
AUDIENCE: Give him an x and y?

456
00:24:11,970 --> 00:24:13,890
科尔顿·奥格登：是的 给他一个x和y 
COLTON OGDEN: Yes, give him an x and y.

457
00:24:13,890 --> 00:24:17,350
所以是的 所以他已经有了x和y 
So yes, so he does have an x and y already.

458
00:24:17,350 --> 00:24:19,750
所以如果你看--我穿对了吗？
So if you look at-- am I in the right one?

459
00:24:19,750 --> 00:24:23,179
所以如果你转到Character0 这仍然是Character0 
So if you go to character0, this is character0 still.

460
00:24:23,179 --> 00:24:26,220
我们已经给了他一个x和y 但还需要再走一步 
We have given him an x and y already, but there needs to be another step.

461
00:24:26,220 --> 00:24:27,511
另一个步骤涉及到什么？
What's the other step involved?

462
00:24:32,930 --> 00:24:36,620
因此 如果我们想要移动 我们需要检查键盘输入 
So if we wanted to move, we need to check for keyboard input.

463
00:24:36,620 --> 00:24:39,320
然后我们需要取他的X--
And then we need to take his x--

464
00:24:39,320 --> 00:24:42,140
我们现在只需要让他在x轴上移动 
we're just going to move him on the x-axis for now.

465
00:24:42,140 --> 00:24:47,390
我们基本上需要把他的性格变量X放在这里 
We basically need to take his characterX variable up here,

466
00:24:47,390 --> 00:24:49,040
我们需要修改这一点 
and we need to modify that.

467
00:24:49,040 --> 00:24:55,260
我们基本上可以做我们在Love这里所做的相同的事情 
We can basically do the same thing that we did down here in love.update.

468
00:24:55,260 --> 00:24:58,040
在此之前 它是在坐标系中--
Previously, it was on the coordinate system--

469
00:24:58,040 --> 00:24:59,130
Love.graph ics.翻译 
love.graphics.translate.

470
00:24:59,130 --> 00:25:01,220
我们修改了相机卷轴 
We modified the camera scroll.

471
00:25:01,220 --> 00:25:05,900
我们将其设置为滚动速度乘以增量时间 
We set that equal to scroll speed times delta time.

472
00:25:05,900 --> 00:25:07,130
我们把它减去或相加 
We subtracted or added it.

473
00:25:07,130 --> 00:25:09,755
在这种情况下 我们要做的是有一个新的常量 称为
In this case, what we're doing is we have a new constant called

474
00:25:09,755 --> 00:25:13,250
CHARACTER_MOVE_SPEED 我们正在执行完全相同的操作
CHARACTER_MOVE_SPEED, and we're just doing that exact same operation

475
00:25:13,250 --> 00:25:18,020
但用的是Character X 而不是CameraScroll 
but on characterX instead of cameraScroll.

476
00:25:18,020 --> 00:25:24,900
因此 最终的结果是我们有了这个角色 
So the end result of that is that we have the character here.

477
00:25:24,900 --> 00:25:28,287
然后我们可以向左或向右移动他 他就会离开屏幕 
And then we can move him left or right, and he go off screen.

478
00:25:28,287 --> 00:25:29,870
现在 有几件事是错的 
Now, there's a couple of things wrong.

479
00:25:29,870 --> 00:25:30,500
怎么了？
What's wrong?

480
00:25:30,500 --> 00:25:33,632
现在的场景有哪些地方出了问题？
What are some of the things that are wrong with the scene right now?

481
00:25:33,632 --> 00:25:35,450
观众：镜头应该和他一起移动 
AUDIENCE: The camera should move with him.

482
00:25:35,450 --> 00:25:36,320
科尔顿·奥格登：相机应该和他们一起移动 
COLTON OGDEN: Camera should move with them.

483
00:25:36,320 --> 00:25:37,700
观众：没有动画 
AUDIENCE: No animation.

484
00:25:37,700 --> 00:25:39,440
科尔顿·奥格登：没有动画 
COLTON OGDEN: Does not have animation.

485
00:25:39,440 --> 00:25:41,690
这可能是两个真正的错误 
Those are probably the two real things that are wrong.

486
00:25:41,690 --> 00:25:45,712
所以摄像头不会跟踪他 这很重要 
So camera does not track him, which is an important thing.

487
00:25:45,712 --> 00:25:48,670
显然 我们希望能够保持对我们角色的引用 
Obviously, we want to be able to maintain a reference to our character,

488
00:25:48,670 --> 00:25:50,150
除非我们在屏幕的左边
unless we're at the left edge of the screen.

489
00:25:50,150 --> 00:25:52,880
如果我们在屏幕的左边缘 这实际上是可以的 
If we're at the left edge of the screen, this is actually OK.

490
00:25:52,880 --> 00:25:56,690
这是分配的一部分--我们夹住x射线 
And that's part of the distro-- is we clamp the x so

491
00:25:56,690 --> 00:25:59,690
它不会超过左边
that it doesn't go past the left edge.

492
00:25:59,690 --> 00:26:05,210
但是如果我们超出了中间 而不是屏幕的右边 
But if we're beyond the middle and not to the right edge of the screen,

493
00:26:05,210 --> 00:26:08,910
它应该和他一起运动 反之亦然
it should be moving along with him and vice versa.

494
00:26:08,910 --> 00:26:11,030
然后他需要动画 所以他的精灵
And then he needs to animate, so his sprite

495
00:26:11,030 --> 00:26:15,050
需要每隔一定的秒数改变一次是否在移动 
needs to change every certain number of seconds whether he's moving.

496
00:26:15,050 --> 00:26:17,180
只有在他移动的时候才能看到 对吧？
And it has to be only when he's moving, right?

497
00:26:17,180 --> 00:26:20,240
如果他站着不动 你可以有一个空闲的动画 
If he's standing still, you can have an idle animation.

498
00:26:20,240 --> 00:26:23,460
有些角色会用脚敲 做这样的事情 
Some characters will tap their foot and do stuff like that.

499
00:26:23,460 --> 00:26:26,870
但为了这个例子 我们希望他
But let's say for the sake of this example we want him just

500
00:26:26,870 --> 00:26:28,790
在他空闲的时候站着不动
to stand still when he's idle.

501
00:26:28,790 --> 00:26:31,940
我们希望他在移动的时候有一个真实的动画 
And we want him to have an actual animation when he's moving.

502
00:26:31,940 --> 00:26:34,640
我们得处理好这两件事
We need to take care of these two pieces--

503
00:26:34,640 --> 00:26:38,310
如果算上空闲的动画部分的话 有三块 
three pieces if you count the idle animation part.

504
00:26:38,310 --> 00:26:43,310
让我们进入角色2 处理第一部分 
So let's go into character2 and take care of the first part, which

505
00:26:43,310 --> 00:26:45,890
正在追踪他
is tracking him.

506
00:26:45,890 --> 00:26:47,504
让我们进入角色2 
So let me go into character2.

507
00:26:47,504 --> 00:26:49,670
我们先运行一下看看是什么样的 
Let's run it first so we can see what it looks like.

508
00:26:54,610 --> 00:26:58,680
所以现在摄像头基本上是固定在播放器上的 
So now the camera is basically affixed to the player.

509
00:26:58,680 --> 00:27:01,670
在这个例子中 我们不考虑左边缘的问题 
In this example, we don't take care of the left edge issue.

510
00:27:01,670 --> 00:27:03,910
在发行版中 这是固定的 
In the distro, that's fixed.

511
00:27:03,910 --> 00:27:09,210
但是我们有基本的侧滚动机制--拿一个角色 
But we have the basic side scrolling mechanic-- take a character,

512
00:27:09,210 --> 00:27:11,610
追随她.
follow him.

513
00:27:11,610 --> 00:27:13,980
你觉得我们是怎么做到的？
How do you think that we're accomplishing this?

514
00:27:17,520 --> 00:27:18,020
是的
Yes.

515
00:27:18,020 --> 00:27:22,250
观众：根据人物X翻译图画？
AUDIENCE: Translate the drawing against the characterX?

516
00:27:22,250 --> 00:27:24,700
科尔顿·奥格登：是的 完全正确 
COLTON OGDEN: Yes, exactly.

517
00:27:24,700 --> 00:27:28,190
它不可能是X这个字符 
And it can't be exactly the characterX though,

518
00:27:28,190 --> 00:27:31,760
因为如果是的话 那么这个字符应该在左边 对吧？
because if it is, then the character is going to be on the left edge, right?

519
00:27:31,760 --> 00:27:35,290
所以我们需要偏移我们平移的x 
So we need to offset our x that we translate by.

520
00:27:35,290 --> 00:27:40,820
我们需要基本上平移他的x减去一半的屏幕空间
We need to basically translate by his x minus half the screen space

521
00:27:40,820 --> 00:27:42,590
加上字符宽度的一半 
plus half the character width.

522
00:27:42,590 --> 00:27:45,340
这将产生翻译它的效果 但始终保持
And that will have the effect of translating it but always keeping

523
00:27:45,340 --> 00:27:48,530
如果这有道理的话 那就是偏离播放器半个屏幕宽度 
that offset half a screen width away from the player, if that makes sense.

524
00:27:48,530 --> 00:27:52,450
所以我们所做的是在角色中--这是角色2 对吧--
And so what we're doing is in character-- this is character2, right--

525
00:27:52,450 --> 00:27:58,040
特征2 我们仍然在做我们曾经做过的事情 
character2, we're still doing the same thing we did.

526
00:27:58,040 --> 00:28:01,070
实际上 那是错误的文件 
Actually, that's the wrong file.

527
00:28:01,070 --> 00:28:05,510
我们在这里修改Character X 
We are modifying characterX here.

528
00:28:05,510 --> 00:28:07,970
所以我们之前做了同样的事情--
So same thing we did before--

529
00:28:07,970 --> 00:28:10,920
将移动速度乘以增量时间 然后进行加法或减法
multiply the move speed by delta time and either add or subtract it

530
00:28:10,920 --> 00:28:12,253
如果我们按向左或向右 
if we're pressing left or right.

531
00:28:12,253 --> 00:28:16,994
而且 在这里--重新引入相机卷轴 
But also, here-- reintroducing camera scroll.

532
00:28:16,994 --> 00:28:20,160
我们将其设置为 就像我说的 Character X减去虚拟宽度除以
And we're setting it to, like I said, characterX minus VIRTUAL_WIDTH divided

533
00:28:20,160 --> 00:28:23,450
2 半个屏幕 然后正偏移量
by 2, half the screen, and then positive offset

534
00:28:23,450 --> 00:28:27,860
他的宽度除以2 所以他正好在中间 
of his width divided by 2 so that he's perfectly right in the center.

535
00:28:27,860 --> 00:28:30,110
因为请记住 字符的坐标
Because remember, characters' coordinates

536
00:28:30,110 --> 00:28:34,100
被放在他们的左边 而不是他们的中间 
are set by their left, not their center.

537
00:28:34,100 --> 00:28:36,740
然后我们只是做我们以前做过的事情 
And then we just do what we did before.

538
00:28:36,740 --> 00:28:40,010
我们根据CameraScroll对场景进行翻译 
We translate the scene based on cameraScroll,

539
00:28:40,010 --> 00:28:44,720
我们用Math.Floor将他呈现在CharacterX Charactery上
and we render him at characterX characterY using math.floor

540
00:28:44,720 --> 00:28:48,430
以防止他在我们的世界空间中处于一个分割点
to prevent him from being at a fractional point in our world space

541
00:28:48,430 --> 00:28:50,690
然后它变得模糊和做作 
and then it being blurry and artifacted.

542
00:28:50,690 --> 00:28:55,487
这就是我们如何跟踪角色的某种程度上的问题 
And that's sort of it in terms of how we can get tracking over character.

543
00:28:55,487 --> 00:28:57,320
如果你想沿着y轴追踪 
And if you wanted to track along the y-axis,

544
00:28:57,320 --> 00:28:58,760
你也可以做同样的事情 
you could do the exact same thing.

545
00:28:58,760 --> 00:29:02,690
维护相机滚动X和摄像机滚动Y--
Maintain a cameraScroll x and a cameraScroll y--

546
00:29:02,690 --> 00:29:04,940
所以要把它们分开 
so keep them separated.

547
00:29:04,940 --> 00:29:09,260
然后你就可以在这里翻译了 
And then you would just translate here.

548
00:29:09,260 --> 00:29:11,750
所以我们传入0 因为我们不想
So we're passing in 0, because we don't want

549
00:29:11,750 --> 00:29:13,430
必须沿y轴跟踪 
to track along the y-axis necessarily.

550
00:29:13,430 --> 00:29:18,140
但您需要做的就是传递您的y CameraScroll 
But all you would need to do is pass in your y cameraScroll.

551
00:29:18,140 --> 00:29:20,579
然后你可以根据性格来做
And then you could do it based on characterY

552
00:29:20,579 --> 00:29:22,370
不管它们是否在地面上
and whether or not they're above the ground

553
00:29:22,370 --> 00:29:25,310
或者越过天空中的某个点 
or past a certain point in the sky.

554
00:29:25,310 --> 00:29:29,020
那么 对于这里的摄像头跟踪系统是如何工作的 有什么问题吗？
So any questions at all as to how the camera tracking is working here?

555
00:29:31,790 --> 00:29:33,830
好的 
All right.

556
00:29:33,830 --> 00:29:38,332
所以我们解决了一个问题 那就是缺乏跟踪 
So we took care of one issue, which was the lack of tracking.

557
00:29:38,332 --> 00:29:40,790
但还有一个问题 那就是他没有动画 
But there was one other issue, which was he's not animated.

558
00:29:40,790 --> 00:29:47,330
他所做的就是像M.C.哈默那样移动--
All he's doing is just moving sort of like M.C. Hammer--

559
00:29:47,330 --> 00:29:48,451
或者是M.C.Usher？
or is it M.C. Usher?

560
00:29:48,451 --> 00:29:48,950
M.C.哈默？
M.C. Hammer?

561
00:29:48,950 --> 00:29:50,330
我忘了 
I forget.

562
00:29:50,330 --> 00:29:51,140
他就是这么做的 
He's doing that.

563
00:29:51,140 --> 00:29:52,220
他什么都没做 
He's not doing anything.

564
00:29:52,220 --> 00:29:55,640
我们需要让他动起来 这样他看起来就像有生命一样
We need to actually animate him so that he looks like he has some life to him

565
00:29:55,640 --> 00:29:57,680
而且你还可以重要地区别于
and that you can also differentiate importantly

566
00:29:57,680 --> 00:29:59,390
在两个不同的状态之间 
between two separate states.

567
00:29:59,390 --> 00:30:02,630
他可以无所事事 不动 也可以动起来 
He can be idle, he's not moving, and he can be moving.

568
00:30:02,630 --> 00:30:05,450
所以我们应该有某种视觉反馈
So we should have some sort of visual feedback

569
00:30:05,450 --> 00:30:08,960
关于目前正在发生的事情 
as to what's currently going on.

570
00:30:08,960 --> 00:30:14,030
因此 有谁知道我们如何着手实施
So anybody know how we can go about implementing

571
00:30:14,030 --> 00:30:16,360
为我们的角色制作动画片？
an animation for our character?

572
00:30:16,360 --> 00:30:18,703
我们需要哪些零件？
What are the pieces that we'll need?

573
00:30:18,703 --> 00:30:20,667
观众：我想如果他走对了 那么
AUDIENCE: I guess if he's moving right, then

574
00:30:20,667 --> 00:30:25,570
调用一个函数和一个渲染来查看一些图像？
call a function and a render that looks through some images?

575
00:30:25,570 --> 00:30:26,320
科尔顿·奥格登：是的 
COLTON OGDEN: Yes.

576
00:30:26,320 --> 00:30:29,680
所以如果他向右移动 那么就有一个功能
So if he's moving right, then have a function

577
00:30:29,680 --> 00:30:31,750
这就像是在一些图像中循环 
that sort of loops through some images.

578
00:30:31,750 --> 00:30:34,520
这实际上就是我们将要做的事情 
That is effectively what we will be doing.

579
00:30:34,520 --> 00:30:37,680
我们有一个叫动画的课程 我已经在这里介绍过了 
We have a class called Animation, which I've introduced here.

580
00:30:37,680 --> 00:30:40,750
它所做的基本上就是跟踪--你
And all it basically does is keep track of-- you

581
00:30:40,750 --> 00:30:44,140
将其传递到一个表中 该表包含工作表的框架
pass it in a table, which has the frames of the sheet

582
00:30:44,140 --> 00:30:45,760
您想要设置动画的对象 
that you want to animate over.

583
00:30:45,760 --> 00:30:47,160
所以我们可以直接进去--
So we can just pass in--

584
00:30:47,160 --> 00:30:48,660
让我们继续前进 看看这里 
let's go ahead and take a look here.

585
00:30:50,700 --> 00:30:53,470
我之前参考了这张幻灯片 但所有这些
And I referenced the slide earlier, but all of these

586
00:30:53,470 --> 00:30:57,160
有1 2 3 4 5 6 7 8 9 10--不管有多少 
are 1, 2, 3, 4, 5, 6, 7, 8, 9, 10-- however many there are,

587
00:30:57,160 --> 00:31:01,296
你只要进入动画即可 
you just pass into the animation.

588
00:31:01,296 --> 00:31:02,420
假设他在梯子上 
Let's say he's on a ladder.

589
00:31:02,420 --> 00:31:05,920
假设这是1、2、3、4、5、6和7 
So let's say this is 1, 2, 3, 4, 5, 6, and 7.

590
00:31:05,920 --> 00:31:08,560
你说 帧将是6和7 
You say, the frames are going to be 6 and 7,

591
00:31:08,560 --> 00:31:12,070
所以它们会从左到右循环 从后面开始
so those will just loop left to right, starting back

592
00:31:12,070 --> 00:31:16,240
在开始的时候 当它结束的时候 然后你给它一个间隔 
at the beginning when it's finished And then you give it an interval.

593
00:31:16,240 --> 00:31:19,520
比方说 我希望动画以秒为单位这么快地发生 
So say I want the animation to happen this fast in terms of seconds,

594
00:31:19,520 --> 00:31:23,000
所以我希望它可能每0.2秒发生一次 
so I want it that maybe happened every 0.2 seconds.

595
00:31:23,000 --> 00:31:25,934
因此 这将产生每0.2秒的影响 
And so that will have the effect of every 0.2 seconds,

596
00:31:25,934 --> 00:31:27,100
它会记录一个计时器 
it'll keep track of a timer.

597
00:31:27,100 --> 00:31:30,790
那么我们已经超过0.2秒了吗？
So have we gone over 0.2 seconds?

598
00:31:30,790 --> 00:31:33,700
从0开始 然后每次都加上增量时间 
Start at 0 and then add delta time to it every time.

599
00:31:33,700 --> 00:31:37,750
如果有 则增加当前动画的帧 
If we have, increment what our current frame of animation is.

600
00:31:37,750 --> 00:31:42,280
所以我们现在的画面是这一幅 然后0.2秒过去了 
So our current frame is this one, and then 0.2 seconds elapses,

601
00:31:42,280 --> 00:31:43,480
就是这一次 
it's going to be this one.

602
00:31:43,480 --> 00:31:47,000
然后0.2秒过去了 我们需要循环回到起点 
And then 0.2 second elapses, and we need to loop back to the beginning.

603
00:31:47,000 --> 00:31:49,150
所以我们最终会使用模数来解决这个问题
So we'll end up using modulus to take care of that

604
00:31:49,150 --> 00:31:51,070
就像我们在动画课上看到的那样 
as we can see in the Animation class.

605
00:31:54,520 --> 00:31:55,930
基本上 这些都在这里完成了 
Basically, that's all done here.

606
00:31:55,930 --> 00:32:00,340
因此 如果我们有不止一帧动画 回想一下 它在这里得到了定义 
So if we have more than one frame of animation, recall it gets a def here.

607
00:32:00,340 --> 00:32:04,112
所以我们得到帧 我们得到一个间隔 得到一个被初始化为0的计时器 
So we get frames, we get an interval, get a timer that's initialized to 0,

608
00:32:04,112 --> 00:32:05,320
然后获得当前帧 
and then get a current frame.

609
00:32:05,320 --> 00:32:09,070
我们将当前帧设置为1 
We'll say the current frame is 1.

610
00:32:09,070 --> 00:32:12,322
然后 只要我们有不止一帧 
And then as long as we have more than one frame,

611
00:32:12,322 --> 00:32:14,530
循环或尝试动画是没有意义的
there's no point in looping over or trying to animate

612
00:32:14,530 --> 00:32:16,930
只有一帧的任何动画 
any animation that only has one frame.

613
00:32:16,930 --> 00:32:20,140
当然 我们可以制作只有一帧的动画 
And we can, of course, have animations that only have one frame.

614
00:32:20,140 --> 00:32:23,500
闲置只是一帧动画 就像我们在这里看到的 
Idle is only one frame of animation, as we saw here.

615
00:32:23,500 --> 00:32:24,959
这只是一帧而已 
That's only one frame.

616
00:32:24,959 --> 00:32:27,000
我们不需要做任何逻辑来说 哦 
We don't need to do any sort of logic to say, oh,

617
00:32:27,000 --> 00:32:29,560
下一帧是什么 因为只有一帧 
what's the next frame, because there's only one frame.

618
00:32:29,560 --> 00:32:37,330
但是如果我们看角色3 我们可以在那里看到两个帧 
But if we were to look at character3, we can see two frames there.

619
00:32:37,330 --> 00:32:39,760
然后 这只是一个画面 他无所事事 
And then that's just one, frame he's idle.

620
00:32:39,760 --> 00:32:42,860
当我们向左移动时 他也会朝那个方向移动 
And when we move left, he moves in that direction.

621
00:32:42,860 --> 00:32:45,822
有没有人记得我们怎么才能找到他--因为很明显 
Anybody recall how we can get him-- because obviously,

622
00:32:45,822 --> 00:32:47,530
我们刚刚看到了电子表格 
we saw the spreadsheet just a second ago,

623
00:32:47,530 --> 00:32:50,290
而精灵面对的只有一个方向--
and there was only one direction that the sprites were facing--

624
00:32:50,290 --> 00:32:54,070
我们怎么才能让他看起来像那样 即使有
how we can get him to look that way, even though there's

625
00:32:54,070 --> 00:32:57,323
没有精灵让他看起来那样吗？
no sprites for him to look that way?

626
00:32:57,323 --> 00:32:59,170
观众：把它绕着轴翻转 
AUDIENCE: Flip it on the axis.

627
00:32:59,170 --> 00:33:03,190
科尔顿·奥格登：翻转它 所以爱 
COLTON OGDEN: Flip it, so love.graphics.draw.

628
00:33:03,190 --> 00:33:07,900
回想一下 您可以在任意轴上传递负比例因子 
Recall you can pass in a negative scale factor on whatever axis you want,

629
00:33:07,900 --> 00:33:10,912
这将会产生沿着那个轴翻转的结果 
and that'll have the result of flipping it along that axis.

630
00:33:10,912 --> 00:33:11,870
这就是我们要做的一切 
That's all we're doing.

631
00:33:11,870 --> 00:33:14,161
这是默认的框架 所以我们只是绘制它 
So this is the default frame, so we're just drawing it.

632
00:33:14,161 --> 00:33:17,300
然后我们必须保持对他面对的方向的参考 
And then we have to keep a reference to whatever direction he's facing.

633
00:33:17,300 --> 00:33:19,390
如果他的方向是正确的 我们将
And if his direction is equal to right, we'll

634
00:33:19,390 --> 00:33:23,300
只需绘制该帧 然后循环处理动画即可 
just draw that frame and then loop and process the animation.

635
00:33:23,300 --> 00:33:29,380
如果他面朝左 画它 但也要执行负1变换
If he's facing left, draw it, but also perform a negative 1 transformation

636
00:33:29,380 --> 00:33:30,820
在x轴上 
on the x-axis.

637
00:33:30,820 --> 00:33:33,670
就像这样 我们让它奏效了 
And just like that, we have that working.

638
00:33:33,670 --> 00:33:34,600
所以我们要做的是--
So all we're doing--

639
00:33:34,600 --> 00:33:36,070
只要有个计时器就行了 
just keep a timer.

640
00:33:36,070 --> 00:33:41,050
然后 当计时器超过我们的间隔时 只需增加帧 
And then when the timer goes over our interval, just increment the frame.

641
00:33:41,050 --> 00:33:44,140
然后用模数循环到它上面--
And then use modulus to loop back over it--

642
00:33:44,140 --> 00:33:45,480
返回到从1开始 
back to starting at 1.

643
00:33:45,480 --> 00:33:48,691
这些都是在这28号线上完成的 
And that's all done here on this line 28.

644
00:33:48,691 --> 00:33:50,440
所以你可以再往里面看一点
And so you can look in there a little more

645
00:33:50,440 --> 00:33:53,320
如果你想掌握数学原理 
if you want to get a handle on how the math works,

646
00:33:53,320 --> 00:33:58,300
但它只是一个简单的迭代帧集合的序列
but it is just a simple sequence of iterating over a collection of frames

647
00:33:58,300 --> 00:33:59,640
以计时器为基础 
based on a timer.

648
00:33:59,640 --> 00:34:02,830
这就产生了这样的效果--就像我之前说过的活页书一样--
And that has the effect-- just like a flip book, as I said earlier--

649
00:34:02,830 --> 00:34:06,160
我们的角色有一个动画和一些生活 
of our character having an animation and having some life.

650
00:34:06,160 --> 00:34:10,060
那么 关于这个动画课程是如何运作的 有什么问题吗？
So any questions as to how this animation class works?

651
00:34:10,060 --> 00:34:12,437
观众：渲染是在动画课上吗？
AUDIENCE: The render is in the Animate class?

652
00:34:12,437 --> 00:34:13,270
科尔顿·奥格登：所以不是 
COLTON OGDEN: So no.

653
00:34:13,270 --> 00:34:14,894
渲染不在动画类中 
The render is not in the animate class.

654
00:34:14,894 --> 00:34:16,780
所以渲染是--
So the render is--

655
00:34:16,780 --> 00:34:20,060
我意识到我在这里没有展示任何真正的Main 
I realize I didn't show any actual main here.

656
00:34:20,060 --> 00:34:22,830
我们这里有两个动画 只是一个闲置的动画 
We have two animations here, which was just the idle one,

657
00:34:22,830 --> 00:34:24,550
所以我们只传了一帧 
so we're just passing in one frame.

658
00:34:24,550 --> 00:34:26,794
我们将它的间隔设为1 
We're going to give it an interval of 1.

659
00:34:26,794 --> 00:34:29,710
这并不重要 但为了保持一致性 
It's not going to really matter, but just for the sake of consistency,

660
00:34:29,710 --> 00:34:31,750
我们给它一个1的区间--任意的 
we're giving it an interval of 1-- arbitrary.

661
00:34:31,750 --> 00:34:35,090
也许我们以后会想要改变他的动画 
And maybe we want to change his animation later.

662
00:34:35,090 --> 00:34:39,100
因此 通过在这里设置间隔 我们不会忘记在以后添加一个 
So by having an interval here, we won't forget to add one later.

663
00:34:39,100 --> 00:34:41,409
移动的动画--回想一下10和11 
Moving animation-- recall 10 and 11.

664
00:34:41,409 --> 00:34:43,130
所以这是在这张纸的最后--
So it's toward the end of the sheet--

665
00:34:43,130 --> 00:34:46,090
两个行走的框架 
the two walking frames.

666
00:34:46,090 --> 00:34:48,520
这里的间隔是0.2秒 
Interval here is 0.2 seconds.

667
00:34:48,520 --> 00:34:51,969
我们需要一个当前的动画来渲染他 
We need a current animation to render him,

668
00:34:51,969 --> 00:34:55,909
然后我们会参考他所看的任何方向 
and then we keep a reference to whatever direction he's looking at.

669
00:34:55,909 --> 00:34:58,570
所以如果他向右看 我们就去
So if he's looking to the right, we're going

670
00:34:58,570 --> 00:35:02,282
要在love.graph中引用这一点 请在底部绘制 
to reference this in the love.graphics.draw at the bottom.

671
00:35:02,282 --> 00:35:04,990
这就是我们要用来表演精灵翻转的东西
And that's what we're going to use to perform the sprite flipping

672
00:35:04,990 --> 00:35:07,560
沿着x轴 
along the x-axis.

673
00:35:07,560 --> 00:35:09,500
保持对这一点的引用 
Maintain a reference to that.

674
00:35:09,500 --> 00:35:14,500
然后在这里 我们实际引用动画的部分
And then down here, the part that we actually reference the animation

675
00:35:14,500 --> 00:35:18,670
如果你在看《字符1》 在150号线上 
is on line 150 if you're looking at character1.

676
00:35:18,670 --> 00:35:20,870
或者是第二个特征？
Or is it character2?

677
00:35:20,870 --> 00:35:22,410
抱歉 角色3 
Sorry, character3.

678
00:35:22,410 --> 00:35:26,130
如果你看的是第三个角色的第150行 
If you're looking at line 150 in character3,

679
00:35:26,130 --> 00:35:29,307
我们使用CurrentAnimation：getCurrentFrame() 
we're using currentAnimation:getCurrentFrame().

680
00:35:29,307 --> 00:35:32,640
所以这个类实际上只会告诉你动画的当前帧是什么
So the class will actually just tell you whatever the current frame of animation

681
00:35:32,640 --> 00:35:37,410
是因为它保留了对它基于计时器的帧的引用
is, because it keeps a reference to what frame it is based on the timer

682
00:35:37,410 --> 00:35:39,287
以及已经过去了多少 
and how much has elapsed.

683
00:35:39,287 --> 00:35:43,760
观众：所以这个班级正在实时生成一个不同的画面
AUDIENCE: So the class is generating a different frame real time

684
00:35:43,760 --> 00:35:45,019
然后把它插在那里 
and plugging it in there.

685
00:35:45,019 --> 00:35:45,810
科尔顿·奥格登：是的 
COLTON OGDEN: Yeah.

686
00:35:45,810 --> 00:35:49,420
它维护对当前帧的引用 
It's maintaining a reference to whatever the current frame is,

687
00:35:49,420 --> 00:35:51,990
它在你给它的时候得到的相框表格里
and it's in the table of frames that it got when you gave it

688
00:35:51,990 --> 00:35:56,000
最上面的定义--
the definition up at the top here--

689
00:35:56,000 --> 00:35:59,880
第51到58行 我们在其中创建两个动画 
lines 51 to 58 where we create the two animations.

690
00:35:59,880 --> 00:36:03,870
基本上 它维护对该框架表中哪个索引的引用
Basically, it maintains a reference to which index in this frame table

691
00:36:03,870 --> 00:36:04,930
我们已经到了 
we're at.

692
00:36:04,930 --> 00:36:10,180
所以 如果0.2秒过去了 我们从1开始 然后我们转到2 
So if 0.2 seconds has elapsed, we start at 1, and then we go to 2.

693
00:36:10,180 --> 00:36:11,520
然后我们将返回到1 
And then we'll go back to 1.

694
00:36:11,520 --> 00:36:15,970
所以它基本上只会返回帧和索引 
And so it'll just basically return frames, index.

695
00:36:15,970 --> 00:36:20,720
并且帧索引1是10 帧索引2是11 
And frames index 1 is 10, frames index 2 is 11.

696
00:36:20,720 --> 00:36:25,480
所以函数是getCurrentFrame 
And so the function is getCurrentFrame.

697
00:36:25,480 --> 00:36:29,730
因此Character Quads、CurrentAnimation、GetCurrentFrame 
So characterQuads, currentAnimation, getCurrentFrame.

698
00:36:29,730 --> 00:36:37,410
然后在这里 因为我们正在进行原点转换--
And then here, because we're performing an origin transformation--

699
00:36:37,410 --> 00:36:43,260
所以 当你翻转精灵时 这是另一件需要考虑的事情 
so that's another thing to consider when you're flipping sprites.

700
00:36:43,260 --> 00:36:45,480
当你翻转一个精灵时 它实际上是顺着它翻转的
When you flip a sprite, it actually flips along

701
00:36:45,480 --> 00:36:47,490
不管它的默认来源是什么 
whatever its default origin is.

702
00:36:47,490 --> 00:36:53,130
任何精灵的默认原点都在这里的左上角 
And the default origin of any sprite is its top left corner here.

703
00:36:53,130 --> 00:36:56,880
所以如果你沿着x轴翻转某物 
So if you flip something along its x-axis,

704
00:36:56,880 --> 00:37:00,630
它会出现在这里 而不是在原地翻转 
it'll appear here instead of just flipping in place.

705
00:37:00,630 --> 00:37:03,870
所以实际上你必须将原点设置为其中心
So you actually have to set the origin to its center

706
00:37:03,870 --> 00:37:07,090
当你做任何形式的原地翻转精灵 
when you do any sort of in place flipping of a sprite.

707
00:37:07,090 --> 00:37:10,290
因此 当您查看代码时 您会注意到
So you'll notice in the code when you're looking

708
00:37:10,290 --> 00:37:16,980
在这里 我们将字符宽度除以2 再加上字符高度
at it that we have plus CHARACTER_WIDTH divided by 2 and plus CHARACTER_HEIGHT

709
00:37:16,980 --> 00:37:21,000
用这两个除以2 
divided by 2 on these two here.

710
00:37:21,000 --> 00:37:24,240
所以我们移动它的绘制位置 然后我们移动它的原点
So we shift where it gets drawn, and then we shift its origin

711
00:37:24,240 --> 00:37:26,610
偏移量在第160行 
offsets which are here on line 160.

712
00:37:26,610 --> 00:37:28,920
所以 如果你看love.graph 你会发现
So if you look at love.graphics.draw, you'll

713
00:37:28,920 --> 00:37:31,770
看 它有很多可选参数 
see it has a lot of optional arguments.

714
00:37:31,770 --> 00:37:36,960
底部的这两个参数是原点偏移参数 
And these two at the bottom are the origin offset arguments.

715
00:37:36,960 --> 00:37:39,840
所以这些只有在以下情况下才真正发挥作用
And so these only really come into play when

716
00:37:39,840 --> 00:37:44,970
你做一些精灵在轴上的翻转
you do some kind of flipping of a sprite on an axis

717
00:37:44,970 --> 00:37:50,560
你想要图形的一致性 而不是让它以这样或那样的方式翻转 
and you want graphical consistency not to have it flip one way or the other.

718
00:37:50,560 --> 00:37:53,381
有时这就是你想要的效果 但在这种情况下 
Sometimes that's the effect you're looking for, but in this case,

719
00:37:53,381 --> 00:37:53,880
事实并非如此 
it's not.

720
00:37:53,880 --> 00:37:56,360
我们希望他呆在原地不动 
We want him to literally stay in the exact same place.

721
00:37:56,360 --> 00:37:58,334
因此 要在完全相同的位置翻转一杯雪碧 
So to flip a sprite in the exact same place,

722
00:37:58,334 --> 00:38:00,750
您需要将其原点设置在其中心 而不是其左上角 
you need a set its origin to its center, not its top left.

723
00:38:00,750 --> 00:38:04,090
这说得通吗？
Does that makes sense?

724
00:38:04,090 --> 00:38:05,130
好的 
OK.

725
00:38:05,130 --> 00:38:08,940
还有这里 0是这里的旋转 
And also here, 0 is the rotation here.

726
00:38:08,940 --> 00:38:11,140
因此 如果您要添加
So it's sort of required if you're going to add

727
00:38:11,140 --> 00:38:13,870
将这么多参数传递给函数 
this many arguments to the function.

728
00:38:13,870 --> 00:38:18,540
但我们正在测试方向是否等于左 我们想要翻到负1
But we're testing if direction is equal to left, we want to flip by negative 1

729
00:38:18,540 --> 00:38:22,920
在x上 否则就给它1 
on the x, else just give it 1.

730
00:38:22,920 --> 00:38:26,880
因此 1只是表示默认变换 所以没有翻转 
So 1 just means default transformation, so no flipping.

731
00:38:26,880 --> 00:38:30,360
然后我们根本不在y上翻转 所以它永远是1 
And then we don't flip on the y at all, so that will always be 1.

732
00:38:30,360 --> 00:38:34,950
简而言之 这就是如何让你的角色动画化 同时
And so that's in a nutshell how you can get your character to animate and also

733
00:38:34,950 --> 00:38:37,560
设置动画时 请保持原地不动 
stay in place when you animate it.

734
00:38:37,560 --> 00:38:43,810
那么 有没有关于动画或原点偏移或任何工作原理的问题？
So any questions as to how animations or the origin offsets or any of that work?

735
00:38:47,660 --> 00:38:48,230
好的 
OK.

736
00:38:48,230 --> 00:38:50,500
所以我们确实谈到了动画 
So we did talk about animations.

737
00:38:50,500 --> 00:38:53,450
我们将讨论的最后一件事是跳跃 
The last thing we'll talk about for the character is jumping.

738
00:38:53,450 --> 00:38:58,240
那么 如果你回忆起Flappy Bird 我们怎么才能让我们的角色跳起来呢？
So if you recall from Flappy Bird, how can we get our character to jump?

739
00:38:58,240 --> 00:39:02,300
我们需要些什么呢？
What are some of the pieces we need?

740
00:39:02,300 --> 00:39:07,050
观众：按下键 然后y上升 
AUDIENCE: Key press, and then the y goes up.

741
00:39:07,050 --> 00:39:08,490
然后我们必须有重力 
And then we have to have gravity.

742
00:39:08,490 --> 00:39:09,360
科尔顿·奥格登：是的 
COLTON OGDEN: Yep.

743
00:39:09,360 --> 00:39:14,140
所以按键是我们需要的一件事 所以检查一下空间
So key press is one thing we need, so check for space

744
00:39:14,140 --> 00:39:16,020
将成为默认密钥 
is going to be the default key.

745
00:39:16,020 --> 00:39:19,240
Y上升 然后检查重力 
y goes up, and then check for gravity.

746
00:39:19,240 --> 00:39:22,860
所以我们不仅需要y 我们还需要 
So not only do we need y, but we also need delta y.

747
00:39:22,860 --> 00:39:29,340
我们需要速度 因为重力是速度的变换 而不是
We need velocity, because gravity is a transformation on velocity, not

748
00:39:29,340 --> 00:39:31,780
严阵以待 
strictly on position.

749
00:39:31,780 --> 00:39:39,540
所以如果我们回到角色4 这是一种
So if we go back to character4, this is sort

750
00:39:39,540 --> 00:39:41,970
以一种老套的方式来实现重力 
of a hackish way of implementing gravity,

751
00:39:41,970 --> 00:39:44,700
因为我们实际上还没有合并瓷砖碰撞 
because we haven't actually incorporated tile collisions.

752
00:39:44,700 --> 00:39:47,830
为此 我将推迟大部分实施
And I'll defer most of the implementation for that

753
00:39:47,830 --> 00:39:51,060
至于发行版 我会和你们一起去的 
as to the distro, and I'll go over with you guys.

754
00:39:51,060 --> 00:39:53,700
但现在 我们拥有和以前完全一样的东西 
But right now, we have the exact same thing we had before,

755
00:39:53,700 --> 00:39:55,460
在那里我们有瓷砖滚动 
where we have tile scrolling.

756
00:39:55,460 --> 00:39:58,500
但如果我按空格键 我上去 然后他下来 
But if I press space bar, I go up, and then he comes down.

757
00:39:58,500 --> 00:40:01,300
请注意 他也有一个动画 
And notice that he has an animation as well.

758
00:40:01,300 --> 00:40:02,410
他有着不同的身材 
He has a different frame.

759
00:40:02,410 --> 00:40:05,469
所以如果他在跳跃 他就有一个小小的跳跃框 
So if he's jumping, he's got a little jump frame.

760
00:40:05,469 --> 00:40:07,260
这意味着我们现在有三个动画 
So that means now we have three animations.

761
00:40:07,260 --> 00:40:09,834
我们有一个闲置的动画 我们有一个移动的动画 
We have an idle animation, we have a moving animation,

762
00:40:09,834 --> 00:40:11,250
然后我们有一个跳跃动画 
and then we have a jump animation.

763
00:40:11,250 --> 00:40:14,250
所以实际上 我们也有三个州--
So effectively, we have three states as well--

764
00:40:14,250 --> 00:40:18,090
空闲状态、移动状态和跳跃状态 
idle state, moving state, and jumping state.

765
00:40:18,090 --> 00:40:20,220
实际上是四个州 
Four states, actually.

766
00:40:20,220 --> 00:40:23,490
另外 我注意到这里有一个小错误 如果你还在空中 
And also, I noticed a slight bug here where if you're still in the air,

767
00:40:23,490 --> 00:40:25,307
他的框架没有改变 
his frame doesn't change.

768
00:40:25,307 --> 00:40:27,390
所以它实际上可能应该停留在那个画面上 
So it actually probably should stay to that frame,

769
00:40:27,390 --> 00:40:28,830
即使他站着不动 
even if he's standing still.

770
00:40:28,830 --> 00:40:30,700
但我想这没什么大不了的 
But I guess it doesn't matter too much.

771
00:40:30,700 --> 00:40:34,050
我们也把它理解为一种特征 
We also interpret it as a feature.

772
00:40:34,050 --> 00:40:40,520
但当他在空中飞行时 他有几个状态 
But he's got a couple of states when he's in the air.

773
00:40:40,520 --> 00:40:42,480
这里应该有两个州 
There should be two states here.

774
00:40:42,480 --> 00:40:44,730
一种是跳跃状态 另一种是下降状态 
One is jumping state, and one is falling state.

775
00:40:44,730 --> 00:40:48,540
我们知道为什么两者不同是一件重要的事情吗？
And do we know why the two being different is an important thing?

776
00:40:52,780 --> 00:40:56,070
所以如果我们想一想超级马里奥兄弟 
So if we think about Super Mario Bros.

777
00:40:56,070 --> 00:41:00,970
我们思考跳跃和坠落之间的区别 
and we think about the differences between jumping and falling,

778
00:41:00,970 --> 00:41:04,260
根据马里奥是否跳跃 有哪些事情会改变
what are some of the things that change based on whether Mario is jumping

779
00:41:04,260 --> 00:41:07,080
或者他是不是在坠落？
or whether he's falling?

780
00:41:07,080 --> 00:41:10,520
我应该说 他与环境的互动有什么不同？
How does he interact differently with the environment, I should say?

781
00:41:15,050 --> 00:41:21,480
所以 如果不熟悉的话 马里奥--当他跳起来的时候 他实际上可以击中盖帽 
So if unfamiliar, Mario-- when he jumps, he can actually hit blocks.

782
00:41:21,480 --> 00:41:23,570
因此 如果他在一个街区下面 他击中了一个街区 
So if he's below a block and he hits a block that

783
00:41:23,570 --> 00:41:27,120
它有某种行为 它会触发那个区块中的任何东西 
has some sort of behavior in it, it will trigger whatever is in that block,

784
00:41:27,120 --> 00:41:29,960
不管它是一枚硬币 还是要毁掉这个街区 
whether it's a coin or whether it's to destroy the block.

785
00:41:29,960 --> 00:41:34,790
如果他倒下了 回想一下如果他像野猪一样落在敌人身上 
And if he's falling, recall if he lands on top of an enemy like a goomba,

786
00:41:34,790 --> 00:41:36,450
他会消灭敌人 
he'll destroy the enemy.

787
00:41:36,450 --> 00:41:39,290
因此 我们需要区分这两种状态 
And so we need to distinguish between these two states.

788
00:41:39,290 --> 00:41:43,310
因为当他跳的时候 他不能--
Because when he's jumping, he's not able to--

789
00:41:43,310 --> 00:41:46,730
当他真的飞起来的时候 他不能攻击敌人 
when he's actually going up, he can't attack the enemy.

790
00:41:46,730 --> 00:41:49,580
同样 当他倒下时 他不能摧毁街区 
And likewise, when he's falling down, he can't destroy the block.

791
00:41:49,580 --> 00:41:52,550
所以即使他在空中跳跃
So even though he's jumping up in the air

792
00:41:52,550 --> 00:41:55,460
重力正在应用一种变换
and the gravity is applying a transformation

793
00:41:55,460 --> 00:42:00,590
这一切看起来都像是一个州 实际上有两个重要的变化
and it all looks like one state, there's actually two important changes

794
00:42:00,590 --> 00:42:02,250
在他所在的州都是相关的 
in his state that are relevant.

795
00:42:02,250 --> 00:42:04,740
这是我们需要注意的事情 
And that's something that we'll need to pay attention to,

796
00:42:04,740 --> 00:42:05,698
而且它在发行版中 
and it's in the distro.

797
00:42:05,698 --> 00:42:09,920
他有跌倒状态和跳跃状态 
He has a falling state and a jumping state.

798
00:42:09,920 --> 00:42:13,160
即使它们共享相同的动画 
Even though they share the same animation,

799
00:42:13,160 --> 00:42:15,690
他们有不同的行为 
they have different behavior.

800
00:42:15,690 --> 00:42:24,180
因此 让我们继续查看这里的Character 4发行版 
So let's go ahead and look at the character4 distro here.

801
00:42:24,180 --> 00:42:28,130
所以我在这里做的是 我为这个角色添加了一个增量y 
So what I've done here is I've added a delta y for the character.

802
00:42:28,130 --> 00:42:31,340
所以就像在Flappy Bird中我们按空格键一样
So just like in Flappy Bird when we press space

803
00:42:31,340 --> 00:42:34,710
我们的增量y上升到负50--
and we made our delta y go up to negative 50--

804
00:42:34,710 --> 00:42:37,370
所以立刻涨到了相当高的水平 因为
so instantly shot up pretty high, because that was getting

805
00:42:37,370 --> 00:42:38,870
适用于每一帧 
applied every frame.

806
00:42:38,870 --> 00:42:41,150
这里也是一样 
Same thing here.

807
00:42:41,150 --> 00:42:45,560
一旦我们按下空格键 我们将把增量y改为负50
Once we press space, we're going to change delta y to negative 50

808
00:42:45,560 --> 00:42:53,100
如果我们往下走到这里 
if we go down to right here.

809
00:42:53,100 --> 00:42:56,990
因此 如果键等于空格 我将它放在love.keyPressed函数中 
So if the key is equal to space, I have it in the love.keyPressed function.

810
00:42:56,990 --> 00:42:59,810
因为我们是在Main.Lua中做这一切 只是为了说明 
Since we're doing all this in main.lua just for illustration,

811
00:42:59,810 --> 00:43:02,890
事情有点简单 
things are a little simple.

812
00:43:02,890 --> 00:43:05,720
如果密钥等于空间并且他的增量y是
If key is equal to space and his delta y is

813
00:43:05,720 --> 00:43:07,670
等于0 如果我们不这样做会发生什么
equal to 0, what would happen if we didn't

814
00:43:07,670 --> 00:43:09,775
检查增量y是否等于0？
check to see if delta y was equal to 0?

815
00:43:09,775 --> 00:43:11,475
观众：我们在空中双人跳跃 
AUDIENCE: We double jump in the air.

816
00:43:11,475 --> 00:43:12,225
科尔顿·奥格登：是的 
COLTON OGDEN: Yep.

817
00:43:12,225 --> 00:43:15,470
我们将能够无限跳跃 所以我们必须对此进行检查 
We'd be able to jump infinitely, so we have to do a check for that.

818
00:43:15,470 --> 00:43:17,330
我们把他的速度调到了跳跃速度 
We set his dy to JUMP_VELOCITY.

819
00:43:17,330 --> 00:43:26,660
JUMP_SPECTURE是第29行上的一个常量 它是负200 
JUMP_VELOCITY is a constant up top on line 29, which is negative 200.

820
00:43:26,660 --> 00:43:29,060
重力等于7 
And then gravity is equal to 7.

821
00:43:29,060 --> 00:43:34,220
所以我们要做的就是把它设置为负200--他的增量y--
And so what we do is we set it to negative 200-- his delta y--

822
00:43:34,220 --> 00:43:35,600
只要他一跳起来 
as soon as he jumps.

823
00:43:35,600 --> 00:43:40,850
然后更新中的每一帧 我们基本上
And then every frame down in update, we basically

824
00:43:40,850 --> 00:43:43,580
通过重力增加他的增量y 
increment his delta y by gravity.

825
00:43:43,580 --> 00:43:50,634
然后我们把他的y增加 乘以 
And then we increment his y by delta y times delta time.

826
00:43:50,634 --> 00:43:52,800
所以它的效果就是当他在空中时
And so it'll have the effect of when he's in the air

827
00:43:52,800 --> 00:43:57,950
他的速度是负的 实际上
and he's got a negative velocity, it'll actually

828
00:43:57,950 --> 00:44:00,530
开始变得越来越积极 直到它变得积极 
start becoming positive and positive until it is positive,

829
00:44:00,530 --> 00:44:03,350
然后他倒在地上 
and then he falls back to the ground.

830
00:44:03,350 --> 00:44:05,810
然后是我之前提到的黑客攻击--
And then the hack that I was referring to earlier--

831
00:44:05,810 --> 00:44:10,490
因为我们还没有在这个例子中实现碰撞检测--
since we don't have collision detection implemented in this example yet--

832
00:44:10,490 --> 00:44:13,310
我们只是想看看他有没有
is we're just basically checking to see whether he has

833
00:44:13,310 --> 00:44:17,180
低于我们设定的地图底线 
gone below what we set the map's floor.

834
00:44:17,180 --> 00:44:22,280
如果他有 那么首先把他的位置设定在那块瓷砖的上方
And if he has, then set his position, first of all, to be above that tile

835
00:44:22,280 --> 00:44:23,780
这里是133线 
here on line 133.

836
00:44:23,780 --> 00:44:25,722
然后将他的增量y设为0 
And then set his delta y equal to 0.

837
00:44:25,722 --> 00:44:27,680
这将允许我们再次进入太空 
And that will allow us then to hit space again,

838
00:44:27,680 --> 00:44:29,462
因为他的增量y等于0 
because his delta y will be equal to 0.

839
00:44:29,462 --> 00:44:32,696
观众：所以我没有在上面看到[INAUDIBLE] 
AUDIENCE: So I didn't see [INAUDIBLE] on it.

840
00:44:32,696 --> 00:44:34,550
那么 看起来总是有重力存在 
Looks like there's always gravity, then.

841
00:44:34,550 --> 00:44:35,810
科尔顿·奥格登：总会有重力 某种东西
COLTON OGDEN: There is always gravity, something

842
00:44:35,810 --> 00:44:37,570
我在演讲前不久意识到 
I realized shortly before lecture.

843
00:44:37,570 --> 00:44:44,540
但我认为 你真正需要做的就是 如果角色死了--
But all you would really have to do is, I think, if character dy--

844
00:44:44,540 --> 00:44:45,230
嗯 
Yeah.

845
00:44:45,230 --> 00:44:48,271
您可以很容易地将其提取出来--只需围绕它添加一条if语句 
You could easily take that out of there-- just an if statement around it.

846
00:44:48,271 --> 00:44:50,272
观众：这只是浪费资源 对吗？
AUDIENCE: It's just a waste of resources, right?

847
00:44:50,272 --> 00:44:51,104
科尔顿·奥格登：是的 
COLTON OGDEN: It is.

848
00:44:51,104 --> 00:44:53,300
我是说 这并不贵 因为你所做的
I mean, it's not expensive, because all you're doing

849
00:44:53,300 --> 00:44:57,075
是将变量递增一定的量 
is incrementing a variable by a certain amount.

850
00:44:57,075 --> 00:44:59,700
如果说有什么不同的话 那就是如果你每一帧都要引入一个IF条件 
If anything, if you're introducing an if condition every frame,

851
00:44:59,700 --> 00:45:01,910
即使不是更多 也可能是相同的 
which is probably the same if not actually more.

852
00:45:01,910 --> 00:45:06,030
我认为分支更像是CPU 而不仅仅是一个赋值 
I think a branch is more CPU than just an assignment.

853
00:45:06,030 --> 00:45:09,004
对于这一点 我不是完全确定 
I'm not entirely sure about that.

854
00:45:09,004 --> 00:45:09,940
观众：很有趣 
AUDIENCE: Interesting.

855
00:45:09,940 --> 00:45:10,731
科尔顿·奥格登：是的 
COLTON OGDEN: Yeah.

856
00:45:10,731 --> 00:45:13,860
在这种情况下 它实际上没有任何副作用 
In this case, it doesn't really have any side effects.

857
00:45:13,860 --> 00:45:16,410
但值得注意的是 这是一件好事 
But it's a good thing to notice.

858
00:45:16,410 --> 00:45:20,265
但现在请注意 我们可以沿着这里的地板走 
But now notice that we can just sort of walk along the floor here,

859
00:45:20,265 --> 00:45:21,890
因为没有碰撞检测 
because there's no collision detection.

860
00:45:21,890 --> 00:45:27,320
我们将很快讨论如何实现冲突检测 
We'll talk about how we implement a collision detection soon.

861
00:45:27,320 --> 00:45:31,430
所以我们要开始讨论的一件事--我们会好好休息一下
So one thing that we'll start talking on-- and we'll take a break fairly

862
00:45:31,430 --> 00:45:32,660
很快--
soon--

863
00:45:32,660 --> 00:45:34,250
是程序级生成 
is procedural level generation.

864
00:45:34,250 --> 00:45:36,350
所以我是程序级生成的铁杆粉丝 
So I am a big fan of procedural level generation,

865
00:45:36,350 --> 00:45:39,470
而平台级别实际上相当容易--
and platformer levels are actually fairly easy--

866
00:45:39,470 --> 00:45:40,790
至少在简单的意义上--
at least in a simple sense--

867
00:45:40,790 --> 00:45:43,170
在程序上产生 
to procedurally generate.

868
00:45:43,170 --> 00:45:47,060
所以就像第三场比赛一样 我们基本上
And so like with match three, all we basically

869
00:45:47,060 --> 00:45:48,890
只是在我们的网格中循环 然后
did was just loop through our grid and just

870
00:45:48,890 --> 00:45:52,580
比方说 哦 得到一个随机的颜色和一个随机的变化 
say, oh, get a random color and a random variety.

871
00:45:52,580 --> 00:45:56,306
然后在任务中 事情变得有点复杂 
And then with the assignment, it was a little bit more complicated,

872
00:45:56,306 --> 00:45:59,180
在那里 你必须检查你是否处于第一级 
where you actually had to check to see whether you were on level one.

873
00:45:59,180 --> 00:46:01,040
如果你不是 那么你的品种
And then if you weren't, then your variety

874
00:46:01,040 --> 00:46:05,422
应该是一定的数量 这取决于你已经走了多远
should be maybe a certain amount depending on how far along you've

875
00:46:05,422 --> 00:46:06,380
在比赛中取得了进步 
progressed in the game.

876
00:46:09,710 --> 00:46:13,970
有了平台级别 我们必须考虑
With a platformer level, we have to think

877
00:46:13,970 --> 00:46:21,800
关于我们如何利用磁贴ID的网格 并从数学上考虑它 
about how we can take that grid of tile IDs and think about it mathematically.

878
00:46:21,800 --> 00:46:26,870
我们如何才能得到一个级别的结果 但每次都让它不同--
How can we get the results of a level, but make it different every time--

879
00:46:26,870 --> 00:46:30,110
引入一些变种 对吗？
introduce some variation, right?

880
00:46:30,110 --> 00:46:33,710
所以我找到的解决方案是最有意义的
And so the solution that I found that makes the most sense

881
00:46:33,710 --> 00:46:37,500
是一列接一列地进行 
is going column by column.

882
00:46:37,500 --> 00:46:41,880
所以在这里 我们只有一堆--这只是
So here, we just have a bunch of-- this is just

883
00:46:41,880 --> 00:46:45,680
一个非常简单的完美屏幕截图来说明一个非常简单的方式
a very simple perfect screenshot to illustrate a very simple way

884
00:46:45,680 --> 00:46:47,030
生成标高的能力 
of generating the level.

885
00:46:47,030 --> 00:46:53,180
但请记住 如果我们只考虑这些瓷砖--这些空白空间--
But recall, if we just think about these tiles here-- these empty spaces--

886
00:46:53,180 --> 00:46:59,720
作为0 而这些是1 在这种情况下 它几乎是二进制的 
being a 0 and these being a 1, it's sort of almost like binary in this case.

887
00:46:59,720 --> 00:47:05,630
我们可以先用0填充整个空间 只需假定为空 
We could just fill the entire thing with 0 first, just assume empty space.

888
00:47:05,630 --> 00:47:10,040
然后我们可以一列一列地往下走 只有一个机会
And then we could just column by column go down and just have a chance

889
00:47:10,040 --> 00:47:10,730
每一列 
every column.

890
00:47:10,730 --> 00:47:12,740
好的 我要在这里建一个地面吗？
OK, do I want to generate a ground here?

891
00:47:12,740 --> 00:47:15,830
如果我这样做了 从底层开始 然后
If I do, start at the ground level and then just

892
00:47:15,830 --> 00:47:18,470
一直向下生成土砖 
generate earth tiles all the way down.

893
00:47:18,470 --> 00:47:22,850
然后转到下一个x位置 做同样的事情 做同样的事情 
And then go to the next x position, do the same thing, do the same thing.

894
00:47:22,850 --> 00:47:26,420
然后 也许你产生的世界上的每一列 
And then maybe every column of the world that you're generating,

895
00:47:26,420 --> 00:47:29,540
你也有机会产生这样的支柱 
you also have a chance to generate a pillar like this.

896
00:47:29,540 --> 00:47:35,300
因此 如果生成支柱是真的 那么我想要产生--
So if generate pillar is true, then I want to spawn--

897
00:47:35,300 --> 00:47:38,720
我想从这里开始 而不是从这里开始 
instead of starting the ground here, I want to start it here.

898
00:47:38,720 --> 00:47:41,020
然后你可能会有一面旗子上写着 
And then maybe you have a flag that says,

899
00:47:41,020 --> 00:47:43,140
好的 我不仅想要产生柱子 
OK, not only do I want to generate pillars,

900
00:47:43,140 --> 00:47:45,590
我还想生成裂缝--
I also want to generate chasms--

901
00:47:45,590 --> 00:47:47,874
只有空旷的空间 对球员来说是障碍 
just empty space, obstacles for the player.

902
00:47:47,874 --> 00:47:50,290
因为如果他掉下来--掉到世界空间之下--
Because if he falls down-- it goes below the world space--

903
00:47:50,290 --> 00:47:51,870
游戏就该结束了
it should be game over.

904
00:47:51,870 --> 00:47:55,400
那么这样的话 你就说如果产生鸿沟--
So in that case, you just say if generate chasm--

905
00:47:55,400 --> 00:47:59,270
做数学 随机10或其他什么--
make math.random 10 or whatever it is--

906
00:47:59,270 --> 00:48:01,160
那就去下一个x
then just go to the next x.

907
00:48:01,160 --> 00:48:02,340
什么都别做
Don't even do anything.

908
00:48:02,340 --> 00:48:04,670
这将产生一个鸿沟的结果 
And that will have the result of generating a chasm.

909
00:48:04,670 --> 00:48:07,250
一点点地
And so little piece by piece--

910
00:48:07,250 --> 00:48:10,010
做这样的小事
doing small things like that has the net effect

911
00:48:10,010 --> 00:48:14,810
产生了很多视觉上有趣的 动态的 
of generating a lot of visually interesting, dynamic,

912
00:48:14,810 --> 00:48:15,691
和随机水平 
and random levels.

913
00:48:15,691 --> 00:48:16,940
你永远不知道会发生什么 
You never know what to expect.

914
00:48:16,940 --> 00:48:19,290
这是一个非常基本的例子 
And this is a very basic example.

915
00:48:19,290 --> 00:48:21,780
你可以用它无限远 
You could go infinitely far with it.

916
00:48:21,780 --> 00:48:25,520
不管你有多少关于如何
However many ideas you have in terms of how

917
00:48:25,520 --> 00:48:28,610
为玩家创造障碍、有趣的关卡和风景--
to create obstacles and interesting levels and scenery for the player--

918
00:48:28,610 --> 00:48:30,758
你完全可以实现它 
you could absolutely implement that.

919
00:48:30,758 --> 00:48:35,159
观众：如果有一个平台可以跳上去 你怎么处理？
AUDIENCE: How do you handle if there's a platform to jump on?

920
00:48:35,159 --> 00:48:37,239
你必须有这种一致性 
You have to have that consistency.

921
00:48:37,239 --> 00:48:38,030
是的 
COLTON OGDEN: Yeah.

922
00:48:38,030 --> 00:48:41,750
所以如果它是一个平台 这取决于你想如何实现平台 
So if it's a platform, it depends on how you want to implement platforms.

923
00:48:45,090 --> 00:48:47,870
实际上 我参加了一个关于超级马里奥兄弟的研讨会 
And actually, I did a seminar on Super Mario Bros.,

924
00:48:47,870 --> 00:48:50,840
我们把平台做成瓷砖 
and we did platforms as tiles.

925
00:48:50,840 --> 00:48:53,980
在这种情况下 我们将有块 实际上是
In this case, we'll have blocks that are actually

926
00:48:53,980 --> 00:48:55,940
我们称之为游戏对象--
what we've denoted as game objects-- which

927
00:48:55,940 --> 00:48:58,010
和瓷砖有点不同
are a little bit different than tiles.

928
00:48:58,010 --> 00:49:00,950
因为它们可以有任意的大小 而且它们不一定
Because they can have arbitrary sizes, and they don't necessarily

929
00:49:00,950 --> 00:49:02,990
都必须连接到世界电网上
have to be affixed to the world grid.

930
00:49:02,990 --> 00:49:08,960
但是如果你要把一个平台 比如说 
But if you were to treat a platform that was, let's say,

931
00:49:08,960 --> 00:49:14,630
两块瓷砖那么宽 你要做的就是
two tiles wide as tiles, all you would do

932
00:49:14,630 --> 00:49:19,250
基本上就是在这里有一个标志 就像 生成平台
is just basically have a flag up here that's like, generate platform

933
00:49:19,250 --> 00:49:20,987
等于真或者别的什么
equals true or whatever--

934
00:49:20,987 --> 00:49:22,570
观众：然后关掉它 
AUDIENCE: And then turn it off after--

935
00:49:22,570 --> 00:49:24,170
科尔顿·奥格登：不管迭代多少次 都要把它关掉 
COLTON OGDEN: Turn it off after however many iterations.

936
00:49:24,170 --> 00:49:25,610
你也需要它的大小 
You also need the size of it.

937
00:49:25,610 --> 00:49:29,834
你需要一面旗子 就像平台宽度等于多少 
You'll need a flag that's like platform width equals however many,

938
00:49:29,834 --> 00:49:31,250
所以你只需要保留一个计数器
and so you'll just keep a counter.

939
00:49:31,250 --> 00:49:35,960
就像当前平台瓦片等于1 2 3 
It's like current platform tile equals 1, 2, 3.

940
00:49:35,960 --> 00:49:39,260
如果它等于width 那么你就不会再生成它了 
And if it's equal to width, then you don't generate it any more.

941
00:49:39,260 --> 00:49:43,560
这就有可能与柱子相撞
And that has the effect of potentially colliding with pillars

942
00:49:43,560 --> 00:49:44,810
如果你不考虑这个的话
if you don't account for that.

943
00:49:44,810 --> 00:49:49,760
所以你也可以在你的逻辑中说 如果我现在正在生成一个平台 
So you can also in your logic say, if I'm generating a platform right now,

944
00:49:49,760 --> 00:49:50,930
不要产生柱子 
don't generate a pillar.

945
00:49:50,930 --> 00:49:52,971
但你可能会产生一个裂缝 因为这个裂缝
But you could generate a chasm, because the chasm

946
00:49:52,971 --> 00:49:56,330
不会干扰您的平台 
doesn't interfere with your platform.

947
00:50:01,160 --> 00:50:04,170
如果你没有平台作为瓷砖--如果它们是不同的物体--
If you don't have platforms as tiles-- if they're different objects--

948
00:50:04,170 --> 00:50:07,370
那么 您就不必在实际的世界生成阶段这样做了 
then you don't have to do it during the actual world generation phase.

949
00:50:07,370 --> 00:50:08,660
你可以直接测试一下 
You can just test.

950
00:50:08,660 --> 00:50:12,020
你可以只创建一个游戏对象 这是一个平台 
You can just create a game object that's a platform.

951
00:50:12,020 --> 00:50:14,417
取决于你的算法有多复杂 
Depending on how complicated your algorithm is,

952
00:50:14,417 --> 00:50:17,250
也许当你生成它的时候 要确保它不在柱子旁边 
maybe make sure that it's not next to a pillar when you generate it.

953
00:50:17,250 --> 00:50:20,900
你可以把瓷砖放在这里 然后看一看
And you could just do that by getting the tile here and then looking

954
00:50:20,900 --> 00:50:22,640
在接下来的四块瓷砖上--
at the next four tiles--

955
00:50:22,640 --> 00:50:23,810
差不多就是这样 
something like that.

956
00:50:23,810 --> 00:50:29,690
在本例中 我们不使用平台 但它是
We don't do platforms in this example, but it's something

957
00:50:29,690 --> 00:50:31,910
你可以很容易地用瓷砖做到这一点 
that you could pretty easily do with tiles.

958
00:50:31,910 --> 00:50:36,470
虽然难度稍大 但仍相当容易
And slightly more difficult but also still fairly easy to

959
00:50:36,470 --> 00:50:40,460
处理游戏对象 它包含在发行版中
do with game objects, which is included in the distro

960
00:50:40,460 --> 00:50:42,680
我们稍后会谈到这一点 
and which we'll touch on in a little bit.

961
00:50:45,802 --> 00:50:49,450
让我们看看 我们在一个水平上--
Let's see, we're at level--

962
00:50:49,450 --> 00:50:51,950
哦 在我们开始之前我还有几件事想展示
oh, another couple of things that I wanted to show before we

963
00:50:51,950 --> 00:50:55,730
实际上 开始学习如何生成关卡的代码 
actually start getting into the code for how to generate levels.

964
00:50:55,730 --> 00:51:00,275
这是整个项目的精灵工作表 这是一个非常酷的精灵
This is the sprite sheet for this whole project, which is a really cool sprite

965
00:51:00,275 --> 00:51:02,460
我在网上找到的一张纸 
sheet that I found online.

966
00:51:02,460 --> 00:51:04,944
这是在马里奥这样的平台上的精神 
It's in the spirit of platformers like Mario,

967
00:51:04,944 --> 00:51:07,110
它的右边有一个很好的小模型 
and it's got a nice little mockup here on the right.

968
00:51:07,110 --> 00:51:08,930
所以我鼓励你们看看这一点
So I encourage you to take a look at that

969
00:51:08,930 --> 00:51:12,530
也许会得到一些灵感 看看所有不同的酷东西 
and just maybe get some inspiration and see all the different cool stuff.

970
00:51:12,530 --> 00:51:14,896
如果你想的话 可以随便修修补补 
Tinker around with it if you want to.

971
00:51:14,896 --> 00:51:17,770
但正如你在这里看到的 有几个非常突出的事情 
But as you can see here, there's a couple of pretty prominent things.

972
00:51:17,770 --> 00:51:19,580
我们有一吨的瓷砖 
We have a ton of tiles.

973
00:51:19,580 --> 00:51:20,830
这些都是瓷砖--
These are all tiles here--

974
00:51:20,830 --> 00:51:22,720
不同的瓷砖和变体 
different tiles and variations.

975
00:51:22,720 --> 00:51:25,240
然后我们这里有一大堆这样的浇头 
And then we have a ton of these toppers here.

976
00:51:25,240 --> 00:51:32,500
所以真正帮助整个演示的是
And so what really helps this whole demonstration

977
00:51:32,500 --> 00:51:35,140
产生这些能级的一个事实是 我们有
of generating these levels is the fact that we have

978
00:51:35,140 --> 00:51:37,750
要处理的视觉内容太多了 
so much visual content to work with.

979
00:51:37,750 --> 00:51:40,930
这里 再一次 是瓷砖 
And so here, again, are the tiles.

980
00:51:40,930 --> 00:51:42,130
这是上等菜 
Here are the toppers.

981
00:51:42,130 --> 00:51:46,360
然后当你把这两者放在一起 然后你也
And then when you take the two together and then you also

982
00:51:46,360 --> 00:51:49,840
有这些随机的背景--
have these random backgrounds--

983
00:51:49,840 --> 00:51:52,300
这些是顶层 这里是瓷砖的顶层 
these are toppers here, the top of the tiles here.

984
00:51:52,300 --> 00:51:57,340
仅仅拥有丰富的视觉多样性是令人难以置信的容易
It's incredibly easy to just have a sheer abundance of visual variety

985
00:51:57,340 --> 00:52:00,240
和有趣的东西 在你的游戏水平 甚至没有--
and interesting things in your game levels without even--

986
00:52:00,240 --> 00:52:02,230
这里的算法非常简单 
and the algorithms here are very simple.

987
00:52:02,230 --> 00:52:06,160
我们所做的只是检查以生成柱子和柱子 
All we're doing is just checking to generate pillars and columns.

988
00:52:06,160 --> 00:52:07,420
我知道呀 
I know.

989
00:52:07,420 --> 00:52:13,060
我认为这真的很酷 有助于说明
I thought it was really cool and helps illustrate the importance and power

990
00:52:13,060 --> 00:52:15,934
整个程序性的方法来为这个创造层次 
of this whole procedural approach to creating the levels for this.

991
00:52:15,934 --> 00:52:18,850
我认为 实际上并没有那么多的游戏可以利用这一点 
And there's actually not that many games that take advantage, I think,

992
00:52:18,850 --> 00:52:21,720
在平台类型中的程序级生成 
of procedural level generation in the platformer genre.

993
00:52:21,720 --> 00:52:24,184
很多游戏 比如《我的世界》和《Terraria》--
Plenty of games like Minecraft and Terraria--

994
00:52:24,184 --> 00:52:26,600
Terraria就是一个很好的平台 这就是一个例子 
Terraria is a great platformer that is an example of that.

995
00:52:26,600 --> 00:52:29,342
但我不认为我见过真正好的超级马里奥兄弟 
But I don't think I've seen a really good Super Mario Bros.

996
00:52:29,342 --> 00:52:30,800
这样做的游戏 
game that does something like that.

997
00:52:33,620 --> 00:52:34,120
让我们看看 
Let's see.

998
00:52:34,120 --> 00:52:34,580
现在几点？
What time is it?

999
00:52:34,580 --> 00:52:35,230
6：23 
6:23.

1000
00:52:35,230 --> 00:52:37,210
让我们休息五分钟 
Let's take a five minute.

1001
00:52:37,210 --> 00:52:39,100
然后我们一从那里回来 
And then as soon as we get back from that,

1002
00:52:39,100 --> 00:52:43,150
我们将开始研究如何真正实现程序级
we'll start going into how we actually can implement the procedural level

1003
00:52:43,150 --> 00:52:45,440
更详细的生成 
generation in more detail.

1004
00:52:45,440 --> 00:52:46,920
好了 欢迎回来 
All right, welcome back.

1005
00:52:46,920 --> 00:52:47,890
这是第四课 
This is lecture four.

1006
00:52:47,890 --> 00:52:49,681
在我们休息之前 我们聊了聊
And before we took a break, we were talking

1007
00:52:49,681 --> 00:52:54,040
关于平台级别上下文中的程序级别生成 
about procedural level generation in the context of platformer levels.

1008
00:52:54,040 --> 00:53:00,940
回想一下 这里只有几个例子 我很快就用了我的代码 
So recall, here are just a few examples that I took pretty quickly of my code.

1009
00:53:00,940 --> 00:53:04,450
你可以看到它们有不同的背景 不同的瓷砖 
And you can see they have different backgrounds, different tiles.

1010
00:53:04,450 --> 00:53:07,420
有时我们有裂缝 有时我们有支柱 
Sometimes we have chasms, sometimes we have pillars.

1011
00:53:07,420 --> 00:53:12,610
我们将讨论几种方法来实现这一点 
We'll be talking about a few ways to do the tile version of that,

1012
00:53:12,610 --> 00:53:14,120
因为这里有两个层次 
because there's two levels here.

1013
00:53:14,120 --> 00:53:18,620
例如 在发行版中 我们会看到也有灌木丛之类的东西 
In the distro, we'll see there are also things like bushes, for example.

1014
00:53:18,620 --> 00:53:21,460
我们可以在中间上方看到紫色的--
We can see in the top middle there the purple--

1015
00:53:21,460 --> 00:53:24,280
我猜那些紫色的小仙人掌 
well, I guess those little purple cacti.

1016
00:53:24,280 --> 00:53:28,960
而在它的正下方 有一根柱子 上面有一根黄色的蕨类植物 
And the one right below that, there is a pillar with a yellow fern on it.

1017
00:53:28,960 --> 00:53:31,780
这些是与瓷砖分开的物体--
Those are separate objects from the tiles--

1018
00:53:31,780 --> 00:53:32,860
游戏对象 
game objects.

1019
00:53:32,860 --> 00:53:38,170
但实际的瓷砖本身 我们将在这里稍微挖掘一下如何
But the actual tiles themselves we'll dig in here a little bit as to how

1020
00:53:38,170 --> 00:53:39,710
才能让它们产生 
to get those generated.

1021
00:53:39,710 --> 00:53:44,615
所以我们首先要看的是水平0 只是一些平坦的水平--所以
So the first thing we want to look at, level0, is just some flat levels-- so

1022
00:53:44,615 --> 00:53:46,240
基本上就是我们已经做过的 
just basically what we've already done.

1023
00:53:46,240 --> 00:53:50,980
所以我要继续 进入0级 
So I'm going to go ahead and go into level0.

1024
00:53:54,230 --> 00:53:59,680
然后如果我们看到这里 我们有一个简单的平坦的水平 
And then if we see here, we have a simple flat level,

1025
00:53:59,680 --> 00:54:01,040
就像我们以前做的那样 
just like we did before.

1026
00:54:01,040 --> 00:54:02,690
现在瓷砖不同了 
Now the tiles are different.

1027
00:54:02,690 --> 00:54:07,360
如果我按R键 它们每次都会随机生成 
And if I press R, they're randomly generating every time.

1028
00:54:07,360 --> 00:54:12,782
所以你可以感受到这一代人在视觉上看起来有多多样化 
So you can get a sense of just how visually diverse this generation looks.

1029
00:54:12,782 --> 00:54:14,740
哦 我想这可能是之前的一个漏洞 
Oh, I think that might have been a bug earlier.

1030
00:54:14,740 --> 00:54:16,090
我没有把握 
I'm not sure.

1031
00:54:16,090 --> 00:54:17,440
我还没看过呢 
Haven't seen that yet.

1032
00:54:17,440 --> 00:54:19,480
但我们可以在这里看到 我在按R键 
But we can see here, I'm pressing R.

1033
00:54:19,480 --> 00:54:26,020
我要做的就是把我们拥有的瓷砖阵列 
All I'm doing is taking the array of tiles that we have,

1034
00:54:26,020 --> 00:54:30,430
我给它分配了一套瓷砖和一套顶层
and I'm assigning it a tile set and a topper set

1035
00:54:30,430 --> 00:54:35,830
在这一代的范围的情况下 
in the case of the scope of this generation.

1036
00:54:35,830 --> 00:54:39,460
回想一下 顶层只是顶层的精灵 
So recall that the topper is just the top layer sprite,

1037
00:54:39,460 --> 00:54:46,180
瓷砖就是下面的瓷砖 
and the tile set is the tiles underneath.

1038
00:54:46,180 --> 00:54:51,100
有没有人想建议我是如何渲染顶层和瓷砖的
Anybody want to just suggest how I'm rendering the topper versus the tiles

1039
00:54:51,100 --> 00:54:53,856
那里发生了什么事？
and what's going on there?

1040
00:54:53,856 --> 00:54:58,100
观众：你只是把它从床单的一部分拉出来 对吗？
AUDIENCE: You're just pulling it from part of the sheet, right?

1041
00:54:58,100 --> 00:54:58,850
科尔顿·奥格登：是的 
COLTON OGDEN: Yes.

1042
00:54:58,850 --> 00:55:01,282
是的 简而言之 我只是在拉开盖子
Yeah, in a nutshell, I'm just pulling the toppers

1043
00:55:01,282 --> 00:55:02,740
从床单的不同部分 
from a different part of the sheet.

1044
00:55:02,740 --> 00:55:05,510
你知道我是如何存储信息的吗--这里存储了什么
Any idea how I'm storing information-- what's being stored here

1045
00:55:05,510 --> 00:55:08,195
才能让它像这样渲染？
to get it to render like this?

1046
00:55:08,195 --> 00:55:12,155
观众：也许你只需要把陀螺的位置储存起来
AUDIENCE: Maybe you just need to store the position of the topper

1047
00:55:12,155 --> 00:55:15,620
并知道其他一切都低于这一点 
and know that everything else is below that.

1048
00:55:15,620 --> 00:55:16,460
科尔顿·奥格登：是的 
COLTON OGDEN: Yes.

1049
00:55:16,460 --> 00:55:18,410
这样你就可以存储顶部的位置
So you could store the position of the topper

1050
00:55:18,410 --> 00:55:21,200
并知道其他一切都低于这一点 
and know that everything else is below that.

1051
00:55:21,200 --> 00:55:24,360
这将适用于平坦的水平 
That would work for a flat level.

1052
00:55:24,360 --> 00:55:27,502
我认为对于有柱子的楼层来说 这是不可靠的 
I don't think that would be reliable for a level that has pillars on it,

1053
00:55:27,502 --> 00:55:29,960
因为柱子的高度比地面高 
because the pillars are a higher elevation than the ground.

1054
00:55:29,960 --> 00:55:32,001
然后还有裂缝之类的东西 
And then there's also chasms and stuff like that.

1055
00:55:35,090 --> 00:55:37,115
所以实际上这里发生的事情是我们
So what's going on here actually is we're

1056
00:55:37,115 --> 00:55:41,850
在瓷砖上存储一面旗帜 说明上面是否有顶层 
storing a flag in the tile that says whether or not it has a topper on it.

1057
00:55:41,850 --> 00:55:45,320
如果它有顶部 那么我们不仅渲染瓷砖 
And if it has a topper, then we render not only the tile,

1058
00:55:45,320 --> 00:55:49,580
但一旦我们渲染了瓷砖 我们也渲染了顶部 
but as soon as we render the tile, we also render the topper.

1059
00:55:49,580 --> 00:55:54,650
在这里 我不会深入到代码中 
And I won't go too deep into the code here.

1060
00:55:54,650 --> 00:55:58,640
但我们正在做的是让所有这些不同的瓷砖集和顶层集
But what we're doing to get all these different tile sets and topper sets

1061
00:55:58,640 --> 00:56:04,570
还有就是我们必须把所有这些瓷砖--这些瓷砖的集合--
too is we have to take all of these tile sets-- these collections of tiles--

1062
00:56:04,570 --> 00:56:06,050
然后把它们分了 对吗？
and divide them up, right?

1063
00:56:06,050 --> 00:56:09,390
我们必须知道 如果我们想要以瓷砖呈现整个关卡
We have to know that if we want to render the entire level in tile

1064
00:56:09,390 --> 00:56:15,450
设置一个 那么我们基本上应该把这个放到它自己的工作表上--
set one, then we should basically take this into its own sheet--

1065
00:56:15,450 --> 00:56:19,190
它自己的表--这个放到自己的表里 这个放到自己的表里 
its own table-- this into its own table, this into its own table, going

1066
00:56:19,190 --> 00:56:21,560
实际上是从左到右 
left to right actually.

1067
00:56:21,560 --> 00:56:26,370
我们基本上有四路嵌套循环 
And we have basically four way nested loop.

1068
00:56:26,370 --> 00:56:31,460
所以我们用x上的每一组来计算y上的每一组 
So we go every set on the x by every set on the y.

1069
00:56:31,460 --> 00:56:36,380
然后在其中的每一个中 我们要查找沿x的每一块瓷砖
And then within each of those, we want to look for every tile along the x

1070
00:56:36,380 --> 00:56:40,070
和沿y方向的每一块瓷砖 并分开
and every tile along the y therein and split up

1071
00:56:40,070 --> 00:56:45,020
瓷砖设置 这样我们就可以索引到单独的四边形 
the tile sets so that we can index into the individual quads.

1072
00:56:45,020 --> 00:56:49,430
所以在实际的代码中 我不会在这里深入研究它 
So in the actual code, I won't go too deeply into it here.

1073
00:56:49,430 --> 00:56:53,330
但如果你对我们是如何做到这一点感兴趣的 我可以带你去看看 
But I'll show you where it is if you're curious to look into how we do that.

1074
00:56:53,330 --> 00:56:58,790
它在源代码中的马里奥 util.lua 这是我们以前回忆起的地方
It's in Mario in Source, util.lua, which is recall where we before

1075
00:56:58,790 --> 00:57:02,930
存储了我们的GenerateQuads函数 该函数对切片执行简单的拆分
stored our generateQuads function, which does a simple split on a tile

1076
00:57:02,930 --> 00:57:08,420
根据传入的宽度和高度沿其x和y方向放置工作表 
sheet along its x and y based on whatever width and height you pass in.

1077
00:57:08,420 --> 00:57:14,210
这里还有一个GenerateTileSets函数 它接受四元组
We have in here also a generateTileSets function, which takes in the quads

1078
00:57:14,210 --> 00:57:16,790
来自GenerateQuads表的 
from a generateQuads table.

1079
00:57:16,790 --> 00:57:22,520
因此 我们首先在所有这些或所有这些上生成四元组 
So we first generate quads on all of this or all of this.

1080
00:57:22,520 --> 00:57:26,840
所以我们把每一帧都除以16 这就是--
So we have every single frame of this divided by 16, which is--

1081
00:57:26,840 --> 00:57:28,130
我不知道那有多少 
I don't know how many that is.

1082
00:57:28,130 --> 00:57:33,990
6乘5乘10乘5 10乘4--
6 by 5 times 10 by 5, 10 by 4--

1083
00:57:33,990 --> 00:57:38,510
那么多四元 所以成千上万的四元 我想 如果不是几百的话 
that many quads, so thousands of quads, I think, if not hundreds.

1084
00:57:38,510 --> 00:57:41,930
我敢肯定这是几千个四元房 
This I'm pretty sure is thousands of quads.

1085
00:57:41,930 --> 00:57:45,890
然后我们把它取出来 然后用
And then we take that and then divide it using

1086
00:57:45,890 --> 00:57:49,790
沿x轴的集合的数目 y轴上的集合的数目 
the number of sets along the x-axis, sets on the y-axis,

1087
00:57:49,790 --> 00:57:53,480
然后每个瓷砖的大小沿x设置 沿y设置大小 
and then the size of each tile set along the x and size along the y.

1088
00:57:53,480 --> 00:57:59,801
在这里 我们基本上使用一个四向嵌套循环来划分它 
We basically divide it using a four way nested loop here.

1089
00:57:59,801 --> 00:58:01,250
我们基本上只是把它分了 
We basically just divide it up.

1090
00:58:01,250 --> 00:58:03,980
然后 不是做GenerateQuad
And then instead of doing a generateQuads

1091
00:58:03,980 --> 00:58:09,950
在整个画面中 我们只是
along the entirety of the picture, we just

1092
00:58:09,950 --> 00:58:12,830
基本上对我们得到的四元桌做一个2D切片
basically do a 2D slice of that quad table we get back

1093
00:58:12,830 --> 00:58:14,930
从第一个genateQuad调用开始 
from the first generateQuads call.

1094
00:58:14,930 --> 00:58:18,229
所以我鼓励你们看看这里 并尝试一下 
So I encourage you to look in here and experiment with that.

1095
00:58:18,229 --> 00:58:21,020
你不一定需要知道它在任务中是如何工作的 
You don't need to necessarily know how it works for the assignment.

1096
00:58:21,020 --> 00:58:25,400
但这就是我们基本上可以拿到像这样的巨型床单的方式
But that's how we can basically take a giant sheet like this

1097
00:58:25,400 --> 00:58:28,370
并轻松地将其集成到我们的代码中 
and easily integrate it into our code.

1098
00:58:28,370 --> 00:58:32,090
我们只需换入和换出任何活动磁贴
We can just swap in and out whatever active tile

1099
00:58:32,090 --> 00:58:34,520
我们想要处理的工作表 假设一切
sheet we want to work with, assuming that everything

1100
00:58:34,520 --> 00:58:38,510
像这样干净地布局 这是你或你的艺术家的一部分 
is cleanly laid out like this, which is on the part of you or your artist.

1101
00:58:38,510 --> 00:58:44,000
你要确保一切都有利于程序化的组织 
You want to make sure that everything is conducive to programmatic organization.

1102
00:58:44,000 --> 00:58:46,830
如果东西以一种非常尴尬的方式散布--
Had things been scattered around in a very awkward way--

1103
00:58:46,830 --> 00:58:50,300
也许东西是之字形的 或者有奇怪的空间或类似的东西
maybe things were zig zagged or there were weird spaces or something like

1104
00:58:50,300 --> 00:58:50,900
那个--
that--

1105
00:58:50,900 --> 00:58:53,630
我们不能做像我们在这里做的那样干净的事情
we wouldn't be able to do something as clean as what we did here

1106
00:58:53,630 --> 00:58:57,620
Util.lua中只有63减去20行代码
in util.lua with just 63 minus 20 lines of code

1107
00:58:57,620 --> 00:59:01,164
通过获取每个单独的瓷砖集 
by getting each individual tile set.

1108
00:59:01,164 --> 00:59:03,080
所以这是一个重要的考虑因素
So that's an important consideration if you're

1109
00:59:03,080 --> 00:59:06,260
考虑为您的项目创建资产
looking at creating assets for your project

1110
00:59:06,260 --> 00:59:11,601
并且您想要对您的磁贴集进行一些程序化的热交换 
and you want to do some programmatic hot swapping of your tile sets.

1111
00:59:11,601 --> 00:59:13,100
让我们确保我们是对的--
Let's make sure we're in the right--

1112
00:59:13,100 --> 00:59:15,980
我们在这里不是正确的例子 所以我们
we're not in the right example here, so we're

1113
00:59:15,980 --> 00:59:23,210
进入0层进入主干道 
going to go into level0 into main.

1114
00:59:23,210 --> 00:59:27,380
现在我们有了所有瓷砖的常量 高度是多少
And we have constants now for all of our tile sets and what the height is

1115
00:59:27,380 --> 00:59:28,865
以及它们有多少是宽到高的 
and how many they are wide by tall.

1116
00:59:32,330 --> 00:59:33,380
我们在这里做 
We do it here.

1117
00:59:33,380 --> 00:59:36,530
我们从我们的瓷砖和鞋面上拿到我们的普通四元房 
We get our regular quads from our tiles and toppers,

1118
00:59:36,530 --> 00:59:39,730
所以这些就是那块大瓷砖里的每一块瓷砖
so these are just literally every single tile within that big tile

1119
00:59:39,730 --> 00:59:40,810
把床单放在一张桌子上 
sheet put in one table.

1120
00:59:40,810 --> 00:59:42,560
然后我们就分成了几组瓷砖
And then we just divided up into tile sets

1121
00:59:42,560 --> 00:59:45,860
和topper集 在这里使用GenerateTileSets函数 
and topper sets here with generateTileSets function.

1122
00:59:45,860 --> 00:59:50,160
然后我们得到一个随机的瓦片集和一个随机的顶层集--
And then we get a random tile set and a random topper set here--

1123
00:59:50,160 --> 00:59:54,260
随机数、瓦片集的数目、顶层集的数目 
math.random, number of tile sets, number of topper sets.

1124
00:59:54,260 --> 01:00:00,480
在最下面 我们有一个GenerateLevel函数--
And then at the very bottom also, we have a generateLevel function--

1125
01:00:00,480 --> 01:00:03,846
223--它将在接下来的两个示例中构建 
223-- which is going to be built upon in the next two examples.

1126
01:00:03,846 --> 01:00:05,720
0级只是一个平坦的级别 所以实际上
Level0 is just a flat level, so it's actually

1127
01:00:05,720 --> 01:00:11,960
这就是我们之前看到的 如果y小于7 
exactly what we saw before, which was just if y is less than 7,

1128
01:00:11,960 --> 01:00:14,770
ID应等于天空或地面 
ID should be equal to sky or ground.

1129
01:00:14,770 --> 01:00:17,067
然后这一部分实际上就是我
And then this part is actually what I was

1130
01:00:17,067 --> 01:00:19,150
用最上面的词暗指之前 因为回忆起
alluding to before with the topper, because recall

1131
01:00:19,150 --> 01:00:23,690
我们需要在瓷砖中存储一面旗帜来渲染或不渲染顶部 
we need to store a flag in a tile to render a topper or not.

1132
01:00:23,690 --> 01:00:28,540
它应该是地面上最上面的瓷砖是什么 
And it should be whatever the top tile is in the level on the ground.

1133
01:00:28,540 --> 01:00:31,960
在这个非常简单的扁平物体中 我们总是可以
In this very simple flat thing, we can always

1134
01:00:31,960 --> 01:00:34,060
假设它将是相同的y能级 
assume it'll be the same y level.

1135
01:00:34,060 --> 01:00:36,580
在本例中 如果它等于7 则topper
In this case, if it's equal to 7, then topper

1136
01:00:36,580 --> 01:00:38,500
应为真 否则为假 
should be true, otherwise, false.

1137
01:00:38,500 --> 01:00:43,600
所以沿y7的每一块瓷砖的topper都等于真 
So every tile along y 7 is going to have topper equals true.

1138
01:00:43,600 --> 01:00:46,420
这一点在这里发挥了作用 
And this comes into play up here.

1139
01:00:46,420 --> 01:00:55,090
如果我们真的爱 我们就不仅仅像以前那样拥有了.ID
If we do love.graphics.draw(tilesheet), we have not only just tile.ID as we did

1140
01:00:55,090 --> 01:01:01,150
以前 但我们现在有瓷砖集索引到瓷砖集 
before, but we have tile sets indexed into tileset now.

1141
01:01:01,150 --> 01:01:03,760
请记住 tieset获得的随机值介于1
So remember, tileset got a random value between 1

1142
01:01:03,760 --> 01:01:08,930
不管我们从巨大的瓷砖上拼接出多少瓷砖
and however many tile sets we had that we spliced out of our massive tile

1143
01:01:08,930 --> 01:01:09,700
床单 
sheet.

1144
01:01:09,700 --> 01:01:14,650
现在 我们只需对其进行索引 然后再对tile.id进行索引 
Now, we just index into that, and then we index into tile.ID.

1145
01:01:14,650 --> 01:01:21,070
而tile.ID将是我们的ID 但相对于该工作表 而不是
And tile.ID will then be whatever our ID is but relative to that sheet, not

1146
01:01:21,070 --> 01:01:24,320
一下子把整个精灵都干掉了 
the whole entire sprite at once.

1147
01:01:24,320 --> 01:01:25,570
托珀也是如此 
And the same thing for topper.

1148
01:01:25,570 --> 01:01:27,700
我们有一个TOPER集合 我们索引到TOPER
We have a topper set, we index into topper

1149
01:01:27,700 --> 01:01:31,510
在我们得到的最上面的一组 然后就是
sets here at the topper set that we got, and then that's

1150
01:01:31,510 --> 01:01:38,045
在那里我们将拥有组成特定集合的瓷砖集合 
where we'll have the collection of tiles that form that particular set.

1151
01:01:38,045 --> 01:01:39,670
因此 这两者是完全分开的 
And so the two are completely separate.

1152
01:01:39,670 --> 01:01:43,150
它们可以是一个随机颜色的瓷砖和一个随机的顶层 但它是一致的 
They can be one random color tile with one random topper, but it's consistent.

1153
01:01:43,150 --> 01:01:43,660
这是全球性的 
It's global.

1154
01:01:43,660 --> 01:01:47,870
我们有一套顶层和一套瓷砖 它们在任何时候都是活动的 
We have one topper set and one tile set that are active at any one time.

1155
01:01:47,870 --> 01:01:50,560
如果我们按R键 就像我在上面做的那样 那么我们
And if we press R, which I did up here, then we

1156
01:01:50,560 --> 01:01:52,972
只需在139和140行将它们重置为随机 
just reset them to random on line 139 and 140.

1157
01:01:52,972 --> 01:01:55,930
瓦集得到一个新的随机数 TOPER集得到一个新的随机数 
Tile set gets a new random number, topper set gets a new random number.

1158
01:01:55,930 --> 01:01:58,220
它的效果是--
It has the effect of--

1159
01:01:58,220 --> 01:02:01,000
我们可以四处走动 然后生成随机集 
we can just walk around and then generate random sets.

1160
01:02:04,090 --> 01:02:04,960
太简单了 
So pretty simple.

1161
01:02:04,960 --> 01:02:07,270
再回想一下 托珀是--
And recall again, topper is--

1162
01:02:07,270 --> 01:02:12,110
因为我们脚下的瓷砖是y 7 topper等于true 
because the tile that we're standing on is y seven, topper equals true.

1163
01:02:12,110 --> 01:02:16,624
所以在这种情况下 特定的顶层总是会有一个顶层 
So in that case, that particular top layer is always going to have a topper.

1164
01:02:16,624 --> 01:02:18,790
它给了我们一个很好的视觉变化 
And it gives us a nice little bit of visual variety,

1165
01:02:18,790 --> 01:02:22,690
因为它实际上会产生很大的不同 
because it actually makes quite a bit of a difference having

1166
01:02:22,690 --> 01:02:23,944
一个加顶的和一个不加顶的 
a topper versus no topper.

1167
01:02:23,944 --> 01:02:26,110
你也可以不戴帽子 
And you can also just not have a topper and consider

1168
01:02:26,110 --> 01:02:33,250
这是一个排列的toppers倍瓷砖 像程序算法 
that a permutation of the toppers times tiles, like procedural algorithm.

1169
01:02:33,250 --> 01:02:34,150
这是平坦的水平 
That's flat levels.

1170
01:02:34,150 --> 01:02:36,740
有谁对这是怎么运作的有任何疑问吗
Does anybody have any questions as to how this works

1171
01:02:36,740 --> 01:02:38,230
或者我们在这里做的任何事
or anything that we're doing here?

1172
01:02:41,300 --> 01:02:42,780
好的.
OK.

1173
01:02:42,780 --> 01:02:46,140
所以事情有点平淡 有点无聊 
So things are a little flat, a little boring.

1174
01:02:46,140 --> 01:02:50,160
下一步我们要介绍的是
The next step will be actually introducing one of the things

1175
01:02:50,160 --> 01:02:55,110
我们可以在这里看到我们的样本水平的小集合 
that we can see here in our little collection of sample levels,

1176
01:02:55,110 --> 01:02:58,290
就像中间的这根柱子
like this pillar right here in the very middle.

1177
01:02:58,290 --> 01:03:02,670
有谁记得我们是怎么产生一个柱子的
Does anybody recall how we go about spawning a pillar as opposed

1178
01:03:02,670 --> 01:03:06,428
变成平地
to just flat land?

1179
01:03:06,428 --> 01:03:10,027
观众：对于那一栏 只是把一些更多的污垢或更多的瓷砖下来 
AUDIENCE: For that column, just put some more dirt down or more tiles down.

1180
01:03:10,027 --> 01:03:11,430
是的 
COLTON OGDEN: Yep.

1181
01:03:11,430 --> 01:03:15,880
因此 对于这一列 只是把更多的瓷砖下来 而不仅仅是地面水平 
So for that column, just put more tiles down instead of just the ground level.

1182
01:03:15,880 --> 01:03:17,530
这正是我们要做的
That's exactly what we're going to do.

1183
01:03:17,530 --> 01:03:21,840
所以我要打开一楼和主干道 
So I'm going to go ahead and open up level1 and main,

1184
01:03:21,840 --> 01:03:25,770
我也会运行这个例子 这样你们就能看到它是什么样子的 
and I'll run the example here as well just so you can see it looks like.

1185
01:03:30,100 --> 01:03:32,590
这里我们有不少 
So here we have quite a few.

1186
01:03:32,590 --> 01:03:34,340
注意我们还没有实现碰撞 
And notice we haven't implement collision,

1187
01:03:34,340 --> 01:03:35,970
所以我们还在查
so we're still walking through them.

1188
01:03:35,970 --> 01:03:38,120
但他们只是随机的 
But they're just random.

1189
01:03:38,120 --> 01:03:40,530
它们的随机数量取决于口味 真的 
Their random amount is up to taste, really.

1190
01:03:40,530 --> 01:03:43,920
在这里很常见 所以可能值得
Right here it's pretty common, so it might be worth

1191
01:03:43,920 --> 01:03:46,500
把数量降低一点
lowering the amount a little bit.

1192
01:03:46,500 --> 01:03:51,120
如果你想的话 你也可以有一面旗帜 上面写着 产卵之柱 
If you wanted to, you could also maybe have a flag that says, spawn pillar,

1193
01:03:51,120 --> 01:03:52,800
也许你想要一个支柱宽度 
and maybe you want a pillar width.

1194
01:03:52,800 --> 01:03:56,430
你可以有一个到三个瓷砖之间的任何地方 
You could have anywhere between one and three tiles.

1195
01:03:56,430 --> 01:04:02,070
如果它的宽度大于1 那么只需循环几次
And if its width is greater than 1, then just loop over a few times

1196
01:04:02,070 --> 01:04:05,970
把同一高度画几次而不是一次 
and just draw that same height a few times as opposed to just one time,

1197
01:04:05,970 --> 01:04:08,982
然后将标志设回false 
and then set the flag back to false.

1198
01:04:08,982 --> 01:04:10,440
你可以用它做很多事情 
A lot of things you can do with it.

1199
01:04:10,440 --> 01:04:12,120
而且这里有点高
And also, they're a little tall here.

1200
01:04:12,120 --> 01:04:15,214
对于主要发行版 我最终使它们变短了一点 
For the main distro, I ended up making them a little shorter.

1201
01:04:15,214 --> 01:04:17,130
但我们将在代码中看到如何做到这一点 
But we'll see how we do this in the code here.

1202
01:04:17,130 --> 01:04:23,800
它主要在我们的generateLevel函数中 
It's going to mostly be down in our generateLevel function.

1203
01:04:23,800 --> 01:04:26,340
所以我们在这里做的--继续隐藏--
So what we're doing here-- go ahead and hide that--

1204
01:04:26,340 --> 01:04:28,970
我们有一个基本的代码--
is we have basically this code here--

1205
01:04:28,970 --> 01:04:31,500
第227至236行 
line 227 to 236.

1206
01:04:31,500 --> 01:04:38,820
所以我们要做的就是用天空填满整个空间 
So all we're doing here is just filling our entire thing with just sky.

1207
01:04:38,820 --> 01:04:41,340
我们只是把它设为空 
We're just setting the entire thing to empty.

1208
01:04:41,340 --> 01:04:45,520
现在我们有一个完全填充的2D数组 
And now we have a fully populated 2D array.

1209
01:04:45,520 --> 01:04:47,520
我们要做的就是改变瓷砖--我们
All we need to do in order to change a tile-- we

1210
01:04:47,520 --> 01:04:52,530
不必担心插入或添加太多的瓷砖到我们的数组 
don't have to worry about insertions or adding too many tiles to our array.

1211
01:04:52,530 --> 01:04:56,670
我们现在所能做的就是直接改变那里存在的任何瓷砖 
All we can do now is just directly change whatever tile exists there.

1212
01:04:56,670 --> 01:05:01,380
所以我们要做的就是从239行开始 
So all we need to do is starting on line 239,

1213
01:05:01,380 --> 01:05:05,400
我们将开始在整个级别上逐列迭代
we're going to start doing the column by column iteration over our entire level

1214
01:05:05,400 --> 01:05:09,150
并决定我们是否应该建立支柱 
and deciding whether we should generate pillars or not.

1215
01:05:09,150 --> 01:05:11,960
我们总是会产生地面 
And we're always going to generate ground.

1216
01:05:11,960 --> 01:05:14,960
这是旗帜衍生柱 
So here's the flag spawnPillar.

1217
01:05:14,960 --> 01:05:18,690
如果它等于1 这基本上会被分配给spawnPillar 
And if it's equal to 1, this is going to basically be assigned to spawnPillar.

1218
01:05:18,690 --> 01:05:20,190
所以math.random（5）==1.
So math.random(5)==1.

1219
01:05:20,190 --> 01:05:24,300
我们有五分之一的机会产生一个柱子 
We have a 1 in 5 chance of spawning a pillar.

1220
01:05:24,300 --> 01:05:28,755
如果我们只需要一个柱子 那么柱子从4到6等于4--
If we just want a pillar, then pillar gets equal to 4 from 4 to 6--

1221
01:05:28,755 --> 01:05:34,470
所以y等于4到6
so y gets 4 to 6 effectively--

1222
01:05:34,470 --> 01:05:37,800
x柱上的瓷砖 ID地面 
tiles at pillar x, ID ground.

1223
01:05:37,800 --> 01:05:41,310
然后在这里我们设置顶部 回忆一下 
And then here's where we set the topper, recall,

1224
01:05:41,310 --> 01:05:47,820
因为现在柱子可以是表面上最上面的瓦片 
because now pillars can be the top most tile on the surface.

1225
01:05:47,820 --> 01:05:49,320
但它们在地面以上 
But they're above the ground level.

1226
01:05:49,320 --> 01:05:53,540
所以我们基本上就是说 当我们生成一个柱子时 
So we just basically say, when we're generating a pillar,

1227
01:05:53,540 --> 01:05:57,300
如果pillar等于4--也就是我们开始的第一个瓦片--
if pillar is equal to 4-- which is the very first tile that we start at--

1228
01:05:57,300 --> 01:05:59,190
然后在这里设置topper等于true 
then set topper equal to true here.

1229
01:05:59,190 --> 01:06:01,140
否则 将其设置为false 
Otherwise, set it to false.

1230
01:06:01,140 --> 01:06:06,601
所以这就是我们如何让柱子也有顶部 然后在这种情况下 
So that's how we can get pillars to also have toppers and then in this case,

1231
01:06:06,601 --> 01:06:08,100
我们还没有产生任何裂缝
we're not generating any chasms yet.

1232
01:06:08,100 --> 01:06:09,183
所以我们要做的就是
So all we're going to do--

1233
01:06:11,850 --> 01:06:15,030
一旦我们在那个特定的柱子上生成了一个柱子 
once we've generated a pillar on that particular column,

1234
01:06:15,030 --> 01:06:18,060
我们就说地是7直到地图的高度
we'll just say ground gets 7 until the map height--

1235
01:06:18,060 --> 01:06:21,130
因此 在屏幕的最底部 
so towards the very bottom of the screen.

1236
01:06:21,130 --> 01:06:22,720
然后我们就把它放在地面上 
And then we'll just set it to ground.

1237
01:06:22,720 --> 01:06:25,890
在这种情况下 我们要确保
And then topper-- in this case, we're going to make sure

1238
01:06:25,890 --> 01:06:27,690
我们不是在生一根柱子 
that we're not spawning a pillar.

1239
01:06:27,690 --> 01:06:29,850
因为如果我们不检查这个 它就会
Because if we don't check this, then it'll

1240
01:06:29,850 --> 01:06:35,310
在柱子与地面相接的地方也会产生一个顶端 
also spawn a topper where the pillar meets the ground,

1241
01:06:35,310 --> 01:06:36,930
这看起来会有点傻 
and it'll look a little bit silly.

1242
01:06:36,930 --> 01:06:39,500
然后我们还想检查地面是否等于7 
And then we also want to check that ground is equal to 7.

1243
01:06:39,500 --> 01:06:44,560
所以加在一起 这就产生了这种行为的影响 
And so all together, that has the effect of this behavior.

1244
01:06:44,560 --> 01:06:47,400
因此 如果我们不检查那个产卵支柱 
And so if we didn't check for that spawnPillar,

1245
01:06:47,400 --> 01:06:49,560
我们的脚下也会有一个鞋帽 
we'd have a topper right below our feet here too,

1246
01:06:49,560 --> 01:06:52,320
这看起来很奇怪 
which looks graphically strange.

1247
01:06:52,320 --> 01:06:54,240
而且 你也可以看到--
And also, you can see--

1248
01:06:54,240 --> 01:06:59,169
紧急情况下 我们得到了两倍宽的柱子 
emergently, we're getting double width pillars.

1249
01:06:59,169 --> 01:07:00,960
这只是一种天然的副产品
And that's just kind of a natural byproduct

1250
01:07:00,960 --> 01:07:02,420
很多这样的随机化 
of a lot of these randomizations.

1251
01:07:02,420 --> 01:07:05,490
很多这样的程序性算法--
A lot of these procedural algorithms--

1252
01:07:05,490 --> 01:07:08,040
他们会产生你可能不一定会产生的结果
they'll generate outcomes that you might not necessarily

1253
01:07:08,040 --> 01:07:10,500
这是一件很酷的事情 
have anticipated, which is kind of a cool thing.

1254
01:07:10,500 --> 01:07:15,180
你不必给它编程 让它有两块瓷砖宽的柱子 
You didn't necessarily program it to have pillars that were two tiles wide,

1255
01:07:15,180 --> 01:07:18,000
但这只是随机化的本质--这就是你得到的 
but just the nature of randomization-- that's just what you get.

1256
01:07:18,000 --> 01:07:20,791
这是程序级生成的另一个令人兴奋的事情
And that's another exciting thing about procedural level generation

1257
01:07:20,791 --> 01:07:25,260
它甚至可以让编写算法的人感到惊讶 
is that it can surprise even the person that wrote the algorithm.

1258
01:07:25,260 --> 01:07:30,300
这真的很酷 而且它省去了你必须创建关卡的工作 
It's really cool, and it saves you work having to create levels.

1259
01:07:30,300 --> 01:07:32,070
这就是柱子水平 
So that was pillared levels.

1260
01:07:32,070 --> 01:07:37,109
鸿沟级别--谁能告诉我我们如何才能计算出鸿沟级别？
Chasm levels-- who can tell me how we can do chasm levels?

1261
01:07:37,109 --> 01:07:40,350
观众：你只要跳过一栏即可 
AUDIENCE: You just skip a column.

1262
01:07:40,350 --> 01:07:42,590
科尔顿·奥格登：是的 
COLTON OGDEN: Yep.

1263
01:07:42,590 --> 01:07:43,550
您可以跳过一列 
you skip a column.

1264
01:07:43,550 --> 01:07:45,841
所以一开始 我们基本上只能说
So at the very beginning, all we can just basically say

1265
01:07:45,841 --> 01:07:48,020
是 我想在这里制造一个鸿沟吗？
is, do I want to generate a chasm here?

1266
01:07:48,020 --> 01:07:50,270
如果我这样做了 就跳过 
If I do, just skip.

1267
01:07:50,270 --> 01:07:53,360
转到循环的下一个迭代 
Go to the next iteration of the loop.

1268
01:07:53,360 --> 01:07:56,060
所以我们来看看这一点 
And so we'll take a look at that.

1269
01:07:56,060 --> 01:08:00,299
就这么简单 因为Lua没有继续的概念--
As simple as it is, because Lua doesn't have the notion of continue--

1270
01:08:00,299 --> 01:08:02,090
这将是一次重温 因为我相信
this will be a refresher, because I believe

1271
01:08:02,090 --> 01:08:04,850
这是在其中一个作业中--
this was in one of the assignments--

1272
01:08:04,850 --> 01:08:08,310
它有一份Goto声明 
it has a goto statement.

1273
01:08:08,310 --> 01:08:13,450
因此 基本上 代码与前面一样 逐列开始 
So basically, same code as before, starting column by column.

1274
01:08:13,450 --> 01:08:16,279
在贴图宽度之前 X等于1 
x equals one until map width.

1275
01:08:16,279 --> 01:08:17,890
我们有七分之一的机会--
We have a 1 in 7 chance--

1276
01:08:17,890 --> 01:08:20,149
太武断了 
just arbitrary.

1277
01:08:20,149 --> 01:08:22,250
理想情况下 这应该是--
And this should ideally--

1278
01:08:22,250 --> 01:08:28,529
如果您正在设计一个完整的大型游戏或应用程序 
if you're engineering an entire large game or application,

1279
01:08:28,529 --> 01:08:31,839
这可能会被称为spawn_chasm_Chance 
this would be called SPAWN_CHASM_CHANCE probably,

1280
01:08:31,839 --> 01:08:33,380
然后在某个地方将其设置为7 
and just set that to seven somewhere.

1281
01:08:33,380 --> 01:08:35,180
但我们这里只是把它设为7--
But we're just setting it to 7 here--

1282
01:08:35,180 --> 01:08:39,560
只是一个静态的幻数 但幻数通常是不好的 
just a static magic number, but magic numbers are generally bad.

1283
01:08:39,560 --> 01:08:46,460
继续--所以继续在循环的最底部
Goto continue-- and so continue is here at the very bottom of the loop

1284
01:08:46,460 --> 01:08:50,536
这就是x=1的mapWidth 
here, which is this for x = 1, mapWidth.

1285
01:08:50,536 --> 01:08:53,660
所以它会有直接跳到x等于2的效果 如果这是1 
So it will have the effect of skipping straight to x equals 2 if this at 1,

1286
01:08:53,660 --> 01:08:55,670
例如 
for example.

1287
01:08:55,670 --> 01:08:58,630
许多语言只是简单地延续了下去 
A lot of languages just simply have continue.

1288
01:08:58,630 --> 01:09:05,090
Lua没有继续 所以这是社区建立的传统
Lua does not have continue, so this is a community established tradition

1289
01:09:05,090 --> 01:09:07,729
用于在Lua中实现类似于Continue的行为 
for implementing continue-like behavior in Lua.

1290
01:09:07,729 --> 01:09:14,000
您通过双冒号创建一个标签 该标签带有一个名称 然后是一个双冒号 
You create a label via double colon with a name and then a double colon,

1291
01:09:14,000 --> 01:09:16,200
然后你就直接去找它 
and then you just goto it.

1292
01:09:16,200 --> 01:09:18,859
这就像产生裂缝一样简单 
And so that's as simple as it is for generating chasms.

1293
01:09:18,859 --> 01:09:26,800
所以 如果我们到第二级运行 我们就会得到裂缝 
And so if we go to level2 and run that, we get chasms.

1294
01:09:26,800 --> 01:09:30,359
所以现在我们有了一点有趣的视觉变化 
And so now we've got a little bit of interesting visual variety.

1295
01:09:30,359 --> 01:09:33,680
在这个例子中 它并没有产生大量的裂缝 
It's not spawning a ton of chasms in this example.

1296
01:09:33,680 --> 01:09:35,590
到目前为止 它已经产生了一个 
It spawned one so far.

1297
01:09:35,590 --> 01:09:36,470
还有一个 
There's another one.

1298
01:09:36,470 --> 01:09:38,762
有时只是紧急情况下 你可以得到两个 
And then sometimes just emergently, you can get two.

1299
01:09:38,762 --> 01:09:39,470
看 这就对了 
See, there we go.

1300
01:09:39,470 --> 01:09:41,540
结果 我们遇到了一些有趣的障碍 
We get some interesting obstacles as a result.

1301
01:09:41,540 --> 01:09:43,939
看起来就像是有人故意这么做的--
It almost looks as if someone intentionally did that--

1302
01:09:43,939 --> 01:09:45,199
差不多了 
almost.

1303
01:09:45,199 --> 01:09:47,990
我可能会 就像我说的 把柱子的尺寸缩小一点 
I would probably, like I said, shrink the pillar size a little bit.

1304
01:09:47,990 --> 01:09:48,781
它有点高 
It's a little tall.

1305
01:09:52,310 --> 01:09:52,910
就是这样 
That's that.

1306
01:09:52,910 --> 01:09:56,360
这是基本的程序--在平台的背景下 
That's basic procedural-- in the context of platformers,

1307
01:09:56,360 --> 01:09:58,970
这就是我们如何开始的心理模型
that's the mental model for how we can start

1308
01:09:58,970 --> 01:10:01,059
想着制造障碍 
thinking about generating obstacles.

1309
01:10:01,059 --> 01:10:03,350
你可以选择很多不同的方向 
And there's a lot of different directions you could go.

1310
01:10:03,350 --> 01:10:09,320
比方说 也许你想要建造金字塔 
Let's say maybe you wanted to generate pyramids.

1311
01:10:09,320 --> 01:10:10,910
我是说 这在马里奥很常见 
I mean, it's a common thing in Mario.

1312
01:10:10,910 --> 01:10:14,480
将有步骤 [INAUDIBLE]为它设置 
There will be steps, [INAUDIBLE] set for it.

1313
01:10:14,480 --> 01:10:18,457
同样的实现基本上也会在这里发生 
The same implementation would basically happen here.

1314
01:10:18,457 --> 01:10:20,540
会有一点不同 因为你是
It would be a little bit different, because you're

1315
01:10:20,540 --> 01:10:22,081
在逐列的基础上这样做 
doing it on a column by column basis.

1316
01:10:22,081 --> 01:10:24,770
但你只需要有效地保持一个引用
But you'd effectively just maintain a reference

1317
01:10:24,770 --> 01:10:27,620
到类似台阶的高度 然后你
to something like step height, and then you

1318
01:10:27,620 --> 01:10:30,216
会说生成楼梯在这里是正确的 
would say generate stairs is true here.

1319
01:10:30,216 --> 01:10:32,090
然后您只需将Step Height设置为1 
And then you would just set step height to 1.

1320
01:10:32,090 --> 01:10:34,360
然后你在这里添加一块瓷砖 
So then you add a tile here.

1321
01:10:34,360 --> 01:10:37,800
你可以从地面一直到台阶高度 生成一块瓷砖 
You would go from ground level up until step height, generate a tile,

1322
01:10:37,800 --> 01:10:40,520
转到下一步 然后将步高增加到2 
go the next one, and then increment step height to 2.

1323
01:10:40,520 --> 01:10:44,630
然后从地面开始 直到台阶的高度--
And then do from ground until step height--

1324
01:10:44,630 --> 01:10:45,620
瓷砖会往上爬 
tiles go up.

1325
01:10:45,620 --> 01:10:51,080
然后是1 然后是2和3 直到达到楼梯宽度 在这种情况下
So 1 and then 2 and 3 until you've gone to stairs width, in which case

1326
01:10:51,080 --> 01:10:52,400
您将停止生成楼梯 
you stop generating stairs.

1327
01:10:52,400 --> 01:10:56,955
这就是你如何
That's this principle behind how you could

1328
01:10:56,955 --> 01:10:58,580
做一些稍微复杂一点的事情 
do something a little more complicated.

1329
01:10:58,580 --> 01:11:00,980
或者金字塔--同样的东西 金字塔的宽度 
Or pyramids-- same exact thing, pyramid width.

1330
01:11:00,980 --> 01:11:03,890
然后你一直走到金字塔的宽度等于--
And then you just go until pyramid width equals--

1331
01:11:03,890 --> 01:11:07,430
或者我们在金字塔宽度除以2 让它向上 
or we're at pyramid width divided by 2, make it go up.

1332
01:11:07,430 --> 01:11:09,540
如果我们比它高 就让它降下来 
And if we're higher than that, make it go down.

1333
01:11:09,540 --> 01:11:12,760
然后你就会得到金字塔方法的影响 
And then you have the effect of the pyramid approach.

1334
01:11:12,760 --> 01:11:13,516
嗯 
Yeah.

1335
01:11:13,516 --> 01:11:15,265
观众：你们把栏目放在哪里？
AUDIENCE: Where are you putting the column

1336
01:11:15,265 --> 01:11:18,576
如果它是[INAUDIBLE] 则生成 
generation if it's a [INAUDIBLE].

1337
01:11:18,576 --> 01:11:20,480
它没有处于播放状态 
It's not in the play state.

1338
01:11:20,480 --> 01:11:22,550
科尔顿·奥格登：在这种情况下 一切都在主线上 卢阿 
COLTON OGDEN: In this case, it's all in main.lua.

1339
01:11:22,550 --> 01:11:25,520
但在发行版中 它将位于Level Maker.lua中 
But in the distro, it's going to be in levelmaker.lua.

1340
01:11:25,520 --> 01:11:28,400
所以我们已经突破了所有这些功能
So we've broken out all of this functionality

1341
01:11:28,400 --> 01:11:31,730
我们是如何越狱的 
into just how we did Breakout.

1342
01:11:31,730 --> 01:11:34,100
我们有同样的东西--水平制造者--
We had the same sort of thing-- level maker--

1343
01:11:34,100 --> 01:11:35,620
它只有LevMaker.Generate 
and it just has levelMaker.generate.

1344
01:11:35,620 --> 01:11:37,370
然后你给它一个宽度和高度 
And then you give it a width and a height,

1345
01:11:37,370 --> 01:11:39,621
它将为你生成一个完整的关卡 
and it will generate an entire level for you.

1346
01:11:39,621 --> 01:11:42,507
观众：整个级别 但它必须持续--
AUDIENCE: An entire level, but it has to continuously--

1347
01:11:42,507 --> 01:11:44,912
哦 你一下子把它都生成了？
oh, you generate it all at once?

1348
01:11:44,912 --> 01:11:48,244
它不会在你走路时产生吗？
It doesn't generate as you walk?

1349
01:11:48,244 --> 01:11:51,410
科尔顿·奥格登：问题是 它是持续产生的 还是一次性产生的？
COLTON OGDEN: The question is, does it generate continuously or all at once?

1350
01:11:51,410 --> 01:11:53,010
它只是一下子产生所有的东西 
It just generates all at once.

1351
01:11:53,010 --> 01:11:56,090
所以你可以实施一个--
So you could implement a--

1352
01:11:56,090 --> 01:12:01,820
如果你想成为一名无限长跑运动员 你会选择你自己
if you wanted to do an infinite runner, the way you would do that is you

1353
01:12:01,820 --> 01:12:04,450
会把你的关卡分成小块 
would break up your level into chunks.

1354
01:12:04,450 --> 01:12:07,860
而对于无限的跑步者 通常你只能朝一个方向移动 
And with infinite runners, usually you can only move in one direction.

1355
01:12:07,860 --> 01:12:10,850
所以当你向右转时 你之前产生的水平--他们得到
So as you go right, your levels that you've generated before-- they get

1356
01:12:10,850 --> 01:12:14,960
丢弃 因此您可以避免内存过度消耗 
discarded, so you avoid memory overconsumption.

1357
01:12:14,960 --> 01:12:17,270
你要做的就是生成一大块--
What you would do is you would just generate a chunk--

1358
01:12:17,270 --> 01:12:19,940
也许是100乘20级 
maybe a 100 by 20 level.

1359
01:12:19,940 --> 01:12:22,850
然后你会经历那个 经历那个 
And then you would go through that, through that.

1360
01:12:22,850 --> 01:12:28,040
然后当你到达平端时 可能减去5块或10块瓷砖 
And then when you get to level end minus maybe like five tiles or 10 tiles,

1361
01:12:28,040 --> 01:12:32,840
你会生成另一个 附加它 放在右边 
you would generate another one, append it, put it to the right,

1362
01:12:32,840 --> 01:12:36,740
然后你就可以从左边转到右边 
and then you would just go from the left to the right.

1363
01:12:36,740 --> 01:12:40,960
你可能需要一些半花哨的代码
And you probably would need some sort of semi-fancy code

1364
01:12:40,960 --> 01:12:44,350
一旦你生成了它们 就把它们拼接在一起 
to splice them together once you've generated them.

1365
01:12:44,350 --> 01:12:47,627
或者 你可以随时垫上你的--
Alternatively, you could just always pad your--

1366
01:12:47,627 --> 01:12:49,210
不 你可能不想垫垫 
no, you probably wouldn't want to pad.

1367
01:12:49,210 --> 01:12:56,560
我可能会把它们首尾相连 然后去掉x等于1100
I would probably just splice them end to end and then get rid of x equals 1 100

1368
01:12:56,560 --> 01:13:01,810
或者 一旦它超过屏幕的左边缘 就会有很多人出现在左侧 
or however many on the left once it's gone past the left edge of the screen.

1369
01:13:01,810 --> 01:13:05,050
在这种情况下 总而言之 它完全是静态的 
In this case, to summarize, it's all static.

1370
01:13:05,050 --> 01:13:06,780
但你可以很容易地--
But you could very easily--

1371
01:13:06,780 --> 01:13:11,090
这并不容易 但你完全可以让它成为一名无限的跑步者 
not easily, but you could very well make it an infinite runner.

1372
01:13:11,090 --> 01:13:11,590
嗯 
Yeah.

1373
01:13:11,590 --> 01:13:16,572
观众：所以我们渲染了整个关卡 但我们就是看不到全部？
AUDIENCE: So we're rendering the entire level, but we just can't see it all?

1374
01:13:16,572 --> 01:13:19,280
科尔顿·奥格登：问题是 我们是在渲染整个关卡吗 
COLTON OGDEN: The question is, are we rendering the entire level,

1375
01:13:19,280 --> 01:13:20,488
但我们就是看不到一切吗？
but we just can't see it all?

1376
01:13:20,488 --> 01:13:21,410
答案是肯定的 
The answer is yes.

1377
01:13:21,410 --> 01:13:24,493
目前 在这个实现中 我们只是渲染整个级别--
Currently, in this implementation, we're just rendering the entire level--

1378
01:13:24,493 --> 01:13:26,720
因此 一块一块地被吸引到屏幕上 
so tile by tile is getting drawn to the screen.

1379
01:13:26,720 --> 01:13:30,410
对于像这样的小例子来说 这不是一个问题 
For small examples like this, it's not a concern.

1380
01:13:30,410 --> 01:13:33,860
但对于较大的级别--例如 如果我们做一个Terraria级别 
But for a large level-- like if we did a Terraria level, for example.

1381
01:13:33,860 --> 01:13:38,480
兵马俑数以千计的瓷砖可能
Terraria's thousands and thousands of tiles wide by probably

1382
01:13:38,480 --> 01:13:40,340
1000或更高的瓷砖--
1,000 or more tiles tall--

1383
01:13:40,340 --> 01:13:44,630
您只想渲染一块 只渲染您可以看到的部分 
you want to render only a chunk, only what you can visibly see.

1384
01:13:44,630 --> 01:13:49,730
为此 您可以使用相机偏移量 然后只需渲染
And for that, you could use your camera offset and then just render

1385
01:13:49,730 --> 01:13:53,949
从左侧的一块瓷砖到底部边缘以下的一块瓷砖
from one tile to the left and above that to one tile below the bottom edge

1386
01:13:53,949 --> 01:13:55,490
在摄像机的右手边 
of the camera and to the right of it.

1387
01:13:55,490 --> 01:13:57,650
只需渲染该分片的子集 
Just render that subset of tiles.

1388
01:13:57,650 --> 01:14:01,250
因此 您只需要一个for循环来迭代一小段 
So you just need a for loop to iterate over a small section.

1389
01:14:01,250 --> 01:14:04,550
观众：所以你可以做一个阵列
AUDIENCE: So you can kind of make an array

1390
01:14:04,550 --> 01:14:07,034
地图会是什么样子 然后
of what the map's going to look like and then

1391
01:14:07,034 --> 01:14:11,184
只渲染数组中您可以看到的部分 
just render only slices of the array that you can see.

1392
01:14:11,184 --> 01:14:12,180
是那么回事吗？
Is that right?

1393
01:14:12,180 --> 01:14:18,654
如果您放置一个多维数组 然后您只需遍历它
If you put a multi-dimensional array and then you just go through it

1394
01:14:18,654 --> 01:14:20,542
并随时随地渲染--这就是你的想法吗？
and render as you go-- is that the thought?

1395
01:14:20,542 --> 01:14:22,250
科尔顿·奥格登：问题是 你只要
COLTON OGDEN: Question was, you just have

1396
01:14:22,250 --> 01:14:24,400
针对您的关卡的多维瓷砖阵列 
a multi-dimensional array of tiles for your level,

1397
01:14:24,400 --> 01:14:25,983
然后你只需要在你走的时候渲染它 
and then you just render it as you go.

1398
01:14:25,983 --> 01:14:27,050
答案是肯定的 
The answer is yes.

1399
01:14:27,050 --> 01:14:29,600
你会得到你的整体瓷砖--
You would have your overall tiles--

1400
01:14:29,600 --> 01:14:35,030
您的大型2D阵列 由100×20或其他数千个瓷砖组成 
your big 2D array of 100 by 20 or however many thousands of tiles.

1401
01:14:35,030 --> 01:14:38,295
然后根据您的摄像机渲染的位置 
And then based on wherever your camera is rendering,

1402
01:14:38,295 --> 01:14:41,150
它只是一个嵌套数量内for循环 
it's just a for loop within that just of a nested amount.

1403
01:14:41,150 --> 01:14:46,970
所以 也许你的玩家在x30加上6张牌 
So maybe your player is at x 30 plus 6 tiles.

1404
01:14:46,970 --> 01:14:51,350
所以你只需要渲染30块到45块
So you would just render from 30 tiles to maybe 45 tiles

1405
01:14:51,350 --> 01:14:55,040
在x上 在y上可能是10到20--
on x and maybe 10 to 20 on the y--

1406
01:14:55,040 --> 01:14:56,120
就是那一大块 
just that chunk.

1407
01:14:56,120 --> 01:14:58,100
这只是相对于你的相机的位置 
And it's just relative to where your camera is.

1408
01:14:58,100 --> 01:15:00,230
你总是只渲染一小部分--
You're always rendering just a small little--

1409
01:15:00,230 --> 01:15:02,630
基本上 在这一点上 它实际上是一个相机 
basically, it is effectively a camera at that point.

1410
01:15:02,630 --> 01:15:05,630
它正在将一大块瓷砖渲染到屏幕上 
It's rendering a chunk of the tiles to the screen.

1411
01:15:05,630 --> 01:15:07,359
听众：但在这段代码中 情况并非如此 
AUDIENCE: But in this code, it's not.

1412
01:15:07,359 --> 01:15:08,650
科尔顿·奥格登：在这段代码中 没有 
COLTON OGDEN: In this code, no.

1413
01:15:08,650 --> 01:15:10,300
这里的水平是--
The levels here are--

1414
01:15:10,300 --> 01:15:13,494
它已经足够复杂了 不能引入 
it's sufficiently complicated to introduce.

1415
01:15:13,494 --> 01:15:15,410
我的意思是 这并不是太复杂的介绍 
I mean, it's not too complicated to introduce.

1416
01:15:15,410 --> 01:15:16,520
这很容易 
It's pretty easy.

1417
01:15:16,520 --> 01:15:20,540
但消费--这里的加工--
But the consumption-- the processing here--

1418
01:15:20,540 --> 01:15:23,030
是非常轻的 因为能级相当小 
is very light, because the levels are fairly small.

1419
01:15:23,030 --> 01:15:25,430
即使我们真的有很大的水平 
And even if we did have really large levels,

1420
01:15:25,430 --> 01:15:29,550
它足够小 不必担心 
it's sufficiently small to not have to worry about it.

1421
01:15:29,550 --> 01:15:33,770
但如果我们真的达到了1000块或更多的水平 
But if we did get to a point where your levels were 1,000 tiles or more,

1422
01:15:33,770 --> 01:15:35,656
然后也许这些瓷砖有额外的 
and then maybe those tiles have additional,

1423
01:15:35,656 --> 01:15:38,030
你只是想挤出所有可能的性能
you just want to squeeze all the performance possible out

1424
01:15:38,030 --> 01:15:40,350
您的应用程序的 
of your application.

1425
01:15:40,350 --> 01:15:43,050
您可以考虑只渲染一个子集 
You could look into just rendering a subset.

1426
01:15:43,050 --> 01:15:46,340
它很容易介绍 但就是不能
It's fairly simple to introduce but just not something

1427
01:15:46,340 --> 01:15:50,420
我们在这项任务中包含了 
that we included in this assignment.

1428
01:15:50,420 --> 01:15:54,687
关于这种东西是如何工作的 还有其他问题吗？
Any other questions as to how this sort of thing works?

1429
01:15:58,115 --> 01:15:58,615
好的 
OK.

1430
01:16:01,120 --> 01:16:04,960
到目前为止 我们已经讨论了过程级生成 
So far, we've talked about procedural level generation.

1431
01:16:04,960 --> 01:16:09,250
我们已经讨论了动画和渲染之类的东西 
We've talked about animation and rendering and all that stuff.

1432
01:16:09,250 --> 01:16:12,970
我们还没有真正讨论如何做瓷砖碰撞 
We haven't really talked about how to do tile collision.

1433
01:16:12,970 --> 01:16:15,550
我们不会涉及太多的细节 
And we won't go into a terrible amount of detail,

1434
01:16:15,550 --> 01:16:17,170
因为代码有点长 
because the code is a little lengthy.

1435
01:16:17,170 --> 01:16:19,961
阅读并理解它将是你们任务的一部分 
It'll be part of your assignment to read over it and understand it,

1436
01:16:19,961 --> 01:16:24,940
但我们拥有的是TileMap类 
but it's in the TileMap class that we have.

1437
01:16:24,940 --> 01:16:29,290
基本上 整个大意是因为我们是
Basically, the whole gist is that because we're

1438
01:16:29,290 --> 01:16:34,990
在固定的2D切片数组上 它将始终为0 0 至少
on a 2D tile array that's fixed, it'll always be at 0, 0, at least

1439
01:16:34,990 --> 01:16:37,580
在我们目前实现的模型中 
in the model that we've currently implemented.

1440
01:16:37,580 --> 01:16:42,730
我们只需将坐标转换为平铺 然后
We can just convert coordinates to tiles and then

1441
01:16:42,730 --> 01:16:48,310
只要检查一下 看看瓷砖是否在任何地方
just check to see whether or not the tiles at whatever that is

1442
01:16:48,310 --> 01:16:51,220
是不是坚固的 
are solid or not.

1443
01:16:51,220 --> 01:16:57,830
在这种情况下 假设我们想要查看角色的顶部 
Let's say we wanted to look at the top of our character in this case.

1444
01:16:57,830 --> 01:17:00,970
所以如果我们有我们的角色在这里 
So if we have our character here.

1445
01:17:00,970 --> 01:17:04,240
为了说明起见 我把他放在他上方的两块瓷砖之间
For the sake of illustration, I put him between two tiles above him

1446
01:17:04,240 --> 01:17:07,750
只是为了表明我们为什么需要以我们现在的方式来做这件事 
just to show why we need to do this the way that we are doing it.

1447
01:17:07,750 --> 01:17:10,600
但你要说的是--
But you take the point here--

1448
01:17:10,600 --> 01:17:14,440
他的最左上角 所以是player.x 然后是player.y 
his very top left, so player.x and then player.y,

1449
01:17:14,440 --> 01:17:17,080
这实际上就是他们的0 0版本 
which is effectively their version of 0, 0.

1450
01:17:17,080 --> 01:17:20,610
然后是Player.x加上Player.Width减去--
And then player.x plus player.width minus--

1451
01:17:20,610 --> 01:17:27,210
对于很多碰撞 我们都是负1
we do a minus one for a lot of collisions

1452
01:17:27,210 --> 01:17:29,740
这样他就可以在街区之间走动了 
so that he can walk between blocks and stuff like that.

1453
01:17:29,740 --> 01:17:33,940
因为如果你不给他稍微少一点的钱--
Because if you don't basically give him slightly less than the amount--

1454
01:17:33,940 --> 01:17:37,080
因为他有16个像素宽 瓷砖有16个像素宽--
because he's 16 pixels wide, and the tiles are 16 pixels wide--

1455
01:17:37,080 --> 01:17:39,730
如果他在两个街区之间想摔倒 
if he's between two blocks and he wanted to fall down,

1456
01:17:39,730 --> 01:17:42,580
他只是不会倒下 因为它还在探测碰撞 
he just won't fall down, because it's still detecting a collision.

1457
01:17:45,340 --> 01:17:47,140
因为如果他在这个洞里--
Because if he's on the hole here--

1458
01:17:47,140 --> 01:17:50,500
假设这是一个洞 这些是这里的瓷砖 
let's say this is the hole, and these are the tiles here.

1459
01:17:50,500 --> 01:17:52,230
X加上宽度--
The x plus the width--

1460
01:17:52,230 --> 01:17:55,120
它会在这块瓷砖和这块瓷砖上引发碰撞 
it'll trigger a collision on this tile and this tile still.

1461
01:17:55,120 --> 01:17:58,480
所以基本上 你需要将他的碰撞框最小化一个像素
So basically, you need to minimize his collision box by one pixel

1462
01:17:58,480 --> 01:18:03,970
从本质上讲 要适应16个像素的间隙 这就是它的归结 
to fit through 16 pixel gaps essentially is what it boils down to.

1463
01:18:03,970 --> 01:18:07,315
但碰撞背后的主旨--
But the gist behind collision--

1464
01:18:07,315 --> 01:18:09,190
在这种情况下 这只适用于他
in this case, this would only apply when he's

1465
01:18:09,190 --> 01:18:11,440
跳跃 因为这是他唯一能真正
jumping, because this is the only time at which he can really

1466
01:18:11,440 --> 01:18:13,240
与他上方的瓷砖相撞 
collide with tiles that are above him.

1467
01:18:13,240 --> 01:18:17,190
您将测试落在此像素上的任何块
You would test for whatever block falls on this pixel

1468
01:18:17,190 --> 01:18:19,490
不管落在这个像素上的是什么块 
and whatever block falls on this pixel.

1469
01:18:19,490 --> 01:18:23,380
如果它们中的任何一个是实心的 就会引发碰撞 
And if either of them are solid, you trigger collision.

1470
01:18:23,380 --> 01:18:25,610
如果没有 那么根本就不会发生碰撞 
And if not, then there's no collision at all.

1471
01:18:25,610 --> 01:18:29,210
例如 如果他就在这里--
So if he's right here, for example--

1472
01:18:29,210 --> 01:18:31,960
就在瓷砖的正下方--它只会检查一个瓷砖 
right directly beneath a tile-- it's only going to check one tile.

1473
01:18:31,960 --> 01:18:35,440
这一点和这一点都将落在这块瓷砖上 
This point and this point are both going to fall on this tile.

1474
01:18:35,440 --> 01:18:39,220
但我们之所以要检查这里和这里的两个点
But the reason that we want to check for both points here and here

1475
01:18:39,220 --> 01:18:42,850
如果他在两块不同的瓷砖下面 
is in the event that he is beneath two separate tiles,

1476
01:18:42,850 --> 01:18:45,354
因为现在这一点将检查这块瓷砖 
because now this point's going to check this tile,

1477
01:18:45,354 --> 01:18:47,020
这一块将检查这块瓷砖 
and this one's going to check this tile.

1478
01:18:47,020 --> 01:18:50,950
我们不能只检查这个瓷砖 因为如果我们只检查这个瓷砖
We can't just check this tile, because if we only check this tile

1479
01:18:50,950 --> 01:18:53,860
这里没有瓷砖 但这里有瓷砖 
and there was no tile here but there was a tile here,

1480
01:18:53,860 --> 01:18:57,070
他的跳跃仍然不会引发碰撞 
him jumping would still not trigger a collision.

1481
01:18:57,070 --> 01:18:59,950
它会认为它只是在看这里 而不是这里 
It would think that it was only looking here and not here.

1482
01:18:59,950 --> 01:19:05,200
所以对于我们有效地在他的每一边进行的每一次碰撞 
So for every collision on every side we do of him effectively,

1483
01:19:05,200 --> 01:19:09,520
我们需要有效地检查那条边的两个角 
we need to check both corners of that edge effectively.

1484
01:19:09,520 --> 01:19:14,610
所以当他跳的时候 我们转到这一点--
So when he's jumping, we turn this point--

1485
01:19:14,610 --> 01:19:19,690
这个x y--只需除以瓷砖的大小就可以得到瓷砖 
this x, y-- into a tile by just dividing it by tile size.

1486
01:19:19,690 --> 01:19:23,890
所以我们可以说 Player.x除以瓷砖大小加1 
So we can say, player.x divided by tile size plus one.

1487
01:19:23,890 --> 01:19:27,520
这将等于x上的任何平铺 
That's going to equal whatever tile this is on the x.

1488
01:19:27,520 --> 01:19:29,200
然后对y做同样的事情--
And then same thing for the y--

1489
01:19:29,200 --> 01:19:32,410
我们只需将y除以瓷砖大小 然后在上面加1 
we just divide the y by tile size, and then we add 1 to it.

1490
01:19:32,410 --> 01:19:34,900
这将使我们能够得到准确的瓷砖 
And that will allow us to get the exact tile.

1491
01:19:34,900 --> 01:19:39,340
如果我们使用从操作中得到的x y 
If we use those x, y that we get from that operation,

1492
01:19:39,340 --> 01:19:44,560
我们有效地获得了瓦片2D数组中y x索引处的精确瓦片 
we get the exact tile at that y, x index in our tile's 2D array effectively.

1493
01:19:44,560 --> 01:19:45,820
所以我们对跳跃也是这样做的 
So we do that for jump.

1494
01:19:45,820 --> 01:19:50,099
我们检查了他头顶的两个角 
We check both corners of the top of his head.

1495
01:19:50,099 --> 01:19:52,390
我们对底部做同样的事情 只是在那个时候 
We do the same thing for the bottom, only at that time,

1496
01:19:52,390 --> 01:19:56,260
我们检查x 然后y加上高度 
we're checking x, and then y plus height,

1497
01:19:56,260 --> 01:19:58,810
然后x加上宽度 y加上高度 
and then x plus width, y plus height.

1498
01:19:58,810 --> 01:20:01,862
如果我们做的是左边缘 我们要检查什么？
And then if we're doing the left edge, what are we checking?

1499
01:20:05,208 --> 01:20:07,125
观众：左下角和左上角？
AUDIENCE: The bottom left and top left?

1500
01:20:07,125 --> 01:20:08,000
科尔顿·奥格登：我们是 
COLTON OGDEN: We are.

1501
01:20:08,000 --> 01:20:13,220
所以这将是x0 y 然后是x0 y加上高度 
So that will be x0, y, and then x0, y plus height.

1502
01:20:13,220 --> 01:20:15,590
然后如果它是正确的边缘 同样的事情 
And then if it's the right edge, same thing.

1503
01:20:15,590 --> 01:20:23,420
我们检查x+宽度y 然后我们检查x+宽度y+高度 
We check x plus width y, and then we check x plus width y plus height.

1504
01:20:23,420 --> 01:20:30,320
这就是这个发行版中碰撞检测背后的主旨 
And so that's the gist behind collision detection in the distro here.

1505
01:20:30,320 --> 01:20:35,405
如果我们转到磁贴地图 你可以在马里奥看到它 
And you can see it in Mario if we go to TileMap.

1506
01:20:39,590 --> 01:20:42,680
指向磁贴--这实际上就是它发生的地方 
Point to tile-- this is effectively where it happens.

1507
01:20:49,610 --> 01:20:52,390
在第32行 我们基本上是返回--
On line 32, we're basically returning--

1508
01:20:52,390 --> 01:20:53,660
这里的这段代码--
this bit of code here--

1509
01:20:53,660 --> 01:20:56,030
28比30--是一张支票
28 to 30-- is a check.

1510
01:20:56,030 --> 01:20:59,120
因为我们可以跳过地图的边缘 我们
Because we can jump over the map edge, we

1511
01:20:59,120 --> 01:21:02,669
将无法在切片y除以平铺大小时进行检查
won't be able to check at tile y divided by TILE_SIZE

1512
01:21:02,669 --> 01:21:05,460
加1 x除以平铺大小加1 因为这些都是零 
plus 1, x divided by TILE_SIZE plus one, because those will be nil.

1513
01:21:05,460 --> 01:21:07,209
这些都不会存在 因为他真的会
Those won't exist, because he'll literally

1514
01:21:07,209 --> 01:21:08,510
在地图边界之外 
be outside the map boundaries.

1515
01:21:08,510 --> 01:21:12,540
如果他在它下面 或者他超过了左边或右边 情况也是一样的 
Same thing if he goes below it or he goes beyond the left or right edge.

1516
01:21:12,540 --> 01:21:14,030
这就是这里的所有代码 
So that's all this code is here.

1517
01:21:14,030 --> 01:21:17,780
它只是确保如果我们真的超越地图的边界 
It just makes sure that if we do go beyond the map boundaries,

1518
01:21:17,780 --> 01:21:18,920
我们归零 
we return nil.

1519
01:21:18,920 --> 01:21:23,540
因此 我们可以检查为零 而不是得到瓷砖索引错误 
So that way, we can check nil rather than getting a tile index error.

1520
01:21:23,540 --> 01:21:26,370
然后在第32行是我刚才提到的操作 
And then on line 32 is the operation that I just mentioned,

1521
01:21:26,370 --> 01:21:28,550
那就是我们用y--
which was we take the y--

1522
01:21:28,550 --> 01:21:33,020
所以我们传入的这个x和y将是玩家的实际x y 
so this x and y that we pass in are going to be the player's actual x, y.

1523
01:21:33,020 --> 01:21:38,360
当我们传递这些信息时 我们只需要在self上获得瓷砖 瓷砖 
When we pass those in, we're just going to get the tile at self.tiles,

1524
01:21:38,360 --> 01:21:43,130
然后有效地y除以Tile_Size得到一个整数 
and then effectively y divided by TILE_SIZE taken down to an integer,

1525
01:21:43,130 --> 01:21:43,890
然后加1 
and then add 1.

1526
01:21:43,890 --> 01:21:49,070
回想一下 表是1索引的 但坐标是0索引的 
Because recall, tables are 1 indexed, but the coordinates are 0 indexed.

1527
01:21:49,070 --> 01:21:53,210
因此 这将导致索引结果为0 因此我们希望将其加1 
So this will result in a 0 indexed outcome, so we want to add 1 to it.

1528
01:21:53,210 --> 01:21:57,000
这里的情况也一样--math.loor(X)除以TableSize加1 
Same thing for here-- math.floor(x) divided by TILE_SIZE plus 1.

1529
01:21:57,000 --> 01:21:59,870
因此 有效地 指向瓷砖 
So effectively, points to tiles.

1530
01:21:59,870 --> 01:22:01,660
然后我们就从那里得到一块瓷砖 
And then we'll just get a tile from that.

1531
01:22:01,660 --> 01:22:05,130
而瓷砖--我们可以检查一下 嘿 那瓷砖是不是实心的？
And the tile-- we can just check, hey, is that tile solid or not?

1532
01:22:05,130 --> 01:22:07,830
如果是 则触发碰撞 
If it is, trigger collision.

1533
01:22:07,830 --> 01:22:12,980
这就是能够在平台上做到这一点的主旨
So that's the gist behind being able to do it in a platformer

1534
01:22:12,980 --> 01:22:14,459
在那里一切都是固定的 
where everything is fixed.

1535
01:22:14,459 --> 01:22:16,250
这就像是我们可以走的一条捷径 
That's sort of like a shortcut we can take.

1536
01:22:16,250 --> 01:22:19,730
因为现在 这有什么好处呢？
Because now, what's the nice thing about this?

1537
01:22:19,730 --> 01:22:24,980
这个算法有一个非常棒的地方 
What jumps out as being a super nice thing about this algorithm,

1538
01:22:24,980 --> 01:22:35,720
想象一下 我们的游戏世界里有10,000块瓷砖 
imagining that we have, let's say, 10,000 tiles in our game world.

1539
01:22:35,720 --> 01:22:38,390
所以如果你看一看 我们所做的就是
So if you look and see, all we're doing is

1540
01:22:38,390 --> 01:22:40,700
我们只是在做一个简单的数学运算
we're just doing a simple mathematical operation

1541
01:22:40,700 --> 01:22:44,150
关于他的x和y是什么 对吗？
on what his x and y is, right?

1542
01:22:44,150 --> 01:22:46,520
除了这个 还有什么办法？
What's the alternative to this?

1543
01:22:46,520 --> 01:22:50,430
例如 如果我们通过AABB进行这项工作 
If we were doing this via AABB, for example,

1544
01:22:50,430 --> 01:22:54,518
我们必须遍历每一块瓷砖 对吗？
we'd have to iterate over every single tile, right?

1545
01:22:54,518 --> 01:22:56,474
观众：你能总结一下吗？
AUDIENCE: Can you summarize?

1546
01:22:56,474 --> 01:23:00,386
为了避免重复屏幕上的所有内容 
To avoid iterating over everything on the screen,

1547
01:23:00,386 --> 01:23:03,820
你只是检查了他所在的栏目和栏目标题？
you just check the column that he's in and the column tile?

1548
01:23:03,820 --> 01:23:04,880
科尔顿·奥格登：是的 
COLTON OGDEN: Yep.

1549
01:23:04,880 --> 01:23:09,720
所以大意是他有一个x和一个y 
So the gist is he's got an x and a y.

1550
01:23:09,720 --> 01:23:13,940
X和y将在世界坐标中 所以他的x可能是67
The x and the y are going to be in world coordinates, so his x could be 67

1551
01:23:13,940 --> 01:23:16,040
他的y可能是38岁左右 
and his y could be 38 or something like that.

1552
01:23:16,040 --> 01:23:17,450
它们不会均匀地映射到瓷砖 
They don't map evenly to tiles.

1553
01:23:17,450 --> 01:23:20,660
但如果我们把这些除以我们世界中的瓷砖大小--
But if we divide those by whatever the tile size is in our world--

1554
01:23:20,660 --> 01:23:25,310
16--这将是一模一样的瓷砖
16-- that's going to be the exact tile.

1555
01:23:25,310 --> 01:23:30,500
我们还必须在它的基础上加1 因为Lua中的表是1索引的 
We also have to add 1 to it, because the tables in lua are 1 indexed.

1556
01:23:30,500 --> 01:23:34,040
但是我们可以用x y来索引我们自己的瓷砖
But we can index our self.tiles at the x, y

1557
01:23:34,040 --> 01:23:36,945
我们从中得到的--除以16 
that we get from that-- the dividing by 16.

1558
01:23:36,945 --> 01:23:39,320
这就是他要撞上的瓷砖 
And that will be the exact tile that he's colliding with.

1559
01:23:43,340 --> 01:23:45,710
我们基本上不需要有一系列的瓷砖
We don't have to basically have a collection of tiles

1560
01:23:45,710 --> 01:23:48,710
我们迭代并检查它们是否
that we iterate over and check whether they

1561
01:23:48,710 --> 01:23:51,200
使用AABB碰撞检测与玩家碰撞
collide with the player using AABB collision detection

1562
01:23:51,200 --> 01:23:52,220
就像我们以前做过的那样 
like we've done before.

1563
01:23:52,220 --> 01:23:54,620
因为回想一下 在《越狱》中 我们有砖头 对吗？
Because recall, in Breakout, we had the bricks, right?

1564
01:23:54,620 --> 01:23:56,990
他们都有自己的x y 但他们不在一个网格上 
They all had their own x, y, but they weren't on a grid.

1565
01:23:56,990 --> 01:23:58,040
他们还没修好 
They weren't fixed.

1566
01:23:58,040 --> 01:24:01,130
所以我们不得不真的把它们拿来做AABB 
So we had to actually take them and do an AABB.

1567
01:24:01,130 --> 01:24:03,740
我们不得不迭代它们并对它们执行AABB 
We had to iterate over them and perform AABB on them,

1568
01:24:03,740 --> 01:24:08,450
因为没有确定性的方法可以非常快速地对它们进行索引 
because there's no deterministic way to just index at them really quickly.

1569
01:24:08,450 --> 01:24:11,300
数组和链表的情况是一样的 
It's the same thing with arrays versus linked lists.

1570
01:24:11,300 --> 01:24:16,610
因为数组--你可以计算某个值在多大程度上被赋予了索引 
Because arrays-- you can calculate how far some value is given an index.

1571
01:24:16,610 --> 01:24:18,450
您可以立即访问它 
You have instant access to it.

1572
01:24:18,450 --> 01:24:22,070
这是一个操作的顺序 而不是链表 
It's an order of one operation as opposed to a linked list.

1573
01:24:22,070 --> 01:24:24,230
如果你想试着得到一个特定值 
If you want to try and get to a particular value,

1574
01:24:24,230 --> 01:24:26,854
你必须遍历整个过程 直到找到它 
you have to iterate through the entire thing until you find it.

1575
01:24:26,854 --> 01:24:31,790
观众：你能不能找一下你可能要降落的栏目？
AUDIENCE: Can you just look for the column that you might be landing on?

1576
01:24:31,790 --> 01:24:36,650
科尔顿·奥格登：无论你的x除以16 你都能得到准确的瓷砖--
COLTON OGDEN: You're getting the exact tile at whatever your x divided by 16--

1577
01:24:36,650 --> 01:24:38,150
或者不管你的瓷砖大小是什么--
or whatever your tile size is--

1578
01:24:38,150 --> 01:24:40,370
你的y除以16是 
and your y divided by 16 is.

1579
01:24:40,370 --> 01:24:43,010
记住 你这么做是为了两个不同的观点
And you're doing it, recall, for two different points

1580
01:24:43,010 --> 01:24:44,777
取决于你要找的是什么 
depending on what you're looking for.

1581
01:24:44,777 --> 01:24:47,360
如果你要找的是高于你角色的瓷砖 
If you're looking for the tiles that are above your character,

1582
01:24:47,360 --> 01:24:49,280
你将在这一点上做这件事 
you're going to be doing it for this point.

1583
01:24:49,280 --> 01:24:53,030
所以不管这个值是什么--他的基数x y-
So whatever this value is-- his base x, y--

1584
01:24:53,030 --> 01:24:57,490
不管它被16除以什么 然后再除以16 
whatever that is divided by 16 and then whatever that is divided by 16.

1585
01:24:57,490 --> 01:25:00,310
然后你就可以得到他正上方的瓷砖了 
And then that'll get you whatever tiles are directly above him.

1586
01:25:00,310 --> 01:25:03,160
它将与与该点相交的任何切片相交
It will intersect with whatever tile intersects with this point

1587
01:25:03,160 --> 01:25:05,272
任何瓷砖都与这一点相交 
and whatever tile intersects with this point.

1588
01:25:05,272 --> 01:25:07,730
如果我们看左边 这里和这里也是一样的 
Same thing with here and here if we're looking on the left,

1589
01:25:07,730 --> 01:25:09,080
这里 这里 如果我们看的是底部 
here, here if we're looking on the bottom,

1590
01:25:09,080 --> 01:25:11,610
这里和这里 如果我们看的是右边的话 
and here and here if we're looking on the right side.

1591
01:25:11,610 --> 01:25:13,640
我们会在他已经
And we check for collision after he's already

1592
01:25:13,640 --> 01:25:18,340
移动以使这些点与可能的块相交 
moved so that these points will be intersected with potential blocks.

1593
01:25:18,340 --> 01:25:20,840
这就是我们可以检查是否发生碰撞的方法 
And that's how we can check whether it's a collision or not.

1594
01:25:20,840 --> 01:25:26,844
我们在他移动和处于某种移动状态时这样做 
We do this when he moves and is in some sort of movement state.

1595
01:25:26,844 --> 01:25:29,130
观众：所以你还在做碰撞检测
AUDIENCE: So you're still doing collision detection

1596
01:25:29,130 --> 01:25:31,430
他的实际坐标 但你只是
with his actual coordinates, but you're just

1597
01:25:31,430 --> 01:25:34,620
缩小你的字符宽度--
narrowing what you're character width--

1598
01:25:34,620 --> 01:25:36,000
科尔顿·奥格登：是的 
COLTON OGDEN: Yep.

1599
01:25:36,000 --> 01:25:39,360
我们把它从在每一块瓷砖上迭代
we're turning it from iterating over every single tile

1600
01:25:39,360 --> 01:25:42,540
到即时运算 因为我们可以从数学上得到
to an instant operation, because we can just mathematically get

1601
01:25:42,540 --> 01:25:45,210
一模一样的瓦片 他没有
the exact tiles that he's at without having

1602
01:25:45,210 --> 01:25:47,130
担心他在地图上的位置 
to worry about where he is in the map.

1603
01:25:47,130 --> 01:25:50,450
这只是即时访问 
It's just instant access.

1604
01:25:50,450 --> 01:25:53,820
这只是因为我们知道瓷砖总是
And this only works because we know the tiles are always

1605
01:25:53,820 --> 01:25:55,290
固定在完全相同的位置 
fixed in the exact same locations.

1606
01:25:55,290 --> 01:25:56,623
他们总是从0 0开始 
They're always starting at 0, 0.

1607
01:25:56,623 --> 01:25:58,262
它们永远都是瓷砖大小 
They're always going to be TILE_SIZE.

1608
01:25:58,262 --> 01:25:59,970
当事情变得更复杂的时候
Things get a little more complicated when

1609
01:25:59,970 --> 01:26:04,920
我们引入游戏对象 它们有自己独立的x y 
we introduce game objects, which have their own independent x, y.

1610
01:26:04,920 --> 01:26:06,824
对于这些 您确实需要迭代 
And for those, you do have to iterate over.

1611
01:26:06,824 --> 01:26:09,990
基本上 您拥有一组游戏对象或一组实体 
You have basically a collection of game objects or a collection of entities.

1612
01:26:09,990 --> 01:26:12,270
让我们假设游戏世界里有蜗牛 
Let's say we have snails in the game world.

1613
01:26:12,270 --> 01:26:16,770
蜗牛不会每次都出现在某个固定的位置 
The snails aren't going to be at some fixed location every time.

1614
01:26:16,770 --> 01:26:19,170
它们可以连续移动 
They can move continuously.

1615
01:26:19,170 --> 01:26:21,960
因此 对于这些 我们必须将它们全部保存在一个容器中
So for those, we have to actually keep them all in a container

1616
01:26:21,960 --> 01:26:26,940
然后循环浏览它们 然后说 我的球员有没有撞到其中的任何一个？
and then loop through them and say, has my player collided with any of these?

1617
01:26:26,940 --> 01:26:29,520
如果他有 那么就会引发与那只蜗牛的碰撞--
If he has, then trigger a collision with that snail--

1618
01:26:29,520 --> 01:26:34,532
如果玩家处于行走状态或跳跃状态 则杀死它或杀死该玩家 
kill it or kill the player if he's in a walking state or a jump state.

1619
01:26:34,532 --> 01:26:36,240
如果他处于跌倒状态 那么他们
And if he's in a falling state, then they

1620
01:26:36,240 --> 01:26:39,480
应该会死 因为他正从顶部与他们相撞 
should die, because he's colliding with them from the top.

1621
01:26:39,480 --> 01:26:43,500
然后缩小检查碰撞的范围 就像你在底部看到的那样
And you narrow down what collision you check for, as you can see at the bottom

1622
01:26:43,500 --> 01:26:44,850
这里 
here.

1623
01:26:44,850 --> 01:26:47,267
瓷砖碰撞--当你看着你的角色上方时 
Tile collision-- when you're looking above your character,

1624
01:26:47,267 --> 01:26:49,683
你只是在测试当你处于跳跃状态时 
you're only testing that when you're in the jumping state,

1625
01:26:49,683 --> 01:26:51,390
因为这是你唯一需要的时间 
because it's the only time you need to.

1626
01:26:51,390 --> 01:26:55,380
所以这是唯一一个你会与你上方的瓷砖相撞的点 
So that's the only point at which you'll collide with tiles that are above you.

1627
01:26:55,380 --> 01:26:58,980
当你处于下落状态时 你就会检查你脚下的瓷砖 
When you're in the falling state is when you'll check for tiles below you.

1628
01:26:58,980 --> 01:27:01,390
然后你可以与你身边的瓷砖互动
And then you can interact with tiles to your side

1629
01:27:01,390 --> 01:27:04,020
当你处于跳跃、坠落或移动状态时 
when you're in either the jumping, falling, or moving state,

1630
01:27:04,020 --> 01:27:08,285
因此 您应该检查所有这三个州的左侧和右侧磁贴 
so you should check for left and right tiles in all three of those states.

1631
01:27:08,285 --> 01:27:12,835
观众：你不是应该总是测试一下自己的底线 以防出现裂痕吗？
AUDIENCE: Shouldn't you always test for beneath you in case you get a chasm?

1632
01:27:12,835 --> 01:27:13,960
科尔顿·奥格登：以防万一？
COLTON OGDEN: In case what?

1633
01:27:13,960 --> 01:27:15,430
观众：以防出现裂痕 
AUDIENCE: In case you get a chasm.

1634
01:27:15,430 --> 01:27:17,138
科尔顿·奥格登：如果你有裂痕 是的 
COLTON OGDEN: In case you get chasm, yes.

1635
01:27:21,210 --> 01:27:21,930
你说得对 
You're correct.

1636
01:27:21,930 --> 01:27:24,660
这实际上应该只在播放器中进行测试
This should actually be tested only when in the player

1637
01:27:24,660 --> 01:27:26,820
跌倒状态和球员行走状态 是的 
falling state and player walking state, yes.

1638
01:27:26,820 --> 01:27:30,690
所以问题是 你不是应该测试你脚下的瓷砖吗
So the question was, shouldn't you be testing for tiles beneath you

1639
01:27:30,690 --> 01:27:32,300
当你走路的时候？
when you're walking?

1640
01:27:32,300 --> 01:27:35,274
是的--不仅是摔倒 而且还会走路 
And yes-- not just falling, but walking as well.

1641
01:27:35,274 --> 01:27:37,440
这只只会跳 这只会摔倒 还会走路 
This one only jumping, this one falling and walking,

1642
01:27:37,440 --> 01:27:39,690
这个是跳跃、坠落和移动的 
and this one for jumping, falling, and moving.

1643
01:27:44,490 --> 01:27:45,660
这有意义吗--
Does that make sense--

1644
01:27:45,660 --> 01:27:49,890
我们如何将x y转化为一块瓷砖
how we can take the x, y and sort of turn that into a tile

1645
01:27:49,890 --> 01:27:52,410
只要除以16就行了吗？
by just dividing it by 16?

1646
01:27:52,410 --> 01:27:56,970
而且一定要注意加1 因为我们自己的瓷砖 瓷砖
And do note the plus 1 as well, because our tiles in our self.tiles

1647
01:27:56,970 --> 01:27:58,530
有1个索引 
are 1 indexed.

1648
01:27:58,530 --> 01:28:01,440
所以当我们用x y除以瓷砖大小时 我们就是
And so when we divide x, y by tile size, we're

1649
01:28:01,440 --> 01:28:05,160
将得到一个0索引坐标 
going to get a 0 indexed coordinate.

1650
01:28:05,160 --> 01:28:10,930
如果我们的x是14 我们就在第一个瓦片内 
If our x is at 14, we're within the first tile.

1651
01:28:10,930 --> 01:28:13,170
但如果我们把它除以16 我们会得到零 
But if we divide that by 16, we're going to get zero.

1652
01:28:13,170 --> 01:28:16,086
所以我们需要加1 这样我们就得到了数组中的第一个平铺
So we need to add 1 to that so that we get the first tile in the array

1653
01:28:16,086 --> 01:28:20,280
不管那块瓷砖是什么 它都会是 
still, which will be whatever that tile is.

1654
01:28:20,280 --> 01:28:23,100
这就是碰撞的原理 
So that's how the collision works.

1655
01:28:23,100 --> 01:28:27,390
它都是在这里的TileMap中实现的 
It's all implemented in TileMap here.

1656
01:28:27,390 --> 01:28:36,170
基本上玩家所处的每一个状态 都在StatesEntity中 
And basically every state that the player is in, which is in StatesEntity,

1657
01:28:36,170 --> 01:28:38,870
然后运动员跌倒 无所事事 跳跃和行走--
and then player falling, idle, jump, and walking--

1658
01:28:38,870 --> 01:28:43,590
这些都是执行此检查的状态 
these are all states that perform this check.

1659
01:28:43,590 --> 01:28:45,500
他们基本上做了这里的所有逻辑
They basically do all the logic that's here

1660
01:28:45,500 --> 01:28:47,720
在底部 这是在播放器中测试
at the bottom, which is testing in the player

1661
01:28:47,720 --> 01:28:51,620
左碰撞或右碰撞的跳跃状态、下降状态和移动状态 
jumping state, falling state, and moving state for left or right collision.

1662
01:28:51,620 --> 01:28:55,192
然后在下落状态下 我们检查下面是否有碰撞 
And then in the falling state, we check for collision below us.

1663
01:28:55,192 --> 01:28:57,650
然后在跳跃状态下 我们检查上方是否有碰撞 
And then in jumping state, we check for collision above us.

1664
01:28:57,650 --> 01:29:01,670
这一切都是在各州内部完成的 
That's all done within the states themselves.

1665
01:29:01,670 --> 01:29:05,089
但从像素到瓷砖的实际转换--
But the actual transformation from pixels to tiles--

1666
01:29:05,089 --> 01:29:07,130
这只是我们从TileMap调用的一个函数 
that's just a function that we call from TileMap.

1667
01:29:07,130 --> 01:29:09,859
这只是一个效用函数 
It's just a utility function.

1668
01:29:09,859 --> 01:29:11,650
观众：这个函数叫什么来着？
AUDIENCE: What's the function called again?

1669
01:29:11,650 --> 01:29:13,460
科尔顿·奥格登：这叫PointToTile 
COLTON OGDEN: It's called pointToTile.

1670
01:29:13,460 --> 01:29:18,170
所以如果你在TileMap的第27行--
So if you're in TileMap on line 27--

1671
01:29:18,170 --> 01:29:19,430
PointToTile(x y) 
pointToTile(x, y).

1672
01:29:19,430 --> 01:29:22,430
这里的第一点只是一小部分
And the first little bit here is just the bit

1673
01:29:22,430 --> 01:29:25,910
这基本上可以让你走出地图的界限
that lets you basically go outside the map bounds

1674
01:29:25,910 --> 01:29:27,960
而不会出现平铺索引错误 
without getting a tile index error.

1675
01:29:27,960 --> 01:29:33,110
因此 如果它正好在平铺限制之外 小于0 或大于宽度 
So if it's just outside the tile limits, less than 0, or greater than width,

1676
01:29:33,110 --> 01:29:34,100
只需返回零即可 
just return nil.

1677
01:29:34,100 --> 01:29:35,870
所以你可以在nil上做一个检查
And so you can do a check on nil to check

1678
01:29:35,870 --> 01:29:40,345
查看TileMap point tToTile是否等于Nil
to see whether TileMap pointToTile is equal to nil

1679
01:29:40,345 --> 01:29:41,720
或者当你做碰撞的时候不会 
or not when you do the collision.

1680
01:29:41,720 --> 01:29:46,570
如果是的话 那就什么都别做了 
And if it is, then just don't do anything probably.

1681
01:29:46,570 --> 01:29:51,530
但假设您在磁贴边界内 在第32行
But assuming that you're within the tile boundaries, on line 32

1682
01:29:51,530 --> 01:29:54,691
就是你进行转化的地方--数学地板 回想一下 
is where you do that transformation-- the math.floor, recall,

1683
01:29:54,691 --> 01:29:56,690
因为我们想要得到这些的整数值 
because we want to get integer values for these.

1684
01:29:56,690 --> 01:29:58,856
我们不想得到小数 因为你
We don't want to get fractional numbers, because you

1685
01:29:58,856 --> 01:30:03,220
我不能将这些瓷砖作为小数编制索引 尽管我不确定 
can't index these tiles as fractional numbers, although I'm not sure.

1686
01:30:03,220 --> 01:30:06,650
我认为在Lua中通常可以--为瓷砖建立索引
I think you might be able to in Lua generally-- index a tile

1687
01:30:06,650 --> 01:30:07,740
以一个小数 
by a fractional number.

1688
01:30:07,740 --> 01:30:10,290
但在本例中 我们只需要整数 
But in this case, we just want integers.

1689
01:30:10,290 --> 01:30:14,440
所以我们将y上的数学地板除以平铺大小加1 
So we call math.floor on y divided by TILE_SIZE plus 1,

1690
01:30:14,440 --> 01:30:16,730
Y除以平铺大小 然后再加1 
y divided by TILE_SIZE then add 1 to that,

1691
01:30:16,730 --> 01:30:18,484
然后我们对x做同样的事情 
and then we do the same thing for the x.

1692
01:30:18,484 --> 01:30:20,122
这就是我们的行动 
So that's the operation.

1693
01:30:20,122 --> 01:30:23,330
然后在我们想要检查任何我们想要碰撞的瓷砖的地方 
And then wherever we want to check for whatever tiles we want to collide for,

1694
01:30:23,330 --> 01:30:28,070
我们只在x和y坐标上调用point ToTile 
we just call pointToTile on those x and y coordinates.

1695
01:30:28,070 --> 01:30:33,480
这就是游戏中所有基于瓷砖的碰撞背后的主干
That's the backbone behind all the tile-based collision in the game

1696
01:30:33,480 --> 01:30:34,400
有效地 
effectively.

1697
01:30:37,630 --> 01:30:41,490
对于这是如何工作的 有什么问题吗？
Any questions as to how this works?

1698
01:30:41,490 --> 01:30:41,990
是 
Yes.

1699
01:30:41,990 --> 01:30:45,742
观众：所以你探测到的只是角落的碰撞
AUDIENCE: So you're only detecting the collision of corners

1700
01:30:45,742 --> 01:30:47,620
而不是边缘本身？
and not the edge itself?

1701
01:30:47,620 --> 01:30:51,230
科尔顿·奥格登：正确 因为你真的不需要检查边缘
COLTON OGDEN: Correct, because you don't really need to check for the edge

1702
01:30:51,230 --> 01:30:53,830
如果考虑到上角和下角 
if you're taking into consideration the top and bottom corner,

1703
01:30:53,830 --> 01:30:57,610
除非你的实体足够高 他们需要
unless your entity is sufficiently tall that they need

1704
01:30:57,610 --> 01:31:00,340
检查是否有三块以上的瓷砖 
to check for more than three tiles.

1705
01:31:00,340 --> 01:31:03,730
在这种情况下 我们的实体不超过两个瓷砖高 
In this case, our entity is not more than two tiles tall,

1706
01:31:03,730 --> 01:31:08,556
所以我们只需要检查他的左上角 左下角 
so we only need to check for his top left, bottom left.

1707
01:31:08,556 --> 01:31:10,930
如果是左碰撞 右上角 右下角 
If we're doing a left collision, top right, bottom right.

1708
01:31:10,930 --> 01:31:16,330
如果我们在做右碰撞 他的左上角 右上角的顶部和底部
If we're doing a right collision, his top left, top right for top and bottom

1709
01:31:16,330 --> 01:31:17,710
左下角 右下角为底部 
left, bottom right for bottom.

1710
01:31:17,710 --> 01:31:20,980
如果你有一个八块高的实体 
If you had an entity that was eight tiles tall,

1711
01:31:20,980 --> 01:31:26,330
你需要检查他右侧的每一块瓷砖 
you need to check every single tile along his right side, which

1712
01:31:26,330 --> 01:31:30,550
只是意味着你需要迭代他的整个身高除以瓷砖大小 
just means you need to iterate over his entire height divided by tile size.

1713
01:31:30,550 --> 01:31:34,450
然后只需对每个瓷砖检查的y进行偏移 
And then just offset the y that you're checking for each of those tiles.

1714
01:31:34,450 --> 01:31:36,090
这说得通吗？
Does that makes sense?

1715
01:31:36,090 --> 01:31:38,860
好的 酷 
OK, cool.

1716
01:31:38,860 --> 01:31:39,490
好的 
All right.

1717
01:31:39,490 --> 01:31:41,890
我通过提到国家简要地提到了这一点 
I alluded to this briefly by mentioning state.

1718
01:31:45,340 --> 01:31:48,340
我不知道我是否暗示了我们使用实体的事实 
I don't know if I alluded so much to the fact that we're using entities.

1719
01:31:48,340 --> 01:31:53,260
但在这个发行版中 我们被介绍了实体的概念 
But in this distro, we're introduced to the concept of entities.

1720
01:31:53,260 --> 01:31:57,960
一个实体几乎可以是你想要的任何东西 
An entity can be almost anything you want it to be.

1721
01:31:57,960 --> 01:31:59,980
在这个发行版中 我们考虑的是实体
In this distro, we're considering entities

1722
01:31:59,980 --> 01:32:03,250
基本上是任何有生命或有知觉的东西--
to basically be anything that's living or sentient moving around--

1723
01:32:03,250 --> 01:32:04,900
在这种情况下 球员或蜗牛 
in this case, the player or snails.

1724
01:32:04,900 --> 01:32:10,132
这些是实体 然后它们只是实体的子集 
Those are entities, and then they just are subsets of entity.

1725
01:32:10,132 --> 01:32:11,590
实体是一个非常抽象的东西 
An entity is a very abstract thing.

1726
01:32:11,590 --> 01:32:15,850
你会在很多游戏引擎和很多讨论中看到它
You'll see it in a lot of game engines and a lot of discussions

1727
01:32:15,850 --> 01:32:19,300
关于如何组织你的游戏以及如何设计它 
about how to organize your game and how to engineer it.

1728
01:32:19,300 --> 01:32:24,460
Unity可能是最突出的采用者
Unity is probably the most prominent adopter

1729
01:32:24,460 --> 01:32:27,460
所谓的实体组件系统 由此
of what's called the entity component system, whereby

1730
01:32:27,460 --> 01:32:29,350
你在你的比赛中拥有一切 
you have everything in your game.

1731
01:32:29,350 --> 01:32:31,510
你游戏中的每一件事都是一个实体 
Every single thing in your game is an entity,

1732
01:32:31,510 --> 01:32:34,480
然后每个实体都是由组件组成的 
and then every entity is comprised of components.

1733
01:32:34,480 --> 01:32:37,960
而这些组件最终会驱动你的行为 
And these components ultimately drive your behavior.

1734
01:32:37,960 --> 01:32:41,290
这有点像如果你熟悉组合而不是继承 
It's sort of like if you're familiar with composition over inheritance.

1735
01:32:41,290 --> 01:32:43,900
如果你听说过这是一件软件工程的事情 
If you've heard of this as a software engineering thing,

1736
01:32:43,900 --> 01:32:45,460
这实际上是相同的范式 
that's effectively the same paradigm.

1737
01:32:45,460 --> 01:32:50,290
而不是继承一堆不同的东西成为你的--
Rather than inherit a bunch of different things to be your--

1738
01:32:50,290 --> 01:32:52,620
假设您有一个基本怪物类 
let's say you have a base monster class.

1739
01:32:52,620 --> 01:32:55,240
然后你有一个妖精 它是怪物的子集 
And then you have a goblin that's a subset of monster,

1740
01:32:55,240 --> 01:32:56,710
所以它是从怪物那里继承下来的 
so it inherits from monster.

1741
01:32:56,710 --> 01:32:59,500
然后你有了一个从小妖精那里继承下来的小妖精军阀 
And then you have a goblin warlord who inherits from goblin,

1742
01:32:59,500 --> 01:33:02,950
然后你就有了一个从那里继承下来的古老的妖精军阀 
and then you have an ancient goblin warlord that inherits from that.

1743
01:33:02,950 --> 01:33:06,270
与其让这种嵌套的继承树 
Rather than have this nested tree of inheritance,

1744
01:33:06,270 --> 01:33:11,380
你采用合成法 这意味着你拿一个底座容器 
you adopt composition, which means you take a base container,

1745
01:33:11,380 --> 01:33:14,110
然后用不同的组件填充它 这些组件表示
and then you fill it with different components that represent

1746
01:33:14,110 --> 01:33:16,510
您的对象的行为是什么 
what the behavior of your object is.

1747
01:33:16,510 --> 01:33:19,810
所以如果你有一个实体--
So if you have an entity--

1748
01:33:19,810 --> 01:33:21,820
比方说 你给它一个怪物组件 
let's say you give it a monster component.

1749
01:33:21,820 --> 01:33:25,256
然后也许你还会给它一个古老的组成部分 
And then maybe you also give it an ancient component,

1750
01:33:25,256 --> 01:33:26,380
所以它是一个古老的怪物 
so it's an ancient monster.

1751
01:33:26,380 --> 01:33:28,210
也许你给它一个妖精组件 
And maybe you give it a goblin component,

1752
01:33:28,210 --> 01:33:32,022
那么它就是一个古老的妖精 
so then it's an ancient monster goblin.

1753
01:33:32,022 --> 01:33:33,730
然后你给它一个军阀的组成部分 
And then you give it a warlord component,

1754
01:33:33,730 --> 01:33:35,150
所以这是一个古老的妖怪军阀 
so it's an ancient goblin monster warlord.

1755
01:33:35,150 --> 01:33:36,940
所以它包含了构成它的所有部件
So it has all the pieces that make it what

1756
01:33:36,940 --> 01:33:40,930
它不需要你去创造这个疯狂的继承链 
it is without you having to create this crazy chain of inheritance.

1757
01:33:40,930 --> 01:33:44,920
这实际上就是实体组件系统的模型
That's effectively what the model of an entity component system

1758
01:33:44,920 --> 01:33:48,820
是与标准继承的对比--用它来驱动
is versus standard inheritance-- using that to drive

1759
01:33:48,820 --> 01:33:51,050
你的问题的模型 
the model of your problem.

1760
01:33:51,050 --> 01:33:53,890
在这种情况下 我们不会讨论疯狂的实体组件 
In this case, we're not going into crazy entity components.

1761
01:33:53,890 --> 01:33:56,020
但我想提出来 因为团结 
But I wanted to bring it up, because Unity,

1762
01:33:56,020 --> 01:34:01,000
我们将在几周内介绍 它完全是基于组件的 
which we'll be covering in a few weeks, is entirely component-based.

1763
01:34:01,000 --> 01:34:03,550
您在Unity中编写的所有内容都是一个组件 
Everything you write in Unity is a component.

1764
01:34:03,550 --> 01:34:08,140
和实体 无论它们是否在实体组件系统中 
And entities, whether they're in an entity component system or not,

1765
01:34:08,140 --> 01:34:10,570
构成了大多数大型比赛的中坚力量 
form the backbone of most large games.

1766
01:34:10,570 --> 01:34:15,440
大多数游戏都有一定的复杂性
Most games that have some complexity to them

1767
01:34:15,440 --> 01:34:19,750
将它们中的大多数部分建模为具有行为的实体
model most of the pieces within them as entities that have behaviors

1768
01:34:19,750 --> 01:34:21,260
做一些事情 
and do things.

1769
01:34:21,260 --> 01:34:28,360
因此 在这种情况下 实体是蜗牛和我们的玩家 
And so in this case, entities are snails and our player.

1770
01:34:28,360 --> 01:34:31,900
然后从瓷砖上分开--
And then separate from the tiles--

1771
01:34:31,900 --> 01:34:33,220
当我们做碰撞的时候--
when we do collision for that--

1772
01:34:33,220 --> 01:34:36,130
我们还想检查与玩家在每个实体上的冲突 
we want to also check collision on every entity with the player.

1773
01:34:36,130 --> 01:34:39,577
所以我们要确定在这种情况下玩家与蜗牛相撞 
So we make sure that the player's collided with the snail in this case,

1774
01:34:39,577 --> 01:34:41,910
因为这是他们唯一可以成为的其他实体 
because that's the only other entities that they can be.

1775
01:34:41,910 --> 01:34:47,100
但如果你愿意 你可以拥有任意数量的敌人 
But you can have an arbitrary number of enemies if you want to.

1776
01:34:47,100 --> 01:34:49,970
如果你与一个实体发生冲突--所以只是一个for循环 
If you collide with an entity-- so just a for loop.

1777
01:34:49,970 --> 01:34:54,940
因此 对于成对的实体 请检查冲突 
So for entity in pairs of entities, check collision.

1778
01:34:54,940 --> 01:34:58,720
如果你处于跳跃状态 那就去死吧 
If you're in the jump state, then die.

1779
01:34:58,720 --> 01:35:02,410
如果你处于秋天状态 那就杀了它 等等 
If you're in the fall state, kill it, et cetera.

1780
01:35:02,410 --> 01:35:06,609
当你在做实体到实体交互的大部分事情时 
When you're doing most of your entity to entity interaction stuff,

1781
01:35:06,609 --> 01:35:08,150
这通常是您建模的方式 
that's generally how you'll model it.

1782
01:35:08,150 --> 01:35:11,497
您只需迭代所有内容 然后将所有内容碰撞 
You'll just iterate over everything and then just collide everything.

1783
01:35:11,497 --> 01:35:13,330
根据什么与什么发生冲突 您将
Depending on what collides with what, you'll

1784
01:35:13,330 --> 01:35:16,970
只是将所有东西与其他东西碰撞 并以这种方式处理互动 
just collide everything with everything else and process interactions that way.

1785
01:35:16,970 --> 01:35:18,400
这是我们有效地做到这一点的方式 
That's effectively how we do it.

1786
01:35:18,400 --> 01:35:20,496
我们在--
We have in the--

1787
01:35:20,496 --> 01:35:22,930
我相信它在GameLevel 
I believe it's in GameLevel.

1788
01:35:22,930 --> 01:35:28,350
这维护了对充满实体的表的引用 
This maintains a reference to a table full of entities,

1789
01:35:28,350 --> 01:35:29,830
摆满了物品的桌子 
a table full of objects.

1790
01:35:29,830 --> 01:35:32,770
物体可以--我们稍后会讨论这一点--
Objects can be-- we'll talk about that in a second--

1791
01:35:32,770 --> 01:35:35,800
宝石 积木 灌木丛 诸如此类的东西 然后是一张瓷砖地图 
gems, and blocks, and bushes, and stuff like that, and then a tile map.

1792
01:35:40,820 --> 01:35:43,400
对于每个实体 我们只需更新它 
For every entity, we just update it.

1793
01:35:43,400 --> 01:35:45,580
然后对于每个对象 我们都会更新它 
And then for every object, we update it.

1794
01:35:45,580 --> 01:35:49,020
然后 对于对象中的每个对象 我们也进行渲染 
And then for every object in objects, we render it as well.

1795
01:35:49,020 --> 01:35:50,660
然后我们渲染每一个实体 
And then we render every entity.

1796
01:35:50,660 --> 01:35:55,100
这只是你如何看待游戏世界的基本方式 
This is just sort of basic how you would take a game world,

1797
01:35:55,100 --> 01:35:57,320
填充它 然后处理和更新它 
populate it, and then process and update it.

1798
01:35:57,320 --> 01:36:02,270
只是容器 维护着对所有东西的引用的表 
Just containers, tables that maintain a bunch of references to everything,

1799
01:36:02,270 --> 01:36:03,830
然后只需更新它们 
and then just update them.

1800
01:36:03,830 --> 01:36:06,050
实际的互动发生在--
The actual interaction takes place in the--

1801
01:36:06,050 --> 01:36:09,590
因为它们取决于我们所处的状态 
because they're dependent on what state we're in.

1802
01:36:09,590 --> 01:36:16,610
如果你看一下球员在状态斜杠中的所有不同状态
If you look at all the different states for the player in the states slash

1803
01:36:16,610 --> 01:36:23,040
Entity文件夹 您将看到 例如 在玩家倒下状态的第62行 
entity folder, you'll see, for example, on line 62 of the player falling state,

1804
01:36:23,040 --> 01:36:28,390
我们正在迭代Level中的每个对象 
we're iterating over every object in the level.objects.

1805
01:36:28,390 --> 01:36:31,400
注意玩家有一个关于它的等级的参考
And notice the player has a reference to its level

1806
01:36:31,400 --> 01:36:33,780
这样它就可以访问它里面的所有东西 
so that it can access everything within it.

1807
01:36:33,780 --> 01:36:36,170
然后在该级别内 所有对象都被存储 
And then within that level, all the objects are stored.

1808
01:36:36,170 --> 01:36:38,820
所以它所需要做的就是说 如果物体碰撞
So all it needs to do is just say, if the object collides

1809
01:36:38,820 --> 01:36:43,400
玩家和对象是实心的 然后将我们的dy设置为零 
the player and the object is solid, then set our dy to zero,

1810
01:36:43,400 --> 01:36:44,822
等等 等等 
et cetera, et cetera.

1811
01:36:44,822 --> 01:36:47,030
所有这些代码实际上都很容易阅读 
All this code's actually pretty easy to read through,

1812
01:36:47,030 --> 01:36:49,010
所以我鼓励你们去看看它
so I would encourage you to take a look at it

1813
01:36:49,010 --> 01:36:51,800
只需理解所有的碰撞和东西是如何
and just understand how all the collision and stuff is

1814
01:36:51,800 --> 01:36:57,740
在球员、物体、积木和诸如此类的东西之间工作--
working between the player, the objects, the blocks, and things like that--

1815
01:36:57,740 --> 01:37:01,900
像积木这样的东西是固体的 像灌木丛这样的东西不是固体 
things like blocks are solid, things like bushes are not solid.

1816
01:37:01,900 --> 01:37:05,210
但这就是要点 
But that's the gist.

1817
01:37:05,210 --> 01:37:07,670
拥有对象或实体的集合 
Have a collection of objects or entities.

1818
01:37:07,670 --> 01:37:10,940
然后根据你所处的状态 与一些 
And then depending on what state you're in, collide with some.

1819
01:37:10,940 --> 01:37:14,540
然后根据州的情况 也许这会让你丧命 
And then depending on the state, maybe that kills you,

1820
01:37:14,540 --> 01:37:17,130
也许那会杀死敌人 也许什么都不会发生
maybe that kills the enemy, maybe nothing happens,

1821
01:37:17,130 --> 01:37:18,350
也许你变得所向披靡 
maybe you become invincible.

1822
01:37:18,350 --> 01:37:21,200
也许你撞上了一个通电的游戏物体 
Maybe you collide with a power-up game object,

1823
01:37:21,200 --> 01:37:26,570
而这种动力触发了你自己 玩家 无敌是真的 
and that power-up triggers your self.player.invincible is true.

1824
01:37:26,570 --> 01:37:29,430
然后如果self.player.incelble是真的 
And then if self.player.invincible is true,

1825
01:37:29,430 --> 01:37:32,060
然后 也许你可以用彩虹动画来渲染他 
then maybe you render him with a rainbow animation.

1826
01:37:32,060 --> 01:37:35,960
然后在任何他会与敌人相撞并死亡的活动中 
And then in any of the functions where he would collide and die with an enemy,

1827
01:37:35,960 --> 01:37:38,160
他不再死了 他只是杀了他们 
he no longer dies, he just kills them.

1828
01:37:38,160 --> 01:37:44,690
这就是你如何与物体互动的主旨
So that's sort of the gist behind how you would interact with objects

1829
01:37:44,690 --> 01:37:46,520
以及如何处理它 
and how to process it.

1830
01:37:46,520 --> 01:37:50,160
游戏对象不同 
Game objects are different.

1831
01:37:50,160 --> 01:37:54,470
就像我之前说的 这些是我们可以看到的一些物体的例子 
Like I said earlier, these are examples of some of the objects here we can see.

1832
01:37:54,470 --> 01:37:58,100
左下角的宝石都在发行版中 
The gems on the bottom left there are all in the distro.

1833
01:37:58,100 --> 01:38:00,740
如果你碰到一个街区--如果我们有几分钟的时间 
If you hit a block-- and if we have a few minutes,

1834
01:38:00,740 --> 01:38:02,690
我会很快地展示给你们看它是怎么工作的--
I'll show you really quickly how that works--

1835
01:38:02,690 --> 01:38:06,590
如果你击中一个格挡 你将有机会产生一个宝石 
if you hit a block, you'll have a chance to spawn a gem.

1836
01:38:06,590 --> 01:38:11,000
如果你收集了gen--也就是说如果你与那个游戏物体相撞--
If you collect the gen-- which means if you collide with that game object--

1837
01:38:11,000 --> 01:38:13,406
把你的分数加100
increment your score 100.

1838
01:38:13,406 --> 01:38:16,280
这些都是我没有时间实现的其他对象 
These are all other objects that I didn't have any time to implement.

1839
01:38:16,280 --> 01:38:21,366
但就在大门口 只是作为一个心理练习 
But just off the gate, just as a mental exercise,

1840
01:38:21,366 --> 01:38:23,240
你觉得我们该怎么做梯子
how do you think we could implement a ladder?

1841
01:38:26,570 --> 01:38:28,760
是啊
Yeah.

1842
01:38:28,760 --> 01:38:30,700
观众：你只会有一个攀登状态 
AUDIENCE: You would just have a climb state.

1843
01:38:30,700 --> 01:38:34,136
如果玩家触摸梯子并按下某个键 
And if the player is touching a ladder and presses a certain key,

1844
01:38:34,136 --> 01:38:37,010
它们会进入爬升状态 这会使它们上升 
they would enter the climb state, and that would cause them to go up.

1845
01:38:37,010 --> 01:38:37,926
科尔顿·奥格登：正确 
COLTON OGDEN: Correct.

1846
01:38:37,926 --> 01:38:41,990
托尼说如果他们爬上梯子 
So what Tony said was if they go onto a ladder,

1847
01:38:41,990 --> 01:38:43,820
它们应该进入爬升状态 
they should go into a climb state.

1848
01:38:43,820 --> 01:38:45,861
取决于它们是否处于爬升状态
And depending on whether they're in a climb state

1849
01:38:45,861 --> 01:38:49,540
如果他们按下一个按钮 他们应该上升或下降 
or not, if they press a button, they should go up or down.

1850
01:38:49,540 --> 01:38:50,870
然后你会检查 
And then you would check.

1851
01:38:50,870 --> 01:38:54,140
如果他们在梯子的顶端 离开攀登状态 
If they're at the top of the ladder, get off the climb state,

1852
01:38:54,140 --> 01:38:56,060
进入步行状态 
go into a walk state.

1853
01:38:56,060 --> 01:38:59,375
或者如果他们在梯子的底部 进入步行状态 
Or if they're at the bottom of the ladder, go into a walk state.

1854
01:38:59,375 --> 01:39:02,000
这只是另一个游戏对象 你只是碰撞 
And that's just another game object that you just collide with,

1855
01:39:02,000 --> 01:39:03,841
对你来说这是一个新的状态
and then it's a new state for you.

1856
01:39:03,841 --> 01:39:04,340
是的
Yes.

1857
01:39:04,340 --> 01:39:06,288
观众：你可能真的想让它处于一个秋天的状态 
AUDIENCE: You may actually want it in a fall state,

1858
01:39:06,288 --> 01:39:08,885
因为这样你就可以有一个梯子 实际上不去任何地方 
because that way you could have a ladder that doesn't actually go anywhere,

1859
01:39:08,885 --> 01:39:09,926
只会让你更高
it just gives you height.

1860
01:39:09,926 --> 01:39:13,481
但你可以用它来跳过宽的缝隙 
But you could use that to jump over wide gaps.

1861
01:39:13,481 --> 01:39:15,230
科尔顿·奥格登：托尼说你可以
COLTON OGDEN: What Tony said was you could

1862
01:39:15,230 --> 01:39:17,980
有能力从梯子上跳下来
have the ability to jump off a ladder.

1863
01:39:17,980 --> 01:39:19,540
你是这么说的吗是的.
Is that what you Said Yeah.

1864
01:39:19,540 --> 01:39:21,920
从梯子上跳下来的能力 这样你就可以把它当作障碍物 
The ability to jump off a ladder so that you can then use it as an obstacle.

1865
01:39:21,920 --> 01:39:22,878
这是绝对正确的 
That's absolutely true.

1866
01:39:22,878 --> 01:39:26,950
实际上 我们在这里看到的模型 很难看出来 
Actually, in the mock up that we saw up here, it's super hard to see.

1867
01:39:26,950 --> 01:39:28,925
我看看能不能放大 
I'll see if I can maybe zoom in on it here.

1868
01:39:35,920 --> 01:39:41,740
马里奥 马里奥 图形 然后它被称为全张 
Mario, Mario, graphics, and then it's called full sheet.

1869
01:39:41,740 --> 01:39:46,470
我在这堂课中使用的整个工作表都被称为fullsheet.png 
The whole entire sheet that I used for this lecture is called fullsheet.png.

1870
01:39:46,470 --> 01:39:49,560
我不知道那是什么 
I don't know what that is.

1871
01:39:49,560 --> 01:39:56,886
所以如果你把这里放大很高 我们可以有效地看到
So if you zoom in really high here, we can see effectively

1872
01:39:56,886 --> 01:39:58,010
你所指的是--
what you were alluding to--

1873
01:39:58,010 --> 01:40:01,181
就在这里 这个小小的绳索 
right here, this little rope thing.

1874
01:40:01,181 --> 01:40:03,180
我猜为了这个模型的缘故
I'm guessing for the sake of this mock up that's

1875
01:40:03,180 --> 01:40:04,680
他们想要说明的是 
what they were trying to illustrate.

1876
01:40:04,680 --> 01:40:07,970
但是你有一个游戏对象 可以让你进入攀登状态 
But you have a game object that lets you go into a climb state.

1877
01:40:07,970 --> 01:40:11,090
不管它是梯子还是绳子 
Whether it's a ladder or whether it's a rope,

1878
01:40:11,090 --> 01:40:15,636
只需为玩家添加一个新状态 
just add a new state for the player.

1879
01:40:15,636 --> 01:40:18,260
如果他们处于攀爬状态 那么我们就有了这个新的动画
If they're in that climb state, then we have this new animation

1880
01:40:18,260 --> 01:40:21,830
这是我们之前在床单上看到的 这是他们的背面或正面 
which we saw in the sheet earlier, which was their back or their front.

1881
01:40:21,830 --> 01:40:24,830
然后他们只是爬上它 然后更新它
And then they just climb up it and just update it

1882
01:40:24,830 --> 01:40:27,881
如果他们在梯子上向上或向下移动 
if they're moving up or down the ladder.

1883
01:40:27,881 --> 01:40:29,880
然后给他们跳下来的能力 
And then just give them the ability to jump off.

1884
01:40:29,880 --> 01:40:32,255
然后 当你到达顶端或底部时 就下车 
And then when you get to the top or bottom, just get off.

1885
01:40:33,950 --> 01:40:37,580
你可以想到很多同样的事情 有很多这样的障碍 
And you could think a lot of the same thing with a lot of these obstacles,

1886
01:40:37,580 --> 01:40:39,410
就像这里的尖刺 
like the spikes here.

1887
01:40:39,410 --> 01:40:43,410
如果你在跳跃 你击中了它 你可能会死 
If you're jumping and you hit it, you should probably die.

1888
01:40:43,410 --> 01:40:50,070
因此 您将检查对象ID是否可能等于Spikes
And so you would check for if the object.ID maybe is equal to spikes

1889
01:40:50,070 --> 01:40:55,230
或者是否反对致命等于真 
or whether object.lethal equals true.

1890
01:40:55,230 --> 01:40:56,850
这个也是一样的 
Same thing with this one.

1891
01:40:56,850 --> 01:41:01,410
然后有些障碍完全是表面上的 就像这里的蘑菇 
And then some obstacles are completely cosmetic, like this mushroom here.

1892
01:41:01,410 --> 01:41:04,770
就发行版而言 灌木丛、蘑菇和仙人掌
In the case of the distro, bushes and mushrooms and cacti

1893
01:41:04,770 --> 01:41:07,230
所有这些东西都完全是表面上的 
and all those sorts of things are just completely cosmetic,

1894
01:41:07,230 --> 01:41:08,310
这样你就可以穿行其中了 
so you can walk through them.

1895
01:41:08,310 --> 01:41:11,130
它们不会触发碰撞 但会被渲染为游戏对象 
They don't trigger collision, but they're rendered as game objects.

1896
01:41:11,130 --> 01:41:12,546
它们不是瓷砖网格的一部分 
They're not part of the tile grid.

1897
01:41:17,180 --> 01:41:19,560
它们的处理方式不同于瓷砖 
They don't get processed in the same way as tiles.

1898
01:41:19,560 --> 01:41:20,910
它们不是存储在y x中 
They're not stored in the y, x.

1899
01:41:24,930 --> 01:41:27,760
这就是我们开始思考物体的有效方式
So that's effectively how we can start thinking about objects

1900
01:41:27,760 --> 01:41:29,010
以及如何赋予他们行为举止 
and how to give them behavior.

1901
01:41:29,010 --> 01:41:32,400
作业的一部分将是添加一面旗帜 
Part of the assignment is going to be adding a flag.

1902
01:41:32,400 --> 01:41:34,300
所以这面旗帜在精灵纸上 
So this flag is in the sprite sheet.

1903
01:41:34,300 --> 01:41:36,150
所以你要做的是--
So what you'll do--

1904
01:41:36,150 --> 01:41:38,760
我会在这节课的最后谈到这一点 
and I'll touch on this at the end of the lecture here.

1905
01:41:38,760 --> 01:41:41,910
我们就快到了 
We're getting close to it.

1906
01:41:41,910 --> 01:41:44,490
这些钥匙实际上在右下角--
These keys here actually at the bottom right--

1907
01:41:44,490 --> 01:41:47,150
所以任务的一部分将是--
so part of the assignment will be to--

1908
01:41:47,150 --> 01:41:48,430
它实际上就在这里 
it's actually right here.

1909
01:41:48,430 --> 01:41:50,040
所以我会很快地复习一下 
So I'll go over it really quickly.

1910
01:41:50,040 --> 01:41:52,320
确保玩家总是在坚实的地面上开始 
Ensure the player always starts above solid land.

1911
01:41:52,320 --> 01:41:56,830
在这种情况下 当詹姆斯跑到这里时 你跑了第一个例子 
So in this case, when James came up here and ran, you ran the first example.

1912
01:41:56,830 --> 01:41:58,770
在我们第一次开发这个游戏的时候 
The very first time that we spawned the game,

1913
01:41:58,770 --> 01:42:06,180
这就在球员在x1产生的地方产生了一个裂痕 
it generated a chasm right where the player spawned at x1.

1914
01:42:06,180 --> 01:42:08,480
因此 如果发生这种情况 他就会坠落而死 
And so he just falls to his death if that happens.

1915
01:42:11,332 --> 01:42:13,290
就在门口 有人有什么想法吗？
Just right off the gate, anybody have any ideas

1916
01:42:13,290 --> 01:42:16,920
至于我们可以做些什么来检查我们是否在坚实的陆地上 
as to what we could do to check to see if we're at solid land,

1917
01:42:16,920 --> 01:42:21,321
假设玩家的默认开始时间是x1？
assuming that the player's default start is at x1?

1918
01:42:21,321 --> 01:42:24,243
观众：在那块瓷砖上 检查它是不是实心的 
AUDIENCE: At that tile, check if it's solid.

1919
01:42:24,243 --> 01:42:27,824
如果不是 那么只需将它移到x上 直到它为真 
If not, then just move it there over x until it's true.

1920
01:42:27,824 --> 01:42:28,615
科尔顿·奥格登：是的 
COLTON OGDEN: Yeah.

1921
01:42:28,615 --> 01:42:31,590
我们可能想要做的是沿着柱子往下看 
What we probably want to do is look all the way down the column,

1922
01:42:31,590 --> 01:42:36,400
因为我们从最高处开始 
because we start towards the top.

1923
01:42:36,400 --> 01:42:39,610
如果我们发现下面没有瓷砖--这只是一个纯粹的裂缝--
If we find that there's no tiles down there-- it's just pure chasm--

1924
01:42:39,610 --> 01:42:42,660
我们可能想换掉这名球员 
we probably want to shift the player.

1925
01:42:42,660 --> 01:42:45,720
然后随机的钥匙和锁--
And then random keys and locks--

1926
01:42:45,720 --> 01:42:50,760
让我打开LevelMaker 这样我们就可以看到您将与什么交互 
let me open up LevelMaker so we can see what you'll be interacting with,

1927
01:42:50,760 --> 01:42:53,940
因为您实际上要做的大部分事情都是在LevelMaker中完成的 
because most of what you'll be doing actually is in LevelMaker.

1928
01:42:58,080 --> 01:43:01,830
它做了很多我们以前用数学做的事情 随机的 
It does a lot of what we did before with just math.random,

1929
01:43:01,830 --> 01:43:05,670
然后它会插入到物体中 
and then it will insert into objects.

1930
01:43:05,670 --> 01:43:10,290
所以物体在这里是一张桌子 
So objects is a table here.

1931
01:43:10,290 --> 01:43:14,410
它会根据某种逻辑插入一个游戏对象 
It will insert a game object depending on some logic.

1932
01:43:14,410 --> 01:43:17,627
所以在这种情况下 如果我们要产生一根柱子 
So in this case, if we're generating a pillar,

1933
01:43:17,627 --> 01:43:19,710
我们有机会在柱子上长出灌木丛 
we have a chance to generate a bush on the pillar.

1934
01:43:19,710 --> 01:43:23,940
因此 如果math.dom(8)是1 那么在本例中 我们已经生成了一个柱 
So if math.random(8) is 1, in this case, we're already generating a pillar.

1935
01:43:23,940 --> 01:43:26,935
所以我们有一个额外的机会 这是在机会之上
So we have an additional chance that's on top of the chance

1936
01:43:26,935 --> 01:43:27,960
以产生一根柱子--
to generated a pillar--

1937
01:43:27,960 --> 01:43:33,180
所以基本上 我认为在那个特定的迭代中有64%的几率
so basically, I think it's a 1 in 64 chance on that particular iteration

1938
01:43:33,180 --> 01:43:36,170
用灌木造一根柱子 
to generate a pillar with a bush.

1939
01:43:39,010 --> 01:43:42,330
您只需将新的游戏对象添加到对象中 
You just add a new game object to objects.

1940
01:43:42,330 --> 01:43:44,710
在本例中 这是游戏对象的构造函数 
In this case, this is the constructor for a game object.

1941
01:43:44,710 --> 01:43:48,420
你给它一个x y 宽度 高度 然后是一个框架 
You give it an x, y, width, height, and then a frame.

1942
01:43:48,420 --> 01:43:52,230
然后 该帧相对于与纹理匹配的任何四元表
And then the frame is relative to whatever quad table matches the texture

1943
01:43:52,230 --> 01:43:52,770
这里有一根线 
string here.

1944
01:43:52,770 --> 01:43:56,185
所以灌木丛就是纹理 所以灌木丛中的任何四边形
So bushes is the texture, and so whatever quad in bushes

1945
01:43:56,185 --> 01:43:57,060
你想给它--
you want to give it--

1946
01:43:57,060 --> 01:44:02,340
在这种情况下 我们只是给了它一个随机的帧 
in this case, we just gave it a random frame from that.

1947
01:44:02,340 --> 01:44:05,600
然后 许多相同的逻辑也适用于其他部分 
And then a lot of the same logic applies to other parts.

1948
01:44:05,600 --> 01:44:08,550
这是我们在平地上生长灌木丛的另一个部分 
This is another part where we generate bushes just on flat land.

1949
01:44:08,550 --> 01:44:10,240
我们有机会产生一个积木--
We have a chance to generate a block--

1950
01:44:10,240 --> 01:44:13,330
十分之一的几率这是一个跳跃障碍 
1 in 10 chance this is a jump block.

1951
01:44:13,330 --> 01:44:16,350
所以这里我们有纹理 x y 宽度 高度 边框 
So here we have texture, x, y, width, height, frame.

1952
01:44:16,350 --> 01:44:18,570
注意 我们有可碰撞的是真的 这是
Notice that we have collidable is true, and this

1953
01:44:18,570 --> 01:44:22,980
就是我们如何测试瓷砖是否可碰撞 
is how we can test to see whether a tile is collidable or not.

1954
01:44:22,980 --> 01:44:26,140
Hit为FALSE 意味着我们还没有达到它 
Hit is false, meaning that we haven't hit it yet.

1955
01:44:26,140 --> 01:44:33,870
如果我们击中了它 那么我们基本上执行这个代码--onCollide被调用 
And if we have hit it, then we do this code basically-- onCollide gets called.

1956
01:44:37,170 --> 01:44:40,865
您可以看到在冲突代码中调用它的位置--
You can see where this gets called in the collision code for--

1957
01:44:43,800 --> 01:44:45,165
如果我们看球员的话 
if we look in Player.

1958
01:44:52,800 --> 01:44:55,200
玩家有检查左碰撞 检查右碰撞 
Player has check left collisions, check right collisions,

1959
01:44:55,200 --> 01:44:59,280
并检查对象碰撞 
and check object collisions.

1960
01:44:59,280 --> 01:45:02,145
它没有向上和向下检查碰撞 
It doesn't have check up and down collisions.

1961
01:45:02,145 --> 01:45:04,020
对于这两种情况都有一个角落的案例
There is a corner case for both of those such

1962
01:45:04,020 --> 01:45:05,519
这种逻辑必须被复制 
that the logic had to be duplicated.

1963
01:45:05,519 --> 01:45:06,960
我忘记了确切的原因 
I forget exactly why.

1964
01:45:06,960 --> 01:45:10,550
但你基本上得到了一个你要检查的对象的列表 
But you basically get a list of objects that you check for.

1965
01:45:15,840 --> 01:45:17,856
哦 原因是当你得到
Oh, the reason why is because when you get

1966
01:45:17,856 --> 01:45:19,980
当你处于跳跃状态时碰撞的物体 
the collided objects when you're in the jump state,

1967
01:45:19,980 --> 01:45:22,840
您可以触发onCollide函数 
you trigger the onCollide function.

1968
01:45:22,840 --> 01:45:26,560
那么 让我们来看看PlayerJumpState 
So let's go to PlayerJumpState.

1969
01:45:26,560 --> 01:45:34,434
如果我们处于跳跃状态 这基本上就是我们
If we're in the jump state, this is where we would basically

1970
01:45:34,434 --> 01:45:37,350
检查是否有任何物体与玩家发生碰撞 
check to see if we've gotten any objects that collide with the player.

1971
01:45:37,350 --> 01:45:41,690
如果它是实心的 则调用其onCollide函数object.onCollide 然后
If it's solid, call its onCollide function, object.onCollide, and then

1972
01:45:41,690 --> 01:45:44,720
基本上 我们只传入对象本身 
we just pass in the object itself, basically.

1973
01:45:44,720 --> 01:45:48,100
所以如果你回到LevelMaker 那就是
And so if you go back to LevelMaker, that's

1974
01:45:48,100 --> 01:45:50,290
在那里我们编写onCollide函数 
where we write the onCollide function.

1975
01:45:50,290 --> 01:45:55,000
我们在此处的游戏对象中编写onCollide函数 
We write the onCollide function within the game object here.

1976
01:45:55,000 --> 01:45:56,750
所以我们就给它一个OnCollide 记住 
So we just give it an onCollide, remember,

1977
01:45:56,750 --> 01:45:58,940
因为函数是一等公民 
because functions are first class citizens.

1978
01:45:58,940 --> 01:46:03,000
我们可以这样说 onCollide获取函数obj 
We can just say onCollide gets function obj,

1979
01:46:03,000 --> 01:46:06,440
其中obj将成为这个对象 
where obj is going to be this object.

1980
01:46:06,440 --> 01:46:12,130
如果它还没有被击中 五分之一的机会刷新宝石-
If it wasn't hit already, one in five chance to spawn a gem--

1981
01:46:12,130 --> 01:46:14,260
所以要创造一个宝石 
so going to create a gem.

1982
01:46:14,260 --> 01:46:16,320
里面的东西都一样
It's got all the same stuff in it.

1983
01:46:16,320 --> 01:46:20,710
在这种情况下 它有自己的函数onConversion 
In this case, it has its own function called onConsume.

1984
01:46:20,710 --> 01:46:24,289
onConclusion接受一个玩家和一个对象 
onConsume takes a player and an object.

1985
01:46:24,289 --> 01:46:26,080
顺便说一下 这都是武断的 
And then this is all arbitrary, by the way.

1986
01:46:26,080 --> 01:46:27,980
你可以创建任何你想要的功能 
You can create whatever functions you want.

1987
01:46:27,980 --> 01:46:31,570
这些都是回调函数 有效的 
These are callback functions, effectively.

1988
01:46:31,570 --> 01:46:35,050
我们只需要播放拾音器的声音 然后在分数上加100 
We're just going to play the pickup sound and then add 100 to our score.

1989
01:46:35,050 --> 01:46:38,830
然后在这里 如果我们真的得到了一颗宝石 
And then here, in the event that we did get a gem,

1990
01:46:38,830 --> 01:46:41,920
我们在0.1秒的时间内补间它 
we tween it over the course of 0.1 seconds.

1991
01:46:41,920 --> 01:46:46,040
我们把它的y从下面的块到上面 
We tween its y to be from below the block to up above,

1992
01:46:46,040 --> 01:46:49,070
所以它有一个向上的动画效果 
so it has an upwards animation, effectively.

1993
01:46:49,070 --> 01:46:50,820
然后我们有另一个声音播放 
And then we have another sound that plays.

1994
01:46:50,820 --> 01:46:53,111
但这就是我们生成游戏对象的有效方式 
But that's effectively how we're spawning game objects.

1995
01:46:53,111 --> 01:46:56,787
游戏对象有纹理 x y 宽度 高度 然后
Game objects have textures, x, y, width, height, and then

1996
01:46:56,787 --> 01:46:58,870
你可以给他们回调函数 
you can give them callback functions that you then

1997
01:46:58,870 --> 01:47:01,360
执行任何与你相关的事情
execute wherever it's relevant to you.

1998
01:47:01,360 --> 01:47:05,650
在这种情况下 你只需要担心onCollide 
In this case, you'll only really need to worry about onCollide,

1999
01:47:05,650 --> 01:47:12,310
因为任务是创建随机密钥和锁 
because the assignment is create random keys and locks.

2000
01:47:12,310 --> 01:47:15,380
它们必须是相同的颜色 但你可以随机选择它们 
They have to be the same color, but you can choose them at random.

2001
01:47:15,380 --> 01:47:18,190
如果玩家碰到钥匙 
If the player collides with the key, then he

2002
01:47:18,190 --> 01:47:21,820
可能会得到一些标志 比如key获得为true
should probably get some flag that's like key obtained is true

2003
01:47:21,820 --> 01:47:23,140
或者类似的东西
or something like that.

2004
01:47:23,140 --> 01:47:27,900
然后你去关卡中生成的区块 
And then you go to the block that spawns in the level,

2005
01:47:27,900 --> 01:47:31,150
所以应该生成一个颜色相同块 
so you should spawn a block with that same color.

2006
01:47:31,150 --> 01:47:37,300
然后在碰撞 你应该解锁它 所以摆脱块
And then on collide, you should unlock it, so get rid of the block

2007
01:47:37,300 --> 01:47:40,900
然后产生一个新的游戏对象--
and then spawn a new game object--

2008
01:47:40,900 --> 01:47:42,250
国旗
the flag.

2009
01:47:42,250 --> 01:47:44,770
然后这个标志将有自己的碰撞 
And then that flag will have its own on collide.

2010
01:47:44,770 --> 01:47:47,830
当你撞到旗子时 重新开始 
And when you collide with the flag, restart the level.

2011
01:47:47,830 --> 01:47:51,040
这实际上就是问题集的要点 
And that's effectively the gist behind the problem set.

2012
01:47:51,040 --> 01:47:52,720
所以可能不需要...
So it probably shouldn't take--

2013
01:47:52,720 --> 01:47:57,570
我会说大概40或50行代码就可以了 
I would say probably maybe 40 or 50 lines of code probably should do it.

2014
01:47:57,570 --> 01:47:59,530
观众：那个游戏物体--
AUDIENCE: That game object--

2015
01:47:59,530 --> 01:48:01,762
是在上课吗
was that a class?

2016
01:48:01,762 --> 01:48:02,470
这不是桌子 
It's not a table.

2017
01:48:02,470 --> 01:48:03,460
那是什么？
What is that?

2018
01:48:03,460 --> 01:48:05,200
科尔顿·奥格登：这是一个类 
COLTON OGDEN: It is a class.

2019
01:48:05,200 --> 01:48:06,460
有一个GameObject类 
There's a GameObject class.

2020
01:48:06,460 --> 01:48:11,290
游戏对象基本上是--我意识到我没有太多地触及它 
A game object is basically-- and I realize I didn't touch on it too much.

2021
01:48:11,290 --> 01:48:18,760
在这个发行版的上下文中 您几乎可以将其视为一个实体 
In the context of this distro, you could almost think of it as an entity.

2022
01:48:18,760 --> 01:48:21,640
在这种情况下 我所做的是区分
In this case, what I've done is I've differentiated

2023
01:48:21,640 --> 01:48:24,040
在生物和非生物之间
between living things and non-living things

2024
01:48:24,040 --> 01:48:28,960
是实体还是游戏对象 这是一种半随意的区别 
as being entities versus game objects, which is a semi-arbitrary distinction.

2025
01:48:28,960 --> 01:48:31,870
但对于这样一个小项目来说 这是有意义的 
But for a small project like this, it makes sense.

2026
01:48:31,870 --> 01:48:37,390
对于大型项目 我可能会将所有内容都创建为一个实体
For a large project, I would probably create everything as an entity

2027
01:48:37,390 --> 01:48:39,820
然后给出不同类型的实体
and then give different kinds of entities

2028
01:48:39,820 --> 01:48:41,654
它们自己的行为和它们自己的组件 
their own behavior and their own components,

2029
01:48:41,654 --> 01:48:43,986
有点像您处理实体组件系统的方式 
sort of like how you do with an entity component system.

2030
01:48:43,986 --> 01:48:46,305
观众：在Lua中有两种创建类的方法吗 
AUDIENCE: Are there two ways to create a class in Lua,

2031
01:48:46,305 --> 01:48:50,530
一个带大括号的和一个带正括号的？
one with the curly brackets and one with regular parentheses?

2032
01:48:50,530 --> 01:48:53,510
科尔顿·奥格登：事实上是有的 
COLTON OGDEN: There is, actually.

2033
01:48:53,510 --> 01:48:56,650
所以问题是 在Lua中创建类的方法不止一种吗
So the question was, is there more than one way to create a class in Lua

2034
01:48:56,650 --> 01:48:59,690
无论是圆括号还是花括号？
whether it's parentheses or curly brackets?

2035
01:48:59,690 --> 01:49:00,190
是 
Yes.

2036
01:49:00,190 --> 01:49:02,315
我想我从来没有真正谈过这个 
I don't think I've ever actually talked about this.

2037
01:49:05,430 --> 01:49:08,290
让我们回到LevelMaker 
Let's go back to LevelMaker.

2038
01:49:08,290 --> 01:49:12,550
如果您实例化一个类和该类
If you instantiate a class and that class

2039
01:49:12,550 --> 01:49:22,930
只接受一个表作为它的唯一参数 你可以直接传入这个 
takes in just a table as its only argument, you can just pass in this.

2040
01:49:22,930 --> 01:49:25,790
这实际上就是参数表 
This effectively is that argument table.

2041
01:49:25,790 --> 01:49:27,400
你不需要括号 
You don't need parentheses.

2042
01:49:27,400 --> 01:49:30,141
它有效地做到了这一点--
It's effectively doing this--

2043
01:49:30,141 --> 01:49:32,140
同样的事情 只是你不需要括号 
same thing, only you don't need the parentheses.

2044
01:49:32,140 --> 01:49:35,220
观众：然后那是一张被传进来的桌子？
AUDIENCE: And then that's a table that's being passed in?

2045
01:49:35,220 --> 01:49:37,820
科尔顿·奥格登：正确 
COLTON OGDEN: Correct.

2046
01:49:37,820 --> 01:49:40,840
这只是实例化的另一种形式
It's just an alternative form of instantiation

2047
01:49:40,840 --> 01:49:44,394
关于那些只把表作为他们什么时候的论据的东西
on things that only take a table as their argument for when

2048
01:49:44,394 --> 01:49:45,310
它们被实例化 
they get instantiated.

2049
01:49:45,310 --> 01:49:47,680
观众：那样的话你们只能有一张桌子吗？
AUDIENCE: And you can only have one table in that case?

2050
01:49:47,680 --> 01:49:49,935
科尔顿·奥格登：正确 是的 
COLTON OGDEN: Correct, yes.

2051
01:49:49,935 --> 01:49:53,572
观众：创建一个新的班级不是更容易吗？
AUDIENCE: Wouldn't it be easier to create a new class which

2052
01:49:53,572 --> 01:49:59,392
会有自己的一组游戏对象 所以你
would have its own set of game objects so you

2053
01:49:59,392 --> 01:50:04,260
将创建一个GEM 它将是Helper Dot Gem 它
would create a gem which would be helper dot gem, which

2054
01:50:04,260 --> 01:50:06,754
会反过来创建一个游戏对象吗？
would in turn create a game object?

2055
01:50:06,754 --> 01:50:08,628
科尔顿·奥格登：你能再说一次吗？
COLTON OGDEN: Can you say that one more time?

2056
01:50:08,628 --> 01:50:10,500
观众：这很难解释 
AUDIENCE: It's kind of hard to explain.

2057
01:50:10,500 --> 01:50:15,420
创建另一个类不是更容易吗？
Wouldn't it be easier to create another class which

2058
01:50:15,420 --> 01:50:19,028
会有你的宝石和所有东西 你的宝石在那个班级里
would have your gem and everything, and your gem in that class

2059
01:50:19,028 --> 01:50:20,504
会是一个游戏对象吗？
would be a game object?

2060
01:50:20,504 --> 01:50:22,472
但在这堂课上 当你想要宝石的时候 
But in this class, when you wanted a gem,

2061
01:50:22,472 --> 01:50:27,400
你会说本地gem等同于helper类的点gem 
you would say local gem equals helper class dot gem.

2062
01:50:27,400 --> 01:50:30,750
科尔顿·奥格登：问题是 不是吗？
COLTON OGDEN: The question was, wouldn't it

2063
01:50:30,750 --> 01:50:37,120
创建一个helper类来实例化gem会更容易吗？
be easier to create a helper class that would allow you to instantiate gems?

2064
01:50:37,120 --> 01:50:37,620
有可能 
Possibly.

2065
01:50:40,260 --> 01:50:45,690
我想如果你把这个设计得更有力一点 
I think if you were going to design this a little bit more robustly,

2066
01:50:45,690 --> 01:50:47,490
如果这是一场更大的比赛 
and if this were going to be a larger game,

2067
01:50:47,490 --> 01:50:51,539
然后 您只需为块、宝石等创建一个子类 
then you would just create a subclass for blocks, gems, et cetera.

2068
01:50:51,539 --> 01:50:54,330
缩小发行版中的文件数量并进行排序
To shrink the number of files that we had in the distro and to sort

2069
01:50:54,330 --> 01:50:59,040
将所有东西整合在一起 并将所有级别代码放在一起
of consolidate everything together and put all of the level code together

2070
01:50:59,040 --> 01:51:04,440
在其中一个地方 我决定只将GameObject创建为一个抽象类
in one spot, I decided to just create GameObject as an abstract class that

2071
01:51:04,440 --> 01:51:07,950
然后 您只需在实际的
you could then just create your own behavior for within the actual

2072
01:51:07,950 --> 01:51:11,340
构造函数--这是这里的这一位 这只是表格--
constructor-- which is this bit here, which is just the table--

2073
01:51:11,340 --> 01:51:14,742
然后允许您覆盖onCollide和onConsumer函数 
and then allow you to override the onCollide and onConsume functions.

2074
01:51:14,742 --> 01:51:16,950
你实际上可以给它任何你想要的功能 
You can actually give it whatever functions you want.

2075
01:51:16,950 --> 01:51:22,540
您可以给它指定一些任意命名的函数 然后稍后对其进行测试 
You could give this some arbitrary named function and then test for it later.

2076
01:51:22,540 --> 01:51:26,490
这几乎就像是一种晦涩的继承方式 
This is almost like an obscure way of inheritance.

2077
01:51:26,490 --> 01:51:31,980
但我认为 如果我设计这件事的目标是让它成为真正的
But I think if I were to engineer this with the goal of making it a really

2078
01:51:31,980 --> 01:51:34,260
在大型比赛中 我只会把它分成两类 
large game, I would just subclass.

2079
01:51:34,260 --> 01:51:38,850
我会为GEM创建一个类 为BLOCK创建一个类 为布什创建一个类 
I would just create a class for gem, a class for block, a class for bush,

2080
01:51:38,850 --> 01:51:40,830
等等 等等 
et cetera, et cetera.

2081
01:51:40,830 --> 01:51:43,170
对于这个例子来说 这并不是严格必要的 
It wasn't strictly necessary for this example,

2082
01:51:43,170 --> 01:51:45,090
所以我们最终把所有东西都保留了一点
so we ended up keeping everything a little bit

2083
01:51:45,090 --> 01:51:52,470
在某种意义上更抽象--更一般的目的 
more abstract in a sense-- a little bit more general purpose.

2084
01:51:52,470 --> 01:51:57,790
但是 是的 你绝对可以为这些人创建类 
But yeah, you could definitely create classes for those.

2085
01:51:57,790 --> 01:52:00,060
如果您处于实体组件系统中 
And if you were in an entity component system,

2086
01:52:00,060 --> 01:52:03,405
你可以有一个可消耗的部件 
you could have a consumable component.

2087
01:52:03,405 --> 01:52:05,280
然后 该消耗性组件将会
And then that consumable component would then

2088
01:52:05,280 --> 01:52:09,510
允许你给它一些影响玩家的行为 当
allow you to give it some sort of behavior that affects the player when

2089
01:52:09,510 --> 01:52:11,221
玩家消耗该物品 
the player consumes that object.

2090
01:52:11,221 --> 01:52:13,470
在本例中 宝石是一种消耗品 因此您只需
In this case, a gem is a consumable, so you would just

2091
01:52:13,470 --> 01:52:16,290
给它一个具有宝石质地的可消耗成分
give it a consumable component with a texture of the gem

2092
01:52:16,290 --> 01:52:18,510
然后给它一个回调函数 
and then give it a callback function that

2093
01:52:18,510 --> 01:52:20,025
只会增加玩家的分数
just increments the player's score.

2094
01:52:20,025 --> 01:52:24,060
你可以用10到15行代码来实现 
You could probably put that in 10 or 15 lines of code.

2095
01:52:24,060 --> 01:52:25,330
很简单的 
It would be pretty easy.

2096
01:52:25,330 --> 01:52:29,680
然后块将是一个产卵器组件 
And then blocks would be a spawner component,

2097
01:52:29,680 --> 01:52:31,170
这样它们才有机会产卵
so they have a chance to spawn.

2098
01:52:31,170 --> 01:52:36,560
然后你会传入spawner组件一个gem 
And then you would pass in that spawner component a gem maybe,

2099
01:52:36,560 --> 01:52:40,560
这样它就有机会将你放入产卵器的宝石产卵
so it would have a chance to spawn the gem that you passed into the spawner

2100
01:52:40,560 --> 01:52:46,030
然后是一个固体成分 这是固体 
component-- and then also a solid component to say, oh, this is solid.

2101
01:52:46,030 --> 01:52:48,102
所以如果我撞到它 我应该会引发碰撞
So if I hit it, I should trigger a collision

2102
01:52:48,102 --> 01:52:49,560
却无法穿过它
and not be able to walk through it.

2103
01:52:49,560 --> 01:52:53,760
所以你只需要把这些组件叠加起来 
So you just layer on these components.

2104
01:52:53,760 --> 01:52:58,650
我鼓励你们思考这种作曲方式
I would encourage you to think about this way of composing

2105
01:52:58,650 --> 01:53:02,340
你的对象有点 特别是当我们走向统一 
your objects a little bit, particularly as we get towards Unity, which

2106
01:53:02,340 --> 01:53:07,560
很多人使用了这个概念 
makes a lot of use of this concept.

2107
01:53:07,560 --> 01:53:10,290
简而言之 是的 
In short, yes.

2108
01:53:10,290 --> 01:53:12,326
我想差不多就这些了 
I think that's pretty much everything.

2109
01:53:12,326 --> 01:53:13,200
我先走了 
Let me just go ahead.

2110
01:53:13,200 --> 01:53:18,090
我们快没时间了但我说了再说一次
We're running out of time here, but like I said, one more time--

2111
01:53:18,090 --> 01:53:21,504
确保播放器开始以上坚实的土地 随机颜色的关键和锁 
make sure the player starts above solid land, random color key and lock,

2112
01:53:21,504 --> 01:53:24,420
然后确保当你拿到钥匙的时候 你可以打开锁 
and then make sure that when you get the key, you can unlock the lock,

2113
01:53:24,420 --> 01:53:25,920
这就产生了目标 
and that spawns the goal.

2114
01:53:25,920 --> 01:53:30,540
这些都是你可以添加到LevelMaker类中的 
So this is all something you can just add to the LevelMaker class,

2115
01:53:30,540 --> 01:53:35,620
这一切都将与你的游戏水平的方式 
and it will all work with your game level that way.

2116
01:53:35,620 --> 01:53:39,210
然后你触摸目标旗 然后重生的水平 
And then you touch the goal flag, then respawn the level.

2117
01:53:39,210 --> 01:53:41,520
今天 我们来谈谈《超级马里奥兄弟》 
So today, we talked about Super Mario Bros.

2118
01:53:41,520 --> 01:53:44,850
那个时代的另一款任天堂游戏
The other big Nintendo game of that era--

2119
01:53:44,850 --> 01:53:47,700
可以说是有史以来最伟大的电影之一--就是塞尔达 
arguably one of the greatest of all time-- is Zelda.

2120
01:53:47,700 --> 01:53:51,840
所以我们将讨论一个非常简单的塞尔达传说游戏 
So we'll be talking about a very simple Legend of Zelda game,

2121
01:53:51,840 --> 01:53:54,810
我们有一个随机的地牢可以去
where we just have a random dungeon that we can go through,

2122
01:53:54,810 --> 01:53:57,480
一个自上而下的视角 与简单的怪物战斗 
a top down perspective, fight simple monsters,

2123
01:53:57,480 --> 01:54:00,780
开胸炸墙之类的
open chests, blow up walls-- that sort of thing.

2124
01:54:00,780 --> 01:54:02,880
我们将讨论触发器和事件 
We'll talk about triggers and events.

2125
01:54:02,880 --> 01:54:06,530
然后我们再谈受伤的箱子 库存
And then we'll talk about hurt boxes, inventory,

2126
01:54:06,530 --> 01:54:09,950
一个非常简单的GUI 用于打开菜单 
a very simple GUI for opening up a menu, and then world states

2127
01:54:09,950 --> 01:54:13,710
这样我们就能看到哪些门被炸开了
so that we can see which doors have been blasted open so that they

2128
01:54:13,710 --> 01:54:15,840
适当地渲染 诸如此类 
render appropriately and whatnot.

2129
01:54:15,840 --> 01:54:16,970
马里奥就到此为止了 
And that's it for Mario.

2130
01:54:16,970 --> 01:54:17,970
非常感谢您的光临 
Thanks a lot for coming.

2131
01:54:17,970 --> 01:54:20,120
下次再见了 
I'll see you guys next time.
