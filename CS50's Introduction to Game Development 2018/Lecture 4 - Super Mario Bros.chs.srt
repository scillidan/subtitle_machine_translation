1
00:00:00,000 --> 00:00:02,976
[音乐播放]

2
00:00:16,097 --> 00:00:17,430
科尔顿·奥格登：嗨 晚上好 

3
00:00:17,430 --> 00:00:19,970
欢迎来到GD50第四讲 

4
00:00:19,970 --> 00:00:22,140
这是超级马里奥兄弟 

5
00:00:22,140 --> 00:00:23,990
然而 正如这里的幻灯片所示 我们是

6
00:00:23,990 --> 00:00:26,220
而不是使用真正的超级马里奥兄弟精灵床单 

7
00:00:26,220 --> 00:00:27,260
这有点像敲竹杠 

8
00:00:27,260 --> 00:00:28,968
但我发现了一张非常棒的雪碧表

9
00:00:28,968 --> 00:00:33,590
所有的基本瓷砖 我们需要让这件事工作 

10
00:00:33,590 --> 00:00:36,782
在发行版中有一个链接 可以在哪里在线找到它 

11
00:00:36,782 --> 00:00:38,240
我玩得很开心 

12
00:00:38,240 --> 00:00:40,040
所以希望 如果你好奇 也许你

13
00:00:40,040 --> 00:00:43,100
可以用里面的一些精灵去做你自己的事情 

14
00:00:43,100 --> 00:00:48,740
但超级马里奥兄弟--这堂课和作业的实际游戏

15
00:00:48,740 --> 00:00:51,822
基于--这是这里显示的游戏 

16
00:00:51,822 --> 00:00:53,280
我想每个人都知道这是什么 

17
00:00:53,280 --> 00:00:55,238
这可能是有史以来最著名的比赛 

18
00:00:55,238 --> 00:00:57,260
但这款游戏是1985年问世的--

19
00:00:57,260 --> 00:00:59,720
在某种程度上给游戏行业带来了革命 

20
00:00:59,720 --> 00:01:03,890
正是这款游戏将游戏行业从崩溃中拯救出来

21
00:01:03,890 --> 00:01:08,530
在70年代 由于许多糟糕的游戏制作政策

22
00:01:08,530 --> 00:01:11,630
以及公司和低质量保证标准 

23
00:01:11,630 --> 00:01:15,200
它基本上经历了70年代末80年代初的游戏崩盘

24
00:01:15,200 --> 00:01:19,340
并将游戏真正带回了人们意识的前沿 

25
00:01:19,340 --> 00:01:22,700
这款游戏和像塞尔达传奇这样的游戏以及许多其他NES游戏

26
00:01:22,700 --> 00:01:25,280
使任天堂基本上成为视频游戏的霸主

27
00:01:25,280 --> 00:01:27,346
80年代和90年代的工业 

28
00:01:27,346 --> 00:01:29,470
即使在今天 有了像《野性呼吸》这样的游戏 

29
00:01:29,470 --> 00:01:31,670
他们仍在做自己的事 

30
00:01:31,670 --> 00:01:32,900
这是超级马里奥兄弟 

31
00:01:32,900 --> 00:01:34,670
这是一个2D平台 

32
00:01:34,670 --> 00:01:38,270
这基本上意味着你控制着马里奥 他是一名水管工 

33
00:01:38,270 --> 00:01:41,570
他走来走去 站在一边看着他 

34
00:01:41,570 --> 00:01:42,800
他从左走到右 

35
00:01:42,800 --> 00:01:44,130
他能跳上跳下 

36
00:01:44,130 --> 00:01:45,240
他受到重力的影响 

37
00:01:45,240 --> 00:01:46,280
他能打出盖帽 

38
00:01:46,280 --> 00:01:47,420
他能扑向敌人 

39
00:01:47,420 --> 00:01:50,450
他可以顺着管道往下走 有很多层 

40
00:01:50,450 --> 00:01:53,350
在当时 这是一场相当复杂的游戏 

41
00:01:53,350 --> 00:01:58,660
它催生了无数的分支和盗版以及其他优质产品

42
00:01:58,660 --> 00:02:00,580
平台玩家

43
00:02:00,580 --> 00:02:02,550
当我们今天谈论《超级马里奥兄弟》时 

44
00:02:02,550 --> 00:02:05,840
我们将要讨论的一些主题是平铺地图--

45
00:02:05,840 --> 00:02:10,130
所以我们可以用一系列的数字

46
00:02:10,130 --> 00:02:13,640
把ID拼起来变成游戏世界

47
00:02:13,640 --> 00:02:20,260
正如你在这里看到的 游戏被分成16乘16的方块 

48
00:02:20,260 --> 00:02:22,460
你可以看到砖块和问号块 

49
00:02:22,460 --> 00:02:26,630
管道甚至都是由简单的瓦片组成 

50
00:02:26,630 --> 00:02:28,610
它们映射到身份证 

51
00:02:28,610 --> 00:02:34,100
当你有一个2D表格或数组 你只是把它全部覆盖起来 

52
00:02:34,100 --> 00:02:37,550
并在适当的x y 

53
00:02:37,550 --> 00:02:40,190
你会感觉自己存在于某个游戏世界中

54
00:02:40,190 --> 00:02:43,769
尽管它只是由一堆小方块组成 

55
00:02:43,769 --> 00:02:45,560
2D动画是我们将要讨论的内容 

56
00:02:45,560 --> 00:02:47,393
到目前为止 我们还没有真正做任何动画

57
00:02:47,393 --> 00:02:50,790
至少在性格方面是这样的 

58
00:02:50,790 --> 00:02:52,250
我们会和马里奥一起做的 

59
00:02:52,250 --> 00:02:55,610
他会有我们版本的马里奥 外星人

60
00:02:55,610 --> 00:02:58,006
当他移动的时候 他会有两帧动画 

61
00:02:58,006 --> 00:03:00,380
动画的画面--有点像一本翻页书

62
00:03:00,380 --> 00:03:03,005
如果你用过的话 你可以看到单独的图片 

63
00:03:03,005 --> 00:03:05,180
当你快速地背靠背展示它们时 

64
00:03:05,180 --> 00:03:07,190
你会看到动画的外观 

65
00:03:07,190 --> 00:03:08,480
我们会讨论的 

66
00:03:08,480 --> 00:03:11,300
程序化关卡生成--我们将把所有的关卡

67
00:03:11,300 --> 00:03:12,570
随机生成 

68
00:03:12,570 --> 00:03:14,900
所以每次我们从头开始玩这个游戏 

69
00:03:14,900 --> 00:03:16,566
一切都会完全不同

70
00:03:16,566 --> 00:03:19,370
我们不必硬编码一组有限的水平 

71
00:03:19,370 --> 00:03:23,180
在我看来 一切都将是动态的 也是有趣的 

72
00:03:23,180 --> 00:03:25,820
我们会讨论一些平台物理学的基础知识

73
00:03:25,820 --> 00:03:27,740
以及如何将其应用到游戏世界中

74
00:03:27,740 --> 00:03:34,310
这里 因为我们只是使用一个瓷砖表 

75
00:03:34,310 --> 00:03:37,730
每一个都有一个x y在游戏世界空间中被硬编码 

76
00:03:37,730 --> 00:03:41,330
我们要做的就是拿马里奥的x y 

77
00:03:41,330 --> 00:03:44,150
然后除以图块大小

78
00:03:44,150 --> 00:03:46,670
然后我们基本上得到了

79
00:03:46,670 --> 00:03:48,960
在我们的阵列中 在世界的那个点 

80
00:03:48,960 --> 00:03:53,750
因此可以很容易地进行任意的碰撞检测

81
00:03:53,750 --> 00:03:56,210
关于你要去的方向 而不是迭代

82
00:03:56,210 --> 00:03:57,860
你世界里的每一块瓷砖 

83
00:03:57,860 --> 00:04:01,430
因为这只是一个简单的数学运算 就可以得到准确的切片

84
00:04:01,430 --> 00:04:05,000
给出两个坐标 因为世界在一个固定的空间里 

85
00:04:05,000 --> 00:04:07,250
我们将在我们的游戏中有一个小蜗牛

86
00:04:07,250 --> 00:04:09,680
四处走动 做几个随机的动画

87
00:04:09,680 --> 00:04:13,070
它会追逐玩家 就像是人工智能的一个基本入门 

88
00:04:13,070 --> 00:04:16,250
最后 我们将讨论通电和游戏对象之类的东西

89
00:04:16,250 --> 00:04:19,200
以及我们可能如何影响马里奥并获得这些

90
00:04:19,200 --> 00:04:21,079
诸如此类的事情 

91
00:04:21,079 --> 00:04:22,370
所以 首先 我们来看一段演示 

92
00:04:22,370 --> 00:04:24,560
所以如果有谁愿意上台

93
00:04:24,560 --> 00:04:29,660
要测试我的Mario实现 那将是非常棒的 

94
00:04:29,660 --> 00:04:31,440
詹姆斯?

95
00:04:31,440 --> 00:04:35,970
我要进入这里 所以我们应该都准备好了 

96
00:04:35,970 --> 00:04:39,360
所以一旦你准备好了 继续并点击那里的返回 

97
00:04:39,360 --> 00:04:42,510
而且你应该启动并运行它 

98
00:04:42,510 --> 00:04:45,380
所以作为随机水平的一部分--

99
00:04:45,380 --> 00:04:49,160
所以目前 我们有一个绿色外星人 

100
00:04:49,160 --> 00:04:53,270
在这种情况下 这些区块有一个随机的机会来产生宝石 

101
00:04:53,270 --> 00:04:56,469
因此 一旦他们这样做了 你就可以拿起宝石了 

102
00:04:56,469 --> 00:04:58,010
要么他们有宝石 要么他们没有 

103
00:04:58,010 --> 00:05:00,330
你可以拿起它 你会得到100分 

104
00:05:00,330 --> 00:05:02,180
正如我们所见 世界在某种程度上正在发生变化

105
00:05:02,180 --> 00:05:07,537
基于詹姆斯的化身在哪里 所以它跟踪角色 

106
00:05:07,537 --> 00:05:08,870
我们对相机有了一些概念 

107
00:05:08,870 --> 00:05:11,430
到目前为止 你在积木上越来越不走运了 

108
00:05:11,430 --> 00:05:15,810
所以你可能会从空间中掉下来 所以你可能会想要避免这种情况 

109
00:05:15,810 --> 00:05:18,314
但如果你想演示一下如何做到这一点 

110
00:05:18,314 --> 00:05:20,730
因此 在这种情况下 我们与它下面的两个街区相撞 

111
00:05:20,730 --> 00:05:23,070
右边的那个有宝石 

112
00:05:23,070 --> 00:05:26,160
所以请继续往下倒 这样我们就可以演示了 

113
00:05:26,160 --> 00:05:28,350
因此 当我们摔倒时 我们会检测玩家是否

114
00:05:28,350 --> 00:05:31,312
低于世界极限 然后我们让他回来

115
00:05:31,312 --> 00:05:32,520
在比赛开始的时候 

116
00:05:32,520 --> 00:05:35,220
你可以按Enter键 它应该会重生一个全新的世界 

117
00:05:35,220 --> 00:05:38,400
注意我们是如何在地面上随机打洞的 

118
00:05:38,400 --> 00:05:39,960
我们有随机的瓷砖 

119
00:05:39,960 --> 00:05:41,697
我们为他们准备了随机的头衔 

120
00:05:41,697 --> 00:05:42,780
所有的区块都是随机的 

121
00:05:42,780 --> 00:05:44,220
我们现在有蜗牛了 

122
00:05:44,220 --> 00:05:45,960
他们在追逐詹姆斯 

123
00:05:45,960 --> 00:05:47,469
他可以跳到它们上面 

124
00:05:47,469 --> 00:05:50,010
这里有很多移动的小棋子 但也有很多

125
00:05:50,010 --> 00:05:51,270
实际上非常简单 

126
00:05:51,270 --> 00:05:54,610
我很快就会向你们展示 

127
00:05:54,610 --> 00:05:55,970
詹姆斯：我应该停下来吗？

128
00:05:55,970 --> 00:05:56,490
科尔顿·奥格登：是的 当然 

129
00:05:56,490 --> 00:05:57,390
这将是一个很好的观点 

130
00:05:57,390 --> 00:05:58,098
所以谢谢你 詹姆斯 

131
00:05:58,098 --> 00:05:59,610
非常感激 

132
00:05:59,610 --> 00:06:04,470
目前 还没有水平结束的概念 

133
00:06:04,470 --> 00:06:06,300
这是这篇文章的一部分 实际上将

134
00:06:06,300 --> 00:06:09,600
产生一个玩家可以与之交互的对象 只是重新触发

135
00:06:09,600 --> 00:06:11,490
基本上是一个新的水平 

136
00:06:11,490 --> 00:06:18,670
但这个基本平台背后的整个引擎都在那里 而且都能正常工作 

137
00:06:18,670 --> 00:06:22,410
所以我们的目标是在这里看到的 

138
00:06:22,410 --> 00:06:24,300
我们在这堂课的目标是演示

139
00:06:24,300 --> 00:06:27,960
我们怎样才能让角色在屏幕上四处移动 

140
00:06:27,960 --> 00:06:32,520
还有一个摄像头可以跟踪他们的位置 还有随机化的瓷砖 

141
00:06:32,520 --> 00:06:35,220
也许地上有柱子 地上有洞 

142
00:06:35,220 --> 00:06:36,640
所有这一切 再一次--

143
00:06:36,640 --> 00:06:38,640
至少瓷砖--只是以数字的形式存储 

144
00:06:38,640 --> 00:06:42,960
所以我们真正需要做的就是对一系列数字进行转换 

145
00:06:42,960 --> 00:06:48,150
也许1等于有一块瓷砖 0等于空白 

146
00:06:48,150 --> 00:06:51,360
所以只要看看它 我们就会看到我们一列接一列地看 

147
00:06:51,360 --> 00:06:55,140
我们可以说 哦 也许有机会不会在Y方向上产生任何瓷砖

148
00:06:55,140 --> 00:06:58,890
在这张世界地图的第x栏上 

149
00:06:58,890 --> 00:07:02,670
或者在这个特殊的y上 也许不是产卵到地面 

150
00:07:02,670 --> 00:07:05,972
我们在它上面和下面繁殖一对 这样我们就得到了一根柱子

151
00:07:05,972 --> 00:07:06,930
以此类推 

152
00:07:06,930 --> 00:07:10,080
就是这些随机化的总和

153
00:07:10,080 --> 00:07:14,620
相当于游戏级别的一个不错的小变化 

154
00:07:14,620 --> 00:07:18,300
所以我们首先要讨论的是什么是平铺地图 

155
00:07:18,300 --> 00:07:21,720
到目前为止 我提到的是你真的可以想到一张瓷砖地图

156
00:07:21,720 --> 00:07:27,030
作为有效的二维数组或数字表格 

157
00:07:27,030 --> 00:07:30,180
它比这要复杂一点 这取决于它有多复杂

158
00:07:30,180 --> 00:07:35,610
你的平台是这样的 因为有些数字等于实心的瓷砖

159
00:07:35,610 --> 00:07:36,670
或者不去 

160
00:07:36,670 --> 00:07:39,840
所以你应该能够检查瓷砖是否可碰撞 

161
00:07:39,840 --> 00:07:42,930
这意味着玩家或您要检查的任何实体

162
00:07:42,930 --> 00:07:44,930
可能真的会与它相撞 或者

163
00:07:44,930 --> 00:07:45,430
不 

164
00:07:45,430 --> 00:07:48,400
因此 很明显 我们不想在空瓷砖上引发碰撞 

165
00:07:48,400 --> 00:07:50,400
我们希望球员能够在这些比赛中自由移动 

166
00:07:50,400 --> 00:07:53,280
但如果它们撞到墙上 或者重力在影响它们 

167
00:07:53,280 --> 00:07:56,970
当它们击中它们下面或上面的瓷砖时 我们希望检测到碰撞

168
00:07:56,970 --> 00:07:59,627
然后根据它们的移动方向阻止它们 

169
00:07:59,627 --> 00:08:02,460
根据你使用平台的复杂程度 也许

170
00:08:02,460 --> 00:08:04,422
例如 你有动画瓷砖 

171
00:08:04,422 --> 00:08:07,380
因此 如果对切片进行了动画处理 它将显示不同的动画帧

172
00:08:07,380 --> 00:08:09,330
根据你使用的定时器 

173
00:08:09,330 --> 00:08:10,590
真的 天空是无限的 

174
00:08:10,590 --> 00:08:12,630
在本例中 我们将相当简单 

175
00:08:12,630 --> 00:08:17,520
我们的瓷砖将主要是带有几个其他特征的数字 这些

176
00:08:17,520 --> 00:08:19,920
我们稍后会看到的 

177
00:08:19,920 --> 00:08:22,840
这只是一个非常简单的地图的例子--只是一张彩色的地图

178
00:08:22,840 --> 00:08:23,340
背景资料 

179
00:08:23,340 --> 00:08:28,320
我们有自己的角色 然后我们可以把所有这些瓷砖可视化

180
00:08:28,320 --> 00:08:34,307
只是为了理论上的0或1 

181
00:08:34,307 --> 00:08:37,140
Tables0--所以我将实际进入一点实现

182
00:08:37,140 --> 00:08:41,789
下面是我们如何开始画一些非常简单的瓷砖 

183
00:08:41,789 --> 00:08:46,050
所以 如果你在看发行版 以磁贴0

184
00:08:46,050 --> 00:08:47,990
将是我们从这里开始的地方 

185
00:08:47,990 --> 00:08:53,200
我将继续运行磁贴图 这样我们就可以看到它是什么样子的 

186
00:08:53,200 --> 00:08:54,330
所以这就是瓷砖0 

187
00:08:54,330 --> 00:08:58,560
这是一个比我们刚才看到的简单得多的程序 但我们在这里所做的

188
00:08:58,560 --> 00:09:01,560
只是背景中的一种颜色 然后是瓷砖 

189
00:09:05,567 --> 00:09:08,400
走出大门 有谁知道第一步会是什么

190
00:09:08,400 --> 00:09:10,520
如果我们想要实施这一点呢？

191
00:09:14,504 --> 00:09:19,304
观众：只要把瓷砖放在一个圈里 画出来 然后有一个背景就可以了？

192
00:09:19,304 --> 00:09:21,470
科尔顿·奥格登：所以把瓷砖放在一个圈里 画出来 

193
00:09:21,470 --> 00:09:22,580
然后了解一下背景情况 

194
00:09:22,580 --> 00:09:23,079
是 

195
00:09:23,079 --> 00:09:29,600
因此 基本上 如果这是我们磁砖中的主要Lua 

196
00:09:29,600 --> 00:09:33,590
我们首先需要一张瓷砖桌子来存放我们的--

197
00:09:33,590 --> 00:09:35,990
我们不会只存储纯平的数字 

198
00:09:35,990 --> 00:09:39,350
我们将存储一些小桌子 里面有号码和身份证 

199
00:09:39,350 --> 00:09:45,432
所以如果我们有一个2D表格 我们可以说tile.id 

200
00:09:45,432 --> 00:09:46,640
在这里 我们有一张空桌子 

201
00:09:46,640 --> 00:09:47,848
我们要把它填满 

202
00:09:50,780 --> 00:09:54,470
如果我们要画我们的瓷砖 我们需要某种精灵 

203
00:09:54,470 --> 00:09:57,980
我所做的就是在这里切下一小段 

204
00:09:57,980 --> 00:10:00,230
这就是tiles.png 

205
00:10:00,230 --> 00:10:04,076
从字面上看 它只是主精灵的一块瓷砖

206
00:10:04,076 --> 00:10:05,450
随发行版一起提供的床单 

207
00:10:05,450 --> 00:10:12,710
然后右边是透明的 所以我们可以抵消--

208
00:10:12,710 --> 00:10:19,370
可能瓷砖ID%1等于实心块 然后瓷砖ID%2等于空 

209
00:10:19,370 --> 00:10:24,050
因此 如果我们回忆一下生成四边形 我们可以拆分一个精灵薄片

210
00:10:24,050 --> 00:10:26,560
分成我们想要的任何数量的四边形 

211
00:10:26,560 --> 00:10:29,300
假设这是16块高的瓷砖--

212
00:10:29,300 --> 00:10:33,080
每一块瓷砖--然后整个东西是两块瓷砖宽 

213
00:10:33,080 --> 00:10:36,835
所以它需要被分成两块独立的瓷砖 

214
00:10:36,835 --> 00:10:41,330
我们只需要生成四元组 然后我们就会有一张桌子 

215
00:10:41,330 --> 00:10:45,290
该表的每个索引都将是

216
00:10:45,290 --> 00:10:47,560
映射到这些瓷砖之一的四边形 

217
00:10:47,560 --> 00:10:50,270
所以1号是这块瓷砖 2号

218
00:10:50,270 --> 00:10:53,120
将是这里的透明部分 然后

219
00:10:53,120 --> 00:10:55,929
这就是我们的ID将如何有效地映射

220
00:10:55,929 --> 00:10:57,470
绘制到屏幕上的内容 

221
00:10:57,470 --> 00:11:02,130
ID是我们的四元表的索引 

222
00:11:02,130 --> 00:11:08,890
回到图块0 我们这里只有一个地图的宽度和高度 

223
00:11:08,890 --> 00:11:13,880
我们只是想说生成一张20乘以20的地图 

224
00:11:13,880 --> 00:11:15,860
RBG--我们只是将其设置为随机的

225
00:11:15,860 --> 00:11:19,280
所以我们要用一种随机的颜色清除屏幕 

226
00:11:19,280 --> 00:11:24,020
然后这是Quads=GenerateQuads 

227
00:11:24,020 --> 00:11:26,114
请注意 我们在这里传入了瓷砖大小 

228
00:11:26,114 --> 00:11:28,530
这是一个很好的做法 只要让你的瓷砖大小恒定即可 

229
00:11:28,530 --> 00:11:31,940
所以我们整堂课的瓷砖大小--

230
00:11:31,940 --> 00:11:33,710
他们都将是16岁乘16岁 

231
00:11:33,710 --> 00:11:36,950
所以因为它们是对称的 所以我们只需要传入瓷砖大小 

232
00:11:36,950 --> 00:11:40,130
然后这就是我们最终产生地图的地方--

233
00:11:40,130 --> 00:11:42,960
所以嵌套了for循环 

234
00:11:42,960 --> 00:11:47,290
Y表示贴图高度为1 x表示贴图宽度为1 

235
00:11:47,290 --> 00:11:50,920
请记住 我们必须将一个空表插入到基表中

236
00:11:50,920 --> 00:11:52,700
将作为我们当前的行 

237
00:11:52,700 --> 00:11:56,570
然后在那一行中 我们将在Tiles y添加一个小号 

238
00:11:56,570 --> 00:12:01,280
因为y将在这里--我们当前的行和ID 

239
00:12:01,280 --> 00:12:07,790
所以我们在这里做的是 如果y小于5-

240
00:12:07,790 --> 00:12:11,150
这意味着我们基本上只会为地面设置一个任意点 

241
00:12:11,150 --> 00:12:15,810
如果距离顶部少于5块 那么就让它成为天空 

242
00:12:15,810 --> 00:12:19,340
所以天空--在这里的24 25线--我们只是

243
00:12:19,340 --> 00:12:20,900
设置两个磁贴ID 正如我之前所说的 

244
00:12:20,900 --> 00:12:23,772
天空是2 所以它将在床单的右侧 

245
00:12:23,772 --> 00:12:24,730
然后 地面就是一个 

246
00:12:24,730 --> 00:12:28,230
这将是工作表中生成的第一个四元组 

247
00:12:28,230 --> 00:12:33,200
因此 如果y小于5 则该ID应等于sky否则

248
00:12:33,200 --> 00:12:35,420
它应该等于地面 

249
00:12:35,420 --> 00:12:38,850
因此 在这里 这就是它发挥作用的地方 

250
00:12:38,850 --> 00:12:41,690
我们将用我们随机的颜色清除屏幕 

251
00:12:41,690 --> 00:12:44,690
正如James所说 我们将迭代遍历循环 

252
00:12:44,690 --> 00:12:47,990
我们要在瓦片y x处拿到瓷砖 

253
00:12:47,990 --> 00:12:53,630
然后我们只需在该瓷砖ID处绘制床单和四边形 

254
00:12:53,630 --> 00:12:58,850
然后回想一下 由于表是1索引的 而坐标是0索引的 

255
00:12:58,850 --> 00:13:01,640
我们取x和y 减去1 

256
00:13:01,640 --> 00:13:03,680
然后我们只需将它们乘以瓷砖大小 

257
00:13:03,680 --> 00:13:07,280
它的效果是画出每一块瓷砖

258
00:13:07,280 --> 00:13:10,190
在他们各自的世界节点上 并使

259
00:13:10,190 --> 00:13:14,060
看起来好像我们有了这个世界--这堆砖

260
00:13:14,060 --> 00:13:17,010
每次都有一个随机的背景 

261
00:13:17,010 --> 00:13:20,550
这并不是很有趣 但只是稍微多样化了一点 

262
00:13:20,550 --> 00:13:22,910
这就是它背后的最基本的要点 

263
00:13:22,910 --> 00:13:26,118
我的意思是 这基本上和我们在第三场比赛中做的差不多 

264
00:13:26,118 --> 00:13:29,210
我们只是把每一个小块

265
00:13:29,210 --> 00:13:38,090
分别在网格中以索引的方式在瓷砖板上按颜色和品种分类 

266
00:13:38,090 --> 00:13:41,370
只是这次 他们会一直待在同一个地方 

267
00:13:41,370 --> 00:13:43,760
所以我们不必担心它们的x和y

268
00:13:43,760 --> 00:13:45,440
不同于y和x坐标

269
00:13:45,440 --> 00:13:48,710
我们不保留对这些的引用 

270
00:13:48,710 --> 00:13:49,999
这就是静态瓦片 

271
00:13:49,999 --> 00:13:52,040
有人对我们如何

272
00:13:52,040 --> 00:13:53,769
在屏幕上绘制静态图块？

273
00:13:53,769 --> 00:13:54,560
很基本的东西 

274
00:13:58,440 --> 00:14:02,330
整个名称背后的侧滚动游戏

275
00:14:02,330 --> 00:14:06,742
就是方块的滚动是基于我们在游戏中的动作 

276
00:14:06,742 --> 00:14:08,450
它可以是一个自动滚动 在这种情况下 

277
00:14:08,450 --> 00:14:10,802
也许你是一架飞机

278
00:14:10,802 --> 00:14:12,760
通过自动滚动的关卡 

279
00:14:12,760 --> 00:14:14,080
而你在射击

280
00:14:14,080 --> 00:14:16,121
你并不能真正控制你要去哪里 

281
00:14:16,121 --> 00:14:18,549
或者它可以像马里奥 你控制一个化身 

282
00:14:18,549 --> 00:14:20,340
你可以四处走动 跳跃之类的

283
00:14:20,340 --> 00:14:22,560
摄像机会一直盯着你

284
00:14:22,560 --> 00:14:27,180
所以滚动只是相对于你的角色的x和y的位置 

285
00:14:27,180 --> 00:14:30,480
所以我将给你们展示一个例子

286
00:14:30,480 --> 00:14:32,357
在我们的游戏中实现滚动 

287
00:14:32,357 --> 00:14:35,190
为了做到这一点 我们真正要研究的函数--

288
00:14:35,190 --> 00:14:37,290
在一个新的功能--

289
00:14:37,290 --> 00:14:41,250
is love.graphics.translate（x y）.

290
00:14:41,250 --> 00:14:45,240
所以它所做的就是有效地将

291
00:14:45,240 --> 00:14:48,840
Love 2D的坐标系 这样每当我们画东西的时候 

292
00:14:48,840 --> 00:14:52,190
它会自动移动x y

293
00:14:52,190 --> 00:14:58,770
这就产生了所有东西都被扭曲的效果

294
00:14:58,770 --> 00:15:00,630
基于我们传递的x y

295
00:15:00,630 --> 00:15:05,100
所以如果我们保持一个字符所在位置的引用 

296
00:15:05,100 --> 00:15:09,480
我们可以改变屏幕上所有东西的位置

297
00:15:09,480 --> 00:15:13,020
这会让它看起来像是一个摄像头 但它不是 

298
00:15:13,020 --> 00:15:15,390
我们所做的只是移动坐标系

299
00:15:15,390 --> 00:15:16,720
基于一些偏移量--

300
00:15:16,720 --> 00:15:19,914
在这种情况下 玩家是有效的 

301
00:15:19,914 --> 00:15:22,080
观众：所以它改变了整个坐标系？

302
00:15:22,080 --> 00:15:22,996
科尔顿·奥格登：的确如此 

303
00:15:22,996 --> 00:15:27,210
它按x和y移动坐标系中绘制的所有对象 

304
00:15:27,210 --> 00:15:31,170
所以这基本上会影响所呈现的内容

305
00:15:31,170 --> 00:15:32,820
进入当时的活动窗口 

306
00:15:35,710 --> 00:15:38,580
所以我要继续往下拉瓷砖1

307
00:15:38,580 --> 00:15:40,696
所以我们可以看看这是如何运作的 

308
00:15:40,696 --> 00:15:44,290
让我继续并首先运行程序 

309
00:15:44,290 --> 00:15:47,970
因此 如果我们要进入发行版的磁砖1 

310
00:15:47,970 --> 00:15:49,980
目前它看起来几乎一模一样 

311
00:15:49,980 --> 00:15:53,610
但是如果我只按向左或向右 我就可以移动它 

312
00:15:53,610 --> 00:15:57,810
所以我们可以在这里看到 这是2D瓷砖阵列

313
00:15:57,810 --> 00:15:59,140
在这里被切断 

314
00:15:59,140 --> 00:16:02,550
然后它也被切断了 因为我们只生成了一个20x20的级别 

315
00:16:02,550 --> 00:16:05,560
它的最右边也被切断了 

316
00:16:05,560 --> 00:16:08,310
这些是您通常会对用户隐藏的详细信息

317
00:16:08,310 --> 00:16:13,740
只需将x夹在0和右侧之间

318
00:16:13,740 --> 00:16:17,064
贴图的大小减去虚拟宽度 

319
00:16:17,064 --> 00:16:19,730
而这将会产生这样的效果 无论你何时到达这一点 

320
00:16:19,730 --> 00:16:22,599
它不会再让你向右转了 同样的事情也会发生在左边 

321
00:16:22,599 --> 00:16:24,390
嗯 我们现在所做的--我们没有

322
00:16:24,390 --> 00:16:26,170
完全是根据角色来做的 

323
00:16:26,170 --> 00:16:29,590
我们只是使用键盘输入 

324
00:16:29,590 --> 00:16:32,100
因此 让我们继续讨论磁砖1 

325
00:16:35,280 --> 00:16:41,520
所以我们要看的重要的事情是--

326
00:16:41,520 --> 00:16:45,090
正如我刚才提到的 我们将调用love.graph

327
00:16:45,090 --> 00:16:47,460
在名为CameraScroll的某个值上 

328
00:16:53,010 --> 00:16:56,930
它必须是负值 因为如果我们向右移动

329
00:16:56,930 --> 00:16:59,246
在这上面还是在左边--

330
00:16:59,246 --> 00:17:02,370
如果我们向左移动 摄像机卷轴基本上会减少 

331
00:17:02,370 --> 00:17:03,453
所以它会变得更少 

332
00:17:03,453 --> 00:17:05,339
所以我们可以说 当我们在

333
00:17:05,339 --> 00:17:08,470
如果我们从0开始 向左转将是0或更小 

334
00:17:08,470 --> 00:17:10,170
否则它就会减少 

335
00:17:10,170 --> 00:17:14,760
如果我们按向右 摄像镜头应该会增加 

336
00:17:14,760 --> 00:17:19,480
如果我们想要向右移动或向左移动的外观 

337
00:17:19,480 --> 00:17:22,829
实际上 你必须以相反的方向翻译 

338
00:17:22,829 --> 00:17:34,840
因为如果我们看这个 如果我们调用love.graph 转换为正的 

339
00:17:34,840 --> 00:17:36,810
所有这些都将向右移动 

340
00:17:36,810 --> 00:17:39,330
所以它看起来就像我们在向左移动 

341
00:17:39,330 --> 00:17:41,690
如果我们把它向左平移负数 

342
00:17:41,690 --> 00:17:44,370
它会有我们向右移动的样子 

343
00:17:44,370 --> 00:17:48,570
因此 如果我们的卷轴是正面的 并且我们想要向右移动 

344
00:17:48,570 --> 00:17:52,330
我们实际上必须将其转换为负值 

345
00:17:52,330 --> 00:18:00,660
这就是为什么我把它命名为Native Math.Floor 

346
00:18:00,660 --> 00:18:04,710
有人知道为什么我们要在摄像机上叫Math.Floor吗？

347
00:18:04,710 --> 00:18:09,980
而不是简单地调用底片相机滚动？

348
00:18:09,980 --> 00:18:13,950
有人记得Math.Floor是做什么的吗？

349
00:18:13,950 --> 00:18:17,560
所以数学 地板将返回--

350
00:18:17,560 --> 00:18:21,450
它基本上会将数字向下截断到最小整数 

351
00:18:21,450 --> 00:18:24,330
它基本上会去掉浮点值 

352
00:18:24,330 --> 00:18:26,400
因为我们正在渲染到虚拟分辨率

353
00:18:26,400 --> 00:18:32,640
有了推力 如果我们基本上将平移偏移一小部分 

354
00:18:32,640 --> 00:18:34,020
你会得到手工艺品 

355
00:18:34,020 --> 00:18:37,470
因为它夺走了你的窗户 只是冷凝

356
00:18:37,470 --> 00:18:42,280
你的图像放到虚拟画布上 你会得到奇怪的模糊之类的东西 

357
00:18:42,280 --> 00:18:48,330
所以当你画一些东西的时候 你有一个分数 

358
00:18:48,330 --> 00:18:51,840
你把它画到一张被放大的虚拟画布上

359
00:18:51,840 --> 00:18:55,410
或者它正在被浓缩 只要确保数学 平铺它

360
00:18:55,410 --> 00:18:58,710
所以你不会得到任何奇怪的模糊伪装 

361
00:18:58,710 --> 00:19:02,056
如果你把它拿出来试一试 或者即使是在发行版中

362
00:19:02,056 --> 00:19:04,680
你把它从球员的位置上拿出来 你就会看到球员

363
00:19:04,680 --> 00:19:07,560
会得到奇怪的模糊的人工制品之类的东西 

364
00:19:07,560 --> 00:19:10,912
这就是为什么它在那里 如果你好奇的话 

365
00:19:10,912 --> 00:19:12,870
所以我们在这里所做的一切--我们只是想说

366
00:19:12,870 --> 00:19:16,580
如果等于左 则向左滚动摄像机 向右滚动 

367
00:19:16,580 --> 00:19:22,910
或者基本上减少我们的相机滚动 然后增加或相机滚动 

368
00:19:22,910 --> 00:19:25,970
然后在这里使用负面的版本 

369
00:19:25,970 --> 00:19:30,344
您也可以将相机滚动指定为正数

370
00:19:30,344 --> 00:19:32,510
当你向左移动 当你向右移动时 

371
00:19:32,510 --> 00:19:35,690
然后你可以在这里给它正常的相机卷轴 

372
00:19:35,690 --> 00:19:39,020
但就这一部分而言 这是一种精神上的颠覆 

373
00:19:39,020 --> 00:19:44,480
所以当我们按向左的时候 我决定在这里减少它 

374
00:19:44,480 --> 00:19:51,050
因为当我们按向右的时候 我们在x轴上做得更少 然后在x轴上做得更多 

375
00:19:51,050 --> 00:19:52,010
这有意义吗？

376
00:19:52,010 --> 00:19:52,665
有谁有问题吗？

377
00:19:52,665 --> 00:19:53,831
观众：我有一个问题 

378
00:19:53,831 --> 00:19:56,222
在JavaScript中有没有相应的函数

379
00:19:56,222 --> 00:20:01,672
而在像这样的其他语言中 你可以移动整个坐标吗？

380
00:20:01,672 --> 00:20:04,130
Colton Ogden：在JavaScript中有类似的函数吗

381
00:20:04,130 --> 00:20:06,640
在那里你可以移动整个坐标系？

382
00:20:06,640 --> 00:20:09,020
可能不是在基本的JavaScript中 

383
00:20:09,020 --> 00:20:10,760
我对css不是很熟悉 

384
00:20:10,760 --> 00:20:14,040
可能有一个css函数可以做到这一点 

385
00:20:14,040 --> 00:20:18,120
在许多2D游戏引擎中 是的 我会说 

386
00:20:18,120 --> 00:20:22,310
许多实际的2D游戏引擎都会有一个摄像头对象 它

387
00:20:22,310 --> 00:20:24,110
这在某种程度上概括了这一行为 

388
00:20:24,110 --> 00:20:26,480
Love2D没有摄像头 所以这是排序

389
00:20:26,480 --> 00:20:30,200
我们为什么要这样做--是因为这是一种较低级别的游戏

390
00:20:30,200 --> 00:20:30,952
框架 Love2D 

391
00:20:30,952 --> 00:20:32,660
它不会给你带来那么多东西

392
00:20:32,660 --> 00:20:36,800
就在门口 这使得它非常适合教授这些概念 

393
00:20:36,800 --> 00:20:41,180
但更强大的解决方案 如Unity或Phaser

394
00:20:41,180 --> 00:20:45,350
或许多其他游戏框架 它们将只有一个摄像头对象 

395
00:20:45,350 --> 00:20:49,270
你只要给它你的x 然后你就移动它 

396
00:20:49,270 --> 00:20:51,170
你基本上是这样说的 以跟踪玩家--

397
00:20:51,170 --> 00:20:55,985
比如camera.trackPlayer或trackEntityPlayer--

398
00:20:55,985 --> 00:20:57,360
这也会产生同样的效果 

399
00:20:57,360 --> 00:20:58,693
它稍微抽象了一点 

400
00:20:58,693 --> 00:21:00,800
这是一个比我们正在做的更高的水平 

401
00:21:00,800 --> 00:21:04,427
但这背后的原理是一样的 

402
00:21:04,427 --> 00:21:06,260
那么 关于这是如何运作的 还有其他问题吗？

403
00:21:09,780 --> 00:21:11,090
好的 太酷了 

404
00:21:11,090 --> 00:21:13,610
这就是我们正在做的所有事情 

405
00:21:13,610 --> 00:21:17,180
我们只是得到一个相机卷轴 递减和递增它 

406
00:21:17,180 --> 00:21:19,970
然后每一帧 我们都在翻译

407
00:21:19,970 --> 00:21:21,350
在我们画完所有的画之前 

408
00:21:21,350 --> 00:21:25,010
你必须在画之前做平移 因为你做的每一件事

409
00:21:25,010 --> 00:21:30,260
在平移受新坐标系更改影响后绘制 

410
00:21:30,260 --> 00:21:33,290
这就是滚动 

411
00:21:33,290 --> 00:21:37,220
让我们真正开始讨论如何画一个人--一个化身--

412
00:21:37,220 --> 00:21:46,280
不仅仅是一套瓷砖 因为这是游戏的核心 

413
00:21:46,280 --> 00:21:53,270
如果我们看一下Character 0 这将是我们这里的第一个示例 

414
00:21:53,270 --> 00:21:57,350
这只是一个非常简单的例子--

415
00:21:57,350 --> 00:21:57,960
字符0 

416
00:22:00,800 --> 00:22:02,990
你们可能已经知道这是怎么回事了 

417
00:22:02,990 --> 00:22:07,120
我们所做的只是在屏幕上画一个精灵--

418
00:22:07,120 --> 00:22:09,680
所以就去爱吧 图画 

419
00:22:09,680 --> 00:22:13,070
我们从一块瓷砖上拿到了四边形 

420
00:22:13,070 --> 00:22:15,470
我相信它就在幻灯片里 

421
00:22:15,470 --> 00:22:18,260
实际的床单在这里 

422
00:22:18,260 --> 00:22:21,680
所以我们有一个小家伙--

423
00:22:21,680 --> 00:22:22,970
几帧动画 

424
00:22:22,970 --> 00:22:26,080
它有16个宽 20个高 我们只有一个四边形 

425
00:22:26,080 --> 00:22:27,420
我们先把它分成四个部分 

426
00:22:27,420 --> 00:22:32,240
所以我们知道它是16×20高的 所以我们只生成四边形

427
00:22:32,240 --> 00:22:35,690
在这张图上 16岁和20岁 

428
00:22:35,690 --> 00:22:38,000
在这个例子中 我们所做的就是

429
00:22:38,000 --> 00:22:42,796
取下第一帧 也就是1次方 然后画出来 

430
00:22:42,796 --> 00:22:45,170
正如你在这里看到的 我们有一堆不同的东西 

431
00:22:45,170 --> 00:22:47,000
我们有一种蹲着的状态 我们会

432
00:22:47,000 --> 00:22:50,100
稍后我们将了解更多有关动画的内容 

433
00:22:50,100 --> 00:22:53,160
但在这里 我们让他爬上了梯子 

434
00:22:53,160 --> 00:22:55,290
但你可以看到所有这些不同的框架 

435
00:22:55,290 --> 00:22:57,800
我们将向您展示如何背靠背播放它们

436
00:22:57,800 --> 00:22:59,430
并得到不同的动画 

437
00:22:59,430 --> 00:23:01,970
但为了这个基本的例子 我们所做的一切

438
00:23:01,970 --> 00:23:05,360
只是渲染了第一帧 

439
00:23:05,360 --> 00:23:08,200
我们可以看到--

440
00:23:08,200 --> 00:23:11,240
让我确保我在正确的文件中 我是--

441
00:23:11,240 --> 00:23:17,790
我们在第43行和第44行得到了角色表 

442
00:23:17,790 --> 00:23:21,820
然后我们必须给他一个X 所以CharacterX Charactery 

443
00:23:21,820 --> 00:23:24,360
在这种情况下 我们只是将他设置在7号瓷砖之上 

444
00:23:24,360 --> 00:23:29,840
所以我们用7减去1乘以Tile_Size 因为切片是1索引的

445
00:23:29,840 --> 00:23:31,909
但是坐标是0索引的 

446
00:23:31,909 --> 00:23:33,950
然后我们只需减去高度 他就会

447
00:23:33,950 --> 00:23:38,450
就在瓷砖的上方 而不是瓷砖的右边 

448
00:23:38,450 --> 00:23:44,120
然后在这里 我们做一个爱 画 画

449
00:23:44,120 --> 00:23:46,460
就像我之前说的 就是角色Quads1 

450
00:23:46,460 --> 00:23:49,660
这只是一个非常基本的硬编码示例 

451
00:23:49,660 --> 00:23:51,410
对于这是如何工作的 有什么问题吗？

452
00:23:58,270 --> 00:24:00,514
现在让我们假设我们想让他移动 

453
00:24:00,514 --> 00:24:01,180
我们需要什么？

454
00:24:01,180 --> 00:24:03,304
如果我们只是想让他搬走 下一步该怎么办？

455
00:24:08,984 --> 00:24:11,970
观众：给他一个x和y？

456
00:24:11,970 --> 00:24:13,890
科尔顿·奥格登：是的 给他一个x和y 

457
00:24:13,890 --> 00:24:17,350
所以是的 所以他已经有了x和y 

458
00:24:17,350 --> 00:24:19,750
所以如果你看--我穿对了吗？

459
00:24:19,750 --> 00:24:23,179
所以如果你转到Character0 这仍然是Character0 

460
00:24:23,179 --> 00:24:26,220
我们已经给了他一个x和y 但还需要再走一步 

461
00:24:26,220 --> 00:24:27,511
另一个步骤涉及到什么？

462
00:24:32,930 --> 00:24:36,620
因此 如果我们想要移动 我们需要检查键盘输入 

463
00:24:36,620 --> 00:24:39,320
然后我们需要取他的X--

464
00:24:39,320 --> 00:24:42,140
我们现在只需要让他在x轴上移动 

465
00:24:42,140 --> 00:24:47,390
我们基本上需要把他的性格变量X放在这里 

466
00:24:47,390 --> 00:24:49,040
我们需要修改这一点 

467
00:24:49,040 --> 00:24:55,260
我们基本上可以做我们在Love这里所做的相同的事情 

468
00:24:55,260 --> 00:24:58,040
在此之前 它是在坐标系中--

469
00:24:58,040 --> 00:24:59,130
Love.graph ics.翻译 

470
00:24:59,130 --> 00:25:01,220
我们修改了相机卷轴 

471
00:25:01,220 --> 00:25:05,900
我们将其设置为滚动速度乘以增量时间 

472
00:25:05,900 --> 00:25:07,130
我们把它减去或相加 

473
00:25:07,130 --> 00:25:09,755
在这种情况下 我们要做的是有一个新的常量 称为

474
00:25:09,755 --> 00:25:13,250
CHARACTER_MOVE_SPEED 我们正在执行完全相同的操作

475
00:25:13,250 --> 00:25:18,020
但用的是Character X 而不是CameraScroll 

476
00:25:18,020 --> 00:25:24,900
因此 最终的结果是我们有了这个角色 

477
00:25:24,900 --> 00:25:28,287
然后我们可以向左或向右移动他 他就会离开屏幕 

478
00:25:28,287 --> 00:25:29,870
现在 有几件事是错的 

479
00:25:29,870 --> 00:25:30,500
怎么了？

480
00:25:30,500 --> 00:25:33,632
现在的场景有哪些地方出了问题？

481
00:25:33,632 --> 00:25:35,450
观众：镜头应该和他一起移动 

482
00:25:35,450 --> 00:25:36,320
科尔顿·奥格登：相机应该和他们一起移动 

483
00:25:36,320 --> 00:25:37,700
观众：没有动画 

484
00:25:37,700 --> 00:25:39,440
科尔顿·奥格登：没有动画 

485
00:25:39,440 --> 00:25:41,690
这可能是两个真正的错误 

486
00:25:41,690 --> 00:25:45,712
所以摄像头不会跟踪他 这很重要 

487
00:25:45,712 --> 00:25:48,670
显然 我们希望能够保持对我们角色的引用 

488
00:25:48,670 --> 00:25:50,150
除非我们在屏幕的左边

489
00:25:50,150 --> 00:25:52,880
如果我们在屏幕的左边缘 这实际上是可以的 

490
00:25:52,880 --> 00:25:56,690
这是分配的一部分--我们夹住x射线 

491
00:25:56,690 --> 00:25:59,690
它不会超过左边

492
00:25:59,690 --> 00:26:05,210
但是如果我们超出了中间 而不是屏幕的右边 

493
00:26:05,210 --> 00:26:08,910
它应该和他一起运动 反之亦然

494
00:26:08,910 --> 00:26:11,030
然后他需要动画 所以他的精灵

495
00:26:11,030 --> 00:26:15,050
需要每隔一定的秒数改变一次是否在移动 

496
00:26:15,050 --> 00:26:17,180
只有在他移动的时候才能看到 对吧？

497
00:26:17,180 --> 00:26:20,240
如果他站着不动 你可以有一个空闲的动画 

498
00:26:20,240 --> 00:26:23,460
有些角色会用脚敲 做这样的事情 

499
00:26:23,460 --> 00:26:26,870
但为了这个例子 我们希望他

500
00:26:26,870 --> 00:26:28,790
在他空闲的时候站着不动

501
00:26:28,790 --> 00:26:31,940
我们希望他在移动的时候有一个真实的动画 

502
00:26:31,940 --> 00:26:34,640
我们得处理好这两件事

503
00:26:34,640 --> 00:26:38,310
如果算上空闲的动画部分的话 有三块 

504
00:26:38,310 --> 00:26:43,310
让我们进入角色2 处理第一部分 

505
00:26:43,310 --> 00:26:45,890
正在追踪他

506
00:26:45,890 --> 00:26:47,504
让我们进入角色2 

507
00:26:47,504 --> 00:26:49,670
我们先运行一下看看是什么样的 

508
00:26:54,610 --> 00:26:58,680
所以现在摄像头基本上是固定在播放器上的 

509
00:26:58,680 --> 00:27:01,670
在这个例子中 我们不考虑左边缘的问题 

510
00:27:01,670 --> 00:27:03,910
在发行版中 这是固定的 

511
00:27:03,910 --> 00:27:09,210
但是我们有基本的侧滚动机制--拿一个角色 

512
00:27:09,210 --> 00:27:11,610
追随她.

513
00:27:11,610 --> 00:27:13,980
你觉得我们是怎么做到的？

514
00:27:17,520 --> 00:27:18,020
是的

515
00:27:18,020 --> 00:27:22,250
观众：根据人物X翻译图画？

516
00:27:22,250 --> 00:27:24,700
科尔顿·奥格登：是的 完全正确 

517
00:27:24,700 --> 00:27:28,190
它不可能是X这个字符 

518
00:27:28,190 --> 00:27:31,760
因为如果是的话 那么这个字符应该在左边 对吧？

519
00:27:31,760 --> 00:27:35,290
所以我们需要偏移我们平移的x 

520
00:27:35,290 --> 00:27:40,820
我们需要基本上平移他的x减去一半的屏幕空间

521
00:27:40,820 --> 00:27:42,590
加上字符宽度的一半 

522
00:27:42,590 --> 00:27:45,340
这将产生翻译它的效果 但始终保持

523
00:27:45,340 --> 00:27:48,530
如果这有道理的话 那就是偏离播放器半个屏幕宽度 

524
00:27:48,530 --> 00:27:52,450
所以我们所做的是在角色中--这是角色2 对吧--

525
00:27:52,450 --> 00:27:58,040
特征2 我们仍然在做我们曾经做过的事情 

526
00:27:58,040 --> 00:28:01,070
实际上 那是错误的文件 

527
00:28:01,070 --> 00:28:05,510
我们在这里修改Character X 

528
00:28:05,510 --> 00:28:07,970
所以我们之前做了同样的事情--

529
00:28:07,970 --> 00:28:10,920
将移动速度乘以增量时间 然后进行加法或减法

530
00:28:10,920 --> 00:28:12,253
如果我们按向左或向右 

531
00:28:12,253 --> 00:28:16,994
而且 在这里--重新引入相机卷轴 

532
00:28:16,994 --> 00:28:20,160
我们将其设置为 就像我说的 Character X减去虚拟宽度除以

533
00:28:20,160 --> 00:28:23,450
2 半个屏幕 然后正偏移量

534
00:28:23,450 --> 00:28:27,860
他的宽度除以2 所以他正好在中间 

535
00:28:27,860 --> 00:28:30,110
因为请记住 字符的坐标

536
00:28:30,110 --> 00:28:34,100
被放在他们的左边 而不是他们的中间 

537
00:28:34,100 --> 00:28:36,740
然后我们只是做我们以前做过的事情 

538
00:28:36,740 --> 00:28:40,010
我们根据CameraScroll对场景进行翻译 

539
00:28:40,010 --> 00:28:44,720
我们用Math.Floor将他呈现在CharacterX Charactery上

540
00:28:44,720 --> 00:28:48,430
以防止他在我们的世界空间中处于一个分割点

541
00:28:48,430 --> 00:28:50,690
然后它变得模糊和做作 

542
00:28:50,690 --> 00:28:55,487
这就是我们如何跟踪角色的某种程度上的问题 

543
00:28:55,487 --> 00:28:57,320
如果你想沿着y轴追踪 

544
00:28:57,320 --> 00:28:58,760
你也可以做同样的事情 

545
00:28:58,760 --> 00:29:02,690
维护相机滚动X和摄像机滚动Y--

546
00:29:02,690 --> 00:29:04,940
所以要把它们分开 

547
00:29:04,940 --> 00:29:09,260
然后你就可以在这里翻译了 

548
00:29:09,260 --> 00:29:11,750
所以我们传入0 因为我们不想

549
00:29:11,750 --> 00:29:13,430
必须沿y轴跟踪 

550
00:29:13,430 --> 00:29:18,140
但您需要做的就是传递您的y CameraScroll 

551
00:29:18,140 --> 00:29:20,579
然后你可以根据性格来做

552
00:29:20,579 --> 00:29:22,370
不管它们是否在地面上

553
00:29:22,370 --> 00:29:25,310
或者越过天空中的某个点 

554
00:29:25,310 --> 00:29:29,020
那么 对于这里的摄像头跟踪系统是如何工作的 有什么问题吗？

555
00:29:31,790 --> 00:29:33,830
好的 

556
00:29:33,830 --> 00:29:38,332
所以我们解决了一个问题 那就是缺乏跟踪 

557
00:29:38,332 --> 00:29:40,790
但还有一个问题 那就是他没有动画 

558
00:29:40,790 --> 00:29:47,330
他所做的就是像M.C.哈默那样移动--

559
00:29:47,330 --> 00:29:48,451
或者是M.C.Usher？

560
00:29:48,451 --> 00:29:48,950
M.C.哈默？

561
00:29:48,950 --> 00:29:50,330
我忘了 

562
00:29:50,330 --> 00:29:51,140
他就是这么做的 

563
00:29:51,140 --> 00:29:52,220
他什么都没做 

564
00:29:52,220 --> 00:29:55,640
我们需要让他动起来 这样他看起来就像有生命一样

565
00:29:55,640 --> 00:29:57,680
而且你还可以重要地区别于

566
00:29:57,680 --> 00:29:59,390
在两个不同的状态之间 

567
00:29:59,390 --> 00:30:02,630
他可以无所事事 不动 也可以动起来 

568
00:30:02,630 --> 00:30:05,450
所以我们应该有某种视觉反馈

569
00:30:05,450 --> 00:30:08,960
关于目前正在发生的事情 

570
00:30:08,960 --> 00:30:14,030
因此 有谁知道我们如何着手实施

571
00:30:14,030 --> 00:30:16,360
为我们的角色制作动画片？

572
00:30:16,360 --> 00:30:18,703
我们需要哪些零件？

573
00:30:18,703 --> 00:30:20,667
观众：我想如果他走对了 那么

574
00:30:20,667 --> 00:30:25,570
调用一个函数和一个渲染来查看一些图像？

575
00:30:25,570 --> 00:30:26,320
科尔顿·奥格登：是的 

576
00:30:26,320 --> 00:30:29,680
所以如果他向右移动 那么就有一个功能

577
00:30:29,680 --> 00:30:31,750
这就像是在一些图像中循环 

578
00:30:31,750 --> 00:30:34,520
这实际上就是我们将要做的事情 

579
00:30:34,520 --> 00:30:37,680
我们有一个叫动画的课程 我已经在这里介绍过了 

580
00:30:37,680 --> 00:30:40,750
它所做的基本上就是跟踪--你

581
00:30:40,750 --> 00:30:44,140
将其传递到一个表中 该表包含工作表的框架

582
00:30:44,140 --> 00:30:45,760
您想要设置动画的对象 

583
00:30:45,760 --> 00:30:47,160
所以我们可以直接进去--

584
00:30:47,160 --> 00:30:48,660
让我们继续前进 看看这里 

585
00:30:50,700 --> 00:30:53,470
我之前参考了这张幻灯片 但所有这些

586
00:30:53,470 --> 00:30:57,160
有1 2 3 4 5 6 7 8 9 10--不管有多少 

587
00:30:57,160 --> 00:31:01,296
你只要进入动画即可 

588
00:31:01,296 --> 00:31:02,420
假设他在梯子上 

589
00:31:02,420 --> 00:31:05,920
假设这是1、2、3、4、5、6和7 

590
00:31:05,920 --> 00:31:08,560
你说 帧将是6和7 

591
00:31:08,560 --> 00:31:12,070
所以它们会从左到右循环 从后面开始

592
00:31:12,070 --> 00:31:16,240
在开始的时候 当它结束的时候 然后你给它一个间隔 

593
00:31:16,240 --> 00:31:19,520
比方说 我希望动画以秒为单位这么快地发生 

594
00:31:19,520 --> 00:31:23,000
所以我希望它可能每0.2秒发生一次 

595
00:31:23,000 --> 00:31:25,934
因此 这将产生每0.2秒的影响 

596
00:31:25,934 --> 00:31:27,100
它会记录一个计时器 

597
00:31:27,100 --> 00:31:30,790
那么我们已经超过0.2秒了吗？

598
00:31:30,790 --> 00:31:33,700
从0开始 然后每次都加上增量时间 

599
00:31:33,700 --> 00:31:37,750
如果有 则增加当前动画的帧 

600
00:31:37,750 --> 00:31:42,280
所以我们现在的画面是这一幅 然后0.2秒过去了 

601
00:31:42,280 --> 00:31:43,480
就是这一次 

602
00:31:43,480 --> 00:31:47,000
然后0.2秒过去了 我们需要循环回到起点 

603
00:31:47,000 --> 00:31:49,150
所以我们最终会使用模数来解决这个问题

604
00:31:49,150 --> 00:31:51,070
就像我们在动画课上看到的那样 

605
00:31:54,520 --> 00:31:55,930
基本上 这些都在这里完成了 

606
00:31:55,930 --> 00:32:00,340
因此 如果我们有不止一帧动画 回想一下 它在这里得到了定义 

607
00:32:00,340 --> 00:32:04,112
所以我们得到帧 我们得到一个间隔 得到一个被初始化为0的计时器 

608
00:32:04,112 --> 00:32:05,320
然后获得当前帧 

609
00:32:05,320 --> 00:32:09,070
我们将当前帧设置为1 

610
00:32:09,070 --> 00:32:12,322
然后 只要我们有不止一帧 

611
00:32:12,322 --> 00:32:14,530
循环或尝试动画是没有意义的

612
00:32:14,530 --> 00:32:16,930
只有一帧的任何动画 

613
00:32:16,930 --> 00:32:20,140
当然 我们可以制作只有一帧的动画 

614
00:32:20,140 --> 00:32:23,500
闲置只是一帧动画 就像我们在这里看到的 

615
00:32:23,500 --> 00:32:24,959
这只是一帧而已 

616
00:32:24,959 --> 00:32:27,000
我们不需要做任何逻辑来说 哦 

617
00:32:27,000 --> 00:32:29,560
下一帧是什么 因为只有一帧 

618
00:32:29,560 --> 00:32:37,330
但是如果我们看角色3 我们可以在那里看到两个帧 

619
00:32:37,330 --> 00:32:39,760
然后 这只是一个画面 他无所事事 

620
00:32:39,760 --> 00:32:42,860
当我们向左移动时 他也会朝那个方向移动 

621
00:32:42,860 --> 00:32:45,822
有没有人记得我们怎么才能找到他--因为很明显 

622
00:32:45,822 --> 00:32:47,530
我们刚刚看到了电子表格 

623
00:32:47,530 --> 00:32:50,290
而精灵面对的只有一个方向--

624
00:32:50,290 --> 00:32:54,070
我们怎么才能让他看起来像那样 即使有

625
00:32:54,070 --> 00:32:57,323
没有精灵让他看起来那样吗？

626
00:32:57,323 --> 00:32:59,170
观众：把它绕着轴翻转 

627
00:32:59,170 --> 00:33:03,190
科尔顿·奥格登：翻转它 所以爱 

628
00:33:03,190 --> 00:33:07,900
回想一下 您可以在任意轴上传递负比例因子 

629
00:33:07,900 --> 00:33:10,912
这将会产生沿着那个轴翻转的结果 

630
00:33:10,912 --> 00:33:11,870
这就是我们要做的一切 

631
00:33:11,870 --> 00:33:14,161
这是默认的框架 所以我们只是绘制它 

632
00:33:14,161 --> 00:33:17,300
然后我们必须保持对他面对的方向的参考 

633
00:33:17,300 --> 00:33:19,390
如果他的方向是正确的 我们将

634
00:33:19,390 --> 00:33:23,300
只需绘制该帧 然后循环处理动画即可 

635
00:33:23,300 --> 00:33:29,380
如果他面朝左 画它 但也要执行负1变换

636
00:33:29,380 --> 00:33:30,820
在x轴上 

637
00:33:30,820 --> 00:33:33,670
就像这样 我们让它奏效了 

638
00:33:33,670 --> 00:33:34,600
所以我们要做的是--

639
00:33:34,600 --> 00:33:36,070
只要有个计时器就行了 

640
00:33:36,070 --> 00:33:41,050
然后 当计时器超过我们的间隔时 只需增加帧 

641
00:33:41,050 --> 00:33:44,140
然后用模数循环到它上面--

642
00:33:44,140 --> 00:33:45,480
返回到从1开始 

643
00:33:45,480 --> 00:33:48,691
这些都是在这28号线上完成的 

644
00:33:48,691 --> 00:33:50,440
所以你可以再往里面看一点

645
00:33:50,440 --> 00:33:53,320
如果你想掌握数学原理 

646
00:33:53,320 --> 00:33:58,300
但它只是一个简单的迭代帧集合的序列

647
00:33:58,300 --> 00:33:59,640
以计时器为基础 

648
00:33:59,640 --> 00:34:02,830
这就产生了这样的效果--就像我之前说过的活页书一样--

649
00:34:02,830 --> 00:34:06,160
我们的角色有一个动画和一些生活 

650
00:34:06,160 --> 00:34:10,060
那么 关于这个动画课程是如何运作的 有什么问题吗？

651
00:34:10,060 --> 00:34:12,437
观众：渲染是在动画课上吗？

652
00:34:12,437 --> 00:34:13,270
科尔顿·奥格登：所以不是 

653
00:34:13,270 --> 00:34:14,894
渲染不在动画类中 

654
00:34:14,894 --> 00:34:16,780
所以渲染是--

655
00:34:16,780 --> 00:34:20,060
我意识到我在这里没有展示任何真正的Main 

656
00:34:20,060 --> 00:34:22,830
我们这里有两个动画 只是一个闲置的动画 

657
00:34:22,830 --> 00:34:24,550
所以我们只传了一帧 

658
00:34:24,550 --> 00:34:26,794
我们将它的间隔设为1 

659
00:34:26,794 --> 00:34:29,710
这并不重要 但为了保持一致性 

660
00:34:29,710 --> 00:34:31,750
我们给它一个1的区间--任意的 

661
00:34:31,750 --> 00:34:35,090
也许我们以后会想要改变他的动画 

662
00:34:35,090 --> 00:34:39,100
因此 通过在这里设置间隔 我们不会忘记在以后添加一个 

663
00:34:39,100 --> 00:34:41,409
移动的动画--回想一下10和11 

664
00:34:41,409 --> 00:34:43,130
所以这是在这张纸的最后--

665
00:34:43,130 --> 00:34:46,090
两个行走的框架 

666
00:34:46,090 --> 00:34:48,520
这里的间隔是0.2秒 

667
00:34:48,520 --> 00:34:51,969
我们需要一个当前的动画来渲染他 

668
00:34:51,969 --> 00:34:55,909
然后我们会参考他所看的任何方向 

669
00:34:55,909 --> 00:34:58,570
所以如果他向右看 我们就去

670
00:34:58,570 --> 00:35:02,282
要在love.graph中引用这一点 请在底部绘制 

671
00:35:02,282 --> 00:35:04,990
这就是我们要用来表演精灵翻转的东西

672
00:35:04,990 --> 00:35:07,560
沿着x轴 

673
00:35:07,560 --> 00:35:09,500
保持对这一点的引用 

674
00:35:09,500 --> 00:35:14,500
然后在这里 我们实际引用动画的部分

675
00:35:14,500 --> 00:35:18,670
如果你在看《字符1》 在150号线上 

676
00:35:18,670 --> 00:35:20,870
或者是第二个特征？

677
00:35:20,870 --> 00:35:22,410
抱歉 角色3 

678
00:35:22,410 --> 00:35:26,130
如果你看的是第三个角色的第150行 

679
00:35:26,130 --> 00:35:29,307
我们使用CurrentAnimation：getCurrentFrame() 

680
00:35:29,307 --> 00:35:32,640
所以这个类实际上只会告诉你动画的当前帧是什么

681
00:35:32,640 --> 00:35:37,410
是因为它保留了对它基于计时器的帧的引用

682
00:35:37,410 --> 00:35:39,287
以及已经过去了多少 

683
00:35:39,287 --> 00:35:43,760
观众：所以这个班级正在实时生成一个不同的画面

684
00:35:43,760 --> 00:35:45,019
然后把它插在那里 

685
00:35:45,019 --> 00:35:45,810
科尔顿·奥格登：是的 

686
00:35:45,810 --> 00:35:49,420
它维护对当前帧的引用 

687
00:35:49,420 --> 00:35:51,990
它在你给它的时候得到的相框表格里

688
00:35:51,990 --> 00:35:56,000
最上面的定义--

689
00:35:56,000 --> 00:35:59,880
第51到58行 我们在其中创建两个动画 

690
00:35:59,880 --> 00:36:03,870
基本上 它维护对该框架表中哪个索引的引用

691
00:36:03,870 --> 00:36:04,930
我们已经到了 

692
00:36:04,930 --> 00:36:10,180
所以 如果0.2秒过去了 我们从1开始 然后我们转到2 

693
00:36:10,180 --> 00:36:11,520
然后我们将返回到1 

694
00:36:11,520 --> 00:36:15,970
所以它基本上只会返回帧和索引 

695
00:36:15,970 --> 00:36:20,720
并且帧索引1是10 帧索引2是11 

696
00:36:20,720 --> 00:36:25,480
所以函数是getCurrentFrame 

697
00:36:25,480 --> 00:36:29,730
因此Character Quads、CurrentAnimation、GetCurrentFrame 

698
00:36:29,730 --> 00:36:37,410
然后在这里 因为我们正在进行原点转换--

699
00:36:37,410 --> 00:36:43,260
所以 当你翻转精灵时 这是另一件需要考虑的事情 

700
00:36:43,260 --> 00:36:45,480
当你翻转一个精灵时 它实际上是顺着它翻转的

701
00:36:45,480 --> 00:36:47,490
不管它的默认来源是什么 

702
00:36:47,490 --> 00:36:53,130
任何精灵的默认原点都在这里的左上角 

703
00:36:53,130 --> 00:36:56,880
所以如果你沿着x轴翻转某物 

704
00:36:56,880 --> 00:37:00,630
它会出现在这里 而不是在原地翻转 

705
00:37:00,630 --> 00:37:03,870
所以实际上你必须将原点设置为其中心

706
00:37:03,870 --> 00:37:07,090
当你做任何形式的原地翻转精灵 

707
00:37:07,090 --> 00:37:10,290
因此 当您查看代码时 您会注意到

708
00:37:10,290 --> 00:37:16,980
在这里 我们将字符宽度除以2 再加上字符高度

709
00:37:16,980 --> 00:37:21,000
用这两个除以2 

710
00:37:21,000 --> 00:37:24,240
所以我们移动它的绘制位置 然后我们移动它的原点

711
00:37:24,240 --> 00:37:26,610
偏移量在第160行 

712
00:37:26,610 --> 00:37:28,920
所以 如果你看love.graph 你会发现

713
00:37:28,920 --> 00:37:31,770
看 它有很多可选参数 

714
00:37:31,770 --> 00:37:36,960
底部的这两个参数是原点偏移参数 

715
00:37:36,960 --> 00:37:39,840
所以这些只有在以下情况下才真正发挥作用

716
00:37:39,840 --> 00:37:44,970
你做一些精灵在轴上的翻转

717
00:37:44,970 --> 00:37:50,560
你想要图形的一致性 而不是让它以这样或那样的方式翻转 

718
00:37:50,560 --> 00:37:53,381
有时这就是你想要的效果 但在这种情况下 

719
00:37:53,381 --> 00:37:53,880
事实并非如此 

720
00:37:53,880 --> 00:37:56,360
我们希望他呆在原地不动 

721
00:37:56,360 --> 00:37:58,334
因此 要在完全相同的位置翻转一杯雪碧 

722
00:37:58,334 --> 00:38:00,750
您需要将其原点设置在其中心 而不是其左上角 

723
00:38:00,750 --> 00:38:04,090
这说得通吗？

724
00:38:04,090 --> 00:38:05,130
好的 

725
00:38:05,130 --> 00:38:08,940
还有这里 0是这里的旋转 

726
00:38:08,940 --> 00:38:11,140
因此 如果您要添加

727
00:38:11,140 --> 00:38:13,870
将这么多参数传递给函数 

728
00:38:13,870 --> 00:38:18,540
但我们正在测试方向是否等于左 我们想要翻到负1

729
00:38:18,540 --> 00:38:22,920
在x上 否则就给它1 

730
00:38:22,920 --> 00:38:26,880
因此 1只是表示默认变换 所以没有翻转 

731
00:38:26,880 --> 00:38:30,360
然后我们根本不在y上翻转 所以它永远是1 

732
00:38:30,360 --> 00:38:34,950
简而言之 这就是如何让你的角色动画化 同时

733
00:38:34,950 --> 00:38:37,560
设置动画时 请保持原地不动 

734
00:38:37,560 --> 00:38:43,810
那么 有没有关于动画或原点偏移或任何工作原理的问题？

735
00:38:47,660 --> 00:38:48,230
好的 

736
00:38:48,230 --> 00:38:50,500
所以我们确实谈到了动画 

737
00:38:50,500 --> 00:38:53,450
我们将讨论的最后一件事是跳跃 

738
00:38:53,450 --> 00:38:58,240
那么 如果你回忆起Flappy Bird 我们怎么才能让我们的角色跳起来呢？

739
00:38:58,240 --> 00:39:02,300
我们需要些什么呢？

740
00:39:02,300 --> 00:39:07,050
观众：按下键 然后y上升 

741
00:39:07,050 --> 00:39:08,490
然后我们必须有重力 

742
00:39:08,490 --> 00:39:09,360
科尔顿·奥格登：是的 

743
00:39:09,360 --> 00:39:14,140
所以按键是我们需要的一件事 所以检查一下空间

744
00:39:14,140 --> 00:39:16,020
将成为默认密钥 

745
00:39:16,020 --> 00:39:19,240
Y上升 然后检查重力 

746
00:39:19,240 --> 00:39:22,860
所以我们不仅需要y 我们还需要 

747
00:39:22,860 --> 00:39:29,340
我们需要速度 因为重力是速度的变换 而不是

748
00:39:29,340 --> 00:39:31,780
严阵以待 

749
00:39:31,780 --> 00:39:39,540
所以如果我们回到角色4 这是一种

750
00:39:39,540 --> 00:39:41,970
以一种老套的方式来实现重力 

751
00:39:41,970 --> 00:39:44,700
因为我们实际上还没有合并瓷砖碰撞 

752
00:39:44,700 --> 00:39:47,830
为此 我将推迟大部分实施

753
00:39:47,830 --> 00:39:51,060
至于发行版 我会和你们一起去的 

754
00:39:51,060 --> 00:39:53,700
但现在 我们拥有和以前完全一样的东西 

755
00:39:53,700 --> 00:39:55,460
在那里我们有瓷砖滚动 

756
00:39:55,460 --> 00:39:58,500
但如果我按空格键 我上去 然后他下来 

757
00:39:58,500 --> 00:40:01,300
请注意 他也有一个动画 

758
00:40:01,300 --> 00:40:02,410
他有着不同的身材 

759
00:40:02,410 --> 00:40:05,469
所以如果他在跳跃 他就有一个小小的跳跃框 

760
00:40:05,469 --> 00:40:07,260
这意味着我们现在有三个动画 

761
00:40:07,260 --> 00:40:09,834
我们有一个闲置的动画 我们有一个移动的动画 

762
00:40:09,834 --> 00:40:11,250
然后我们有一个跳跃动画 

763
00:40:11,250 --> 00:40:14,250
所以实际上 我们也有三个州--

764
00:40:14,250 --> 00:40:18,090
空闲状态、移动状态和跳跃状态 

765
00:40:18,090 --> 00:40:20,220
实际上是四个州 

766
00:40:20,220 --> 00:40:23,490
另外 我注意到这里有一个小错误 如果你还在空中 

767
00:40:23,490 --> 00:40:25,307
他的框架没有改变 

768
00:40:25,307 --> 00:40:27,390
所以它实际上可能应该停留在那个画面上 

769
00:40:27,390 --> 00:40:28,830
即使他站着不动 

770
00:40:28,830 --> 00:40:30,700
但我想这没什么大不了的 

771
00:40:30,700 --> 00:40:34,050
我们也把它理解为一种特征 

772
00:40:34,050 --> 00:40:40,520
但当他在空中飞行时 他有几个状态 

773
00:40:40,520 --> 00:40:42,480
这里应该有两个州 

774
00:40:42,480 --> 00:40:44,730
一种是跳跃状态 另一种是下降状态 

775
00:40:44,730 --> 00:40:48,540
我们知道为什么两者不同是一件重要的事情吗？

776
00:40:52,780 --> 00:40:56,070
所以如果我们想一想超级马里奥兄弟 

777
00:40:56,070 --> 00:41:00,970
我们思考跳跃和坠落之间的区别 

778
00:41:00,970 --> 00:41:04,260
根据马里奥是否跳跃 有哪些事情会改变

779
00:41:04,260 --> 00:41:07,080
或者他是不是在坠落？

780
00:41:07,080 --> 00:41:10,520
我应该说 他与环境的互动有什么不同？

781
00:41:15,050 --> 00:41:21,480
所以 如果不熟悉的话 马里奥--当他跳起来的时候 他实际上可以击中盖帽 

782
00:41:21,480 --> 00:41:23,570
因此 如果他在一个街区下面 他击中了一个街区 

783
00:41:23,570 --> 00:41:27,120
它有某种行为 它会触发那个区块中的任何东西 

784
00:41:27,120 --> 00:41:29,960
不管它是一枚硬币 还是要毁掉这个街区 

785
00:41:29,960 --> 00:41:34,790
如果他倒下了 回想一下如果他像野猪一样落在敌人身上 

786
00:41:34,790 --> 00:41:36,450
他会消灭敌人 

787
00:41:36,450 --> 00:41:39,290
因此 我们需要区分这两种状态 

788
00:41:39,290 --> 00:41:43,310
因为当他跳的时候 他不能--

789
00:41:43,310 --> 00:41:46,730
当他真的飞起来的时候 他不能攻击敌人 

790
00:41:46,730 --> 00:41:49,580
同样 当他倒下时 他不能摧毁街区 

791
00:41:49,580 --> 00:41:52,550
所以即使他在空中跳跃

792
00:41:52,550 --> 00:41:55,460
重力正在应用一种变换

793
00:41:55,460 --> 00:42:00,590
这一切看起来都像是一个州 实际上有两个重要的变化

794
00:42:00,590 --> 00:42:02,250
在他所在的州都是相关的 

795
00:42:02,250 --> 00:42:04,740
这是我们需要注意的事情 

796
00:42:04,740 --> 00:42:05,698
而且它在发行版中 

797
00:42:05,698 --> 00:42:09,920
他有跌倒状态和跳跃状态 

798
00:42:09,920 --> 00:42:13,160
即使它们共享相同的动画 

799
00:42:13,160 --> 00:42:15,690
他们有不同的行为 

800
00:42:15,690 --> 00:42:24,180
因此 让我们继续查看这里的Character 4发行版 

801
00:42:24,180 --> 00:42:28,130
所以我在这里做的是 我为这个角色添加了一个增量y 

802
00:42:28,130 --> 00:42:31,340
所以就像在Flappy Bird中我们按空格键一样

803
00:42:31,340 --> 00:42:34,710
我们的增量y上升到负50--

804
00:42:34,710 --> 00:42:37,370
所以立刻涨到了相当高的水平 因为

805
00:42:37,370 --> 00:42:38,870
适用于每一帧 

806
00:42:38,870 --> 00:42:41,150
这里也是一样 

807
00:42:41,150 --> 00:42:45,560
一旦我们按下空格键 我们将把增量y改为负50

808
00:42:45,560 --> 00:42:53,100
如果我们往下走到这里 

809
00:42:53,100 --> 00:42:56,990
因此 如果键等于空格 我将它放在love.keyPressed函数中 

810
00:42:56,990 --> 00:42:59,810
因为我们是在Main.Lua中做这一切 只是为了说明 

811
00:42:59,810 --> 00:43:02,890
事情有点简单 

812
00:43:02,890 --> 00:43:05,720
如果密钥等于空间并且他的增量y是

813
00:43:05,720 --> 00:43:07,670
等于0 如果我们不这样做会发生什么

814
00:43:07,670 --> 00:43:09,775
检查增量y是否等于0？

815
00:43:09,775 --> 00:43:11,475
观众：我们在空中双人跳跃 

816
00:43:11,475 --> 00:43:12,225
科尔顿·奥格登：是的 

817
00:43:12,225 --> 00:43:15,470
我们将能够无限跳跃 所以我们必须对此进行检查 

818
00:43:15,470 --> 00:43:17,330
我们把他的速度调到了跳跃速度 

819
00:43:17,330 --> 00:43:26,660
JUMP_SPECTURE是第29行上的一个常量 它是负200 

820
00:43:26,660 --> 00:43:29,060
重力等于7 

821
00:43:29,060 --> 00:43:34,220
所以我们要做的就是把它设置为负200--他的增量y--

822
00:43:34,220 --> 00:43:35,600
只要他一跳起来 

823
00:43:35,600 --> 00:43:40,850
然后更新中的每一帧 我们基本上

824
00:43:40,850 --> 00:43:43,580
通过重力增加他的增量y 

825
00:43:43,580 --> 00:43:50,634
然后我们把他的y增加 乘以 

826
00:43:50,634 --> 00:43:52,800
所以它的效果就是当他在空中时

827
00:43:52,800 --> 00:43:57,950
他的速度是负的 实际上

828
00:43:57,950 --> 00:44:00,530
开始变得越来越积极 直到它变得积极 

829
00:44:00,530 --> 00:44:03,350
然后他倒在地上 

830
00:44:03,350 --> 00:44:05,810
然后是我之前提到的黑客攻击--

831
00:44:05,810 --> 00:44:10,490
因为我们还没有在这个例子中实现碰撞检测--

832
00:44:10,490 --> 00:44:13,310
我们只是想看看他有没有

833
00:44:13,310 --> 00:44:17,180
低于我们设定的地图底线 

834
00:44:17,180 --> 00:44:22,280
如果他有 那么首先把他的位置设定在那块瓷砖的上方

835
00:44:22,280 --> 00:44:23,780
这里是133线 

836
00:44:23,780 --> 00:44:25,722
然后将他的增量y设为0 

837
00:44:25,722 --> 00:44:27,680
这将允许我们再次进入太空 

838
00:44:27,680 --> 00:44:29,462
因为他的增量y等于0 

839
00:44:29,462 --> 00:44:32,696
观众：所以我没有在上面看到[INAUDIBLE] 

840
00:44:32,696 --> 00:44:34,550
那么 看起来总是有重力存在 

841
00:44:34,550 --> 00:44:35,810
科尔顿·奥格登：总会有重力 某种东西

842
00:44:35,810 --> 00:44:37,570
我在演讲前不久意识到 

843
00:44:37,570 --> 00:44:44,540
但我认为 你真正需要做的就是 如果角色死了--

844
00:44:44,540 --> 00:44:45,230
嗯 

845
00:44:45,230 --> 00:44:48,271
您可以很容易地将其提取出来--只需围绕它添加一条if语句 

846
00:44:48,271 --> 00:44:50,272
观众：这只是浪费资源 对吗？

847
00:44:50,272 --> 00:44:51,104
科尔顿·奥格登：是的 

848
00:44:51,104 --> 00:44:53,300
我是说 这并不贵 因为你所做的

849
00:44:53,300 --> 00:44:57,075
是将变量递增一定的量 

850
00:44:57,075 --> 00:44:59,700
如果说有什么不同的话 那就是如果你每一帧都要引入一个IF条件 

851
00:44:59,700 --> 00:45:01,910
即使不是更多 也可能是相同的 

852
00:45:01,910 --> 00:45:06,030
我认为分支更像是CPU 而不仅仅是一个赋值 

853
00:45:06,030 --> 00:45:09,004
对于这一点 我不是完全确定 

854
00:45:09,004 --> 00:45:09,940
观众：很有趣 

855
00:45:09,940 --> 00:45:10,731
科尔顿·奥格登：是的 

856
00:45:10,731 --> 00:45:13,860
在这种情况下 它实际上没有任何副作用 

857
00:45:13,860 --> 00:45:16,410
但值得注意的是 这是一件好事 

858
00:45:16,410 --> 00:45:20,265
但现在请注意 我们可以沿着这里的地板走 

859
00:45:20,265 --> 00:45:21,890
因为没有碰撞检测 

860
00:45:21,890 --> 00:45:27,320
我们将很快讨论如何实现冲突检测 

861
00:45:27,320 --> 00:45:31,430
所以我们要开始讨论的一件事--我们会好好休息一下

862
00:45:31,430 --> 00:45:32,660
很快--

863
00:45:32,660 --> 00:45:34,250
是程序级生成 

864
00:45:34,250 --> 00:45:36,350
所以我是程序级生成的铁杆粉丝 

865
00:45:36,350 --> 00:45:39,470
而平台级别实际上相当容易--

866
00:45:39,470 --> 00:45:40,790
至少在简单的意义上--

867
00:45:40,790 --> 00:45:43,170
在程序上产生 

868
00:45:43,170 --> 00:45:47,060
所以就像第三场比赛一样 我们基本上

869
00:45:47,060 --> 00:45:48,890
只是在我们的网格中循环 然后

870
00:45:48,890 --> 00:45:52,580
比方说 哦 得到一个随机的颜色和一个随机的变化 

871
00:45:52,580 --> 00:45:56,306
然后在任务中 事情变得有点复杂 

872
00:45:56,306 --> 00:45:59,180
在那里 你必须检查你是否处于第一级 

873
00:45:59,180 --> 00:46:01,040
如果你不是 那么你的品种

874
00:46:01,040 --> 00:46:05,422
应该是一定的数量 这取决于你已经走了多远

875
00:46:05,422 --> 00:46:06,380
在比赛中取得了进步 

876
00:46:09,710 --> 00:46:13,970
有了平台级别 我们必须考虑

877
00:46:13,970 --> 00:46:21,800
关于我们如何利用磁贴ID的网格 并从数学上考虑它 

878
00:46:21,800 --> 00:46:26,870
我们如何才能得到一个级别的结果 但每次都让它不同--

879
00:46:26,870 --> 00:46:30,110
引入一些变种 对吗？

880
00:46:30,110 --> 00:46:33,710
所以我找到的解决方案是最有意义的

881
00:46:33,710 --> 00:46:37,500
是一列接一列地进行 

882
00:46:37,500 --> 00:46:41,880
所以在这里 我们只有一堆--这只是

883
00:46:41,880 --> 00:46:45,680
一个非常简单的完美屏幕截图来说明一个非常简单的方式

884
00:46:45,680 --> 00:46:47,030
生成标高的能力 

885
00:46:47,030 --> 00:46:53,180
但请记住 如果我们只考虑这些瓷砖--这些空白空间--

886
00:46:53,180 --> 00:46:59,720
作为0 而这些是1 在这种情况下 它几乎是二进制的 

887
00:46:59,720 --> 00:47:05,630
我们可以先用0填充整个空间 只需假定为空 

888
00:47:05,630 --> 00:47:10,040
然后我们可以一列一列地往下走 只有一个机会

889
00:47:10,040 --> 00:47:10,730
每一列 

890
00:47:10,730 --> 00:47:12,740
好的 我要在这里建一个地面吗？

891
00:47:12,740 --> 00:47:15,830
如果我这样做了 从底层开始 然后

892
00:47:15,830 --> 00:47:18,470
一直向下生成土砖 

893
00:47:18,470 --> 00:47:22,850
然后转到下一个x位置 做同样的事情 做同样的事情 

894
00:47:22,850 --> 00:47:26,420
然后 也许你产生的世界上的每一列 

895
00:47:26,420 --> 00:47:29,540
你也有机会产生这样的支柱 

896
00:47:29,540 --> 00:47:35,300
因此 如果生成支柱是真的 那么我想要产生--

897
00:47:35,300 --> 00:47:38,720
我想从这里开始 而不是从这里开始 

898
00:47:38,720 --> 00:47:41,020
然后你可能会有一面旗子上写着 

899
00:47:41,020 --> 00:47:43,140
好的 我不仅想要产生柱子 

900
00:47:43,140 --> 00:47:45,590
我还想生成裂缝--

901
00:47:45,590 --> 00:47:47,874
只有空旷的空间 对球员来说是障碍 

902
00:47:47,874 --> 00:47:50,290
因为如果他掉下来--掉到世界空间之下--

903
00:47:50,290 --> 00:47:51,870
游戏就该结束了

904
00:47:51,870 --> 00:47:55,400
那么这样的话 你就说如果产生鸿沟--

905
00:47:55,400 --> 00:47:59,270
做数学 随机10或其他什么--

906
00:47:59,270 --> 00:48:01,160
那就去下一个x

907
00:48:01,160 --> 00:48:02,340
什么都别做

908
00:48:02,340 --> 00:48:04,670
这将产生一个鸿沟的结果 

909
00:48:04,670 --> 00:48:07,250
一点点地

910
00:48:07,250 --> 00:48:10,010
做这样的小事

911
00:48:10,010 --> 00:48:14,810
产生了很多视觉上有趣的 动态的 

912
00:48:14,810 --> 00:48:15,691
和随机水平 

913
00:48:15,691 --> 00:48:16,940
你永远不知道会发生什么 

914
00:48:16,940 --> 00:48:19,290
这是一个非常基本的例子 

915
00:48:19,290 --> 00:48:21,780
你可以用它无限远 

916
00:48:21,780 --> 00:48:25,520
不管你有多少关于如何

917
00:48:25,520 --> 00:48:28,610
为玩家创造障碍、有趣的关卡和风景--

918
00:48:28,610 --> 00:48:30,758
你完全可以实现它 

919
00:48:30,758 --> 00:48:35,159
观众：如果有一个平台可以跳上去 你怎么处理？

920
00:48:35,159 --> 00:48:37,239
你必须有这种一致性 

921
00:48:37,239 --> 00:48:38,030
是的 

922
00:48:38,030 --> 00:48:41,750
所以如果它是一个平台 这取决于你想如何实现平台 

923
00:48:45,090 --> 00:48:47,870
实际上 我参加了一个关于超级马里奥兄弟的研讨会 

924
00:48:47,870 --> 00:48:50,840
我们把平台做成瓷砖 

925
00:48:50,840 --> 00:48:53,980
在这种情况下 我们将有块 实际上是

926
00:48:53,980 --> 00:48:55,940
我们称之为游戏对象--

927
00:48:55,940 --> 00:48:58,010
和瓷砖有点不同

928
00:48:58,010 --> 00:49:00,950
因为它们可以有任意的大小 而且它们不一定

929
00:49:00,950 --> 00:49:02,990
都必须连接到世界电网上

930
00:49:02,990 --> 00:49:08,960
但是如果你要把一个平台 比如说 

931
00:49:08,960 --> 00:49:14,630
两块瓷砖那么宽 你要做的就是

932
00:49:14,630 --> 00:49:19,250
基本上就是在这里有一个标志 就像 生成平台

933
00:49:19,250 --> 00:49:20,987
等于真或者别的什么

934
00:49:20,987 --> 00:49:22,570
观众：然后关掉它 

935
00:49:22,570 --> 00:49:24,170
科尔顿·奥格登：不管迭代多少次 都要把它关掉 

936
00:49:24,170 --> 00:49:25,610
你也需要它的大小 

937
00:49:25,610 --> 00:49:29,834
你需要一面旗子 就像平台宽度等于多少 

938
00:49:29,834 --> 00:49:31,250
所以你只需要保留一个计数器

939
00:49:31,250 --> 00:49:35,960
就像当前平台瓦片等于1 2 3 

940
00:49:35,960 --> 00:49:39,260
如果它等于width 那么你就不会再生成它了 

941
00:49:39,260 --> 00:49:43,560
这就有可能与柱子相撞

942
00:49:43,560 --> 00:49:44,810
如果你不考虑这个的话

943
00:49:44,810 --> 00:49:49,760
所以你也可以在你的逻辑中说 如果我现在正在生成一个平台 

944
00:49:49,760 --> 00:49:50,930
不要产生柱子 

945
00:49:50,930 --> 00:49:52,971
但你可能会产生一个裂缝 因为这个裂缝

946
00:49:52,971 --> 00:49:56,330
不会干扰您的平台 

947
00:50:01,160 --> 00:50:04,170
如果你没有平台作为瓷砖--如果它们是不同的物体--

948
00:50:04,170 --> 00:50:07,370
那么 您就不必在实际的世界生成阶段这样做了 

949
00:50:07,370 --> 00:50:08,660
你可以直接测试一下 

950
00:50:08,660 --> 00:50:12,020
你可以只创建一个游戏对象 这是一个平台 

951
00:50:12,020 --> 00:50:14,417
取决于你的算法有多复杂 

952
00:50:14,417 --> 00:50:17,250
也许当你生成它的时候 要确保它不在柱子旁边 

953
00:50:17,250 --> 00:50:20,900
你可以把瓷砖放在这里 然后看一看

954
00:50:20,900 --> 00:50:22,640
在接下来的四块瓷砖上--

955
00:50:22,640 --> 00:50:23,810
差不多就是这样 

956
00:50:23,810 --> 00:50:29,690
在本例中 我们不使用平台 但它是

957
00:50:29,690 --> 00:50:31,910
你可以很容易地用瓷砖做到这一点 

958
00:50:31,910 --> 00:50:36,470
虽然难度稍大 但仍相当容易

959
00:50:36,470 --> 00:50:40,460
处理游戏对象 它包含在发行版中

960
00:50:40,460 --> 00:50:42,680
我们稍后会谈到这一点 

961
00:50:45,802 --> 00:50:49,450
让我们看看 我们在一个水平上--

962
00:50:49,450 --> 00:50:51,950
哦 在我们开始之前我还有几件事想展示

963
00:50:51,950 --> 00:50:55,730
实际上 开始学习如何生成关卡的代码 

964
00:50:55,730 --> 00:51:00,275
这是整个项目的精灵工作表 这是一个非常酷的精灵

965
00:51:00,275 --> 00:51:02,460
我在网上找到的一张纸 

966
00:51:02,460 --> 00:51:04,944
这是在马里奥这样的平台上的精神 

967
00:51:04,944 --> 00:51:07,110
它的右边有一个很好的小模型 

968
00:51:07,110 --> 00:51:08,930
所以我鼓励你们看看这一点

969
00:51:08,930 --> 00:51:12,530
也许会得到一些灵感 看看所有不同的酷东西 

970
00:51:12,530 --> 00:51:14,896
如果你想的话 可以随便修修补补 

971
00:51:14,896 --> 00:51:17,770
但正如你在这里看到的 有几个非常突出的事情 

972
00:51:17,770 --> 00:51:19,580
我们有一吨的瓷砖 

973
00:51:19,580 --> 00:51:20,830
这些都是瓷砖--

974
00:51:20,830 --> 00:51:22,720
不同的瓷砖和变体 

975
00:51:22,720 --> 00:51:25,240
然后我们这里有一大堆这样的浇头 

976
00:51:25,240 --> 00:51:32,500
所以真正帮助整个演示的是

977
00:51:32,500 --> 00:51:35,140
产生这些能级的一个事实是 我们有

978
00:51:35,140 --> 00:51:37,750
要处理的视觉内容太多了 

979
00:51:37,750 --> 00:51:40,930
这里 再一次 是瓷砖 

980
00:51:40,930 --> 00:51:42,130
这是上等菜 

981
00:51:42,130 --> 00:51:46,360
然后当你把这两者放在一起 然后你也

982
00:51:46,360 --> 00:51:49,840
有这些随机的背景--

983
00:51:49,840 --> 00:51:52,300
这些是顶层 这里是瓷砖的顶层 

984
00:51:52,300 --> 00:51:57,340
仅仅拥有丰富的视觉多样性是令人难以置信的容易

985
00:51:57,340 --> 00:52:00,240
和有趣的东西 在你的游戏水平 甚至没有--

986
00:52:00,240 --> 00:52:02,230
这里的算法非常简单 

987
00:52:02,230 --> 00:52:06,160
我们所做的只是检查以生成柱子和柱子 

988
00:52:06,160 --> 00:52:07,420
我知道呀 

989
00:52:07,420 --> 00:52:13,060
我认为这真的很酷 有助于说明

990
00:52:13,060 --> 00:52:15,934
整个程序性的方法来为这个创造层次 

991
00:52:15,934 --> 00:52:18,850
我认为 实际上并没有那么多的游戏可以利用这一点 

992
00:52:18,850 --> 00:52:21,720
在平台类型中的程序级生成 

993
00:52:21,720 --> 00:52:24,184
很多游戏 比如《我的世界》和《Terraria》--

994
00:52:24,184 --> 00:52:26,600
Terraria就是一个很好的平台 这就是一个例子 

995
00:52:26,600 --> 00:52:29,342
但我不认为我见过真正好的超级马里奥兄弟 

996
00:52:29,342 --> 00:52:30,800
这样做的游戏 

997
00:52:33,620 --> 00:52:34,120
让我们看看 

998
00:52:34,120 --> 00:52:34,580
现在几点？

999
00:52:34,580 --> 00:52:35,230
6：23 

1000
00:52:35,230 --> 00:52:37,210
让我们休息五分钟 

1001
00:52:37,210 --> 00:52:39,100
然后我们一从那里回来 

1002
00:52:39,100 --> 00:52:43,150
我们将开始研究如何真正实现程序级

1003
00:52:43,150 --> 00:52:45,440
更详细的生成 

1004
00:52:45,440 --> 00:52:46,920
好了 欢迎回来 

1005
00:52:46,920 --> 00:52:47,890
这是第四课 

1006
00:52:47,890 --> 00:52:49,681
在我们休息之前 我们聊了聊

1007
00:52:49,681 --> 00:52:54,040
关于平台级别上下文中的程序级别生成 

1008
00:52:54,040 --> 00:53:00,940
回想一下 这里只有几个例子 我很快就用了我的代码 

1009
00:53:00,940 --> 00:53:04,450
你可以看到它们有不同的背景 不同的瓷砖 

1010
00:53:04,450 --> 00:53:07,420
有时我们有裂缝 有时我们有支柱 

1011
00:53:07,420 --> 00:53:12,610
我们将讨论几种方法来实现这一点 

1012
00:53:12,610 --> 00:53:14,120
因为这里有两个层次 

1013
00:53:14,120 --> 00:53:18,620
例如 在发行版中 我们会看到也有灌木丛之类的东西 

1014
00:53:18,620 --> 00:53:21,460
我们可以在中间上方看到紫色的--

1015
00:53:21,460 --> 00:53:24,280
我猜那些紫色的小仙人掌 

1016
00:53:24,280 --> 00:53:28,960
而在它的正下方 有一根柱子 上面有一根黄色的蕨类植物 

1017
00:53:28,960 --> 00:53:31,780
这些是与瓷砖分开的物体--

1018
00:53:31,780 --> 00:53:32,860
游戏对象 

1019
00:53:32,860 --> 00:53:38,170
但实际的瓷砖本身 我们将在这里稍微挖掘一下如何

1020
00:53:38,170 --> 00:53:39,710
才能让它们产生 

1021
00:53:39,710 --> 00:53:44,615
所以我们首先要看的是水平0 只是一些平坦的水平--所以

1022
00:53:44,615 --> 00:53:46,240
基本上就是我们已经做过的 

1023
00:53:46,240 --> 00:53:50,980
所以我要继续 进入0级 

1024
00:53:54,230 --> 00:53:59,680
然后如果我们看到这里 我们有一个简单的平坦的水平 

1025
00:53:59,680 --> 00:54:01,040
就像我们以前做的那样 

1026
00:54:01,040 --> 00:54:02,690
现在瓷砖不同了 

1027
00:54:02,690 --> 00:54:07,360
如果我按R键 它们每次都会随机生成 

1028
00:54:07,360 --> 00:54:12,782
所以你可以感受到这一代人在视觉上看起来有多多样化 

1029
00:54:12,782 --> 00:54:14,740
哦 我想这可能是之前的一个漏洞 

1030
00:54:14,740 --> 00:54:16,090
我没有把握 

1031
00:54:16,090 --> 00:54:17,440
我还没看过呢 

1032
00:54:17,440 --> 00:54:19,480
但我们可以在这里看到 我在按R键 

1033
00:54:19,480 --> 00:54:26,020
我要做的就是把我们拥有的瓷砖阵列 

1034
00:54:26,020 --> 00:54:30,430
我给它分配了一套瓷砖和一套顶层

1035
00:54:30,430 --> 00:54:35,830
在这一代的范围的情况下 

1036
00:54:35,830 --> 00:54:39,460
回想一下 顶层只是顶层的精灵 

1037
00:54:39,460 --> 00:54:46,180
瓷砖就是下面的瓷砖 

1038
00:54:46,180 --> 00:54:51,100
有没有人想建议我是如何渲染顶层和瓷砖的

1039
00:54:51,100 --> 00:54:53,856
那里发生了什么事？

1040
00:54:53,856 --> 00:54:58,100
观众：你只是把它从床单的一部分拉出来 对吗？

1041
00:54:58,100 --> 00:54:58,850
科尔顿·奥格登：是的 

1042
00:54:58,850 --> 00:55:01,282
是的 简而言之 我只是在拉开盖子

1043
00:55:01,282 --> 00:55:02,740
从床单的不同部分 

1044
00:55:02,740 --> 00:55:05,510
你知道我是如何存储信息的吗--这里存储了什么

1045
00:55:05,510 --> 00:55:08,195
才能让它像这样渲染？

1046
00:55:08,195 --> 00:55:12,155
观众：也许你只需要把陀螺的位置储存起来

1047
00:55:12,155 --> 00:55:15,620
并知道其他一切都低于这一点 

1048
00:55:15,620 --> 00:55:16,460
科尔顿·奥格登：是的 

1049
00:55:16,460 --> 00:55:18,410
这样你就可以存储顶部的位置

1050
00:55:18,410 --> 00:55:21,200
并知道其他一切都低于这一点 

1051
00:55:21,200 --> 00:55:24,360
这将适用于平坦的水平 

1052
00:55:24,360 --> 00:55:27,502
我认为对于有柱子的楼层来说 这是不可靠的 

1053
00:55:27,502 --> 00:55:29,960
因为柱子的高度比地面高 

1054
00:55:29,960 --> 00:55:32,001
然后还有裂缝之类的东西 

1055
00:55:35,090 --> 00:55:37,115
所以实际上这里发生的事情是我们

1056
00:55:37,115 --> 00:55:41,850
在瓷砖上存储一面旗帜 说明上面是否有顶层 

1057
00:55:41,850 --> 00:55:45,320
如果它有顶部 那么我们不仅渲染瓷砖 

1058
00:55:45,320 --> 00:55:49,580
但一旦我们渲染了瓷砖 我们也渲染了顶部 

1059
00:55:49,580 --> 00:55:54,650
在这里 我不会深入到代码中 

1060
00:55:54,650 --> 00:55:58,640
但我们正在做的是让所有这些不同的瓷砖集和顶层集

1061
00:55:58,640 --> 00:56:04,570
还有就是我们必须把所有这些瓷砖--这些瓷砖的集合--

1062
00:56:04,570 --> 00:56:06,050
然后把它们分了 对吗？

1063
00:56:06,050 --> 00:56:09,390
我们必须知道 如果我们想要以瓷砖呈现整个关卡

1064
00:56:09,390 --> 00:56:15,450
设置一个 那么我们基本上应该把这个放到它自己的工作表上--

1065
00:56:15,450 --> 00:56:19,190
它自己的表--这个放到自己的表里 这个放到自己的表里 

1066
00:56:19,190 --> 00:56:21,560
实际上是从左到右 

1067
00:56:21,560 --> 00:56:26,370
我们基本上有四路嵌套循环 

1068
00:56:26,370 --> 00:56:31,460
所以我们用x上的每一组来计算y上的每一组 

1069
00:56:31,460 --> 00:56:36,380
然后在其中的每一个中 我们要查找沿x的每一块瓷砖

1070
00:56:36,380 --> 00:56:40,070
和沿y方向的每一块瓷砖 并分开

1071
00:56:40,070 --> 00:56:45,020
瓷砖设置 这样我们就可以索引到单独的四边形 

1072
00:56:45,020 --> 00:56:49,430
所以在实际的代码中 我不会在这里深入研究它 

1073
00:56:49,430 --> 00:56:53,330
但如果你对我们是如何做到这一点感兴趣的 我可以带你去看看 

1074
00:56:53,330 --> 00:56:58,790
它在源代码中的马里奥 util.lua 这是我们以前回忆起的地方

1075
00:56:58,790 --> 00:57:02,930
存储了我们的GenerateQuads函数 该函数对切片执行简单的拆分

1076
00:57:02,930 --> 00:57:08,420
根据传入的宽度和高度沿其x和y方向放置工作表 

1077
00:57:08,420 --> 00:57:14,210
这里还有一个GenerateTileSets函数 它接受四元组

1078
00:57:14,210 --> 00:57:16,790
来自GenerateQuads表的 

1079
00:57:16,790 --> 00:57:22,520
因此 我们首先在所有这些或所有这些上生成四元组 

1080
00:57:22,520 --> 00:57:26,840
所以我们把每一帧都除以16 这就是--

1081
00:57:26,840 --> 00:57:28,130
我不知道那有多少 

1082
00:57:28,130 --> 00:57:33,990
6乘5乘10乘5 10乘4--

1083
00:57:33,990 --> 00:57:38,510
那么多四元 所以成千上万的四元 我想 如果不是几百的话 

1084
00:57:38,510 --> 00:57:41,930
我敢肯定这是几千个四元房 

1085
00:57:41,930 --> 00:57:45,890
然后我们把它取出来 然后用

1086
00:57:45,890 --> 00:57:49,790
沿x轴的集合的数目 y轴上的集合的数目 

1087
00:57:49,790 --> 00:57:53,480
然后每个瓷砖的大小沿x设置 沿y设置大小 

1088
00:57:53,480 --> 00:57:59,801
在这里 我们基本上使用一个四向嵌套循环来划分它 

1089
00:57:59,801 --> 00:58:01,250
我们基本上只是把它分了 

1090
00:58:01,250 --> 00:58:03,980
然后 不是做GenerateQuad

1091
00:58:03,980 --> 00:58:09,950
在整个画面中 我们只是

1092
00:58:09,950 --> 00:58:12,830
基本上对我们得到的四元桌做一个2D切片

1093
00:58:12,830 --> 00:58:14,930
从第一个genateQuad调用开始 

1094
00:58:14,930 --> 00:58:18,229
所以我鼓励你们看看这里 并尝试一下 

1095
00:58:18,229 --> 00:58:21,020
你不一定需要知道它在任务中是如何工作的 

1096
00:58:21,020 --> 00:58:25,400
但这就是我们基本上可以拿到像这样的巨型床单的方式

1097
00:58:25,400 --> 00:58:28,370
并轻松地将其集成到我们的代码中 

1098
00:58:28,370 --> 00:58:32,090
我们只需换入和换出任何活动磁贴

1099
00:58:32,090 --> 00:58:34,520
我们想要处理的工作表 假设一切

1100
00:58:34,520 --> 00:58:38,510
像这样干净地布局 这是你或你的艺术家的一部分 

1101
00:58:38,510 --> 00:58:44,000
你要确保一切都有利于程序化的组织 

1102
00:58:44,000 --> 00:58:46,830
如果东西以一种非常尴尬的方式散布--

1103
00:58:46,830 --> 00:58:50,300
也许东西是之字形的 或者有奇怪的空间或类似的东西

1104
00:58:50,300 --> 00:58:50,900
那个--

1105
00:58:50,900 --> 00:58:53,630
我们不能做像我们在这里做的那样干净的事情

1106
00:58:53,630 --> 00:58:57,620
Util.lua中只有63减去20行代码

1107
00:58:57,620 --> 00:59:01,164
通过获取每个单独的瓷砖集 

1108
00:59:01,164 --> 00:59:03,080
所以这是一个重要的考虑因素

1109
00:59:03,080 --> 00:59:06,260
考虑为您的项目创建资产

1110
00:59:06,260 --> 00:59:11,601
并且您想要对您的磁贴集进行一些程序化的热交换 

1111
00:59:11,601 --> 00:59:13,100
让我们确保我们是对的--

1112
00:59:13,100 --> 00:59:15,980
我们在这里不是正确的例子 所以我们

1113
00:59:15,980 --> 00:59:23,210
进入0层进入主干道 

1114
00:59:23,210 --> 00:59:27,380
现在我们有了所有瓷砖的常量 高度是多少

1115
00:59:27,380 --> 00:59:28,865
以及它们有多少是宽到高的 

1116
00:59:32,330 --> 00:59:33,380
我们在这里做 

1117
00:59:33,380 --> 00:59:36,530
我们从我们的瓷砖和鞋面上拿到我们的普通四元房 

1118
00:59:36,530 --> 00:59:39,730
所以这些就是那块大瓷砖里的每一块瓷砖

1119
00:59:39,730 --> 00:59:40,810
把床单放在一张桌子上 

1120
00:59:40,810 --> 00:59:42,560
然后我们就分成了几组瓷砖

1121
00:59:42,560 --> 00:59:45,860
和topper集 在这里使用GenerateTileSets函数 

1122
00:59:45,860 --> 00:59:50,160
然后我们得到一个随机的瓦片集和一个随机的顶层集--

1123
00:59:50,160 --> 00:59:54,260
随机数、瓦片集的数目、顶层集的数目 

1124
00:59:54,260 --> 01:00:00,480
在最下面 我们有一个GenerateLevel函数--

1125
01:00:00,480 --> 01:00:03,846
223--它将在接下来的两个示例中构建 

1126
01:00:03,846 --> 01:00:05,720
0级只是一个平坦的级别 所以实际上

1127
01:00:05,720 --> 01:00:11,960
这就是我们之前看到的 如果y小于7 

1128
01:00:11,960 --> 01:00:14,770
ID应等于天空或地面 

1129
01:00:14,770 --> 01:00:17,067
然后这一部分实际上就是我

1130
01:00:17,067 --> 01:00:19,150
用最上面的词暗指之前 因为回忆起

1131
01:00:19,150 --> 01:00:23,690
我们需要在瓷砖中存储一面旗帜来渲染或不渲染顶部 

1132
01:00:23,690 --> 01:00:28,540
它应该是地面上最上面的瓷砖是什么 

1133
01:00:28,540 --> 01:00:31,960
在这个非常简单的扁平物体中 我们总是可以

1134
01:00:31,960 --> 01:00:34,060
假设它将是相同的y能级 

1135
01:00:34,060 --> 01:00:36,580
在本例中 如果它等于7 则topper

1136
01:00:36,580 --> 01:00:38,500
应为真 否则为假 

1137
01:00:38,500 --> 01:00:43,600
所以沿y7的每一块瓷砖的topper都等于真 

1138
01:00:43,600 --> 01:00:46,420
这一点在这里发挥了作用 

1139
01:00:46,420 --> 01:00:55,090
如果我们真的爱 我们就不仅仅像以前那样拥有了.ID

1140
01:00:55,090 --> 01:01:01,150
以前 但我们现在有瓷砖集索引到瓷砖集 

1141
01:01:01,150 --> 01:01:03,760
请记住 tieset获得的随机值介于1

1142
01:01:03,760 --> 01:01:08,930
不管我们从巨大的瓷砖上拼接出多少瓷砖

1143
01:01:08,930 --> 01:01:09,700
床单 

1144
01:01:09,700 --> 01:01:14,650
现在 我们只需对其进行索引 然后再对tile.id进行索引 

1145
01:01:14,650 --> 01:01:21,070
而tile.ID将是我们的ID 但相对于该工作表 而不是

1146
01:01:21,070 --> 01:01:24,320
一下子把整个精灵都干掉了 

1147
01:01:24,320 --> 01:01:25,570
托珀也是如此 

1148
01:01:25,570 --> 01:01:27,700
我们有一个TOPER集合 我们索引到TOPER

1149
01:01:27,700 --> 01:01:31,510
在我们得到的最上面的一组 然后就是

1150
01:01:31,510 --> 01:01:38,045
在那里我们将拥有组成特定集合的瓷砖集合 

1151
01:01:38,045 --> 01:01:39,670
因此 这两者是完全分开的 

1152
01:01:39,670 --> 01:01:43,150
它们可以是一个随机颜色的瓷砖和一个随机的顶层 但它是一致的 

1153
01:01:43,150 --> 01:01:43,660
这是全球性的 

1154
01:01:43,660 --> 01:01:47,870
我们有一套顶层和一套瓷砖 它们在任何时候都是活动的 

1155
01:01:47,870 --> 01:01:50,560
如果我们按R键 就像我在上面做的那样 那么我们

1156
01:01:50,560 --> 01:01:52,972
只需在139和140行将它们重置为随机 

1157
01:01:52,972 --> 01:01:55,930
瓦集得到一个新的随机数 TOPER集得到一个新的随机数 

1158
01:01:55,930 --> 01:01:58,220
它的效果是--

1159
01:01:58,220 --> 01:02:01,000
我们可以四处走动 然后生成随机集 

1160
01:02:04,090 --> 01:02:04,960
太简单了 

1161
01:02:04,960 --> 01:02:07,270
再回想一下 托珀是--

1162
01:02:07,270 --> 01:02:12,110
因为我们脚下的瓷砖是y 7 topper等于true 

1163
01:02:12,110 --> 01:02:16,624
所以在这种情况下 特定的顶层总是会有一个顶层 

1164
01:02:16,624 --> 01:02:18,790
它给了我们一个很好的视觉变化 

1165
01:02:18,790 --> 01:02:22,690
因为它实际上会产生很大的不同 

1166
01:02:22,690 --> 01:02:23,944
一个加顶的和一个不加顶的 

1167
01:02:23,944 --> 01:02:26,110
你也可以不戴帽子 

1168
01:02:26,110 --> 01:02:33,250
这是一个排列的toppers倍瓷砖 像程序算法 

1169
01:02:33,250 --> 01:02:34,150
这是平坦的水平 

1170
01:02:34,150 --> 01:02:36,740
有谁对这是怎么运作的有任何疑问吗

1171
01:02:36,740 --> 01:02:38,230
或者我们在这里做的任何事

1172
01:02:41,300 --> 01:02:42,780
好的.

1173
01:02:42,780 --> 01:02:46,140
所以事情有点平淡 有点无聊 

1174
01:02:46,140 --> 01:02:50,160
下一步我们要介绍的是

1175
01:02:50,160 --> 01:02:55,110
我们可以在这里看到我们的样本水平的小集合 

1176
01:02:55,110 --> 01:02:58,290
就像中间的这根柱子

1177
01:02:58,290 --> 01:03:02,670
有谁记得我们是怎么产生一个柱子的

1178
01:03:02,670 --> 01:03:06,428
变成平地

1179
01:03:06,428 --> 01:03:10,027
观众：对于那一栏 只是把一些更多的污垢或更多的瓷砖下来 

1180
01:03:10,027 --> 01:03:11,430
是的 

1181
01:03:11,430 --> 01:03:15,880
因此 对于这一列 只是把更多的瓷砖下来 而不仅仅是地面水平 

1182
01:03:15,880 --> 01:03:17,530
这正是我们要做的

1183
01:03:17,530 --> 01:03:21,840
所以我要打开一楼和主干道 

1184
01:03:21,840 --> 01:03:25,770
我也会运行这个例子 这样你们就能看到它是什么样子的 

1185
01:03:30,100 --> 01:03:32,590
这里我们有不少 

1186
01:03:32,590 --> 01:03:34,340
注意我们还没有实现碰撞 

1187
01:03:34,340 --> 01:03:35,970
所以我们还在查

1188
01:03:35,970 --> 01:03:38,120
但他们只是随机的 

1189
01:03:38,120 --> 01:03:40,530
它们的随机数量取决于口味 真的 

1190
01:03:40,530 --> 01:03:43,920
在这里很常见 所以可能值得

1191
01:03:43,920 --> 01:03:46,500
把数量降低一点

1192
01:03:46,500 --> 01:03:51,120
如果你想的话 你也可以有一面旗帜 上面写着 产卵之柱 

1193
01:03:51,120 --> 01:03:52,800
也许你想要一个支柱宽度 

1194
01:03:52,800 --> 01:03:56,430
你可以有一个到三个瓷砖之间的任何地方 

1195
01:03:56,430 --> 01:04:02,070
如果它的宽度大于1 那么只需循环几次

1196
01:04:02,070 --> 01:04:05,970
把同一高度画几次而不是一次 

1197
01:04:05,970 --> 01:04:08,982
然后将标志设回false 

1198
01:04:08,982 --> 01:04:10,440
你可以用它做很多事情 

1199
01:04:10,440 --> 01:04:12,120
而且这里有点高

1200
01:04:12,120 --> 01:04:15,214
对于主要发行版 我最终使它们变短了一点 

1201
01:04:15,214 --> 01:04:17,130
但我们将在代码中看到如何做到这一点 

1202
01:04:17,130 --> 01:04:23,800
它主要在我们的generateLevel函数中 

1203
01:04:23,800 --> 01:04:26,340
所以我们在这里做的--继续隐藏--

1204
01:04:26,340 --> 01:04:28,970
我们有一个基本的代码--

1205
01:04:28,970 --> 01:04:31,500
第227至236行 

1206
01:04:31,500 --> 01:04:38,820
所以我们要做的就是用天空填满整个空间 

1207
01:04:38,820 --> 01:04:41,340
我们只是把它设为空 

1208
01:04:41,340 --> 01:04:45,520
现在我们有一个完全填充的2D数组 

1209
01:04:45,520 --> 01:04:47,520
我们要做的就是改变瓷砖--我们

1210
01:04:47,520 --> 01:04:52,530
不必担心插入或添加太多的瓷砖到我们的数组 

1211
01:04:52,530 --> 01:04:56,670
我们现在所能做的就是直接改变那里存在的任何瓷砖 

1212
01:04:56,670 --> 01:05:01,380
所以我们要做的就是从239行开始 

1213
01:05:01,380 --> 01:05:05,400
我们将开始在整个级别上逐列迭代

1214
01:05:05,400 --> 01:05:09,150
并决定我们是否应该建立支柱 

1215
01:05:09,150 --> 01:05:11,960
我们总是会产生地面 

1216
01:05:11,960 --> 01:05:14,960
这是旗帜衍生柱 

1217
01:05:14,960 --> 01:05:18,690
如果它等于1 这基本上会被分配给spawnPillar 

1218
01:05:18,690 --> 01:05:20,190
所以math.random（5）==1.

1219
01:05:20,190 --> 01:05:24,300
我们有五分之一的机会产生一个柱子 

1220
01:05:24,300 --> 01:05:28,755
如果我们只需要一个柱子 那么柱子从4到6等于4--

1221
01:05:28,755 --> 01:05:34,470
所以y等于4到6

1222
01:05:34,470 --> 01:05:37,800
x柱上的瓷砖 ID地面 

1223
01:05:37,800 --> 01:05:41,310
然后在这里我们设置顶部 回忆一下 

1224
01:05:41,310 --> 01:05:47,820
因为现在柱子可以是表面上最上面的瓦片 

1225
01:05:47,820 --> 01:05:49,320
但它们在地面以上 

1226
01:05:49,320 --> 01:05:53,540
所以我们基本上就是说 当我们生成一个柱子时 

1227
01:05:53,540 --> 01:05:57,300
如果pillar等于4--也就是我们开始的第一个瓦片--

1228
01:05:57,300 --> 01:05:59,190
然后在这里设置topper等于true 

1229
01:05:59,190 --> 01:06:01,140
否则 将其设置为false 

1230
01:06:01,140 --> 01:06:06,601
所以这就是我们如何让柱子也有顶部 然后在这种情况下 

1231
01:06:06,601 --> 01:06:08,100
我们还没有产生任何裂缝

1232
01:06:08,100 --> 01:06:09,183
所以我们要做的就是

1233
01:06:11,850 --> 01:06:15,030
一旦我们在那个特定的柱子上生成了一个柱子 

1234
01:06:15,030 --> 01:06:18,060
我们就说地是7直到地图的高度

1235
01:06:18,060 --> 01:06:21,130
因此 在屏幕的最底部 

1236
01:06:21,130 --> 01:06:22,720
然后我们就把它放在地面上 

1237
01:06:22,720 --> 01:06:25,890
在这种情况下 我们要确保

1238
01:06:25,890 --> 01:06:27,690
我们不是在生一根柱子 

1239
01:06:27,690 --> 01:06:29,850
因为如果我们不检查这个 它就会

1240
01:06:29,850 --> 01:06:35,310
在柱子与地面相接的地方也会产生一个顶端 

1241
01:06:35,310 --> 01:06:36,930
这看起来会有点傻 

1242
01:06:36,930 --> 01:06:39,500
然后我们还想检查地面是否等于7 

1243
01:06:39,500 --> 01:06:44,560
所以加在一起 这就产生了这种行为的影响 

1244
01:06:44,560 --> 01:06:47,400
因此 如果我们不检查那个产卵支柱 

1245
01:06:47,400 --> 01:06:49,560
我们的脚下也会有一个鞋帽 

1246
01:06:49,560 --> 01:06:52,320
这看起来很奇怪 

1247
01:06:52,320 --> 01:06:54,240
而且 你也可以看到--

1248
01:06:54,240 --> 01:06:59,169
紧急情况下 我们得到了两倍宽的柱子 

1249
01:06:59,169 --> 01:07:00,960
这只是一种天然的副产品

1250
01:07:00,960 --> 01:07:02,420
很多这样的随机化 

1251
01:07:02,420 --> 01:07:05,490
很多这样的程序性算法--

1252
01:07:05,490 --> 01:07:08,040
他们会产生你可能不一定会产生的结果

1253
01:07:08,040 --> 01:07:10,500
这是一件很酷的事情 

1254
01:07:10,500 --> 01:07:15,180
你不必给它编程 让它有两块瓷砖宽的柱子 

1255
01:07:15,180 --> 01:07:18,000
但这只是随机化的本质--这就是你得到的 

1256
01:07:18,000 --> 01:07:20,791
这是程序级生成的另一个令人兴奋的事情

1257
01:07:20,791 --> 01:07:25,260
它甚至可以让编写算法的人感到惊讶 

1258
01:07:25,260 --> 01:07:30,300
这真的很酷 而且它省去了你必须创建关卡的工作 

1259
01:07:30,300 --> 01:07:32,070
这就是柱子水平 

1260
01:07:32,070 --> 01:07:37,109
鸿沟级别--谁能告诉我我们如何才能计算出鸿沟级别？

1261
01:07:37,109 --> 01:07:40,350
观众：你只要跳过一栏即可 

1262
01:07:40,350 --> 01:07:42,590
科尔顿·奥格登：是的 

1263
01:07:42,590 --> 01:07:43,550
您可以跳过一列 

1264
01:07:43,550 --> 01:07:45,841
所以一开始 我们基本上只能说

1265
01:07:45,841 --> 01:07:48,020
是 我想在这里制造一个鸿沟吗？

1266
01:07:48,020 --> 01:07:50,270
如果我这样做了 就跳过 

1267
01:07:50,270 --> 01:07:53,360
转到循环的下一个迭代 

1268
01:07:53,360 --> 01:07:56,060
所以我们来看看这一点 

1269
01:07:56,060 --> 01:08:00,299
就这么简单 因为Lua没有继续的概念--

1270
01:08:00,299 --> 01:08:02,090
这将是一次重温 因为我相信

1271
01:08:02,090 --> 01:08:04,850
这是在其中一个作业中--

1272
01:08:04,850 --> 01:08:08,310
它有一份Goto声明 

1273
01:08:08,310 --> 01:08:13,450
因此 基本上 代码与前面一样 逐列开始 

1274
01:08:13,450 --> 01:08:16,279
在贴图宽度之前 X等于1 

1275
01:08:16,279 --> 01:08:17,890
我们有七分之一的机会--

1276
01:08:17,890 --> 01:08:20,149
太武断了 

1277
01:08:20,149 --> 01:08:22,250
理想情况下 这应该是--

1278
01:08:22,250 --> 01:08:28,529
如果您正在设计一个完整的大型游戏或应用程序 

1279
01:08:28,529 --> 01:08:31,839
这可能会被称为spawn_chasm_Chance 

1280
01:08:31,839 --> 01:08:33,380
然后在某个地方将其设置为7 

1281
01:08:33,380 --> 01:08:35,180
但我们这里只是把它设为7--

1282
01:08:35,180 --> 01:08:39,560
只是一个静态的幻数 但幻数通常是不好的 

1283
01:08:39,560 --> 01:08:46,460
继续--所以继续在循环的最底部

1284
01:08:46,460 --> 01:08:50,536
这就是x=1的mapWidth 

1285
01:08:50,536 --> 01:08:53,660
所以它会有直接跳到x等于2的效果 如果这是1 

1286
01:08:53,660 --> 01:08:55,670
例如 

1287
01:08:55,670 --> 01:08:58,630
许多语言只是简单地延续了下去 

1288
01:08:58,630 --> 01:09:05,090
Lua没有继续 所以这是社区建立的传统

1289
01:09:05,090 --> 01:09:07,729
用于在Lua中实现类似于Continue的行为 

1290
01:09:07,729 --> 01:09:14,000
您通过双冒号创建一个标签 该标签带有一个名称 然后是一个双冒号 

1291
01:09:14,000 --> 01:09:16,200
然后你就直接去找它 

1292
01:09:16,200 --> 01:09:18,859
这就像产生裂缝一样简单 

1293
01:09:18,859 --> 01:09:26,800
所以 如果我们到第二级运行 我们就会得到裂缝 

1294
01:09:26,800 --> 01:09:30,359
所以现在我们有了一点有趣的视觉变化 

1295
01:09:30,359 --> 01:09:33,680
在这个例子中 它并没有产生大量的裂缝 

1296
01:09:33,680 --> 01:09:35,590
到目前为止 它已经产生了一个 

1297
01:09:35,590 --> 01:09:36,470
还有一个 

1298
01:09:36,470 --> 01:09:38,762
有时只是紧急情况下 你可以得到两个 

1299
01:09:38,762 --> 01:09:39,470
看 这就对了 

1300
01:09:39,470 --> 01:09:41,540
结果 我们遇到了一些有趣的障碍 

1301
01:09:41,540 --> 01:09:43,939
看起来就像是有人故意这么做的--

1302
01:09:43,939 --> 01:09:45,199
差不多了 

1303
01:09:45,199 --> 01:09:47,990
我可能会 就像我说的 把柱子的尺寸缩小一点 

1304
01:09:47,990 --> 01:09:48,781
它有点高 

1305
01:09:52,310 --> 01:09:52,910
就是这样 

1306
01:09:52,910 --> 01:09:56,360
这是基本的程序--在平台的背景下 

1307
01:09:56,360 --> 01:09:58,970
这就是我们如何开始的心理模型

1308
01:09:58,970 --> 01:10:01,059
想着制造障碍 

1309
01:10:01,059 --> 01:10:03,350
你可以选择很多不同的方向 

1310
01:10:03,350 --> 01:10:09,320
比方说 也许你想要建造金字塔 

1311
01:10:09,320 --> 01:10:10,910
我是说 这在马里奥很常见 

1312
01:10:10,910 --> 01:10:14,480
将有步骤 [INAUDIBLE]为它设置 

1313
01:10:14,480 --> 01:10:18,457
同样的实现基本上也会在这里发生 

1314
01:10:18,457 --> 01:10:20,540
会有一点不同 因为你是

1315
01:10:20,540 --> 01:10:22,081
在逐列的基础上这样做 

1316
01:10:22,081 --> 01:10:24,770
但你只需要有效地保持一个引用

1317
01:10:24,770 --> 01:10:27,620
到类似台阶的高度 然后你

1318
01:10:27,620 --> 01:10:30,216
会说生成楼梯在这里是正确的 

1319
01:10:30,216 --> 01:10:32,090
然后您只需将Step Height设置为1 

1320
01:10:32,090 --> 01:10:34,360
然后你在这里添加一块瓷砖 

1321
01:10:34,360 --> 01:10:37,800
你可以从地面一直到台阶高度 生成一块瓷砖 

1322
01:10:37,800 --> 01:10:40,520
转到下一步 然后将步高增加到2 

1323
01:10:40,520 --> 01:10:44,630
然后从地面开始 直到台阶的高度--

1324
01:10:44,630 --> 01:10:45,620
瓷砖会往上爬 

1325
01:10:45,620 --> 01:10:51,080
然后是1 然后是2和3 直到达到楼梯宽度 在这种情况下

1326
01:10:51,080 --> 01:10:52,400
您将停止生成楼梯 

1327
01:10:52,400 --> 01:10:56,955
这就是你如何

1328
01:10:56,955 --> 01:10:58,580
做一些稍微复杂一点的事情 

1329
01:10:58,580 --> 01:11:00,980
或者金字塔--同样的东西 金字塔的宽度 

1330
01:11:00,980 --> 01:11:03,890
然后你一直走到金字塔的宽度等于--

1331
01:11:03,890 --> 01:11:07,430
或者我们在金字塔宽度除以2 让它向上 

1332
01:11:07,430 --> 01:11:09,540
如果我们比它高 就让它降下来 

1333
01:11:09,540 --> 01:11:12,760
然后你就会得到金字塔方法的影响 

1334
01:11:12,760 --> 01:11:13,516
嗯 

1335
01:11:13,516 --> 01:11:15,265
观众：你们把栏目放在哪里？

1336
01:11:15,265 --> 01:11:18,576
如果它是[INAUDIBLE] 则生成 

1337
01:11:18,576 --> 01:11:20,480
它没有处于播放状态 

1338
01:11:20,480 --> 01:11:22,550
科尔顿·奥格登：在这种情况下 一切都在主线上 卢阿 

1339
01:11:22,550 --> 01:11:25,520
但在发行版中 它将位于Level Maker.lua中 

1340
01:11:25,520 --> 01:11:28,400
所以我们已经突破了所有这些功能

1341
01:11:28,400 --> 01:11:31,730
我们是如何越狱的 

1342
01:11:31,730 --> 01:11:34,100
我们有同样的东西--水平制造者--

1343
01:11:34,100 --> 01:11:35,620
它只有LevMaker.Generate 

1344
01:11:35,620 --> 01:11:37,370
然后你给它一个宽度和高度 

1345
01:11:37,370 --> 01:11:39,621
它将为你生成一个完整的关卡 

1346
01:11:39,621 --> 01:11:42,507
观众：整个级别 但它必须持续--

1347
01:11:42,507 --> 01:11:44,912
哦 你一下子把它都生成了？

1348
01:11:44,912 --> 01:11:48,244
它不会在你走路时产生吗？

1349
01:11:48,244 --> 01:11:51,410
科尔顿·奥格登：问题是 它是持续产生的 还是一次性产生的？

1350
01:11:51,410 --> 01:11:53,010
它只是一下子产生所有的东西 

1351
01:11:53,010 --> 01:11:56,090
所以你可以实施一个--

1352
01:11:56,090 --> 01:12:01,820
如果你想成为一名无限长跑运动员 你会选择你自己

1353
01:12:01,820 --> 01:12:04,450
会把你的关卡分成小块 

1354
01:12:04,450 --> 01:12:07,860
而对于无限的跑步者 通常你只能朝一个方向移动 

1355
01:12:07,860 --> 01:12:10,850
所以当你向右转时 你之前产生的水平--他们得到

1356
01:12:10,850 --> 01:12:14,960
丢弃 因此您可以避免内存过度消耗 

1357
01:12:14,960 --> 01:12:17,270
你要做的就是生成一大块--

1358
01:12:17,270 --> 01:12:19,940
也许是100乘20级 

1359
01:12:19,940 --> 01:12:22,850
然后你会经历那个 经历那个 

1360
01:12:22,850 --> 01:12:28,040
然后当你到达平端时 可能减去5块或10块瓷砖 

1361
01:12:28,040 --> 01:12:32,840
你会生成另一个 附加它 放在右边 

1362
01:12:32,840 --> 01:12:36,740
然后你就可以从左边转到右边 

1363
01:12:36,740 --> 01:12:40,960
你可能需要一些半花哨的代码

1364
01:12:40,960 --> 01:12:44,350
一旦你生成了它们 就把它们拼接在一起 

1365
01:12:44,350 --> 01:12:47,627
或者 你可以随时垫上你的--

1366
01:12:47,627 --> 01:12:49,210
不 你可能不想垫垫 

1367
01:12:49,210 --> 01:12:56,560
我可能会把它们首尾相连 然后去掉x等于1100

1368
01:12:56,560 --> 01:13:01,810
或者 一旦它超过屏幕的左边缘 就会有很多人出现在左侧 

1369
01:13:01,810 --> 01:13:05,050
在这种情况下 总而言之 它完全是静态的 

1370
01:13:05,050 --> 01:13:06,780
但你可以很容易地--

1371
01:13:06,780 --> 01:13:11,090
这并不容易 但你完全可以让它成为一名无限的跑步者 

1372
01:13:11,090 --> 01:13:11,590
嗯 

1373
01:13:11,590 --> 01:13:16,572
观众：所以我们渲染了整个关卡 但我们就是看不到全部？

1374
01:13:16,572 --> 01:13:19,280
科尔顿·奥格登：问题是 我们是在渲染整个关卡吗 

1375
01:13:19,280 --> 01:13:20,488
但我们就是看不到一切吗？

1376
01:13:20,488 --> 01:13:21,410
答案是肯定的 

1377
01:13:21,410 --> 01:13:24,493
目前 在这个实现中 我们只是渲染整个级别--

1378
01:13:24,493 --> 01:13:26,720
因此 一块一块地被吸引到屏幕上 

1379
01:13:26,720 --> 01:13:30,410
对于像这样的小例子来说 这不是一个问题 

1380
01:13:30,410 --> 01:13:33,860
但对于较大的级别--例如 如果我们做一个Terraria级别 

1381
01:13:33,860 --> 01:13:38,480
兵马俑数以千计的瓷砖可能

1382
01:13:38,480 --> 01:13:40,340
1000或更高的瓷砖--

1383
01:13:40,340 --> 01:13:44,630
您只想渲染一块 只渲染您可以看到的部分 

1384
01:13:44,630 --> 01:13:49,730
为此 您可以使用相机偏移量 然后只需渲染

1385
01:13:49,730 --> 01:13:53,949
从左侧的一块瓷砖到底部边缘以下的一块瓷砖

1386
01:13:53,949 --> 01:13:55,490
在摄像机的右手边 

1387
01:13:55,490 --> 01:13:57,650
只需渲染该分片的子集 

1388
01:13:57,650 --> 01:14:01,250
因此 您只需要一个for循环来迭代一小段 

1389
01:14:01,250 --> 01:14:04,550
观众：所以你可以做一个阵列

1390
01:14:04,550 --> 01:14:07,034
地图会是什么样子 然后

1391
01:14:07,034 --> 01:14:11,184
只渲染数组中您可以看到的部分 

1392
01:14:11,184 --> 01:14:12,180
是那么回事吗？

1393
01:14:12,180 --> 01:14:18,654
如果您放置一个多维数组 然后您只需遍历它

1394
01:14:18,654 --> 01:14:20,542
并随时随地渲染--这就是你的想法吗？

1395
01:14:20,542 --> 01:14:22,250
科尔顿·奥格登：问题是 你只要

1396
01:14:22,250 --> 01:14:24,400
针对您的关卡的多维瓷砖阵列 

1397
01:14:24,400 --> 01:14:25,983
然后你只需要在你走的时候渲染它 

1398
01:14:25,983 --> 01:14:27,050
答案是肯定的 

1399
01:14:27,050 --> 01:14:29,600
你会得到你的整体瓷砖--

1400
01:14:29,600 --> 01:14:35,030
您的大型2D阵列 由100×20或其他数千个瓷砖组成 

1401
01:14:35,030 --> 01:14:38,295
然后根据您的摄像机渲染的位置 

1402
01:14:38,295 --> 01:14:41,150
它只是一个嵌套数量内for循环 

1403
01:14:41,150 --> 01:14:46,970
所以 也许你的玩家在x30加上6张牌 

1404
01:14:46,970 --> 01:14:51,350
所以你只需要渲染30块到45块

1405
01:14:51,350 --> 01:14:55,040
在x上 在y上可能是10到20--

1406
01:14:55,040 --> 01:14:56,120
就是那一大块 

1407
01:14:56,120 --> 01:14:58,100
这只是相对于你的相机的位置 

1408
01:14:58,100 --> 01:15:00,230
你总是只渲染一小部分--

1409
01:15:00,230 --> 01:15:02,630
基本上 在这一点上 它实际上是一个相机 

1410
01:15:02,630 --> 01:15:05,630
它正在将一大块瓷砖渲染到屏幕上 

1411
01:15:05,630 --> 01:15:07,359
听众：但在这段代码中 情况并非如此 

1412
01:15:07,359 --> 01:15:08,650
科尔顿·奥格登：在这段代码中 没有 

1413
01:15:08,650 --> 01:15:10,300
这里的水平是--

1414
01:15:10,300 --> 01:15:13,494
它已经足够复杂了 不能引入 

1415
01:15:13,494 --> 01:15:15,410
我的意思是 这并不是太复杂的介绍 

1416
01:15:15,410 --> 01:15:16,520
这很容易 

1417
01:15:16,520 --> 01:15:20,540
但消费--这里的加工--

1418
01:15:20,540 --> 01:15:23,030
是非常轻的 因为能级相当小 

1419
01:15:23,030 --> 01:15:25,430
即使我们真的有很大的水平 

1420
01:15:25,430 --> 01:15:29,550
它足够小 不必担心 

1421
01:15:29,550 --> 01:15:33,770
但如果我们真的达到了1000块或更多的水平 

1422
01:15:33,770 --> 01:15:35,656
然后也许这些瓷砖有额外的 

1423
01:15:35,656 --> 01:15:38,030
你只是想挤出所有可能的性能

1424
01:15:38,030 --> 01:15:40,350
您的应用程序的 

1425
01:15:40,350 --> 01:15:43,050
您可以考虑只渲染一个子集 

1426
01:15:43,050 --> 01:15:46,340
它很容易介绍 但就是不能

1427
01:15:46,340 --> 01:15:50,420
我们在这项任务中包含了 

1428
01:15:50,420 --> 01:15:54,687
关于这种东西是如何工作的 还有其他问题吗？

1429
01:15:58,115 --> 01:15:58,615
好的 

1430
01:16:01,120 --> 01:16:04,960
到目前为止 我们已经讨论了过程级生成 

1431
01:16:04,960 --> 01:16:09,250
我们已经讨论了动画和渲染之类的东西 

1432
01:16:09,250 --> 01:16:12,970
我们还没有真正讨论如何做瓷砖碰撞 

1433
01:16:12,970 --> 01:16:15,550
我们不会涉及太多的细节 

1434
01:16:15,550 --> 01:16:17,170
因为代码有点长 

1435
01:16:17,170 --> 01:16:19,961
阅读并理解它将是你们任务的一部分 

1436
01:16:19,961 --> 01:16:24,940
但我们拥有的是TileMap类 

1437
01:16:24,940 --> 01:16:29,290
基本上 整个大意是因为我们是

1438
01:16:29,290 --> 01:16:34,990
在固定的2D切片数组上 它将始终为0 0 至少

1439
01:16:34,990 --> 01:16:37,580
在我们目前实现的模型中 

1440
01:16:37,580 --> 01:16:42,730
我们只需将坐标转换为平铺 然后

1441
01:16:42,730 --> 01:16:48,310
只要检查一下 看看瓷砖是否在任何地方

1442
01:16:48,310 --> 01:16:51,220
是不是坚固的 

1443
01:16:51,220 --> 01:16:57,830
在这种情况下 假设我们想要查看角色的顶部 

1444
01:16:57,830 --> 01:17:00,970
所以如果我们有我们的角色在这里 

1445
01:17:00,970 --> 01:17:04,240
为了说明起见 我把他放在他上方的两块瓷砖之间

1446
01:17:04,240 --> 01:17:07,750
只是为了表明我们为什么需要以我们现在的方式来做这件事 

1447
01:17:07,750 --> 01:17:10,600
但你要说的是--

1448
01:17:10,600 --> 01:17:14,440
他的最左上角 所以是player.x 然后是player.y 

1449
01:17:14,440 --> 01:17:17,080
这实际上就是他们的0 0版本 

1450
01:17:17,080 --> 01:17:20,610
然后是Player.x加上Player.Width减去--

1451
01:17:20,610 --> 01:17:27,210
对于很多碰撞 我们都是负1

1452
01:17:27,210 --> 01:17:29,740
这样他就可以在街区之间走动了 

1453
01:17:29,740 --> 01:17:33,940
因为如果你不给他稍微少一点的钱--

1454
01:17:33,940 --> 01:17:37,080
因为他有16个像素宽 瓷砖有16个像素宽--

1455
01:17:37,080 --> 01:17:39,730
如果他在两个街区之间想摔倒 

1456
01:17:39,730 --> 01:17:42,580
他只是不会倒下 因为它还在探测碰撞 

1457
01:17:45,340 --> 01:17:47,140
因为如果他在这个洞里--

1458
01:17:47,140 --> 01:17:50,500
假设这是一个洞 这些是这里的瓷砖 

1459
01:17:50,500 --> 01:17:52,230
X加上宽度--

1460
01:17:52,230 --> 01:17:55,120
它会在这块瓷砖和这块瓷砖上引发碰撞 

1461
01:17:55,120 --> 01:17:58,480
所以基本上 你需要将他的碰撞框最小化一个像素

1462
01:17:58,480 --> 01:18:03,970
从本质上讲 要适应16个像素的间隙 这就是它的归结 

1463
01:18:03,970 --> 01:18:07,315
但碰撞背后的主旨--

1464
01:18:07,315 --> 01:18:09,190
在这种情况下 这只适用于他

1465
01:18:09,190 --> 01:18:11,440
跳跃 因为这是他唯一能真正

1466
01:18:11,440 --> 01:18:13,240
与他上方的瓷砖相撞 

1467
01:18:13,240 --> 01:18:17,190
您将测试落在此像素上的任何块

1468
01:18:17,190 --> 01:18:19,490
不管落在这个像素上的是什么块 

1469
01:18:19,490 --> 01:18:23,380
如果它们中的任何一个是实心的 就会引发碰撞 

1470
01:18:23,380 --> 01:18:25,610
如果没有 那么根本就不会发生碰撞 

1471
01:18:25,610 --> 01:18:29,210
例如 如果他就在这里--

1472
01:18:29,210 --> 01:18:31,960
就在瓷砖的正下方--它只会检查一个瓷砖 

1473
01:18:31,960 --> 01:18:35,440
这一点和这一点都将落在这块瓷砖上 

1474
01:18:35,440 --> 01:18:39,220
但我们之所以要检查这里和这里的两个点

1475
01:18:39,220 --> 01:18:42,850
如果他在两块不同的瓷砖下面 

1476
01:18:42,850 --> 01:18:45,354
因为现在这一点将检查这块瓷砖 

1477
01:18:45,354 --> 01:18:47,020
这一块将检查这块瓷砖 

1478
01:18:47,020 --> 01:18:50,950
我们不能只检查这个瓷砖 因为如果我们只检查这个瓷砖

1479
01:18:50,950 --> 01:18:53,860
这里没有瓷砖 但这里有瓷砖 

1480
01:18:53,860 --> 01:18:57,070
他的跳跃仍然不会引发碰撞 

1481
01:18:57,070 --> 01:18:59,950
它会认为它只是在看这里 而不是这里 

1482
01:18:59,950 --> 01:19:05,200
所以对于我们有效地在他的每一边进行的每一次碰撞 

1483
01:19:05,200 --> 01:19:09,520
我们需要有效地检查那条边的两个角 

1484
01:19:09,520 --> 01:19:14,610
所以当他跳的时候 我们转到这一点--

1485
01:19:14,610 --> 01:19:19,690
这个x y--只需除以瓷砖的大小就可以得到瓷砖 

1486
01:19:19,690 --> 01:19:23,890
所以我们可以说 Player.x除以瓷砖大小加1 

1487
01:19:23,890 --> 01:19:27,520
这将等于x上的任何平铺 

1488
01:19:27,520 --> 01:19:29,200
然后对y做同样的事情--

1489
01:19:29,200 --> 01:19:32,410
我们只需将y除以瓷砖大小 然后在上面加1 

1490
01:19:32,410 --> 01:19:34,900
这将使我们能够得到准确的瓷砖 

1491
01:19:34,900 --> 01:19:39,340
如果我们使用从操作中得到的x y 

1492
01:19:39,340 --> 01:19:44,560
我们有效地获得了瓦片2D数组中y x索引处的精确瓦片 

1493
01:19:44,560 --> 01:19:45,820
所以我们对跳跃也是这样做的 

1494
01:19:45,820 --> 01:19:50,099
我们检查了他头顶的两个角 

1495
01:19:50,099 --> 01:19:52,390
我们对底部做同样的事情 只是在那个时候 

1496
01:19:52,390 --> 01:19:56,260
我们检查x 然后y加上高度 

1497
01:19:56,260 --> 01:19:58,810
然后x加上宽度 y加上高度 

1498
01:19:58,810 --> 01:20:01,862
如果我们做的是左边缘 我们要检查什么？

1499
01:20:05,208 --> 01:20:07,125
观众：左下角和左上角？

1500
01:20:07,125 --> 01:20:08,000
科尔顿·奥格登：我们是 

1501
01:20:08,000 --> 01:20:13,220
所以这将是x0 y 然后是x0 y加上高度 

1502
01:20:13,220 --> 01:20:15,590
然后如果它是正确的边缘 同样的事情 

1503
01:20:15,590 --> 01:20:23,420
我们检查x+宽度y 然后我们检查x+宽度y+高度 

1504
01:20:23,420 --> 01:20:30,320
这就是这个发行版中碰撞检测背后的主旨 

1505
01:20:30,320 --> 01:20:35,405
如果我们转到磁贴地图 你可以在马里奥看到它 

1506
01:20:39,590 --> 01:20:42,680
指向磁贴--这实际上就是它发生的地方 

1507
01:20:49,610 --> 01:20:52,390
在第32行 我们基本上是返回--

1508
01:20:52,390 --> 01:20:53,660
这里的这段代码--

1509
01:20:53,660 --> 01:20:56,030
28比30--是一张支票

1510
01:20:56,030 --> 01:20:59,120
因为我们可以跳过地图的边缘 我们

1511
01:20:59,120 --> 01:21:02,669
将无法在切片y除以平铺大小时进行检查

1512
01:21:02,669 --> 01:21:05,460
加1 x除以平铺大小加1 因为这些都是零 

1513
01:21:05,460 --> 01:21:07,209
这些都不会存在 因为他真的会

1514
01:21:07,209 --> 01:21:08,510
在地图边界之外 

1515
01:21:08,510 --> 01:21:12,540
如果他在它下面 或者他超过了左边或右边 情况也是一样的 

1516
01:21:12,540 --> 01:21:14,030
这就是这里的所有代码 

1517
01:21:14,030 --> 01:21:17,780
它只是确保如果我们真的超越地图的边界 

1518
01:21:17,780 --> 01:21:18,920
我们归零 

1519
01:21:18,920 --> 01:21:23,540
因此 我们可以检查为零 而不是得到瓷砖索引错误 

1520
01:21:23,540 --> 01:21:26,370
然后在第32行是我刚才提到的操作 

1521
01:21:26,370 --> 01:21:28,550
那就是我们用y--

1522
01:21:28,550 --> 01:21:33,020
所以我们传入的这个x和y将是玩家的实际x y 

1523
01:21:33,020 --> 01:21:38,360
当我们传递这些信息时 我们只需要在self上获得瓷砖 瓷砖 

1524
01:21:38,360 --> 01:21:43,130
然后有效地y除以Tile_Size得到一个整数 

1525
01:21:43,130 --> 01:21:43,890
然后加1 

1526
01:21:43,890 --> 01:21:49,070
回想一下 表是1索引的 但坐标是0索引的 

1527
01:21:49,070 --> 01:21:53,210
因此 这将导致索引结果为0 因此我们希望将其加1 

1528
01:21:53,210 --> 01:21:57,000
这里的情况也一样--math.loor(X)除以TableSize加1 

1529
01:21:57,000 --> 01:21:59,870
因此 有效地 指向瓷砖 

1530
01:21:59,870 --> 01:22:01,660
然后我们就从那里得到一块瓷砖 

1531
01:22:01,660 --> 01:22:05,130
而瓷砖--我们可以检查一下 嘿 那瓷砖是不是实心的？

1532
01:22:05,130 --> 01:22:07,830
如果是 则触发碰撞 

1533
01:22:07,830 --> 01:22:12,980
这就是能够在平台上做到这一点的主旨

1534
01:22:12,980 --> 01:22:14,459
在那里一切都是固定的 

1535
01:22:14,459 --> 01:22:16,250
这就像是我们可以走的一条捷径 

1536
01:22:16,250 --> 01:22:19,730
因为现在 这有什么好处呢？

1537
01:22:19,730 --> 01:22:24,980
这个算法有一个非常棒的地方 

1538
01:22:24,980 --> 01:22:35,720
想象一下 我们的游戏世界里有10,000块瓷砖 

1539
01:22:35,720 --> 01:22:38,390
所以如果你看一看 我们所做的就是

1540
01:22:38,390 --> 01:22:40,700
我们只是在做一个简单的数学运算

1541
01:22:40,700 --> 01:22:44,150
关于他的x和y是什么 对吗？

1542
01:22:44,150 --> 01:22:46,520
除了这个 还有什么办法？

1543
01:22:46,520 --> 01:22:50,430
例如 如果我们通过AABB进行这项工作 

1544
01:22:50,430 --> 01:22:54,518
我们必须遍历每一块瓷砖 对吗？

1545
01:22:54,518 --> 01:22:56,474
观众：你能总结一下吗？

1546
01:22:56,474 --> 01:23:00,386
为了避免重复屏幕上的所有内容 

1547
01:23:00,386 --> 01:23:03,820
你只是检查了他所在的栏目和栏目标题？

1548
01:23:03,820 --> 01:23:04,880
科尔顿·奥格登：是的 

1549
01:23:04,880 --> 01:23:09,720
所以大意是他有一个x和一个y 

1550
01:23:09,720 --> 01:23:13,940
X和y将在世界坐标中 所以他的x可能是67

1551
01:23:13,940 --> 01:23:16,040
他的y可能是38岁左右 

1552
01:23:16,040 --> 01:23:17,450
它们不会均匀地映射到瓷砖 

1553
01:23:17,450 --> 01:23:20,660
但如果我们把这些除以我们世界中的瓷砖大小--

1554
01:23:20,660 --> 01:23:25,310
16--这将是一模一样的瓷砖

1555
01:23:25,310 --> 01:23:30,500
我们还必须在它的基础上加1 因为Lua中的表是1索引的 

1556
01:23:30,500 --> 01:23:34,040
但是我们可以用x y来索引我们自己的瓷砖

1557
01:23:34,040 --> 01:23:36,945
我们从中得到的--除以16 

1558
01:23:36,945 --> 01:23:39,320
这就是他要撞上的瓷砖 

1559
01:23:43,340 --> 01:23:45,710
我们基本上不需要有一系列的瓷砖

1560
01:23:45,710 --> 01:23:48,710
我们迭代并检查它们是否

1561
01:23:48,710 --> 01:23:51,200
使用AABB碰撞检测与玩家碰撞

1562
01:23:51,200 --> 01:23:52,220
就像我们以前做过的那样 

1563
01:23:52,220 --> 01:23:54,620
因为回想一下 在《越狱》中 我们有砖头 对吗？

1564
01:23:54,620 --> 01:23:56,990
他们都有自己的x y 但他们不在一个网格上 

1565
01:23:56,990 --> 01:23:58,040
他们还没修好 

1566
01:23:58,040 --> 01:24:01,130
所以我们不得不真的把它们拿来做AABB 

1567
01:24:01,130 --> 01:24:03,740
我们不得不迭代它们并对它们执行AABB 

1568
01:24:03,740 --> 01:24:08,450
因为没有确定性的方法可以非常快速地对它们进行索引 

1569
01:24:08,450 --> 01:24:11,300
数组和链表的情况是一样的 

1570
01:24:11,300 --> 01:24:16,610
因为数组--你可以计算某个值在多大程度上被赋予了索引 

1571
01:24:16,610 --> 01:24:18,450
您可以立即访问它 

1572
01:24:18,450 --> 01:24:22,070
这是一个操作的顺序 而不是链表 

1573
01:24:22,070 --> 01:24:24,230
如果你想试着得到一个特定值 

1574
01:24:24,230 --> 01:24:26,854
你必须遍历整个过程 直到找到它 

1575
01:24:26,854 --> 01:24:31,790
观众：你能不能找一下你可能要降落的栏目？

1576
01:24:31,790 --> 01:24:36,650
科尔顿·奥格登：无论你的x除以16 你都能得到准确的瓷砖--

1577
01:24:36,650 --> 01:24:38,150
或者不管你的瓷砖大小是什么--

1578
01:24:38,150 --> 01:24:40,370
你的y除以16是 

1579
01:24:40,370 --> 01:24:43,010
记住 你这么做是为了两个不同的观点

1580
01:24:43,010 --> 01:24:44,777
取决于你要找的是什么 

1581
01:24:44,777 --> 01:24:47,360
如果你要找的是高于你角色的瓷砖 

1582
01:24:47,360 --> 01:24:49,280
你将在这一点上做这件事 

1583
01:24:49,280 --> 01:24:53,030
所以不管这个值是什么--他的基数x y-

1584
01:24:53,030 --> 01:24:57,490
不管它被16除以什么 然后再除以16 

1585
01:24:57,490 --> 01:25:00,310
然后你就可以得到他正上方的瓷砖了 

1586
01:25:00,310 --> 01:25:03,160
它将与与该点相交的任何切片相交

1587
01:25:03,160 --> 01:25:05,272
任何瓷砖都与这一点相交 

1588
01:25:05,272 --> 01:25:07,730
如果我们看左边 这里和这里也是一样的 

1589
01:25:07,730 --> 01:25:09,080
这里 这里 如果我们看的是底部 

1590
01:25:09,080 --> 01:25:11,610
这里和这里 如果我们看的是右边的话 

1591
01:25:11,610 --> 01:25:13,640
我们会在他已经

1592
01:25:13,640 --> 01:25:18,340
移动以使这些点与可能的块相交 

1593
01:25:18,340 --> 01:25:20,840
这就是我们可以检查是否发生碰撞的方法 

1594
01:25:20,840 --> 01:25:26,844
我们在他移动和处于某种移动状态时这样做 

1595
01:25:26,844 --> 01:25:29,130
观众：所以你还在做碰撞检测

1596
01:25:29,130 --> 01:25:31,430
他的实际坐标 但你只是

1597
01:25:31,430 --> 01:25:34,620
缩小你的字符宽度--

1598
01:25:34,620 --> 01:25:36,000
科尔顿·奥格登：是的 

1599
01:25:36,000 --> 01:25:39,360
我们把它从在每一块瓷砖上迭代

1600
01:25:39,360 --> 01:25:42,540
到即时运算 因为我们可以从数学上得到

1601
01:25:42,540 --> 01:25:45,210
一模一样的瓦片 他没有

1602
01:25:45,210 --> 01:25:47,130
担心他在地图上的位置 

1603
01:25:47,130 --> 01:25:50,450
这只是即时访问 

1604
01:25:50,450 --> 01:25:53,820
这只是因为我们知道瓷砖总是

1605
01:25:53,820 --> 01:25:55,290
固定在完全相同的位置 

1606
01:25:55,290 --> 01:25:56,623
他们总是从0 0开始 

1607
01:25:56,623 --> 01:25:58,262
它们永远都是瓷砖大小 

1608
01:25:58,262 --> 01:25:59,970
当事情变得更复杂的时候

1609
01:25:59,970 --> 01:26:04,920
我们引入游戏对象 它们有自己独立的x y 

1610
01:26:04,920 --> 01:26:06,824
对于这些 您确实需要迭代 

1611
01:26:06,824 --> 01:26:09,990
基本上 您拥有一组游戏对象或一组实体 

1612
01:26:09,990 --> 01:26:12,270
让我们假设游戏世界里有蜗牛 

1613
01:26:12,270 --> 01:26:16,770
蜗牛不会每次都出现在某个固定的位置 

1614
01:26:16,770 --> 01:26:19,170
它们可以连续移动 

1615
01:26:19,170 --> 01:26:21,960
因此 对于这些 我们必须将它们全部保存在一个容器中

1616
01:26:21,960 --> 01:26:26,940
然后循环浏览它们 然后说 我的球员有没有撞到其中的任何一个？

1617
01:26:26,940 --> 01:26:29,520
如果他有 那么就会引发与那只蜗牛的碰撞--

1618
01:26:29,520 --> 01:26:34,532
如果玩家处于行走状态或跳跃状态 则杀死它或杀死该玩家 

1619
01:26:34,532 --> 01:26:36,240
如果他处于跌倒状态 那么他们

1620
01:26:36,240 --> 01:26:39,480
应该会死 因为他正从顶部与他们相撞 

1621
01:26:39,480 --> 01:26:43,500
然后缩小检查碰撞的范围 就像你在底部看到的那样

1622
01:26:43,500 --> 01:26:44,850
这里 

1623
01:26:44,850 --> 01:26:47,267
瓷砖碰撞--当你看着你的角色上方时 

1624
01:26:47,267 --> 01:26:49,683
你只是在测试当你处于跳跃状态时 

1625
01:26:49,683 --> 01:26:51,390
因为这是你唯一需要的时间 

1626
01:26:51,390 --> 01:26:55,380
所以这是唯一一个你会与你上方的瓷砖相撞的点 

1627
01:26:55,380 --> 01:26:58,980
当你处于下落状态时 你就会检查你脚下的瓷砖 

1628
01:26:58,980 --> 01:27:01,390
然后你可以与你身边的瓷砖互动

1629
01:27:01,390 --> 01:27:04,020
当你处于跳跃、坠落或移动状态时 

1630
01:27:04,020 --> 01:27:08,285
因此 您应该检查所有这三个州的左侧和右侧磁贴 

1631
01:27:08,285 --> 01:27:12,835
观众：你不是应该总是测试一下自己的底线 以防出现裂痕吗？

1632
01:27:12,835 --> 01:27:13,960
科尔顿·奥格登：以防万一？

1633
01:27:13,960 --> 01:27:15,430
观众：以防出现裂痕 

1634
01:27:15,430 --> 01:27:17,138
科尔顿·奥格登：如果你有裂痕 是的 

1635
01:27:21,210 --> 01:27:21,930
你说得对 

1636
01:27:21,930 --> 01:27:24,660
这实际上应该只在播放器中进行测试

1637
01:27:24,660 --> 01:27:26,820
跌倒状态和球员行走状态 是的 

1638
01:27:26,820 --> 01:27:30,690
所以问题是 你不是应该测试你脚下的瓷砖吗

1639
01:27:30,690 --> 01:27:32,300
当你走路的时候？

1640
01:27:32,300 --> 01:27:35,274
是的--不仅是摔倒 而且还会走路 

1641
01:27:35,274 --> 01:27:37,440
这只只会跳 这只会摔倒 还会走路 

1642
01:27:37,440 --> 01:27:39,690
这个是跳跃、坠落和移动的 

1643
01:27:44,490 --> 01:27:45,660
这有意义吗--

1644
01:27:45,660 --> 01:27:49,890
我们如何将x y转化为一块瓷砖

1645
01:27:49,890 --> 01:27:52,410
只要除以16就行了吗？

1646
01:27:52,410 --> 01:27:56,970
而且一定要注意加1 因为我们自己的瓷砖 瓷砖

1647
01:27:56,970 --> 01:27:58,530
有1个索引 

1648
01:27:58,530 --> 01:28:01,440
所以当我们用x y除以瓷砖大小时 我们就是

1649
01:28:01,440 --> 01:28:05,160
将得到一个0索引坐标 

1650
01:28:05,160 --> 01:28:10,930
如果我们的x是14 我们就在第一个瓦片内 

1651
01:28:10,930 --> 01:28:13,170
但如果我们把它除以16 我们会得到零 

1652
01:28:13,170 --> 01:28:16,086
所以我们需要加1 这样我们就得到了数组中的第一个平铺

1653
01:28:16,086 --> 01:28:20,280
不管那块瓷砖是什么 它都会是 

1654
01:28:20,280 --> 01:28:23,100
这就是碰撞的原理 

1655
01:28:23,100 --> 01:28:27,390
它都是在这里的TileMap中实现的 

1656
01:28:27,390 --> 01:28:36,170
基本上玩家所处的每一个状态 都在StatesEntity中 

1657
01:28:36,170 --> 01:28:38,870
然后运动员跌倒 无所事事 跳跃和行走--

1658
01:28:38,870 --> 01:28:43,590
这些都是执行此检查的状态 

1659
01:28:43,590 --> 01:28:45,500
他们基本上做了这里的所有逻辑

1660
01:28:45,500 --> 01:28:47,720
在底部 这是在播放器中测试

1661
01:28:47,720 --> 01:28:51,620
左碰撞或右碰撞的跳跃状态、下降状态和移动状态 

1662
01:28:51,620 --> 01:28:55,192
然后在下落状态下 我们检查下面是否有碰撞 

1663
01:28:55,192 --> 01:28:57,650
然后在跳跃状态下 我们检查上方是否有碰撞 

1664
01:28:57,650 --> 01:29:01,670
这一切都是在各州内部完成的 

1665
01:29:01,670 --> 01:29:05,089
但从像素到瓷砖的实际转换--

1666
01:29:05,089 --> 01:29:07,130
这只是我们从TileMap调用的一个函数 

1667
01:29:07,130 --> 01:29:09,859
这只是一个效用函数 

1668
01:29:09,859 --> 01:29:11,650
观众：这个函数叫什么来着？

1669
01:29:11,650 --> 01:29:13,460
科尔顿·奥格登：这叫PointToTile 

1670
01:29:13,460 --> 01:29:18,170
所以如果你在TileMap的第27行--

1671
01:29:18,170 --> 01:29:19,430
PointToTile(x y) 

1672
01:29:19,430 --> 01:29:22,430
这里的第一点只是一小部分

1673
01:29:22,430 --> 01:29:25,910
这基本上可以让你走出地图的界限

1674
01:29:25,910 --> 01:29:27,960
而不会出现平铺索引错误 

1675
01:29:27,960 --> 01:29:33,110
因此 如果它正好在平铺限制之外 小于0 或大于宽度 

1676
01:29:33,110 --> 01:29:34,100
只需返回零即可 

1677
01:29:34,100 --> 01:29:35,870
所以你可以在nil上做一个检查

1678
01:29:35,870 --> 01:29:40,345
查看TileMap point tToTile是否等于Nil

1679
01:29:40,345 --> 01:29:41,720
或者当你做碰撞的时候不会 

1680
01:29:41,720 --> 01:29:46,570
如果是的话 那就什么都别做了 

1681
01:29:46,570 --> 01:29:51,530
但假设您在磁贴边界内 在第32行

1682
01:29:51,530 --> 01:29:54,691
就是你进行转化的地方--数学地板 回想一下 

1683
01:29:54,691 --> 01:29:56,690
因为我们想要得到这些的整数值 

1684
01:29:56,690 --> 01:29:58,856
我们不想得到小数 因为你

1685
01:29:58,856 --> 01:30:03,220
我不能将这些瓷砖作为小数编制索引 尽管我不确定 

1686
01:30:03,220 --> 01:30:06,650
我认为在Lua中通常可以--为瓷砖建立索引

1687
01:30:06,650 --> 01:30:07,740
以一个小数 

1688
01:30:07,740 --> 01:30:10,290
但在本例中 我们只需要整数 

1689
01:30:10,290 --> 01:30:14,440
所以我们将y上的数学地板除以平铺大小加1 

1690
01:30:14,440 --> 01:30:16,730
Y除以平铺大小 然后再加1 

1691
01:30:16,730 --> 01:30:18,484
然后我们对x做同样的事情 

1692
01:30:18,484 --> 01:30:20,122
这就是我们的行动 

1693
01:30:20,122 --> 01:30:23,330
然后在我们想要检查任何我们想要碰撞的瓷砖的地方 

1694
01:30:23,330 --> 01:30:28,070
我们只在x和y坐标上调用point ToTile 

1695
01:30:28,070 --> 01:30:33,480
这就是游戏中所有基于瓷砖的碰撞背后的主干

1696
01:30:33,480 --> 01:30:34,400
有效地 

1697
01:30:37,630 --> 01:30:41,490
对于这是如何工作的 有什么问题吗？

1698
01:30:41,490 --> 01:30:41,990
是 

1699
01:30:41,990 --> 01:30:45,742
观众：所以你探测到的只是角落的碰撞

1700
01:30:45,742 --> 01:30:47,620
而不是边缘本身？

1701
01:30:47,620 --> 01:30:51,230
科尔顿·奥格登：正确 因为你真的不需要检查边缘

1702
01:30:51,230 --> 01:30:53,830
如果考虑到上角和下角 

1703
01:30:53,830 --> 01:30:57,610
除非你的实体足够高 他们需要

1704
01:30:57,610 --> 01:31:00,340
检查是否有三块以上的瓷砖 

1705
01:31:00,340 --> 01:31:03,730
在这种情况下 我们的实体不超过两个瓷砖高 

1706
01:31:03,730 --> 01:31:08,556
所以我们只需要检查他的左上角 左下角 

1707
01:31:08,556 --> 01:31:10,930
如果是左碰撞 右上角 右下角 

1708
01:31:10,930 --> 01:31:16,330
如果我们在做右碰撞 他的左上角 右上角的顶部和底部

1709
01:31:16,330 --> 01:31:17,710
左下角 右下角为底部 

1710
01:31:17,710 --> 01:31:20,980
如果你有一个八块高的实体 

1711
01:31:20,980 --> 01:31:26,330
你需要检查他右侧的每一块瓷砖 

1712
01:31:26,330 --> 01:31:30,550
只是意味着你需要迭代他的整个身高除以瓷砖大小 

1713
01:31:30,550 --> 01:31:34,450
然后只需对每个瓷砖检查的y进行偏移 

1714
01:31:34,450 --> 01:31:36,090
这说得通吗？

1715
01:31:36,090 --> 01:31:38,860
好的 酷 

1716
01:31:38,860 --> 01:31:39,490
好的 

1717
01:31:39,490 --> 01:31:41,890
我通过提到国家简要地提到了这一点 

1718
01:31:45,340 --> 01:31:48,340
我不知道我是否暗示了我们使用实体的事实 

1719
01:31:48,340 --> 01:31:53,260
但在这个发行版中 我们被介绍了实体的概念 

1720
01:31:53,260 --> 01:31:57,960
一个实体几乎可以是你想要的任何东西 

1721
01:31:57,960 --> 01:31:59,980
在这个发行版中 我们考虑的是实体

1722
01:31:59,980 --> 01:32:03,250
基本上是任何有生命或有知觉的东西--

1723
01:32:03,250 --> 01:32:04,900
在这种情况下 球员或蜗牛 

1724
01:32:04,900 --> 01:32:10,132
这些是实体 然后它们只是实体的子集 

1725
01:32:10,132 --> 01:32:11,590
实体是一个非常抽象的东西 

1726
01:32:11,590 --> 01:32:15,850
你会在很多游戏引擎和很多讨论中看到它

1727
01:32:15,850 --> 01:32:19,300
关于如何组织你的游戏以及如何设计它 

1728
01:32:19,300 --> 01:32:24,460
Unity可能是最突出的采用者

1729
01:32:24,460 --> 01:32:27,460
所谓的实体组件系统 由此

1730
01:32:27,460 --> 01:32:29,350
你在你的比赛中拥有一切 

1731
01:32:29,350 --> 01:32:31,510
你游戏中的每一件事都是一个实体 

1732
01:32:31,510 --> 01:32:34,480
然后每个实体都是由组件组成的 

1733
01:32:34,480 --> 01:32:37,960
而这些组件最终会驱动你的行为 

1734
01:32:37,960 --> 01:32:41,290
这有点像如果你熟悉组合而不是继承 

1735
01:32:41,290 --> 01:32:43,900
如果你听说过这是一件软件工程的事情 

1736
01:32:43,900 --> 01:32:45,460
这实际上是相同的范式 

1737
01:32:45,460 --> 01:32:50,290
而不是继承一堆不同的东西成为你的--

1738
01:32:50,290 --> 01:32:52,620
假设您有一个基本怪物类 

1739
01:32:52,620 --> 01:32:55,240
然后你有一个妖精 它是怪物的子集 

1740
01:32:55,240 --> 01:32:56,710
所以它是从怪物那里继承下来的 

1741
01:32:56,710 --> 01:32:59,500
然后你有了一个从小妖精那里继承下来的小妖精军阀 

1742
01:32:59,500 --> 01:33:02,950
然后你就有了一个从那里继承下来的古老的妖精军阀 

1743
01:33:02,950 --> 01:33:06,270
与其让这种嵌套的继承树 

1744
01:33:06,270 --> 01:33:11,380
你采用合成法 这意味着你拿一个底座容器 

1745
01:33:11,380 --> 01:33:14,110
然后用不同的组件填充它 这些组件表示

1746
01:33:14,110 --> 01:33:16,510
您的对象的行为是什么 

1747
01:33:16,510 --> 01:33:19,810
所以如果你有一个实体--

1748
01:33:19,810 --> 01:33:21,820
比方说 你给它一个怪物组件 

1749
01:33:21,820 --> 01:33:25,256
然后也许你还会给它一个古老的组成部分 

1750
01:33:25,256 --> 01:33:26,380
所以它是一个古老的怪物 

1751
01:33:26,380 --> 01:33:28,210
也许你给它一个妖精组件 

1752
01:33:28,210 --> 01:33:32,022
那么它就是一个古老的妖精 

1753
01:33:32,022 --> 01:33:33,730
然后你给它一个军阀的组成部分 

1754
01:33:33,730 --> 01:33:35,150
所以这是一个古老的妖怪军阀 

1755
01:33:35,150 --> 01:33:36,940
所以它包含了构成它的所有部件

1756
01:33:36,940 --> 01:33:40,930
它不需要你去创造这个疯狂的继承链 

1757
01:33:40,930 --> 01:33:44,920
这实际上就是实体组件系统的模型

1758
01:33:44,920 --> 01:33:48,820
是与标准继承的对比--用它来驱动

1759
01:33:48,820 --> 01:33:51,050
你的问题的模型 

1760
01:33:51,050 --> 01:33:53,890
在这种情况下 我们不会讨论疯狂的实体组件 

1761
01:33:53,890 --> 01:33:56,020
但我想提出来 因为团结 

1762
01:33:56,020 --> 01:34:01,000
我们将在几周内介绍 它完全是基于组件的 

1763
01:34:01,000 --> 01:34:03,550
您在Unity中编写的所有内容都是一个组件 

1764
01:34:03,550 --> 01:34:08,140
和实体 无论它们是否在实体组件系统中 

1765
01:34:08,140 --> 01:34:10,570
构成了大多数大型比赛的中坚力量 

1766
01:34:10,570 --> 01:34:15,440
大多数游戏都有一定的复杂性

1767
01:34:15,440 --> 01:34:19,750
将它们中的大多数部分建模为具有行为的实体

1768
01:34:19,750 --> 01:34:21,260
做一些事情 

1769
01:34:21,260 --> 01:34:28,360
因此 在这种情况下 实体是蜗牛和我们的玩家 

1770
01:34:28,360 --> 01:34:31,900
然后从瓷砖上分开--

1771
01:34:31,900 --> 01:34:33,220
当我们做碰撞的时候--

1772
01:34:33,220 --> 01:34:36,130
我们还想检查与玩家在每个实体上的冲突 

1773
01:34:36,130 --> 01:34:39,577
所以我们要确定在这种情况下玩家与蜗牛相撞 

1774
01:34:39,577 --> 01:34:41,910
因为这是他们唯一可以成为的其他实体 

1775
01:34:41,910 --> 01:34:47,100
但如果你愿意 你可以拥有任意数量的敌人 

1776
01:34:47,100 --> 01:34:49,970
如果你与一个实体发生冲突--所以只是一个for循环 

1777
01:34:49,970 --> 01:34:54,940
因此 对于成对的实体 请检查冲突 

1778
01:34:54,940 --> 01:34:58,720
如果你处于跳跃状态 那就去死吧 

1779
01:34:58,720 --> 01:35:02,410
如果你处于秋天状态 那就杀了它 等等 

1780
01:35:02,410 --> 01:35:06,609
当你在做实体到实体交互的大部分事情时 

1781
01:35:06,609 --> 01:35:08,150
这通常是您建模的方式 

1782
01:35:08,150 --> 01:35:11,497
您只需迭代所有内容 然后将所有内容碰撞 

1783
01:35:11,497 --> 01:35:13,330
根据什么与什么发生冲突 您将

1784
01:35:13,330 --> 01:35:16,970
只是将所有东西与其他东西碰撞 并以这种方式处理互动 

1785
01:35:16,970 --> 01:35:18,400
这是我们有效地做到这一点的方式 

1786
01:35:18,400 --> 01:35:20,496
我们在--

1787
01:35:20,496 --> 01:35:22,930
我相信它在GameLevel 

1788
01:35:22,930 --> 01:35:28,350
这维护了对充满实体的表的引用 

1789
01:35:28,350 --> 01:35:29,830
摆满了物品的桌子 

1790
01:35:29,830 --> 01:35:32,770
物体可以--我们稍后会讨论这一点--

1791
01:35:32,770 --> 01:35:35,800
宝石 积木 灌木丛 诸如此类的东西 然后是一张瓷砖地图 

1792
01:35:40,820 --> 01:35:43,400
对于每个实体 我们只需更新它 

1793
01:35:43,400 --> 01:35:45,580
然后对于每个对象 我们都会更新它 

1794
01:35:45,580 --> 01:35:49,020
然后 对于对象中的每个对象 我们也进行渲染 

1795
01:35:49,020 --> 01:35:50,660
然后我们渲染每一个实体 

1796
01:35:50,660 --> 01:35:55,100
这只是你如何看待游戏世界的基本方式 

1797
01:35:55,100 --> 01:35:57,320
填充它 然后处理和更新它 

1798
01:35:57,320 --> 01:36:02,270
只是容器 维护着对所有东西的引用的表 

1799
01:36:02,270 --> 01:36:03,830
然后只需更新它们 

1800
01:36:03,830 --> 01:36:06,050
实际的互动发生在--

1801
01:36:06,050 --> 01:36:09,590
因为它们取决于我们所处的状态 

1802
01:36:09,590 --> 01:36:16,610
如果你看一下球员在状态斜杠中的所有不同状态

1803
01:36:16,610 --> 01:36:23,040
Entity文件夹 您将看到 例如 在玩家倒下状态的第62行 

1804
01:36:23,040 --> 01:36:28,390
我们正在迭代Level中的每个对象 

1805
01:36:28,390 --> 01:36:31,400
注意玩家有一个关于它的等级的参考

1806
01:36:31,400 --> 01:36:33,780
这样它就可以访问它里面的所有东西 

1807
01:36:33,780 --> 01:36:36,170
然后在该级别内 所有对象都被存储 

1808
01:36:36,170 --> 01:36:38,820
所以它所需要做的就是说 如果物体碰撞

1809
01:36:38,820 --> 01:36:43,400
玩家和对象是实心的 然后将我们的dy设置为零 

1810
01:36:43,400 --> 01:36:44,822
等等 等等 

1811
01:36:44,822 --> 01:36:47,030
所有这些代码实际上都很容易阅读 

1812
01:36:47,030 --> 01:36:49,010
所以我鼓励你们去看看它

1813
01:36:49,010 --> 01:36:51,800
只需理解所有的碰撞和东西是如何

1814
01:36:51,800 --> 01:36:57,740
在球员、物体、积木和诸如此类的东西之间工作--

1815
01:36:57,740 --> 01:37:01,900
像积木这样的东西是固体的 像灌木丛这样的东西不是固体 

1816
01:37:01,900 --> 01:37:05,210
但这就是要点 

1817
01:37:05,210 --> 01:37:07,670
拥有对象或实体的集合 

1818
01:37:07,670 --> 01:37:10,940
然后根据你所处的状态 与一些 

1819
01:37:10,940 --> 01:37:14,540
然后根据州的情况 也许这会让你丧命 

1820
01:37:14,540 --> 01:37:17,130
也许那会杀死敌人 也许什么都不会发生

1821
01:37:17,130 --> 01:37:18,350
也许你变得所向披靡 

1822
01:37:18,350 --> 01:37:21,200
也许你撞上了一个通电的游戏物体 

1823
01:37:21,200 --> 01:37:26,570
而这种动力触发了你自己 玩家 无敌是真的 

1824
01:37:26,570 --> 01:37:29,430
然后如果self.player.incelble是真的 

1825
01:37:29,430 --> 01:37:32,060
然后 也许你可以用彩虹动画来渲染他 

1826
01:37:32,060 --> 01:37:35,960
然后在任何他会与敌人相撞并死亡的活动中 

1827
01:37:35,960 --> 01:37:38,160
他不再死了 他只是杀了他们 

1828
01:37:38,160 --> 01:37:44,690
这就是你如何与物体互动的主旨

1829
01:37:44,690 --> 01:37:46,520
以及如何处理它 

1830
01:37:46,520 --> 01:37:50,160
游戏对象不同 

1831
01:37:50,160 --> 01:37:54,470
就像我之前说的 这些是我们可以看到的一些物体的例子 

1832
01:37:54,470 --> 01:37:58,100
左下角的宝石都在发行版中 

1833
01:37:58,100 --> 01:38:00,740
如果你碰到一个街区--如果我们有几分钟的时间 

1834
01:38:00,740 --> 01:38:02,690
我会很快地展示给你们看它是怎么工作的--

1835
01:38:02,690 --> 01:38:06,590
如果你击中一个格挡 你将有机会产生一个宝石 

1836
01:38:06,590 --> 01:38:11,000
如果你收集了gen--也就是说如果你与那个游戏物体相撞--

1837
01:38:11,000 --> 01:38:13,406
把你的分数加100

1838
01:38:13,406 --> 01:38:16,280
这些都是我没有时间实现的其他对象 

1839
01:38:16,280 --> 01:38:21,366
但就在大门口 只是作为一个心理练习 

1840
01:38:21,366 --> 01:38:23,240
你觉得我们该怎么做梯子

1841
01:38:26,570 --> 01:38:28,760
是啊

1842
01:38:28,760 --> 01:38:30,700
观众：你只会有一个攀登状态 

1843
01:38:30,700 --> 01:38:34,136
如果玩家触摸梯子并按下某个键 

1844
01:38:34,136 --> 01:38:37,010
它们会进入爬升状态 这会使它们上升 

1845
01:38:37,010 --> 01:38:37,926
科尔顿·奥格登：正确 

1846
01:38:37,926 --> 01:38:41,990
托尼说如果他们爬上梯子 

1847
01:38:41,990 --> 01:38:43,820
它们应该进入爬升状态 

1848
01:38:43,820 --> 01:38:45,861
取决于它们是否处于爬升状态

1849
01:38:45,861 --> 01:38:49,540
如果他们按下一个按钮 他们应该上升或下降 

1850
01:38:49,540 --> 01:38:50,870
然后你会检查 

1851
01:38:50,870 --> 01:38:54,140
如果他们在梯子的顶端 离开攀登状态 

1852
01:38:54,140 --> 01:38:56,060
进入步行状态 

1853
01:38:56,060 --> 01:38:59,375
或者如果他们在梯子的底部 进入步行状态 

1854
01:38:59,375 --> 01:39:02,000
这只是另一个游戏对象 你只是碰撞 

1855
01:39:02,000 --> 01:39:03,841
对你来说这是一个新的状态

1856
01:39:03,841 --> 01:39:04,340
是的

1857
01:39:04,340 --> 01:39:06,288
观众：你可能真的想让它处于一个秋天的状态 

1858
01:39:06,288 --> 01:39:08,885
因为这样你就可以有一个梯子 实际上不去任何地方 

1859
01:39:08,885 --> 01:39:09,926
只会让你更高

1860
01:39:09,926 --> 01:39:13,481
但你可以用它来跳过宽的缝隙 

1861
01:39:13,481 --> 01:39:15,230
科尔顿·奥格登：托尼说你可以

1862
01:39:15,230 --> 01:39:17,980
有能力从梯子上跳下来

1863
01:39:17,980 --> 01:39:19,540
你是这么说的吗是的.

1864
01:39:19,540 --> 01:39:21,920
从梯子上跳下来的能力 这样你就可以把它当作障碍物 

1865
01:39:21,920 --> 01:39:22,878
这是绝对正确的 

1866
01:39:22,878 --> 01:39:26,950
实际上 我们在这里看到的模型 很难看出来 

1867
01:39:26,950 --> 01:39:28,925
我看看能不能放大 

1868
01:39:35,920 --> 01:39:41,740
马里奥 马里奥 图形 然后它被称为全张 

1869
01:39:41,740 --> 01:39:46,470
我在这堂课中使用的整个工作表都被称为fullsheet.png 

1870
01:39:46,470 --> 01:39:49,560
我不知道那是什么 

1871
01:39:49,560 --> 01:39:56,886
所以如果你把这里放大很高 我们可以有效地看到

1872
01:39:56,886 --> 01:39:58,010
你所指的是--

1873
01:39:58,010 --> 01:40:01,181
就在这里 这个小小的绳索 

1874
01:40:01,181 --> 01:40:03,180
我猜为了这个模型的缘故

1875
01:40:03,180 --> 01:40:04,680
他们想要说明的是 

1876
01:40:04,680 --> 01:40:07,970
但是你有一个游戏对象 可以让你进入攀登状态 

1877
01:40:07,970 --> 01:40:11,090
不管它是梯子还是绳子 

1878
01:40:11,090 --> 01:40:15,636
只需为玩家添加一个新状态 

1879
01:40:15,636 --> 01:40:18,260
如果他们处于攀爬状态 那么我们就有了这个新的动画

1880
01:40:18,260 --> 01:40:21,830
这是我们之前在床单上看到的 这是他们的背面或正面 

1881
01:40:21,830 --> 01:40:24,830
然后他们只是爬上它 然后更新它

1882
01:40:24,830 --> 01:40:27,881
如果他们在梯子上向上或向下移动 

1883
01:40:27,881 --> 01:40:29,880
然后给他们跳下来的能力 

1884
01:40:29,880 --> 01:40:32,255
然后 当你到达顶端或底部时 就下车 

1885
01:40:33,950 --> 01:40:37,580
你可以想到很多同样的事情 有很多这样的障碍 

1886
01:40:37,580 --> 01:40:39,410
就像这里的尖刺 

1887
01:40:39,410 --> 01:40:43,410
如果你在跳跃 你击中了它 你可能会死 

1888
01:40:43,410 --> 01:40:50,070
因此 您将检查对象ID是否可能等于Spikes

1889
01:40:50,070 --> 01:40:55,230
或者是否反对致命等于真 

1890
01:40:55,230 --> 01:40:56,850
这个也是一样的 

1891
01:40:56,850 --> 01:41:01,410
然后有些障碍完全是表面上的 就像这里的蘑菇 

1892
01:41:01,410 --> 01:41:04,770
就发行版而言 灌木丛、蘑菇和仙人掌

1893
01:41:04,770 --> 01:41:07,230
所有这些东西都完全是表面上的 

1894
01:41:07,230 --> 01:41:08,310
这样你就可以穿行其中了 

1895
01:41:08,310 --> 01:41:11,130
它们不会触发碰撞 但会被渲染为游戏对象 

1896
01:41:11,130 --> 01:41:12,546
它们不是瓷砖网格的一部分 

1897
01:41:17,180 --> 01:41:19,560
它们的处理方式不同于瓷砖 

1898
01:41:19,560 --> 01:41:20,910
它们不是存储在y x中 

1899
01:41:24,930 --> 01:41:27,760
这就是我们开始思考物体的有效方式

1900
01:41:27,760 --> 01:41:29,010
以及如何赋予他们行为举止 

1901
01:41:29,010 --> 01:41:32,400
作业的一部分将是添加一面旗帜 

1902
01:41:32,400 --> 01:41:34,300
所以这面旗帜在精灵纸上 

1903
01:41:34,300 --> 01:41:36,150
所以你要做的是--

1904
01:41:36,150 --> 01:41:38,760
我会在这节课的最后谈到这一点 

1905
01:41:38,760 --> 01:41:41,910
我们就快到了 

1906
01:41:41,910 --> 01:41:44,490
这些钥匙实际上在右下角--

1907
01:41:44,490 --> 01:41:47,150
所以任务的一部分将是--

1908
01:41:47,150 --> 01:41:48,430
它实际上就在这里 

1909
01:41:48,430 --> 01:41:50,040
所以我会很快地复习一下 

1910
01:41:50,040 --> 01:41:52,320
确保玩家总是在坚实的地面上开始 

1911
01:41:52,320 --> 01:41:56,830
在这种情况下 当詹姆斯跑到这里时 你跑了第一个例子 

1912
01:41:56,830 --> 01:41:58,770
在我们第一次开发这个游戏的时候 

1913
01:41:58,770 --> 01:42:06,180
这就在球员在x1产生的地方产生了一个裂痕 

1914
01:42:06,180 --> 01:42:08,480
因此 如果发生这种情况 他就会坠落而死 

1915
01:42:11,332 --> 01:42:13,290
就在门口 有人有什么想法吗？

1916
01:42:13,290 --> 01:42:16,920
至于我们可以做些什么来检查我们是否在坚实的陆地上 

1917
01:42:16,920 --> 01:42:21,321
假设玩家的默认开始时间是x1？

1918
01:42:21,321 --> 01:42:24,243
观众：在那块瓷砖上 检查它是不是实心的 

1919
01:42:24,243 --> 01:42:27,824
如果不是 那么只需将它移到x上 直到它为真 

1920
01:42:27,824 --> 01:42:28,615
科尔顿·奥格登：是的 

1921
01:42:28,615 --> 01:42:31,590
我们可能想要做的是沿着柱子往下看 

1922
01:42:31,590 --> 01:42:36,400
因为我们从最高处开始 

1923
01:42:36,400 --> 01:42:39,610
如果我们发现下面没有瓷砖--这只是一个纯粹的裂缝--

1924
01:42:39,610 --> 01:42:42,660
我们可能想换掉这名球员 

1925
01:42:42,660 --> 01:42:45,720
然后随机的钥匙和锁--

1926
01:42:45,720 --> 01:42:50,760
让我打开LevelMaker 这样我们就可以看到您将与什么交互 

1927
01:42:50,760 --> 01:42:53,940
因为您实际上要做的大部分事情都是在LevelMaker中完成的 

1928
01:42:58,080 --> 01:43:01,830
它做了很多我们以前用数学做的事情 随机的 

1929
01:43:01,830 --> 01:43:05,670
然后它会插入到物体中 

1930
01:43:05,670 --> 01:43:10,290
所以物体在这里是一张桌子 

1931
01:43:10,290 --> 01:43:14,410
它会根据某种逻辑插入一个游戏对象 

1932
01:43:14,410 --> 01:43:17,627
所以在这种情况下 如果我们要产生一根柱子 

1933
01:43:17,627 --> 01:43:19,710
我们有机会在柱子上长出灌木丛 

1934
01:43:19,710 --> 01:43:23,940
因此 如果math.dom(8)是1 那么在本例中 我们已经生成了一个柱 

1935
01:43:23,940 --> 01:43:26,935
所以我们有一个额外的机会 这是在机会之上

1936
01:43:26,935 --> 01:43:27,960
以产生一根柱子--

1937
01:43:27,960 --> 01:43:33,180
所以基本上 我认为在那个特定的迭代中有64%的几率

1938
01:43:33,180 --> 01:43:36,170
用灌木造一根柱子 

1939
01:43:39,010 --> 01:43:42,330
您只需将新的游戏对象添加到对象中 

1940
01:43:42,330 --> 01:43:44,710
在本例中 这是游戏对象的构造函数 

1941
01:43:44,710 --> 01:43:48,420
你给它一个x y 宽度 高度 然后是一个框架 

1942
01:43:48,420 --> 01:43:52,230
然后 该帧相对于与纹理匹配的任何四元表

1943
01:43:52,230 --> 01:43:52,770
这里有一根线 

1944
01:43:52,770 --> 01:43:56,185
所以灌木丛就是纹理 所以灌木丛中的任何四边形

1945
01:43:56,185 --> 01:43:57,060
你想给它--

1946
01:43:57,060 --> 01:44:02,340
在这种情况下 我们只是给了它一个随机的帧 

1947
01:44:02,340 --> 01:44:05,600
然后 许多相同的逻辑也适用于其他部分 

1948
01:44:05,600 --> 01:44:08,550
这是我们在平地上生长灌木丛的另一个部分 

1949
01:44:08,550 --> 01:44:10,240
我们有机会产生一个积木--

1950
01:44:10,240 --> 01:44:13,330
十分之一的几率这是一个跳跃障碍 

1951
01:44:13,330 --> 01:44:16,350
所以这里我们有纹理 x y 宽度 高度 边框 

1952
01:44:16,350 --> 01:44:18,570
注意 我们有可碰撞的是真的 这是

1953
01:44:18,570 --> 01:44:22,980
就是我们如何测试瓷砖是否可碰撞 

1954
01:44:22,980 --> 01:44:26,140
Hit为FALSE 意味着我们还没有达到它 

1955
01:44:26,140 --> 01:44:33,870
如果我们击中了它 那么我们基本上执行这个代码--onCollide被调用 

1956
01:44:37,170 --> 01:44:40,865
您可以看到在冲突代码中调用它的位置--

1957
01:44:43,800 --> 01:44:45,165
如果我们看球员的话 

1958
01:44:52,800 --> 01:44:55,200
玩家有检查左碰撞 检查右碰撞 

1959
01:44:55,200 --> 01:44:59,280
并检查对象碰撞 

1960
01:44:59,280 --> 01:45:02,145
它没有向上和向下检查碰撞 

1961
01:45:02,145 --> 01:45:04,020
对于这两种情况都有一个角落的案例

1962
01:45:04,020 --> 01:45:05,519
这种逻辑必须被复制 

1963
01:45:05,519 --> 01:45:06,960
我忘记了确切的原因 

1964
01:45:06,960 --> 01:45:10,550
但你基本上得到了一个你要检查的对象的列表 

1965
01:45:15,840 --> 01:45:17,856
哦 原因是当你得到

1966
01:45:17,856 --> 01:45:19,980
当你处于跳跃状态时碰撞的物体 

1967
01:45:19,980 --> 01:45:22,840
您可以触发onCollide函数 

1968
01:45:22,840 --> 01:45:26,560
那么 让我们来看看PlayerJumpState 

1969
01:45:26,560 --> 01:45:34,434
如果我们处于跳跃状态 这基本上就是我们

1970
01:45:34,434 --> 01:45:37,350
检查是否有任何物体与玩家发生碰撞 

1971
01:45:37,350 --> 01:45:41,690
如果它是实心的 则调用其onCollide函数object.onCollide 然后

1972
01:45:41,690 --> 01:45:44,720
基本上 我们只传入对象本身 

1973
01:45:44,720 --> 01:45:48,100
所以如果你回到LevelMaker 那就是

1974
01:45:48,100 --> 01:45:50,290
在那里我们编写onCollide函数 

1975
01:45:50,290 --> 01:45:55,000
我们在此处的游戏对象中编写onCollide函数 

1976
01:45:55,000 --> 01:45:56,750
所以我们就给它一个OnCollide 记住 

1977
01:45:56,750 --> 01:45:58,940
因为函数是一等公民 

1978
01:45:58,940 --> 01:46:03,000
我们可以这样说 onCollide获取函数obj 

1979
01:46:03,000 --> 01:46:06,440
其中obj将成为这个对象 

1980
01:46:06,440 --> 01:46:12,130
如果它还没有被击中 五分之一的机会刷新宝石-

1981
01:46:12,130 --> 01:46:14,260
所以要创造一个宝石 

1982
01:46:14,260 --> 01:46:16,320
里面的东西都一样

1983
01:46:16,320 --> 01:46:20,710
在这种情况下 它有自己的函数onConversion 

1984
01:46:20,710 --> 01:46:24,289
onConclusion接受一个玩家和一个对象 

1985
01:46:24,289 --> 01:46:26,080
顺便说一下 这都是武断的 

1986
01:46:26,080 --> 01:46:27,980
你可以创建任何你想要的功能 

1987
01:46:27,980 --> 01:46:31,570
这些都是回调函数 有效的 

1988
01:46:31,570 --> 01:46:35,050
我们只需要播放拾音器的声音 然后在分数上加100 

1989
01:46:35,050 --> 01:46:38,830
然后在这里 如果我们真的得到了一颗宝石 

1990
01:46:38,830 --> 01:46:41,920
我们在0.1秒的时间内补间它 

1991
01:46:41,920 --> 01:46:46,040
我们把它的y从下面的块到上面 

1992
01:46:46,040 --> 01:46:49,070
所以它有一个向上的动画效果 

1993
01:46:49,070 --> 01:46:50,820
然后我们有另一个声音播放 

1994
01:46:50,820 --> 01:46:53,111
但这就是我们生成游戏对象的有效方式 

1995
01:46:53,111 --> 01:46:56,787
游戏对象有纹理 x y 宽度 高度 然后

1996
01:46:56,787 --> 01:46:58,870
你可以给他们回调函数 

1997
01:46:58,870 --> 01:47:01,360
执行任何与你相关的事情

1998
01:47:01,360 --> 01:47:05,650
在这种情况下 你只需要担心onCollide 

1999
01:47:05,650 --> 01:47:12,310
因为任务是创建随机密钥和锁 

2000
01:47:12,310 --> 01:47:15,380
它们必须是相同的颜色 但你可以随机选择它们 

2001
01:47:15,380 --> 01:47:18,190
如果玩家碰到钥匙 

2002
01:47:18,190 --> 01:47:21,820
可能会得到一些标志 比如key获得为true

2003
01:47:21,820 --> 01:47:23,140
或者类似的东西

2004
01:47:23,140 --> 01:47:27,900
然后你去关卡中生成的区块 

2005
01:47:27,900 --> 01:47:31,150
所以应该生成一个颜色相同块 

2006
01:47:31,150 --> 01:47:37,300
然后在碰撞 你应该解锁它 所以摆脱块

2007
01:47:37,300 --> 01:47:40,900
然后产生一个新的游戏对象--

2008
01:47:40,900 --> 01:47:42,250
国旗

2009
01:47:42,250 --> 01:47:44,770
然后这个标志将有自己的碰撞 

2010
01:47:44,770 --> 01:47:47,830
当你撞到旗子时 重新开始 

2011
01:47:47,830 --> 01:47:51,040
这实际上就是问题集的要点 

2012
01:47:51,040 --> 01:47:52,720
所以可能不需要...

2013
01:47:52,720 --> 01:47:57,570
我会说大概40或50行代码就可以了 

2014
01:47:57,570 --> 01:47:59,530
观众：那个游戏物体--

2015
01:47:59,530 --> 01:48:01,762
是在上课吗

2016
01:48:01,762 --> 01:48:02,470
这不是桌子 

2017
01:48:02,470 --> 01:48:03,460
那是什么？

2018
01:48:03,460 --> 01:48:05,200
科尔顿·奥格登：这是一个类 

2019
01:48:05,200 --> 01:48:06,460
有一个GameObject类 

2020
01:48:06,460 --> 01:48:11,290
游戏对象基本上是--我意识到我没有太多地触及它 

2021
01:48:11,290 --> 01:48:18,760
在这个发行版的上下文中 您几乎可以将其视为一个实体 

2022
01:48:18,760 --> 01:48:21,640
在这种情况下 我所做的是区分

2023
01:48:21,640 --> 01:48:24,040
在生物和非生物之间

2024
01:48:24,040 --> 01:48:28,960
是实体还是游戏对象 这是一种半随意的区别 

2025
01:48:28,960 --> 01:48:31,870
但对于这样一个小项目来说 这是有意义的 

2026
01:48:31,870 --> 01:48:37,390
对于大型项目 我可能会将所有内容都创建为一个实体

2027
01:48:37,390 --> 01:48:39,820
然后给出不同类型的实体

2028
01:48:39,820 --> 01:48:41,654
它们自己的行为和它们自己的组件 

2029
01:48:41,654 --> 01:48:43,986
有点像您处理实体组件系统的方式 

2030
01:48:43,986 --> 01:48:46,305
观众：在Lua中有两种创建类的方法吗 

2031
01:48:46,305 --> 01:48:50,530
一个带大括号的和一个带正括号的？

2032
01:48:50,530 --> 01:48:53,510
科尔顿·奥格登：事实上是有的 

2033
01:48:53,510 --> 01:48:56,650
所以问题是 在Lua中创建类的方法不止一种吗

2034
01:48:56,650 --> 01:48:59,690
无论是圆括号还是花括号？

2035
01:48:59,690 --> 01:49:00,190
是 

2036
01:49:00,190 --> 01:49:02,315
我想我从来没有真正谈过这个 

2037
01:49:05,430 --> 01:49:08,290
让我们回到LevelMaker 

2038
01:49:08,290 --> 01:49:12,550
如果您实例化一个类和该类

2039
01:49:12,550 --> 01:49:22,930
只接受一个表作为它的唯一参数 你可以直接传入这个 

2040
01:49:22,930 --> 01:49:25,790
这实际上就是参数表 

2041
01:49:25,790 --> 01:49:27,400
你不需要括号 

2042
01:49:27,400 --> 01:49:30,141
它有效地做到了这一点--

2043
01:49:30,141 --> 01:49:32,140
同样的事情 只是你不需要括号 

2044
01:49:32,140 --> 01:49:35,220
观众：然后那是一张被传进来的桌子？

2045
01:49:35,220 --> 01:49:37,820
科尔顿·奥格登：正确 

2046
01:49:37,820 --> 01:49:40,840
这只是实例化的另一种形式

2047
01:49:40,840 --> 01:49:44,394
关于那些只把表作为他们什么时候的论据的东西

2048
01:49:44,394 --> 01:49:45,310
它们被实例化 

2049
01:49:45,310 --> 01:49:47,680
观众：那样的话你们只能有一张桌子吗？

2050
01:49:47,680 --> 01:49:49,935
科尔顿·奥格登：正确 是的 

2051
01:49:49,935 --> 01:49:53,572
观众：创建一个新的班级不是更容易吗？

2052
01:49:53,572 --> 01:49:59,392
会有自己的一组游戏对象 所以你

2053
01:49:59,392 --> 01:50:04,260
将创建一个GEM 它将是Helper Dot Gem 它

2054
01:50:04,260 --> 01:50:06,754
会反过来创建一个游戏对象吗？

2055
01:50:06,754 --> 01:50:08,628
科尔顿·奥格登：你能再说一次吗？

2056
01:50:08,628 --> 01:50:10,500
观众：这很难解释 

2057
01:50:10,500 --> 01:50:15,420
创建另一个类不是更容易吗？

2058
01:50:15,420 --> 01:50:19,028
会有你的宝石和所有东西 你的宝石在那个班级里

2059
01:50:19,028 --> 01:50:20,504
会是一个游戏对象吗？

2060
01:50:20,504 --> 01:50:22,472
但在这堂课上 当你想要宝石的时候 

2061
01:50:22,472 --> 01:50:27,400
你会说本地gem等同于helper类的点gem 

2062
01:50:27,400 --> 01:50:30,750
科尔顿·奥格登：问题是 不是吗？

2063
01:50:30,750 --> 01:50:37,120
创建一个helper类来实例化gem会更容易吗？

2064
01:50:37,120 --> 01:50:37,620
有可能 

2065
01:50:40,260 --> 01:50:45,690
我想如果你把这个设计得更有力一点 

2066
01:50:45,690 --> 01:50:47,490
如果这是一场更大的比赛 

2067
01:50:47,490 --> 01:50:51,539
然后 您只需为块、宝石等创建一个子类 

2068
01:50:51,539 --> 01:50:54,330
缩小发行版中的文件数量并进行排序

2069
01:50:54,330 --> 01:50:59,040
将所有东西整合在一起 并将所有级别代码放在一起

2070
01:50:59,040 --> 01:51:04,440
在其中一个地方 我决定只将GameObject创建为一个抽象类

2071
01:51:04,440 --> 01:51:07,950
然后 您只需在实际的

2072
01:51:07,950 --> 01:51:11,340
构造函数--这是这里的这一位 这只是表格--

2073
01:51:11,340 --> 01:51:14,742
然后允许您覆盖onCollide和onConsumer函数 

2074
01:51:14,742 --> 01:51:16,950
你实际上可以给它任何你想要的功能 

2075
01:51:16,950 --> 01:51:22,540
您可以给它指定一些任意命名的函数 然后稍后对其进行测试 

2076
01:51:22,540 --> 01:51:26,490
这几乎就像是一种晦涩的继承方式 

2077
01:51:26,490 --> 01:51:31,980
但我认为 如果我设计这件事的目标是让它成为真正的

2078
01:51:31,980 --> 01:51:34,260
在大型比赛中 我只会把它分成两类 

2079
01:51:34,260 --> 01:51:38,850
我会为GEM创建一个类 为BLOCK创建一个类 为布什创建一个类 

2080
01:51:38,850 --> 01:51:40,830
等等 等等 

2081
01:51:40,830 --> 01:51:43,170
对于这个例子来说 这并不是严格必要的 

2082
01:51:43,170 --> 01:51:45,090
所以我们最终把所有东西都保留了一点

2083
01:51:45,090 --> 01:51:52,470
在某种意义上更抽象--更一般的目的 

2084
01:51:52,470 --> 01:51:57,790
但是 是的 你绝对可以为这些人创建类 

2085
01:51:57,790 --> 01:52:00,060
如果您处于实体组件系统中 

2086
01:52:00,060 --> 01:52:03,405
你可以有一个可消耗的部件 

2087
01:52:03,405 --> 01:52:05,280
然后 该消耗性组件将会

2088
01:52:05,280 --> 01:52:09,510
允许你给它一些影响玩家的行为 当

2089
01:52:09,510 --> 01:52:11,221
玩家消耗该物品 

2090
01:52:11,221 --> 01:52:13,470
在本例中 宝石是一种消耗品 因此您只需

2091
01:52:13,470 --> 01:52:16,290
给它一个具有宝石质地的可消耗成分

2092
01:52:16,290 --> 01:52:18,510
然后给它一个回调函数 

2093
01:52:18,510 --> 01:52:20,025
只会增加玩家的分数

2094
01:52:20,025 --> 01:52:24,060
你可以用10到15行代码来实现 

2095
01:52:24,060 --> 01:52:25,330
很简单的 

2096
01:52:25,330 --> 01:52:29,680
然后块将是一个产卵器组件 

2097
01:52:29,680 --> 01:52:31,170
这样它们才有机会产卵

2098
01:52:31,170 --> 01:52:36,560
然后你会传入spawner组件一个gem 

2099
01:52:36,560 --> 01:52:40,560
这样它就有机会将你放入产卵器的宝石产卵

2100
01:52:40,560 --> 01:52:46,030
然后是一个固体成分 这是固体 

2101
01:52:46,030 --> 01:52:48,102
所以如果我撞到它 我应该会引发碰撞

2102
01:52:48,102 --> 01:52:49,560
却无法穿过它

2103
01:52:49,560 --> 01:52:53,760
所以你只需要把这些组件叠加起来 

2104
01:52:53,760 --> 01:52:58,650
我鼓励你们思考这种作曲方式

2105
01:52:58,650 --> 01:53:02,340
你的对象有点 特别是当我们走向统一 

2106
01:53:02,340 --> 01:53:07,560
很多人使用了这个概念 

2107
01:53:07,560 --> 01:53:10,290
简而言之 是的 

2108
01:53:10,290 --> 01:53:12,326
我想差不多就这些了 

2109
01:53:12,326 --> 01:53:13,200
我先走了 

2110
01:53:13,200 --> 01:53:18,090
我们快没时间了但我说了再说一次

2111
01:53:18,090 --> 01:53:21,504
确保播放器开始以上坚实的土地 随机颜色的关键和锁 

2112
01:53:21,504 --> 01:53:24,420
然后确保当你拿到钥匙的时候 你可以打开锁 

2113
01:53:24,420 --> 01:53:25,920
这就产生了目标 

2114
01:53:25,920 --> 01:53:30,540
这些都是你可以添加到LevelMaker类中的 

2115
01:53:30,540 --> 01:53:35,620
这一切都将与你的游戏水平的方式 

2116
01:53:35,620 --> 01:53:39,210
然后你触摸目标旗 然后重生的水平 

2117
01:53:39,210 --> 01:53:41,520
今天 我们来谈谈《超级马里奥兄弟》 

2118
01:53:41,520 --> 01:53:44,850
那个时代的另一款任天堂游戏

2119
01:53:44,850 --> 01:53:47,700
可以说是有史以来最伟大的电影之一--就是塞尔达 

2120
01:53:47,700 --> 01:53:51,840
所以我们将讨论一个非常简单的塞尔达传说游戏 

2121
01:53:51,840 --> 01:53:54,810
我们有一个随机的地牢可以去

2122
01:53:54,810 --> 01:53:57,480
一个自上而下的视角 与简单的怪物战斗 

2123
01:53:57,480 --> 01:54:00,780
开胸炸墙之类的

2124
01:54:00,780 --> 01:54:02,880
我们将讨论触发器和事件 

2125
01:54:02,880 --> 01:54:06,530
然后我们再谈受伤的箱子 库存

2126
01:54:06,530 --> 01:54:09,950
一个非常简单的GUI 用于打开菜单 

2127
01:54:09,950 --> 01:54:13,710
这样我们就能看到哪些门被炸开了

2128
01:54:13,710 --> 01:54:15,840
适当地渲染 诸如此类 

2129
01:54:15,840 --> 01:54:16,970
马里奥就到此为止了 

2130
01:54:16,970 --> 01:54:17,970
非常感谢您的光临 

2131
01:54:17,970 --> 01:54:20,120
下次再见了 
