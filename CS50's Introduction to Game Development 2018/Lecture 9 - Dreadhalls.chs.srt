1
00:00:16,850 --> 00:00:17,850
科尔顿·奥格登：好的 

2
00:00:17,850 --> 00:00:20,580
欢迎来到GD50第九讲 

3
00:00:20,580 --> 00:00:23,970
今天的主题是可怕的大厅 

4
00:00:23,970 --> 00:00:29,400
因此 上周我们冒险进入了Unity 这是我们首次涉足3D领域 而且不仅是3D 

5
00:00:29,400 --> 00:00:32,460
但也只是让我们的头和手

6
00:00:32,460 --> 00:00:36,690
围绕着统一游戏引擎 它是虚幻和其他游戏中的

7
00:00:36,690 --> 00:00:42,450
这是2D和3D游戏中最流行的游戏引擎 

8
00:00:42,450 --> 00:00:46,740
上周我们做了一个2.5D风格的直升机游戏 

9
00:00:46,740 --> 00:00:51,910
一切都是3D的 但我们仍然只基于两个轴来对齐东西 

10
00:00:51,910 --> 00:00:55,060
X和y 我相信 可能是z和y 

11
00:00:55,060 --> 00:00:57,660
我不记得了 但两把斧头对三把斧头 

12
00:00:57,660 --> 00:01:02,310
今天 我们实际上将使用我们可用的所有三个轴

13
00:01:02,310 --> 00:01:05,160
在Unity3D中的一款名为Dreadhalls的游戏的背景下 

14
00:01:05,160 --> 00:01:08,895
所以恐怖大厅是什么--

15
00:01:08,895 --> 00:01:11,190
这是一款VR游戏 实际上是第一款VR游戏

16
00:01:11,190 --> 00:01:16,230
我曾经在Oculus Gear VR Samsung Gear VR上玩过 

17
00:01:16,230 --> 00:01:20,107
它让你置身于黑暗而诡异的3D迷宫中

18
00:01:20,107 --> 00:01:21,940
你真的不知道发生了什么 

19
00:01:21,940 --> 00:01:23,861
你可以四处走走 拿到收藏品

20
00:01:23,861 --> 00:01:25,860
和你看到的生物和东西相遇

21
00:01:25,860 --> 00:01:28,130
在右下角的屏幕截图中 

22
00:01:28,130 --> 00:01:30,130
今天的示例将稍微简单一些 

23
00:01:30,130 --> 00:01:33,450
但它允许我们探索程序迷宫生成之类的事情

24
00:01:33,450 --> 00:01:36,120
和第一人称相机控制 

25
00:01:36,120 --> 00:01:40,140
上周我们使用了一种第三人称摄像机

26
00:01:40,140 --> 00:01:42,750
我们就像是回到了现场很远的地方 

27
00:01:42,750 --> 00:01:45,030
今天我们将使用第一人称相机

28
00:01:45,030 --> 00:01:47,800
摄像机实际上就是我们的眼睛 就好像我们是

29
00:01:47,800 --> 00:01:51,270
自己在迷宫里走来走去 

30
00:01:51,270 --> 00:01:54,610
不幸的是 本周我们不会使用VR演示 

31
00:01:54,610 --> 00:01:58,110
但下周我希望能做一个虚拟现实的样本

32
00:01:58,110 --> 00:02:00,510
使用这个项目 这样我们就可以看到它在VR中是如何工作的

33
00:02:00,510 --> 00:02:02,812
以及Unity的工具包在VR中是如何工作的 

34
00:02:02,812 --> 00:02:04,770
所以我们今天要讲的一些话题--

35
00:02:04,770 --> 00:02:06,180
我们将讨论纹理处理 

36
00:02:06,180 --> 00:02:10,259
回想一下上周的直升机和我们游戏中的所有物品

37
00:02:10,259 --> 00:02:11,966
只是一种单调的颜色 

38
00:02:11,966 --> 00:02:14,340
它们实际上并没有任何与之相关的质地 

39
00:02:14,340 --> 00:02:17,010
我们将讨论如何为材质指定纹理

40
00:02:17,010 --> 00:02:19,780
以及如何将这些材质应用于场景中的对象 

41
00:02:19,780 --> 00:02:23,490
我们将讨论材质和照明 因此不仅材质 而且

42
00:02:23,490 --> 00:02:28,710
Unity支持的不同类型的灯光以及有关这些的一些细节 

43
00:02:28,710 --> 00:02:30,880
我们将再次讨论3D迷宫的生成 

44
00:02:30,880 --> 00:02:37,046
因此 我们将有一个简单但有效的算法来创建3D数据

45
00:02:37,046 --> 00:02:39,420
结构来表示我们的级别 而不是以前的

46
00:02:39,420 --> 00:02:42,870
我们只有一张瓷砖地图 我们可以

47
00:02:42,870 --> 00:02:45,150
生成让我们看起来像是在四处走动

48
00:02:45,150 --> 00:02:46,740
在某种2D世界里 

49
00:02:46,740 --> 00:02:50,880
现在 我们将实际对数据执行类似的操作 即2D数组 

50
00:02:50,880 --> 00:02:53,850
但我们将使用该数组并实际创建3D块

51
00:02:53,850 --> 00:02:57,000
并创建一个我们可以在3D空间中漫步的迷宫

52
00:02:57,000 --> 00:02:59,400
是一种有趣的东西 

53
00:02:59,400 --> 00:03:03,300
上周我们在比赛中只有一个场景 那只是一个游戏场景 

54
00:03:03,300 --> 00:03:06,600
即使我们在那个场景中有一场比赛 

55
00:03:06,600 --> 00:03:08,100
我们没有在场景之间过渡 

56
00:03:08,100 --> 00:03:10,080
我们只是重新加载了同样的场景 

57
00:03:10,080 --> 00:03:16,180
今天我们将有一个标题屏幕和一个游戏场景 其中

58
00:03:16,180 --> 00:03:19,080
是我们在2D中相爱的想法的演变

59
00:03:19,080 --> 00:03:22,609
在那里我们有一个状态机 它统治着我们的整个游戏

60
00:03:22,609 --> 00:03:24,900
我们可能所处的不同状态 无论是

61
00:03:24,900 --> 00:03:28,170
是标题、游戏结束、播放状态等等 

62
00:03:28,170 --> 00:03:32,310
Unity对场景对象做了同样的事情 它是有效的

63
00:03:32,310 --> 00:03:35,460
一系列对齐的游戏对象的快照

64
00:03:35,460 --> 00:03:38,100
在编辑器中以一种特定的方式 

65
00:03:38,100 --> 00:03:41,220
我们将讨论雾和全局照明

66
00:03:41,220 --> 00:03:43,260
以及某些其他东西 允许我们创造

67
00:03:43,260 --> 00:03:46,380
一种有利于那种感觉的氛围

68
00:03:46,380 --> 00:03:49,530
我们今天想要进入我们的游戏 这是一种令人毛骨悚然和诡异的东西 

69
00:03:49,530 --> 00:03:54,100
最后 当我们谈论如何在游戏中创建UI元素时 

70
00:03:54,100 --> 00:03:58,590
我们将讨论Unity 2D 它的画布对象和文本标签

71
00:03:58,590 --> 00:04:01,057
以及其他一些事情 以及它们是如何运作的 

72
00:04:01,057 --> 00:04:02,890
这是一个硬币的两面 

73
00:04:02,890 --> 00:04:07,220
Unity 3D还与Unity 2D捆绑在一起 

74
00:04:07,220 --> 00:04:11,880
一套工具 不仅用于制作2D游戏 还用于制作2D界面 

75
00:04:11,880 --> 00:04:14,730
可以应用到您的3D游戏中 

76
00:04:14,730 --> 00:04:15,720
首先是demo 

77
00:04:15,720 --> 00:04:17,910
上周我一直在生病 所以我

78
00:04:17,910 --> 00:04:21,120
我会要求任何人来演示 因为我不

79
00:04:21,120 --> 00:04:23,370
我不想传染其他人所以我要去

80
00:04:23,370 --> 00:04:27,660
在这节课上 我们来展示一下这个博弈

81
00:04:27,660 --> 00:04:29,350
我为你准备的

82
00:04:29,350 --> 00:04:30,720
这里有两个场景 

83
00:04:30,720 --> 00:04:33,090
注意这里我有一个标题场景和一个地点场景 

84
00:04:33,090 --> 00:04:35,100
我现在在Unity编辑器中 

85
00:04:35,100 --> 00:04:37,852
我将在这里加载标题场景 我已经完成了 

86
00:04:37,852 --> 00:04:40,560
然后注意它有一个游戏视图和一个场景视图 

87
00:04:40,560 --> 00:04:41,794
我要按播放键了 

88
00:04:41,794 --> 00:04:44,460
我们要确保它被设置为最大化 它是 

89
00:04:44,460 --> 00:04:46,980
所以我们这里有声音 所以我们应该听到音频 

90
00:04:46,980 --> 00:04:49,890
按播放键

91
00:04:49,890 --> 00:04:53,310
请注意我们有一段背景音乐

92
00:04:53,310 --> 00:04:54,600
玩了

93
00:04:54,600 --> 00:04:58,200
我们有一个非常-我们可以很容易地在爱情2D中做到这一点 

94
00:04:58,200 --> 00:05:02,640
这只是一个黑色的屏幕 上面有两个文本标签 

95
00:05:02,640 --> 00:05:06,230
这是通过Unity的2D UI工具包完成的 

96
00:05:06,230 --> 00:05:07,096
所以它说--

97
00:05:07,096 --> 00:05:08,220
它告诉我们按回车键 

98
00:05:08,220 --> 00:05:12,990
所以如果我按下回车键 我们会立刻被传送到这个迷宫里 

99
00:05:12,990 --> 00:05:14,490
这个诡异的迷宫

100
00:05:14,490 --> 00:05:17,220
所以我可以在这个迷宫里走 

101
00:05:17,220 --> 00:05:18,960
有一些事情正在发生 

102
00:05:18,960 --> 00:05:21,870
有谁能告诉我

103
00:05:21,870 --> 00:05:24,630
他们注意到了这个场景 他们会注意到什么？

104
00:05:31,480 --> 00:05:32,730
有哪些要素？

105
00:05:32,730 --> 00:05:35,470
如果你要自己把这些放在一起 你会从哪里开始？

106
00:05:35,470 --> 00:05:37,553
我们能把什么拼在一起？

107
00:05:41,201 --> 00:05:41,700
是的

108
00:05:44,800 --> 00:05:45,300
是的

109
00:05:45,300 --> 00:05:47,841
必须有一个你可以立足的地方 而且确实有 

110
00:05:47,841 --> 00:05:52,380
当然 我们在场景中生成的不仅仅是墙 

111
00:05:52,380 --> 00:05:54,020
但我们得找个地方坐下

112
00:05:54,020 --> 00:05:57,190
如果你往上看 很难分辨 

113
00:05:57,190 --> 00:05:59,970
但我们也有一个天花板 所以地面 天花板和墙壁 

114
00:06:02,880 --> 00:06:04,110
某种照明 

115
00:06:04,110 --> 00:06:05,160
是的

116
00:06:05,160 --> 00:06:08,580
所以在这个例子中 我们实际上是在利用周围环境

117
00:06:08,580 --> 00:06:10,780
照明 而不是有光源 

118
00:06:10,780 --> 00:06:12,090
所以我们来看看 

119
00:06:12,090 --> 00:06:13,680
在上周的课上 我们用了

120
00:06:13,680 --> 00:06:16,559
在两周前的讲座中 我们使用了一个定向光物体 

121
00:06:16,559 --> 00:06:18,600
但在这种情况下 场景中没有灯光 

122
00:06:18,600 --> 00:06:20,590
我们实际上使用了Unity的世界照明 

123
00:06:20,590 --> 00:06:21,923
我们很快就会看到

124
00:06:24,840 --> 00:06:28,140
当我们四处走动时 注意我可以移动到

125
00:06:28,140 --> 00:06:30,610
我的摄像头在用鼠标看 

126
00:06:30,610 --> 00:06:35,550
所以我们实际上是用第一人称控制器来控制摄像机 FPS

127
00:06:35,550 --> 00:06:40,980
控制器 它实际上是Unity提供给你的一个组件 

128
00:06:40,980 --> 00:06:44,280
然后注意到如果我们继续探索迷宫 

129
00:06:44,280 --> 00:06:49,010
我们在这里遇到了这个小东西 它是一种皮卡 

130
00:06:49,010 --> 00:06:54,690
当我们拿起这个的时候 我们就像一架奇怪的钢琴

131
00:06:54,690 --> 00:06:56,355
声音 然后场景重新加载 

132
00:06:59,346 --> 00:07:02,520
有没有人注意到我们在远处看到的东西 

133
00:07:02,520 --> 00:07:04,040
比如这是如何影响的

134
00:07:07,310 --> 00:07:09,210
就像我看着这面墙 

135
00:07:09,210 --> 00:07:11,940
比如说 这很难说 

136
00:07:11,940 --> 00:07:16,712
而不是在这条走廊里有什么区别

137
00:07:16,712 --> 00:07:19,282
观众：我想光源离得更远 

138
00:07:19,282 --> 00:07:21,240
科尔顿·奥格登：光源更远 

139
00:07:21,240 --> 00:07:21,750
算是吧

140
00:07:21,750 --> 00:07:24,480
所以我们现在看到的

141
00:07:24,480 --> 00:07:29,520
一种叫做雾的图形概念 

142
00:07:29,520 --> 00:07:34,230
所以雾能让你有效地增加色彩

143
00:07:34,230 --> 00:07:37,680
基于对象在场景中的距离

144
00:07:37,680 --> 00:07:39,550
并将颜色添加到它们上 

145
00:07:39,550 --> 00:07:42,130
它给你一种错觉 

146
00:07:42,130 --> 00:07:44,550
就好像你被雾包围了一样

147
00:07:44,550 --> 00:07:48,210
它已经存在了很长一段时间 甚至可以追溯到N64天 

148
00:07:48,210 --> 00:07:51,390
我们今天晚些时候会讲到 这其实非常简单

149
00:07:51,390 --> 00:07:55,500
将其添加到Unity游戏及其世界照明系统中 

150
00:07:55,500 --> 00:07:59,530
有没有关于雾 不仅仅是美学上的 

151
00:07:59,530 --> 00:08:01,763
但它如何可能有助于性能？

152
00:08:08,286 --> 00:08:09,162
是啊

153
00:08:09,162 --> 00:08:12,700
观众：不需要太高的像素清晰度 因为它已经

154
00:08:12,700 --> 00:08:13,670
[听不见] 

155
00:08:13,670 --> 00:08:16,260
你不需要那么多的像素清晰度 

156
00:08:16,260 --> 00:08:17,000
算是吧

157
00:08:17,000 --> 00:08:22,080
很久以前人们对雾的使用

158
00:08:22,080 --> 00:08:25,380
因为最终事情完全

159
00:08:25,380 --> 00:08:29,620
不透明超过一定的点 你不需要在你的游戏远提请距离 

160
00:08:29,620 --> 00:08:33,059
所以你实际上可以动态地喜欢--你

161
00:08:33,059 --> 00:08:35,730
可以省略渲染一定距离以外的事物

162
00:08:35,730 --> 00:08:37,730
因为无论如何你都看不到他们

163
00:08:37,730 --> 00:08:40,919
这是一种优化技术 

164
00:08:40,919 --> 00:08:45,060
当绘制距离是计算机的一个巨大瓶颈时 

165
00:08:45,060 --> 00:08:48,510
和电子游戏机 

166
00:08:48,510 --> 00:08:52,147
像寂静岭 PS1的游戏 几乎完全是雾 

167
00:08:52,147 --> 00:08:53,980
在你面前 你几乎看不到什么 

168
00:08:53,980 --> 00:08:56,070
我们稍后会看到一个截图 

169
00:08:56,070 --> 00:08:58,770
他们利用这一点来提高他们的表现

170
00:08:58,770 --> 00:09:01,045
并且还提供一定的美感 

171
00:09:01,045 --> 00:09:03,420
还有一件事你可能会注意

172
00:09:03,420 --> 00:09:07,500
就是有一个循环的声音 有点像是令人毛骨悚然的低语声

173
00:09:07,500 --> 00:09:11,000
这只是为了增加气氛

174
00:09:11,000 --> 00:09:11,760
对的

175
00:09:11,760 --> 00:09:16,140
只是因为没有它 我们会--这是这样的小事情 特别是

176
00:09:16,140 --> 00:09:19,140
在这样的恐怖游戏中 气氛可以决定一切 

177
00:09:19,140 --> 00:09:23,140
用非常简单的想法 雾 一些耳语 第一人称控制器 

178
00:09:23,140 --> 00:09:27,270
所以你有狭窄的走廊 你可以生产一些非常可怕的东西 

179
00:09:27,270 --> 00:09:29,190
这里还缺少一些东西 

180
00:09:29,190 --> 00:09:33,180
也就是说 没有任何东西会攻击你

181
00:09:33,180 --> 00:09:36,570
但要加上一点也不难 

182
00:09:36,570 --> 00:09:39,824
但是因为我们使用的是程序生成 

183
00:09:39,824 --> 00:09:41,490
你需要一种所谓的导航网状物 

184
00:09:41,490 --> 00:09:44,115
你需要程序化地生成它 这样才能

185
00:09:44,115 --> 00:09:45,682
可以在3D空间里跟踪你 

186
00:09:45,682 --> 00:09:48,390
我们可能会有时间来讨论一下如何做到这一点

187
00:09:48,390 --> 00:09:52,860
今天晚些时候 但这并没有在这节课中实现 

188
00:09:52,860 --> 00:09:57,790
但要做到这一点也不是太不可行 

189
00:09:57,790 --> 00:10:01,120
但这些是我们今天要看的一些片段 

190
00:10:01,120 --> 00:10:03,230
这就是片名场景 

191
00:10:03,230 --> 00:10:07,230
请注意 实际上这里并不是很多 所以如果我缩小 

192
00:10:07,230 --> 00:10:10,410
我们可以看到油画是巨大的 只是在单位

193
00:10:10,410 --> 00:10:13,320
因为以这种方式呈现它们对引擎来说更加优化 

194
00:10:13,320 --> 00:10:20,910
但我们可以看到 尽管这是一个2D用户界面 但它在3D空间中非常明显 

195
00:10:20,910 --> 00:10:26,650
如果你点击这里的按钮 我们最终会得到--

196
00:10:26,650 --> 00:10:27,150
哦 不 

197
00:10:27,150 --> 00:10:28,950
这只会让我们陷入--抱歉 

198
00:10:28,950 --> 00:10:30,340
点击这里的按钮 

199
00:10:30,340 --> 00:10:33,770
这将把我们带入2D Unity 2D模式 

200
00:10:33,770 --> 00:10:36,060
因此 现在我们正在与2D中的事物进行交互 

201
00:10:36,060 --> 00:10:39,600
实际上 我可以点击这个标签并将其移动

202
00:10:39,600 --> 00:10:43,962
在2D中 就好像我们使用的是2D游戏引擎 而不是3D游戏引擎 

203
00:10:43,962 --> 00:10:45,670
所以我们稍后会看到这一点 

204
00:10:45,670 --> 00:10:47,470
这只是片名的场景 

205
00:10:47,470 --> 00:10:49,060
所以这场戏本身--

206
00:10:49,060 --> 00:10:50,295
我不会把它存起来的 

207
00:10:50,295 --> 00:10:51,690
话剧场景本身--

208
00:10:51,690 --> 00:10:53,910
我将从2D回到3D--

209
00:10:53,910 --> 00:10:55,480
几乎是空的 

210
00:10:55,480 --> 00:10:57,390
所以我们这里有一个第一人称控制人 

211
00:10:57,390 --> 00:11:00,440
这是FPS控制器对象 

212
00:11:00,440 --> 00:11:05,400
有人--有人告诉我FPS控制器的基本构成吗？

213
00:11:05,400 --> 00:11:08,219
仅仅通过看这里的场景就可以了？

214
00:11:08,219 --> 00:11:10,260
有哪些片段会让你眼前一亮？

215
00:11:14,172 --> 00:11:17,142
观众：我以为你只是把摄像机放在球员所在的地方

216
00:11:17,142 --> 00:11:18,850
或者就在球员面前 

217
00:11:18,850 --> 00:11:19,190
科尔顿·奥格登：没错 

218
00:11:19,190 --> 00:11:21,690
你把相机放在玩家所在的地方 效果很好

219
00:11:21,690 --> 00:11:24,960
你的头应该相对于他们身体的位置 

220
00:11:24,960 --> 00:11:27,630
他们的身体--他们的身体是由什么构成的？

221
00:11:27,630 --> 00:11:30,555
你能看出来吗？

222
00:11:30,555 --> 00:11:33,770
观众：它可能只是一个--它看起来像一个中间的立方体 

223
00:11:33,770 --> 00:11:35,936
科尔顿·奥格登：实际上就是这个太空舱 

224
00:11:35,936 --> 00:11:37,590
我不知道你能不能看出来 

225
00:11:37,590 --> 00:11:40,490
这里有一个胶囊 这个绿色的胶囊 

226
00:11:40,490 --> 00:11:43,670
它一定比立方体更有组织的感觉 

227
00:11:43,670 --> 00:11:45,800
但你也可以用一个立方体 

228
00:11:45,800 --> 00:11:50,990
但在Unity中 角色控制器是用胶囊表示的 

229
00:11:50,990 --> 00:11:54,680
而角色控制器在Unity中是免费的 这真的很好 

230
00:11:54,680 --> 00:11:57,270
它们是标准资产的一部分 

231
00:11:57,270 --> 00:11:59,030
因此 如果您要导入包 在Unity中--

232
00:11:59,030 --> 00:12:01,460
如果您进入资产、导入包 则会有

233
00:12:01,460 --> 00:12:04,850
很多免费提供的套餐都会给你带来些许帮助 

234
00:12:04,850 --> 00:12:08,090
请注意 里面有2D套装、摄像机、角色 

235
00:12:08,090 --> 00:12:12,890
角色包具有3D角色或第三人称角色 

236
00:12:12,890 --> 00:12:15,260
第一人称角色 有些是基于物理的 

237
00:12:15,260 --> 00:12:16,820
有些不是基于物理的 

238
00:12:16,820 --> 00:12:19,130
这个特殊的控制器不是物理控制器

239
00:12:19,130 --> 00:12:21,830
基于 这意味着我们不会对其施加力量 

240
00:12:21,830 --> 00:12:23,040
我们把它搬来搬去 

241
00:12:23,040 --> 00:12:24,850
它是运动学的 

242
00:12:24,850 --> 00:12:28,610
它受到重力的影响 所以从某种意义上说 它是基于物理的 

243
00:12:28,610 --> 00:12:32,140
但它不像刚体和刚体那样严格地基于物理 

244
00:12:32,140 --> 00:12:35,030
以及发生在这个刚体和另一个刚体之间的碰撞

245
00:12:35,030 --> 00:12:37,070
不同于如果我们是的话

246
00:12:37,070 --> 00:12:40,550
以使其成为纯粹基于刚体的角色控制器 

247
00:12:40,550 --> 00:12:43,396
有一个纯粹基于刚体的角色控制器

248
00:12:43,396 --> 00:12:45,770
你可以进口的--还没有做过很多试验 

249
00:12:45,770 --> 00:12:48,770
但你可能会想出这在游戏中有很好的用途

250
00:12:48,770 --> 00:12:53,120
或者 您可能想要在具有不同材质的表面上精确移动 

251
00:12:53,120 --> 00:12:56,150
喜欢结冰的表面或诸如此类的东西 并让它应用

252
00:12:56,150 --> 00:13:00,390
以一种非常现实的方式 

253
00:13:00,390 --> 00:13:03,980
在我们的游戏场景中 我们有一些东西--

254
00:13:03,980 --> 00:13:06,027
我们有一个地牢发电机物体 

255
00:13:06,027 --> 00:13:08,360
所以这个地下城生成器对象只是一个空对象

256
00:13:08,360 --> 00:13:10,730
这里有一个电平生成器脚本 

257
00:13:10,730 --> 00:13:13,970
然后我们还有其他几个对象 地板父对象 墙父对象 

258
00:13:13,970 --> 00:13:15,680
还有一个耳语来源 

259
00:13:15,680 --> 00:13:19,220
因此 我们将深入了解所有这些内容的具体含义 

260
00:13:19,220 --> 00:13:21,810
我们今天的目标是谈论几件事 

261
00:13:21,810 --> 00:13:24,537
所以我们将讨论--这是一张我们迷宫的照片 

262
00:13:24,537 --> 00:13:26,870
因此 我们在高级别上讨论了其中一些事情 

263
00:13:26,870 --> 00:13:30,920
今天我们将探索如何在Unity中实现它们 所以做一个迷宫 

264
00:13:30,920 --> 00:13:35,210
制作雾效果 用我们的角色控制器穿行 

265
00:13:35,210 --> 00:13:37,940
我们希望能够在这里进行某种游戏 

266
00:13:37,940 --> 00:13:40,410
所以我们有这种红色硬币形式的收藏品 

267
00:13:40,410 --> 00:13:43,370
这实际上是另一个标准资产包的一部分 即原型

268
00:13:43,370 --> 00:13:44,300
资产打包 

269
00:13:44,300 --> 00:13:48,350
它附带了一个原型小硬币物体 你可以扔进去 

270
00:13:48,350 --> 00:13:51,800
有没有人注意到这枚硬币有什么特别之处

271
00:13:51,800 --> 00:13:55,350
这只是一枚红色硬币？

272
00:13:55,350 --> 00:13:58,063
你还知道这一幕还有什么原因吗？

273
00:13:58,063 --> 00:13:59,570
观众：它在发光 

274
00:13:59,570 --> 00:14:01,028
科尔顿·奥格登：它在发光 

275
00:14:01,028 --> 00:14:03,844
关于它是如何发光的有什么想法吗？

276
00:14:03,844 --> 00:14:05,810
观众：里面有光源吗？

277
00:14:05,810 --> 00:14:06,650
科尔顿·奥格登：里面有一个光源 

278
00:14:06,650 --> 00:14:07,490
一点儿没错 

279
00:14:07,490 --> 00:14:08,570
所以我们会讨论这个问题 

280
00:14:08,570 --> 00:14:10,153
我们将向您展示如何实现这一点 

281
00:14:10,153 --> 00:14:11,450
在Unity中很容易做到 

282
00:14:11,450 --> 00:14:17,000
然后我们还将在最后讨论我们的2D场景 我们的标题场景 

283
00:14:17,000 --> 00:14:19,820
以及如何构建它 这在Unity中实际上非常容易

284
00:14:19,820 --> 00:14:21,830
而不是通过代码来做某事 

285
00:14:21,830 --> 00:14:24,500
你很少真正需要触摸界面

286
00:14:24,500 --> 00:14:26,810
代码 至少在如何布局它们方面是这样 

287
00:14:26,810 --> 00:14:29,870
在Unity中 您可以非常直观地使用鼠标做任何事情 

288
00:14:29,870 --> 00:14:33,260
事实上 制作界面是一件很愉快的事情

289
00:14:33,260 --> 00:14:37,110
如果您习惯于只用代码编写它们的话 

290
00:14:37,110 --> 00:14:41,870
所以纹理--所以上周或两周前 我们没有做任何纹理方面的工作 

291
00:14:41,870 --> 00:14:42,830
好吧 那不是真的 

292
00:14:42,830 --> 00:14:45,170
我们在背景上有一个纹理 它

293
00:14:45,170 --> 00:14:47,850
是一种滚动的背景 

294
00:14:47,850 --> 00:14:49,820
但我们并没有太多地关注这一点 

295
00:14:49,820 --> 00:14:52,800
在今天的例子中 你知道直升机和硬币

296
00:14:52,800 --> 00:14:56,180
还有那些建筑和所有的东西 那些

297
00:14:56,180 --> 00:15:01,160
都是与平面颜色相关联的多边形 

298
00:15:01,160 --> 00:15:04,770
今天我们将讨论如何使用材质对物体进行纹理处理 

299
00:15:04,770 --> 00:15:07,280
因此 在Unity中很容易做到这一点 

300
00:15:07,280 --> 00:15:10,640
所以我要去我的片名现场

301
00:15:10,640 --> 00:15:14,612
在这里 仅仅因为它是以一种与剧本相反的相当正常的方式点亮的

302
00:15:14,612 --> 00:15:16,820
场景 它不是以正常方式照明的 因为我们

303
00:15:16,820 --> 00:15:18,450
使用环境照明 

304
00:15:18,450 --> 00:15:20,600
我们没有天空盒子 

305
00:15:20,600 --> 00:15:25,010
标题场景具有相当正常的照明设置 

306
00:15:25,010 --> 00:15:29,630
因此 如果我在场景中添加一个立方体 您可以

307
00:15:29,630 --> 00:15:33,500
可以立即看到默认情况下我们确实在这里得到了一份材料 

308
00:15:33,500 --> 00:15:36,350
它有一种叫做反照率的成分 

309
00:15:36,350 --> 00:15:39,740
反照率只是指它的表面颜色是什么样子的 

310
00:15:39,740 --> 00:15:43,346
它有一个更技术性的定义 

311
00:15:43,346 --> 00:15:45,470
你可以在维基百科上查到什么是反照率 

312
00:15:45,470 --> 00:15:49,340
这与光与表面相互作用的方式有关 

313
00:15:49,340 --> 00:15:51,050
这里还有很多其他的元素 

314
00:15:51,050 --> 00:15:52,899
你可以让东西看起来像金属 

315
00:15:52,899 --> 00:15:54,440
你可以让它看起来光滑或粗糙 

316
00:15:54,440 --> 00:15:56,990
您还可以添加法线贴图、高度贴图、

317
00:15:56,990 --> 00:16:00,110
还有一些其他的东西 这让它更像是凹凸不平的质地 

318
00:16:00,110 --> 00:16:01,260
以此类推 

319
00:16:01,260 --> 00:16:04,860
你也可以用这种方式让物体发光 

320
00:16:04,860 --> 00:16:08,710
这枚硬币实际上不仅发光 而且还是一个光源 

321
00:16:08,710 --> 00:16:11,730
因此 它同时做到了这两点 

322
00:16:11,730 --> 00:16:13,290
这里还有一些其他的东西 

323
00:16:13,290 --> 00:16:18,800
例如 假设你有一个非常大的立方体和一个很小的纹理 

324
00:16:18,800 --> 00:16:20,900
如果你把一个非常小的纹理放在一个大立方体上 

325
00:16:20,900 --> 00:16:22,108
它会是什么样子的？

326
00:16:26,835 --> 00:16:27,710
你的直觉是什么？

327
00:16:27,710 --> 00:16:29,876
如果我们有一个非常大的立方体 但一个非常--就像

328
00:16:29,876 --> 00:16:34,354
假设我们有一个64x64像素的纹理 但我们的立方体是巨大的吗？

329
00:16:34,354 --> 00:16:36,270
这会对立方体产生什么影响？

330
00:16:40,140 --> 00:16:43,330
它看起来会有点像N64立方体 对吗？

331
00:16:43,330 --> 00:16:46,390
基本上发生的是它将在纹理之间进行内插

332
00:16:46,390 --> 00:16:50,500
像素 即将纹理应用于立方体时的纹理元素 

333
00:16:50,500 --> 00:16:53,050
因此 当你将一个小纹理应用到一个大表面上时 

334
00:16:53,050 --> 00:16:55,090
它会看起来被拉长了 

335
00:16:55,090 --> 00:16:58,100
它会看起来被拉长了 

336
00:16:58,100 --> 00:17:01,586
它看起来也会经过过滤 就像你在YouTube视频中看到的那样

337
00:17:01,586 --> 00:17:04,210
如果你观看它们 它们被记录在一个非常小的分辨率上 

338
00:17:04,210 --> 00:17:05,109
但你却把它们炸飞了 

339
00:17:05,109 --> 00:17:07,119
它们看起来像是过滤过的 或者如果你曾经伸展过

340
00:17:07,119 --> 00:17:11,530
一张图片放在正确的软件中 在滤镜中看起来像是内插的 

341
00:17:11,530 --> 00:17:13,450
它会有那样的样子 

342
00:17:13,450 --> 00:17:15,520
所以你能做的就是贴瓷砖 

343
00:17:15,520 --> 00:17:19,339
所以在这里我们可以看到 有一个平铺元素x和y 

344
00:17:19,339 --> 00:17:23,020
所以在x和y方向上是1 因为它只

345
00:17:23,020 --> 00:17:25,900
适用于平面 

346
00:17:25,900 --> 00:17:31,960
所以平铺的效果是这样的 如果你有一个64x64的纹理 

347
00:17:31,960 --> 00:17:35,007
您只需将该纹理平铺几次即可获得所需的效果

348
00:17:35,007 --> 00:17:37,090
看着你想要的任何表面 你是

349
00:17:37,090 --> 00:17:38,590
试着在你的游戏世界里看 

350
00:17:38,590 --> 00:17:40,990
可能是一个非常小的物体 也可能是一个非常大的物体

351
00:17:40,990 --> 00:17:43,073
你作为一个角色来看待你想要的

352
00:17:43,073 --> 00:17:47,050
例如 瓦砖或石头 

353
00:17:47,050 --> 00:17:57,640
因此 为了将纹理应用到场景中的3D对象 我将进入这里 

354
00:17:57,640 --> 00:18:00,517
所以你首先需要一种材料 

355
00:18:00,517 --> 00:18:02,350
这些都是Unity材质对象 

356
00:18:02,350 --> 00:18:04,270
你可以看出来 因为他们有一个圆形--

357
00:18:04,270 --> 00:18:07,102
它们看起来都像是被包裹在一个球体上 

358
00:18:07,102 --> 00:18:09,310
这些都是Unity材质 而不是纹理 

359
00:18:09,310 --> 00:18:13,880
纹理只是2D对象、2D纹理、2D图像 

360
00:18:13,880 --> 00:18:16,420
这是我下载的资产包的一部分

361
00:18:16,420 --> 00:18:23,290
这节课的题目是低聚地下城模块 它在资产商店里 

362
00:18:23,290 --> 00:18:25,650
所以我要做的就是申请--

363
00:18:25,650 --> 00:18:28,570
假设我只想将此岩石材质应用于此对象 

364
00:18:28,570 --> 00:18:29,069
正确的 

365
00:18:29,069 --> 00:18:30,545
然后我就去找那个 

366
00:18:30,545 --> 00:18:33,790
我要先加一个--

367
00:18:33,790 --> 00:18:40,550
我想是因为我进入了材料中 所以它的外观不正确 

368
00:18:40,550 --> 00:18:42,040
那就这么做吧 

369
00:18:42,040 --> 00:18:44,587
哦 那太奇怪了 

370
00:18:44,587 --> 00:18:45,920
我要创造一个新的场景 

371
00:18:48,980 --> 00:18:53,480
然后我要添加一个立方体 然后--

372
00:18:53,480 --> 00:18:57,370
不是爆裂 可能是横梁 

373
00:18:57,370 --> 00:19:00,770
我想知道为什么不是--

374
00:19:00,770 --> 00:19:01,810
这太奇怪了 

375
00:19:01,810 --> 00:19:03,685
出于某种原因 这可能是我

376
00:19:03,685 --> 00:19:08,570
已经启用了不允许其正确渲染的功能 

377
00:19:08,570 --> 00:19:11,710
但这样做的效果应该是我们通常会应用

378
00:19:11,710 --> 00:19:19,030
如果将纹理应用于材质 它将

379
00:19:19,030 --> 00:19:23,360
有创造的效果--它会立即产生纹理 

380
00:19:23,360 --> 00:19:25,390
但我能做的是 我可以在这里转到纹理 

381
00:19:25,390 --> 00:19:26,770
这也应该是可行的 

382
00:19:26,770 --> 00:19:29,260
我可以转到那里 然后它就会这样应用它 

383
00:19:29,260 --> 00:19:34,570
因此 通常情况下 如果你在一个新的项目中添加了一个新的3D对象 

384
00:19:34,570 --> 00:19:37,150
你只需点击一种材质并将其拖到3D对象上 

385
00:19:37,150 --> 00:19:38,770
它会为你带来质感 

386
00:19:38,770 --> 00:19:40,810
在这种情况下 我认为因为它自动地

387
00:19:40,810 --> 00:19:44,590
基于某些项目设置将材质指定给这些对象

388
00:19:44,590 --> 00:19:48,820
我就是不能--

389
00:19:48,820 --> 00:19:50,080
我不确定--

390
00:19:50,080 --> 00:19:53,080
你可以转到这里的反照率分量 

391
00:19:53,080 --> 00:19:58,190
因此 反照率不仅是一种颜色 也是一种物体的纹理 

392
00:19:58,190 --> 00:20:00,430
所以你可以应用纹理 只需2D图像 

393
00:20:00,430 --> 00:20:02,680
一种材料的反照率成分 

394
00:20:02,680 --> 00:20:03,280
正确的 

395
00:20:03,280 --> 00:20:07,720
这将具有与立即对其进行纹理处理相同的效果 

396
00:20:07,720 --> 00:20:13,520
所以通常情况下 这应该会产生一个反照率--

397
00:20:13,520 --> 00:20:16,330
创建具有该纹理作为反照率的新材质

398
00:20:16,330 --> 00:20:21,110
您可以为3D对象设置材质 

399
00:20:21,110 --> 00:20:23,800
现在我在想我是不是

400
00:20:23,800 --> 00:20:24,849
嗯 

401
00:20:24,849 --> 00:20:25,390
我没有把握 

402
00:20:25,390 --> 00:20:29,199
我不太清楚为什么它不能立刻起作用

403
00:20:29,199 --> 00:20:30,490
就像它通常应该做的那样 

404
00:20:30,490 --> 00:20:31,900
在一个全新的项目中 它会的 

405
00:20:31,900 --> 00:20:32,980
我会试着去调查 

406
00:20:32,980 --> 00:20:36,070
但如果发生这样的事情 出于某种原因 你会--

407
00:20:36,070 --> 00:20:38,940
我认为这与着色器设置在这里的方式有关 

408
00:20:38,940 --> 00:20:41,770
也许有一种背景我只是不太确定 

409
00:20:41,770 --> 00:20:46,990
但您可以在此处手动设置反照率分量 

410
00:20:46,990 --> 00:20:48,860
它也会有同样的效果 

411
00:20:48,860 --> 00:20:52,810
所以你材料的反照率成分 设置了一种纹理 

412
00:20:52,810 --> 00:20:54,580
为对象添加纹理 

413
00:20:54,580 --> 00:20:58,720
所以这就是我们从这种外观中得到的有效方式

414
00:20:58,720 --> 00:21:03,550
从平面着色或平面颜色着色对象到纹理着色

415
00:21:03,550 --> 00:21:07,000
就像这样的物体 

416
00:21:07,000 --> 00:21:14,350
而纹理贴图本身就是一个非常广泛的领域 而且相当复杂 

417
00:21:14,350 --> 00:21:18,470
但最终它看起来像这样 

418
00:21:18,470 --> 00:21:23,690
有谁能告诉我这是什么样子的吗？

419
00:21:23,690 --> 00:21:28,750
所以我们在这里看到 很明显 我们有一个完全纹理的模型 

420
00:21:28,750 --> 00:21:34,410
但如果我们看这个 我们看起来像是做了什么？

421
00:21:38,247 --> 00:21:39,330
那么它看起来是什么样子呢？

422
00:21:39,330 --> 00:21:40,580
忽略所有行 

423
00:21:40,580 --> 00:21:43,145
但我们在表面上看到的是什么样子呢？

424
00:21:46,174 --> 00:21:49,100
这只是一种质感 对吧？

425
00:21:49,100 --> 00:21:49,600
哎呀 

426
00:21:49,600 --> 00:21:51,750
我们可以在这里看到一些颜色 

427
00:21:51,750 --> 00:21:55,170
例如 也许他的腰带在这里或实际上是在那里

428
00:21:55,170 --> 00:21:56,700
看起来像是他的头顶 

429
00:21:56,700 --> 00:22:00,872
这是他的头顶 然后我们有他的腰带和其他东西 

430
00:22:00,872 --> 00:22:04,080
就在这里 我们可以很清楚地看到这就像是他的口罩 

431
00:22:04,080 --> 00:22:04,580
对吗？

432
00:22:04,580 --> 00:22:08,700
但它只是在2D表面上 就像这是一个规则的纹理 

433
00:22:08,700 --> 00:22:13,260
所以我们在这里所做的基本上是

434
00:22:13,260 --> 00:22:19,290
组成模型的所有多边形 并将它们平铺 对吗？

435
00:22:19,290 --> 00:22:23,520
把它们平放在我们的纹理所在的桌子上

436
00:22:23,520 --> 00:22:25,970
这就是UV贴图的含义 

437
00:22:25,970 --> 00:22:29,340
这通常是你在任何3D建模软件中都要做的事情

438
00:22:29,340 --> 00:22:31,150
你正在使用的东西 

439
00:22:31,150 --> 00:22:36,990
在Unity中 将纹理应用于材质或具有纹理的材质时

440
00:22:36,990 --> 00:22:41,840
对于一个物体 它将使用它的标准--

441
00:22:41,840 --> 00:22:44,640
它有自己的内置映射算法

442
00:22:44,640 --> 00:22:47,130
这将对模型应用材质 

443
00:22:47,130 --> 00:22:49,800
因此 它对不同的对象做了不同的处理 

444
00:22:49,800 --> 00:22:53,330
例如 我们可以像球体一样创建 

445
00:22:53,330 --> 00:22:55,530
把球体移到这里来 

446
00:22:55,530 --> 00:23:00,450
我会再试一次 看看是否将这种材料

447
00:23:00,450 --> 00:23:02,260
对此很感兴趣 

448
00:23:02,260 --> 00:23:02,760
不是的 

449
00:23:02,760 --> 00:23:03,630
这是不可能的 

450
00:23:03,630 --> 00:23:08,850
所以应用一种--所以如果我们进入这个材料

451
00:23:08,850 --> 00:23:13,760
这里 由于某种原因 它是灰色的 

452
00:23:16,820 --> 00:23:18,960
又是新场景 

453
00:23:18,960 --> 00:23:22,710
创建新的3D球体 

454
00:23:22,710 --> 00:23:34,261
然后 哦 这一次看起来像是--哦 我不知道 

455
00:23:34,261 --> 00:23:34,760
不是的 

456
00:23:34,760 --> 00:23:35,968
我不认为这有什么用 

457
00:23:38,360 --> 00:23:39,050
噢 

458
00:23:39,050 --> 00:23:41,450
现在它允许我们接受一种纹理 

459
00:23:41,450 --> 00:23:42,200
好的 

460
00:23:42,200 --> 00:23:43,370
这样我们就可以应用纹理了 

461
00:23:43,370 --> 00:23:43,870
哎呦 

462
00:23:43,870 --> 00:23:46,070
可以对其应用纹理 

463
00:23:46,070 --> 00:23:50,089
所以现在我们可以看到我们的球体也被映射了 

464
00:23:50,089 --> 00:23:51,380
而且它看起来相当令人信服 

465
00:23:51,380 --> 00:23:53,421
它被包裹在一种它不会

466
00:23:53,421 --> 00:23:55,400
看起来太扭曲或太奇怪了 

467
00:23:55,400 --> 00:24:01,340
因此 Unity有自己的原始对象贴图方式 

468
00:24:01,340 --> 00:24:05,070
无论是球体 立方体 我们还有其他一些 胶囊 圆柱体 

469
00:24:05,070 --> 00:24:06,049
飞机 

470
00:24:06,049 --> 00:24:08,090
显然 这取决于你的质地是什么 

471
00:24:08,090 --> 00:24:12,680
如果您的纹理相当华丽 它最终可能会看起来扭曲 

472
00:24:12,680 --> 00:24:18,230
但对于大多数目的 对于简单的基本体对象 对于大多数纹理

473
00:24:18,230 --> 00:24:19,430
它应该运行得很好 

474
00:24:19,430 --> 00:24:24,470
现在 如果您导入了一个类似于桌子或角色的模型

475
00:24:24,470 --> 00:24:29,790
而你刚刚给它涂上了纹理 它看起来不会很好 

476
00:24:29,790 --> 00:24:31,380
它会看起来一团糟 

477
00:24:31,380 --> 00:24:34,790
因此 您的3D软件将导出一种材质

478
00:24:34,790 --> 00:24:37,380
该模型假定您已对

479
00:24:37,380 --> 00:24:40,280
在那个有质感的软件里 

480
00:24:40,280 --> 00:24:42,830
它实际上会给你一种材料 然后你就可以

481
00:24:42,830 --> 00:24:47,330
将适当地将纹理应用于角色的引用 

482
00:24:47,330 --> 00:24:49,910
但同样的一种应用纹理 只是

483
00:24:49,910 --> 00:24:52,250
复杂模型的规则纹理 

484
00:24:52,250 --> 00:24:55,850
只是不起作用 因为它没有以一种智能的方式进行UV贴图 

485
00:24:55,850 --> 00:24:59,330
Unity不会知道我有桌子的 

486
00:24:59,330 --> 00:25:04,430
我想以一种看起来令人信服的方式将纹理映射到桌子上 

487
00:25:04,430 --> 00:25:09,920
如果我们创建一个立方体 你可以看到这种情况 

488
00:25:09,920 --> 00:25:13,130
然后如果我们继续--

489
00:25:16,050 --> 00:25:18,950
因为某些原因而变得明显起来 

490
00:25:18,950 --> 00:25:22,350
如果我们从这里上去 我要先分配--

491
00:25:22,350 --> 00:25:22,850
好的 

492
00:25:22,850 --> 00:25:25,610
出于某种原因 这种做法立即奏效了 

493
00:25:25,610 --> 00:25:29,570
但你可以看到 我们对它应用了一种墙体纹理 

494
00:25:29,570 --> 00:25:35,300
如果我们按比例缩小--这是上面的比例按钮 

495
00:25:35,300 --> 00:25:37,280
你可以移动、旋转东西 

496
00:25:37,280 --> 00:25:42,200
如果不熟悉 这里上面的这些顶部按钮是变换操作符 

497
00:25:42,200 --> 00:25:46,010
这样你就可以移动物体、旋转物体和缩放物体 

498
00:25:46,010 --> 00:25:53,630
所以如果你沿着这个y轴缩放一点 然后你放大 

499
00:25:53,630 --> 00:25:56,520
纹理看起来非常压缩和扭曲 

500
00:25:56,520 --> 00:25:58,691
因为它只是在做同样的算法

501
00:25:58,691 --> 00:26:00,440
假设它是相同类型的表面

502
00:26:00,440 --> 00:26:03,680
而不考虑它是如何被扭曲的 

503
00:26:03,680 --> 00:26:04,430
正确的 

504
00:26:04,430 --> 00:26:09,830
因此 理想情况下 你不会让这种扁平化发生 

505
00:26:09,830 --> 00:26:13,820
因此 在您的3D软件中 您可以打开模型

506
00:26:13,820 --> 00:26:19,670
然后将纹理应用到模型的每个单独的多边形

507
00:26:19,670 --> 00:26:22,482
以一种看起来令人信服的方式 

508
00:26:22,482 --> 00:26:24,440
所以这不是你必须要做的事情

509
00:26:24,440 --> 00:26:29,510
为你的项目做讲课或演示 

510
00:26:29,510 --> 00:26:33,700
但是 如果您正在创建自己的3D资源 如果您正在导入3D资源 

511
00:26:33,700 --> 00:26:37,340
如果你想以我们今天所做的方式使用纹理 

512
00:26:37,340 --> 00:26:41,750
您可能需要熟悉UV包装 UV

513
00:26:41,750 --> 00:26:44,940
在您正在使用的任何软件中展开、UV贴图 

514
00:26:44,940 --> 00:26:46,940
如果你只是总体上不熟悉它

515
00:26:46,940 --> 00:26:53,540
并想知道在将一个平坦的白色多边形

516
00:26:53,540 --> 00:26:55,946
角色变成了有质感的东西 

517
00:26:55,946 --> 00:26:57,320
这实际上就是发生的事情 

518
00:26:57,320 --> 00:27:00,710
你打开它 把它压平 有点像邮票

519
00:27:00,710 --> 00:27:07,670
有效地将材质映射到其上 并映射纹理的UV 

520
00:27:07,670 --> 00:27:12,710
因此纹理的虚拟坐标指向您的3D模型 

521
00:27:12,710 --> 00:27:17,670
所以有没有任何关于这是如何运作的问题

522
00:27:17,670 --> 00:27:22,368
或者关于统一和应用纹理？

523
00:27:22,368 --> 00:27:28,140
观众：你们制作右侧纹理的一般方法是什么

524
00:27:28,140 --> 00:27:32,307
就像是一个被夷为平地的世界？

525
00:27:32,307 --> 00:27:34,640
科尔顿·奥格登：你如何制作右边的纹理？

526
00:27:34,640 --> 00:27:36,640
我的意思是 这本身就是一种艺术形式 

527
00:27:36,640 --> 00:27:42,810
你确实需要用手来做 而且你知道--

528
00:27:42,810 --> 00:27:44,810
我是说 有大量的试验和错误

529
00:27:44,810 --> 00:27:47,360
这一点也会出现在你制作模型的过程中

530
00:27:47,360 --> 00:27:50,240
打开它 注意到 哦 这看起来很奇怪 

531
00:27:50,240 --> 00:27:53,210
当我将这个多边形应用到曲面上时 

532
00:27:53,210 --> 00:27:55,490
我将继续更改这种纹理 

533
00:27:55,490 --> 00:28:00,020
但你可以使用任何--你可以使用Gimp或Photoshop或任何标准

534
00:28:00,020 --> 00:28:02,722
纹理创建软件和Just--

535
00:28:02,722 --> 00:28:05,180
这是一种东西--我不经常做 但它是一种

536
00:28:05,180 --> 00:28:07,388
我想你会随着时间的推移变得更好 

537
00:28:07,388 --> 00:28:12,390
纹理艺术家和造型艺术家可能会开发出类似于

538
00:28:12,390 --> 00:28:17,960
对什么是好的纹理 什么是不好的有一个协调的感觉 

539
00:28:17,960 --> 00:28:23,480
通常 您将首先制作模型 然后再制作纹理 

540
00:28:27,750 --> 00:28:28,400
好的 

541
00:28:28,400 --> 00:28:31,100
所以我们已经谈了一些模特的事情--

542
00:28:31,100 --> 00:28:32,810
抱歉 关于材料的事 

543
00:28:32,810 --> 00:28:35,710
我们会非常简短地再回顾一遍 

544
00:28:35,710 --> 00:28:39,320
有一个我非常喜欢的资源 我

545
00:28:39,320 --> 00:28:42,260
Think在教学方面做得非常好

546
00:28:42,260 --> 00:28:44,190
超越了团结的基础 

547
00:28:44,190 --> 00:28:46,820
这就是Catlikecoding.com 它是完全免费的 

548
00:28:46,820 --> 00:28:51,800
他们只是在那里有一堆免费的文章 非常深入 

549
00:28:51,800 --> 00:28:55,550
这是其中一篇文章的屏幕截图

550
00:28:55,550 --> 00:28:58,880
在那里他们谈论如何制作真正有趣的材料 

551
00:28:58,880 --> 00:29:00,655
所以你可以看到这里 左边的这一张 

552
00:29:00,655 --> 00:29:02,780
它看起来非常--你知道 它看起来像一个火球 

553
00:29:02,780 --> 00:29:05,310
就像它是由岩浆制成的 

554
00:29:05,310 --> 00:29:06,480
上面有凹凸不平的地方 

555
00:29:06,480 --> 00:29:11,482
它有轮廓 你可以看到它上面有一种火焰的光芒 

556
00:29:11,482 --> 00:29:13,190
在右边 你可以看到这个模型

557
00:29:13,190 --> 00:29:16,730
有条件地照亮了它的某些部分 

558
00:29:16,730 --> 00:29:19,960
就像它的金属部分是闪闪发光的 但它的其余部分却不是 

559
00:29:19,960 --> 00:29:22,550
那么 我们如何让这种材料的某些部分闪闪发光呢？

560
00:29:22,550 --> 00:29:24,680
我们如何让它的某些部分变平呢？

561
00:29:24,680 --> 00:29:26,150
这篇文章对此进行了深入的探讨 

562
00:29:26,150 --> 00:29:29,870
实际上 他们所做的就是使用几层地图 

563
00:29:29,870 --> 00:29:36,050
比如光泽度贴图 这是一种纹理 它告诉你--

564
00:29:36,050 --> 00:29:39,500
在您编写的Unity自定义着色器中引用的

565
00:29:39,500 --> 00:29:41,750
这篇文章教你怎么写 

566
00:29:41,750 --> 00:29:46,610
这将使纹理的某些部分和某些部分具有光泽

567
00:29:46,610 --> 00:29:48,744
它没有光泽 所以没有光泽 

568
00:29:48,744 --> 00:29:51,410
所以你可以做很多非常酷、非常有趣的事情 

569
00:29:51,410 --> 00:29:54,450
而Unity的遮阳系统非常--

570
00:29:54,450 --> 00:29:55,790
某种程度上说 天空是极限 

571
00:29:55,790 --> 00:29:59,230
因为它实际上是一种标准的着色器语言 就像你会--

572
00:29:59,230 --> 00:30:02,330
我认为 这实际上与HLSL是一样的 

573
00:30:02,330 --> 00:30:05,100
这是高级着色语言 这是一种--

574
00:30:05,100 --> 00:30:07,850
如果我没记错的话

575
00:30:07,850 --> 00:30:09,920
它最初是由微软提出的 而且它是

576
00:30:09,920 --> 00:30:14,422
非常类似于开放GL着色语言GLSL 

577
00:30:14,422 --> 00:30:16,880
因此 这些实际上只是一些小程序

578
00:30:16,880 --> 00:30:18,171
在你的显卡上运行 

579
00:30:18,171 --> 00:30:19,910
我们以前谈过这个问题 

580
00:30:19,910 --> 00:30:23,540
但它们告诉您的场景如何处理灯光

581
00:30:23,540 --> 00:30:25,520
对于其中的对象 

582
00:30:25,520 --> 00:30:28,610
Unity中的所有东西都有一个与之相关联的着色器 

583
00:30:28,610 --> 00:30:32,555
即使它只是标准着色器 默认情况下只是白色 

584
00:30:32,555 --> 00:30:34,430
但您可以编写自己的着色器 并且

585
00:30:34,430 --> 00:30:37,610
具有几乎无限的可能性 

586
00:30:37,610 --> 00:30:45,020
这实际上是一个着色器 它是一个着色器

587
00:30:45,020 --> 00:30:46,910
这是用代码写的 

588
00:30:46,910 --> 00:30:51,800
但我们有很多这样的变量暴露在我们面前 

589
00:30:51,800 --> 00:30:53,570
反照率就是其中之一 

590
00:30:53,570 --> 00:30:55,310
反照率是有条件的 

591
00:30:55,310 --> 00:31:00,350
如果它将纹理应用到它 它将只渲染该纹理 

592
00:31:00,350 --> 00:31:05,150
但如果您对其应用颜色 它会将该颜色应用于您的材质 

593
00:31:05,150 --> 00:31:07,280
这就是你可以得到 你知道的 纹理

594
00:31:07,280 --> 00:31:09,080
物件与非质感的物件 

595
00:31:09,080 --> 00:31:13,587
金属只计算曲面的光泽度和反射率 

596
00:31:13,587 --> 00:31:15,920
这只是一些写入着色器的东西

597
00:31:15,920 --> 00:31:19,400
并产生负责实现这一目标的照明 

598
00:31:19,400 --> 00:31:22,850
所有这些不同的东西都只是一个着色器的一部分 

599
00:31:22,850 --> 00:31:25,520
材质实际上是着色器 

600
00:31:25,520 --> 00:31:26,870
他们在某种程度上是同一个人 

601
00:31:26,870 --> 00:31:28,703
材料在这一点上有点不同

602
00:31:28,703 --> 00:31:32,760
您还可以指定其曲面应如何与其他对象交互 

603
00:31:32,760 --> 00:31:35,320
举个例子 如果你在冰层上 

604
00:31:35,320 --> 00:31:40,040
一种材料不仅可以看起来像某种东西的光滑、冰冷的外观 

605
00:31:40,040 --> 00:31:43,160
但是 当我走过它的时候 它有多滑？

606
00:31:43,160 --> 00:31:44,070
我应该滑行吗？

607
00:31:44,070 --> 00:31:47,540
还有其他有物理意义的东西应该如何与之相互作用呢？

608
00:31:47,540 --> 00:31:51,620
因此 这两个手拉手是某种程度上的材料 

609
00:31:51,620 --> 00:31:56,390
但很有可能 因为你开始做的唯一真正的事情

610
00:31:56,390 --> 00:31:58,100
你需要考虑的是--

611
00:31:58,100 --> 00:32:00,980
而你只是受到好奇心的束缚--

612
00:32:00,980 --> 00:32:04,610
我们的反照率 可能是金属的 也可能是排放物 

613
00:32:04,610 --> 00:32:07,670
然后取决于你有多大--你的东西有多大

614
00:32:07,670 --> 00:32:10,670
以及你的纹理有多小 可能是瓷砖 

615
00:32:10,670 --> 00:32:13,730
然后回想起上周我们操纵了抵消 

616
00:32:13,730 --> 00:32:16,250
所以偏移量是纹理移动的程度 并调用它

617
00:32:16,250 --> 00:32:19,250
绕回另一边 

618
00:32:19,250 --> 00:32:22,040
因此通过操纵x轴上的偏移量 

619
00:32:22,040 --> 00:32:27,740
我们能够得到无限滚动的纹理 对吗？

620
00:32:27,740 --> 00:32:30,320
所以所有这些东西都有它们的用处 

621
00:32:30,320 --> 00:32:32,810
而且 Unity中的几乎所有东西都有其用途 

622
00:32:32,810 --> 00:32:35,441
这是一个可以使用的非常庞大的工具包 

623
00:32:35,441 --> 00:32:37,940
但这些可能是你将会看到的重要东西 

624
00:32:37,940 --> 00:32:40,340
这篇文章和这个网站上的许多其他文章 

625
00:32:40,340 --> 00:32:43,580
如果你想深入了解Unity 我强烈推荐这本书 

626
00:32:43,580 --> 00:32:48,380
将使您深入了解事物是如何工作的 而不仅仅是表面

627
00:32:48,380 --> 00:32:50,060
拉平那里 

628
00:32:50,060 --> 00:32:51,500
有什么关于材料的问题吗？

629
00:32:54,550 --> 00:32:55,669
好的 

630
00:32:55,669 --> 00:32:57,460
所以我们现在来看看照明 

631
00:32:57,460 --> 00:33:00,890
所以材料是方程式的一部分 

632
00:33:00,890 --> 00:33:04,240
因此 这在某种程度上定义了物体在光线照射时应该是什么样子 

633
00:33:04,240 --> 00:33:08,590
但我们也需要场景中的光本身来照亮事物 

634
00:33:08,590 --> 00:33:12,830
这是摘自另一篇关于渲染的类似猫的编码的文章 

635
00:33:12,830 --> 00:33:15,160
所以这是一个有很多灯光的场景 很多

636
00:33:15,160 --> 00:33:17,470
发光的灯光 发光的灯光 

637
00:33:17,470 --> 00:33:21,130
还有很多事情要做 但这件事

638
00:33:21,130 --> 00:33:24,580
是关于如何理解照明的另一个很棒的系列文章

639
00:33:24,580 --> 00:33:26,010
统一中的模特 

640
00:33:26,010 --> 00:33:27,250
它教会了你很多东西 

641
00:33:27,250 --> 00:33:31,726
它几乎教会了你最基本的成分 

642
00:33:31,726 --> 00:33:34,600
某种程度上 软件和渲染 如果你想深入了解的话 

643
00:33:34,600 --> 00:33:36,840
我当然没有看过每一篇文章

644
00:33:36,840 --> 00:33:39,590
因为有大量的内容 而且非常深刻 

645
00:33:39,590 --> 00:33:44,130
但如果你想真正了解它是如何工作的 

646
00:33:44,130 --> 00:33:46,850
我鼓励你去探索这一点 

647
00:33:46,850 --> 00:33:49,210
因此 我们将介绍几种不同类型的照明 

648
00:33:49,210 --> 00:33:52,230
除了本文讨论的更复杂的事情之外 

649
00:33:52,230 --> 00:33:55,810
我们将介绍不同样式的灯光 您可能会看到

650
00:33:55,810 --> 00:33:58,870
当你刚开始的时候 要经常使用 

651
00:33:58,870 --> 00:34:00,190
所以点光源 

652
00:34:00,190 --> 00:34:05,590
有谁知道基于这张图片的点光源可能是什么？

653
00:34:05,590 --> 00:34:08,259
观众：指的是一个非常具体的方向？

654
00:34:08,259 --> 00:34:10,800
科尔顿·奥格登：它并没有指向一个非常具体的方向 

655
00:34:10,800 --> 00:34:13,760
这实际上是一个聚光灯 

656
00:34:13,760 --> 00:34:19,710
因此 点光源是一种实际射出的光源

657
00:34:19,710 --> 00:34:21,130
在它周围的各个方向 

658
00:34:21,130 --> 00:34:24,540
因此 它向各个方向发光 但在一个有限的区域内 

659
00:34:24,540 --> 00:34:26,880
在特定的强度下 

660
00:34:26,880 --> 00:34:30,000
聚光灯向特定方向照射灯光 

661
00:34:30,000 --> 00:34:31,440
所以只有一个方向 

662
00:34:31,440 --> 00:34:33,989
聚光灯的有趣之处在于 你实际上可以

663
00:34:33,989 --> 00:34:36,330
给他们贴上所谓的曲奇 

664
00:34:36,330 --> 00:34:40,679
曲奇的作用 非常类似于蝙蝠侠之光的作用 

665
00:34:40,679 --> 00:34:43,230
它允许您将纹理应用于灯光

666
00:34:43,230 --> 00:34:46,929
因此投射阴影 特定的阴影 在光上 

667
00:34:46,929 --> 00:34:49,739
因此 如果你想制作类似蝙蝠信号的东西 

668
00:34:49,739 --> 00:34:53,350
你可以把蝙蝠侠图标饼干放在聚光灯下 

669
00:34:53,350 --> 00:34:56,314
这将会带来光明 但蝙蝠侠的标志

670
00:34:56,314 --> 00:34:57,480
都会在这件事的中间 

671
00:34:57,480 --> 00:35:00,990
这实际上就是拿着一个字面意思的聚光灯

672
00:35:00,990 --> 00:35:03,530
然后把一个物体放在上面 

673
00:35:03,530 --> 00:35:04,405
它会产生阴影 

674
00:35:04,405 --> 00:35:05,460
手动阴影 

675
00:35:05,460 --> 00:35:05,910
观众：这叫曲奇吗？

676
00:35:05,910 --> 00:35:07,576
科尔顿·奥格登：是的 这叫曲奇 

677
00:35:10,050 --> 00:35:11,050
平行光 

678
00:35:11,050 --> 00:35:14,070
有人知道平行光是什么吗？

679
00:35:14,070 --> 00:35:18,493
因此 尽管它的名字叫它 但实际上它与聚光灯不是一回事 

680
00:35:22,840 --> 00:35:26,220
所以平行光--实际上 我们上周用的是平行光 

681
00:35:26,220 --> 00:35:27,300
最后一堂课 

682
00:35:27,300 --> 00:35:31,050
平行光向单一方向投射光线 

683
00:35:31,050 --> 00:35:34,530
但在整个场景中 就像是太阳一样 

684
00:35:34,530 --> 00:35:38,220
因此 这使我们能够整体照亮整个场景 

685
00:35:38,220 --> 00:35:41,350
但所有的光都是从一个方向投射的 

686
00:35:41,350 --> 00:35:45,000
因此 如果要在场景中产生日光的外观 

687
00:35:45,000 --> 00:35:49,020
只需一盏平行光就能照亮一切 

688
00:35:49,020 --> 00:35:54,222
然后 最后一种使用较少的东西被称为区域光 

689
00:35:54,222 --> 00:35:56,430
那么有没有人知道--有没有人能猜出

690
00:35:56,430 --> 00:35:58,110
光线是基于这张照片的吗？

691
00:36:03,810 --> 00:36:04,310
是 

692
00:36:04,310 --> 00:36:07,650
观众：只是表面上的光吗？

693
00:36:07,650 --> 00:36:09,990
科尔顿·奥格登：光只存在于表面 

694
00:36:09,990 --> 00:36:11,070
算是吧 是的 

695
00:36:11,070 --> 00:36:13,740
所以它是从表面发出的光

696
00:36:13,740 --> 00:36:21,040
在一个方向上有效地使用特定指定的矩形 

697
00:36:21,040 --> 00:36:24,360
所以你可以定义一个很大的区域 

698
00:36:24,360 --> 00:36:27,870
例如 也许你想在你的游戏中加入一个墙条之类的东西

699
00:36:27,870 --> 00:36:33,694
在墙上专门向左或类似的方向发光 

700
00:36:33,694 --> 00:36:35,360
这就是区域光的能力所在 

701
00:36:35,360 --> 00:36:38,940
现在 区域光在计算上是昂贵的 

702
00:36:38,940 --> 00:36:41,649
因此 只有在烘焙灯光时才能使用它们 

703
00:36:41,649 --> 00:36:44,440
有人记得当提到照明时烘焙是什么意思吗？

704
00:36:47,520 --> 00:36:51,600
所以烘焙照明只是意味着 不是实时照明 

705
00:36:51,600 --> 00:36:56,350
动态计算 光只计算一次

706
00:36:56,350 --> 00:37:01,285
并保存 几乎冻结在场景中的所有对象上 

707
00:37:01,285 --> 00:37:02,910
因此 这是有好处也有坏处的 

708
00:37:02,910 --> 00:37:07,094
我们认为烘焙照明有什么好处呢？

709
00:37:07,094 --> 00:37:09,010
观众：它的计算量较小 

710
00:37:09,010 --> 00:37:10,884
科尔顿·奥格登：计算量较小 

711
00:37:10,884 --> 00:37:15,630
烘焙照明有什么不利之处？

712
00:37:15,630 --> 00:37:17,817
观众：不能受到动态影响 

713
00:37:17,817 --> 00:37:19,650
科尔顿·奥格登：不能受到动态影响 

714
00:37:19,650 --> 00:37:22,190
所以如果你走在一个烘焙的灯光场景中

715
00:37:22,190 --> 00:37:25,340
你希望在某件事上投下阴影 或者为某件事

716
00:37:25,340 --> 00:37:27,860
给你投下阴影 这是不会发生的 

717
00:37:27,860 --> 00:37:29,720
因为环境已经--

718
00:37:29,720 --> 00:37:31,880
该场景的照明已预烘焙 

719
00:37:31,880 --> 00:37:35,510
这几乎就像我们刚刚以一种特定的方式重新描绘了世界 

720
00:37:35,510 --> 00:37:37,970
但我们实际上并没有进行任何照明计算 

721
00:37:37,970 --> 00:37:41,270
但这就是照明在N64时代的工作方式 

722
00:37:41,270 --> 00:37:43,850
这就是它现在在某些情况下仍然起作用的方式 

723
00:37:43,850 --> 00:37:46,790
如果你知道什么都不会给某事蒙上阴影 

724
00:37:46,790 --> 00:37:50,270
您可以为场景制作非常漂亮的灯光

725
00:37:50,270 --> 00:37:53,110
而不需要实时进行 

726
00:37:53,110 --> 00:37:55,250
你可以直接烤它 对吗？

727
00:37:55,250 --> 00:37:57,290
所以这些是不同类型的灯 

728
00:37:57,290 --> 00:37:59,480
所以我们可以看到 在统一组织中--

729
00:37:59,480 --> 00:38:01,940
所以如果我们走到这里 

730
00:38:01,940 --> 00:38:05,270
我要--现在我们有一个平行光 

731
00:38:05,270 --> 00:38:07,700
所以这个平行光就是这个物体 

732
00:38:07,700 --> 00:38:11,640
默认情况下 所有--你可以想放大多少就放大多少 

733
00:38:11,640 --> 00:38:13,290
但这有点像--

734
00:38:13,290 --> 00:38:16,140
哦 又来了 

735
00:38:16,140 --> 00:38:21,270
这种平行光只朝一个方向照射 

736
00:38:21,270 --> 00:38:22,220
这样我就可以把它搬到这里来 

737
00:38:22,220 --> 00:38:24,905
所以目前我在--

738
00:38:24,905 --> 00:38:27,470
导航有点奇怪 只是

739
00:38:27,470 --> 00:38:29,490
因为它被稍微旋转了一下 

740
00:38:29,490 --> 00:38:31,790
考虑到它是平行光 它的自转--

741
00:38:34,620 --> 00:38:36,210
所以请注意它是如何变化的 

742
00:38:36,210 --> 00:38:39,014
所以如果我把它往上照 注意到所有的东西都变黑了

743
00:38:39,014 --> 00:38:41,180
因为灯光只是向上照射 对吗？

744
00:38:41,180 --> 00:38:43,710
所以它就好像是从下面来的 

745
00:38:43,710 --> 00:38:46,700
如果我把它照向那里 注意到灯光

746
00:38:46,700 --> 00:38:51,680
在球体和小立方体上有一些变化 对吗？

747
00:38:51,680 --> 00:38:55,190
因为它们会受到光线方向的影响 

748
00:38:55,190 --> 00:38:57,230
但他们都受到了完全相同的影响 

749
00:38:57,230 --> 00:38:59,155
因为平行光无处不在 

750
00:38:59,155 --> 00:39:00,530
它贯穿了整个场景 

751
00:39:00,530 --> 00:39:02,330
它是一个全球性的物体 

752
00:39:02,330 --> 00:39:05,250
现在如果我删除平行光--

753
00:39:05,250 --> 00:39:07,380
注意现在没有光 所以这些东西只是

754
00:39:07,380 --> 00:39:10,160
看起来就像是静态阴影 

755
00:39:10,160 --> 00:39:12,290
你可以添加一个新的光线--

756
00:39:12,290 --> 00:39:15,759
如果你右击你的游戏对象视图 然后你走到这里 

757
00:39:15,759 --> 00:39:18,300
你可以看到我们有我们说过的所有不同的灯 

758
00:39:18,300 --> 00:39:20,910
还有一些东西叫做反射探头和光探针组 

759
00:39:20,910 --> 00:39:22,743
而这些都稍微复杂了一点 

760
00:39:22,743 --> 00:39:26,750
但这些可以让你有效地获得伪实时照明

761
00:39:26,750 --> 00:39:30,185
以及带有烘焙灯光和反射的反射 

762
00:39:30,185 --> 00:39:32,060
在今天的课程中 我们不会讨论这些问题 

763
00:39:32,060 --> 00:39:34,900
但这里有一个点光源 例如 

764
00:39:34,900 --> 00:39:36,800
那么 让我想想 它在哪里？

765
00:39:36,800 --> 00:39:37,820
就在这里 

766
00:39:37,820 --> 00:39:40,820
所以我要把它移到这里 

767
00:39:40,820 --> 00:39:46,002
所以你可以看到它不像平行光那样是全局的 对吗？

768
00:39:46,002 --> 00:39:49,210
它只会影响到这个非常有限的部分--我要把它放大一点

769
00:39:49,210 --> 00:39:50,668
这样你就能看得更清楚一点 

770
00:39:50,668 --> 00:39:53,564
但它只是影响了这两个物体

771
00:39:53,564 --> 00:39:54,980
相对于它所在的位置 

772
00:39:57,520 --> 00:40:00,455
因此 这对于场景中的灯之类的东西非常有效 

773
00:40:00,455 --> 00:40:03,080
如果你想要路灯 或者你想要

774
00:40:03,080 --> 00:40:05,270
也许就像房子里着火了一样 

775
00:40:05,270 --> 00:40:08,760
或者 如果你想要我们已经拥有的能量--

776
00:40:08,760 --> 00:40:12,840
或者是我们在《团结》里的那辆皮卡 对吧？

777
00:40:12,840 --> 00:40:14,750
我们只有--

778
00:40:14,750 --> 00:40:21,210
它只是在一个非常小的半径内发出紫色的光 

779
00:40:21,210 --> 00:40:25,250
请注意 这里我们可以更改灯光的颜色 

780
00:40:25,250 --> 00:40:26,810
所以如果我这样做的话--

781
00:40:31,540 --> 00:40:37,010
这就对了--所以我就这么做 

782
00:40:37,010 --> 00:40:39,470
所以请注意 现在它发出了紫色的光 

783
00:40:39,470 --> 00:40:41,379
所以你可以随心所欲地给灯光上色

784
00:40:41,379 --> 00:40:42,920
来产生你想要的任何效果 

785
00:40:42,920 --> 00:40:45,100
所以火不会发出白光 

786
00:40:45,100 --> 00:40:47,740
它很可能会像橙色红光一样发出 

787
00:40:47,740 --> 00:40:51,352
街灯可能会发出一种黄色的橙色光 

788
00:40:51,352 --> 00:40:54,560
所以取决于你的场景是什么样子以及你想要模仿的是什么 

789
00:40:54,560 --> 00:40:59,405
只需使用这些非常简单的对象 您就可以完成几乎任何事情 

790
00:40:59,405 --> 00:41:02,180
所以我要去掉点光源 

791
00:41:02,180 --> 00:41:05,390
然后我要创造一个聚光灯 

792
00:41:05,390 --> 00:41:08,630
我不会仅仅因为需要烘焙而创建区域光

793
00:41:08,630 --> 00:41:10,010
场景中的灯光 

794
00:41:10,010 --> 00:41:12,843
但我将创建一个聚光灯 以便我们可以看到它是什么样子的 

795
00:41:15,282 --> 00:41:16,490
把它放在正确的位置 

796
00:41:22,400 --> 00:41:27,400
有时候 想要弄清楚自己的确切位置可能有点困难 

797
00:41:27,400 --> 00:41:30,685
好了 快到了 

798
00:41:30,685 --> 00:41:31,950
我们走吧 

799
00:41:31,950 --> 00:41:33,540
完美无缺 

800
00:41:33,540 --> 00:41:37,229
所以这里的这个小聚光灯是由我们的物体产生的 

801
00:41:37,229 --> 00:41:38,770
所以你可以看到我们可以移动它 

802
00:41:38,770 --> 00:41:41,430
然后 如果我们想要的话 我们也可以在它上面应用一个cookie 

803
00:41:41,430 --> 00:41:42,190
就在这里 

804
00:41:42,190 --> 00:41:46,080
所以在你的--如果你在聚光灯下 你想要给它应用一个纹理 

805
00:41:46,080 --> 00:41:47,980
就这块小饼干--

806
00:41:47,980 --> 00:41:49,230
它只需要一种质地 

807
00:41:49,230 --> 00:41:51,630
所以无论你想要什么形象 

808
00:41:51,630 --> 00:41:56,220
如果你要创造一种曲奇纹理 白色意味着全光和全黑

809
00:41:56,220 --> 00:41:58,112
意思是全阴影 

810
00:41:58,112 --> 00:41:59,820
所以你可以把它变成一个灰度图像 

811
00:41:59,820 --> 00:42:02,680
你可以让它在白色和黑色之间的任何地方 

812
00:42:02,680 --> 00:42:05,520
这会让你产生一些有趣的效果 

813
00:42:05,520 --> 00:42:07,530
例如 手册中的--

814
00:42:10,230 --> 00:42:11,370
它不在这里 

815
00:42:11,370 --> 00:42:13,470
我在这里没有包括图片 但手册

816
00:42:13,470 --> 00:42:17,340
显示有一种类似于你放在展台上的灯 

817
00:42:17,340 --> 00:42:19,590
他们有一堆LED 对吧？

818
00:42:19,590 --> 00:42:22,470
它们就像是在一个网格中 它们发出聚光灯 

819
00:42:22,470 --> 00:42:25,800
你可以用这些网格线创建一个类似于灰度的曲奇 

820
00:42:25,800 --> 00:42:28,020
它会将光线照射到场景中 就好像它是

821
00:42:28,020 --> 00:42:32,910
从LED的栅格中进行广播 

822
00:42:32,910 --> 00:42:36,240
因此 只要有一些非常简单的想法 你就可以做很多事情 

823
00:42:36,240 --> 00:42:39,610
这些都是我们可以使用的照明类型 

824
00:42:39,610 --> 00:42:42,790
在今天的课程中 我们只使用了点光源 

825
00:42:42,790 --> 00:42:46,900
在上一节课中 我们使用了平行光 

826
00:42:46,900 --> 00:42:51,330
和聚光灯 例如 您可以通过编程

827
00:42:51,330 --> 00:42:54,190
例如 更改聚光灯的旋转 

828
00:42:54,190 --> 00:42:57,960
如果你想在你的场景中有一个摆动的聚光灯来照亮

829
00:42:57,960 --> 00:42:59,490
一些墙壁或表面 

830
00:42:59,490 --> 00:43:01,900
你可以用它做很多很酷的事情 

831
00:43:01,900 --> 00:43:04,750
这些是Unity中的核心灯光类型 

832
00:43:04,750 --> 00:43:08,846
有没有人对它们的用途有任何疑问 

833
00:43:08,846 --> 00:43:10,988
观众：对于定向光 

834
00:43:10,988 --> 00:43:12,660
它的位置还是它面对的方向

835
00:43:12,660 --> 00:43:14,430
科尔顿·奥格登：这并不重要--所以对于定向光 

836
00:43:14,430 --> 00:43:15,660
放在哪里并不重要

837
00:43:15,660 --> 00:43:17,451
你可以把它放在场景中的任何地方

838
00:43:17,451 --> 00:43:19,540
00或更远的地方--

839
00:43:19,540 --> 00:43:23,100
整个场景都会有同样的效果

840
00:43:23,100 --> 00:43:25,850
还有问题吗

841
00:43:25,850 --> 00:43:27,030
好的.

842
00:43:27,030 --> 00:43:27,630
酷酷

843
00:43:27,630 --> 00:43:29,180
所以那些是光 

844
00:43:29,180 --> 00:43:31,050
凹凸贴图 我们会简单讨论一下 

845
00:43:31,050 --> 00:43:32,580
所以凹凸贴图

846
00:43:32,580 --> 00:43:36,000
我们确实在游戏中用到了这个 

847
00:43:36,000 --> 00:43:39,750
凹凸贴图实际上是--所以你在左边看到的

848
00:43:39,750 --> 00:43:41,820
是真实的3D场景

849
00:43:41,820 --> 00:43:44,810
这些是实时着色的实际模型 

850
00:43:44,810 --> 00:43:48,690
或者 不是实时的 但它们实际上是被照亮的真实模型 

851
00:43:48,690 --> 00:43:52,510
在中间 我们可以看到所谓的凹凸贴图 在右边 

852
00:43:52,510 --> 00:43:56,240
我们可以看到一个--那只是一个公寓--

853
00:43:56,240 --> 00:43:58,020
就像平面一样 

854
00:43:58,020 --> 00:44:01,090
用一个凹凸贴图--用同样的凹凸贴图--应用到它 

855
00:44:01,090 --> 00:44:02,590
然后被照亮 

856
00:44:02,590 --> 00:44:08,970
所以凹凸贴图允许我们做的是取一个平坦的墙或平面

857
00:44:08,970 --> 00:44:14,820
或者任何你想要的东西 然后模拟一个真实的三维轮廓 

858
00:44:14,820 --> 00:44:18,540
三维的凸起 或者任何你想要的东西

859
00:44:18,540 --> 00:44:22,740
而不需要创建实际的几何形状来使其成为可能 

860
00:44:22,740 --> 00:44:25,240
所以有不同的工具可以让

861
00:44:25,240 --> 00:44:28,050
创建凹凸贴图对象--

862
00:44:28,050 --> 00:44:29,220
或凹凸贴图纹理 

863
00:44:29,220 --> 00:44:33,060
通常3D包会有这些 所以你可以创建它们 

864
00:44:33,060 --> 00:44:34,930
或其他软件 

865
00:44:34,930 --> 00:44:38,580
但它们实际上只是

866
00:44:38,580 --> 00:44:41,130
曲面法线的一部分

867
00:44:41,130 --> 00:44:50,130
一个向量从多边形的外部 到给定的点 

868
00:44:50,130 --> 00:44:53,130
他们告诉联合照明系统 

869
00:44:53,130 --> 00:44:59,640
假装好像真的有几何体指向那个方向

870
00:44:59,640 --> 00:45:00,990
当你计算它的时候 

871
00:45:00,990 --> 00:45:04,310
因此 即使它不会扭曲几何图形 

872
00:45:04,310 --> 00:45:06,150
就像 这仍然是完全平坦的 

873
00:45:06,150 --> 00:45:12,730
灯光让人觉得几何体是一种 你知道的 轮廓 

874
00:45:12,730 --> 00:45:15,360
因此 它允许我们创造--

875
00:45:15,360 --> 00:45:17,730
这是一个玩具的例子 但它实际上

876
00:45:17,730 --> 00:45:20,900
与此相关的墙有--

877
00:45:20,900 --> 00:45:23,760
我们上周对此进行了报道 只是没有那么详细 

878
00:45:23,760 --> 00:45:25,860
但是你想要变平的墙和你

879
00:45:25,860 --> 00:45:28,485
不想有太多的多边形 你可以创建一个凹凸

880
00:45:28,485 --> 00:45:30,369
为凹凸贴图贴图并应用该凹凸贴图 

881
00:45:30,369 --> 00:45:32,910
然后当你渲染它的时候 当你走过一堵墙时 

882
00:45:32,910 --> 00:45:36,600
它看起来就像墙实际上有裂缝和凹凸不平的地方 

883
00:45:36,600 --> 00:45:37,890
以获得逼真的效果 

884
00:45:37,890 --> 00:45:40,140
而这在游戏中也有轻微的使用 

885
00:45:40,140 --> 00:45:41,820
如果你想的话 你可以把它调高 

886
00:45:41,820 --> 00:45:45,300
我没有在我的电脑上 因为我的规格不够 

887
00:45:45,300 --> 00:45:49,990
但今天示例中的每个纹理都有一个与之关联的凹凸贴图 

888
00:45:49,990 --> 00:46:01,920
因此 您可以实际看到凹凸贴图在不同使用程度下的效果 

889
00:46:01,920 --> 00:46:03,770
这里的材料--我要去--

890
00:46:03,770 --> 00:46:09,850
我要加载包含实际素材的场景 

891
00:46:13,100 --> 00:46:16,340
我要--事实上 我不需要加载场景 

892
00:46:16,340 --> 00:46:18,350
我所要做的就是去找材料 

893
00:46:18,350 --> 00:46:20,630
比如地板 

894
00:46:20,630 --> 00:46:21,830
楼层在哪里？

895
00:46:21,830 --> 00:46:23,520
就在这里 

896
00:46:23,520 --> 00:46:26,000
请注意 在前面 我们讨论了反照率 

897
00:46:26,000 --> 00:46:27,740
然后我还提到了法线贴图 

898
00:46:27,740 --> 00:46:30,020
所以就在这里 你真正需要做的就是

899
00:46:30,020 --> 00:46:32,660
为了让Unity检测法线贴图--这只是

900
00:46:32,660 --> 00:46:34,160
标准着色器的一部分 

901
00:46:34,160 --> 00:46:38,480
顺便说一句 法线贴图和凹凸贴图实际上是同义词 

902
00:46:38,480 --> 00:46:42,740
只需拖动法线贴图纹理即可

903
00:46:42,740 --> 00:46:45,020
进入这片田野 这个小广场 

904
00:46:45,020 --> 00:46:47,600
然后给它一个应用法线贴图的度数 

905
00:46:47,600 --> 00:46:51,260
所以如果你看这里 你可能会看到--

906
00:46:51,260 --> 00:46:52,270
我不记得了 

907
00:46:52,270 --> 00:46:56,090
是的 我们可以看到它是如何改变质地的 对吗？

908
00:46:56,090 --> 00:47:02,000
因此 在零值时 根本不会发生法线贴图 

909
00:47:02,000 --> 00:47:04,190
这种质地是完全平坦的 就好像我们

910
00:47:04,190 --> 00:47:07,850
仅执行了常规的将纹理应用于球体 

911
00:47:07,850 --> 00:47:11,980
但是我们应用法线映射的程度--所以请注意 在第一次 

912
00:47:11,980 --> 00:47:15,830
它看起来很逼真 就像我们得到了一种石质纹理 

913
00:47:15,830 --> 00:47:21,860
我们走得越多 它看起来就越夸张 对吗？

914
00:47:21,860 --> 00:47:25,400
你可以继续这样做 最终它会

915
00:47:25,400 --> 00:47:26,660
看起来真的很扭曲 

916
00:47:26,660 --> 00:47:28,535
但这让你--

917
00:47:28,535 --> 00:47:30,410
这取决于你的电脑有多强大 

918
00:47:30,410 --> 00:47:32,750
你可以更高或更低--

919
00:47:32,750 --> 00:47:36,380
影响到多大的颠簸--

920
00:47:36,380 --> 00:47:40,610
凹凸贴图、法线贴图对照明渲染的影响程度 

921
00:47:40,610 --> 00:47:45,410
所以很容易就能得到一个相当 有点 

922
00:47:45,410 --> 00:47:47,360
在你的场景中有额外的现实感 

923
00:47:47,360 --> 00:47:49,610
所以你会注意到 如果你走在现场 

924
00:47:49,610 --> 00:47:51,710
如果你关掉灯光 就更容易看到

925
00:47:51,710 --> 00:47:55,220
所有的表面、地板、天花板和墙壁

926
00:47:55,220 --> 00:47:59,820
拥有凹凸贴图和纹理贴图 

927
00:47:59,820 --> 00:48:04,190
这是--如果你想知道这些奇怪的颜色纹理是什么 

928
00:48:04,190 --> 00:48:10,520
曲面法线及其排列的RGB或XYZ 

929
00:48:10,520 --> 00:48:12,410
这就是它是如何被编码成这个的 

930
00:48:12,410 --> 00:48:13,910
你经常可以看到--

931
00:48:13,910 --> 00:48:16,850
如果你看到的是凹凸贴图和纹理贴图--

932
00:48:16,850 --> 00:48:19,789
你们可以一起看 就像 哦 好的 这是有意义的 

933
00:48:19,789 --> 00:48:21,830
我预计会更颠簸或会做的部分

934
00:48:21,830 --> 00:48:26,810
与它们在实际凹凸贴图纹理上的外观相关 

935
00:48:26,810 --> 00:48:27,910
你可以在这里看到它 

936
00:48:27,910 --> 00:48:31,790
凹凸贴图中所有凹凸不平或有轮廓的东西都非常明显 

937
00:48:31,790 --> 00:48:35,210
这只是数据编码方式的本质 

938
00:48:35,210 --> 00:48:38,424
所以任何关于凹凸贴图如何工作或它们是什么的问题

939
00:48:38,424 --> 00:48:39,590
或者如何在Unity中使用它们？

940
00:48:42,800 --> 00:48:43,640
好的 

941
00:48:43,640 --> 00:48:44,360
凉爽的 

942
00:48:44,360 --> 00:48:46,568
所以现在我们要开始得到一点

943
00:48:46,568 --> 00:48:50,600
这一切是如何在我们的游戏迷宫中结合在一起的 

944
00:48:50,600 --> 00:48:53,150
我们会讨论迷宫的生成 

945
00:48:53,150 --> 00:48:58,910
我就从这里开始 

946
00:48:58,910 --> 00:49:02,330
所以我在真实的游戏场景中 

947
00:49:02,330 --> 00:49:04,850
所以在场景中 我像以前一样加载播放 

948
00:49:04,850 --> 00:49:06,366
我要按播放键了

949
00:49:06,366 --> 00:49:08,907
我要关掉我的声音 因为那令人毛骨悚然的声音

950
00:49:08,907 --> 00:49:12,712
过一段时间会有点迷失方向

951
00:49:12,712 --> 00:49:13,670
然后我要...

952
00:49:16,220 --> 00:49:18,930
实际上 我打算去一个2乘3的视图 

953
00:49:21,470 --> 00:49:24,620
然后点击播放 

954
00:49:24,620 --> 00:49:28,670
所以我们在下面有一个常规的游戏视图 

955
00:49:28,670 --> 00:49:34,800
然后 如果我缩小 你可以看到我们的场景之前是空的 

956
00:49:34,800 --> 00:49:36,050
但现在我们有个迷宫

957
00:49:36,050 --> 00:49:40,770
目前它还不是很明显 

958
00:49:40,770 --> 00:49:42,890
我们要用雾对吧

959
00:49:42,890 --> 00:49:45,860
而回忆雾让我们能够有效地为

960
00:49:45,860 --> 00:49:48,790
到离我们更远的物体 

961
00:49:48,790 --> 00:49:51,850
第二我们的屋顶上有天花板

962
00:49:51,850 --> 00:49:53,580
在我们的迷宫上盖个屋顶

963
00:49:53,580 --> 00:49:57,530
所以它实际上挡住了迷宫的样子 

964
00:49:57,530 --> 00:50:00,380
所以我们可以很容易地做一些改变

965
00:50:00,380 --> 00:50:03,660
为了更好地观察我们的迷宫

966
00:50:03,660 --> 00:50:06,520
所以我要去窗口 我要去灯光 设置 

967
00:50:06,520 --> 00:50:08,930
所以如果你去窗口 灯光 设置 

968
00:50:08,930 --> 00:50:12,750
这些是全局Unity照明设置 

969
00:50:12,750 --> 00:50:15,650
你可以设置你的天空盒 你可以设置环境照明 

970
00:50:15,650 --> 00:50:19,130
你可以设置像雾这样的东西 你可以选择如何烘烤东西 

971
00:50:19,130 --> 00:50:21,300
这里有很多东西

972
00:50:21,300 --> 00:50:22,850
我们不会涵盖几乎所有的 

973
00:50:22,850 --> 00:50:25,070
我们将涵盖其中的一些 

974
00:50:25,070 --> 00:50:26,884
环境照明是一个大问题 

975
00:50:26,884 --> 00:50:29,300
这就是我们在这个游戏中如何照亮场景 

976
00:50:29,300 --> 00:50:32,140
所以所有的灯光

977
00:50:32,140 --> 00:50:35,077
那么所有的照明都是环境照明 

978
00:50:35,077 --> 00:50:36,160
我们就是这么做的 

979
00:50:36,160 --> 00:50:37,380
我们要用颜色来做 

980
00:50:37,380 --> 00:50:40,640
因此 请注意 您可以选择天空框 渐变和颜色 

981
00:50:40,640 --> 00:50:45,650
所以如果你选择天空盒环境 灯光 它会有一种--

982
00:50:45,650 --> 00:50:48,440
它看起来会有点像我们这里的这个天空盒子 

983
00:50:48,440 --> 00:50:50,980
这个在很远的地方 看起来是蓝色的 

984
00:50:50,980 --> 00:50:52,470
更自然一点 

985
00:50:52,470 --> 00:50:54,860
但我没有--但当它应用到我们的场景时 

986
00:50:54,860 --> 00:50:58,590
它看起来和我们想要的不太一样 

987
00:50:58,590 --> 00:51:00,860
所以我们选择的只是颜色 

988
00:51:00,860 --> 00:51:04,190
我选择了这种墨绿色的棕色调 

989
00:51:04,190 --> 00:51:06,620
这就给了我想要的结果 

990
00:51:06,620 --> 00:51:08,630
但是你可以把它做成任何你想要的颜色 

991
00:51:08,630 --> 00:51:11,000
我们可以把这个做成某种鲜艳的黄色 

992
00:51:11,000 --> 00:51:12,958
我不知道这会是什么样子 

993
00:51:12,958 --> 00:51:15,460
这可能会看起来很可怕 但是--

994
00:51:15,460 --> 00:51:16,340
是啊 

995
00:51:16,340 --> 00:51:17,990
我是说 实际上 这...

996
00:51:17,990 --> 00:51:21,030
以一种奇怪的方式这种看起来很有趣 

997
00:51:21,030 --> 00:51:25,160
事实上 它看起来比我所做的更接近最初的恐怖大厅游戏 

998
00:51:25,160 --> 00:51:26,427
但这并不是很可怕 

999
00:51:26,427 --> 00:51:28,010
看起来我们就像在金字塔里 

1000
00:51:30,560 --> 00:51:33,290
那就是--我能回去吗？

1001
00:51:33,290 --> 00:51:33,910
不是的 

1002
00:51:33,910 --> 00:51:34,410
好的 

1003
00:51:34,410 --> 00:51:37,960
好吧 我把颜色搞砸了 

1004
00:51:37,960 --> 00:51:41,100
现在我想知道我以前是什么颜色的 

1005
00:51:41,100 --> 00:51:43,110
它就像一种难看的绿色 

1006
00:51:43,110 --> 00:51:44,950
就像这样 

1007
00:51:44,950 --> 00:51:47,360
这可能已经足够好了 

1008
00:51:47,360 --> 00:51:47,900
好的 

1009
00:51:47,900 --> 00:51:48,930
差不多是这样 

1010
00:51:48,930 --> 00:51:54,147
所以我们再玩一次 我们可以看到我们又回到了令人讨厌的深色 

1011
00:51:54,147 --> 00:51:55,480
但那是环境照明 

1012
00:51:55,480 --> 00:51:59,101
因此 它应用了一种照明 统一 只是氛围 

1013
00:51:59,101 --> 00:52:01,850
有点像平行光 但它没有方向 

1014
00:52:01,850 --> 00:52:08,990
它只适用于场景中给定强度的所有内容 

1015
00:52:08,990 --> 00:52:12,320
这就是我们如何照亮我们的场景 

1016
00:52:12,320 --> 00:52:13,220
就这么简单 

1017
00:52:13,220 --> 00:52:16,640
只有场景中的环境照明和我们的照明场景窗口 

1018
00:52:16,640 --> 00:52:20,300
现在 这里另一件重要的事情是雾 

1019
00:52:20,300 --> 00:52:22,370
所以雾是很容易的--

1020
00:52:22,370 --> 00:52:25,610
几乎和点击这里的这个按钮一样简单 上面写着雾 

1021
00:52:25,610 --> 00:52:27,770
然后可能会为它选择一种颜色 

1022
00:52:27,770 --> 00:52:31,010
您可以选择密度 因此很明显 如果是密度较高的雾

1023
00:52:31,010 --> 00:52:33,320
它会让你看起来像是在一个雾气更大的地方 

1024
00:52:33,320 --> 00:52:37,040
它会把颜色加到离你更近的东西上

1025
00:52:37,040 --> 00:52:40,460
比具有较低密度雾时的速度更快 

1026
00:52:40,460 --> 00:52:43,949
这里还有其他一些功能 其中一些

1027
00:52:43,949 --> 00:52:45,240
我不是很熟悉 

1028
00:52:45,240 --> 00:52:48,320
但就今天的例子而言 只是点击一下--

1029
00:52:48,320 --> 00:52:49,880
确保选择了雾 

1030
00:52:49,880 --> 00:52:52,620
然后单击 确保您的雾具有正确的颜色 

1031
00:52:52,620 --> 00:52:55,700
所以如果你的雾是可笑的红色 

1032
00:52:55,700 --> 00:52:59,030
它可能会看起来很奇怪 

1033
00:52:59,030 --> 00:53:00,406
是啊 

1034
00:53:00,406 --> 00:53:02,780
但你可以看到你可以做各种奇怪的效果

1035
00:53:02,780 --> 00:53:04,335
只要把这些东西加在一起 

1036
00:53:04,335 --> 00:53:07,210
就像 如果你想要有某种效果 就像--

1037
00:53:07,210 --> 00:53:10,790
我不知道 有毒的异国他乡 也许你想要一片紫雾

1038
00:53:10,790 --> 00:53:13,780
而不是像深绿色的雾之类的 

1039
00:53:13,780 --> 00:53:15,400
这太简单了 

1040
00:53:15,400 --> 00:53:19,290
通过这种方式 你会产生很多非常基本但有效的效果 

1041
00:53:19,290 --> 00:53:22,926
让我找找--我想它就是那种令人讨厌的绿色 

1042
00:53:22,926 --> 00:53:24,800
观众：你是怎么让这个屏幕再次出现的？

1043
00:53:24,800 --> 00:53:26,066
上面写着闪电的那个？

1044
00:53:26,066 --> 00:53:28,940
科尔顿·奥格登：要调出这个照明屏 你需要做的就是

1045
00:53:28,940 --> 00:53:29,920
就是 如果你用的是Mac--

1046
00:53:29,920 --> 00:53:31,190
我认为在Windows中也是一样的--有

1047
00:53:31,190 --> 00:53:33,230
顶部菜单中的窗口选项 

1048
00:53:33,230 --> 00:53:37,730
窗口 然后是照明 然后是设置 

1049
00:53:37,730 --> 00:53:41,100
因此 这将带您了解至少与以下内容相关的所有设置

1050
00:53:41,100 --> 00:53:42,766
今天的例子 

1051
00:53:42,766 --> 00:53:45,020
所以我们在场景中没有使用任何灯光

1052
00:53:45,020 --> 00:53:50,490
我们之前谈到的 至少对于场景本身的照明来说 

1053
00:53:50,490 --> 00:53:55,020
现在 有点光源被用于皮卡 

1054
00:53:55,020 --> 00:53:57,430
我马上就给你们展示一下 

1055
00:53:57,430 --> 00:54:02,460
但我想要说明的是我们如何看待我们的迷宫

1056
00:54:02,460 --> 00:54:03,880
在它被生成之后 

1057
00:54:03,880 --> 00:54:05,700
所以我们首先要做的是--

1058
00:54:05,700 --> 00:54:10,490
请注意 在此之前 我们在远处看不到迷宫

1059
00:54:10,490 --> 00:54:12,990
因为因为有雾 它是纯深绿色的 

1060
00:54:12,990 --> 00:54:18,870
它给那个几何图形增加了绿色 因为它离我们太远了 

1061
00:54:18,870 --> 00:54:20,645
所以我现在要禁用雾 

1062
00:54:20,645 --> 00:54:23,186
它实际上会记住你的设置 这是一种不错的选择 

1063
00:54:23,186 --> 00:54:25,950
所以只需禁用雾即可 

1064
00:54:25,950 --> 00:54:30,600
我要在场景中添加一个平行光 

1065
00:54:30,600 --> 00:54:33,619
所以我要在这里加一个平行光 

1066
00:54:33,619 --> 00:54:35,160
然后我要再按一次播放 

1067
00:54:38,130 --> 00:54:42,165
现在 我们的场景被点亮了 

1068
00:54:44,910 --> 00:54:49,960
而且 你知道 它看起来很不同 不那么可怕 

1069
00:54:49,960 --> 00:54:52,040
我们可以更清楚地看到我们的迷宫 

1070
00:54:52,040 --> 00:54:57,930
我们实际上可以看到它是块的集合 

1071
00:54:57,930 --> 00:54:59,160
它是瓷砖砌成的 

1072
00:54:59,160 --> 00:55:02,880
现在 我们看不到迷宫 因为迷宫有屋顶 

1073
00:55:02,880 --> 00:55:04,980
所以我所做的就是做了一个生成的屋顶 

1074
00:55:04,980 --> 00:55:10,170
脚本中的一个选项 因此如果您取消选择该选项 然后我们重试 

1075
00:55:10,170 --> 00:55:11,830
现在我们可以看到我们的迷宫了 

1076
00:55:11,830 --> 00:55:14,029
这就是我们的迷宫的样子 

1077
00:55:14,029 --> 00:55:16,320
所以关于团结的酷的事情 我真的很喜欢 

1078
00:55:16,320 --> 00:55:19,540
仅仅是这种通过场景观看的能力是独立的

1079
00:55:19,540 --> 00:55:22,500
的实际游戏 只是为了帮助调试 

1080
00:55:22,500 --> 00:55:26,550
很难知道您是否正确地生成了迷宫

1081
00:55:26,550 --> 00:55:27,800
当你在3D中创建它的时候 

1082
00:55:27,800 --> 00:55:29,940
你知道 在2D中 你可以很容易地看到它 

1083
00:55:29,940 --> 00:55:33,910
但在3D游戏中 尤其是在第一人称游戏中 你看不到它 

1084
00:55:33,910 --> 00:55:37,110
所以能够像这样分割你的视野--场景和游戏--

1085
00:55:37,110 --> 00:55:41,400
实际上看到 哦 我的算法在起作用 或者它不起作用 

1086
00:55:41,400 --> 00:55:43,120
超级有帮助 

1087
00:55:43,120 --> 00:55:47,240
所以我们可以看到它正在为我们雕刻一个迷宫 

1088
00:55:47,240 --> 00:55:48,450
它看起来有点奇怪 

1089
00:55:48,450 --> 00:55:53,730
这不是一个传统的迷宫 因为它有经典的迷宫

1090
00:55:53,730 --> 00:55:54,870
对它进行整形 

1091
00:55:54,870 --> 00:55:58,830
但它实际上起到了迷宫的作用 而且工作得很好

1092
00:55:58,830 --> 00:56:01,530
为了它的预期目的 

1093
00:56:01,530 --> 00:56:05,680
算法非常简单 我们将会讨论这一点 

1094
00:56:05,680 --> 00:56:07,440
这就是我们的迷宫 

1095
00:56:07,440 --> 00:56:10,320
我将继续并还原所有--

1096
00:56:10,320 --> 00:56:13,610
我想如果我重新加载场景 它应该会恢复原状 

1097
00:56:13,610 --> 00:56:14,110
不要存钱 

1098
00:56:14,110 --> 00:56:14,730
是啊 

1099
00:56:14,730 --> 00:56:17,521
好的 一切都恢复了 所有的灯光和一切都恢复了 

1100
00:56:17,521 --> 00:56:19,770
我去做个心理检查 确保 

1101
00:56:19,770 --> 00:56:20,610
是啊 

1102
00:56:20,610 --> 00:56:23,250
一切都运转得很好 

1103
00:56:23,250 --> 00:56:27,960
所以有没有人知道到哪里去

1104
00:56:27,960 --> 00:56:32,500
如果我们要实施3D迷宫就开始了？

1105
00:56:32,500 --> 00:56:34,490
观众：我以前做过一次是

1106
00:56:34,490 --> 00:56:40,760
你把一堆x放在你想要在数组中画东西的地方 

1107
00:56:40,760 --> 00:56:47,270
然后循环遍历数组并绘制、实例化墙壁 

1108
00:56:47,270 --> 00:56:48,020
科尔顿·奥格登：是的 

1109
00:56:48,020 --> 00:56:50,190
因此 创建一个数组 

1110
00:56:50,190 --> 00:56:53,870
在你想要的地方填上x--

1111
00:56:53,870 --> 00:56:56,081
无论您想要实例化什么数据 

1112
00:56:56,081 --> 00:56:57,830
然后循环并实例化所有内容 

1113
00:56:57,830 --> 00:57:00,830
这就是它的工作原理 

1114
00:57:00,830 --> 00:57:04,250
现在 从创造迷宫的角度来看 

1115
00:57:04,250 --> 00:57:06,110
你有没有什么想法--

1116
00:57:06,110 --> 00:57:09,940
您将如何着手实现一个简单的迷宫生成器？

1117
00:57:09,940 --> 00:57:13,415
显然 有非常复杂的迷宫生成算法 

1118
00:57:13,415 --> 00:57:17,747
所以没什么特别花哨的 只是一个简单的--

1119
00:57:17,747 --> 00:57:18,830
你会怎么做一个迷宫？

1120
00:57:18,830 --> 00:57:19,891
观众：所以这是随机的？

1121
00:57:19,891 --> 00:57:20,390
或者--

1122
00:57:20,390 --> 00:57:21,473
科尔顿·奥格登：这是随机的 

1123
00:57:33,540 --> 00:57:37,490
所以从我们有一个数组的想法开始 对吗？

1124
00:57:37,490 --> 00:57:40,670
它必须是一个2D阵列 因为我们有两个轴 

1125
00:57:40,670 --> 00:57:42,420
我们在这里创造了一些东西 

1126
00:57:42,420 --> 00:57:46,670
即使我们在3D环境中 我们也不需要3D阵列 

1127
00:57:46,670 --> 00:57:48,290
我们只需要一个二维数组 

1128
00:57:48,290 --> 00:57:51,080
因为如果在任何地方都有一个正值

1129
00:57:51,080 --> 00:57:54,830
我们想要在3D迷宫中生成一个积木 

1130
00:57:54,830 --> 00:57:56,850
我们只生成一列块 

1131
00:57:56,850 --> 00:57:59,840
我们不需要担心第三维空间 对吗？

1132
00:57:59,840 --> 00:58:04,890
我们的迷宫没有考虑多个层次 在这一点上

1133
00:58:04,890 --> 00:58:07,590
我们可能需要考虑三个维度 

1134
00:58:07,590 --> 00:58:14,460
即使这样 你仍然可以把它们分成不同的二维迷宫阵列 

1135
00:58:14,460 --> 00:58:16,580
我们只有一个x和一个y 

1136
00:58:16,580 --> 00:58:19,456
那么我们该如何开始呢--

1137
00:58:19,456 --> 00:58:22,330
我们将从什么开始填充ARRA--假设我们有一个数组 

1138
00:58:22,330 --> 00:58:24,320
这只是一堆零 对吧？

1139
00:58:24,320 --> 00:58:27,530
在初始化数组之后 我们要用它填充什么？

1140
00:58:35,130 --> 00:58:37,618
观众：所以我在想 也许你可以从

1141
00:58:37,618 --> 00:58:44,830
如果只有四面墙 也许会增加走廊？

1142
00:58:45,330 --> 00:58:48,870
科尔顿·奥格登：所以从一堆墙开始 然后增加走廊 

1143
00:58:48,870 --> 00:58:51,990
这正是我们要做的 

1144
00:58:51,990 --> 00:58:54,220
这个算法实际上非常简单 

1145
00:58:54,220 --> 00:58:56,790
所以我会试着画一点 只是为了看看

1146
00:58:56,790 --> 00:58:58,530
如果我能说明这是如何运作的 

1147
00:58:58,530 --> 00:59:01,613
观众：你如何确保你能从一边到另一边

1148
00:59:01,613 --> 00:59:04,500
中间没有墙吗？

1149
00:59:04,500 --> 00:59:10,530
科尔顿·奥格登：通过确保你改变的每一件事都是正交的 

1150
00:59:10,530 --> 00:59:13,540
每一块--你移动的每一步都是垂直的 

1151
00:59:13,540 --> 00:59:17,820
这将确保你在一个点开始 在另一个点结束 

1152
00:59:17,820 --> 00:59:20,940
而这些点将始终可以相互访问 

1153
00:59:20,940 --> 00:59:23,250
仅仅是因为算法是多么的简单

1154
00:59:23,250 --> 00:59:24,910
以及它的正交性 

1155
00:59:24,910 --> 00:59:28,980
所以如果我们从墙开始--

1156
00:59:28,980 --> 00:59:35,250
所以1 1 1 1 1 1 1 1 1 1 

1157
00:59:35,250 --> 00:59:39,142
这些都是--在发行版中 这些都是布尔值

1158
00:59:39,142 --> 00:59:41,850
因为我们不需要--我们只需要0和1 所以我们

1159
00:59:41,850 --> 00:59:43,150
将使用True和False 

1160
00:59:43,150 --> 00:59:45,600
为此 我们不需要使用整数 

1161
00:59:45,600 --> 00:59:48,900
这就是我们从这里开始的迷宫 

1162
00:59:48,900 --> 00:59:53,160
实际上 我要增加另一个维度 因为--

1163
00:59:53,160 --> 00:59:56,700
或者不是另一个维度 而是另一个大小 

1164
00:59:56,700 --> 01:00:01,260
只是因为墙总是需要留在那里--才能在那里 

1165
01:00:01,260 --> 01:00:03,540
这些基本上是碰不到的 

1166
01:00:03,540 --> 01:00:08,760
我会尽我所能画出来的 

1167
01:00:08,760 --> 01:00:10,950
正确的 

1168
01:00:10,950 --> 01:00:14,850
因此 我们有效地将这里作为创建迷宫的工作区 

1169
01:00:14,850 --> 01:00:16,066
因为我们希望这是--

1170
01:00:16,066 --> 01:00:17,940
我们无论如何都想要墙 因为我们不想

1171
01:00:17,940 --> 01:00:20,065
希望我们的人能够走出迷宫

1172
01:00:20,065 --> 01:00:21,600
或者看到外面的世界 永远不会 

1173
01:00:21,600 --> 01:00:24,130
我们希望他们被锁在里面 

1174
01:00:24,130 --> 01:00:29,470
所以我们这里有所有的这些 这些真实的 有效的 

1175
01:00:29,470 --> 01:00:33,690
所以我们所需要做的就是从某个随机的位置开始 

1176
01:00:33,690 --> 01:00:36,980
让我们假设这个值 

1177
01:00:36,980 --> 01:00:40,140
在3 2--或者 嗯 实际上 从技术上讲

1178
01:00:40,140 --> 01:00:44,820
它是2 3 因为我们在一个二维数组中索引y 然后是x 

1179
01:00:44,820 --> 01:00:46,782
所以我们开始2 3 

1180
01:00:46,782 --> 01:00:48,720
我们从这里开始 

1181
01:00:48,720 --> 01:00:53,700
然后我们基本上可以向左移动--

1182
01:00:53,700 --> 01:00:57,314
或者我们可以向左或向右或向上或向下移动 

1183
01:00:57,314 --> 01:00:58,980
但我们不能同时搬家 

1184
01:00:58,980 --> 01:01:01,822
为什么我们不能同时搬家呢？

1185
01:01:01,822 --> 01:01:04,780
比方说我们--比方说 首先 让我说 我们是--

1186
01:01:04,780 --> 01:01:08,880
假设我们要在迷宫中凿出一条路 

1187
01:01:08,880 --> 01:01:16,050
所以我们要把这些1变成0 但我们只能移动--

1188
01:01:16,050 --> 01:01:19,530
我们只能垂直移动 意思是向左或向右 向上或向下 

1189
01:01:19,530 --> 01:01:20,970
我们不能沿对角线移动 

1190
01:01:20,970 --> 01:01:23,770
所以我们只能...

1191
01:01:23,770 --> 01:01:28,530
假设我们有一个x移动 对吗？

1192
01:01:28,530 --> 01:01:29,479
一步一步走 

1193
01:01:33,610 --> 01:01:35,070
而这些可以设置为--

1194
01:01:35,070 --> 01:01:37,420
默认情况下 它们是0 所以我们基本上是说 

1195
01:01:37,420 --> 01:01:40,594
在这一代人的这一步上 我们将走向何方？

1196
01:01:40,594 --> 01:01:43,510
实际上 从技术上讲 这是方向 因为我们--这种方式

1197
01:01:43,510 --> 01:01:45,585
我们是通过指示来做的 

1198
01:01:45,585 --> 01:01:48,403
观众：如果你在往下走 那么你面前的是什么

1199
01:01:48,403 --> 01:01:50,135
将不会有围墙 

1200
01:01:50,135 --> 01:01:53,685
除了你来自的地方 你的两边都会有墙 

1201
01:01:54,185 --> 01:01:54,976
科尔顿·奥格登：是的 

1202
01:01:54,976 --> 01:01:58,120
所以如果你在这里 他们向下移动 这将是0 

1203
01:01:58,120 --> 01:02:00,940
这将是0 所以这些点是相连的 

1204
01:02:00,940 --> 01:02:05,260
然后我们将从那里朝一个给定的方向移动 

1205
01:02:05,260 --> 01:02:07,810
所以所有这些--比方说他们搬到了这里 

1206
01:02:07,810 --> 01:02:10,330
所有这些都将被联系在一起 

1207
01:02:10,330 --> 01:02:14,350
因此 如果我们搬到这里 所有这些都将联系在一起 

1208
01:02:14,350 --> 01:02:17,350
仅仅是因为我们是垂直移动的 

1209
01:02:17,350 --> 01:02:20,590
我们不能创造一个遥不可及的迷宫 

1210
01:02:20,590 --> 01:02:22,879
因为这种方式--

1211
01:02:22,879 --> 01:02:25,170
仅仅是因为它们是垂直运动的 

1212
01:02:25,170 --> 01:02:29,370
如果我们沿对角线移动 如果我移动到这里 对吗？

1213
01:02:29,370 --> 01:02:31,960
这里有墙 那里有两个空间 

1214
01:02:31,960 --> 01:02:34,840
这是行不通的 因为我们无法访问它 

1215
01:02:34,840 --> 01:02:37,400
我们看到一个--我们会在这里看到一个立方体 在这里看到一个立方体 

1216
01:02:37,400 --> 01:02:41,257
我们将会看到--我们将不能沿对角线穿过墙壁 

1217
01:02:41,257 --> 01:02:43,090
这就是为什么我们需要确保我们只有

1218
01:02:43,090 --> 01:02:48,350
在x或y方向上移动 而不是同时朝两个方向移动 

1219
01:02:48,350 --> 01:02:52,450
所以算法所做的就是随机选择我是否应该移动x

1220
01:02:52,450 --> 01:02:53,980
或者我应该换个位置 

1221
01:02:53,980 --> 01:02:56,120
我应该采取积极的还是消极的态度 

1222
01:02:56,120 --> 01:02:58,780
所以它会做的--数学上的点随机 相等--

1223
01:02:58,780 --> 01:03:00,970
你知道 二等于一 

1224
01:03:00,970 --> 01:03:05,380
有效地在代码中它是随机的点值 小于0.5 

1225
01:03:05,380 --> 01:03:10,150
因为Unity中的随机点值会将0到1表示为浮点数 

1226
01:03:10,150 --> 01:03:15,310
所以你说如果随机点值小于0.5 

1227
01:03:15,310 --> 01:03:20,650
这是真与假之间的随机机会 有效率为50%--

1228
01:03:20,650 --> 01:03:21,790
移入x或移入y 

1229
01:03:21,790 --> 01:03:27,850
然后是同样的事情 但我应该朝着积极还是消极的方向前进呢？

1230
01:03:27,850 --> 01:03:31,000
所以如果我在这里 我在想 好的 让我们看看 

1231
01:03:31,000 --> 01:03:32,274
X移动还是y移动？

1232
01:03:32,274 --> 01:03:35,440
再一次 这将是一个x移动 所以我将向左或向右移动 

1233
01:03:35,440 --> 01:03:38,380
好的 我要把负数移到1还是1

1234
01:03:38,380 --> 01:03:41,410
一步 向右走还是向左走？

1235
01:03:41,410 --> 01:03:45,570
所以如果它是负1 它会向左移动 对吗？

1236
01:03:45,570 --> 01:03:49,870
如果它是正1 它就会向右移动 

1237
01:03:49,870 --> 01:03:53,350
所以这就是算法的本质 只是循环了一堆次 

1238
01:03:53,350 --> 01:03:58,420
每当我移动到另一块瓷砖时 就把它变成零 

1239
01:03:58,420 --> 01:04:01,720
所以实际上 这变成了零 

1240
01:04:01,720 --> 01:04:04,580
更改颜色 

1241
01:04:04,580 --> 01:04:06,580
所以这会变成零 

1242
01:04:06,580 --> 01:04:10,210
所以现在那是一片空地 

1243
01:04:10,210 --> 01:04:13,900
在代码中 它会立即将角色传送到那个空间 

1244
01:04:13,900 --> 01:04:14,680
也是 

1245
01:04:14,680 --> 01:04:18,100
所以我们知道我们的角色总是在一个空白的空间里 

1246
01:04:18,100 --> 01:04:22,690
因为他被安置在迷宫中产生的第一个开放空间 

1247
01:04:22,690 --> 01:04:27,940
在这个迭代中 假设x移动等于负1 

1248
01:04:27,940 --> 01:04:31,540
假设我们一直在循环 直到我们清除了x个块 

1249
01:04:31,540 --> 01:04:34,060
所以我想清理--比方说我想清理五个街区 

1250
01:04:34,060 --> 01:04:39,190
所以清除等于5 

1251
01:04:39,190 --> 01:04:40,190
这就是街区的数量--

1252
01:04:40,190 --> 01:04:43,940
当我们清除了那么多街区 我们就完成了迷宫生成器 

1253
01:04:43,940 --> 01:04:48,880
所以清除了一个 所以我们目前的计数器是一个 

1254
01:04:48,880 --> 01:04:51,100
所以x 我们得到--抛硬币 

1255
01:04:51,100 --> 01:04:55,040
我们以负1的速度向x方向移动 

1256
01:04:55,040 --> 01:05:02,590
所以我们移到这里 然后我们把这个变成零 

1257
01:05:02,590 --> 01:05:08,390
现在 算法的这种实现一次前进一步 

1258
01:05:08,390 --> 01:05:12,190
因此 由于它的随机性 它最终所做的是

1259
01:05:12,190 --> 01:05:15,650
它会产生很大的变形空间 

1260
01:05:15,650 --> 01:05:18,520
仅仅因为爬行器在不停地移动 

1261
01:05:18,520 --> 01:05:20,170
有点 就像 很随意 

1262
01:05:20,170 --> 01:05:22,840
那么 我们可以对该算法进行哪些改进呢

1263
01:05:22,840 --> 01:05:27,018
让它看起来更像走廊或走廊？

1264
01:05:27,018 --> 01:05:29,309
观众：一直走到你撞到另一面墙？

1265
01:05:29,309 --> 01:05:30,770
是同一个方向吗？

1266
01:05:30,770 --> 01:05:32,561
科尔顿·奥格登：你可以这样做 是的 留着

1267
01:05:32,561 --> 01:05:34,640
一直走到你撞到另一面墙 

1268
01:05:34,640 --> 01:05:36,270
其结果是--

1269
01:05:36,270 --> 01:05:39,390
你的意思是撞到迷宫的一边？

1270
01:05:39,390 --> 01:05:41,150
是的 因为它--好吧 如果你这么做了 

1271
01:05:41,150 --> 01:05:44,390
它实际上就像是--

1272
01:05:44,390 --> 01:05:45,810
这会有点--

1273
01:05:45,810 --> 01:05:50,150
在某些情况下可能行得通 但走廊会很长

1274
01:05:50,150 --> 01:05:53,130
而且没有太多的转弯或类似的事情 

1275
01:05:53,130 --> 01:05:57,650
所以结果 我们真正想要做的是 当我们抛硬币时

1276
01:05:57,650 --> 01:06:03,920
我们说x移动或y移动 我们也想说移动的次数 

1277
01:06:03,920 --> 01:06:08,240
我们希望有效地创建一个名为Numbers to Move的新变量 

1278
01:06:08,240 --> 01:06:14,930
移动 然后我们将其设置为1之间的随机数 

1279
01:06:14,930 --> 01:06:22,460
我们要移动1块瓷砖 或者说迷宫的大小减去2 

1280
01:06:22,460 --> 01:06:24,950
把两面墙都考虑进去 对吧？

1281
01:06:24,950 --> 01:06:28,130
所以我们假设我们得到了--

1282
01:06:28,130 --> 01:06:32,920
假设我们--假设我们做了x移动减去1 

1283
01:06:32,920 --> 01:06:35,836
我们只需要移动等于1 对吗？

1284
01:06:35,836 --> 01:06:36,710
所以我们只搬到这里 

1285
01:06:36,710 --> 01:06:40,040
我们朝这个方向移动一次 所以我们有两个空间 

1286
01:06:40,040 --> 01:06:44,270
然后让我们再次抛硬币 然后我们开始行动--

1287
01:06:44,270 --> 01:06:46,310
正1 

1288
01:06:46,310 --> 01:06:50,120
再走两步 我们就有两个了 

1289
01:06:50,120 --> 01:06:54,620
所以我们要在y轴上移动两个方向 一个方向 

1290
01:06:54,620 --> 01:06:59,030
这是我们往下走的结果 所以我们先是0 然后是0 

1291
01:07:01,640 --> 01:07:07,970
因此 这样做的效果是我们移动--

1292
01:07:07,970 --> 01:07:11,240
我们一次可以搬进不止一个街区

1293
01:07:11,240 --> 01:07:17,540
避免那种随机的、随意的、奇怪的、有机的大房间

1294
01:07:17,540 --> 01:07:18,780
我们想要的美感 

1295
01:07:18,780 --> 01:07:26,110
如果我们想要一个走廊 网格状 看起来像地牢的房间发电机 对吗？

1296
01:07:26,110 --> 01:07:32,480
这里有一个警告 那就是如果我们从这里开始 例如 

1297
01:07:32,480 --> 01:07:34,400
然后我们想

1298
01:07:34,400 --> 01:07:35,660
我们来抛硬币决定吧

1299
01:07:35,660 --> 01:07:39,470
是x移动 但它是正4.

1300
01:07:39,470 --> 01:07:43,600
我们显然不能把四块瓷砖移到右边 

1301
01:07:43,600 --> 01:07:45,770
它会从外面进入我们的墙 第二 

1302
01:07:45,770 --> 01:07:48,480
它实际上超出了数组的范围 

1303
01:07:48,480 --> 01:07:51,440
所以我们需要压制这个价值 

1304
01:07:51,440 --> 01:07:57,200
当我们给我们的值加1时 无论x--

1305
01:07:57,200 --> 01:07:58,700
我们基本上都要保留指针 

1306
01:07:58,700 --> 01:08:02,030
我们保持指针指向我们当前所在的瓷砖 

1307
01:08:02,030 --> 01:08:03,920
我们得保持...

1308
01:08:03,920 --> 01:08:07,580
当我们实际上在我们的步骤中转到下一个瓦片时 

1309
01:08:07,580 --> 01:08:11,300
我们需要把这个值限制在我们的墙的范围内 

1310
01:08:11,300 --> 01:08:15,890
所以我们需要夹在

1311
01:08:15,890 --> 01:08:18,439
因为我们不想为零

1312
01:08:18,439 --> 01:08:24,649
我们想把它夹在1和主尺寸减2之间 

1313
01:08:24,649 --> 01:08:28,310
因为我们要确保我们不会走得比这更远

1314
01:08:28,310 --> 01:08:30,600
这里.

1315
01:08:30,600 --> 01:08:31,740
这有道理吗？

1316
01:08:31,740 --> 01:08:34,490
这就是发电机的工作原理

1317
01:08:34,490 --> 01:08:37,250
这比一次只移动一个街区更进一步 

1318
01:08:37,250 --> 01:08:41,840
就因为迷宫看起来太空旷怪异了

1319
01:08:41,840 --> 01:08:44,819
通过这种方法 你朝着一个方向前进 

1320
01:08:44,819 --> 01:08:47,720
并且对于随机数量的瓦片而不是一次仅一个瓦片 

1321
01:08:47,720 --> 01:08:51,350
你实际上得到的是一个很漂亮的 简单的迷宫 

1322
01:08:51,350 --> 01:08:56,068
这不是真正的迷宫生成的工作原理 对于你会看到的迷宫 

1323
01:08:56,068 --> 01:08:59,359
和一个真正的迷宫 就像在一本填字游戏书或迷宫书中一样

1324
01:08:59,359 --> 01:09:00,080
什么的

1325
01:09:00,080 --> 01:09:02,840
那些更复杂 

1326
01:09:02,840 --> 01:09:05,630
但这个解决方案效果很好 

1327
01:09:05,630 --> 01:09:10,500
它非常快 非常便宜 实际上很容易理解 

1328
01:09:10,500 --> 01:09:13,910
有关于迷宫生成器的问题吗至少是算法

1329
01:09:13,910 --> 01:09:15,590
应用到我们的2D阵列中 是否有效？

1330
01:09:18,500 --> 01:09:19,301
好吧

1331
01:09:19,301 --> 01:09:19,800
酷了

1332
01:09:19,800 --> 01:09:22,844
基本上就是这么回事

1333
01:09:22,844 --> 01:09:26,010
我们先休息五分钟 

1334
01:09:26,010 --> 01:09:28,140
回来的时候我们会再下潜一点

1335
01:09:28,140 --> 01:09:32,840
角色控制器是如何工作的 还有拾取器 

1336
01:09:32,840 --> 01:09:35,700
以及游戏的其他方面 

1337
01:09:35,700 --> 01:09:37,649
好了 欢迎回到第九课 

1338
01:09:37,649 --> 01:09:40,350
休息之前我们讨论了

1339
01:09:40,350 --> 01:09:42,810
我们实现了程序化的迷宫生成 

1340
01:09:42,810 --> 01:09:47,520
所以一个相当简单的算法 

1341
01:09:47,520 --> 01:09:49,439
看看哪里容易迷路 

1342
01:09:49,439 --> 01:09:52,319
但它们不是传统意义上的迷宫

1343
01:09:52,319 --> 01:09:57,390
就像你在益智书中看到的那样 

1344
01:09:57,390 --> 01:10:00,990
另一个推销猫式编码 因为他的文章是惊人的 

1345
01:10:00,990 --> 01:10:05,530
他还有一个关于他如何做迷宫生成器的 

1346
01:10:05,530 --> 01:10:08,230
在这一个 除了普通的街区--

1347
01:10:08,230 --> 01:10:09,060
哦对不起

1348
01:10:09,060 --> 01:10:13,080
我没把幻灯片放在那上面 

1349
01:10:13,080 --> 01:10:15,570
这是另一篇文章的截图

1350
01:10:15,570 --> 01:10:20,229
他在书中谈到了如何制作自己的迷宫生成器 

1351
01:10:20,229 --> 01:10:22,020
他最酷的地方在于

1352
01:10:22,020 --> 01:10:24,186
一堆不同的几何图形 

1353
01:10:24,186 --> 01:10:25,320
不仅仅是街区 

1354
01:10:25,320 --> 01:10:27,900
他有门窗和其他东西 

1355
01:10:27,900 --> 01:10:30,270
他的算法和我的有点不同

1356
01:10:30,270 --> 01:10:32,550
并产生了一些非常有趣的东西 

1357
01:10:32,550 --> 01:10:37,050
你可以看到 它也有一个场景

1358
01:10:37,050 --> 01:10:40,260
叠加在真实的场景上 

1359
01:10:40,260 --> 01:10:44,460
他用两个摄像头做了个小把戏 

1360
01:10:44,460 --> 01:10:50,010
所以这里的另一个迷宫斜线地牢生成器的文章

1361
01:10:50,010 --> 01:10:52,822
我真的很喜欢他创造的地牢

1362
01:10:52,822 --> 01:10:54,030
和龙式发电机

1363
01:10:54,030 --> 01:10:56,550
这和我作为一个开发者的兴趣有关

1364
01:10:56,550 --> 01:11:00,450
因为我真的很喜欢Roguelike和地牢生成器和RPG 

1365
01:11:00,450 --> 01:11:03,180
但他详细介绍了如何

1366
01:11:03,180 --> 01:11:06,980
一个非常漂亮高效的2D迷宫斜线

1367
01:11:06,980 --> 01:11:10,460
地牢生成器 产生非常好看的地牢 

1368
01:11:10,460 --> 01:11:13,680
如你所见 它的布局非常多变 有很多走廊

1369
01:11:13,680 --> 01:11:15,039
房间之类的东西

1370
01:11:15,039 --> 01:11:17,580
所以在Unity中实现这样的功能会很酷 

1371
01:11:17,580 --> 01:11:20,700
有太多的发电机和资产

1372
01:11:20,700 --> 01:11:23,182
在Unity中做同样的事情

1373
01:11:23,182 --> 01:11:24,390
可在资产商店中使用 

1374
01:11:24,390 --> 01:11:25,960
所以大部分时间你不必自己做这个 

1375
01:11:25,960 --> 01:11:29,340
你可以创建--你可以去找免费或付费的资产 

1376
01:11:29,340 --> 01:11:33,600
它会为你做所有这些 并为你节省大量的时间 

1377
01:11:33,600 --> 01:11:36,270
其中有多少是可以定制的 

1378
01:11:36,270 --> 01:11:40,290
这样你就可以定制发电机 以满足你的游戏的需求 

1379
01:11:40,290 --> 01:11:43,290
我们看到了游戏中的灯光是如何工作的 

1380
01:11:43,290 --> 01:11:48,460
我们已经看到了迷宫 它是如何产生的 它是什么样子的 

1381
01:11:48,460 --> 01:11:51,380
我们还没有看过角色控制器 

1382
01:11:51,380 --> 01:11:53,130
所以我们会简单地看一下 

1383
01:11:53,130 --> 01:11:55,650
至少在Unity中 

1384
01:11:55,650 --> 01:11:58,950
让一些基本的东西开始运行 

1385
01:11:58,950 --> 01:12:04,110
在我们的游戏中 我们获得FPS控制器的方式是Unity 

1386
01:12:04,110 --> 01:12:09,390
我之前提到过 一套内置的标准资产

1387
01:12:09,390 --> 01:12:12,710
让人们习惯游戏引擎的包 

1388
01:12:12,710 --> 01:12:15,000
或者只是想引导他们的游戏 

1389
01:12:15,000 --> 01:12:16,860
和运行一些非常基本的组件 

1390
01:12:16,860 --> 01:12:22,050
非常基本的东西 对让你的游戏运行非常有帮助 

1391
01:12:22,050 --> 01:12:25,890
所以实际上我们使用了原型标准资产包作为我们的皮卡 

1392
01:12:25,890 --> 01:12:32,280
我们使用字符一为字符控制器 FPS

1393
01:12:32,280 --> 01:12:34,270
controller.

1394
01:12:34,270 --> 01:12:37,640
所以如果你在一个新的项目中 

1395
01:12:37,640 --> 01:12:41,140
你把这个角色导入到游戏里

1396
01:12:41,140 --> 01:12:44,700
这样你就可以立即使用它给你的预制件来创建

1397
01:12:44,700 --> 01:12:46,370
字符对象 

1398
01:12:46,370 --> 01:12:49,980
所以默认情况下 它会把它放在你的资产文件夹里 

1399
01:12:49,980 --> 01:12:52,440
下面是标准资产 然后是角色 

1400
01:12:52,440 --> 01:12:54,171
还有一个第一人称文件夹

1401
01:12:54,171 --> 01:12:55,920
在第一人称的文件夹里

1402
01:12:55,920 --> 01:12:59,790
预置文件夹 其具有FPS控制器游戏对象 

1403
01:12:59,790 --> 01:13:02,430
所以你所需要做的就是把它拖到场景中 

1404
01:13:02,430 --> 01:13:05,490
然后这就成了你的默认摄像头 

1405
01:13:08,196 --> 01:13:09,899
观众：这是Unity自带的吗？

1406
01:13:09,899 --> 01:13:11,690
科尔顿·奥格登：它是统一的 对吧 

1407
01:13:11,690 --> 01:13:12,898
这只是一项标准资产 

1408
01:13:12,898 --> 01:13:15,000
观众：它总是在预制的文件夹里吗？

1409
01:13:15,000 --> 01:13:18,360
科尔顿·奥格登：它总是在--FPS控制器总是在--

1410
01:13:18,360 --> 01:13:19,710
所以你必须先把它导入 

1411
01:13:19,710 --> 01:13:22,950
您必须导入资产包 

1412
01:13:22,950 --> 01:13:24,450
角色包 

1413
01:13:24,450 --> 01:13:27,030
一旦导入了Characters包 

1414
01:13:27,030 --> 01:13:29,520
您将进入Assets文件夹中的Standard Assets 

1415
01:13:29,520 --> 01:13:32,160
将会有一个名为Standard Assets的新文件夹 

1416
01:13:32,160 --> 01:13:37,500
在Standard Assets中 您将转到Characters 然后是第一人称 然后是

1417
01:13:37,500 --> 01:13:40,447
预制板 然后你就会在那里找到FPS控制器 

1418
01:13:40,447 --> 01:13:41,280
观众：谢谢 

1419
01:13:41,280 --> 01:13:42,030
科尔顿·奥格登：是的 

1420
01:13:42,030 --> 01:13:42,720
没问题 

1421
01:13:42,720 --> 01:13:45,690
所以FPS控制器 如果我们看看它--

1422
01:13:45,690 --> 01:13:47,550
我们之前简短地谈过这件事 

1423
01:13:47,550 --> 01:13:52,440
但实际上 它只是一个胶囊对撞机 

1424
01:13:52,440 --> 01:13:56,220
这有点违反物理学 因为它是运动学的 

1425
01:13:56,220 --> 01:13:58,980
应用重力的运动学 

1426
01:13:58,980 --> 01:14:01,280
它的顶部有一个摄像头

1427
01:14:01,280 --> 01:14:04,680
头部是用来模拟某人的视角

1428
01:14:04,680 --> 01:14:06,450
从第一人称的角度来看 

1429
01:14:06,450 --> 01:14:08,340
而且有一些编程涉及到

1430
01:14:08,340 --> 01:14:11,010
允许你用按键和鼠标来控制它 

1431
01:14:11,010 --> 01:14:14,100
使用鼠标和位置控制相机的旋转

1432
01:14:14,100 --> 01:14:19,610
对撞机和WASD密钥 

1433
01:14:19,610 --> 01:14:22,390
如果你愿意 你也可以深入研究它的实际脚本 

1434
01:14:22,390 --> 01:14:26,380
它们都包括在标准资产包中 

1435
01:14:26,380 --> 01:14:28,289
当您将其导入到项目中时 它会

1436
01:14:28,289 --> 01:14:30,580
附带了使这一切成为可能的所有脚本 

1437
01:14:30,580 --> 01:14:35,050
我还没有详细地研究过它们 但它们都在那里等着您

1438
01:14:35,050 --> 01:14:37,690
如果对它的工作原理感到好奇 

1439
01:14:37,690 --> 01:14:42,810
因此 如果你想在游戏中只有一个简单的FPS控制器 

1440
01:14:42,810 --> 01:14:46,330
游戏中的一个角色 走来走去 玩第一人称游戏 

1441
01:14:46,330 --> 01:14:49,820
启动和运行大约需要一分钟 

1442
01:14:49,820 --> 01:14:52,150
现在 您可以进行大量的定制

1443
01:14:52,150 --> 01:14:54,460
可以应用到您的角色控制器以使其

1444
01:14:54,460 --> 01:14:59,320
不仅仅是标准的、基本的性格 

1445
01:14:59,320 --> 01:15:03,340
所以你可以设定步行速度 也可以设定跑步速度 

1446
01:15:03,340 --> 01:15:09,240
你可以设置跳跃速度 可以设置鼠标的敏感度

1447
01:15:09,240 --> 01:15:12,970
在游戏上--在FPS控制器上 

1448
01:15:12,970 --> 01:15:16,660
你可以应用所谓的FOV打腿 这意味着当你在冲刺时--

1449
01:15:16,660 --> 01:15:19,780
它允许你按下Shift键进行冲刺 

1450
01:15:19,780 --> 01:15:21,880
这会使你的速度成倍增长--

1451
01:15:21,880 --> 01:15:27,640
它实际上--它会把你的景深扩大一点 以使它

1452
01:15:27,640 --> 01:15:30,580
看起来你好像有点幽闭恐惧症 

1453
01:15:30,580 --> 01:15:33,964
东西就像是在外面 所以它看起来更窄 

1454
01:15:33,964 --> 01:15:36,880
它让你看起来就像是在一条小路上冲刺 

1455
01:15:36,880 --> 01:15:39,130
你可以设置它增加了多少 

1456
01:15:39,130 --> 01:15:41,870
您可以看到这条曲线是如何在这里应用的 

1457
01:15:41,870 --> 01:15:44,620
这是Unity允许您执行的组件之一 

1458
01:15:44,620 --> 01:15:48,460
有一条曲线物体 你可以用这条曲线

1459
01:15:48,460 --> 01:15:50,750
在你的游戏中影响各种东西 

1460
01:15:50,750 --> 01:15:52,660
实际上 我自己也没怎么用过它 

1461
01:15:52,660 --> 01:15:56,560
但如果你在寻找可以应用曲线的东西 

1462
01:15:56,560 --> 01:16:01,510
Unity有一个界面 可以让它在您的检查器中可见 

1463
01:16:01,510 --> 01:16:04,390
头部鲍勃 这意味着当我走路时 摄像机是否应该

1464
01:16:04,390 --> 01:16:07,150
上上下下？

1465
01:16:07,150 --> 01:16:09,500
当你有一个波波头时 曲线是什么样子的？

1466
01:16:09,500 --> 01:16:10,737
这是另一条曲线 

1467
01:16:10,737 --> 01:16:12,820
这就是波波头的样子 有点像

1468
01:16:12,820 --> 01:16:17,710
一个正弦波 但有一点失真 

1469
01:16:17,710 --> 01:16:19,590
还有其他几件事 

1470
01:16:19,590 --> 01:16:21,029
例如 脚步声 

1471
01:16:21,029 --> 01:16:24,070
也许你不喜欢控制器默认的声音 

1472
01:16:24,070 --> 01:16:25,912
所以你给它发出你自己的脚步声 

1473
01:16:25,912 --> 01:16:26,620
超级容易做到 

1474
01:16:26,620 --> 01:16:29,080
只需将新声音拖到此处 

1475
01:16:29,080 --> 01:16:30,640
跳跃声和落地声 

1476
01:16:30,640 --> 01:16:32,920
你还可以再加上两个声音 

1477
01:16:32,920 --> 01:16:37,030
这将允许您自定义角色如何移动的大部分感觉

1478
01:16:37,030 --> 01:16:41,950
就只有一个基本的FPS控制器而言 

1479
01:16:41,950 --> 01:16:47,150
所以只要应用这些非常基本的东西 对它们进行一点定制--

1480
01:16:47,150 --> 01:16:49,240
我们在这迷宫里很幸运

1481
01:16:49,240 --> 01:16:51,940
这意味着迷宫绕了一圈

1482
01:16:51,940 --> 01:16:54,065
回到了我们所在的地方然后在那里结束了

1483
01:16:54,065 --> 01:16:58,180
这就是那个迷宫

1484
01:16:58,180 --> 01:17:01,040
我要把声音调大 

1485
01:17:01,040 --> 01:17:04,090
你能听到脚步声 对吧？

1486
01:17:04,090 --> 01:17:05,710
伴随着令人毛骨悚然的低语声 

1487
01:17:05,710 --> 01:17:13,000
但是脚步声只是由FPS控制器提供给我们的 

1488
01:17:13,000 --> 01:17:16,040
你也可以根据自己的需要来定制

1489
01:17:16,040 --> 01:17:18,040
所以这给了你四处走动的能力

1490
01:17:18,040 --> 01:17:19,623
在场景中以第一人称视图显示 

1491
01:17:19,623 --> 01:17:22,090
它并没有给你更多 

1492
01:17:22,090 --> 01:17:26,260
为了做一个FPS游戏 你可能有一把枪或武器或什么的 

1493
01:17:26,260 --> 01:17:29,140
你需要编写更多的程序 这要复杂得多 

1494
01:17:29,140 --> 01:17:33,880
但对于3D场景的基本导航来说 这是一个很好的基础 

1495
01:17:33,880 --> 01:17:36,200
一个很好的开始 

1496
01:17:36,200 --> 01:17:38,780
那么 有没有关于FPS控制器如何工作的问题？

1497
01:17:41,745 --> 01:17:43,120
还有其他的控制器 

1498
01:17:43,120 --> 01:17:45,110
有第三人称控制器 

1499
01:17:45,110 --> 01:17:47,610
如果你想使用这些 

1500
01:17:47,610 --> 01:17:50,110
它们不带摄像头--根据我的实验 

1501
01:17:50,110 --> 01:17:52,206
它们并没有默认的摄像头 

1502
01:17:52,206 --> 01:17:54,580
所以我觉得你得给他们装个摄像头

1503
01:17:54,580 --> 01:17:55,900
你想要的游戏 

1504
01:17:55,900 --> 01:17:59,440
比如说 有些游戏的摄像头比你的角色高得多

1505
01:17:59,440 --> 01:18:01,315
当你四处走动的时候 

1506
01:18:01,315 --> 01:18:06,250
有一个肩膀后面的外观 几乎像Fortnite或齿轮

1507
01:18:06,250 --> 01:18:08,200
战争 真的很接近角色 

1508
01:18:08,200 --> 01:18:10,530
然后是某种有--就像班卓卡祖伊 

1509
01:18:10,530 --> 01:18:12,340
你可能在爬山 所以相机

1510
01:18:12,340 --> 01:18:15,339
就像是垂直于你所在的位置 并跟随着你 

1511
01:18:15,339 --> 01:18:18,129
围绕这样的相机编程的3D人物

1512
01:18:18,129 --> 01:18:20,920
比第一人称游戏要复杂一些 

1513
01:18:20,920 --> 01:18:24,110
这就是为什么我提到它默认不带摄像头 

1514
01:18:24,110 --> 01:18:26,179
所以可能会更复杂一点

1515
01:18:26,179 --> 01:18:28,720
但我相信资产商店里有很多资产

1516
01:18:28,720 --> 01:18:32,180
这可以帮助你引导你 如果你有一个可编程的摄像头

1517
01:18:32,180 --> 01:18:37,660
在第三人称视图中设置您的角色 

1518
01:18:37,660 --> 01:18:38,160
嗯 

1519
01:18:38,160 --> 01:18:40,660
观众：我注意到当你在迷宫里走来走去时 

1520
01:18:40,660 --> 01:18:45,329
偶尔 你会剪下这堵墙 有点像是看到了它背后的东西 

1521
01:18:45,329 --> 01:18:46,120
科尔顿·奥格登：是的 

1522
01:18:46,120 --> 01:18:49,286
我认为这是因为对撞机有点太大了 

1523
01:18:49,286 --> 01:18:53,040
所以他说的是 穿过迷宫 

1524
01:18:53,040 --> 01:18:55,297
你可以稍微剪穿这堵墙 

1525
01:18:55,297 --> 01:18:57,130
让我们看看你是否真的能体验到它 

1526
01:18:57,130 --> 01:18:59,680
对 就像就在那里 

1527
01:18:59,680 --> 01:19:00,190
嗯 

1528
01:19:00,190 --> 01:19:04,690
这就是--我相信那只是照相机或对撞机

1529
01:19:04,690 --> 01:19:06,610
有点太大了 

1530
01:19:06,610 --> 01:19:09,100
所以我们可以完全摆脱这一点

1531
01:19:09,100 --> 01:19:11,450
通过将对撞机缩小一点 

1532
01:19:11,450 --> 01:19:13,780
只是一个我没有解决的细节 

1533
01:19:13,780 --> 01:19:16,390
但实际上 你会在很多游戏中看到这一点 

1534
01:19:16,390 --> 01:19:20,530
许多游戏都有你可以观察到的剪辑 

1535
01:19:20,530 --> 01:19:22,180
这取决于他们如何编写游戏程序 

1536
01:19:24,700 --> 01:19:25,330
但是 是的 

1537
01:19:25,330 --> 01:19:29,320
关于角色控制器如何工作的任何其他问题 

1538
01:19:29,320 --> 01:19:34,510
以及导入过程的工作原理 以及如何将其应用到您的场景中？

1539
01:19:34,510 --> 01:19:35,730
好的 

1540
01:19:35,730 --> 01:19:36,230
凉爽的 

1541
01:19:36,230 --> 01:19:37,449
是啊 这超级简单 

1542
01:19:37,449 --> 01:19:39,490
同样 下面是FPS控制器的外观 

1543
01:19:39,490 --> 01:19:41,939
太空舱与摄像机相撞 

1544
01:19:41,939 --> 01:19:43,480
然后是第三人称控制器 

1545
01:19:43,480 --> 01:19:46,354
默认情况下 它们会在左侧为您提供一个非常好看的模型

1546
01:19:46,354 --> 01:19:48,349
这样你就可以用它做实验了 

1547
01:19:48,349 --> 01:19:50,140
然后他们显然会给你一个AI One

1548
01:19:50,140 --> 01:19:52,720
这样你就可以用它在你的场景中测试人工智能 

1549
01:19:52,720 --> 01:19:57,460
但我还没有对此进行过太多的试验 以保证它有多好用 

1550
01:19:57,460 --> 01:20:00,760
所以今天这个例子的一个重要方面

1551
01:20:00,760 --> 01:20:04,190
我们已经从只有一个场景变成了两个场景 

1552
01:20:04,190 --> 01:20:09,670
所以我想说明一下我们是如何在场景之间移动的 

1553
01:20:09,670 --> 01:20:13,090
而且 我意识到我们并没有真正涵盖地牢发电机

1554
01:20:13,090 --> 01:20:14,710
在代码细节上 

1555
01:20:14,710 --> 01:20:17,850
但请注意 我在这里暴露了很多东西 

1556
01:20:17,850 --> 01:20:21,300
地板预制件、墙体预制件、天花板预制件 

1557
01:20:21,300 --> 01:20:23,050
这些只是带有纹理的立方体

1558
01:20:23,050 --> 01:20:24,430
成为我们的地板、墙壁和天花板 

1559
01:20:24,430 --> 01:20:27,190
我们只需点击并将它们从检查器拖到我们的场景中 

1560
01:20:27,190 --> 01:20:29,020
放在那里的组件上 

1561
01:20:29,020 --> 01:20:32,154
我们这里有一个字符控制器引用 

1562
01:20:32,154 --> 01:20:34,570
这样我们就可以在场景中放置角色控制器

1563
01:20:34,570 --> 01:20:37,000
当我们生成第一个块时 

1564
01:20:37,000 --> 01:20:41,350
我们基本上可以接受变换 并将其位置设置为任何位置

1565
01:20:41,350 --> 01:20:44,050
那个x z就是 

1566
01:20:44,050 --> 01:20:46,360
然后是地板父对象和墙父对象 

1567
01:20:46,360 --> 01:20:48,820
所以我们之所以有父对象 实际上 

1568
01:20:48,820 --> 01:20:50,260
这是我们之前没有看到的--

1569
01:20:50,260 --> 01:20:52,040
哎呀 我忘了我的.

1570
01:20:52,040 --> 01:20:53,140
就是这样 

1571
01:20:53,140 --> 01:20:55,330
我们在这里拥有父对象的原因

1572
01:20:55,330 --> 01:20:59,740
是因为当我们实例化场景中的所有立方体时 

1573
01:20:59,740 --> 01:21:04,690
只是在某种程度上实例化它们 而不是真正地考虑它 

1574
01:21:04,690 --> 01:21:06,610
结果是--

1575
01:21:06,610 --> 01:21:07,900
基本上 我会在这里展示给你看 

1576
01:21:10,610 --> 01:21:14,300
首先 我不知道这是什么 

1577
01:21:14,300 --> 01:21:18,600
我觉得这--这很有趣 

1578
01:21:18,600 --> 01:21:20,350
哦 因为我点击了楼层家长 

1579
01:21:20,350 --> 01:21:21,269
好的 好的 

1580
01:21:21,269 --> 01:21:23,060
因此 实际上 您可以点击墙的父对象 

1581
01:21:23,060 --> 01:21:24,070
我还没有那么做 但实际上它会的

1582
01:21:24,070 --> 01:21:27,340
显示所有为父对象的对象的位置--或者

1583
01:21:27,340 --> 01:21:29,720
都依赖于那个父母 

1584
01:21:29,720 --> 01:21:31,700
所以这里的地板父母--

1585
01:21:31,700 --> 01:21:33,220
看到有多少块地板了吗？

1586
01:21:33,220 --> 01:21:33,928
这是相当多的 

1587
01:21:38,830 --> 01:21:42,770
这里有很多地砖 而在父母的墙上 还有更多的 

1588
01:21:42,770 --> 01:21:46,780
有很多墙和天花板 

1589
01:21:46,780 --> 01:21:50,720
如果我们只是生成这些 而不给它们分配一个父代 

1590
01:21:50,720 --> 01:21:55,300
它只会非常混乱地填满我们在那里的层级 

1591
01:21:55,300 --> 01:22:00,170
这使得在调试期间导航我们的场景变得非常困难 

1592
01:22:00,170 --> 01:22:03,070
我们不需要看到我们有一百万个克隆的地板

1593
01:22:03,070 --> 01:22:06,310
或者天花板积木或墙体积木 

1594
01:22:06,310 --> 01:22:11,530
因此 我们要做的就是获取所有克隆数据块并将其作为父数据块

1595
01:22:11,530 --> 01:22:13,300
将它们添加到一个对象 

1596
01:22:13,300 --> 01:22:16,720
当您将某个对象设置为父对象时 您会看到一个小下拉列表 

1597
01:22:16,720 --> 01:22:19,290
比如 这个第一人称角色 

1598
01:22:19,290 --> 01:22:23,064
该FPS控制器是该第一人称角色的父角色 

1599
01:22:23,064 --> 01:22:26,230
因此 这是两个独立的对象 它们都构成了FPS控制器 

1600
01:22:26,230 --> 01:22:27,670
有效地 

1601
01:22:27,670 --> 01:22:32,950
父级是顶级的 因此它的子级在这个小箭头中

1602
01:22:32,950 --> 01:22:34,360
在这里 它是可折叠的 

1603
01:22:34,360 --> 01:22:37,030
例如 游戏场景中的所有东西--

1604
01:22:37,030 --> 01:22:39,690
游戏场景是所有这些的父场景 

1605
01:22:39,690 --> 01:22:42,880
它有点像文件夹层次结构类型的东西 

1606
01:22:42,880 --> 01:22:44,630
所以如果你想清理你的场景 

1607
01:22:44,630 --> 01:22:47,750
如果你要实例化一大堆东西 只要有效地

1608
01:22:47,750 --> 01:22:51,140
通过将它们放入父对象来对它们进行容器处理 

1609
01:22:51,140 --> 01:22:57,640
因此 我们在游戏中使用了一个名为Create Child Prefab的功能来做到这一点 

1610
01:22:57,640 --> 01:23:02,510
因此 创建子预置所做的是 它照常进行实例化 

1611
01:23:02,510 --> 01:23:07,470
创建一个预制件 实例化它 给它一个位置xyz 

1612
01:23:07,470 --> 01:23:10,850
四元数点恒等式 因为我们不想对它应用任何旋转 

1613
01:23:10,850 --> 01:23:19,220
但我的预制点变换父点等于父点变换 

1614
01:23:19,220 --> 01:23:22,610
有效地将我们的--我们正在分配

1615
01:23:22,610 --> 01:23:28,414
预设器转换为父转换的父字段 

1616
01:23:28,414 --> 01:23:30,830
这样做的效果就是把它们联系在一起

1617
01:23:30,830 --> 01:23:32,780
在亲子关系中 

1618
01:23:32,780 --> 01:23:38,090
这将允许我们在以下情况下折叠和展开列表

1619
01:23:38,090 --> 01:23:39,750
一位家长有一群孩子 

1620
01:23:39,750 --> 01:23:44,770
我们可以在层次结构视图中展开和收缩 为我们节省了大量--

1621
01:23:44,770 --> 01:23:47,270
在场景导航方面为我们省去了一点头痛

1622
01:23:47,270 --> 01:23:50,030
或者我们实例化了很多东西 这是很正常的 

1623
01:23:53,430 --> 01:23:55,430
所以实际情况可能是--

1624
01:23:55,430 --> 01:23:56,910
我会很快地回顾一下这一点 

1625
01:23:56,910 --> 01:23:58,734
这是一个相当简单的算法 

1626
01:23:58,734 --> 01:24:01,650
我们在屏幕上讨论了这件事 我们没有太多的时间 

1627
01:24:01,650 --> 01:24:04,790
但基本上我们是从z到x 

1628
01:24:04,790 --> 01:24:08,750
我们从z到x的原因是因为在单位中 z和x是

1629
01:24:08,750 --> 01:24:13,790
有点像地轴 而a y 有点像上下轴 

1630
01:24:13,790 --> 01:24:16,190
所以我们不想实例化--我们不会

1631
01:24:16,190 --> 01:24:19,827
真的很担心在我们的迷宫生成器中导航y轴 

1632
01:24:19,827 --> 01:24:22,160
因为我们要做的就是实例化四个块

1633
01:24:22,160 --> 01:24:25,400
在那个阶段的y轴上 

1634
01:24:25,400 --> 01:24:30,470
所以我们基本上是拿我们的二维数组 我们迭代它xy 

1635
01:24:30,470 --> 01:24:36,110
然后我们将其映射到Unity的XZ 如果这有意义的话 

1636
01:24:36,110 --> 01:24:41,670
因为注意--这是我们的地盘 对吧？

1637
01:24:41,670 --> 01:24:46,430
所以在这个变换的位置 你可以看到地面 这是怎样的x 

1638
01:24:46,430 --> 01:24:48,320
蓝色是z 

1639
01:24:48,320 --> 01:24:50,467
Y是这里的轴 

1640
01:24:50,467 --> 01:24:53,300
我们正在产生--我们实际上只关心产生

1641
01:24:53,300 --> 01:24:55,460
在地面上 然后当我们产生一堵墙时 我们只是

1642
01:24:55,460 --> 01:24:57,110
在y线上四个街区高的地方生成它 

1643
01:24:57,110 --> 01:24:59,300
我们不考虑y 

1644
01:24:59,300 --> 01:25:02,990
这就是为什么我们的二维数组是x和y 但x

1645
01:25:02,990 --> 01:25:08,270
以及z 用于将该数组应用于Unity的3D坐标系 

1646
01:25:08,270 --> 01:25:10,580
这说得通吗？

1647
01:25:10,580 --> 01:25:12,110
好的 

1648
01:25:12,110 --> 01:25:15,830
所以我们在z和x上迭代 

1649
01:25:15,830 --> 01:25:20,330
然后我们索引到我们的地图数据z和x 这

1650
01:25:20,330 --> 01:25:22,910
与y和x完全是一回事 

1651
01:25:22,910 --> 01:25:25,610
然后 我们正在创建一个儿童预制件 

1652
01:25:25,610 --> 01:25:29,150
如果地图数据z x 

1653
01:25:29,150 --> 01:25:34,640
回想一下 我们的地图数据是一个二维布尔数组 

1654
01:25:34,640 --> 01:25:39,760
所以如果我们的地图数据z x等于真 那就意味着那里有一堵墙 

1655
01:25:39,760 --> 01:25:42,060
这意味着我们的数组中有一个真的 

1656
01:25:42,060 --> 01:25:45,930
因此 我们应该在该位置实例化一堵墙 

1657
01:25:45,930 --> 01:25:49,439
因此 我们创建了三个墙预制板 将它们分配给墙父节点

1658
01:25:49,439 --> 01:25:51,230
这样它们就会被装在里面

1659
01:25:51,230 --> 01:25:52,938
这样它们就不会妨碍我们的层次结构视图 

1660
01:25:56,206 --> 01:26:01,810
然后--让我看看这个 

1661
01:26:04,430 --> 01:26:06,140
所以如果我们不--

1662
01:26:06,140 --> 01:26:09,550
所以 如果我们已经走进了迷宫 如果我们正在生成迷宫 

1663
01:26:09,550 --> 01:26:14,800
我们看到的第一块瓷砖实际上不是一堵墙 

1664
01:26:14,800 --> 01:26:16,610
所以这是一个空旷的空间--

1665
01:26:16,610 --> 01:26:18,950
所以基本上 这里的其他部分 

1666
01:26:18,950 --> 01:26:22,010
因此 如果映射数据ZX不为真 那么它也将为假 

1667
01:26:22,010 --> 01:26:26,470
因此 如果是这样的话 如果没有放置字符--

1668
01:26:26,470 --> 01:26:28,362
因此 放置的字符只是一个布尔值 

1669
01:26:28,362 --> 01:26:29,320
这是一个私人布尔值 

1670
01:26:29,320 --> 01:26:31,180
我们不希望这在我们的检查员中可见 

1671
01:26:31,180 --> 01:26:33,555
让它在我们的检查员身上出现是没有意义的 

1672
01:26:33,555 --> 01:26:36,880
这只是我们在脚本中使用的布尔值 

1673
01:26:36,880 --> 01:26:39,370
因此 我们默认将其设置为FALSE 因为我们

1674
01:26:39,370 --> 01:26:40,910
还没有把我们的角色放进去 

1675
01:26:40,910 --> 01:26:42,826
但当我们产生迷宫时 我们必须

1676
01:26:42,826 --> 01:26:45,370
当然 我们把我们的角色放在了一个没有墙的地方 

1677
01:26:45,370 --> 01:26:47,578
因为我们显然不想让他被困在墙里

1678
01:26:47,578 --> 01:26:50,080
或者在迷宫中穿行 对吧？

1679
01:26:50,080 --> 01:26:54,550
因此 如果没有放置字符 我们将设置字符控制器的

1680
01:26:54,550 --> 01:26:55,570
变形 

1681
01:26:55,570 --> 01:26:58,760
我们将感知位置和旋转 这是一个函数 

1682
01:26:58,760 --> 01:27:04,720
我们要把它设为x 然后是y1 然后是z 

1683
01:27:04,720 --> 01:27:08,620
然后没有旋转 所以四元数点的身份 

1684
01:27:08,620 --> 01:27:09,860
然后将其设置为真 

1685
01:27:09,860 --> 01:27:12,149
因此 这将永远不会再被调用 

1686
01:27:12,149 --> 01:27:14,440
因此 这只在第一个空格上调用

1687
01:27:14,440 --> 01:27:18,520
我们要穿过迷宫 

1688
01:27:18,520 --> 01:27:21,610
就这样了 

1689
01:27:21,610 --> 01:27:26,890
当我们--不管我们做什么 不管迷宫里有没有墙 

1690
01:27:26,890 --> 01:27:29,860
我们会想要在那个空间创造一个地板和一个天花板 

1691
01:27:29,860 --> 01:27:33,325
所以--当然 这是假设产生屋顶

1692
01:27:33,325 --> 01:27:37,000
是真的吗 回想一下 我们在检查器中公开了一个布尔值

1693
01:27:37,000 --> 01:27:40,580
这样我就可以调试并向你们展示从上面看迷宫是什么样子 

1694
01:27:40,580 --> 01:27:42,850
因此 如果生成屋顶--

1695
01:27:42,850 --> 01:27:48,550
为x 4 z的天花板预制板创建子预制板 因此稍微高一点 

1696
01:27:48,550 --> 01:27:51,760
然后不管怎样 总是想要一层楼 

1697
01:27:51,760 --> 01:27:55,570
因此 在x 0 z处创建地板预制板 

1698
01:27:55,570 --> 01:27:56,910
所以在下面 

1699
01:27:56,910 --> 01:27:59,450
我们的角色控制器被放置在 Recall x1 z 

1700
01:27:59,450 --> 01:28:02,020
所以就在地板上方 

1701
01:28:02,020 --> 01:28:05,500
作业实际上是--作业的一部分

1702
01:28:05,500 --> 01:28:08,730
在地板上挖个洞 

1703
01:28:08,730 --> 01:28:13,140
如果地板上有个洞 角色从洞里掉了下来 

1704
01:28:13,140 --> 01:28:14,390
比赛应该结束了 对吧？

1705
01:28:14,390 --> 01:28:16,515
所以你需要在场景上创建一个游戏

1706
01:28:16,515 --> 01:28:18,170
或者我们需要过渡到那个场景 

1707
01:28:18,170 --> 01:28:22,000
然后我们需要检查角色的变形

1708
01:28:22,000 --> 01:28:25,150
已经跌破了一定的数量 

1709
01:28:25,150 --> 01:28:27,520
这都是相当容易做的事情 

1710
01:28:27,520 --> 01:28:29,920
但你会希望在这里做一些这样的事情 

1711
01:28:29,920 --> 01:28:33,560
然后实际的迷宫数据函数就在这里 

1712
01:28:33,560 --> 01:28:36,490
我不会详细介绍它 但它是算法

1713
01:28:36,490 --> 01:28:40,770
我们之前谈过的 我们选择随机移动的方向 

1714
01:28:40,770 --> 01:28:43,240
我们随机选择一些步数来移动 

1715
01:28:43,240 --> 01:28:45,880
把这个值限制在迷宫的约束范围内 

1716
01:28:45,880 --> 01:28:50,660
然后将我们探索的每一块瓷砖都设置为假 

1717
01:28:50,660 --> 01:28:52,540
这就产生了创造迷宫的效果 

1718
01:28:52,540 --> 01:28:56,280
然后我们只需将该数据作为2D数组返回给我们的函数 

1719
01:28:56,280 --> 01:28:59,989
请注意 在C Sharp中 要创建2D数组 

1720
01:28:59,989 --> 01:29:02,530
它与许多其他语言有一点不同 

1721
01:29:02,530 --> 01:29:04,114
对于这一点 它有自己的一套语法 

1722
01:29:04,114 --> 01:29:06,654
您可能已经熟悉了数组语法 

1723
01:29:06,654 --> 01:29:08,310
但是你还有这个逗号 

1724
01:29:08,310 --> 01:29:12,790
这个逗号表示该索引有两个参数

1725
01:29:12,790 --> 01:29:13,780
这里有语法 

1726
01:29:13,780 --> 01:29:18,000
基本上就是说x应该放在这里 y应该放在那里 

1727
01:29:18,000 --> 01:29:19,060
或者y x 

1728
01:29:19,060 --> 01:29:20,720
这就是二维数组 

1729
01:29:20,720 --> 01:29:23,740
你可以把它变成你想要的任何一个学位 

1730
01:29:23,740 --> 01:29:26,300
只需添加更多逗号即可 

1731
01:29:26,300 --> 01:29:32,350
注意 要为这个2D数组实际分配我们想要的内存--

1732
01:29:32,350 --> 01:29:35,170
新布尔 迷宫大小 迷宫大小 

1733
01:29:35,170 --> 01:29:37,120
所以我们的迷宫总是方形的 

1734
01:29:37,120 --> 01:29:40,690
同样的--你可以很容易地做出这个迷宫

1735
01:29:40,690 --> 01:29:43,630
X 迷宫y 如果你想的话 把它变成矩形 

1736
01:29:43,630 --> 01:29:48,100
因此 您需要有两个公共变量 而不是一个 

1737
01:29:48,100 --> 01:29:51,170
而所有这一切对检查员来说也是相当明显的 

1738
01:29:51,170 --> 01:29:55,480
在我们的地牢发电机中 你可以看到我做了一个要移除的瓷砖 350 

1739
01:29:55,480 --> 01:29:58,360
这意味着我们的迷宫将切割出350块瓷砖 

1740
01:29:58,360 --> 01:30:01,030
一旦切割出350块瓷砖 它就完成了 

1741
01:30:01,030 --> 01:30:03,250
然后我们的迷宫大小是30乘30 

1742
01:30:03,250 --> 01:30:06,620
这意味着我们的迷宫里将会有900块瓷砖 

1743
01:30:06,620 --> 01:30:09,100
所以你可以为你想要的任何东西量身定做

1744
01:30:09,100 --> 01:30:15,850
根据您的喜好生成稀疏或密集的迷宫 

1745
01:30:15,850 --> 01:30:21,060
有什么问题吗 代码是怎么工作的？

1746
01:30:21,060 --> 01:30:22,900
差不多吧

1747
01:30:22,900 --> 01:30:25,910
现在我们来看看场景部分 

1748
01:30:25,910 --> 01:30:27,100
所以在两个...

1749
01:30:27,100 --> 01:30:29,060
哦是的

1750
01:30:29,060 --> 01:30:31,510
观众：我想 就像 一个小的

1751
01:30:31,510 --> 01:30:32,980
像这样的游戏 效果很好 

1752
01:30:32,980 --> 01:30:35,920
但是对于一个更大的游戏 你不想把墙建模吗？

1753
01:30:35,920 --> 01:30:42,300
像是2D的物体 天花板 而不是一个整体的立方体？

1754
01:30:42,300 --> 01:30:43,540
科尔顿·奥格登：哦 是的 

1755
01:30:43,540 --> 01:30:46,750
所以对于一个小游戏来说 它是理想的吗？

1756
01:30:46,750 --> 01:30:51,880
更理想的是将墙壁渲染为一个离散对象 

1757
01:30:51,880 --> 01:30:53,840
几个立方体？

1758
01:30:53,840 --> 01:30:55,180
当然了

1759
01:30:55,180 --> 01:30:56,380
这是百分之百的正确 

1760
01:30:56,380 --> 01:31:00,460
实际上 《我的世界》就是一个例子

1761
01:31:00,460 --> 01:31:03,040
你认为可行 但实际上

1762
01:31:03,040 --> 01:31:06,010
用这种方法生成几何图形后 

1763
01:31:06,010 --> 01:31:10,847
并生产出更优化的模型 

1764
01:31:10,847 --> 01:31:13,180
你认为你在和这个世界互动

1765
01:31:13,180 --> 01:31:15,187
一堆这些小块 都是分开的

1766
01:31:15,187 --> 01:31:17,020
但它实际上是一大块几何图形 

1767
01:31:17,020 --> 01:31:19,900
然后它会动态地计算出你击中的位置 

1768
01:31:19,900 --> 01:31:22,060
并根据需要添加块 

1769
01:31:22,060 --> 01:31:25,026
YouTube上有一些很酷的视频 介绍如何在Unity中做到这一点 

1770
01:31:25,026 --> 01:31:26,650
我很久以前也看过

1771
01:31:26,650 --> 01:31:27,970
这就像是在告诉你

1772
01:31:27,970 --> 01:31:31,600
你可以在Unity中动态地创建网格和顶点 

1773
01:31:31,600 --> 01:31:34,970
然后以这种方式创建对象 这真的很酷 

1774
01:31:34,970 --> 01:31:37,620
但这是一个更先进的一面 

1775
01:31:37,620 --> 01:31:38,560
但是 是的 绝对 

1776
01:31:38,560 --> 01:31:43,090
为了实际实现这一点 一个简单但更有效的方法

1777
01:31:43,090 --> 01:31:48,070
要做到这一点 只需要一个坚固的 大的 墙壁物体 

1778
01:31:48,070 --> 01:31:50,590
你需要它多高就有多高 

1779
01:31:50,590 --> 01:31:54,220
一个角色需要多大的宽度 就有多大的宽度 

1780
01:31:54,220 --> 01:31:56,760
但为了简单起见 为了说明算法 

1781
01:31:56,760 --> 01:32:00,400
我们只是在用立方体

1782
01:32:00,400 --> 01:32:01,030
是啊

1783
01:32:01,030 --> 01:32:02,500
不过 说得对 

1784
01:32:02,500 --> 01:32:05,270
这是百分之百的正确 

1785
01:32:05,270 --> 01:32:07,810
好吧 多个场景 

1786
01:32:07,810 --> 01:32:11,080
所以我们这样做的方式--

1787
01:32:11,080 --> 01:32:14,320
所以我要打开我的文本编辑器 

1788
01:32:14,320 --> 01:32:22,290
哎呀 所以--抢皮卡脚本 

1789
01:32:22,290 --> 01:32:29,640
抓取拾取器是一个连接到角色控制器的组件 

1790
01:32:29,640 --> 01:32:33,600
因为他要去接人

1791
01:32:33,600 --> 01:32:38,100
抓取拾取脚本有效地做的是 

1792
01:32:38,100 --> 01:32:43,710
字符控制器内置碰撞

1793
01:32:43,710 --> 01:32:47,040
有一个你可以定义的函数叫做控制器碰撞器

1794
01:32:47,040 --> 01:32:51,480
碰撞 任何与控制器的碰撞器碰撞的东西

1795
01:32:51,480 --> 01:32:53,700
将触发此回调函数 

1796
01:32:53,700 --> 01:32:59,790
你就能得到你撞到的物体的信息

1797
01:32:59,790 --> 01:33:02,530
然后在上面执行某种逻辑 

1798
01:33:02,530 --> 01:33:05,040
所以它每次都在调用这个函数

1799
01:33:05,040 --> 01:33:09,951
我们也会与场景中的任何瓦片或块发生碰撞 

1800
01:33:09,951 --> 01:33:11,700
只是没有逻辑来解释它们 

1801
01:33:11,700 --> 01:33:14,820
所以它实际上只是一个空函数调用 

1802
01:33:14,820 --> 01:33:24,840
但是如果游戏对象有一个拾取的标签 

1803
01:33:24,840 --> 01:33:28,460
我们已经在Unity编辑器中设置好了 我会告诉你怎么做--

1804
01:33:28,460 --> 01:33:32,730
那么我们应该播放一个来自拾音声源的声音 

1805
01:33:32,730 --> 01:33:34,020
然后我们应该

1806
01:33:34,020 --> 01:33:37,590
你在上节课就用过这个

1807
01:33:37,590 --> 01:33:39,480
但只是在同一个场景中 

1808
01:33:39,480 --> 01:33:43,500
我们要叫场景经理点载入场景 播放 

1809
01:33:43,500 --> 01:33:46,440
你需要Unity引擎点场景管理 

1810
01:33:46,440 --> 01:33:49,770
在脚本顶部使用Unity引擎点场景管理

1811
01:33:49,770 --> 01:33:51,720
才能用上这个

1812
01:33:51,720 --> 01:33:54,690
和加载场景有效地只是将字面上只是

1813
01:33:54,690 --> 01:33:56,850
按名称加载场景 

1814
01:33:56,850 --> 01:33:58,790
我们正在几个地方这样做 

1815
01:33:58,790 --> 01:34:00,165
所以我们真的在那里做 

1816
01:34:00,165 --> 01:34:04,590
但请记住 我们有标题场景 其中有同样的事情 

1817
01:34:04,590 --> 01:34:08,790
你按下回车键 然后加载游戏场景 对吗？

1818
01:34:08,790 --> 01:34:12,600
我创建的输入组件上的负载场景

1819
01:34:12,600 --> 01:34:17,490
附加到标题场景中的文本字段 

1820
01:34:17,490 --> 01:34:19,870
我们在这里做的就是更新 

1821
01:34:19,870 --> 01:34:27,850
我们只是说 如果输入点获取访问提交等于1 

1822
01:34:27,850 --> 01:34:29,980
然后场景管理器点加载场景播放 

1823
01:34:29,980 --> 01:34:33,480
几乎相同--几乎相同的代码 只是在本例中

1824
01:34:33,480 --> 01:34:35,585
我们正在询问Unity的输入 

1825
01:34:35,585 --> 01:34:39,160
它有一个全局输入管理器GET AXIS 

1826
01:34:39,160 --> 01:34:41,490
所以它有几个轴 这是它定义它的方式 

1827
01:34:41,490 --> 01:34:44,250
不同的输入方法 

1828
01:34:44,250 --> 01:34:48,610
然后它通过关键字来定义它们 所以在本例中Submit是一个关键字 

1829
01:34:48,610 --> 01:34:52,170
然后你定义--你映射那些键--

1830
01:34:52,170 --> 01:34:55,740
或者将这些关键字映射到特定的键和输入源

1831
01:34:55,740 --> 01:34:57,330
无论你的目标是什么平台 

1832
01:34:57,330 --> 01:35:01,410
在这种情况下 提交与Enter或Return同义 

1833
01:35:01,410 --> 01:35:03,300
这取决于我们使用的平台 

1834
01:35:03,300 --> 01:35:07,380
如果我们将它导出到Xbox 它可能有其他含义

1835
01:35:07,380 --> 01:35:09,840
或者如果我们要将其输出到网络上 或者如果我们

1836
01:35:09,840 --> 01:35:11,460
将其输出到手机上 

1837
01:35:11,460 --> 01:35:14,740
它有很多不同的变化方式 

1838
01:35:14,740 --> 01:35:19,214
所以它检查的方式是0或1 

1839
01:35:19,214 --> 01:35:21,630
具体地说 所以我们可以说如果输入点获得访问提交

1840
01:35:21,630 --> 01:35:25,840
等于1 场景管理器加载场景播放 

1841
01:35:25,840 --> 01:35:31,290
如果输入不能获得访问提交 它就不允许这样做 因为它显式地

1842
01:35:31,290 --> 01:35:33,690
应为整型 如果为

1843
01:35:33,690 --> 01:35:35,520
试着像使用布尔值一样使用它 

1844
01:35:35,520 --> 01:35:42,870
所以我们需要使用这个等于 等于1来检验等价性 

1845
01:35:42,870 --> 01:35:44,760
这就是我们在那里有效地做的所有事情 

1846
01:35:47,290 --> 01:35:57,540
现在 有趣的是 当我们重新加载场景以进行取景时

1847
01:35:57,540 --> 01:36:01,500
对于迷宫 背景中播放着一段配乐 

1848
01:36:01,500 --> 01:36:05,370
我们希望原声带一直播放相同的东西

1849
01:36:05,370 --> 01:36:07,680
以及循环 对吗？

1850
01:36:07,680 --> 01:36:10,650
音效--我们不希望它立即再次启动

1851
01:36:10,650 --> 01:36:12,840
从头再来 

1852
01:36:12,840 --> 01:36:15,900
我们有点想要这种无缝的感觉 

1853
01:36:15,900 --> 01:36:18,960
那么我们认为我们可以如何解决这个问题呢？

1854
01:36:24,014 --> 01:36:25,680
观众：那么它什么时候不会再播放了？

1855
01:36:25,680 --> 01:36:27,727
当你重新加载场景的时候？

1856
01:36:27,727 --> 01:36:28,560
科尔顿·奥格登：什么？

1857
01:36:28,560 --> 01:36:30,420
观众：当你重新加载场景时 你不想重新开始吗？

1858
01:36:30,420 --> 01:36:31,336
科尔顿·奥格登：正确 

1859
01:36:35,070 --> 01:36:37,120
你有什么想法吗

1860
01:36:37,120 --> 01:36:39,680
观众：把第一级只放在一开始还是什么？

1861
01:36:39,680 --> 01:36:41,130
[听不见]

1862
01:36:41,130 --> 01:36:43,830
科尔顿·奥格登：嗯 所以每当我们与皮卡相撞时 

1863
01:36:43,830 --> 01:36:46,269
我们从头开始重新加载场景

1864
01:36:46,269 --> 01:36:48,810
所以当你重新加载一个场景时 它会破坏所有的游戏对象

1865
01:36:48,810 --> 01:36:51,000
在场景中 包括所有的对象 

1866
01:36:51,000 --> 01:36:53,380
都有音频源

1867
01:36:53,380 --> 01:36:55,650
所以当它重新加载场景时 

1868
01:36:55,650 --> 01:36:58,691
场景中的所有游戏对象 包括那些具有音频源的对象 

1869
01:36:58,691 --> 01:37:00,660
并重新启动他们的游戏 

1870
01:37:00,660 --> 01:37:03,933
所以我们要做的就是防止这种情况发生 

1871
01:37:03,933 --> 01:37:07,770
观众：只要有一个柜台 当你得到第一个皮卡 然后

1872
01:37:07,770 --> 01:37:09,020
就变成了1

1873
01:37:09,020 --> 01:37:12,590
如果小于1 播放声音 

1874
01:37:15,960 --> 01:37:20,170
科尔顿·奥格登：这将产生这样的效果--所以你是说有一个计数器 

1875
01:37:20,170 --> 01:37:20,670
当...

1876
01:37:20,670 --> 01:37:21,461
观众：是的 

1877
01:37:21,461 --> 01:37:22,430
真-假就行了 

1878
01:37:22,430 --> 01:37:24,780
布尔在这方面会更好 

1879
01:37:24,780 --> 01:37:28,050
科尔顿奥格登：所以有一个计数器或真假当你加载场景 

1880
01:37:28,050 --> 01:37:29,240
就会开始放音乐 

1881
01:37:29,240 --> 01:37:31,490
但是当我们从头开始重新加载场景时会发生什么呢

1882
01:37:31,490 --> 01:37:34,026
播放的音频被删除了吗

1883
01:37:34,026 --> 01:37:37,305
观众：你能在场景之间转移某些物体吗？

1884
01:37:37,305 --> 01:37:39,930
科尔顿·奥格登：你能在场景之间转移某些物体吗？

1885
01:37:39,930 --> 01:37:42,210
实际上 你可以 

1886
01:37:42,210 --> 01:37:47,440
实际上 有一个函数叫做don 't destroy on load 

1887
01:37:47,440 --> 01:37:49,560
所以这个d是一个统一函数 

1888
01:37:49,560 --> 01:37:54,490
允许您在场景之间保留对象 

1889
01:37:54,490 --> 01:38:01,620
所以如果你不想让你的音乐对象自我毁灭 

1890
01:38:01,620 --> 01:38:04,140
重新加载-

1891
01:38:04,140 --> 01:38:07,530
严格来说 就是别自毁

1892
01:38:07,530 --> 01:38:10,257
只是不要在加载时破坏游戏对象 

1893
01:38:10,257 --> 01:38:12,840
所以这不会破坏 我们把它应用到我们的音频源上--

1894
01:38:12,840 --> 01:38:14,480
我们的耳语来源 叫做

1895
01:38:14,480 --> 01:38:15,780
在场景中 

1896
01:38:15,780 --> 01:38:19,950
唯一的问题是如果我们重新

1897
01:38:19,950 --> 01:38:23,490
或者如果我们没有在加载时摧毁这个物体 它会继续存在 

1898
01:38:23,490 --> 01:38:26,220
但当我们重新加载场景时 它将实例化一个新的场景 

1899
01:38:26,220 --> 01:38:28,795
那么这将会产生什么影响呢？

1900
01:38:28,795 --> 01:38:31,420
我们将同时播放两个音频源 

1901
01:38:31,420 --> 01:38:32,920
如果我们再做一次会发生什么？

1902
01:38:32,920 --> 01:38:35,670
您将同时播放三个音频源 

1903
01:38:35,670 --> 01:38:37,381
所以每一次你进入下一个阶段 

1904
01:38:37,381 --> 01:38:39,630
您将向场景中添加相同的音轨 

1905
01:38:39,630 --> 01:38:43,150
很快就会变得非常恼人 

1906
01:38:43,150 --> 01:38:47,000
我们避免这种情况发生的方法是通过创建所谓的单例 

1907
01:38:47,000 --> 01:38:50,640
因此 单例是一个只能有效地

1908
01:38:50,640 --> 01:38:52,110
被实例化一次 

1909
01:38:54,630 --> 01:39:02,445
我们通过在这里创建一个名为不要销毁的静态变量来实现这一点 

1910
01:39:06,940 --> 01:39:09,420
不 我们称它为实例 它的类型是不破坏 

1911
01:39:09,420 --> 01:39:12,150
所以这就是这个组件 对吗？

1912
01:39:12,150 --> 01:39:15,270
所以不要破坏阶级作为一个整体

1913
01:39:15,270 --> 01:39:17,280
这个静态变量称为实例 

1914
01:39:17,280 --> 01:39:20,870
默认情况下 我们将其设置为NULL 我们还没有实例化

1915
01:39:20,870 --> 01:39:23,710
A暂时不要销毁组件 

1916
01:39:23,710 --> 01:39:28,620
在我们的场景中 通过逻辑 这确保了什么

1917
01:39:28,620 --> 01:39:31,750
在唤醒功能中 唤醒和启动几乎是一回事 

1918
01:39:31,750 --> 01:39:34,500
它的意思是无论何时--你可以暂停一个对象

1919
01:39:34,500 --> 01:39:37,560
它将从暂停状态中唤醒 

1920
01:39:37,560 --> 01:39:41,830
但是 当对象被实例化时 也会调用唤醒 

1921
01:39:41,830 --> 01:39:48,030
因此 如果实例在唤醒时设置为空 则实例等于以下值 

1922
01:39:48,030 --> 01:39:49,500
所以这不会毁了你 

1923
01:39:49,500 --> 01:39:51,660
所以 无论这是从哪里打来的 这

1924
01:39:51,660 --> 01:39:53,410
不破坏将是一个例子 

1925
01:39:53,410 --> 01:39:56,130
只要第一个不破坏组件就在我们的场景中 

1926
01:39:56,130 --> 01:39:58,710
我们制造的第一个迷宫 

1927
01:39:58,710 --> 01:40:01,530
声源实例将如下所示 

1928
01:40:01,530 --> 01:40:04,800
然后我们为游戏对象设置了加载时不破坏

1929
01:40:04,800 --> 01:40:12,120
持有不破坏或不破坏分量的音频源 

1930
01:40:12,120 --> 01:40:18,360
但是如果实例不等于这个 那么如果我们已经唤醒

1931
01:40:18,360 --> 01:40:20,870
这是2级 例如 

1932
01:40:20,870 --> 01:40:27,150
将设置为加载时不销毁组件上的不销毁组件

1933
01:40:27,150 --> 01:40:29,700
我们在第一个迷宫中创建的对象 

1934
01:40:29,700 --> 01:40:32,270
因为我们在这里做了这个逻辑 

1935
01:40:32,270 --> 01:40:37,630
所以它会尝试实例化第二个 不要破坏组件 

1936
01:40:37,630 --> 01:40:40,170
它会摧毁另一个声源 

1937
01:40:40,170 --> 01:40:41,730
但实例不会为空 

1938
01:40:41,730 --> 01:40:45,690
实例将等于第一个对象 

1939
01:40:45,690 --> 01:40:51,130
所以我们说 如果实例不等于这个 就销毁游戏对象 

1940
01:40:51,130 --> 01:40:54,660
所以这将是从第二个角度来看 不要

1941
01:40:54,660 --> 01:40:56,157
摧毁被创造出来的东西 

1942
01:40:56,157 --> 01:40:58,440
观众：所以基本上都是单身汉 

1943
01:40:58,440 --> 01:41:00,900
科尔顿·奥格登：独生子女将无限期存在

1944
01:41:00,900 --> 01:41:02,640
在其第一次实例化时 

1945
01:41:02,640 --> 01:41:04,770
而且永远只有一个独生子女 

1946
01:41:04,770 --> 01:41:07,174
这是一个非常基本、非常常见的模式

1947
01:41:07,174 --> 01:41:09,090
在软件工程中 以确保它们仅

1948
01:41:09,090 --> 01:41:12,510
在整个项目中呈现一个给定类型的对象 

1949
01:41:15,180 --> 01:41:18,720
但这就是我们防止实例化多个声源的方法 

1950
01:41:18,720 --> 01:41:21,810
我们始终确保只有一个具有该组件的对象

1951
01:41:21,810 --> 01:41:25,830
被一次实例化 并且该对象将来的任何实例化

1952
01:41:25,830 --> 01:41:28,890
假设它们不是第一个物体 立即被销毁 

1953
01:41:28,890 --> 01:41:31,560
如果它们是第一个对象 实例将不会--

1954
01:41:31,560 --> 01:41:34,450
实例将等于该值 因此它仍将跳过这一部分 

1955
01:41:34,450 --> 01:41:36,920
因此 它将继续存在 

1956
01:41:36,920 --> 01:41:40,129
所以任何关于如何在多个场景中坚持下去的问题

1957
01:41:40,129 --> 01:41:41,170
为音源工作吗？

1958
01:41:44,130 --> 01:41:46,790
好的 

1959
01:41:46,790 --> 01:41:48,210
这就是我们如何获得多个场景的原因 

1960
01:41:48,210 --> 01:41:48,952
好大的雾 

1961
01:41:48,952 --> 01:41:51,410
我们已经看到了雾 但我这里有几个截图

1962
01:41:51,410 --> 01:41:55,400
以帮助说明这些年来雾的样子 

1963
01:41:55,400 --> 01:41:57,800
因此 在这张截图中 雾看起来很难令人信服 

1964
01:41:57,800 --> 01:42:00,170
我是N64的图罗克 

1965
01:42:00,170 --> 01:42:03,740
它只是--看起来 你知道 在一定的距离上 

1966
01:42:03,740 --> 01:42:06,560
出现了一层非常浓密的雾 

1967
01:42:06,560 --> 01:42:10,900
实际上 你可以通过设置--

1968
01:42:10,900 --> 01:42:12,950
有一条曲线 一条雾曲线 我相信你

1969
01:42:12,950 --> 01:42:15,732
可以有效地操纵它--

1970
01:42:15,732 --> 01:42:18,440
确定如何将颜色与事物相加的算法

1971
01:42:18,440 --> 01:42:22,280
远距离是非常快的 而不是渐变的或线性的 

1972
01:42:22,280 --> 01:42:24,440
所以你可以让它成为指数级的 有效的 

1973
01:42:24,440 --> 01:42:27,830
让它看起来像是浓雾密布

1974
01:42:27,830 --> 01:42:30,320
几乎从一个非常固定的位置开始 并且

1975
01:42:30,320 --> 01:42:33,600
你面前这个区域的其余部分看起来都很正常 

1976
01:42:33,600 --> 01:42:35,240
这是另一个例子--

1977
01:42:35,240 --> 01:42:37,970
《星球大战帝国之影》是我最喜欢的N64游戏之一

1978
01:42:37,970 --> 01:42:39,650
有着相同的外貌 

1979
01:42:39,650 --> 01:42:43,190
所以在这个时代 你可以看到雾是非常清晰的 

1980
01:42:43,190 --> 01:42:46,040
看起来很做作 因为它的颜色很深 

1981
01:42:46,040 --> 01:42:47,570
在这种情况下 它看起来非常蓝色 

1982
01:42:47,570 --> 01:42:50,630
在这种情况下 它看起来非常淡蓝色 

1983
01:42:50,630 --> 01:42:52,070
这里是寂静山 

1984
01:42:52,070 --> 01:42:55,400
而寂静山看起来更真实 更现实 

1985
01:42:55,400 --> 01:42:58,340
但在这里也在发挥着同样的作用 

1986
01:42:58,340 --> 01:43:05,180
你有一种非常淡的灰色金属蓝色 在这种情况下 密度

1987
01:43:05,180 --> 01:43:06,460
非常高 

1988
01:43:06,460 --> 01:43:09,060
密度要高得多 

1989
01:43:09,060 --> 01:43:13,430
嗯 也许接近我们今天展示的游戏中的最高水平 

1990
01:43:13,430 --> 01:43:16,190
但它实际上是一样的 只是颜色不同 

1991
01:43:16,190 --> 01:43:20,480
他们在这里使用它产生了很大的影响 不仅仅是为了这种美感

1992
01:43:20,480 --> 01:43:24,230
让你看起来像是在某个荒凉的小镇上 

1993
01:43:24,230 --> 01:43:27,715
还可以动态加载对象或防止渲染对象

1994
01:43:27,715 --> 01:43:29,090
都在一定距离之外 

1995
01:43:29,090 --> 01:43:31,825
并优化严重受影响的硬件性能

1996
01:43:31,825 --> 01:43:33,950
当时是有限的 这是PlayStation1 它

1997
01:43:33,950 --> 01:43:36,560
是一个相当弱的游戏机 

1998
01:43:36,560 --> 01:43:40,610
然后是刚刚上映的PS4的巨人之影

1999
01:43:40,610 --> 01:43:42,770
不久前 我们可以看到雾还在继续

2000
01:43:42,770 --> 01:43:44,717
它是二手的 但看起来很逼真 

2001
01:43:44,717 --> 01:43:46,550
而且可能还有更多的东西

2002
01:43:46,550 --> 01:43:48,530
它们可能有好几层雾 

2003
01:43:48,530 --> 01:43:52,700
它们可能有纹理和透明对象

2004
01:43:52,700 --> 01:43:56,240
它们在模拟雾 以及许多更复杂的东西 

2005
01:43:56,240 --> 01:43:58,020
只在一定距离处悬挂的雾

2006
01:43:58,020 --> 01:43:59,810
所以看起来像是湖面上有雾 

2007
01:43:59,810 --> 01:44:02,250
这里有很多东西 但这是一个概念 

2008
01:44:02,250 --> 01:44:04,625
它们很可能有相同的基础

2009
01:44:04,625 --> 01:44:07,344
整个现场都有雾 

2010
01:44:07,344 --> 01:44:09,510
这是我们的游戏 只是为了展示一下它的样子 

2011
01:44:09,510 --> 01:44:10,740
你几乎看不到它 

2012
01:44:10,740 --> 01:44:12,980
但它确实让你有一种迷失的感觉

2013
01:44:12,980 --> 01:44:17,840
在一种非常危险的迷宫感觉中 这--这非常容易做到 

2014
01:44:17,840 --> 01:44:21,470
它可以节省您的性能 还可以增加许多美感

2015
01:44:21,470 --> 01:44:23,000
为了你的比赛 

2016
01:44:23,000 --> 01:44:27,070
因此 我们今天要讨论的最后一件大事实际上是Unity 2D 

2017
01:44:27,070 --> 01:44:28,925
所以我要回到--

2018
01:44:28,925 --> 01:44:29,945
哦 关于雾的问题 

2019
01:44:29,945 --> 01:44:31,820
我知道这是一个相当高层次的概述 

2020
01:44:31,820 --> 01:44:33,800
我们看了一下它是如何应用的

2021
01:44:33,800 --> 01:44:39,540
关于它是如何工作的 或者如何在Unity中找到工作的设置和问题？

2022
01:44:39,540 --> 01:44:40,910
好的 

2023
01:44:40,910 --> 01:44:45,350
所以我们要继续 看看我们的片名场景 

2024
01:44:45,350 --> 01:44:47,730
所以我们在前面简单地看了一下 

2025
01:44:47,730 --> 01:44:50,140
但我想继续向你们展示组件 

2026
01:44:50,140 --> 01:44:51,890
所以我要看看我们的画布 

2027
01:44:51,890 --> 01:44:54,859
如果你双击某个东西 你就会缩小 

2028
01:44:54,859 --> 01:44:57,650
所以它会自动检测你的分辨率是什么

2029
01:44:57,650 --> 01:45:01,220
并在场景视图中相应地缩放画布 

2030
01:45:01,220 --> 01:45:02,850
这里有一个2D按钮 

2031
01:45:02,850 --> 01:45:06,460
我将继续并转到我的默认布局 

2032
01:45:06,460 --> 01:45:09,974
我要点击画布 

2033
01:45:09,974 --> 01:45:12,890
请注意 它改变了一些东西 因为现在我有了一个更大的

2034
01:45:12,890 --> 01:45:15,340
要渲染到的窗口 

2035
01:45:15,340 --> 01:45:19,220
我要点击画布 然后进入2D模式 

2036
01:45:19,220 --> 01:45:22,670
然后请注意 当您点击2D和3D模式时 

2037
01:45:22,670 --> 01:45:26,690
你马上就能看到它 就好像你在操纵它

2038
01:45:26,690 --> 01:45:28,610
在2D引擎和3D引擎中 

2039
01:45:28,610 --> 01:45:31,300
然后回到3D 现在它是一个三维平面

2040
01:45:31,300 --> 01:45:32,930
你实际上看到的是 

2041
01:45:32,930 --> 01:45:37,220
因此 在2D模式下 您可以轻松地导航它 右键单击并拖动它

2042
01:45:37,220 --> 01:45:38,492
四处转转 

2043
01:45:38,492 --> 01:45:40,970
我要走到这里 就像这样 

2044
01:45:40,970 --> 01:45:44,120
这些都是非常简单的组件 您可以

2045
01:45:44,120 --> 01:45:45,980
以图形用户界面的形式与交互 

2046
01:45:45,980 --> 01:45:50,030
现在 你需要做的主要事情是让这些东西发挥作用

2047
01:45:50,030 --> 01:45:52,470
就是画布 就在这里 

2048
01:45:52,470 --> 01:45:58,760
因此 如果您右键单击 然后转到UI 您可以转到Canvas 如果您愿意 

2049
01:45:58,760 --> 01:46:02,010
或者你可以添加任何你想要的东西 

2050
01:46:02,010 --> 01:46:04,400
它会自动为你添加一个画布 

2051
01:46:04,400 --> 01:46:09,300
因为所有的Unity UI渲染都需要一个画布 

2052
01:46:09,300 --> 01:46:12,380
因此 如果我只是在一个空的场景中添加一个文本 

2053
01:46:12,380 --> 01:46:17,810
它只会创造一个全新的画布和活动体系 

2054
01:46:17,810 --> 01:46:23,240
事件系统就是Unity与画布和所有用户界面对话的方式

2055
01:46:23,240 --> 01:46:27,170
画布的元素 给鼠标和键盘输入之类的东西 

2056
01:46:27,170 --> 01:46:31,460
它不是你必须担心或使用的东西 

2057
01:46:31,460 --> 01:46:36,440
但画布是所有图形用户界面内容的整体容器

2058
01:46:36,440 --> 01:46:37,400
你就是这么想的 

2059
01:46:37,400 --> 01:46:40,350
现在 如果我点击磁贴文本或回车文本 

2060
01:46:40,350 --> 01:46:42,481
请注意 它们是画布的子项 

2061
01:46:42,481 --> 01:46:43,730
因此 他们都在画布上 

2062
01:46:43,730 --> 01:46:45,170
画布是它们的父对象 

2063
01:46:45,170 --> 01:46:46,940
标题文本 我可以移动它 

2064
01:46:46,940 --> 01:46:48,710
请注意 它会捕捉 

2065
01:46:48,710 --> 01:46:51,430
它有我的抓拍功能 

2066
01:46:51,430 --> 01:46:54,420
我可以把它放在那里 它会卡在上面 

2067
01:46:54,420 --> 01:46:55,430
它会--是的 

2068
01:46:55,430 --> 01:46:56,570
这很方便 

2069
01:46:56,570 --> 01:46:59,420
您可以缩放边界框 

2070
01:46:59,420 --> 01:47:02,240
它不会缩放实际的文本 但--

2071
01:47:02,240 --> 01:47:06,230
请注意 我确实有正确的理由 

2072
01:47:06,230 --> 01:47:08,480
居中 左对齐 

2073
01:47:08,480 --> 01:47:11,190
那些帮助--

2074
01:47:11,190 --> 01:47:12,880
这类特征 

2075
01:47:12,880 --> 01:47:16,910
我可以通过滑块增加字体大小 这样我就可以立即

2076
01:47:16,910 --> 01:47:19,790
无需编辑一些代码即可查看 然后

2077
01:47:19,790 --> 01:47:23,660
重新加载项目 更改其中一些值将是什么样子 

2078
01:47:23,660 --> 01:47:25,820
我可以很容易地实时改变颜色 

2079
01:47:25,820 --> 01:47:27,800
这样我就能感觉到它看起来是什么样子 

2080
01:47:27,800 --> 01:47:32,870
如果你想要一种粘乎乎的 恐怖的50看 我想 

2081
01:47:32,870 --> 01:47:36,110
还可以将材质指定给 这是一种很酷的方式 

2082
01:47:36,110 --> 01:47:39,070
我没有太详细地探讨这一点 但你有这个选择 

2083
01:47:39,070 --> 01:47:46,130
如果要为其提供材质而不是颜色 请使用物化字体 

2084
01:47:46,130 --> 01:47:48,860
因为归根结底 所有这些东西仍然是3D的 

2085
01:47:48,860 --> 01:47:50,930
但Unity以一种让它看起来像是

2086
01:47:50,930 --> 01:47:52,460
就像你在2D中与它互动一样 

2087
01:47:52,460 --> 01:47:53,000
真的很不错 

2088
01:47:53,000 --> 01:47:55,333
观众：当你把它变成2D形式 当你点击Play时 

2089
01:47:55,333 --> 01:47:56,970
它会向那个敞开大门吗？

2090
01:47:56,970 --> 01:47:57,720
科尔顿·奥格登：是的 

2091
01:47:57,720 --> 01:48:00,740
观众：然后你如何过渡到游戏的其他部分呢？

2092
01:48:00,740 --> 01:48:03,031
科尔顿·奥格登：所以过渡到比赛的其他部分

2093
01:48:03,031 --> 01:48:06,740
是在这里输入的加载场景中 

2094
01:48:06,740 --> 01:48:09,480
所以我们之前看过的剧本 

2095
01:48:09,480 --> 01:48:11,630
因此 这被分配给其中一个文本标签 

2096
01:48:11,630 --> 01:48:12,960
所以我就把它给了--

2097
01:48:12,960 --> 01:48:14,090
我忘了 

2098
01:48:14,090 --> 01:48:15,370
我想是回车文本的问题 

2099
01:48:15,370 --> 01:48:19,610
所以我在输入时给了它这个加载场景 仅仅因为它是Enter文本 

2100
01:48:19,610 --> 01:48:22,197
这看起来很合适 

2101
01:48:22,197 --> 01:48:23,780
可以把它放在现场的任何东西上 

2102
01:48:23,780 --> 01:48:24,710
无所谓 

2103
01:48:24,710 --> 01:48:26,600
只要它有这个更新功能 

2104
01:48:26,600 --> 01:48:30,995
如果输入点获取访问提交等于1 那么就有这个 然后回想一下--

2105
01:48:33,530 --> 01:48:37,640
进入项目设置 输入 

2106
01:48:37,640 --> 01:48:41,430
所有这些轴都是自动为您定义的 

2107
01:48:41,430 --> 01:48:45,200
然后 您可以选择它们映射到什么 但提交 如您所见 

2108
01:48:45,200 --> 01:48:47,880
肯定按钮是Return 

2109
01:48:47,880 --> 01:48:51,440
因此 如果提交等于1 当您按Return时 它将等于1 

2110
01:48:51,440 --> 01:48:52,880
有效地 

2111
01:48:52,880 --> 01:48:55,130
它会被映射到其他按钮 具体取决于

2112
01:48:55,130 --> 01:48:59,250
输入您设备上的信号源 

2113
01:48:59,250 --> 01:49:01,550
但你可以在你的电脑上查看它是什么

2114
01:49:01,550 --> 01:49:04,190
只需转到输入管理器中的轴 

2115
01:49:04,190 --> 01:49:07,580
所以 再一次 编辑 项目设置 输入 

2116
01:49:07,580 --> 01:49:09,423
然后你可以看到这里所有的轴 

2117
01:49:09,423 --> 01:49:12,595
观众：所以 2D场景本身就是一个场景 

2118
01:49:12,595 --> 01:49:14,720
科尔顿·奥格登：这本身就是一个场景 完全是 

2119
01:49:14,720 --> 01:49:17,534
它有摄像头 所以我们--

2120
01:49:17,534 --> 01:49:19,325
摄像机渲染--关于画布的事情

2121
01:49:19,325 --> 01:49:21,170
它是一种与摄像机分开的东西 

2122
01:49:21,170 --> 01:49:25,590
所以它被单独渲染到相机渲染的任何东西上 

2123
01:49:25,590 --> 01:49:28,100
但在这种情况下的摄像机 我所做的 

2124
01:49:28,100 --> 01:49:30,980
因为如果默认情况下我们只渲染相机和用户界面 

2125
01:49:30,980 --> 01:49:32,450
它看起来就像这样 

2126
01:49:32,450 --> 01:49:35,420
它将看起来像是恐怖50的天空 然后按Enter 

2127
01:49:35,420 --> 01:49:40,170
这不是我们想要的美学 所以我拿着相机 

2128
01:49:40,170 --> 01:49:41,960
然后你可以给它一个背景 

2129
01:49:41,960 --> 01:49:45,910
所以默认情况下 背景是天空 就是天空盒子 

2130
01:49:45,910 --> 01:49:48,630
因此 我设置了明确的旗帜 

2131
01:49:48,630 --> 01:49:50,710
清晰的旗帜和背景是一样的 

2132
01:49:50,710 --> 01:49:54,270
所以不管怎样 没有几何学之类的东西 

2133
01:49:54,270 --> 01:49:57,900
透明--这个清晰的颜色 清晰的旗帜 这个

2134
01:49:57,900 --> 01:50:01,042
基本上是在场景中的任何几何体之前绘制 

2135
01:50:03,600 --> 01:50:05,940
所以清晰的旗帜 在这种情况下是纯色的 

2136
01:50:05,940 --> 01:50:08,250
然后是黑色 使用颜色选择器 

2137
01:50:08,250 --> 01:50:11,220
所以超级简单 超级美好 

2138
01:50:11,220 --> 01:50:16,000
然后这个用户界面 这个画布 将被画在这个相机的顶部 

2139
01:50:16,000 --> 01:50:20,850
这就是产生用户界面的综合效果的原因

2140
01:50:20,850 --> 01:50:22,950
文本 然后是黑色背景 

2141
01:50:22,950 --> 01:50:25,860
然后输入具有该组件的文本 

2142
01:50:25,860 --> 01:50:30,090
这将检查提交输入 因为这就是回车和返回映射的位置 

2143
01:50:30,090 --> 01:50:39,346
这就是让我们从当前场景过渡到游戏场景的原因 

2144
01:50:39,346 --> 01:50:41,220
所以还有很多其他很酷的功能

2145
01:50:41,220 --> 01:50:45,540
这些标签之类的东西 

2146
01:50:45,540 --> 01:50:49,170
例如 能够设置其锚位置 

2147
01:50:49,170 --> 01:50:53,310
因此 根据您要运送到的设备 您可能需要--

2148
01:50:53,310 --> 01:50:57,690
你知道 你将拥有多种屏幕尺寸和屏幕分辨率 

2149
01:50:57,690 --> 01:51:01,830
所以你可以说 我希望这个标签永远

2150
01:51:01,830 --> 01:51:06,870
站在我的场景的最上方 我可以做到

2151
01:51:06,870 --> 01:51:11,550
通过点击这里的这个小方框 它是锚点选择器 

2152
01:51:11,550 --> 01:51:13,360
然后点击就可以了 

2153
01:51:13,360 --> 01:51:16,560
因此 这将始终将DRead50‘S的文本锚定在该中间上方 

2154
01:51:16,560 --> 01:51:18,610
无论我们的决心是什么 

2155
01:51:18,610 --> 01:51:21,510
它将永远在那里 

2156
01:51:21,510 --> 01:51:28,080
除此之外 你还可以做很多事情 

2157
01:51:28,080 --> 01:51:31,740
您可以使用任何UI组件执行此操作 只需相对定位即可

2158
01:51:31,740 --> 01:51:33,210
根据分辨率的不同 

2159
01:51:33,210 --> 01:51:35,712
而团结的好处也是 如果你去看游戏 

2160
01:51:35,712 --> 01:51:37,920
你实际上可以选择--对不起 在第二个菜单中--

2161
01:51:37,920 --> 01:51:39,780
您可以选择很多纵横比 

2162
01:51:39,780 --> 01:51:42,030
所以5点04分看起来不太好 

2163
01:51:42,030 --> 01:51:43,920
4点03分看起来不太好 

2164
01:51:43,920 --> 01:51:48,910
16：10 16：9 然后是独立的 

2165
01:51:48,910 --> 01:51:55,140
因此 单机版是您平台的默认导出大小 

2166
01:51:55,140 --> 01:51:58,770
但你可以选择--你可以拥有--

2167
01:51:58,770 --> 01:52:02,220
您可以测试不同的分辨率 也可以添加更多分辨率 

2168
01:52:02,220 --> 01:52:07,230
您可以添加一个固定的分辨率 如果你想 或纵横比 

2169
01:52:07,230 --> 01:52:09,899
用这种方式做很多很酷的事情 

2170
01:52:09,899 --> 01:52:12,940
因此 你不必在不同的设备上进行物理测试 

2171
01:52:12,940 --> 01:52:14,898
虽然这是非常好的 所以你可以确保

2172
01:52:14,898 --> 01:52:17,020
你不会炸毁你的硬件 

2173
01:52:17,020 --> 01:52:19,420
但你有这个选择 

2174
01:52:19,420 --> 01:52:27,090
因此 关于Unity 2D如何工作以及画布如何工作的任何问题

2175
01:52:27,090 --> 01:52:30,600
或者我们是如何让简单的用户界面工作的？

2176
01:52:30,600 --> 01:52:33,630
作业的一部分将是--我们现在就来看看 

2177
01:52:33,630 --> 01:52:35,010
事实上 

2178
01:52:35,010 --> 01:52:38,710
作业9 我们已经讨论过了 关于地板上的缝隙 

2179
01:52:38,710 --> 01:52:41,370
但这将是迷宫发电机的一部分 对吗？

2180
01:52:41,370 --> 01:52:43,170
因为这是我们最终产生的地方 

2181
01:52:43,170 --> 01:52:46,470
或者 生成--迷宫实例化程序 

2182
01:52:46,470 --> 01:52:50,340
迷宫生成器的实际部分 它创建物理迷宫 

2183
01:52:50,340 --> 01:52:52,210
但会在地板上留下缝隙 

2184
01:52:52,210 --> 01:52:56,740
然后当球员跌倒时 大约在两个街区以下 这

2185
01:52:56,740 --> 01:52:57,570
你可以设置--

2186
01:52:57,570 --> 01:53:01,190
检查转换是--y位置小于某个值 

2187
01:53:01,190 --> 01:53:04,500
它应该小于0 

2188
01:53:04,500 --> 01:53:07,810
我认为这是基于它的最高部分 

2189
01:53:07,810 --> 01:53:11,050
然后你应该过渡到一个新的屏幕上 上面写着游戏结束 

2190
01:53:11,050 --> 01:53:14,160
所以创造一个新的场景 非常类似于第一个场景

2191
01:53:14,160 --> 01:53:16,710
我们看到的 这只是标题屏幕 

2192
01:53:16,710 --> 01:53:18,570
你可能可以复制其中的大部分内容 

2193
01:53:18,570 --> 01:53:21,720
但那一幕应该是游戏结束 然后按下

2194
01:53:21,720 --> 01:53:25,890
进入那里应该加载瓷砖场景 

2195
01:53:25,890 --> 01:53:29,050
然后 最后 在剧本中添加一个文本对象

2196
01:53:29,050 --> 01:53:32,610
这个场景只记录了你通过了多少个关卡 

2197
01:53:32,610 --> 01:53:35,610
你也许可以用某种静态变量来做这件事 

2198
01:53:35,610 --> 01:53:39,090
但任何实现这一目标的解决方案都是受欢迎的 

2199
01:53:39,090 --> 01:53:43,050
但总的来说 所有这些都很容易组装在一起 

2200
01:53:43,050 --> 01:53:46,191
那是本周 这是恐怖大厅和我们的第一次突袭

2201
01:53:46,191 --> 01:53:47,190
变成了第一人称游戏 

2202
01:53:47,190 --> 01:53:48,870
下周我们将介绍门户网站 

2203
01:53:48,870 --> 01:53:52,920
它看起来不一定会这么好 但看起来会像这样 

2204
01:53:52,920 --> 01:53:55,260
这是来自门户网站本身的屏幕截图 

2205
01:53:55,260 --> 01:53:58,140
但我们将研究如何渲染到纹理 

2206
01:53:58,140 --> 01:54:01,414
我们如何从我们的角色投射光线 我们的第一人称控制器 

2207
01:54:01,414 --> 01:54:04,080
我们如何才能让它看起来像是我们有武器或枪

2208
01:54:04,080 --> 01:54:06,600
或者是传送枪 这并不太难 

2209
01:54:06,600 --> 01:54:12,870
你只有两个父母 基本上是第一人称控制器的一个模型 

2210
01:54:12,870 --> 01:54:16,837
然后 当我们穿过一个门户时 我们如何从一个门户过渡

2211
01:54:16,837 --> 01:54:17,670
去另一个传送门？

2212
01:54:17,670 --> 01:54:22,620
所以只是--你知道心灵传送 你的变形到另一个位置 

2213
01:54:22,620 --> 01:54:24,180
但仅此而已 

2214
01:54:24,180 --> 01:54:27,960
下周是门户网站 我们下次再见 
