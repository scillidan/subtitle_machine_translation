1
00:00:00,000 --> 00:00:01,964
[音乐播放]
[MUSIC PLAYING]

2
00:00:16,612 --> 00:00:17,570
大卫·马兰：好的 
DAVID MALAN: All right.

3
00:00:17,570 --> 00:00:20,340
欢迎来到游戏开发入门 
Welcome to Introduction to Game Development.

4
00:00:20,340 --> 00:00:22,820
我叫大卫·马兰 这位是科尔顿·奥格登 
My name is David Malan, and this is Colton Ogden.

5
00:00:22,820 --> 00:00:25,160
这是一个只假设CS50这样的类的类
And this is a class that assumes only a class like CS50,

6
00:00:25,160 --> 00:00:28,160
哪一所大学和推广学校是计算机导论
which is the colleges and the extension schools introduction to computer

7
00:00:28,160 --> 00:00:30,050
科学 但更普遍的是 我们只是假设
science but more generally we just assume

8
00:00:30,050 --> 00:00:32,689
你以前有过几乎所有语言的编程经验
that you have prior programming experience in most any language

9
00:00:32,689 --> 00:00:34,100
因此对一些人有一些安慰
and therefore have some comfort with some

10
00:00:34,100 --> 00:00:35,724
编程的基本结构 
of the basic constructs of programming.

11
00:00:35,724 --> 00:00:38,875
但我们假设没有Lua或Lab 2D或任何框架的背景
But we assume no background in Lua or Lab 2D or any of the frameworks

12
00:00:38,875 --> 00:00:40,250
我们会在课堂上用到 
that we'll be using in the class.

13
00:00:40,250 --> 00:00:42,230
所有这一切都在前面 
All of that lies ahead.

14
00:00:42,230 --> 00:00:46,087
所以 如果你和我一样 你可能是伴随着某种电子游戏长大的 
So, if you're like me, you probably grew up with video games of some sort.

15
00:00:46,087 --> 00:00:48,920
当你开始编程时 编程环境
And when you maybe started programming, the programming environments

16
00:00:48,920 --> 00:00:52,340
可能非常基于文本、黑白终端窗口等 
were perhaps very text based, black and white terminal window, and the like.

17
00:00:52,340 --> 00:00:55,580
也许你用Scratch或Alice之类的语言做了一些图形化的事情
And maybe you did something graphical with a language like scratch or Alice

18
00:00:55,580 --> 00:00:57,890
或者更远的地方 或者如果你身处网络世界 
or beyond, or if you're in the world of the web,

19
00:00:57,890 --> 00:01:01,550
您已经制作了更多的图形化应用程序 但仍然非常静态 
you've made more graphical applications of some sort, but still pretty static.

20
00:01:01,550 --> 00:01:04,950
内容的种类出现在屏幕上 然后内容发生变化 以此类推 
The sort of content comes on the screen, then the content changes, and so forth.

21
00:01:04,950 --> 00:01:07,866
如果你是编程新手 这就不那么明显了
And it's a little less obvious if you're a little newer to programming

22
00:01:07,866 --> 00:01:10,340
你是如何去创造一些这样的游戏的
how you go about creating some of those games

23
00:01:10,340 --> 00:01:12,410
从你们一起长大的昨天开始 
from yesteryear with which you all grew up,

24
00:01:12,410 --> 00:01:15,350
哪里有更多的动画 哪里就有更多的异步性 
where there's a lot more animation, there's a lot more asynchronicity,

25
00:01:15,350 --> 00:01:17,210
很多事情同时发生 
lots of things happening at the same time.

26
00:01:17,210 --> 00:01:19,700
发生了很多事情 而你们都没有--
A lot of events happening, and you all NOT--

27
00:01:19,700 --> 00:01:21,740
不仅想要捕捉这种互动性 
not only want to capture this interactivity,

28
00:01:21,740 --> 00:01:23,600
但也想要对那些
but also want to respond to events that are

29
00:01:23,600 --> 00:01:25,308
发生了 特别是如果你有球员的话
happening, especially if you have players

30
00:01:25,308 --> 00:01:27,110
在你旁边的其他地方或在线上 
elsewhere next to you or online.

31
00:01:27,110 --> 00:01:29,210
因此 课程的结构将是
And so the way the course will be structured

32
00:01:29,210 --> 00:01:32,309
是通过对这些不同的游戏的叙述 其中许多
is through a narrative of these various games, many of which

33
00:01:32,309 --> 00:01:33,600
你可能扮演了你自己 
you might have played yourself.

34
00:01:33,600 --> 00:01:35,450
但在这学期的课程中 我们潜水
But over the course of the semester, we dive

35
00:01:35,450 --> 00:01:37,370
深入到每一场比赛的背景下 看看
into the context of each of these games and look

36
00:01:37,370 --> 00:01:39,980
在一些基本的原则 通过这些结构 
at some of the underlying principles, the constructs via which

37
00:01:39,980 --> 00:01:42,604
它们是建立起来的 并真正地把它们作为出发点 
they were built up, and really use them as a point of departure

38
00:01:42,604 --> 00:01:45,200
谈论这些不同的能力
for talking about those various capabilities

39
00:01:45,200 --> 00:01:47,600
你可以把它融入到你自己的游戏中 
that you might integrate into your own games.

40
00:01:47,600 --> 00:01:49,970
最后 在整个学期 
And then punctuating the semester, ultimately,

41
00:01:49,970 --> 00:01:51,320
将是一系列里程碑 
will be a number of milestones.

42
00:01:51,320 --> 00:01:54,560
有些是以小作业的形式 
Some in the form of smaller assignments that are meant to reinforce just some

43
00:01:54,560 --> 00:01:58,170
最近的材料 并为你的成功做好准备 
of the more recent material and sort of set you up for success when the course

44
00:01:58,170 --> 00:02:01,110
是更深入和更多地参与项目 因为 
is deeper and more hands on projects. , Because indeed,

45
00:02:01,110 --> 00:02:04,401
该项目是你将建立或扩展一些自己的游戏 
the project is where you'll build or extend some of your own games.

46
00:02:04,401 --> 00:02:07,400
然后这门课本身会在学期末达到高潮
And then the class itself will culminate at the very end of the semester

47
00:02:07,400 --> 00:02:09,900
你们自己的期末项目 一个求婚的机会
with your very own final project, an opportunity to propose,

48
00:02:09,900 --> 00:02:13,040
设计并实现一个游戏 
to design, and implement a game that somehow or other draws

49
00:02:13,040 --> 00:02:14,330
课程的教训 
upon the course's lessons.

50
00:02:14,330 --> 00:02:16,880
所以当你几个月后离开这里的时候 
So that when you walk out of here in just a few months' time,

51
00:02:16,880 --> 00:02:19,020
你不仅玩了很多游戏
you've not only played your fair share of games,

52
00:02:19,020 --> 00:02:21,522
但实际上你自己也造了几个 
but have actually built several of your own.

53
00:02:21,522 --> 00:02:23,480
废话少说 请允许我把事情
So without further ado, allow me to turn things

54
00:02:23,480 --> 00:02:27,510
去科尔顿看一看 在去年的乒乓球上漫步 
over to Colton for a look and a stroll through yesteryear's Pong.

55
00:02:27,510 --> 00:02:29,050
科尔顿·奥格登：谢谢 大卫 
COLTON OGDEN: Thanks, David.

56
00:02:29,050 --> 00:02:31,790
我很高兴能开始教你们这门课
I'm very excited to begin teaching you guys this course

57
00:02:31,790 --> 00:02:34,910
因为游戏开发让我
because game development was actually what got me

58
00:02:34,910 --> 00:02:36,520
编程的人
into programming in the first place.

59
00:02:36,520 --> 00:02:40,910
我记得2006年或2007年在这里买了这本书 
I remember back in 2006 or 2007 buying this book here,

60
00:02:40,910 --> 00:02:47,110
3D Game Programming All In One 这是一个3D游戏编程的外观 
3D Game Programming All In One, which was a look through 3D game programming.

61
00:02:47,110 --> 00:02:51,110
这是一个游戏引擎中的整体文本
And it was a monolithic text in the context of a game engine

62
00:02:51,110 --> 00:02:54,110
在2000年代后期很流行的一种叫做扭矩的技术 
that was popular in the late 2000s called Torque.

63
00:02:54,110 --> 00:02:58,310
现在不流行了 但在当时很流行 
It's not as in vogue these days, but it at the time was pretty popular,

64
00:02:58,310 --> 00:03:00,200
and it used运用a language语言called叫TorqueScript扭矩.
and it used a language called TorqueScript.

65
00:03:00,200 --> 00:03:02,750
我记得我读过这本书 看到了所有的代码 
And I remember reading through this book and seeing all this code,

66
00:03:02,750 --> 00:03:05,010
and I had never seen看到like source源code码at all before 
and I had never seen like source code at all before,

67
00:03:05,010 --> 00:03:07,457
或者曾经接触过编程
or had ever been introduced to programming.

68
00:03:07,457 --> 00:03:09,290
坦白说 我觉得这很吓人 
And, frankly, I found it quite intimidating,

69
00:03:09,290 --> 00:03:13,400
因为我看了所有我不懂的语法 
because I was looking at all the syntax that I didn't understand,

70
00:03:13,400 --> 00:03:15,650
我对游戏开发一无所知 
and I didn't know anything about game development.

71
00:03:15,650 --> 00:03:19,857
我从小到大一直在玩游戏 并被它迷住了 
I had always played games growing up and been fascinated by it,

72
00:03:19,857 --> 00:03:22,190
但当我开始更习惯使用电脑时
but as I started getting more comfortable with computers

73
00:03:22,190 --> 00:03:23,939
我开始对它产生了更多的好奇
and I started to get more curious about it

74
00:03:23,939 --> 00:03:25,940
并意识到这是一个主要的职业 
and realized that it was a major profession,

75
00:03:25,940 --> 00:03:27,770
我开始往下潜得更深一些 
I started to dive a little deeper.

76
00:03:27,770 --> 00:03:29,030
这是我的第一次尝试 
This was my first foray.

77
00:03:29,030 --> 00:03:32,060
在花了一点时间离开它之后
And after spending a little bit of time away from it

78
00:03:32,060 --> 00:03:34,820
在查看了TorqueScrip的源代码后 它
after looking through the source code for a TorqueScript, which

79
00:03:34,820 --> 00:03:38,240
相当神秘 有很多百分号和美元符号
was rather arcane, a lot of percent symbols and dollar signs

80
00:03:38,240 --> 00:03:41,720
都是我还没想清楚的奇怪的事情 
are the weird things that I just hadn't gotten my mind around.

81
00:03:41,720 --> 00:03:45,830
我又回到了那里 开始真正学习编程的基础知识
I went back to it, started to really learn the basics of programming

82
00:03:45,830 --> 00:03:48,980
以及其他语言 如Python、c和c++ 
and other languages, like Python and c and c++,

83
00:03:48,980 --> 00:03:53,314
我逐渐变得非常喜欢编程和计算机科学 
and I grew to really like programming and computer science a lot.

84
00:03:53,314 --> 00:03:55,980
这只是一张当时扭矩的图像 
And here's just an image of what Torque looked like at the time.

85
00:03:55,980 --> 00:03:59,330
这真的是Unity现在的前身 
It was really the sort of predecessor to Unity nowadays.

86
00:03:59,330 --> 00:04:02,330
虽然 在我看来 统一做事情要好得多 
Although, in my opinion, Unity does things a lot better.

87
00:04:02,330 --> 00:04:05,270
它更容易使用 它使用的语言更时髦
It was more accessible, it uses languages that are more in vogue

88
00:04:05,270 --> 00:04:08,270
并且已经在其他领域的其他人流行和使用 
and popular and used by other people already in other domains.

89
00:04:10,489 --> 00:04:13,030
因此 我们将在课程的末尾介绍“团结” 
And so we'll be covering Unity at the tail end of the course.

90
00:04:13,030 --> 00:04:15,890
因此 我们将主要介绍2D游戏开发 
So we'll be covering predominantly 2D game development.

91
00:04:15,890 --> 00:04:18,589
但我们今天要讲的话题
But the topics that we'll be covering today

92
00:04:18,589 --> 00:04:23,087
我们在Pong的背景下开始的时候 这里有一些要点 
as we get started in the context of Pong are these bullet points here.

93
00:04:23,087 --> 00:04:25,670
Lua 这将是我们主要使用的语言
Lua, which will be the language that we're using predominately

94
00:04:25,670 --> 00:04:28,010
在整个课程中 这是一种非常动态的脚本语言
throughout the course, which is a dynamic scripting language very

95
00:04:28,010 --> 00:04:29,750
类似于Python和Java脚本 
similar to Python and JavaScript.

96
00:04:29,750 --> 00:04:33,290
我们将把Love 2D作为我们的主要游戏框架 它
We'll be covering LOVE 2D as our primary game framework, which

97
00:04:33,290 --> 00:04:39,590
是一个运行库和一个公开其所有方法的框架
is a runtime and a framework which exposes all of its methods

98
00:04:39,590 --> 00:04:41,630
用于绘图、音频、输入等 
for drawing, audio, input, etc.

99
00:04:41,630 --> 00:04:45,530
通过Lua 所以很容易非常快速地编写代码 
via Lua, so that it's very easy to write code very quickly,

100
00:04:45,530 --> 00:04:46,910
但取得了非常好的效果 
but get very good results.

101
00:04:46,910 --> 00:04:50,667
在我看来 他们框架的文档是一流的 
And the documentation for their framework is superb, in my opinion.

102
00:04:50,667 --> 00:04:53,000
今天我们将讨论几个基本原则
Today we'll be talking about a few just basic principles

103
00:04:53,000 --> 00:04:54,960
当我们涉足游戏开发的时候 
as we get our feet wet with game development.

104
00:04:54,960 --> 00:04:57,830
比如绘制形状、绘制文本、
Things like drawing shapes, drawing text,

105
00:04:57,830 --> 00:05:00,440
这两个都是乒乓球非常大的方面 
these are both very big aspects of Pong, which

106
00:05:00,440 --> 00:05:03,500
是一个基于形状和文本的非常简单的游戏
is just a very simple game based on shapes and text

107
00:05:03,500 --> 00:05:05,120
在屏幕上移动 
moving around the screen.

108
00:05:05,120 --> 00:05:09,350
我们将讨论增量时间和速度 这可能是增量时间
We'll be talking about Delta Time and Velocity, which Delta Time is probably

109
00:05:09,350 --> 00:05:11,587
可以说 最重要的变量之一
arguably one of the most important variables

110
00:05:11,587 --> 00:05:14,420
我们在任何游戏框架或引擎中都会跟踪 这只是
that we keep track of in any game framework or engine, which is just

111
00:05:14,420 --> 00:05:17,710
自最后一帧执行以来经过的时间量
the amount of time that's elapsed since the last frame of execution

112
00:05:17,710 --> 00:05:22,454
在我们的游戏中 以2D爱情来衡量 以秒为单位 几分之一秒 
in our game, measured in LOVE 2D in terms of seconds, fractions of seconds.

113
00:05:22,454 --> 00:05:24,370
我们将谈论游戏状态 因为你
We'll be talking about game state, because you

114
00:05:24,370 --> 00:05:25,660
在你的游戏中可以有一个状态 
can have a state in your game.

115
00:05:25,660 --> 00:05:29,359
你可以在标题屏幕上 你可以在玩 你可以在菜单中 
You can be at the title screen, you can be playing, you can be in a menu.

116
00:05:29,359 --> 00:05:32,650
显然 这将非常重要 因为您需要不同的更新逻辑
This will, obviously, be very important because you want different update logic

117
00:05:32,650 --> 00:05:35,525
以及根据您所处的状态呈现逻辑 
and rendering logic depending on what state you're in.

118
00:05:35,525 --> 00:05:37,900
我们将讨论基本的面向对象编程 
We'll be talking about basic object oriented programming,

119
00:05:37,900 --> 00:05:41,080
对于那些可能不熟悉来自C 
for those who might be unfamiliar coming from C.

120
00:05:41,080 --> 00:05:45,640
它基本上是一种封装我们的数据、任何游戏对象的方式 
It's basically a way of encapsulating our data, any of our game objects,

121
00:05:45,640 --> 00:05:49,150
以这样一种方式 与它们相关的变量
in such a way that the variables that are relevant to them

122
00:05:49,150 --> 00:05:52,370
与将对该数据进行操作的函数放在一起 
are put together, along with functions that will operate on that data.

123
00:05:52,370 --> 00:05:55,330
所以不是所有变量都有20个不同的变量
So instead of having like 20 different variables for all

124
00:05:55,330 --> 00:05:58,210
您必须在代码中跟踪这些不同的对象 
these different objects that you have to keep track of in your code,

125
00:05:58,210 --> 00:06:01,000
每个单独的对象可以跟踪它自己的所有信息 
each individual object can keep track of all its own information,

126
00:06:01,000 --> 00:06:04,240
比如它的位置 或者任何其他与它相关的东西 
like its position, or anything else that's relevant to it.

127
00:06:04,240 --> 00:06:07,150
今天我们将讨论热门话题 主要是 
We'll be talking about hit boxes today, predominantly,

128
00:06:07,150 --> 00:06:09,280
在盒子碰撞的情况下 因为我们将
in the context of box collision, because we'll

129
00:06:09,280 --> 00:06:11,989
说的是乒乓球 它只是一个球拍和一个球 
be talking about Pong, which is just paddles and a ball.

130
00:06:11,989 --> 00:06:13,030
这些都是长方形 
Those are all rectangles.

131
00:06:13,030 --> 00:06:16,600
它们将与所谓的轴对齐边界相撞--
And they'll be colliding with what's called axis aligned bound--

132
00:06:16,600 --> 00:06:21,820
轴对齐的边界框 这使得计算两个框是否碰撞
axis aligned bounding boxes, which makes calculating whether two boxes collided

133
00:06:21,820 --> 00:06:25,750
非常简单 与计算旋转命中框相反 
very simple, as opposed to calculating rotated hit boxes,

134
00:06:25,750 --> 00:06:27,190
这就有点复杂了 
which is a bit more complicated.

135
00:06:27,190 --> 00:06:29,439
然后 最后 我们将用音效来打磨 
And then, lastly, we'll polish off with sound effects,

136
00:06:29,439 --> 00:06:32,620
因为在我看来 添加抛光层很重要
because adding that polished layer, in my opinion, is important

137
00:06:32,620 --> 00:06:36,670
它将所有这些联系在一起 让它感觉像一个更有凝聚力的整体 
and it ties it all together and makes it feel like a more cohesive whole.

138
00:06:36,670 --> 00:06:40,294
所以当我们继续下去的时候 我们需要做两件重要的事情
So two important things that we'll need to do when we're following along

139
00:06:40,294 --> 00:06:43,210
下面是示例 稍后我将向您展示回购的链接 
with the examples, which I'll show you a link to the repo in a moment,

140
00:06:43,210 --> 00:06:44,590
就是安装Love 2D 
is getting LOVE 2D installed.

141
00:06:44,590 --> 00:06:46,190
这是一个非常简单的过程 
It's a very simple process.

142
00:06:46,190 --> 00:06:48,290
这里的第一个链接只是一个下载链接 
The first link here is just a download link.

143
00:06:48,290 --> 00:06:50,920
因此 它适用于所有主流操作系统 
So it's available for all major operating systems.

144
00:06:50,920 --> 00:06:53,620
因此 Linux、Mac和Windows都是如此 
So Linux, Mac, and Windows.

145
00:06:53,620 --> 00:06:56,190
然后点击下面的入门链接
And then the Getting Started link down here below

146
00:06:56,190 --> 00:06:58,300
将给你一些关于如何开始的小贴士 
will give you some tips as to how to get started,

147
00:06:58,300 --> 00:07:02,080
在你的Mac iAlias上的机器上运行它 
actually running it on your machine on Mac, iAlias,

148
00:07:02,080 --> 00:07:07,240
它附带的应用程序中的实际运行时可执行文件 
the actual runtime executable within the app that it comes with.

149
00:07:07,240 --> 00:07:11,470
所以在我的个人资料中 我可以很容易地输入Love space
So in my bash profiles that I can easily just type love space

150
00:07:11,470 --> 00:07:15,167
任何包含主Dot Lua文件的目录中的Dot 
dot in any directory that has a main dot Lua file,

151
00:07:15,167 --> 00:07:16,750
我可以非常简单地在任何地方运行它 
and I can run it anywhere very simply.

152
00:07:16,750 --> 00:07:20,050
页面上有类似的操作说明 供其他操作使用
And there are similar instructions located on the page for other operating

153
00:07:20,050 --> 00:07:20,770
系统 
systems.

154
00:07:20,770 --> 00:07:23,350
这是repo 里面有所有的源代码
And this is the repo here, which has all of the source code

155
00:07:23,350 --> 00:07:24,550
我们今天要用到的 
that we'll be using today.

156
00:07:24,550 --> 00:07:28,780
我把它组织成一系列13种不同的传票
And I've structured it in a series of 13 different subrepos

157
00:07:28,780 --> 00:07:32,560
这样你就可以跟随我们的脚步 我们可以从头开始在Pong的基础上发展 
so that you can follow along and we can build upon Pong starting from scratch,

158
00:07:32,560 --> 00:07:35,326
一直走到一个完全实现的游戏 
going all the way to a fully implemented game.

159
00:07:35,326 --> 00:07:37,450
所以我们首先要谈的是Lua是什么 
So the first thing we'll talk about is what Lua is.

160
00:07:37,450 --> 00:07:40,160
我们将在课程的75%时间里使用Lua 
We'll be using Lua for about 75% of the course.

161
00:07:40,160 --> 00:07:42,370
它是一种非常流行的动态脚本语言 
It's a very popular dynamic scripting language.

162
00:07:42,370 --> 00:07:45,040
葡萄牙语是月亮的意思 它是在90年代初发明的
Portuguese for moon, and it was invented in the early 90s

163
00:07:45,040 --> 00:07:48,250
作为主要的配置语言和运行时语言
as primarily a config language and a runtime language

164
00:07:48,250 --> 00:07:54,130
用于编译的代码库 以节省将代码添加到这些代码库的时间
for compiled code bases to save time on adding code to those code bases

165
00:07:54,130 --> 00:07:55,720
并重新编译它们 
and recompiling them.

166
00:07:55,720 --> 00:07:58,480
更快、更容易 尤其是在
A lot faster and a lot easier, especially in the context

167
00:07:58,480 --> 00:08:01,960
90年代计算机速度慢得多的时候 要曝光
of the 90s when computers were much slower, to expose

168
00:08:01,960 --> 00:08:07,270
将您的应用程序的核心功能添加到Lua 这样您就可以
the core functionality of your application to Lua so that you can just

169
00:08:07,270 --> 00:08:11,500
动态运行它 然后与您的已编译代码动态交互 
run it dynamically and then interact with your compiled code on the fly,

170
00:08:11,500 --> 00:08:13,960
而不是重新编译和等待几分钟 
rather than having to recompile and wait minutes,

171
00:08:13,960 --> 00:08:19,150
可能是几个小时 只是为了获得一些新的行为 
potentially hours, just to get some new behavior.

172
00:08:19,150 --> 00:08:22,690
它是一种专注于表的概念的语言 
It's a language that's focused around the concept of a table.

173
00:08:22,690 --> 00:08:26,060
除了基本变量之外 Lua中几乎所有的东西都是表 
Almost everything in Lua aside from basic variables, are tables.

174
00:08:26,060 --> 00:08:30,230
表在本质上是一个在Python语言中的词典或一个在JavaScript中的对象 
A table is essentially a dictionary in Python or an object in JavaScript.

175
00:08:30,230 --> 00:08:31,790
非常相似 
Very similar.

176
00:08:31,790 --> 00:08:33,890
Intent 用于在更大的应用程序中嵌入使用 
Intent, for embedded use in larger applications,

177
00:08:33,890 --> 00:08:37,150
而Lua的本质就是想要
and the very nature of Lua intended to be

178
00:08:37,150 --> 00:08:39,460
在这些大型应用程序的上下文中使用
used in the context of these large applications

179
00:08:39,460 --> 00:08:42,130
这意味着它非常适合与游戏引擎交互 
meant that it was perfect for interacting with game engines.

180
00:08:42,130 --> 00:08:44,800
因为游戏引擎是代码库的完美例子
Because game engines are a perfect example of code bases

181
00:08:44,800 --> 00:08:48,850
这些代码传统上是出于速度目的而编译的代码 
that are traditionally compiled code for speed purposes.

182
00:08:48,850 --> 00:08:52,240
但必须添加次要功能可能会非常麻烦 
But it can be very cumbersome to have to add minor functionality,

183
00:08:52,240 --> 00:08:56,680
然后重新编译 可能会让整个工作室花费几个小时 
and then recompile it and potentially have your whole studio take hours.

184
00:08:56,680 --> 00:09:00,910
所以我们将使用Lua和一个编译的游戏框架Love 2D 
So we'll be using Lua and a compiled game framework, LOVE 2D,

185
00:09:00,910 --> 00:09:03,880
让我们能够快速发展 
to allow us to rapidly develop.

186
00:09:03,880 --> 00:09:06,700
它类似于JavaScript和Python 
It's similar to JavaScript and Python.

187
00:09:06,700 --> 00:09:09,010
对于JavaScript来说 情况更是如此 
A little bit more so to JavaScript.

188
00:09:09,010 --> 00:09:11,230
它非常出色 因为它最初是
And it's very excellent because it was initially

189
00:09:11,230 --> 00:09:15,070
旨在作为一种配置语言 以及--只是一种粘合层 
intended as a config language, and a-- just sort of a glue layer.

190
00:09:15,070 --> 00:09:19,870
它非常适合将数据和代码存储在一起 几乎一个都在同一个位置 
It's very good for storing data and code together, almost one in the same.

191
00:09:19,870 --> 00:09:24,700
所以Love 2D是一个快速的2D游戏开发--
So LOVE 2D is a fast 2D game develop--

192
00:09:24,700 --> 00:09:25,630
开发框架 
development framework.

193
00:09:25,630 --> 00:09:28,790
它是用C++编译的 运行效率非常高 
It's compiled in C++ and it runs very efficiently.

194
00:09:28,790 --> 00:09:33,312
因为它是如此简单 尽管我们在卢阿州运行它 
Because it's so simple, despite the fact that we're running it in Lua,

195
00:09:33,312 --> 00:09:35,020
基本上可以作为你所有东西的模组
and as modules for basically anything you

196
00:09:35,020 --> 00:09:37,061
将需要在2D游戏开发的背景下 
would need in the context of 2D game development.

197
00:09:37,061 --> 00:09:40,690
只有2D游戏正式开发 尽管我认识的一些人
Only 2D game development officially, although some people I know

198
00:09:40,690 --> 00:09:44,840
正在进行微小的3D实验 但还没有正式的结果 
are working on slight little 3D experiments, but nothing official yet.

199
00:09:44,840 --> 00:09:47,872
但它有图形 键盘输入 数学 基本上 任何东西
But it has graphics, keyboard input, math, basically, anything

200
00:09:47,872 --> 00:09:50,080
您可能希望在2D游戏开发的环境中使用 
you could want in the context of 2D game development.

201
00:09:50,080 --> 00:09:51,050
这是完全免费的 
It's completely free.

202
00:09:51,050 --> 00:09:51,950
它是便携的 
It's portable.

203
00:09:51,950 --> 00:09:54,310
你甚至可以在移动设备上运行 也可以在网络上运行 
You can even run it on mobile and also the web.

204
00:09:54,310 --> 00:09:57,400
而且它非常适合原型制作 即使你不一定
And it's excellent for prototyping, even if you don't necessarily

205
00:09:57,400 --> 00:10:01,420
想要在爱情2D中发布一款游戏 它很棒 简单快捷
want to publish a game in LOVE 2D, it's great and easy and fast just

206
00:10:01,420 --> 00:10:03,970
在爱的2D中制造一些东西 然后搬家
to whip something up in LOVE 2D, and then port

207
00:10:03,970 --> 00:10:05,920
无论是哪种框架或引擎
that over to whatever framework or engine

208
00:10:05,920 --> 00:10:08,870
你可能会在现实世界中用到 
you might be using in the real world.

209
00:10:08,870 --> 00:10:12,222
因此 在我们开始研究一些实际的具体代码之前 
So before we get into looking at some actual concrete code,

210
00:10:12,222 --> 00:10:14,680
我认为我们应该看一看最基本的事情
I think the most fundamental thing we should take a look at

211
00:10:14,680 --> 00:10:16,430
是什么叫游戏循环 
is what a game loop is.

212
00:10:16,430 --> 00:10:21,420
因此 从根本上说 游戏只是一个无限循环 就像一段时间真或一段时间
So a game, fundamentally, is just an infinite loop, like a while true or a

213
00:10:21,420 --> 00:10:22,790
只有一次 
while one.

214
00:10:22,790 --> 00:10:27,200
只是在这种情况下 循环的每一次迭代我们都在执行一组步骤
Only in this case, every iteration of that loop we're doing a set of steps

215
00:10:27,200 --> 00:10:28,850
一次又一次的背靠背 
back to back over and over again.

216
00:10:28,850 --> 00:10:31,480
我们正在处理输入 所以我们正在查看 让用户按下
We're processing input so we're seeing, has the user pressed

217
00:10:31,480 --> 00:10:34,220
键盘上的一个键 他们摸过他们的操纵杆了吗 
a key on the keyboard, have they touched their joystick,

218
00:10:34,220 --> 00:10:36,896
他们有没有移动鼠标 点击鼠标 
have they moved the mouse, clicked the mouse.

219
00:10:36,896 --> 00:10:39,020
如果他们有 我们需要将其添加到我们的更新中 
If they have, we need to feed that into our update.

220
00:10:39,020 --> 00:10:42,061
我们需要跟踪这一点 然后更改游戏状态中的任何内容
We need to keep track of that, and then change anything in our game state

221
00:10:42,061 --> 00:10:43,520
这依赖于这种投入 
that relies upon that input.

222
00:10:43,520 --> 00:10:46,640
所以我们应该移动我们的球拍 我们应该检测碰撞 
So we should move our paddles, we should detect collision,

223
00:10:46,640 --> 00:10:49,460
我们应该把所有这些都登记下来 然后无论更新了什么 
we should register all of this, and then whatever has updated,

224
00:10:49,460 --> 00:10:51,410
我们想重现这一点 
we want to rerender that.

225
00:10:51,410 --> 00:10:52,670
我们想要呈现它--
We want to render it--

226
00:10:52,670 --> 00:10:55,190
在它改变的地方渲染 这样我们就有了--
render where it's changed so that we have the--

227
00:10:55,190 --> 00:10:58,477
我们在屏幕上看到 在视觉上 东西实际上
we see on our screen, visually, that things have actually

228
00:10:58,477 --> 00:11:00,560
改变了我们的游戏世界 我们与之互动 
changed in our game world and we interact with it,

229
00:11:00,560 --> 00:11:03,260
我们有一种感觉 我们正在使用某种东西 
and we get a sense that we're using something,

230
00:11:03,260 --> 00:11:07,430
与一些动态的东西互动 
interacting with something dynamic.

231
00:11:07,430 --> 00:11:12,140
在2D游戏的背景下 看待世界的最基本方式
And in the context of 2D games, the most fundamental way of looking at the world

232
00:11:12,140 --> 00:11:14,720
是通过2D坐标系 这只是简单地
is via the 2D coordinate system, which is just simply

233
00:11:14,720 --> 00:11:18,949
就像我们在高中学的几何学一样 x轴和y轴 
as we learned in geometry in high school, x and y-axis.

234
00:11:18,949 --> 00:11:21,740
在这种情况下 它与我们通常所学的略有不同 
In this case, it's slightly different than what we typically learn.

235
00:11:21,740 --> 00:11:26,360
在高中 我们倾向于学习XY起源 有点左下角的意思 
In high school, we tend to learn that the xy origins, sort of bottom left,

236
00:11:26,360 --> 00:11:30,650
正数向上 负数向下 正x向右 
y positive goes up, negative goes down, positive x goes right,

237
00:11:30,650 --> 00:11:31,830
负x向左 
and negative x goes left.

238
00:11:31,830 --> 00:11:34,280
但在这种情况下 我们实际上是从左上角开始 
But in this case, we're actually starting in the top left,

239
00:11:34,280 --> 00:11:38,740
然后y正向下 y负向上 x正向右 
and then it goes y positive down, y negative up, x positive right,

240
00:11:38,740 --> 00:11:40,640
X负数左转 
x negative left.

241
00:11:40,640 --> 00:11:42,980
以及我们想要在游戏中画出的所有东西
And everything that we want to draw in our game

242
00:11:42,980 --> 00:11:45,350
需要有x和y坐标才能按顺序绘制
needs to have an x and y-coordinate to draw in order

243
00:11:45,350 --> 00:11:48,170
以便在屏幕上直观地看到它 
for it to be visually seen on the screen.

244
00:11:48,170 --> 00:11:51,230
所以今天的目标是 我们将从一个相当低的水平开始
So today's goal, we're going to start a fairly low level

245
00:11:51,230 --> 00:11:55,670
并通过今天和未来的课堂上的例子来提升我们的能力 
and work our way up through examples today and in future classes.

246
00:11:55,670 --> 00:11:58,160
我们的第一场比赛可以说是最简单的比赛之一 
Our first game is arguably one of the simplest,

247
00:11:58,160 --> 00:12:00,920
而且 有史以来最著名的游戏之一 乒乓球 
but also, one of the most famous games of all time, Pong,

248
00:12:00,920 --> 00:12:03,500
这部电影于1972年发行 
which was released in 1972.

249
00:12:03,500 --> 00:12:05,499
乒乓球的要点是你有一把球拍
And the gist of Pong is you have a paddle

250
00:12:05,499 --> 00:12:08,540
在屏幕的左侧 在屏幕的右侧有一个桨 
on the left side of the screen, a paddle on the right side of the screen,

251
00:12:08,540 --> 00:12:11,630
无论谁把球传过对手的球拍得10分
whoever scores 10 points by getting the ball past their opponent's paddle

252
00:12:11,630 --> 00:12:14,510
在屏幕的边缘 赢了 
onto the edge of the screen, wins.

253
00:12:14,510 --> 00:12:19,220
所以今天在我们的演讲中 范围是我们想要 最重要的 
And so today in our lecture, the scope is we want to, first and foremost,

254
00:12:19,220 --> 00:12:22,640
在屏幕上画出形状 因为这是我们获得球和球的方式
draw shapes to the screen, because that's how we get our ball and-- ball

255
00:12:22,640 --> 00:12:23,630
和划桨渲染 
and paddles rendering.

256
00:12:23,630 --> 00:12:25,490
而这些只是简单的矩形 
And those are just simply rectangles.

257
00:12:25,490 --> 00:12:28,070
我们想要控制这些球拍的2D位置 
We want to control the 2D position of these paddles,

258
00:12:28,070 --> 00:12:32,630
因为我们想要他们上下移动 希望球也能移动 
because we want them to move up and down and want the ball to also move.

259
00:12:32,630 --> 00:12:36,050
我们想要检测球拍和球之间的碰撞 
We want to detect collision between the paddles and the ball,

260
00:12:36,050 --> 00:12:38,780
因为这是我们让球偏离球拍的方法 
because that's how we get the ball to deflect off the paddles,

261
00:12:38,780 --> 00:12:40,790
并偏离天花板和地板 
and to deflect off the ceiling and the floor.

262
00:12:40,790 --> 00:12:44,250
还有 我们如何检测它是否超出了屏幕的边缘 
And, also, how we detect whether it's gone beyond the edges of the screen,

263
00:12:44,250 --> 00:12:47,270
这样一位选手就能得一分 
such that one player scores a point.

264
00:12:47,270 --> 00:12:51,710
然后我们想要添加音效 以获得某种反馈
And then we want to add sound effects for sort of a feedback

265
00:12:51,710 --> 00:12:54,660
把我们自己更多地投入到游戏中 
and sort of put ourselves into the game a little bit more.

266
00:12:54,660 --> 00:12:57,380
然后是记分 因为比赛的最终目的
And then scorekeeping, because ultimately the purpose of the game

267
00:12:57,380 --> 00:12:59,780
就是打败你的对手 所以你想要一种方法
is to beat your opponent, so you want a way

268
00:12:59,780 --> 00:13:02,840
看看谁先得了10分 
to see who has scored 10 points first.

269
00:13:02,840 --> 00:13:06,590
因此 我们现在将在回购中查看一组示例 
And so we're going to look through a set of examples now in the repo.

270
00:13:06,590 --> 00:13:11,240
如果我们看一下Pong Zero 我已经将其命名为Day Zero更新 
If we look at Pong Zero, I've set this to be called, The Day Zero Update.

271
00:13:11,240 --> 00:13:16,460
在许多游戏中 让游戏发布主要内容是一种趋势
It's a trend among many games to have the games release major content

272
00:13:16,460 --> 00:13:17,870
随着x的更新而更新 
updates as the x update.

273
00:13:17,870 --> 00:13:24,470
所以为了搞笑 我想我们把每个例子都叫在这里 
So just to be cute, I think we'll call each individual example here,

274
00:13:24,470 --> 00:13:26,220
《某事更新》 
The Something Update.

275
00:13:26,220 --> 00:13:29,960
所以我要走进Pong Zero
And so I'm going to go into the Pong Zero

276
00:13:29,960 --> 00:13:36,680
目录的repo 即GitHub repo 
Repo of the directory, the GitHub repo.

277
00:13:36,680 --> 00:13:40,669
如果我们看的是Pong Zero 我们可以看到它
And if we're looking at Pong Zero here, we can see it

278
00:13:40,669 --> 00:13:41,960
这里写着 零日更新 
says here, The Day Zero Update.

279
00:13:41,960 --> 00:13:44,990
我对每一件事都做了相当认真的评论 这样我们就可以--
I've commented everything fairly heavily so that we can--

280
00:13:44,990 --> 00:13:48,290
如果您正在阅读代码 您可以在某种程度上了解正在发生的事情 
if you're reading the code, you can sort of get a sense of what's going on.

281
00:13:48,290 --> 00:13:52,580
在第23行 我们将从声明开始
At line 23, we're going to start off by just declaring

282
00:13:52,580 --> 00:13:54,039
窗口宽度和窗口高度 
a window width and a window height.

283
00:13:54,039 --> 00:13:55,788
这些都是恒定的变量 
And these are just constant variables that

284
00:13:55,788 --> 00:13:58,230
在我们应用程序的其余部分中都可以访问 
will be accessible throughout the rest of our application.

285
00:13:58,230 --> 00:14:01,160
因此 我只是将1280x720设置为任意分辨率 
So I'm just setting 1280 by 720 as an arbitrary resolution.

286
00:14:01,160 --> 00:14:03,770
这没什么大不了的 
It doesn't matter too much.

287
00:14:03,770 --> 00:14:07,700
我们需要注意的一件重要的事情是第29行 
An important thing that we need to look at here is that line 29,

288
00:14:07,700 --> 00:14:12,470
我们使用的是一个名为love.Load的函数 而我实际上
we're using a function called love.load, and I'm actually

289
00:14:12,470 --> 00:14:14,030
现在我们回到幻灯片上 
going to go back to the slides here.

290
00:14:14,030 --> 00:14:15,988
我们将介绍几个函数 我将
We're going to look at a few functions, and I'm

291
00:14:15,988 --> 00:14:18,560
我会把它们看一遍 然后告诉你
going to go over them and just sort of tell you

292
00:14:18,560 --> 00:14:21,240
在我们详细查看代码之前 它们会做些什么 
what they do before we look at the code in too much detail.

293
00:14:21,240 --> 00:14:26,330
Load只是一个函数--由Love Love 2D 
So love.load is just a function that-- given to us by LOVE, LOVE 2D,

294
00:14:26,330 --> 00:14:28,940
然后我们改写它 
and we overwrite it.

295
00:14:28,940 --> 00:14:31,080
我们给它行为 我们告诉它该做什么 
We give it behavior, we tell it what to do.

296
00:14:31,080 --> 00:14:34,190
Love 2D将在我们的main.lua文件中查看它 
And LOVE 2D is going to look at it in our main.lua file.

297
00:14:34,190 --> 00:14:37,460
如果我们正在查看Pong Zero 您将看到它只有一个main.lua文件 
If we're looking at Pong Zero, you'll see it just has a main.lua file.

298
00:14:37,460 --> 00:14:42,410
Love 2D只需要一个main.lua文件 并将运行main.lua文件 
LOVE 2D expects just a main.lua file, and will run the main.lua file,

299
00:14:42,410 --> 00:14:45,830
并且您可以从该main.lua引用目录中的任何其他文件
and you can reference any other file within the directory from that main.lua

300
00:14:45,830 --> 00:14:46,360
文件 
file.

301
00:14:46,360 --> 00:14:49,540
实际上 这是我们的自力更生 
It's our bootstrap, effectively.

302
00:14:49,540 --> 00:14:52,610
我们要用任何东西来替代Love.Load
We're going to override love.load with whatever

303
00:14:52,610 --> 00:14:55,250
我们希望在应用程序的最开始执行 
we want to execute at the very beginning of our application.

304
00:14:55,250 --> 00:14:57,400
这只是一个启动功能 
It's just a startup function.

305
00:14:57,400 --> 00:15:01,590
我们还可以定义上面的函数之外的所有行为 
We can also define all that behavior outside of the function above it,

306
00:15:01,590 --> 00:15:03,887
但在love.load中找到它是一个很好的做法
but it's good practice to find it within love.load

307
00:15:03,887 --> 00:15:05,720
以便阅读您的代码的人知道 
so that someone reading your code will know,

308
00:15:05,720 --> 00:15:08,990
好的 这是所有启动代码发生的地方 
OK, this is where all the startup code takes place.

309
00:15:08,990 --> 00:15:12,570
更新(DT)是一个非常重要的函数 
Love.update(dt) is a very important function.

310
00:15:12,570 --> 00:15:14,720
该函数接受一个名为(Dt)的变量 
This function takes in a variable called (dt).

311
00:15:14,720 --> 00:15:17,164
爱在一个函数中传递它 
Love passes it in a function.

312
00:15:17,164 --> 00:15:19,330
你会用你自己的行为来覆盖它 
You're going to overwrite it with your own behavior,

313
00:15:19,330 --> 00:15:23,530
爱将在每一帧中执行它 在增量时间内传递它 
and Love is going to execute this every frame, passing it in delta time,

314
00:15:23,530 --> 00:15:27,790
您可以在该函数中使用增量时间(DT
and you can use delta time (dt) in that function

315
00:15:27,790 --> 00:15:32,680
根据经过的时间更改您的应用程序 
to change your application based upon how much time has passed.

316
00:15:32,680 --> 00:15:36,670
(Dt)将始终是零点几秒 可能更多 
(dt) will always be a fraction of a second, potentially more,

317
00:15:36,670 --> 00:15:38,320
这取决于您的计算机有多慢 
depending on how slow your computer is.

318
00:15:38,320 --> 00:15:41,410
但通常是六十分之一秒 
But, typically, one-sixtieth of a second.

319
00:15:41,410 --> 00:15:43,930
你可以将游戏中的任何东西都按这个数值进行缩放
And you can scale anything in your game by that amount

320
00:15:43,930 --> 00:15:47,560
以在所有帧速率上获得均匀的行为 
to get even behavior across all frame rates.

321
00:15:47,560 --> 00:15:52,180
Love.DRAW是其中的另一个重要功能--
Love.draw is the other big function amongst--

322
00:15:52,180 --> 00:15:53,350
在更新和绘制之间 
between update and draw.

323
00:15:53,350 --> 00:15:55,720
可以说 这两个功能中的两个是最重要的功能 
Two of the two, arguably, most important functions.

324
00:15:55,720 --> 00:15:58,120
Love.Drawing是我们要使用的函数
Love.draw is the function that we're going

325
00:15:58,120 --> 00:16:02,996
定义有我们所有的绘制行为 我们的渲染行为在其中 
to define that has all of our drawing behavior, our rendering behavior in it.

326
00:16:02,996 --> 00:16:05,620
这就是我们可以画球拍的地方 我们可以画球 
And that's where we can draw our paddles, we can draw our ball.

327
00:16:05,620 --> 00:16:07,411
然后更新是我们可以喜欢变化的地方
And then update is where we can like change

328
00:16:07,411 --> 00:16:09,840
划桨的位置等等 
the paddles position and so forth.

329
00:16:09,840 --> 00:16:13,100
我们将在第一个示例中查看两个更重要的函数 
Two more important functions we'll take a look at in the first example.

330
00:16:13,100 --> 00:16:19,799
Print tf是print tf和C的Love 2D类比 
Love.graphics.printf is the LOVE 2D analog of printf and C. The difference

331
00:16:19,799 --> 00:16:22,090
因为这张照片能让我们实际地画出来
being that this printf lets us actually draw physically

332
00:16:22,090 --> 00:16:24,220
屏幕上 而不是控制台上 
onto the screen versus a console.

333
00:16:24,220 --> 00:16:28,180
我们给它一个字符串形式的文本 以及一个x和y坐标 还可以选择
We give it a text as a string, and an x and a y-coordinate and, optionally,

334
00:16:28,180 --> 00:16:32,890
宽度和对齐 它将在xy处绘制文本 
a width and an align, and it'll will draw the text at xy,

335
00:16:32,890 --> 00:16:35,500
但它也会考虑到宽度 
but it will also take into consideration the width,

336
00:16:35,500 --> 00:16:37,720
它还将考虑到Align 
and it'll also take in consideration the align.

337
00:16:37,720 --> 00:16:41,840
With是要对齐的量 Align是对齐的模式 
The with is how much to align it, and the align is the mode of alignment.

338
00:16:41,840 --> 00:16:47,610
所以如果我们说x是零宽度 我们的窗口宽度 然后我们说居中对齐 
So if we say x is zero width, our window width, and then we say align center,

339
00:16:47,610 --> 00:16:51,250
它将在零和我们的窗口宽度之间移动 并居中对齐 
it's going to go between zero and our window width and center align it.

340
00:16:51,250 --> 00:16:54,460
这将产生居中对齐我们的文本的效果 
So that'll have the effect of center aligning our text.

341
00:16:54,460 --> 00:16:57,100
但我们可以很容易地说 对 它就会对
But we can just as easily say, right, and it will right

342
00:16:57,100 --> 00:16:59,200
在这两者之间对齐 就会产生这样的效果
align it between those two and have the effect

343
00:16:59,200 --> 00:17:01,033
渲染屏幕--渲染文本
of rendering the screen-- rendering the text

344
00:17:01,033 --> 00:17:03,220
沿着屏幕的右边缘 
along the right edge of the screen.

345
00:17:03,220 --> 00:17:06,760
最后 love.window.setmode获取一个宽度和一个高度
And then lastly, love.window.setmode takes a width and a height

346
00:17:06,760 --> 00:17:08,260
和一些可选参数 
and some optional parameters.

347
00:17:08,260 --> 00:17:11,730
这些参数是垂直同步和全屏 
Those parameters being things like V sync and full screen,

348
00:17:11,730 --> 00:17:16,550
并将实际设置我们的窗口并将其渲染到屏幕上 
and will actually set up our window and get it rendering onto the screen.

349
00:17:16,550 --> 00:17:21,400
所以如果我们回到这里的源代码 它--在第29行 
And so if we go back to our source code here, it-- at line 29,

350
00:17:21,400 --> 00:17:23,599
我们正在覆盖love.load 
we're overwriting love.load.

351
00:17:23,599 --> 00:17:27,670
我们传入了love.window.setmode、窗口宽度和窗口
We're passing in love.window.setmode, window width and window

352
00:17:27,670 --> 00:17:31,570
高度 我们将其定义为1280乘以720 
height, which recall we defined up above as 1280 by 720.

353
00:17:31,570 --> 00:17:33,220
我们路过一张桌子 
We're passing in a table.

354
00:17:33,220 --> 00:17:36,280
这是表格的语法 这些花括号 
This is the syntax for a table, these curly brackets.

355
00:17:36,280 --> 00:17:39,920
我们定义键和值的方式就是用等号
And the way that we define keys and values is just with an equal sign

356
00:17:39,920 --> 00:17:40,420
在那里 
therein.

357
00:17:40,420 --> 00:17:44,202
所以全屏显示为假 可调整大小显示为假 垂直同步显示为真 
So full screen gets false, resizeable gets false, V sync gets true.

358
00:17:44,202 --> 00:17:45,910
所以不会是全屏的 它是
So it's going to not be full screen, it's

359
00:17:45,910 --> 00:17:48,230
将是不可调整大小的 但它将是
going to be a not resizeable but it is going to be

360
00:17:48,230 --> 00:17:49,840
同步到我们监视器的刷新率 
synced to our monitor's refresh rate.

361
00:17:49,840 --> 00:17:53,410
这就是垂直同步的地方 垂直同步的简称 
And that's where V sync is, short for vertical sync.

362
00:17:53,410 --> 00:17:56,740
然后在第40行 我们覆盖了Love 绘制 
And then on line 40, we're overwriting love.draw,

363
00:17:56,740 --> 00:18:00,700
这里有love.graph ics.print tf函数 它们在 
and this has the love.graphics.printf function, they're in,

364
00:18:00,700 --> 00:18:03,250
我们在说--我们正在传递字符串 你好 Pong 
and we're saying-- we're passing in the string, hello, Pong.

365
00:18:03,250 --> 00:18:06,360
我们从x0开始 我们正在设置它
We're starting it at x zero, we're setting it

366
00:18:06,360 --> 00:18:10,090
在y窗口高度除以2减去6 
at y window height divided by 2, minus 6.

367
00:18:10,090 --> 00:18:13,220
因为Love 2D的默认字体大小是12像素高 
Because the default font size in LOVE 2D is 12 pixels tall.

368
00:18:13,220 --> 00:18:15,220
所以我们把它提前了6点 所以它是完美的
So we're shifting it up by six so it's perfectly

369
00:18:15,220 --> 00:18:18,910
在屏幕上垂直居中 
centered vertically in the screen.

370
00:18:18,910 --> 00:18:22,936
然后我们将对齐量、宽度设置为窗口宽度
And then we're setting the alignment amount, the width, to window width

371
00:18:22,936 --> 00:18:25,810
这样它就会在我们窗口的整个宽度内对齐它 
so that it's going to align it within the entire width of our window.

372
00:18:25,810 --> 00:18:27,620
现在我们将其设置为中心对齐 
And now we're setting it to center alignment.

373
00:18:27,620 --> 00:18:30,078
因此它将在我们的整个窗口内居中对齐
So it's going to be center aligned within our entire window

374
00:18:30,078 --> 00:18:31,230
从x0开始 
starting at x zero.

375
00:18:31,230 --> 00:18:36,280
所以如果我们去Pong Zero 然后我们实际运行它 
And so if we go to Pong zero, and then we actually run it,

376
00:18:36,280 --> 00:18:38,080
它有这样做的效果 
it has the effect of doing this.

377
00:18:38,080 --> 00:18:41,500
我们只是使用默认字体、默认大小进行渲染 
We're just rendering in our default font, default size,

378
00:18:41,500 --> 00:18:44,230
你好 Pong 就在屏幕中央 
hello, Pong, right in the middle of the screen.

379
00:18:44,230 --> 00:18:47,290
所以不是一个非常令人兴奋的例子 但它
So not a terribly exciting example, but it

380
00:18:47,290 --> 00:18:51,400
正在展示LOVE 2D最重要的功能 
is showcasing the most important functions of LOVE 2D,

381
00:18:51,400 --> 00:18:55,060
这样我们就可以从稍微有趣的例子开始 
so that we can get started with slightly more interesting examples.

382
00:18:55,060 --> 00:18:59,270
所以 我们的第一个内容更新是低分辨率更新 
So, our first content update, is the Low-Res Update.

383
00:18:59,270 --> 00:19:03,590
所以我们正在开发乒乓球 而乒乓球是一项古老的游戏 
So we're developing Pong and Pong is an old game.

384
00:19:03,590 --> 00:19:06,280
它看起来不像我们刚才看到的例子
It doesn't look like the example that we just looked

385
00:19:06,280 --> 00:19:09,410
字体分辨率相当高的地方 
at where the font is fairly high res.

386
00:19:09,410 --> 00:19:11,740
我们想要一些看起来更复古的东西 
We want something that looks a little more retro.

387
00:19:11,740 --> 00:19:14,890
所以我们想要做的是得到我们的解决方案
So what we want to do is get our resolution

388
00:19:14,890 --> 00:19:18,490
看起来像是1972年发布的一款游戏 
looking like it's from a game released in 1972.

389
00:19:18,490 --> 00:19:22,220
所以我们要做的是看看这里更重要的几个函数 
So what we're going to do is look at a few more important functions here.

390
00:19:22,220 --> 00:19:25,240
所以Pong One具有这些功能 
So Pong One has these functions.

391
00:19:25,240 --> 00:19:28,470
所以love.graph ics.setDefaultFilter 
So love.graphics.setDefaultFilter.

392
00:19:28,470 --> 00:19:32,710
这个函数 那个函数的目的是每次
This function, the purpose of that, is every time

393
00:19:32,710 --> 00:19:36,130
我们的应用程序中有一个字体或图像 
we have a font or an image in our application,

394
00:19:36,130 --> 00:19:39,010
默认情况下 它将应用于筛选器 
it's going to be applied a filter by default.

395
00:19:39,010 --> 00:19:41,186
默认情况下 它将使用双线性过滤器 
So it's going to by default a bilinear filter.

396
00:19:41,186 --> 00:19:43,060
那么会发生什么 它的影响是什么
So what's going to happen, the effect of that

397
00:19:43,060 --> 00:19:48,400
基本上 每当我们放大或缩小纹理时 
is, basically, whenever we magnify or downscale a texture,

398
00:19:48,400 --> 00:19:51,130
它会认为--它会假设
it's going to think that-- it's going to assume

399
00:19:51,130 --> 00:19:55,960
我们希望它稍微模糊一点 这样看起来就不会太像素化了 
that we want it to be slightly blurred so as to not look too pixilated.

400
00:19:55,960 --> 00:19:57,700
这在某些情况下是好的 
Which is good in certain contexts.

401
00:19:57,700 --> 00:20:01,362
对于更高分辨率的2D游戏开发 这很好 但正如我们将看到的那样 
For higher res 2D game development, that's good, but as we're going to see,

402
00:20:01,362 --> 00:20:03,820
这在复古游戏的背景下并不是特别好 
that's not particularly good in the context of retro games.

403
00:20:03,820 --> 00:20:08,180
复古游戏有非常2D的 清晰的 像素化的美学 
Retro games have a very 2D, crisp, pixilated aesthetic,

404
00:20:08,180 --> 00:20:09,890
我们想要保留这一点 
and we want to preserve that.

405
00:20:09,890 --> 00:20:11,740
因此 这让我们可以设置默认过滤器 
And so this lets us set a default filter.

406
00:20:11,740 --> 00:20:14,030
我们很快就会看到它的用法 
We'll see that in usage shortly.

407
00:20:14,030 --> 00:20:17,130
另一个重要的--非常重要的功能是输入阶段
Another important-- very important function which is the input phase

408
00:20:17,130 --> 00:20:21,150
在我们前面看到的游戏循环中 love.key(Key)是正在进行的
of our game loop that we saw earlier, love.keypressed(key) is what's going

409
00:20:21,150 --> 00:20:24,610
让我们开始与游戏的这一方面互动 
to allow us to start interacting with that aspect of our game.

410
00:20:24,610 --> 00:20:28,440
因此 Love在main.lua中使用的是一个回调函数love.keypresded(Key) 
So love.keypressed(key) is a callback function that LOVE expects in main.lua.

411
00:20:28,440 --> 00:20:29,940
我们要覆盖它 
We're going to overwrite it.

412
00:20:29,940 --> 00:20:31,980
它被传递到一个键中 该函数
It gets passed in a key, and this function

413
00:20:31,980 --> 00:20:35,230
每当我们按下一个键时 就会被Love 2D呼叫 
gets called every time by LOVE 2D whenever we press a key.

414
00:20:35,230 --> 00:20:37,810
它将检测到按下的键 并调用此函数 
It'll detect a key pressed, and it will call this function.

415
00:20:37,810 --> 00:20:39,810
无论我们在这里定义了什么 它都会这样称呼它 
Whatever we've defined in here, it will call it,

416
00:20:39,810 --> 00:20:42,810
我们可以将其设置为接受特定的键
and we can set it to take in certain keys

417
00:20:42,810 --> 00:20:46,030
并对该输入执行某些操作 它将获得一个字符串 
and perform certain operations on that input and it will get a string.

418
00:20:46,030 --> 00:20:49,320
所以如果我们说--如果我们按下退出键 
So if we say-- if we press the escape key,

419
00:20:49,320 --> 00:20:52,390
键将等于该函数中的字符串转义 
key is going to be equal to the string escape in that function,

420
00:20:52,390 --> 00:20:53,910
我们有权访问它 
and we have access to that.

421
00:20:53,910 --> 00:20:56,700
还有另一个重要的函数love.vent.Quit 
And another important function, love.event.quit.

422
00:20:56,700 --> 00:20:59,760
这只有一个非常简单的效果 即退出应用程序 
This has just a very simple effect of quitting the application,

423
00:20:59,760 --> 00:21:03,980
尽管我们可以在代码中调用它 而不是自己做 
though we can call it in the code as opposed to doing it ourselves.

424
00:21:03,980 --> 00:21:07,882
下面是一个纹理过滤的例子 
And so here's an example of what texture filtering looks like.

425
00:21:07,882 --> 00:21:09,840
点过滤与最近邻点过滤相同
Point filtering is the same as nearest neighbor

426
00:21:09,840 --> 00:21:11,881
过滤 这就是我们将要使用的 
filtering, which is what we're going to be using.

427
00:21:11,881 --> 00:21:15,400
右侧显示的是双线性过滤 它看起来非常模糊 
Bilinear filtering is shown on the right, where it looks pretty blurry.

428
00:21:15,400 --> 00:21:18,890
这就是Love 2D默认应用于字体和纹理的方式 
That's what LOVE 2D applies by default to both fonts and to textures.

429
00:21:21,510 --> 00:21:23,620
我们将在一个例子中看到这一点 
And we'll see that in an example.

430
00:21:23,620 --> 00:21:25,810
我实际上可以用两种不同的风格来运行它 
I can actually run it in two different styles.

431
00:21:25,810 --> 00:21:28,890
所以如果你去回购的Pong One 然后我们运行它 
So if you go to Pong One in the repo, and then we run it,

432
00:21:28,890 --> 00:21:32,919
我们看到这里 你好 乒乓球现在被炸了 
we see here, hello, Pong is now blown up.

433
00:21:32,919 --> 00:21:34,710
实际上 我们会看一些更多的代码 
And we'll look at some more code, actually,

434
00:21:34,710 --> 00:21:36,360
看看它为什么会被炸毁 
to see as to why it's blown up.

435
00:21:36,360 --> 00:21:42,870
但如果我们回到我们的代码 让我启动Pong One 
But if we go back to our code, let me pull up Pong One.

436
00:21:46,670 --> 00:21:52,150
转到Main Lua 然后我马上就解释一下 
Go to main.lua, and then I'm going to explain this in just a second,

437
00:21:52,150 --> 00:21:55,730
但让我注释掉这一点 我们将在这里看到区别 
but let me comment this out and we'll see the difference here.

438
00:21:55,730 --> 00:21:58,370
你可以看到它看起来模糊多了 
You can see it looks a lot blurrier.

439
00:21:58,370 --> 00:22:00,930
这是默认的纹理过滤 
And that's the default texture filtering taking place.

440
00:22:00,930 --> 00:22:04,400
就像我说的 它不仅适用于纹理 也适用于字体 
It applies, like I said, not only to textures but also to fonts.

441
00:22:04,400 --> 00:22:06,150
而这并不是我们想要的美学 
And that's not the aesthetic we want.

442
00:22:06,150 --> 00:22:11,730
因此 让我们从顶部开始 详细了解一下Pong One 
So let's look at Pong One in detail, starting at the top.

443
00:22:11,730 --> 00:22:14,250
在第28行 我们正在收购一个图书馆 
On line 28, we're acquiring a library.

444
00:22:14,250 --> 00:22:16,850
这就是你如何在你的爱情2D中获得一个图书馆
This is how you get a library in your LOVE 2D

445
00:22:16,850 --> 00:22:18,740
申请 或者你的爱情申请 
application, or your LOVE application.

446
00:22:18,740 --> 00:22:21,160
只需与库的名称相等即可 
Just equals require and the name of the library.

447
00:22:21,160 --> 00:22:25,490
我们将使用推送来获取1280 x 720窗口
Push is what we're going to be using to take our 1280 by 720 window

448
00:22:25,490 --> 00:22:31,490
并将其变成432×243的虚拟分辨率窗口 
and turn it into a virtual resolution window at 432 by 243.

449
00:22:31,490 --> 00:22:36,500
我们可以开始从更低分辨率的角度来看待我们的比赛 
We can start to think of our game in terms of a more low res feel,

450
00:22:36,500 --> 00:22:40,220
并以432 x 243像素进行思考 但仍将其渲染
and think about it in 432 by 243 pixels, but still render it

451
00:22:40,220 --> 00:22:42,240
在一个任意大小的窗口中 
in a window that's arbitrarily sized.

452
00:22:42,240 --> 00:22:47,060
在本例中 我们保留了以前看到的1280x720的窗口 
In this case, we're preserving the 1280 by 720 window that we saw before.

453
00:22:47,060 --> 00:22:51,770
如果您转到love.load函数 我们会看到在第47行使用了这个函数 
If you go to our love.load function, we see this being used on line 47.

454
00:22:51,770 --> 00:22:54,410
我们现在不是love.window.setmode 而是
Instead of love.window.setmode, we're now

455
00:22:54,410 --> 00:22:59,000
使用推送设置屏幕、推送库设置屏幕功能 
using push setup screen, the push libraries setup screen function,

456
00:22:59,000 --> 00:23:02,570
它需要一个虚拟的宽度 一个虚拟的高度 我们的常规窗口
where it takes a virtual width, a virtual height, our regular window

457
00:23:02,570 --> 00:23:05,840
宽度和我们的窗口高度 然后是和以前一样的表 
width and our window height, and then the same table as before.

458
00:23:05,840 --> 00:23:09,850
这样做的效果是设置了一个窗口 
And this has the effect of setting up a window that's

459
00:23:09,850 --> 00:23:12,710
得到了1280乘720的具体尺寸 
got our concrete dimensions of 1280 by 720,

460
00:23:12,710 --> 00:23:16,580
而是432x243的虚拟分辨率 
but a virtual resolution of 432 by 243.

461
00:23:16,580 --> 00:23:20,480
所以现在 当它呈现时 就像我们很快会看到的那样 
And so now, when it renders, as we'll see shortly, as--

462
00:23:20,480 --> 00:23:23,425
嗯 正如我们已经看到的 实际上 它被放大了 
well, as we already did see, actually, it's magnified.

463
00:23:23,425 --> 00:23:28,490
它的效果是给我们一个较低的分辨率 
It has the effect of giving us a lower resolution.

464
00:23:28,490 --> 00:23:32,930
在第58行 如果我们看一下love.key按下的函数 
And in line--on line 58, if we look at the love.keypressed function,

465
00:23:32,930 --> 00:23:37,400
我们放在那里 如果键等于字符串转义 
we've put in there, if the key equals the string escape,

466
00:23:37,400 --> 00:23:39,500
然后是爱 事件 退出 
then love.event.quit.

467
00:23:39,500 --> 00:23:41,030
所以现在我们有了输入处理 
So now we have input handling.

468
00:23:41,030 --> 00:23:45,530
我们已经覆盖了Love 按下键(Key) 这是Love 2D将会看到的
We've overridden love.keypressed(key), which LOVE 2D is going to look

469
00:23:45,530 --> 00:23:47,919
在我们的应用程序中 然后根据需要调用 
for in our application, and then call as needed.

470
00:23:47,919 --> 00:23:49,460
然后我们只是往里面看 
And then we're just looking in there.

471
00:23:49,460 --> 00:23:52,250
如果关键字是退出 那么就是love.vent.Quit 
If the key is escape, then love.event.quit.

472
00:23:52,250 --> 00:23:56,180
如果我运行这个应用程序 我现在可以按键盘上的Ess键
And if I run the application, I can now press escape on my keyboard

473
00:23:56,180 --> 00:23:59,780
只需退出它 而不必命令退出或点击
and just quit it and not have to command quit or click

474
00:23:59,780 --> 00:24:03,450
Windows应用程序上的X 
the X on a Windows application.

475
00:24:03,450 --> 00:24:08,140
我们还更改了另外一件事 在第70行的love.Draw函数中 
And we've changed one more thing, also, in the love.draw function on line 70.

476
00:24:08,140 --> 00:24:10,820
我们现在正在使用推送库 
We're using the push library now.

477
00:24:10,820 --> 00:24:14,270
我们需要--它的功能有点像状态机 因为我们
We need to-- it functions sort of as a state machine in that we

478
00:24:14,270 --> 00:24:17,240
将其设置为使用推送以虚拟分辨率开始渲染
set it to start rendering at a virtual resolution with push

479
00:24:17,240 --> 00:24:21,176
应用开始 然后按应用结束 然后应用之间的任何内容 
apply start, and then push apply end, and then anything in between,

480
00:24:21,176 --> 00:24:23,300
这实际上与Open Go的工作原理非常相似 
this is very similar actually to how Open Go works.

481
00:24:23,300 --> 00:24:25,110
我们不会涉及太多细节 
We won't go into too much detail.

482
00:24:25,110 --> 00:24:30,860
但这在精神上与Open Go编程的效果非常相似 
But this is very similar in spirit to how much of Open Go programming works.

483
00:24:30,860 --> 00:24:32,810
按应用开始 按应用结束 
Push apply start, push apply end.

484
00:24:32,810 --> 00:24:37,110
在这两者之间 无论我们称之为什么 都将以这个虚拟分辨率进行渲染 
Between that, whatever we call, is going to render at this virtual resolution.

485
00:24:37,110 --> 00:24:40,250
因此 我们调用相同的love.graph ics.print(F)函数 
And so we are calling the same love.graphics.print(f) function,

486
00:24:40,250 --> 00:24:43,490
你好 零点乒乓球 虚拟高度除以2减6 
hello Pong Zero, virtual high divided by two minus six.

487
00:24:43,490 --> 00:24:44,810
相同的参数 
Same parameters.

488
00:24:44,810 --> 00:24:48,680
它的效果是渲染仍然存在的一切
And it has the effect of rendering everything that's still got

489
00:24:48,680 --> 00:24:53,840
皮肤上的旧别名--
the old aliasing going on the skin--

490
00:24:53,840 --> 00:24:58,150
纹理过滤的效果就是让我们看到放大的文本 
texture filtering going on as the effect of giving us our magnified text.

491
00:24:58,150 --> 00:25:02,910
所以相同的文本 相同的大小 但现在我们的渲染窗口要小得多 
So same text, same size, but now our window of rendering is much smaller.

492
00:25:02,910 --> 00:25:04,550
所以--
So--

493
00:25:04,550 --> 00:25:08,660
到目前为止 对这一切是如何运作的有什么问题吗？
Any questions so far on how any of this works?

494
00:25:08,660 --> 00:25:09,160
好的 
OK.

495
00:25:09,160 --> 00:25:10,580
太棒了 
Awesome.

496
00:25:10,580 --> 00:25:14,660
所以我们把文本直接放到了屏幕上 但我们离Pong还差得远
So we've gotten text right into the screen, but we're nowhere close to Pong

497
00:25:14,660 --> 00:25:16,910
然而 所以我认为第一件大事 就是
yet, so the first big thing, I think, that's

498
00:25:16,910 --> 00:25:20,210
让我们朝那个方向走得更近 这就是我们
going to get us closer in that direction is what we're

499
00:25:20,210 --> 00:25:22,040
将调用矩形更新 
going to call the rectangle update.

500
00:25:22,040 --> 00:25:26,080
所以我们应该看看一些重要的功能 
So some important functions that we should look at.

501
00:25:26,080 --> 00:25:27,800
Love.graph ics.newFont.
Love.graphics.newFont.

502
00:25:27,800 --> 00:25:30,860
我相信默认字体是Arial 
The default font, I believe, is Arial.

503
00:25:30,860 --> 00:25:33,819
我们不想让Arial出现在我们的应用程序中 因为我们需要一些
We don't want Arial in our application, because we want something

504
00:25:33,819 --> 00:25:35,110
这看起来有点复古 
that looks a little more retro.

505
00:25:35,110 --> 00:25:38,570
我们想要一些看起来更相关的东西 
We want something that looks more relevant.

506
00:25:38,570 --> 00:25:43,400
NewFont基本上将采用一个指向字体文件的路径
Love.graphics.newFont will basically take a path to a font file

507
00:25:43,400 --> 00:25:49,050
在我们的文件夹中 如果您在Pong 2文件夹 
that we have in our folder, which if you're in the Pong 2 folder,

508
00:25:49,050 --> 00:25:53,420
您将看到一个Font.ttf文件和一个大小 
you'll see a font.ttf file, and a size.

509
00:25:53,420 --> 00:25:55,760
因为我们实例化的每个字体对象
Because every font object that we instantiate

510
00:25:55,760 --> 00:25:59,240
需要有一个大小 因为字体对象是不变的 
needs to have a size, because the font objects are immutable.

511
00:25:59,240 --> 00:26:03,560
一旦构建 它们就不能更改 因此需要按大小进行分配
Once constructed, they cannot be changed so they need to be allocated on a size

512
00:26:03,560 --> 00:26:05,560
按大小计算 
by size basis.

513
00:26:05,560 --> 00:26:08,540
SetFont将采用任何字体
Love.graphics.setFont will take whatever font

514
00:26:08,540 --> 00:26:13,070
对象 我们可以在这里设置它
object we've acquired from this function call, and we can set it here

515
00:26:13,070 --> 00:26:17,630
它会将Love 2D中的活动字体设置为该字体 
and it'll set the active font in LOVE 2D to be that font.

516
00:26:17,630 --> 00:26:20,240
同样 爱情也是一台状态机
Love is a state machine in the same sense

517
00:26:20,240 --> 00:26:25,520
与以前一样 它将在任何时候都具有活动字体 
as before, in that it will have an active font at any one time,

518
00:26:25,520 --> 00:26:29,630
无论您调用什么打印函数 都将使用当前活动的字体 
and whatever print functions you call, will use the currently active font.

519
00:26:29,630 --> 00:26:33,590
这也适用于您可能想要渲染到屏幕上的任何颜色 
And that also applies to whatever color you might want to render to the screen,

520
00:26:33,590 --> 00:26:34,260
管他呢 
whatever.

521
00:26:34,260 --> 00:26:37,070
如果您有一种字体 并且想要将其呈现为红色 
If you have a font and you want to maybe render it in red,

522
00:26:37,070 --> 00:26:42,080
你也需要一套LOVE 2D的主动色到红色 
you need a set LOVE 2D's active color to red as well.

523
00:26:42,080 --> 00:26:47,330
Clear是一个接受RGBA四元组的函数 
Love.graphics.clear is a function that takes an RGBA quadruple,

524
00:26:47,330 --> 00:26:49,956
并将以该颜色刷新屏幕 
and will flush the screen in that color.

525
00:26:49,956 --> 00:26:52,580
它只有一个简单的效果 就是用那种颜色擦拭屏幕 
It just has a simple effect of wiping the screen in that color.

526
00:26:52,580 --> 00:26:55,512
对于仅绘制纯色背景非常有用 
Useful for drawing just flat color backgrounds.

527
00:26:55,512 --> 00:26:58,220
然后是最后一个功能 可能是最重要的功能 
And then the last function, probably the most important function,

528
00:26:58,220 --> 00:27:00,322
是love.graph ics.Rectangle 
is love.graphics.rectangle.

529
00:27:00,322 --> 00:27:02,030
这是我们将使用的第一个函数
And this is the first function that we'll

530
00:27:02,030 --> 00:27:05,540
看 这实际上是在屏幕上绘制文本以外的东西 
see that actually ends up drawing something beyond text to the screen.

531
00:27:05,540 --> 00:27:09,620
它采用一种模式 可以是填充或线条、x和y
It takes it a mode, which can be fill or line, an x and a y

532
00:27:09,620 --> 00:27:13,140
宽度和高度 它将在该模式下绘制一个矩形 
and a width and a height, and it'll draw a rectangle in that mode.

533
00:27:13,140 --> 00:27:16,610
所以要么是实心 要么是实心矩形 要么是线条矩形 
So either filled, so a filled rectangle, or a line rectangle.

534
00:27:16,610 --> 00:27:19,550
它会--它会用宽度和高度把它画在xy处
It'll take-- it'll draw it at xy with the width and the height

535
00:27:19,550 --> 00:27:21,420
我们把它传进去 
that we pass in.

536
00:27:21,420 --> 00:27:24,240
那么让我们继续下去 看看乒乓球2
So let's go ahead and take a look at Pong 2

537
00:27:24,240 --> 00:27:27,800
在那里我们可以看到这一点实际上得到了实施 
where we can see this actually implemented.

538
00:27:27,800 --> 00:27:31,640
所以Pong 2 我们有我们的Font.ttf 我已经把它包括在内了 
So Pong 2, we have our font.ttf in there that I've included.

539
00:27:31,640 --> 00:27:33,179
然后是一条主流星 
And then a main.lua.

540
00:27:33,179 --> 00:27:35,220
顺便说一句 我忘了提到最后一个例子 
And by the way, I forgot to mention last example,

541
00:27:35,220 --> 00:27:39,330
我们所需的PUSH库也在同一目录中 
push the library that we required is also just in the same directory.

542
00:27:39,330 --> 00:27:43,790
只要文件在目录中 您就可以要求 
And you can just do require as long as the file is there within the directory,

543
00:27:43,790 --> 00:27:45,170
它会直接把它装上 
it will just load it.

544
00:27:45,170 --> 00:27:46,670
您不必指定.lua 
You don't have to specify .lua.

545
00:27:46,670 --> 00:27:52,580
它假定当您需要某个字符串时 它后跟.lua后缀 
It assumes when you require some string, that it follows with the .lua suffix.

546
00:27:52,580 --> 00:27:56,780
所以我们在这里看的是Pong 2中的main.lua 矩形的更新 
So we're here looking at main.lua in Pong 2, the rectangle update.

547
00:27:56,780 --> 00:27:59,900
所以在第28行到第34行 都是一样的东西 
So on line 28 to 34, it's all the same stuff.

548
00:27:59,900 --> 00:28:00,800
我们正在获得推力 
We're acquiring push.

549
00:28:00,800 --> 00:28:04,210
我们在虚拟和物理上都有自己的宽度和高度 
We have our width and height virtually and physically.

550
00:28:04,210 --> 00:28:08,120
在love.load函数中 我们位于第43行
In our love.load function, we are on line 43

551
00:28:08,120 --> 00:28:13,100
将小字体声明为love.graph ics.newFont 
declaring small font to be a love.graphics.newFont,

552
00:28:13,100 --> 00:28:15,590
将路径指定为font.ttf 因为它就在那里
giving it the path font.ttf because it's right there

553
00:28:15,590 --> 00:28:17,720
在同一个目录中 大小为8 
in the same directory at size eight.

554
00:28:17,720 --> 00:28:21,260
这将创建一个字体对象 小字体 然后我们就可以
And this is going to create a font object, small font, that we can then

555
00:28:21,260 --> 00:28:24,600
根据需要设置为活动字体 
set as the active font as needed.

556
00:28:24,600 --> 00:28:29,930
因此 如果我们深入到同一目录中的第78行 
So if we go down to line 78 in the same directory,

557
00:28:29,930 --> 00:28:32,432
我们看到我们正在调用love.graph 清楚 
we see we're calling love.graphics.clear,

558
00:28:32,432 --> 00:28:33,890
所以我们用一种颜色来传递它 
and so we're passing it in a color.

559
00:28:33,890 --> 00:28:36,890
我在谷歌图片上试用了一些乒乓球的图片
I sampled some images of Pong on Google Images

560
00:28:36,890 --> 00:28:45,050
我看到了我喜欢的背景灰色 所以40 45 52 RGB 然后255
and saw a background gray that I liked, so 40, 45, 52, RGB, and then 255 just

561
00:28:45,050 --> 00:28:49,727
意味着完全不透明 因此没有透明度 即Alpha分量 
means completely opaque, so no transparency, the alpha component.

562
00:28:49,727 --> 00:28:51,560
然后我们执行相同的打印 函数
And then we're doing the same print.function

563
00:28:51,560 --> 00:28:53,210
就像我们之前在81号线上做的那样 
as we did before on line 81.

564
00:28:53,210 --> 00:28:56,990
在第89行到第95行下面 我们实际上是
Below that on line 89 down through 95, we're actually

565
00:28:56,990 --> 00:28:59,600
调用love.graph ics.rectang.
calling love.graphics.rectangle.

566
00:28:59,600 --> 00:29:02,210
这是画两个球拍 然后是球 
And these are drawing the two paddles and then the ball.

567
00:29:02,210 --> 00:29:05,720
所以 注意 love.graph 矩形填充模式 
So, note, love.graphics.rectangle fill mode,

568
00:29:05,720 --> 00:29:09,320
因为我们希望球拍完全充满 球也是如此 
because we want the paddles to be completely filled, as is the ball.

569
00:29:09,320 --> 00:29:14,450
我们给它的XY是1030 宽度高度是520 
We're giving it an xy of 1030 and a width height of 520.

570
00:29:14,450 --> 00:29:19,280
在992年 我们--这会产生一点影响
And on 992, we're-- and that'll have the effect of drawing it a little bit

571
00:29:19,280 --> 00:29:23,270
从左上角移动 宽5个像素 高20个像素 
shifted from the top left corner, five pixels wide, 20 pixels tall.

572
00:29:23,270 --> 00:29:26,300
在第92行 我们在做同样的事情 除了我们
On line 92, we're doing the same thing, except we're

573
00:29:26,300 --> 00:29:28,260
实际宽度减去10 
going virtual width minus 10.

574
00:29:28,260 --> 00:29:32,040
所以它会移到我们屏幕的右边 虚拟宽度减去10 
So it's going to go to the right edge of our screen, virtual width minus 10.

575
00:29:32,040 --> 00:29:33,660
所以432减去10 
So 432 minus 10.

576
00:29:33,660 --> 00:29:36,260
所以是422 
So 422.

577
00:29:36,260 --> 00:29:38,370
然后是虚拟身高减去50 
And then virtual height minus 50.

578
00:29:38,370 --> 00:29:41,382
所以这将是一个轻微的--
So it's going to be slightly--

579
00:29:41,382 --> 00:29:43,840
它将从屏幕底部略微向上 
it's going to be slightly up from the bottom of the screen.

580
00:29:43,840 --> 00:29:47,540
所以我们有左上角和右下角的划桨 
So we have our top left paddle and our bottom right paddle.

581
00:29:47,540 --> 00:29:48,920
然后球就在中心了 
And then the ball is dead center.

582
00:29:48,920 --> 00:29:52,070
所以我们坐着--做另一个图形--矩形调用 
So we're sitting-- doing another graphics-- rectangle call.

583
00:29:52,070 --> 00:29:54,080
虚拟宽度减去2除以2 
Virtual width minus two divided by two.

584
00:29:54,080 --> 00:29:56,300
所以就在中间 减去2 因为我们的球
So right in the middle, minus two, because our ball

585
00:29:56,300 --> 00:29:58,550
将是两个像素宽乘以两个像素高 
is going to be two pixels wide by two pixels tall.

586
00:29:58,550 --> 00:30:00,466
虚拟身高也是如此 减去2 
And same thing with virtual height, minus two.

587
00:30:00,466 --> 00:30:03,080
我们的虚拟身高除以2 减去2 
Our virtual height divided by two, minus two.

588
00:30:03,080 --> 00:30:08,040
所以我将继续CD到Pong 2目录并运行它 
So I'm going to go ahead and CD into the Pong 2 directory and run it.

589
00:30:08,040 --> 00:30:11,790
这样的效果就是我们的新字体在中间 
And that has the effect of we have our new font here in the middle.

590
00:30:11,790 --> 00:30:16,040
所以它看起来很好 复古 比以前的Arial字体更好 
So it looks nice and retro, much more so than the Arial font as before.

591
00:30:16,040 --> 00:30:19,149
我们有一个长方形 5像素宽 20像素高 
We have a rectangle here, five pixels wide by 20 pixels tall.

592
00:30:19,149 --> 00:30:21,440
中间的一个球 4像素宽 
A ball in the middle, which is four pixels wide by four

593
00:30:21,440 --> 00:30:23,940
像素高 右下角有一个桨 
pixels tall, and then a paddle on the bottom right,

594
00:30:23,940 --> 00:30:27,260
和左边的桨的尺寸一样 
which is the same dimensions as the paddle on the left.

595
00:30:27,260 --> 00:30:29,407
它看起来很像Pong 
So it looks very similar to Pong.

596
00:30:29,407 --> 00:30:32,240
它一点也不互动 但我们可以感觉到
It's not interactive at all, but we sort of getting the feel of what

597
00:30:32,240 --> 00:30:33,781
我们希望我们的应用程序看起来像 
we want our application to look like.

598
00:30:33,781 --> 00:30:35,930
我们已经大致勾勒出来了 
We have it mostly sketched out.

599
00:30:35,930 --> 00:30:41,160
有什么问题吗？
So any questions so far as to how this works?

600
00:30:41,160 --> 00:30:41,660
好的.
OK.

601
00:30:41,660 --> 00:30:43,440
棒了
Awesome.

602
00:30:43,440 --> 00:30:44,340
3.我的超能力
So Pong 3.

603
00:30:44,340 --> 00:30:48,587
所以目前我们还没有与我们的应用程序进行交互 
So currently we have no interactivity with our application,

604
00:30:48,587 --> 00:30:50,670
我们希望能够移动电极板 
and we want to be able to move the paddles around.

605
00:30:50,670 --> 00:30:53,552
我们不想一直看着一张照片
We don't want to just be looking at an-- at an image the whole time.

606
00:30:53,552 --> 00:30:56,010
因此 桨更新将为我们解决这个问题 
So the paddle update is going to solve this problem for us.

607
00:30:56,010 --> 00:30:59,735
我们将得到第一种--除了按下Escape之外
We're going to actually get our first sort of-- beyond pressing escape

608
00:30:59,735 --> 00:31:01,860
退出应用程序 我们将得到一个感觉 
to quit the application, we're going to get a sense

609
00:31:01,860 --> 00:31:04,200
与之动态互动 
of interacting with it dynamically.

610
00:31:04,200 --> 00:31:07,620
所以我们在这个例子中要看的重要函数
So the important function that we're going to look at in this example

611
00:31:07,620 --> 00:31:11,310
就是love. keyboard. isDownsomeKey
is love.keyboard.isDownsomekey.

612
00:31:11,310 --> 00:31:13,597
这是一个布尔函数 
And this is true-- this is a Boolean function.

613
00:31:13,597 --> 00:31:16,680
它只是返回true或false取决于我们传入的密钥
It just returns true or false depending on whether the key that we pass in

614
00:31:16,680 --> 00:31:21,420
因为一根弦现在被压在这个框架上 
as a string is currently pressed down on this frame.

615
00:31:21,420 --> 00:31:23,980
所以它只返回true或false 
So it just returns true or false.

616
00:31:23,980 --> 00:31:27,030
让我们来看看演示 
And so let's go ahead and take a look at the demo.

617
00:31:27,030 --> 00:31:31,110
我们要继续前进 并拉上乒乓3 
We're going to go ahead and pull up Pong 3.

618
00:31:31,110 --> 00:31:32,670
主路阿 他们进来了 
The main.lua, they're in.

619
00:31:35,430 --> 00:31:39,640
注意第37行 如果你在看乒乓球3 我们有一个新的常数
Notice that line 37 if you're looking in Pong 3 we, have a new constant

620
00:31:39,640 --> 00:31:43,260
我们定义了桨速 它的值为200 
we've defined called paddle speed, which gets the value 200.

621
00:31:43,260 --> 00:31:46,279
这只是一个任意的值 我发现这是一个很好的速度 
And this is just an arbitrary value that I found was a good speed.

622
00:31:46,279 --> 00:31:48,320
但这就是我们的桨移动的速度 
But this is how fast our paddle is going to move.

623
00:31:48,320 --> 00:31:50,280
我们将用时间增量来衡量它 
We're going to scale it by delta time, so we're

624
00:31:50,280 --> 00:31:53,670
乘以过去的秒数 
going to multiply it by how many seconds have passed.

625
00:31:53,670 --> 00:31:56,100
通常 自上一帧起的几分之一秒 
Typically, a fraction of a second since the last frame.

626
00:31:56,100 --> 00:31:59,040
因此 它将移动相同的距离
And this is going to, therefore, move the same distance

627
00:31:59,040 --> 00:32:01,050
随着时间的推移 这取决于您的计算机是否
over time depending on whether your computer is

628
00:32:01,050 --> 00:32:05,230
以每秒10帧或每秒60帧运行 
running at 10 frames per second or 60 frames per second.

629
00:32:05,230 --> 00:32:10,680
如果我们在第63行 我也设置了两个新变量 
So if we go down here to line 63, I've also set up two new variables.

630
00:32:10,680 --> 00:32:12,630
一号选手得分二号选手得分 
Player one score and player two score.

631
00:32:12,630 --> 00:32:14,550
它们都初始化为零 
Those are both initialized at zero.

632
00:32:14,550 --> 00:32:19,920
我们将在这个例子中添加一些乐谱的渲染 
We're going to add in this example, also, some rendering of the score.

633
00:32:19,920 --> 00:32:22,470
注意在第49行 我还添加了
And notice here on line 49, I've also added

634
00:32:22,470 --> 00:32:26,130
一种新的字体 它展示了如何根据字体的大小来区分字体
a new font, which showcases how you need to separate fonts based on their size

635
00:32:26,130 --> 00:32:27,660
因为它们是不可变的对象 
because they're immutable objects.

636
00:32:27,660 --> 00:32:30,090
分数字体得到love.graphics.newFont.
Score font gets love.graphics.newFont.

637
00:32:30,090 --> 00:32:35,430
完全一样的字体文件 但它是32像素大 因为字体-或分数
Same exact font file, but it's 32 pixels large because the font-- or the score

638
00:32:35,430 --> 00:32:38,947
当在Pong中渲染时 屏幕中间相当大 
when rendered in Pong is pretty large in the middle of the screen.

639
00:32:38,947 --> 00:32:41,280
我们现在有两种不同的字体 
And so we're creating-- we have two different fonts now.

640
00:32:41,280 --> 00:32:44,210
一个用来传递我们的信息 一个用来传递我们的分数 
One for rendering our message, one for rendering our score.

641
00:32:44,210 --> 00:32:47,460
它只会呈现这两个变量 参与人1的得分和参与人
And it's just going to render these two variables, player one score and player

642
00:32:47,460 --> 00:32:48,630
两百 
two score.

643
00:32:48,630 --> 00:32:52,260
然后我们也初始化了y值
And then we've also initialized our y values

644
00:32:52,260 --> 00:32:55,290
对于长方形 左边和右边的桨 
for the rectangles, the paddles on the left and the right.

645
00:32:55,290 --> 00:32:58,410
我们需要跟踪他们的y位置 因为乒乓球中的球拍
We need to keep track of their y position, because paddles in Pong

646
00:32:58,410 --> 00:33:00,330
只能上下移动 
can only move up or down.

647
00:33:00,330 --> 00:33:02,787
所以参与人1 Y得到的值和之前一样
So player 1Y gets the same value it did before when

648
00:33:02,787 --> 00:33:05,370
当我们把矩形画到屏幕上时 我们初始化了它 
we initialized the rectangle, when we drew it onto the screen.

649
00:33:05,370 --> 00:33:07,740
它将从30日元开始 所以相当高 
It's going to start at y 30, so pretty high up.

650
00:33:07,740 --> 00:33:10,350
参与人2 y从很低的虚拟高度开始
And player 2y is going to start pretty low, virtual height

651
00:33:10,350 --> 00:33:14,250
减去50 也就是432减去50
minus 50, which is 432 minus 50.

652
00:33:14,250 --> 00:33:17,760
所以在爱.更新 这是我们第一次实际使用的更新
And so in love.update, which is our first actual use of the update

653
00:33:17,760 --> 00:33:21,780
第75行的函数 带有传入的（dt）参数 
function on line 75 with the (dt) parameter that gets passed in.

654
00:33:21,780 --> 00:33:24,320
请注意 记住 爱2D将为我们传递 
Note, remember that LOVE 2D will pass that in for us,

655
00:33:24,320 --> 00:33:27,570
但我们需要给它--我们需要定义它里面的行为 
but we need to give it-- we need to define the behavior inside of it.

656
00:33:27,570 --> 00:33:31,770
我们使用love.keyboard.isDown 并传入字符串w
We're using love.keyboard.isDown, and we're passing in the string w

657
00:33:31,770 --> 00:33:33,590
S为这第一个街区 
and s for this first block.

658
00:33:33,590 --> 00:33:36,000
这里的第一个块是一号选手的动作 
This first block here is player one's movement.

659
00:33:36,000 --> 00:33:40,680
所以 传统上 在计算机上WASD是移动的--
So, traditionally, on computer WASD is to move--

660
00:33:40,680 --> 00:33:43,950
在这个例子中 我们将允许我们自己移动两个球拍 
and this example, we're going to allow ourselves to move both paddles,

661
00:33:43,950 --> 00:33:46,170
因此 我们将使用w和S作为左桨 
so we're going to use w and s for the left paddle,

662
00:33:46,170 --> 00:33:48,030
然后向上或向下划向右划桨 
and up or down for the right paddle.

663
00:33:48,030 --> 00:33:51,050
所以如果love.keyboard.isDown w 这意味着--
So if love.keyboard.isDown w, which means--

664
00:33:51,050 --> 00:33:54,660
或者我们现在正在按W键 玩家1Y
or we've currently pressing the W key, player 1y

665
00:33:54,660 --> 00:34:00,040
等于它自己 加上负的划桨速度乘以增量时间 
is going to get itself, plus negative paddle speed times delta time.

666
00:34:00,040 --> 00:34:01,450
所以它会向上移动 
So it's going to move up.

667
00:34:01,450 --> 00:34:04,924
它将采用负的划桨速度 乘以增量时间 
It's going to take negative paddle speed, multiply it by delta time,

668
00:34:04,924 --> 00:34:06,840
然后把它加到我们的y值上 它将会有
and add that onto our y value, which will have

669
00:34:06,840 --> 00:34:08,580
把我们的球拍向上移动的效果 
the effect of shifting our paddle up.

670
00:34:08,580 --> 00:34:10,469
而事实恰恰相反--
And it's the opposite for--

671
00:34:10,469 --> 00:34:13,480
在82行--如果我们按S键 
on line 82 for-- if we're pressing the s key.

672
00:34:13,480 --> 00:34:17,870
我们需要以正的划桨速度来增加y 因为回想一下 
We need to increase the y by positive paddle speed, because recall,

673
00:34:17,870 --> 00:34:19,560
Y轴运动是--
y-axis movement is--

674
00:34:19,560 --> 00:34:22,359
上涨是负数 下跌是正数 
up is negative, down is positive.

675
00:34:22,359 --> 00:34:24,900
我们用右边的球拍做同样的事情
We're doing the exact same thing with the paddle on the right

676
00:34:24,900 --> 00:34:30,570
只是我们使用UP和DOWN作为love.keyboard.isDown的字符串 
except we're using up and down as the strings into love.keyboard.isDown.

677
00:34:30,570 --> 00:34:36,000
然后在下面的下面 我们正在渲染另外
And then down below here, we are rendering in addition

678
00:34:36,000 --> 00:34:38,940
我们之前呈现的东西 现在也是比分 
to what we rendered before, also, the score now.

679
00:34:38,940 --> 00:34:44,185
因此在第125行 请注意我们调用的是love.graph ics.setFont Scott Font 
So on line 125, note that we're calling love.graphics.setFont, scoreFont,

680
00:34:44,185 --> 00:34:47,310
因为如果我们不调用它 它将使用上一种字体 
because if we don't call this, it will use just whatever the last font was,

681
00:34:47,310 --> 00:34:49,830
默认情况下是8像素字体 因为我们设置了
which by default is the eight pixel font because we set that

682
00:34:49,830 --> 00:34:51,840
在我们的节目中排在首位 
up top in our program.

683
00:34:51,840 --> 00:34:54,030
我们希望将其设置为乐谱字体 然后我们
We want to set it to the score font, and then we

684
00:34:54,030 --> 00:34:55,770
我想调用love.graph ics.print 
want to call love.graphics.print.

685
00:34:55,770 --> 00:34:59,520
在本例中 我只是在具体的地方打印它们 而不是使用printf 
In this case, I'm just printing them in concrete places not, using printf.

686
00:34:59,520 --> 00:35:01,820
虚拟宽度除以2减去50 
Virtual width divided by two minus 50.

687
00:35:01,820 --> 00:35:03,570
因此 无论我们如何调整窗口 它都是
So no matter how we scale our window, it's

688
00:35:03,570 --> 00:35:08,820
始终是窗口中心左侧的50个像素 
always going to be 50 pixels to the left of the center of the window,

689
00:35:08,820 --> 00:35:12,040
和窗口中心右侧的30个像素
and the 30 pixels to the right of the center of the window

690
00:35:12,040 --> 00:35:16,780
如果我们给玩家两分的话 
if we're rendering the player two score.

691
00:35:16,780 --> 00:35:23,150
因此 如果我们进入Pong 3并运行它 它看起来和以前一样 
And so if we go into Pong 3 and we run it, it looks the same as before.

692
00:35:23,150 --> 00:35:26,880
请注意 我们现在在屏幕中间有一个分数 0和0 
Note, that we do have a score now in the middle of the screen, zero and zero.

693
00:35:26,880 --> 00:35:30,720
但是 更重要的是 我们可以上下移动我们的球拍 
But, more importantly, we can move our paddles up and down.

694
00:35:30,720 --> 00:35:34,140
但有一个问题 那就是我可以移动到屏幕边缘之外 
But there's one problem, and that's I can move beyond the edge of the screen,

695
00:35:34,140 --> 00:35:37,320
这不是我们在应用程序中想要的行为 
which is not behavior that we want in our application.

696
00:35:37,320 --> 00:35:40,310
所以我们有一些互动 它在向前发展 
So we have some interactivity, it's moving along,

697
00:35:40,310 --> 00:35:42,570
但不幸的是 我们还有很长的路要走 
but we still have a long way to go, unfortunately.

698
00:35:42,570 --> 00:35:43,890
或者幸运的是 
Or fortunately.

699
00:35:43,890 --> 00:35:47,340
所以让我们继续来看看球的最新情况 
So let's go ahead and look at the ball update.

700
00:35:47,340 --> 00:35:52,710
所以我们有了桨 它们可以移动 它们可以移动到屏幕边缘之外 
So we have paddles, they can move, they can move beyond the edge of the screen,

701
00:35:52,710 --> 00:35:57,070
但是我们没有一个球--它只是坐在屏幕的中央 
but we don't have a ball that-- it just sits in the middle of the screen.

702
00:35:57,070 --> 00:35:58,704
这不是我们要找的 
And that's not what we're looking for.

703
00:35:58,704 --> 00:36:01,620
我们想要一个可以在球拍之间弹跳的球 
We want to have a ball that we can actually bounce between the paddles

704
00:36:01,620 --> 00:36:04,314
这样我们就可以得到一场真正的游戏 而不仅仅是移动球拍 
so we can get an actual game going beyond just moving paddles.

705
00:36:04,314 --> 00:36:06,480
所以我们要看几个重要的函数 
So a few important functions we're going to look at.

706
00:36:06,480 --> 00:36:09,250
我们将在这里随机第一次看到 
We're going to get our first look here at random.

707
00:36:09,250 --> 00:36:13,710
所以在游戏中 随机数的产生是一件很常见的事情
So in games, random number generation is a very common thing

708
00:36:13,710 --> 00:36:17,370
这样我们就可以在不同实例之间获得不可预测性和可变性
so that we get unpredictability and variability between different instances

709
00:36:17,370 --> 00:36:18,982
在我们的比赛中 
of our game.

710
00:36:18,982 --> 00:36:20,940
一个只属于Lua的重要功能 
An important function that just belongs to Lua.

711
00:36:20,940 --> 00:36:23,010
这不是爱情2D的事情 这只是Lua的事情 
It's not a LOVE 2D thing, it's just a Lua thing.

712
00:36:23,010 --> 00:36:25,530
数学 随机种子数 
Math.random seed numb.

713
00:36:25,530 --> 00:36:28,620
你们中的许多人可能都听说过像种子这样的名字 
So many of you have probably heard of like seed,

714
00:36:28,620 --> 00:36:30,990
就像一个随机数生成器 种子 这就是
like a random number generator, seed, and that just

715
00:36:30,990 --> 00:36:33,150
表示随机数生成器 
means a random number generator.

716
00:36:33,150 --> 00:36:35,310
因为它是伪随机的 所以它需要某种排序
Because it's pseudo random, it needs some sort

717
00:36:35,310 --> 00:36:38,850
其所有随机数的起始值 
of starting value to base all of its random numbers off of.

718
00:36:38,850 --> 00:36:42,330
它接受一个起始数字 它执行一些数学运算
It takes a starting number, it performs some mathematical operation

719
00:36:42,330 --> 00:36:45,810
得出新的随机值 然后我们就可以
on that number to derive new random values that we can then

720
00:36:45,810 --> 00:36:46,990
在我们的游戏引擎中使用 
use in our game engine.

721
00:36:46,990 --> 00:36:49,396
但如果我们每次都给它相同的数字 
But if we give it the same number every single time,

722
00:36:49,396 --> 00:36:52,270
它每次都会给我们相同的随机数 
it's just going to give us the same random numbers every single time,

723
00:36:52,270 --> 00:36:53,890
这意味着它根本不会是随机的 
which means it's not going to be random at all.

724
00:36:53,890 --> 00:36:55,420
这将是非常一致的 
It's going to be very consistent.

725
00:36:55,420 --> 00:36:58,530
因此 我们需要一种方法来生成随机数生成器 
So we need a way to seed our random number generator,

726
00:36:58,530 --> 00:37:01,930
给它一个不同的初始值或种子 
give it a different initial value or seed,

727
00:37:01,930 --> 00:37:06,300
我们将用函数数学来实现这一点 随机种子 
and we're going to do that with the function math.randomseed somenumb.

728
00:37:06,300 --> 00:37:09,930
在这种情况下 时间是一个重要的函数 
OS.time is an important function in the context of this,

729
00:37:09,930 --> 00:37:13,980
因为每次获得不同号码的一种非常常见的方法
because a very common way of getting a different number every time

730
00:37:13,980 --> 00:37:17,550
无论当前时间是什么时间 运行应用程序都是在传递它
you run your application is passing it in whatever the current time is

731
00:37:17,550 --> 00:37:20,940
几秒钟内 因为通常是一个非常大的数字
in seconds, because usually it's a very large number that

732
00:37:20,940 --> 00:37:24,210
无论如何 每次运行游戏时都会有所不同 
is going to be different every single time you run your game, no matter what.

733
00:37:24,210 --> 00:37:27,150
因为它的基础是 在大多数发动机的背景下 
Because it's based upon, in the context of most engines,

734
00:37:27,150 --> 00:37:32,450
在Lua的上下文中 所谓的Unix纪元时间是零
in the context of Lua, what's called Unix Epoch time, which is zero

735
00:37:32,450 --> 00:37:39,150
零UTC 1970年1月1日 这是一个巨大的数字 有9位或10位数长
zero UTC January 1st, 1970, which is some huge number nine or 10 digits long

736
00:37:39,150 --> 00:37:41,995
这种情况每时每刻都在改变 
that changes every single second.

737
00:37:41,995 --> 00:37:44,370
然后 为了真正利用这一切 
And then in order to actually take advantage of all this,

738
00:37:44,370 --> 00:37:46,119
我们需要一个函数来获得一个随机数 
we need a function to get a random number,

739
00:37:46,119 --> 00:37:49,427
所以我们用数学 随机 它需要最小值和最大值 
and so we do that with math.random, which takes a min and a max,

740
00:37:49,427 --> 00:37:51,510
尽管从技术上讲 你不需要通过一分钟 
although you don't need to technically pass a min,

741
00:37:51,510 --> 00:37:56,670
如果不传递min 它只会隐式地将min作为1来使用 
it'll just implicitly deuse min as one if you don't pass it a min.

742
00:37:56,670 --> 00:37:59,590
它将返回一个包含在该范围内的值 
And it'll return a value inclusively within that range.

743
00:37:59,590 --> 00:38:02,790
所以如果你说数学 随机一 50 它会给我们
So if you say math.random one, 50, it'll give us

744
00:38:02,790 --> 00:38:04,890
介于1和50之间的随机数 
a random inclusively between 1 and 50.

745
00:38:04,890 --> 00:38:08,110
如果我们只说数学 随机50 它会做同样的事情 
And if we just say math.random 50, it'll do the same exact thing.

746
00:38:08,110 --> 00:38:12,915
它会说 它会假设rmin为1 并给出一个介于1和50之间的值 
It'll say-- it'll assume rmin is one and give us a value between one and 50.

747
00:38:12,915 --> 00:38:14,790
然后是两个重要的数学函数
And then two important mathematical functions

748
00:38:14,790 --> 00:38:18,450
这是非常基本的 但在几乎所有地方的游戏环境中都是有用的 
that are very basic but helpful in the context of games almost everywhere,

749
00:38:18,450 --> 00:38:21,750
它只是math.min 它返回两个值中较小的一个 
it's just math.min, which returns the lesser of two values,

750
00:38:21,750 --> 00:38:24,200
和math.max 它转换两个值中较大的一个 
and math.max which turns the greater of two values.

751
00:38:24,200 --> 00:38:29,260
我们将在将值限制在某个范围内的情况下看到这一点 
And we'll see this in the context of clamping values to some range.

752
00:38:29,260 --> 00:38:31,600
那么 让我们来看看这里的一个演示 
So let's go ahead and take a look at a demo here.

753
00:38:31,600 --> 00:38:33,806
所以我要继续下去 打开Pong 4 
So I'm going to go ahead and open up Pong 4.

754
00:38:37,620 --> 00:38:39,710
然后看一下Main Lua 他们进入了 
And going to look at main.lua they're in.

755
00:38:42,570 --> 00:38:48,300
所以在第47行 我们看到我们正在调用数学 随机种子函数 和以前一样 
So here on line 47, we see we're calling the math.random seedfunction as before.

756
00:38:48,300 --> 00:38:52,380
注意 我们传入的是OS time 另一个函数调用 
And note that we're passing in OS.time, another function call,

757
00:38:52,380 --> 00:38:55,779
因为每次运行我们的应用程序时 OS的时间都会不同 
because OS.time is going to be different every time we run our application.

758
00:38:55,779 --> 00:38:57,570
所以我们每次都在播种我们的应用程序
So we're seeding our application every time

759
00:38:57,570 --> 00:39:02,197
我们根据当前秒相对于0 0 0 
we run it based on whatever the current second is relative to zero, zero, zero,

760
00:39:02,197 --> 00:39:04,537
零 1970年1月1日 
zero, zero, zero, January 1st, 1970.

761
00:39:04,537 --> 00:39:06,870
我们每次跑步都会有所不同 
Which is going to be different every single time we run.

762
00:39:06,870 --> 00:39:10,800
假设我们不在同一秒内运行它 
Assuming we don't run it within the same second.

763
00:39:10,800 --> 00:39:16,860
如果我们下到71号线和7号线--或者 对不起 67号线和68号线 
And then if we go down to line 71 and seven-- or, sorry, 67 and 68,

764
00:39:16,860 --> 00:39:18,420
我们现在有了--
we now have--

765
00:39:18,420 --> 00:39:21,420
我们给我们的球一个起始值 
we're giving a starting value to our ball,

766
00:39:21,420 --> 00:39:23,800
因为我们想真正开始操控我们的球 
because we want to actually start manipulating our ball.

767
00:39:23,800 --> 00:39:27,300
所以我们给它一个X和一个Y 所以我们再次将它放在中心位置
So we give it an X and a Y. So we're setting it right to the center again

768
00:39:27,300 --> 00:39:29,490
但现在 我们正在为它定义一个变量
but, now, we're defining a variable for it

769
00:39:29,490 --> 00:39:33,030
而不是用我们的Love静态地呈现它 graph 矩形
instead of just rendering it statically with our love.graphics.rectangle

770
00:39:33,030 --> 00:39:35,286
函数 因为我们希望这种情况随着时间的推移而改变 
function, because we want this to change over time.

771
00:39:35,286 --> 00:39:37,660
我们想开始让我们的球在屏幕上移动 
We want to start letting our ball move around the screen.

772
00:39:37,660 --> 00:39:40,830
所以这些x和y变量现在开始改变 
So these x and y variables are going to start changing now,

773
00:39:40,830 --> 00:39:44,100
它们将相对于它的当前速度发生变化 
and they're going to change relative to its current velocity.

774
00:39:44,100 --> 00:39:48,840
它的速度将存储在球dx和球dy中 
And its velocity is going to be stored in ball dx and ball dy.

775
00:39:48,840 --> 00:39:53,380
Dx和dy是增量x和增量y的常用缩写 
dx and dy are common shorthands for delta x and delta y,

776
00:39:53,380 --> 00:39:55,500
这就是你表示速度的方式 
which is how you represent velocity.

777
00:39:55,500 --> 00:39:59,100
所以我们要做的是 有效地取我们的增量x和增量
So what we're going to do, effectively, is take whatever our delta x and delta

778
00:39:59,100 --> 00:40:01,672
并将它们一帧一帧地添加到我们的球上 
y are and add them onto our ball frame by frame,

779
00:40:01,672 --> 00:40:03,630
这将产生更新的效果
and that's going to have the effect of updating

780
00:40:03,630 --> 00:40:05,520
我们的球的位置有一定的价值 
our ball's position by some value.

781
00:40:05,520 --> 00:40:07,890
并将增量x和增量y分开
And separating the delta x and the delta y

782
00:40:07,890 --> 00:40:12,662
会让我们的球有不同的角度 不同的轨迹 
will allow us to have different angles, different trajectories for our ball.

783
00:40:12,662 --> 00:40:15,370
然后我们在这个应用程序中也做了另一件事 
And then another thing that we're also doing in this application,

784
00:40:15,370 --> 00:40:18,270
我们从游戏状态的概念开始 
we're starting with the concept of a game state.

785
00:40:18,270 --> 00:40:21,840
因为现在我们可以有一个初始状态 以及我们将拥有的
Because now we can have a starting state, and what we're going to have

786
00:40:21,840 --> 00:40:23,040
是一种播放状态 
is a play state.

787
00:40:23,040 --> 00:40:25,320
在这个例子中 我们要做的就是
And so all we're going to do here in this example

788
00:40:25,320 --> 00:40:28,607
在此应用程序中 启动状态为字符串 
and in this application is start state as a string.

789
00:40:28,607 --> 00:40:31,440
在未来的示例中 我们将使用所谓的状态机
In future examples, we're going to use what's called a state machine

790
00:40:31,440 --> 00:40:34,260
实际上把不同的州分成各自的州--
and actually separate out different states into their own--

791
00:40:34,260 --> 00:40:35,770
放入他们自己的模块中 
into their own modules.

792
00:40:35,770 --> 00:40:36,870
但在这场比赛的背景下 我们只是
But in the context of this game, we're just

793
00:40:36,870 --> 00:40:38,828
我将使用一个简单的字符串来说明
going to use a simple string just to illustrate

794
00:40:38,828 --> 00:40:42,180
它是如何工作的 当我们开始游戏时 我们将说出我们的第一个状态 
how it works, and we're going to say our first state, when we start the game,

795
00:40:42,180 --> 00:40:46,650
应该是处于开始状态的开始字符串 
should be the start string in the start state.

796
00:40:46,650 --> 00:40:49,440
所以在第86行 我们要做的是
And so here on line 86, what we're going to do

797
00:40:49,440 --> 00:40:52,394
是解决我们在上一个例子中遇到的一个问题 
is solve a problem that we had in the last example, which was,

798
00:40:52,394 --> 00:40:55,560
操纵杆可能会移动到屏幕边缘之外 这不是行为
the paddles could move beyond the edges of the screen, which is not behavior

799
00:40:55,560 --> 00:40:56,820
这是我们应该允许的 
that we should permit.

800
00:40:56,820 --> 00:41:02,640
所以我们将在0上调用math.max 同样的操作
So we're going to call math.max on zero, and the same operation

801
00:41:02,640 --> 00:41:06,180
我们以前是这样做的 这将产生返回的效果 无论是哪一个
we were doing before, and that will have the effect of returning whichever

802
00:41:06,180 --> 00:41:08,260
这两个值中较大的一个 
of those two values is greater.

803
00:41:08,260 --> 00:41:10,920
因此 如果值是--
So if the value is--

804
00:41:10,920 --> 00:41:13,971
如果我们在y值上加上负的划桨速度
if we're adding negative paddle speed to our y value

805
00:41:13,971 --> 00:41:15,720
它进入了负值范围 这是
and it goes into the negative range, which

806
00:41:15,720 --> 00:41:18,722
意味着它超出了屏幕的顶端 
means it's beyond the top edge of the screen,

807
00:41:18,722 --> 00:41:20,680
零将是这些值中较大的一个
zero is going to be the greater of those values

808
00:41:20,680 --> 00:41:23,750
所以在这种情况下 它永远是零 Math.max返回
and so it will always be zero in that case. math.max returns

809
00:41:23,750 --> 00:41:25,000
两个值中较大的一个 
the greater of the two values.

810
00:41:25,000 --> 00:41:27,416
所以它会有夹紧它的效果 这样它就永远不会
So it'll have the effect of clamping it such that it never

811
00:41:27,416 --> 00:41:29,520
位于顶部边缘上方 
goes above the top edge.

812
00:41:29,520 --> 00:41:32,130
第96行的情况正好相反 在这里我们
The inverse is true for line 96, where we

813
00:41:32,130 --> 00:41:35,860
对虚拟高度减去20调用math.min 
call math.min on virtual height minus 20,

814
00:41:35,860 --> 00:41:39,290
选手1.y加上划桨速度 增量乘以增量时间 
and player 1.y plus paddle speed.delta-- times delta time.

815
00:41:39,290 --> 00:41:41,790
这将具有相同的效果 它将返回
And this will have the same effect, it will return whichever

816
00:41:41,790 --> 00:41:43,560
这两个值中较小的一个 
of these two values is lesser.

817
00:41:43,560 --> 00:41:47,820
在这种情况下 如果我们超过了虚拟高度减去20 
In which case, if we've gone above virtual height minus 20, which

818
00:41:47,820 --> 00:41:52,410
在屏幕底部移动了我们的球拍的大小 
is down at the bottom of the screen shifted by the size of our paddle,

819
00:41:52,410 --> 00:41:55,000
它将把它设置为虚拟高度减20 
it's going to set it to virtual height minus 20.

820
00:41:55,000 --> 00:41:57,390
因此 我们永远不会低于这一点 
So we never go below that point.

821
00:41:57,390 --> 00:42:01,470
我们也在为2号玩家做同样的事情 完全相同的逻辑 
And we're doing the same thing for player two, exact same logic.

822
00:42:01,470 --> 00:42:04,440
如果我们处于播放状态 我们就会
And then if we're in the play state, we're

823
00:42:04,440 --> 00:42:07,069
来更新我们的球的位置 
going to actually update our ball's position.

824
00:42:07,069 --> 00:42:10,360
所以我们处于--如果我们处于开始状态 球是不会移动的 
So we're in the-- if we're in the start state, ball's not going to move at all.

825
00:42:10,360 --> 00:42:14,730
但如果我们处于播放状态 我们希望球x等于球x加球
But if we're in the play state, we want ball x to equal ball x plus ball

826
00:42:14,730 --> 00:42:16,200
X乘以增量时间 
x times delta time.

827
00:42:16,200 --> 00:42:19,440
请注意 Lua中没有速记
And note that there is no shorthand in Lua

828
00:42:19,440 --> 00:42:23,520
为自身增加价值 这就是为什么我们称之为Ball
for adding the value to itself, which is why we're calling ball

829
00:42:23,520 --> 00:42:26,340
等于球x 加上球x乘以增量时间 
x equals ball x, plus ball x times delta time,

830
00:42:26,340 --> 00:42:30,300
而不是简单地说球x+等于球x乘以增量时间 
instead of just saying ball x plus equals ball x times delta time.

831
00:42:30,300 --> 00:42:33,090
这只是他们做出的语言决定 
Just a language decision that they made.

832
00:42:33,090 --> 00:42:35,760
但如果我们处于播放状态 这将是
But if we're in the play state, this will

833
00:42:35,760 --> 00:42:39,720
无论我们当前的球的速度是多少 都有缩放的效果--
have the effect of scaling whatever our current ball's velocity is and--

834
00:42:39,720 --> 00:42:43,020
乘以增量时间 因此它保持与帧速率无关 
times delta time, so it stays frame rate independent.

835
00:42:43,020 --> 00:42:45,930
然后把它加到球x和球y上 这会使它移位 
And then adding it to ball x and ball y, which will shift it.

836
00:42:45,930 --> 00:42:53,300
我们在这里的170行得到了实际的结果--
And we get this actually working down here in line 170--

837
00:42:53,300 --> 00:42:54,690
174.
174.

838
00:42:54,690 --> 00:42:59,370
我们现在--不只是在屏幕上呈现纯平的数字 
We're now-- instead of just rendering flat numbers to the screen,

839
00:42:59,370 --> 00:43:01,740
我们实际上是在使用球x和球y来渲染 
we're actually using ball x and ball y to render.

840
00:43:01,740 --> 00:43:05,190
如果我们处于播放状态 这些将会更新 
And if we're in the play state, those will get updated.

841
00:43:05,190 --> 00:43:13,740
但如果我们回到第127行 现在 我们在Love中 按键函数 
But if we go back up to line 127, now, we're in the love.keypressed function,

842
00:43:13,740 --> 00:43:15,420
所以我们从120号线开始 
so we're starting on line 120.

843
00:43:15,420 --> 00:43:19,530
在我们刚刚有If键等于逸出之前 那么love.vent.it 
Before we just had the if key equals escape, then love.event.quit.

844
00:43:19,530 --> 00:43:22,620
但现在在第127行 我们要检查
But now on line 127, we're going to check

845
00:43:22,620 --> 00:43:25,800
要查看该键是否等于Enter或Return 
to see if the key is equal to enter or return,

846
00:43:25,800 --> 00:43:29,697
然后我们将使用它作为我们测试状态变化的方法 
and then we're going to use that as our way of just testing state changes.

847
00:43:29,697 --> 00:43:32,280
所以我们要说 如果游戏状态等于开始 
So we're going to say if the game state is equal to the start,

848
00:43:32,280 --> 00:43:35,670
一旦你按回车 游戏状态应该等于玩 
once you press entered, the game state should be equal to play.

849
00:43:35,670 --> 00:43:37,960
否则 将其重新设置为开始 
Otherwise, set it back to start.

850
00:43:37,960 --> 00:43:41,350
我们将它设置为开始 我们将重新初始化我们的x
And we set it back to start, we're going to re-initialize our x

851
00:43:41,350 --> 00:43:43,780
和y在中心 虚拟宽度除以2
and y to be in the center, virtual width divided by two

852
00:43:43,780 --> 00:43:46,420
-2 虚拟高度除以2-2 
minus two, virtual height divided by two minus two,

853
00:43:46,420 --> 00:43:51,040
我们再一次给它一个初始的随机起始速度 
and we're going to give it an initial random starting velocity again.

854
00:43:51,040 --> 00:43:54,040
注意这里 这个数学 随机二等于--
And note here, this math.random two equal--

855
00:43:54,040 --> 00:43:57,150
等于1和100 或负100 
is equal to one, and 100, or negative 100.

856
00:43:57,150 --> 00:43:59,990
这只是Lua做三元运算的方式 
It's just Lua's way of doing a ternary operation.

857
00:43:59,990 --> 00:44:03,400
所以在C语言中 你通常会有这样的--
So in C, you will often have like--

858
00:44:03,400 --> 00:44:08,530
你会有点像数学 随机二等于一 
you would be something like math.random two equals one,

859
00:44:08,530 --> 00:44:13,030
你会有一个问号 100冒号 负100 
and you would have a question mark, 100 colon, negative 100.

860
00:44:13,030 --> 00:44:14,830
这是一模一样的东西 但Lua不是
It's the same exact thing, but Lua doesn't

861
00:44:14,830 --> 00:44:18,850
有三进制操作的简写 所以我们用
have that sort of shorthand for a ternary operation, so we do it with

862
00:44:18,850 --> 00:44:20,350
和或 
and and or.

863
00:44:20,350 --> 00:44:24,310
我们使用逻辑运算来做同样的事情 
We use logical operations instead to do the same thing.

864
00:44:24,310 --> 00:44:28,660
注意这里我们也展示了数学 random可以
And note here we're also showcasing that math.random can take

865
00:44:28,660 --> 00:44:30,760
一个参数或两个参数 
either one argument or two arguments.

866
00:44:30,760 --> 00:44:32,757
在这种情况下 我们说的是数学 随机二 
In this case, we're saying math.random two,

867
00:44:32,757 --> 00:44:35,090
这意味着它会给我们一个介于1和2之间的值 
which means it will give us a value between one and two.

868
00:44:35,090 --> 00:44:36,370
所以五五分成 
So a 50-50.

869
00:44:36,370 --> 00:44:39,070
如果我们做负50-50 那意味着
And then if we do negative 50-50, that means

870
00:44:39,070 --> 00:44:41,500
我们会得到一个介于负50和50之间的值 
we'll get a value between negative 50 and 50.

871
00:44:41,500 --> 00:44:44,147
所以有效范围是100 
So a range of 100, effectively.

872
00:44:44,147 --> 00:44:46,980
如果我们运行应用程序 
And so what that has the effect of doing, if we run our application,

873
00:44:46,980 --> 00:44:48,100
我们进入Pong 4 
we go into Pong 4.

874
00:44:50,970 --> 00:44:53,570
我们在开始状态 所以现在我们渲染--
We're in the start state so now we're rendering--

875
00:44:53,570 --> 00:44:57,230
如果我们处于开始状态 它将被设置为呈现该消息 
if we're in the start state, it's set to render that message.

876
00:44:57,230 --> 00:45:01,370
如果我们按下回车键 球会得到一个随机的速度--实际上
If we press Enter, the ball gets a random veloc-- it's actually

877
00:45:01,370 --> 00:45:03,710
一帧一帧地应用速度 
applying the velocity frame by frame.

878
00:45:03,710 --> 00:45:05,360
它在update方法中更新 
It's updating in the update method.

879
00:45:05,360 --> 00:45:09,410
如果我们再次按Enter键 它将重置 我们将返回到开始状态 
If we press Enter again, it gets reset and we're back in the start state.

880
00:45:09,410 --> 00:45:11,550
所以我们再做一次 它得到一个随机值 
So we do it again, it's getting a random value.

881
00:45:11,550 --> 00:45:12,830
再来一次 随机值 
Do it again, random value.

882
00:45:12,830 --> 00:45:13,860
随机值 
Random value.

883
00:45:13,860 --> 00:45:17,030
所以每次我们得到一个不同的随机球值 
So every time we're getting a different random ball value.

884
00:45:17,030 --> 00:45:24,230
但是如果我们试着运行它 或者试着与它互动 会发生什么呢？
But what happens if we try to actually run it, or try to interact with it?

885
00:45:24,230 --> 00:45:25,140
没什么
Nothing.

886
00:45:25,140 --> 00:45:26,207
直接穿过去 
Goes straight through.

887
00:45:26,207 --> 00:45:28,040
所以我们缺少了一个关键的部分 尽管我们
So we're missing a key piece, even though we

888
00:45:28,040 --> 00:45:32,210
实现了我们游戏引擎的核心组件 
have the core components of our game engine implemented,

889
00:45:32,210 --> 00:45:35,720
我们没有任何具体的游戏 没有任何互动 
we don't have any concrete game play, nothing's interacting.

890
00:45:35,720 --> 00:45:38,550
这是我们需要关注的一个主要部分 
And that's a major piece that we need to look at.

891
00:45:38,550 --> 00:45:40,040
接下来
And so the next--

892
00:45:40,040 --> 00:45:42,170
在我们真正开始之前 
before we actually start doing that, though, we're

893
00:45:42,170 --> 00:45:46,880
我们来看看职业更新 乒乓5 
going to take a look at the class update, Pong 5.

894
00:45:46,880 --> 00:45:52,640
所以为了更深入地了解
And so in order to get into more of a-- in order

895
00:45:52,640 --> 00:45:55,130
为了更有效地扩展代码 我们需要
to scale our code more effectively, we need

896
00:45:55,130 --> 00:45:58,200
开始从阶级的角度看问题 
to start looking in terms of classes.

897
00:45:58,200 --> 00:46:01,826
我们的球没有x和y 我们的桨也没有x和y 
And instead of having an x and a y for our ball, an x and a y for our paddle,

898
00:46:01,826 --> 00:46:04,700
我们的球的Δ x Δ y 所有这些不同的变量 
a delta x, a delta y for our ball, all these different variables that

899
00:46:04,700 --> 00:46:07,310
到处都是开始膨胀我们的代码 
are sort of all over the place starting to bloat our code,

900
00:46:07,310 --> 00:46:10,154
在我们为之疯狂之前 我们应该考虑一下
before we get too crazy with it, we should think about

901
00:46:10,154 --> 00:46:13,070
我们怎样才能把这些数据放在一起 这样我们就可以只考虑
how can we put this data altogether so that we can just think in terms

902
00:46:13,070 --> 00:46:15,530
我们的球拍或者我们的球体 
of our paddles or our ball object.

903
00:46:15,530 --> 00:46:17,780
所以我们使用所谓的类 
And so we use what's called a class.

904
00:46:17,780 --> 00:46:21,110
如果不熟悉 类只是一种获取所有这些变量的方法
If unfamiliar, a class is simply a way of taking all these variables that

905
00:46:21,110 --> 00:46:25,490
我们到目前为止一直在使用 但把它们放在一个容器里 这样
we've been using thus far, but putting them together in a container such that

906
00:46:25,490 --> 00:46:29,600
我们可以说 Paddle.x或Paddle--
we can just say, paddle.x or paddle--

907
00:46:29,600 --> 00:46:31,970
你知道 在这种情况下 是汽车 
you know, in this case, car.

908
00:46:31,970 --> 00:46:37,530
如果我们有一个名为Drive Car的函数 现在我们只需说Car 
If we have a function called drive car, now we can just say, car.drive instead.

909
00:46:37,530 --> 00:46:40,520
我们不一定要有与我们的价值观分开的功能 
We don't have to have functions that are separate from our values,

910
00:46:40,520 --> 00:46:42,020
我们可以把它们放在一起 
that-- we can put them all together.

911
00:46:42,020 --> 00:46:45,500
我们可以问我们的车目前的行驶里程是多少
We can ask what's our car's current mileage instead

912
00:46:45,500 --> 00:46:48,120
所有这些不同的变量无处不在 
of having all these different variables all over the place.

913
00:46:48,120 --> 00:46:51,890
因此 这些课程实际上就是蓝图 
So the classes are effectively blueprints.

914
00:46:51,890 --> 00:46:53,390
使用它--定义一个类 
Use it-- you define a class.

915
00:46:53,390 --> 00:46:55,970
你说 好吧 我的汽车课将会有
You say, OK, my car class is going to have

916
00:46:55,970 --> 00:46:58,400
A--它会有一个里程变量 
a-- it's going to have a mileage variable,

917
00:46:58,400 --> 00:47:02,081
它将有一个油漆变量 它将有一个品牌和一个型号 
it's going to have a paint variable, it's going to have a make and a model,

918
00:47:02,081 --> 00:47:05,330
它将拥有所有这些东西 并将保持自己的状态 
it's going to have all these things, and it's going to maintain its own state.

919
00:47:05,330 --> 00:47:07,080
它将为我们保持这一切 
It's going to maintain all of that for us.

920
00:47:09,890 --> 00:47:10,970
如图所示 
as seen here.

921
00:47:10,970 --> 00:47:14,090
通常 这些就是所谓的字段 
And, typically, these are what are called fields.

922
00:47:14,090 --> 00:47:16,700
然后我们也会有方法 
And then we'll have methods as well.

923
00:47:16,700 --> 00:47:20,730
功能 而不是完全独立于这些数据 
Functions that, instead of being like completely separate from this data,

924
00:47:20,730 --> 00:47:23,960
汽车现在基本上拥有自己的功能 
a car now basically owns its own functions.

925
00:47:23,960 --> 00:47:28,337
它有自己的方法 称为驾驶 或转向 或按喇叭 等等 
It has its own method called drive, or turn, or honk, et cetera,

926
00:47:28,337 --> 00:47:30,170
我们不需要一个名为的函数 
and we don't need to have a function called,

927
00:47:30,170 --> 00:47:35,090
比如 转弯 或者按喇叭等等 
like, turn car, or honk car, et cetera.

928
00:47:35,090 --> 00:47:37,700
然后这门课实际上就是一张蓝图 
And then this class is effectively a blueprint.

929
00:47:37,700 --> 00:47:40,550
好 我们很快就会看到如何定义一个类 
Well, we'll see shortly how to define a class,

930
00:47:40,550 --> 00:47:44,617
但为了真正像一把桨一样拥有自己的数据集 
but in order to actually have like one paddle that has its own set of data,

931
00:47:44,617 --> 00:47:47,450
我们需要定义另一个拥有自己的数据集的划桨--
and another paddle that has its own set of data, we need to define--

932
00:47:47,450 --> 00:47:51,170
我们需要从这个类实例化、创建对象 
we need to instantiate, create objects from this class.

933
00:47:51,170 --> 00:47:54,440
基本上 使用这个类作为蓝图 但将其带到工厂
Basically, use this class as a blueprint, but take it to a factory

934
00:47:54,440 --> 00:47:57,470
并根据蓝图制造混凝土汽车 
and create concrete cars from the blueprint.

935
00:47:57,470 --> 00:47:58,685
这些都是物件 
And those are objects.

936
00:48:01,200 --> 00:48:03,195
就像这里看到的 我们的球拍和球
And so as seen here, our paddles and ball

937
00:48:03,195 --> 00:48:05,880
都是做这件事的完美的简单用例 
are perfect simple use cases for doing this.

938
00:48:05,880 --> 00:48:08,090
那么 让我们继续下去 看看乒乓球5 
So let's go ahead and take a look at Pong 5.

939
00:48:14,481 --> 00:48:17,230
所以在Pong 5中 立即 如果你看一下目录结构 
So in Pong 5, immediately, if you look at the directory structure,

940
00:48:17,230 --> 00:48:21,190
您可以看到 我们已经添加了一个球.lua和一个Paddle.lua 
you can see that we've added a ball.lua and a paddle.lua.

941
00:48:21,190 --> 00:48:25,510
这是大多数面向对象编程语言的传统 
And it's tradition in most languages that have object oriented programming,

942
00:48:25,510 --> 00:48:31,180
正如它所称的 要将类名大写以便您可以区分
as it's called, to capitalize class names just so you can differentiate

943
00:48:31,180 --> 00:48:37,400
类 例如 来自具体的对象、变量或函数 
classes, for example, from concrete objects or variables or functions.

944
00:48:37,400 --> 00:48:43,420
所以如果你去我们的主卢瓦 在第35行 
So if you go to our main.lua, on line 35,

945
00:48:43,420 --> 00:48:46,700
我们需要一个名为类的库 它
we're requiring a library, called class, which

946
00:48:46,700 --> 00:48:50,750
才能让我们真正创建这些类 
is what's going to allow us to actually create these classes.

947
00:48:50,750 --> 00:48:52,400
因为班级不是原生的--
Because classes are not native--

948
00:48:52,400 --> 00:48:55,310
它们在某种意义上是原生的Lua功能 
they are in a sense a native Lua feature,

949
00:48:55,310 --> 00:48:59,900
但是Lua进行面向对象编程的方式有点复杂 
but Lua's way of doing object oriented programming is a little bit convoluted.

950
00:48:59,900 --> 00:49:04,190
一些人好心地建立了一个库 使它变得简单得多 
Some folks have kindly put together a library that makes it a lot simpler,

951
00:49:04,190 --> 00:49:07,430
与其他面向对象的语言有更密切的关系
and a lot more closely related to other languages that do object oriented

952
00:49:07,430 --> 00:49:12,530
更主要的是编程 比如Java或C# 甚至是Python 
programming more predominantly, like Java or C#, or even Python,

953
00:49:12,530 --> 00:49:16,370
允许我们以非常类似的方式使用关键字CLASS
allow us to use the keyword class in a way that's very similar to those

954
00:49:16,370 --> 00:49:17,560
图书馆 
libraries.

955
00:49:17,560 --> 00:49:22,749
在第39行和第43行 我们正在获取自己的代码、球拍和球 
On line 39 and 43, we're acquiring our own code, paddle and ball,

956
00:49:22,749 --> 00:49:25,040
我们现在就来看看这些 所以我们
and we're going to take a look at those right now so we

957
00:49:25,040 --> 00:49:27,330
可以看到班级是什么样子的 
can see what a class looks like.

958
00:49:27,330 --> 00:49:30,314
所以我要继续开一家--
So I'm going to go ahead and open up a--

959
00:49:33,200 --> 00:49:36,740
球文件 bal.lua 
the ball file, ball.lua.

960
00:49:36,740 --> 00:49:38,630
我们可以在这里看到我们所需要做的就是
And we can see here all we need to do just

961
00:49:38,630 --> 00:49:43,220
创建一个Ball类是 使用我们的类库 Ball获取类 
to create a ball class is, using our class library, ball gets class,

962
00:49:43,220 --> 00:49:45,050
然后是像这样的花括号 
and then curly brackets like that.

963
00:49:45,050 --> 00:49:47,900
所以现在我们有了一个类对象 一个类表 
And so now we have a class object, a class table,

964
00:49:47,900 --> 00:49:50,780
实际上 因为Lua的一切都是一张桌子 
effectively, because everything in Lua is a table.

965
00:49:50,780 --> 00:49:53,030
但我们可以从物体的角度来考虑它 
But we can think about it in terms of objects.

966
00:49:53,030 --> 00:49:56,060
我们有一个名为Ball的类对象 然后我们
We have a class object called ball, and then we

967
00:49:56,060 --> 00:49:59,520
可以开始定义属于此类的函数 
can start to define functions that belong to this class.

968
00:49:59,520 --> 00:50:03,230
因此 我们将定义所谓的构造函数或初始化函数
So we're going to define what's called a constructor, or an init function

969
00:50:03,230 --> 00:50:04,820
在本例中 为初始值设定项 
in this case, an initializer.

970
00:50:04,820 --> 00:50:09,200
它将允许我们用任何我们想要的东西来初始化我们的球 
And it's going to allow us to initialize our ball with whatever we want.

971
00:50:09,200 --> 00:50:11,930
在本例中 我们希望以x和y开头 
In this case, we want to start our ball off with an x and a y

972
00:50:11,930 --> 00:50:13,610
宽度和高度 
and a width and a height.

973
00:50:13,610 --> 00:50:16,410
请注意 在这里我们有一个词叫“自我” 
And notice within here we have a word called self.

974
00:50:16,410 --> 00:50:20,330
Self和This是面向对象编程语言中的常用词
Self and this are common words in object oriented programming languages

975
00:50:20,330 --> 00:50:25,610
这意味着我们用这个类创建的任何对象都将是self 
that mean whatever object we're creating with this class is going to be self.

976
00:50:25,610 --> 00:50:27,010
所以我们会看到--
So we'll see that--

977
00:50:27,010 --> 00:50:28,070
我们很快就会看到这一点 
we'll see that shortly.

978
00:50:28,070 --> 00:50:29,250
Self.x得到x 
Self.x gets x.

979
00:50:29,250 --> 00:50:31,940
因此 无论我们使用此调用创建什么具体对象 
So whatever concrete object we create using this call,

980
00:50:31,940 --> 00:50:36,320
这个init调用 将它的x设置为x 将y设置为y 设置其宽度 
this init call, set its x to this x, set its y to the y, set its width,

981
00:50:36,320 --> 00:50:37,000
设置它的高度 
set its height.

982
00:50:37,000 --> 00:50:38,240
那个特定的物体 
That specific object.

983
00:50:38,240 --> 00:50:39,980
赛尔夫 
Self.

984
00:50:39,980 --> 00:50:42,620
然后我们对增量y和增量x做同样的事情 
And then we're doing the same thing for delta y and delta x,

985
00:50:42,620 --> 00:50:46,460
只是我们正在设置这两个随机值 就像我们以前做的那样 
only that we are setting those two random values just as we did before.

986
00:50:46,460 --> 00:50:49,910
Self.dy self.dx 
Self.dy, self.dx.

987
00:50:49,910 --> 00:50:54,890
它属于使用此init调用实例化的任何特定对象
That belongs to whatever specific object gets instantiated using this init call

988
00:50:54,890 --> 00:50:57,530
正如我们将在代码中看到的那样 
as we'll see in the code.

989
00:50:57,530 --> 00:51:01,070
为了简单起见 我们在这里只定义了一个重置函数 
We're defining just a reset function here just to make it easy.

990
00:51:01,070 --> 00:51:02,660
在我们有一个--
Before we had a--

991
00:51:02,660 --> 00:51:06,150
几行代码将我们的球设置到屏幕中央
several lines of code that set our ball to the middle of the screen

992
00:51:06,150 --> 00:51:07,580
给了它一个随机的速度 
and gave it a random velocity.

993
00:51:07,580 --> 00:51:09,830
我们现在正在这样做 这是一种很好的排序方式
We're doing that now, and this is a good way of sort

994
00:51:09,830 --> 00:51:11,810
重构出一组逻辑 
of refactoring out groups of logic.

995
00:51:11,810 --> 00:51:15,260
我们正在创建一个名为Reset的函数 该函数在一个函数中完成所有这些操作
We're creating a function called reset that just does that all in one function

996
00:51:15,260 --> 00:51:19,250
调用 我们只是在Main函数中调用它 压缩我们的代码 
call, and we just call that within our main function, condensing our code.

997
00:51:19,250 --> 00:51:22,130
然后请注意 我们现在有一个更新和一个呈现函数 
And then notice we have an update and a render function now.

998
00:51:22,130 --> 00:51:24,440
我们将从我们自己的更新中调用这些
And we are going to call these from our own update

999
00:51:24,440 --> 00:51:27,560
和我们自己的绘制函数 以便每个对象
and our own draw function such that every object

1000
00:51:27,560 --> 00:51:31,940
我们希望在我们的游戏中 每个实体 我们将在这个游戏的基础上
that we want in our game, every entity, and we'll build upon this game

1001
00:51:31,940 --> 00:51:33,680
在未来的比赛中 
by game in the future.

1002
00:51:33,680 --> 00:51:39,170
我们将只调用更新并呈现来自我们的main的所有内容 lua 
We'll just call update and render on everything from our main.lua,

1003
00:51:39,170 --> 00:51:43,160
并将所有这些都交给每个单独的类和对象
and defer all of that to each individual class and objects

1004
00:51:43,160 --> 00:51:46,670
所以我们不需要有一个Main Lua 这就像是800行代码 
so we don't have to have a main.lua that's like 800 lines of code.

1005
00:51:46,670 --> 00:51:50,480
我们只是在这里发布所有与球相关的更新 
We just break out all of the updates that are pertinent to the ball here,

1006
00:51:50,480 --> 00:51:53,720
以及所有与球相关的渲染代码 
and all the render code that's pertinent to the ball here,

1007
00:51:53,720 --> 00:51:56,090
调用每个单独的球更新和渲染 
call each individual balls update and render,

1008
00:51:56,090 --> 00:51:59,630
节省了我们大量的重构时间 
and save ourselves a lot of time in refactoring.

1009
00:51:59,630 --> 00:52:01,655
如果我们看桨 我们也在做同样的事情 
We're doing the same thing if we look at paddle.

1010
00:52:04,400 --> 00:52:06,410
划桨也是一门课
Paddle's a class, as well.

1011
00:52:06,410 --> 00:52:10,310
它得到了类库的原因.
It gets the reason the class library.

1012
00:52:10,310 --> 00:52:13,910
同样的事情 xy加上高度 还有dy 
Same exact sort of thing here, xy with height, and a dy.

1013
00:52:13,910 --> 00:52:17,960
在这种情况下 我们只是将其初始化为零 这样我们就不会移动 
In this case, we're just initialising that to zero so that we're not moving.

1014
00:52:17,960 --> 00:52:20,640
然后我们在这里调用update函数 
And then we're calling the update function here.

1015
00:52:20,640 --> 00:52:25,250
所以如果dy小于零 我们就像以前一样使用math.max函数 
So if our dy is less than zero, we're using the math.max function as before,

1016
00:52:25,250 --> 00:52:29,630
与屏幕的顶部边缘 然后无论我们的y加上我们的当前dy
with the top edge of the screen, and then whatever our y plus our current dy

1017
00:52:29,630 --> 00:52:31,820
是Δ y 
is, so delta y.

1018
00:52:31,820 --> 00:52:34,880
然后这里 self.y得到math.min 虚拟高度
And then here, self.y gets math.min, virtual height

1019
00:52:34,880 --> 00:52:39,220
减去self.height self.y加上self.dy乘以delta time 
minus self.height, self.y plus self.dy times delta time.

1020
00:52:39,220 --> 00:52:42,470
这就是我们之前看到的用桨的夹紧行为 只是现在 
So that's the clamping behavior that we saw before with the paddles, only now,

1021
00:52:42,470 --> 00:52:45,660
我们把它从main函数中取出来放到update函数中
we took it from main and we put it in our update function

1022
00:52:45,660 --> 00:52:48,110
所以每个paddle调用它的更新 
so each paddle calls its update, and we take some lines

1023
00:52:48,110 --> 00:52:49,700
我们的主文件中的代码 
of code out of our main file.

1024
00:52:49,700 --> 00:52:52,622
然后它有自己的渲染功能 和桨一样 
And then it has its own render function here, same as the paddle.

1025
00:52:52,622 --> 00:52:55,580
球拍的渲染函数和球的渲染函数
The render function for the paddle and the render function for the ball

1026
00:52:55,580 --> 00:52:57,380
实际上是一样的 
are effectively the same.

1027
00:52:57,380 --> 00:53:04,300
所以如果我们去到我们的主管道 我们--我们得到了桨
And so if we go to our main, we-- we're acquiring the paddle

1028
00:53:04,300 --> 00:53:07,000
我们正在获取球 以便我们可以使用它们 
and we're acquiring ball so that we can use them.

1029
00:53:07,000 --> 00:53:13,810
所以如果我们向下到第79行 而不是初始化我们的球dx或球dy 
So if we go down to line 79, instead of initializing our ball dx or ball dy,

1030
00:53:13,810 --> 00:53:18,520
球x 球y 桨y 玩家1 y 玩家2 y 
ball x, ball y, paddle y, player 1y, player 2y,

1031
00:53:18,520 --> 00:53:22,990
现在 我们有一个参与人是简单的桨10 35 20.
now, we have player one is simply paddle 10, 35, 20.

1032
00:53:22,990 --> 00:53:25,180
参与人2是球拍 虚拟宽度减10 
And player two is a paddle, virtual width minus 10,

1033
00:53:25,180 --> 00:53:28,090
虚拟高度减30520
virtual height minus 30, 520.

1034
00:53:28,090 --> 00:53:30,990
球是一个球 虚宽除以二减二 
Ball is a ball, virtual width divided by two minus two,

1035
00:53:30,990 --> 00:53:33,385
虚高减二减二五是？两
virtual height minus two, minus two, [? five by ?] two

1036
00:53:33,385 --> 00:53:35,170
负二四四
minus two, four and four.

1037
00:53:35,170 --> 00:53:39,070
所以这些桨现在可以控制自己的x和y 自己的宽度
So those paddles now have control over their own x and y, their own width

1038
00:53:39,070 --> 00:53:45,010
和高度 以及战斗--或者球对XY宽度有自己的控制
and height, and the battle-- or the ball has its own control over the xy width

1039
00:53:45,010 --> 00:53:45,960
和身高 
and height.

1040
00:53:45,960 --> 00:53:48,650
而自我也适用于这个对象 
And the self applies to this object.

1041
00:53:48,650 --> 00:53:53,300
这就是我们之前看到的构造函数中的self 
This is whatever self was in our constructor that we saw before.

1042
00:53:53,300 --> 00:53:55,630
所以即使是现在我们也可以直接呼叫--所以我们可以简单地
So even now we can just call-- so we can simply

1043
00:53:55,630 --> 00:54:01,550
假设玩家1.x 玩家1.wide 玩家1.y 一切都包含在内 
say player 1.x player 1.width, player 1.y, and everything is contained.

1044
00:54:01,550 --> 00:54:04,055
我们不需要一百万个变量来跟踪
We don't need a million variables to keep track

1045
00:54:04,055 --> 00:54:05,680
在我们比赛中发生的所有事情中 
of all the things going on in our game.

1046
00:54:05,680 --> 00:54:08,890
随着规模的扩大 这一点将变得尤为重要 我们已经--
And this is going to be especially important as we scale, and we have--

1047
00:54:08,890 --> 00:54:11,500
也许我们一次可以在屏幕上看到100个东西 
maybe we have 100 things on the screen at one time.

1048
00:54:11,500 --> 00:54:14,560
我们不希望100乘以x个变量
We don't want 100 times x variables where

1049
00:54:14,560 --> 00:54:20,690
X是 不管它有多少我们需要跟踪的属性 
x is, however many properties that thing has that we need to keep track of.

1050
00:54:20,690 --> 00:54:23,470
这都是同样的逻辑 除了 现在 我们
It's all the same logic except, now, we're

1051
00:54:23,470 --> 00:54:28,420
在我们的更新函数中调用玩家一更新和玩家二更新 
calling player one update and player two update in our update function,

1052
00:54:28,420 --> 00:54:30,670
而不是让所有的逻辑都在里面 
instead of having all that logic therein,

1053
00:54:30,670 --> 00:54:33,342
他们在哪里移动 然后跟踪是否
where they're moving and then keeping track of whether

1054
00:54:33,342 --> 00:54:36,050
否则 它们会越过屏幕的顶部和底部边缘 
or not they're going past the top and bottom edges of the screen.

1055
00:54:36,050 --> 00:54:39,370
然后 如果游戏状态是PLAY 我们现在只需要调用球更新 
And then if game state is play, we're now just calling ball update.

1056
00:54:39,370 --> 00:54:43,210
而这些都是在三角洲时间内通过的 
And these are all getting passed in delta time.

1057
00:54:43,210 --> 00:54:45,120
然后这里也是一样的 
And then same thing here.

1058
00:54:45,120 --> 00:54:47,890
而不是用所有的逻辑来重申球
Instead of having all that logic for restating the ball

1059
00:54:47,890 --> 00:54:50,327
作为一段代码 我们把它取出来 我们重构了它 
as one block of code, we took it out, we refactored it,

1060
00:54:50,327 --> 00:54:52,660
我们把它放到球课上 现在我们要做的就是
we put it into our ball class, and now all we have to do

1061
00:54:52,660 --> 00:54:56,470
只是一行代码 球或重置 
is just one line of code, ball or reset.

1062
00:54:56,470 --> 00:55:00,490
然后在我们的绘图函数的第169行 
And then here down on line 169 in our draw function,

1063
00:55:00,490 --> 00:55:04,060
我们只有一号玩家渲染 二号玩家渲染 球渲染 
we just have player one render, player two render, ball render.

1064
00:55:04,060 --> 00:55:06,925
后来 随着我们的规模扩大 我们制作游戏
And later on as we scale and we make games

1065
00:55:06,925 --> 00:55:09,550
屏幕上有更多的东西 更多的实体 
that have a lot more things on the screen, a lot more entities,

1066
00:55:09,550 --> 00:55:11,890
我们可以只在循环中进行这些渲染 
we can just do these renders in a loop.

1067
00:55:11,890 --> 00:55:15,700
我们只能说 对于屏幕中的每个实体 只需呈现它 
We can just say for each entity in our screen, just render it.

1068
00:55:15,700 --> 00:55:18,340
对于我们屏幕中的每个实体 只需更新它 
For each entity in our screen, just update it.

1069
00:55:18,340 --> 00:55:21,190
我们可以压缩数千--数百行代码
We can condense thousands-- hundreds of lines of code

1070
00:55:21,190 --> 00:55:25,030
通过推迟更新逻辑 只需几行代码
into just a few lines of code by deferring update logic

1071
00:55:25,030 --> 00:55:27,820
以及将逻辑呈现给每个单独的实体 
and rendering logic to each individual entity,

1072
00:55:27,820 --> 00:55:30,070
多亏了面向对象的编程 
thanks to object oriented programming.

1073
00:55:30,070 --> 00:55:33,370
这就是我们将如何使用类进行重构 
And so that's how we're going to refactor using classes.

1074
00:55:33,370 --> 00:55:37,930
那么 到目前为止 对这一切是如何运作的有什么问题吗？
So any questions on how any of that works so far?

1075
00:55:40,640 --> 00:55:41,290
凉爽的 
Cool.

1076
00:55:41,290 --> 00:55:44,170
我认为这是一个很好的观点 可以休息五分钟 
This is a good point, I think, to take a five minute break.

1077
00:55:44,170 --> 00:55:49,676
一旦我们回来 我们将讨论如何查看每秒的帧 
And once we come back, we'll talk about how to look at frames per second.

1078
00:55:49,676 --> 00:55:52,180
好的 
All right.

1079
00:55:52,180 --> 00:55:56,800
所以我们要花一分钟时间来看看一些小东西 
So we're going to take a minute just to look at something kind of small,

1080
00:55:56,800 --> 00:56:00,940
但通常情况是 在游戏中 如果我们
but often it's the case where in games if we

1081
00:56:00,940 --> 00:56:06,400
希望确保我们的性能与我们的应用程序一样运行良好 
want to make sure that we are performing like our applications performing well,

1082
00:56:06,400 --> 00:56:08,940
我们想要--某种方式来监控我们的每秒帧数 
we want to-- some way to monitor our frames per second.

1083
00:56:08,940 --> 00:56:10,731
所以我想我应该花点时间
And so I figured I would just take a second

1084
00:56:10,731 --> 00:56:15,160
来快速地说明这一点 这样我们就可以在未来使用它 
to illustrate this quickly so that we can use this in the future.

1085
00:56:15,160 --> 00:56:18,830
对我们来说很重要的两个功能--
The two functions that are going to be important for us here--

1086
00:56:18,830 --> 00:56:21,959
好的 第一个只是一个小小的化妆品
well, the first of these is just a little small cosmetic addition

1087
00:56:21,959 --> 00:56:22,750
添加到应用程序 
to the application.

1088
00:56:22,750 --> 00:56:25,720
这只是love.window.setTitle 
It's just love.window.setTitle.

1089
00:56:25,720 --> 00:56:31,530
标题 到目前为止我们的申请 我不完全确定是什么--
Title, so far our application, I'm not entirely sure what the--

1090
00:56:31,530 --> 00:56:35,110
它默认地说 我想它说--
it says by default, I think it says--

1091
00:56:35,110 --> 00:56:36,650
上面写了什么--没有标题 
what does it say-- untitled.

1092
00:56:36,650 --> 00:56:37,150
嗯 
Yeah.

1093
00:56:37,150 --> 00:56:41,410
所以这不是--这是一层或多或少的缺乏光泽 
So that's not-- it's a layer of lack of polish, more or less.

1094
00:56:41,410 --> 00:56:43,820
如果能迅速解决这个问题 那就太好了 
And it'd be nice just to solve that problem quickly.

1095
00:56:43,820 --> 00:56:47,937
所以我们将调用一个名为love.window.setTitle的函数 
So we're going to call a function called love.window.setTitle, some string,

1096
00:56:47,937 --> 00:56:49,520
这将很快解决这个问题 
which will solve that problem quickly.

1097
00:56:49,520 --> 00:56:52,900
我们可以让它看起来像是我们已经把细节记下来了 
We can make it look as if we have that detail down.

1098
00:56:52,900 --> 00:56:57,160
然后 实际上将让我们决定是否
And then the thing that's actually going to let us determine whether or not

1099
00:56:57,160 --> 00:56:59,500
我们要么跑得很好 要么跑得很差
we are running well or we're running very poorly

1100
00:56:59,500 --> 00:57:04,180
是一个名为love.timer.getfraMesperSecd.getFPS的函数 
is a function called love.timer.getframespersecond.getFPS,

1101
00:57:04,180 --> 00:57:07,700
这是爱无偿赐予我们的东西
which is something that LOVE graciously gives us for free

1102
00:57:07,700 --> 00:57:09,950
让我们可以很容易地随心所欲地拍打它 
and allows us to very easily slap it wherever we want.

1103
00:57:09,950 --> 00:57:11,866
我们可以将其打印到控制台 或者我们可以
We can print it to the console, or we can just

1104
00:57:11,866 --> 00:57:13,420
直接将其绘制到我们的应用程序 
draw it straight to our application.

1105
00:57:13,420 --> 00:57:15,640
在这种情况下 我们将执行后一种操作 
In this case, we're going to do the latter.

1106
00:57:15,640 --> 00:57:19,800
所以我要继续前进 去爱--
So I'm going to go ahead and go into LOVE--

1107
00:57:19,800 --> 00:57:24,390
或者是我们主场的乒乓球6 
or Pong 6 in our main.

1108
00:57:24,390 --> 00:57:27,830
如果我们继续看这条线--
If we go ahead and look at line--

1109
00:57:32,190 --> 00:57:34,460
它在哪里--64行 
where is it-- line 64.

1110
00:57:34,460 --> 00:57:37,600
Love.window.setTitlePong 简单快捷 
love.window.setTitlePong, just quick and easy.

1111
00:57:37,600 --> 00:57:39,770
现在 我们的窗口标题被适当地设置 
Now, our window header is set appropriately,

1112
00:57:39,770 --> 00:57:49,810
如果我们下到198号线 我已经决定
and if we go down to line 198, here I've decided

1113
00:57:49,810 --> 00:57:54,850
为了在一个单独的函数中对其进行拆分 
to sort of split out this in a separate function,

1114
00:57:54,850 --> 00:57:57,640
在第198行调用了Display FPS 
called display FPS on line 198.

1115
00:57:57,640 --> 00:58:02,320
并且该函数是在行207上定义的 因此函数显示FPS 
And the function is defined on line 207, so a function display FPS,

1116
00:58:02,320 --> 00:58:03,570
不使用任何参数 
takes no parameters.

1117
00:58:03,570 --> 00:58:07,160
它的唯一目标是将我们当前的FPS绘制到屏幕上 
Its only goal is to just draw our current FPS to the screen.

1118
00:58:07,160 --> 00:58:10,000
所以我们要将当前字体设置为小字体 
So we're going to set our current font to a small font.

1119
00:58:10,000 --> 00:58:13,990
我们将设定我们的颜色--这就是我之前提到的 我们
We're going to set our color-- so this is what I alluded to before in that we

1120
00:58:13,990 --> 00:58:19,090
可以将Love的渲染颜色设置为RGBA的四倍 
can set LOVE's rendering color to some RGBA quadruple,

1121
00:58:19,090 --> 00:58:24,580
而我们画出的任何超出这一点的东西都会被画在--
and anything that we draw beyond that point will then be drawn at--

1122
00:58:24,580 --> 00:58:27,140
不管是什么颜色 它都会被吸引过来 
it'll be drawn into whatever that color is.

1123
00:58:27,140 --> 00:58:32,485
所以 在这种情况下 我们给它红色 0,255 在绿色 0 蓝色 255
So, in this case, we're giving it red of zero, 255 on the green, zero blue, 255

1124
00:58:32,485 --> 00:58:35,110
完全不透明 其效果是将我们的颜色设置为
fully opaque, which has the effect of setting our color to just

1125
00:58:35,110 --> 00:58:36,640
完全是绿色的 
completely green.

1126
00:58:36,640 --> 00:58:40,360
然后是love.raphics.print 我们目前的FPS--
And then love.graphics.print, our current FPS--

1127
00:58:40,360 --> 00:58:45,700
字符串 然后是当前的FPS 即love.timer.getFPS 
string, and then our current FPS here, which is love.timer.getFPS.

1128
00:58:45,700 --> 00:58:49,590
但它会将其作为一个数字返回 并且默认情况下 
But it's going to return that as a number, and by default,

1129
00:58:49,590 --> 00:58:52,480
Lua不允许您连接字符串和数字 
Lua does not allow you to concatenate strings and numbers,

1130
00:58:52,480 --> 00:58:55,790
所以我们要在这里连接这个运算符 
so we're going to concatenate here with this ..operator,

1131
00:58:55,790 --> 00:58:58,180
这是在Lua中进行字符串连接的方法 
which is the way of doing string concatenation in Lua.

1132
00:58:58,180 --> 00:59:00,013
我们将调用两个字符串函数 
We're going to call the two string function.

1133
00:59:00,013 --> 00:59:01,792
所以我们来看看Love Timer.FPS 
So we're going to take in love.timer.FPS,

1134
00:59:01,792 --> 00:59:03,500
我们要把它做成一根线 然后
we're going to make it a string, and then

1135
00:59:03,500 --> 00:59:05,110
我们将在这里将其连接起来 
we're going to concatenate it here.

1136
00:59:05,110 --> 00:59:08,832
然后我们将在该值上调用love.graph print 
And then we're going to call love.graphics.print on that value,

1137
00:59:08,832 --> 00:59:10,540
然后我们会把它设为10 10 
and then we're going to put it at 10, 10.

1138
00:59:10,540 --> 00:59:14,360
所以把它从屏幕的左上角移一点 
So shift it just a little bit from the top left edge of the screen.

1139
00:59:14,360 --> 00:59:18,310
因此 这将产生Go to Pong 6的效果 我们运行它 
So that's going to have the effect of the go to Pong 6, and we run it.

1140
00:59:18,310 --> 00:59:20,587
我们现在可以看到它从0和52开始 因为它
We can see now it starts at zero and 52 because it

1141
00:59:20,587 --> 00:59:22,420
必须在它之前收集几帧数据
has to gather a few frames of data before it

1142
00:59:22,420 --> 00:59:25,090
有一个我们可以实际使用的数字 
has a number we can actually use.

1143
00:59:25,090 --> 00:59:32,011
但是我们看到FPS在60 所以我们的游戏运行 否则 还是一样的 
But we see there FPS at 60, and so our game runs, otherwise, just the same.

1144
00:59:32,011 --> 00:59:32,760
完全是随机的 
Completely random.

1145
00:59:32,760 --> 00:59:36,820
有点坏了 不过没关系 我们会修好的 
A little bit broken, but that's OK, we'll fix it up.

1146
00:59:36,820 --> 00:59:39,850
但目前我们有一个问题 那就是
But currently we have a problem, and that's

1147
00:59:39,850 --> 00:59:43,210
我们的球直接穿过了我们的球拍 
that our ball is just going straight through our paddles.

1148
00:59:43,210 --> 00:59:45,274
那么 我们如何解决这个问题呢？
So how can we fix this problem?

1149
00:59:49,070 --> 00:59:51,640
我们需要一些检测碰撞的方法 
We need some way of detecting collision.

1150
00:59:51,640 --> 00:59:59,350
因此 在2D游戏中 通常存在AA、BB碰撞检测的概念 
So in 2D games, generally, there's a concept of aa bb collision detection.

1151
00:59:59,350 --> 01:00:04,750
这是轴对齐边界框碰撞检测 它
And what this is is axis aligned bounding box collision detection, which

1152
01:00:04,750 --> 01:00:09,124
意味着我们有边界框 只有矩形、四边形、
means that we have bounding boxes, just rectangles, quads,

1153
01:00:09,124 --> 01:00:12,040
它们具有不旋转的x和y以及宽度和高度 
which have an x and a y and a width and a height which are nonrotated.

1154
01:00:12,040 --> 01:00:14,470
所以它们完全与我们的轴线对齐 
So they're completely aligned with our axes.

1155
01:00:14,470 --> 01:00:16,810
它们是完全平行垂直的 
They're completely parallel perpendicular.

1156
01:00:16,810 --> 01:00:22,660
所以我们能得到这个简单数学的唯一方法 AA-BB碰撞
So the only way that we can get this easy math, the aa bb collision

1157
01:00:22,660 --> 01:00:25,982
如果我们的盒子没有旋转 检测工作就会起作用 
detection working is if we have no rotation of our boxes.

1158
01:00:25,982 --> 01:00:27,440
它们必须完全一致 
They have to be completely aligned.

1159
01:00:27,440 --> 01:00:30,860
但如果是这样 我们有一个非常简单的算法 
But if they are, we have a very simple algorithm,

1160
01:00:30,860 --> 01:00:34,600
那就是我们只是要确保我们的盒子没有边缘
which is we're just making sure that no edges of our boxes

1161
01:00:34,600 --> 01:00:39,290
在我们的--另一个矩形的相对边缘之外 
are outside the opposite edges of our-- of the other rectangle.

1162
01:00:39,290 --> 01:00:45,070
所以如果我们有一个矩形--我将在这里的屏幕上说明这一点 
So if we have one rectangle-- and I'll illustrate this on the screen here.

1163
01:00:45,070 --> 01:00:47,290
我们有两个长方形 
We have two rectangles.

1164
01:00:47,290 --> 01:00:53,380
如果这条顶边在这条边下面 我们知道
If this top edge is below this edge, we know

1165
01:00:53,380 --> 01:00:56,530
无论如何 它们不会相交--它们不会相交 
no matter what, they're not going to inter-- they're not intersecting.

1166
01:00:56,530 --> 01:00:58,720
它不可能做到 因为它就在下面 
There is no way it can because it's below here.

1167
01:00:58,720 --> 01:01:02,080
所以不管它在x轴和y轴上的什么位置 如果它在这里下面 
So no matter where it is on the x and the y, if it's below here,

1168
01:01:02,080 --> 01:01:04,120
这不是撞车 
it's not a collision.

1169
01:01:04,120 --> 01:01:08,450
如果这条边在这个矩形的这一边 
If this edge is on this side of this rectangle,

1170
01:01:08,450 --> 01:01:11,950
我们也知道 这两个盒子不可能重叠 
we know, as well, there's no way those two boxes can overlap.

1171
01:01:11,950 --> 01:01:15,340
它适用于每一条边 只要它是相对的边 
And it applies to every edge as long as it is the opposite edge.

1172
01:01:15,340 --> 01:01:19,450
所以如果这条边在这条下面 如果这条边在这条上面 
So if this edge is below this one, if this edge is above this one,

1173
01:01:19,450 --> 01:01:22,240
如果这条边在右边 这条边在左边 
if this edge is on the right, and this edge is on the left,

1174
01:01:22,240 --> 01:01:25,790
这意味着无论发生什么 这些盒子都不会碰撞 
it means that no matter what, those boxes aren't colliding.

1175
01:01:25,790 --> 01:01:28,600
所以我们可以简单地做四个条件 
So we can simply do four conditions.

1176
01:01:28,600 --> 01:01:38,500
我们可以说 如果rec1.x不大于rec2.x 加上rec2.wide 
We can say, if rec1.x is not greater than rec 2.x, plus rec2.width,

1177
01:01:38,500 --> 01:01:43,900
并且rec1.x加上rec1.wide不小于rec2.x 
and rec1.x plus rec1.width is not less than rec2.x,

1178
01:01:43,900 --> 01:01:49,870
所以如果这两条边没有超出它们的相对边 y也是一样的 
so if the two edges are not beyond their opposite edges, same thing with the y,

1179
01:01:49,870 --> 01:01:55,090
Y加上rec1的高度 我们知道我们有碰撞 
and the y plus rec1.height, we know that we have a collision.

1180
01:01:55,090 --> 01:01:59,830
我们知道这一点 因为我们还没有达到这些标准中的任何一项 
We know that because we haven't fulfilled any of those criteria.

1181
01:01:59,830 --> 01:02:05,680
但我们知道 如果这不是真的 如果...
But we know that if that's not true, if the--

1182
01:02:05,680 --> 01:02:09,300
其中一条边没有超过另一条边 那么它--
one of the edges is not beyond the opposite edge, then it's--

1183
01:02:09,300 --> 01:02:10,820
我们确实发生了碰撞 
we do have a collision.

1184
01:02:10,820 --> 01:02:12,380
因此 这将是真的 
So it is going to be true.

1185
01:02:12,380 --> 01:02:14,660
因此 我们将在代码中看到这一点 
So we'll see that here in our code.

1186
01:02:14,660 --> 01:02:26,200
Go to Pong 7 在第113行 我们有一个功能
The go to Pongs 7, at line 113, we have a function

1187
01:02:26,200 --> 01:02:29,300
我们称之为球碰撞 
that we're calling called ball collides.

1188
01:02:29,300 --> 01:02:31,684
我们的Ball类有一个名为Collides的函数 
Our ball class has a function called collides.

1189
01:02:31,684 --> 01:02:33,850
那么让我们继续来看看我们的球课 
So let's go ahead and take a look at our ball class.

1190
01:02:40,070 --> 01:02:42,740
在本例中 我们将函数定义为
And in this case, we've defined our function such

1191
01:02:42,740 --> 01:02:45,020
它接受一个划桨参数 所以它是
that it takes in a paddle parameter, so it's

1192
01:02:45,020 --> 01:02:47,210
将与另一个矩形进行比较 该矩形
going to compare against another rectangle that

1193
01:02:47,210 --> 01:02:50,410
具有XY和宽度和高度 
has an xy and a width and a height.

1194
01:02:50,410 --> 01:02:57,470
我们说 如果rx大于划桨x 再加上划桨
And we're saying that if rx is greater than the paddle x, plus the paddle

1195
01:02:57,470 --> 01:03:01,850
宽度 这意味着如果RX大于右边缘 
width, which means if rx is greater than the right edge.

1196
01:03:01,850 --> 01:03:04,880
所以如果我们的左上角大于--
So if our top left is greater than the--

1197
01:03:04,880 --> 01:03:08,250
或者就是我们的左边--比右边大 
or just our left-- is greater than the right edge,

1198
01:03:08,250 --> 01:03:10,190
我们知道我们不可能相撞 
we know that we can't collide.

1199
01:03:10,190 --> 01:03:16,130
如果它比其他矩形大 情况也是一样的 
Same thing if it's greater than the other rectangles,

1200
01:03:16,130 --> 01:03:20,250
Self.x加上self.wide 
self.x plus self.width.

1201
01:03:20,250 --> 01:03:21,350
不 对不起 
No, sorry.

1202
01:03:21,350 --> 01:03:24,040
在这种情况下 如果球拍的x是--
In that case, if the paddle's x is--

1203
01:03:24,040 --> 01:03:26,840
它的操作基本相同 但从划桨的角度来看 
it basically the same operation but from the paddle's perspective.

1204
01:03:26,840 --> 01:03:31,130
如果球拍大于右侧的矩形 
If the paddle is greater than the rectangle on the right side,

1205
01:03:31,130 --> 01:03:33,525
如果它沿着右侧更远地越过右侧边缘 
if it's farther along the right side past the right edge,

1206
01:03:33,525 --> 01:03:35,150
我们知道不可能发生碰撞 
we know that there can be no collision.

1207
01:03:35,150 --> 01:03:36,470
这是不可能的 
It's just impossible.

1208
01:03:36,470 --> 01:03:38,270
Y也是如此 
Same thing with y.

1209
01:03:38,270 --> 01:03:42,050
如果y--self.y 那么这个球是y--
If the y-- self.y, so this ball is y--

1210
01:03:42,050 --> 01:03:45,060
大于划桨的y 加上划桨高度 
is greater than the paddle's y, plus the paddle height.

1211
01:03:45,060 --> 01:03:47,420
所以如果它在桨的边缘以下 因为我们是
So if it's below the edge of the paddle, because we're

1212
01:03:47,420 --> 01:03:51,980
考虑到高度 或者如果划桨的y更大
taking the height into consideration, or if the paddle's y is greater

1213
01:03:51,980 --> 01:03:57,140
比这个球的y加本身高 然后我们
than this ball's y plus self.height, then we

1214
01:03:57,140 --> 01:04:00,440
要知道 这也不可能是碰撞 
know that that also can't be a collision.

1215
01:04:00,440 --> 01:04:03,206
但如果这不是真的 那么我们需要返回真 
But if that's not true, then we need to return true.

1216
01:04:06,170 --> 01:04:11,050
所以如果我们回到主干道--不 那是错误的主干道 
And so if we go back to our main-- no, that's the wrong main.

1217
01:04:11,050 --> 01:04:16,840
我们回到Main 这里是Lua 
We go back to main.lua here.

1218
01:04:16,840 --> 01:04:19,590
我们要把球打成碰撞球 
We're calling ball.collides.

1219
01:04:19,590 --> 01:04:22,030
所以如果我们处于我们的游戏状态 如果我们处于--抱歉 
So if we're in our game state, if we're in our-- sorry,

1220
01:04:22,030 --> 01:04:25,810
如果我们处于游戏状态 如果游戏状态等于游戏 
if we're in our play state, if game state is equal to play,

1221
01:04:25,810 --> 01:04:29,650
如果球与一号球员相撞 那么一号球员就是左桨 
if the ball collides with player one, so player one is the left paddle.

1222
01:04:29,650 --> 01:04:36,400
因此 如果检测到碰撞 那么球.dx和dx就是我们的x速度 
So if there's a collision detected, the ball.dx and dx is our x velocity.

1223
01:04:36,400 --> 01:04:39,500
所以它在x轴上移动的方向是什么 
So it's whatever direction it's moving on the x-axis.

1224
01:04:39,500 --> 01:04:44,230
所以如果它消失了 它就会向左移动--
So it's going to be moving to the left if it's gone--

1225
01:04:44,230 --> 01:04:46,067
如果我们检测到碰撞 
if we detected a collision.

1226
01:04:46,067 --> 01:04:48,400
它是向左还是向右移动并不重要 
And it doesn't matter whether it's moving left or right,

1227
01:04:48,400 --> 01:04:52,842
但我们需要--我们需要做的是将其设置为负值 
but we needed-- what we need to do is set it to its negative value.

1228
01:04:52,842 --> 01:04:54,550
因为如果它向左移动 我们说--
Because if it's moving left and we said--

1229
01:04:54,550 --> 01:04:59,380
假设它在负20像素处向左移动 我们设置为20 
let's say it's moving left at its negative 20 pixels and we set to 20,

1230
01:04:59,380 --> 01:05:01,840
DX现在是20 它将开始向右移动 
the dx is now 20, it's going to start moving to the right.

1231
01:05:01,840 --> 01:05:06,880
它会产生反转其x速度的效果
It's going to have the effect of inverting its x velocity

1232
01:05:06,880 --> 01:05:09,170
因此 扭转了它的方向 
and, therefore, reversing its direction.

1233
01:05:09,170 --> 01:05:12,280
但我们在这里用1.03倍做的
But what we're also doing here with times 1.03

1234
01:05:12,280 --> 01:05:15,070
我们只是为了加快比赛速度而增加了一点 
is we're multiplying a little bit just to speed up the game.

1235
01:05:15,070 --> 01:05:18,460
因为我们不希望游戏进入永恒 只是有相同的速度 
Because we don't want the game to into perpetuity just have the same velocity.

1236
01:05:18,460 --> 01:05:20,230
这不会增加人们的兴奋感 
It's not going to ramp up the excitement.

1237
01:05:20,230 --> 01:05:23,200
我们想要让事情继续下去 我们想要获得一些动力 
We want to keep things going, we want to get some momentum going,

1238
01:05:23,200 --> 01:05:25,660
所以我们要做的就是把Ball.dx
so what we're going to do is call ball.dx

1239
01:05:25,660 --> 01:05:30,707
等于它的负值乘以我们任意确定的定标器 
equals its negative value times a scaler that we've determined arbitrarily.

1240
01:05:30,707 --> 01:05:32,665
在这种情况下 我决定这应该是重点--
In this case, I've decided it should be point--

1241
01:05:32,665 --> 01:05:37,060
1.03 所以每次都会增加3% 
1.03 so it'll increase it by 3% every time.

1242
01:05:37,060 --> 01:05:41,515
然后如果我们有一个--
And then in the event that we have a--

1243
01:05:41,515 --> 01:05:45,760
我们的球--因为它被添加了 它的x速度
our ball-- because it's getting added, its x velocity is getting

1244
01:05:45,760 --> 01:05:48,550
将每个帧添加到其位置 我们希望
added each frame to its position, we want

1245
01:05:48,550 --> 01:05:52,620
以确保它不会像在我们的桨里面一样 
to make sure that it's not like inside of our paddle.

1246
01:05:52,620 --> 01:05:55,600
因为它可能会移动一定数量的像素
Because it is possible that it could shift a certain number of pixels

1247
01:05:55,600 --> 01:05:59,260
向左或向右 因为适用相同的操作 
to the left, or to the right, because the same operation applies.

1248
01:05:59,260 --> 01:06:01,750
因此 这两者有点像在彼此的顶部 
Such that the two are sort of like on top of each other.

1249
01:06:01,750 --> 01:06:04,161
我们想要--我们想要改变它 我们想要重置它 
We want to re-- we want to shift it, we want to reset it.

1250
01:06:04,161 --> 01:06:06,910
所以我们要做的是--因为它会检测到另一次碰撞
So what we're going to do-- because it'll detect another collision

1251
01:06:06,910 --> 01:06:08,040
如果是这样的话马上就去 
immediately if that's the case.

1252
01:06:08,040 --> 01:06:10,270
如果它 在下一帧中 它在那个球拍内 
If it, on the next frame, it's within that paddle,

1253
01:06:10,270 --> 01:06:13,860
它会说它仍在与那把桨相撞
it's going to say that it's still colliding with that paddle

1254
01:06:13,860 --> 01:06:15,610
所以它会再次改变速度 
so it's going to shift its velocity again.

1255
01:06:15,610 --> 01:06:18,430
它将产生无限弹跳的效果
And it's going to have the effect of it infinitely sort of bouncing

1256
01:06:18,430 --> 01:06:19,804
在划桨内来回摆动 
back and forth within the paddle.

1257
01:06:19,804 --> 01:06:21,160
我们不希望这种情况发生 
We don't want that to happen.

1258
01:06:21,160 --> 01:06:23,466
因此 如果我们检测到碰撞 我们想要移动它 
So if we detect a collision, we want to shift it.

1259
01:06:23,466 --> 01:06:26,590
我们想要确保它完全在拍子的碰撞框之外 
We want to make sure it's completely outside of the paddle's collision box.

1260
01:06:26,590 --> 01:06:31,390
所以我们说的是 bal.x得到玩家1 x 加上5 
So we're saying ball.x gets player one.x, plus five.

1261
01:06:31,390 --> 01:06:34,210
加5 因为这是桨的宽度 
Plus five because that's the width of the paddle.

1262
01:06:34,210 --> 01:06:38,401
所以这只有一次你检测到碰撞的效果 负集--
So that has the effect of just once you detect a collision, negative set--

1263
01:06:38,401 --> 01:06:40,150
X速度变为负值 然后立即
x velocity to negative, and then instantly

1264
01:06:40,150 --> 01:06:44,830
把它向右移到左桨的右边 
shift it right on the right edge of the left paddle.

1265
01:06:44,830 --> 01:06:47,170
我们在这里也在做同样的事情 
And we're doing the same thing here.

1266
01:06:47,170 --> 01:06:51,670
如果球撞上了一两个球 我们就是在做--我们在否定或颠倒
If ball collides a play or two, we're doing the-- we're negating or inverting

1267
01:06:51,670 --> 01:06:54,340
它的x速度 
its x velocity.

1268
01:06:54,340 --> 01:06:57,520
然后--这是同样的手术 
And then-- this is the same exact operation,

1269
01:06:57,520 --> 01:07:01,360
但由于它是基于--左上角 
but since it's based on the-- the left top left corner,

1270
01:07:01,360 --> 01:07:04,540
我们不能减去5% 那就说不通了 
we can't minus it by five, that wouldn't make sense.

1271
01:07:04,540 --> 01:07:07,840
我们要把它减去4 因为那是球的宽度 
We're going to minus it by four because that's the width of the ball.

1272
01:07:07,840 --> 01:07:11,310
所以如果我们把它减去5 我们就会有一个像素的空间 
So if we minused it by five, we would have one pixel of space.

1273
01:07:11,310 --> 01:07:15,010
我们在这个例子中加了5 因为我们是
We plussed it by five on this example, because we're

1274
01:07:15,010 --> 01:07:16,667
从右边进来 
coming in from the right side.

1275
01:07:16,667 --> 01:07:19,750
我们只想确保它在划桨的正确边缘 
We want to just make sure that it's right on the right edge of the paddle,

1276
01:07:19,750 --> 01:07:22,240
所以我们将其设置为玩家1e.x 
so we're setting it to player one.x.

1277
01:07:22,240 --> 01:07:25,960
在这种情况下 我们使用的是负四
And in this case, we're using the minus four

1278
01:07:25,960 --> 01:07:28,210
因为这就是球的宽度 
because that's the width of the ball.

1279
01:07:28,210 --> 01:07:30,995
所以我们想把它移到左边 球的宽度 
So we want to shift it to the left, the width of the ball,

1280
01:07:30,995 --> 01:07:34,120
这将产生右桨的效果 如果发生碰撞 
and that will have the effect of the right paddle, if there is a collision,

1281
01:07:34,120 --> 01:07:36,520
它只会被移到另一边 右边--球
it'll just get shifted over, and the right-- the ball

1282
01:07:36,520 --> 01:07:40,150
将在他们的两个边缘接触到球拍 
will be touching the paddle right on their two edges.

1283
01:07:40,150 --> 01:07:45,700
在第118行 我们解决了之前的问题 
Here on line 118, we're solving the problem we had before of what

1284
01:07:45,700 --> 01:07:48,580
发生在...
happens when the--

1285
01:07:48,580 --> 01:07:50,830
哦 对不起 我想的不是这个 
oh, sorry, that's actually not what I was thinking of.

1286
01:07:50,830 --> 01:07:57,880
如果有碰撞 我们需要球的y速度
This is the-- if there's a collision, then we want the ball's y velocity

1287
01:07:57,880 --> 01:07:59,350
每次都是随机的
to randomize every time.

1288
01:07:59,350 --> 01:08:02,470
所以当我们玩这个游戏的时候
So this has the effect of when we're playing the game

1289
01:08:02,470 --> 01:08:05,320
我们检测到两个电极板发生了碰撞
and we've detected a collision between the two paddles,

1290
01:08:05,320 --> 01:08:08,320
我们不想每次都从同一个角度来回
we don't want the same angle back and forth every time

1291
01:08:08,320 --> 01:08:11,710
因为这个博弈会无限地重复
because then the game will just infinitely take place the exact same--

1292
01:08:11,710 --> 01:08:14,291
同样的角度会不断重复
the same angle will just keep happening over and over again.

1293
01:08:14,291 --> 01:08:15,290
我们不希望这样 
We don't that to happen.

1294
01:08:15,290 --> 01:08:19,689
我们希望球从球拍上反弹的方式有一些变化 
We want some variability in terms of how the ball bounces off the paddle.

1295
01:08:19,689 --> 01:08:22,130
所以这个方法的作用是 仍然在这个条件下 
So what this does is, still within the condition,

1296
01:08:22,130 --> 01:08:25,210
如果球与一号玩家相撞
if the ball collides with player one, we're

1297
01:08:25,210 --> 01:08:31,010
如果球的y轴速度为负 
going to, say, if the y velocity of the ball is negative,

1298
01:08:31,010 --> 01:08:32,740
那我们就想让它一直是负的
then we want to keep it going negative.

1299
01:08:32,740 --> 01:08:34,823
我们还是想要球--就像如果球来了
We still want the ball-- like if the ball's coming

1300
01:08:34,823 --> 01:08:37,420
以一种向上的角度 它从球拍上弹开 
at a sort of an upward angle and it bounces off the paddle,

1301
01:08:37,420 --> 01:08:39,290
我们希望x速度移动 
we want the x velocity to shift.

1302
01:08:39,290 --> 01:08:42,819
我们希望它向相反的方向运动 但我们希望球继续向上运动 
We want it to go to opposite direction, but we want the ball to keep going up.

1303
01:08:42,819 --> 01:08:45,069
我们不想让球反弹回来 
We don't want the ball to like bounce back down, which

1304
01:08:45,069 --> 01:08:45,950
完全说不通
wouldn't make any sense.

1305
01:08:45,950 --> 01:08:47,680
我们不想忽略y方向的速度 
We don't want to negate the y velocity.

1306
01:08:47,680 --> 01:08:49,638
所以我们保持y速度为负 
So we're going to keep the y velocity negative,

1307
01:08:49,638 --> 01:08:53,050
我们将它设置为10到150之间的负值 
we're going to set it to a negative value between 10 and 150.

1308
01:08:53,050 --> 01:08:54,050
这是武断的 
And it's just arbitrary.

1309
01:08:54,050 --> 01:08:55,700
你可以随意设置
You can set that to whatever you want.

1310
01:08:55,700 --> 01:08:58,840
如果y方向的速度为正 我们也要做同样的事情 
And then we're going to do the same thing if the y velocity is positive.

1311
01:08:58,840 --> 01:09:02,229
我们想让球
We want the ball to--

1312
01:09:02,229 --> 01:09:07,510
如果球已经落下来了 我们希望它朝正方向运动 
we want the ball to go in the positive direction if it's already coming down.

1313
01:09:07,510 --> 01:09:10,569
所以我们在做同样的事情 
So we're doing the exact same thing here.

1314
01:09:10,569 --> 01:09:13,403
在参与人2的例子中也是一样的逻辑 
It's the same logic in the player two instance.

1315
01:09:13,403 --> 01:09:16,319
然后我以为我看到的是这个
And then this was what I thought I was looking at before for a second,

1316
01:09:16,319 --> 01:09:20,649
但这就是我们如何解决屏幕的上下边界的问题 
but this is how we fix the issue of the upper and lower boundary of the screen.

1317
01:09:20,649 --> 01:09:21,149
对的
Right.

1318
01:09:21,149 --> 01:09:24,750
因为这是一件事来解决我们有桨的事实
Because it's one thing to solve the fact that we have the paddles

1319
01:09:24,750 --> 01:09:27,720
现在让球偏转 但我们不想要球
now deflecting the ball, but we don't want the ball

1320
01:09:27,720 --> 01:09:30,270
要无限地高于屏幕的顶部边缘 
to infinitely go above the top edge of the screen,

1321
01:09:30,270 --> 01:09:32,080
或屏幕的底边 
or the bottom edge of the screen.

1322
01:09:32,080 --> 01:09:34,842
所以这只是一个简单的if条件 
So this is just a simple if condition.

1323
01:09:34,842 --> 01:09:37,050
我们只是说如果球小于或等于
We're just saying if the ball's less than or equal to

1324
01:09:37,050 --> 01:09:40,407
零 这意味着如果球在屏幕的顶端 
zero, which means if the ball's at the top edge of the screen,

1325
01:09:40,407 --> 01:09:42,240
只需将其设置为零 确保它不会
just set it to zero, so make sure it doesn't

1326
01:09:42,240 --> 01:09:46,319
走到屏幕边缘上方 然后否定它的宽速度 
go above the edge of the screen, and then negate its wide velocity,

1327
01:09:46,319 --> 01:09:48,490
因此 它会立即开始向下 
so it's instantly going to start going downwards.

1328
01:09:48,490 --> 01:09:50,273
是 
Yes.

1329
01:09:50,273 --> 01:09:53,880
观众：这个问题是关于乒乓球7号第113行的 
AUDIENCE: This question is about Pong 7, line 113.

1330
01:09:53,880 --> 01:09:57,270
难道球dx和y的移动不能
Couldn't the shifting of the balls dx and y

1331
01:09:57,270 --> 01:10:01,660
在做球碰撞功能时 如果有碰撞？
be done in the ball collides function, if there is a collision?

1332
01:10:01,660 --> 01:10:06,330
科尔顿·奥格登：如果球相撞 球的功能会发生变化--不 
COLTON OGDEN: The shifting of the ball's function if ball collide-- no,

1333
01:10:06,330 --> 01:10:08,580
撞球--碰撞功能
collides the ball-- the collides function

1334
01:10:08,580 --> 01:10:11,470
是--它只返回真或假 
is a-- it just returns true or false.

1335
01:10:11,470 --> 01:10:14,520
所以它会是--
So it would be--

1336
01:10:14,520 --> 01:10:19,530
我的意思是 我认为你可以用这种方式重构它 
I mean, I think you probably could refactor it out that way,

1337
01:10:19,530 --> 01:10:21,540
但碰撞的目的并不是为了
but the purpose of collides isn't to have

1338
01:10:21,540 --> 01:10:23,819
任何像那样的副作用 
any sort of side effects like that.

1339
01:10:23,819 --> 01:10:25,860
它的唯一目的只是返回True或False 
Its only purpose is just to return true or false.

1340
01:10:25,860 --> 01:10:28,651
因为我们可以做任何--我们可以有任何我们想要的行为 
Because we can do any-- we could have any sort of behavior we want.

1341
01:10:28,651 --> 01:10:31,560
在碰撞函数中 我们可能不一定想要移动球
In a collides function, we may not necessarily want to shift the ball

1342
01:10:31,560 --> 01:10:33,601
或者做任何事情 我们可能只希望它返回TRUE
or do anything, we might just want it return true

1343
01:10:33,601 --> 01:10:35,280
把一些东西打印到控制台上 
and print something to the console.

1344
01:10:35,280 --> 01:10:37,920
所以 我认为 从工程学的角度来看 
So, in terms of, I think, in an engineering perspective,

1345
01:10:37,920 --> 01:10:40,847
只要有一个简单的真或假函数就更有意义了 
it makes more sense just to have a simple true or false function,

1346
01:10:40,847 --> 01:10:43,680
然后确定你希望它如何真正影响你的比赛
and then determine how you want that to actually influence your game

1347
01:10:43,680 --> 01:10:48,310
在您的主函数或某个其他函数中声明 
state inside your main function, or inside some other function.

1348
01:10:48,310 --> 01:10:48,810
好的 
OK.

1349
01:10:51,420 --> 01:10:53,570
所以 是的 我们去了这里 
And so, Yeah, we went down here.

1350
01:10:53,570 --> 01:10:57,660
屏幕的顶部边缘 然后是屏幕的底部边缘 
The top edge of the screen, and then bottom edge of the screen.

1351
01:10:57,660 --> 01:11:00,840
如果是球 那也是一样的东西 只是屏幕的底部边缘 
If the ball.y, it's same exact thing, just the bottom edge of the screen.

1352
01:11:00,840 --> 01:11:04,770
如果球Y大于或等于虚拟高度减4 
If the ball.y is greater than or equal to virtual height minus four,

1353
01:11:04,770 --> 01:11:06,840
而我们做的实际上是四分之差 为什么？
and we're doing virtual high minus four, why?

1354
01:11:06,840 --> 01:11:08,190
观众：可能会卡在底部
AUDIENCE: Could get stuck at the bottom

1355
01:11:08,190 --> 01:11:09,450
科尔顿·奥格登：没错 
COLTON OGDEN: Exactly.

1356
01:11:09,450 --> 01:11:12,180
所以我们想确保我们写下--只要我们--
So we want to make sure that we write-- as soon as we--

1357
01:11:12,180 --> 01:11:15,310
球的底边接触屏幕的底部 
the bottom edge of the ball touches the bottom of the screen,

1358
01:11:15,310 --> 01:11:18,720
我们想要检测碰撞 然后我们想说球 Y 那个--
we want to detect a collision, then we want to say ball.y, the--

1359
01:11:18,720 --> 01:11:22,290
获取虚拟高度减去4 以防超出底部边缘
gets virtual height minus four in case it overshot the bottom edge

1360
01:11:22,290 --> 01:11:25,600
根据经过了多少时间和速度有多大 
based on how much time has elapsed and how much the velocity is,

1361
01:11:25,600 --> 01:11:28,320
你想立刻把它立起来 这样它就在边缘
you want to instantly put it right up so that it's at the edge

1362
01:11:28,320 --> 01:11:29,910
所以这是一次干净利落的反弹 
so it's a clean bounce.

1363
01:11:29,910 --> 01:11:32,340
然后 我们想要同样地否定y速度
And then we want to negate the y velocity just the same

1364
01:11:32,340 --> 01:11:35,500
就像我们在上面做的那样 
as we did up above.

1365
01:11:35,500 --> 01:11:46,160
因此 如果我们在这里运行我们的程序 Pong 7 看起来是一样的 
And so if we run our program here, Pong 7, looks the same,

1366
01:11:46,160 --> 01:11:50,200
但现在球开始反弹了 
but now the ball's bouncing.

1367
01:11:50,200 --> 01:11:52,810
注意 它得到了一个否定的--它有一个随机的--它
And note that it got a neg-- it got a random-- it

1368
01:11:52,810 --> 01:11:54,601
看起来像是在底部边缘以下
looks like it's going below the bottom edge

1369
01:11:54,601 --> 01:11:57,760
因为显示器当前的分辨率是720 这是窗口分辨率 
because the monitor is currently at 720 and that's the window resolution,

1370
01:11:57,760 --> 01:11:59,740
但它也在从底部边缘反弹 
but it is bouncing off the bottom edge as well.

1371
01:11:59,740 --> 01:12:03,250
如果你注意到 每次的角度都有一点不同 
And the angle, if you'll note, is a little bit different every time,

1372
01:12:03,250 --> 01:12:10,180
因为我们给它一个随机的y速度 a y--
because we are giving it a random y velocity, a y--

1373
01:12:10,180 --> 01:12:10,680
嗯 
yeah.

1374
01:12:10,680 --> 01:12:14,770
然后这就是影响--哦 我搞砸了 
And then that's influencing-- oh, I messed up.

1375
01:12:14,770 --> 01:12:17,784
我想要举例说明速度的提高 
I wanted to illustrate the speed increase.

1376
01:12:17,784 --> 01:12:19,450
这需要一点时间 
It's going to take a little bit of time.

1377
01:12:19,450 --> 01:12:25,180
但每次它探测到碰撞 它就会扩大它的--
But every time it detects a collision, it is going to be scaling its--

1378
01:12:25,180 --> 01:12:28,346
X速度增加了1.03倍 
the x velocity by 1.03.

1379
01:12:28,346 --> 01:12:30,220
所以它会让它更快一点 
So it's going to make it a little bit faster.

1380
01:12:30,220 --> 01:12:31,840
现在 Y角有点太陡了 
Now, currently, the y angle's a bit steep,

1381
01:12:31,840 --> 01:12:33,950
所以这需要永远的时间来说明这一点 
so it's going to take forever to illustrate that.

1382
01:12:33,950 --> 01:12:37,190
但我们将在后面的示例中看到这一点 
But we'll see that in a later example.

1383
01:12:37,190 --> 01:12:42,290
因此 我们已经掌握了游戏的基本知识 
So we have the basics of our game.

1384
01:12:42,290 --> 01:12:43,960
但我们如何计分呢？
But how are we keeping score?

1385
01:12:43,960 --> 01:12:47,518
决定我们如何在乒乓球项目上得分的因素是什么？
What's the determining factor for how we keep score in Pong?

1386
01:12:47,518 --> 01:12:48,579
左或右 
Left or right.

1387
01:12:48,579 --> 01:12:51,120
只要它穿过屏幕的左边缘或右边缘 
As long as it goes past the left or right edge of the screen.

1388
01:12:51,120 --> 01:12:53,635
那么 我们需要做些什么呢？
So what do we need to thereby do?

1389
01:12:53,635 --> 01:12:55,054
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1390
01:12:55,054 --> 01:12:57,000
科尔顿·奥格登：我们确实需要一个柜台 我们
COLTON OGDEN: We do need a counter, and we

1391
01:12:57,000 --> 01:12:59,700
还需要监控球是否有
need to also monitor whether the ball has

1392
01:12:59,700 --> 01:13:03,720
与屏幕的左边界或右边界发生冲突 
collided with the left or the right boundary of the screen.

1393
01:13:03,720 --> 01:13:06,150
然后让计数器递增 
And then have that increment that counter.

1394
01:13:06,150 --> 01:13:08,970
所以我们接下来来看看乒乓球8
So we're going to go ahead and take a look at Pong 8

1395
01:13:08,970 --> 01:13:13,330
看看这是如何实施的 
to see how this is implemented.

1396
01:13:13,330 --> 01:13:18,352
我们在第88行和第89行有一些反变量 一号玩家得分 
We have here on line 88 and 89 some counter variables, player one score,

1397
01:13:18,352 --> 01:13:19,060
二号玩家得分 
player two score.

1398
01:13:19,060 --> 01:13:21,640
我们已经拥有它们很长时间了 但我们还没有用过它们 
We've had those for a long time, but we haven't used them.

1399
01:13:21,640 --> 01:13:23,440
我们只是用它们来画到屏幕上 
We've only used them to draw to the screen.

1400
01:13:23,440 --> 01:13:27,940
我们现在实际上要递增它们 并将它们显示为记分
We're actually going to now increment them, and show them as scorekeeping

1401
01:13:27,940 --> 01:13:31,390
我们代码中的变量 
variables in our code here.

1402
01:13:31,390 --> 01:13:33,290
我以为我已经在《乒乓球8》中实现了 
I thought I had implemented it in Pong 8,

1403
01:13:33,290 --> 01:13:36,760
但我想我可能遗漏了分数的实际增量 
but I think I might have left out the actual incrementing of the score.

1404
01:13:36,760 --> 01:13:39,220
但这就是与这个例子相关的逻辑 
But this is the logic that's pertinent to that example.

1405
01:13:39,220 --> 01:13:43,030
因此 如果bal.x小于零 这只是
So if ball.x is less than zero, which just

1406
01:13:43,030 --> 01:13:48,430
意味着如果我们已经越过了屏幕的左边缘 
means if we've gone past the left edge of the screen,

1407
01:13:48,430 --> 01:13:49,840
暂时忽略发球手 
ignore serving player for now.

1408
01:13:49,840 --> 01:13:52,640
重要的是 我们现在是在为二号选手得分 
The important thing is now we are doing player two score,

1409
01:13:52,640 --> 01:13:54,580
获得玩家TWP分数 加1 
gets player twp score, plus one.

1410
01:13:54,580 --> 01:13:56,140
只是一个简单的增量 
Just a simple increment.

1411
01:13:56,140 --> 01:13:57,880
然后我们重新设置球 
And then we're resetting the ball.

1412
01:13:57,880 --> 01:13:59,740
这里也是一样 
Same thing for here.

1413
01:13:59,740 --> 01:14:01,990
如果Ball.x大于虚拟宽度 
If the ball.x is greater than virtual width,

1414
01:14:01,990 --> 01:14:08,860
所以通过屏幕的右边缘 实际上它可能是--
so pass the right edge of the screen, and actually it could be ver--

1415
01:14:08,860 --> 01:14:12,120
如果球x加4大于虚拟宽度 
if ball x plus four is greater than virtual width,

1416
01:14:12,120 --> 01:14:14,000
那么 它也会产生同样的效果 
then and it will have the same effect.

1417
01:14:14,000 --> 01:14:16,947
但是 事实上 不是的 因为我们想确保
But, actually, no, because we want to make sure

1418
01:14:16,947 --> 01:14:19,030
当他们得分时 我们根本看不到球 
that we don't see the ball at all when they score.

1419
01:14:19,030 --> 01:14:20,488
所以 是的 这实际上是正确的 
So, yeah, this is actually correct.

1420
01:14:20,488 --> 01:14:23,920
如果Ball.x大于虚拟宽度 则发球手得到2 
If ball.x is greater than virtual width, then serving player gets two,

1421
01:14:23,920 --> 01:14:25,895
一人得分等于一人一分加一 
player one score is player one score plus one.

1422
01:14:25,895 --> 01:14:27,520
然后我们要重置球 
And then we're going to reset the ball.

1423
01:14:27,520 --> 01:14:29,050
发球手 
Serving player.

1424
01:14:29,050 --> 01:14:33,370
所以现在我们要谈的是服务的理念 
So now what we need to talk about is the idea of serving.

1425
01:14:33,370 --> 01:14:35,680
所以当我们开始游戏的时候--
So when we start up the game--

1426
01:14:35,680 --> 01:14:37,328
那么让我们继续来看看--
so let's go ahead and take a look at--

1427
01:14:42,004 --> 01:14:44,920
我们现在要去Pong 所以我们要直接去Pong 9 
we're going to go to Pong now so we're going to go straight to Pong 9,

1428
01:14:44,920 --> 01:14:47,700
然后我们需要看看什么是状态机 
and then we need to take a look at what a state machine is.

1429
01:14:47,700 --> 01:14:50,670
因此 目前在游戏中 我们已经讨论了一点状态 
So currently in the game, we've talked about state a little bit.

1430
01:14:50,670 --> 01:14:53,700
我们已经进入了开始状态 这意味着比赛已经准备好了
We've had the start state, which means the game is ready for us

1431
01:14:53,700 --> 01:14:56,857
只需按下Enter键 球就会以随机的方向飞出 
to just press Enter and then the ball will go off in a random direction.

1432
01:14:56,857 --> 01:14:58,190
然后我们得到了播放状态 
And then we have the play state.

1433
01:14:58,190 --> 01:15:02,490
比赛状态被设置为我们的球拍与球相互作用 
And the play state is set to our paddles interacting with the ball,

1434
01:15:02,490 --> 01:15:06,000
然后基本上记录下分数 
and then keeping track of score, basically.

1435
01:15:06,000 --> 01:15:08,010
状态机非常重要 
A state machine is very important.

1436
01:15:08,010 --> 01:15:11,400
这在游戏开发中是一个普遍存在的概念 
It's a ubiquitous concept in game development.

1437
01:15:11,400 --> 01:15:14,730
这只是意味着 我们如何监控我们所处的状态
It just means, how can we monitor what state we're in

1438
01:15:14,730 --> 01:15:19,050
以及这些状态之间发生了什么转变 以产生新的状态 
and what transitions take place between those states to bring out new states.

1439
01:15:19,050 --> 01:15:22,230
每个单独的州都有自己的逻辑 
And each individual state has its own logic.

1440
01:15:22,230 --> 01:15:26,220
通过将这些状态的逻辑分开 
And by breaking out the logic of these states separately,

1441
01:15:26,220 --> 01:15:32,820
我们可以将我们的代码扩展得更大 而不是针对--
we can scale our code much bigger and not have monolithic code for--

1442
01:15:32,820 --> 01:15:36,270
这张特殊的图表是一个例子 说明了你可能会有什么状态
this particular diagram is an example of what you might have as a state

1443
01:15:36,270 --> 01:15:40,290
机器对于像马里奥这样的角色来说 你有一个躲避状态 一个释放
machine for a character like Mario where you have a ducking state, a release

1444
01:15:40,290 --> 01:15:43,320
接受向下的状态--向内--就像向下的输入 
state which takes the down-- the in-- like the input of down.

1445
01:15:43,320 --> 01:15:45,750
所以如果我们往下放 它就会变得站立 
So if we're releasing down, it'll become standing.

1446
01:15:45,750 --> 01:15:49,130
所以在俯冲状态下 转换为松开向下键 
So ducking state, the transition is release the down key,

1447
01:15:49,130 --> 01:15:50,270
他站了起来 
he becomes standing.

1448
01:15:50,270 --> 01:15:52,140
站立键 按下向下键 
Standing key, press the down key.

1449
01:15:52,140 --> 01:15:56,350
他开始躲避 这些都是状态和转变 
He becomes ducking, these are states and transitions.

1450
01:15:56,350 --> 01:16:01,770
这些单独的状态是他行为的总体表现
These individual states are the overall representation of his behavior

1451
01:16:01,770 --> 01:16:03,080
基本上 总体上是这样的 
at large, basically.

1452
01:16:03,080 --> 01:16:06,240
同样的逻辑也适用于我们的游戏 
And the same logic applies to our game.

1453
01:16:06,240 --> 01:16:09,090
我们有比赛状态 我们有发球状态 
We have a play state, we have a serve state.

1454
01:16:09,090 --> 01:16:11,010
我们想要在州立大学打一场比赛 
We want to have maybe a game over state.

1455
01:16:11,010 --> 01:16:16,300
如果某人得了10分 那么它应该说 哦 获胜者是x 
If someone scores 10 points, then it should say, oh, the winner is x.

1456
01:16:16,300 --> 01:16:19,290
你可以定义任意数量的状态 它--
And you can define any arbitrary number of states, it--

1457
01:16:19,290 --> 01:16:22,540
这取决于你的模型 无论你想要开发什么游戏 
which depends upon your model, whatever game you want to develop.

1458
01:16:22,540 --> 01:16:24,690
例如 就像超级马里奥有一个标题屏幕一样 
For example, like Super Mario has a title screen,

1459
01:16:24,690 --> 01:16:27,864
也许你的比赛已经达到了高分状态 
maybe your game has like a high score state.

1460
01:16:27,864 --> 01:16:30,030
您想要显示游戏中的所有高分
You want to display all the high scores in your game

1461
01:16:30,030 --> 01:16:35,470
我们将在下周的一堂课上展示这一点 
and we'll actually show that in a lecture next week.

1462
01:16:35,470 --> 01:16:37,050
但这就是状态机的含义 
But this is what a state machine is.

1463
01:16:37,050 --> 01:16:40,860
它只是--它可以同时处于任何一种特定的状态 
It's just a-- it can be in any one particular state at one time,

1464
01:16:40,860 --> 01:16:45,270
而这些转变让你可以在你的状态之间切换 
and the transitions are what allow you to go in between your states.

1465
01:16:45,270 --> 01:16:49,150
而且每个状态都有进出其他状态的转换 
And each state does have transitions in and out of other states.

1466
01:16:49,150 --> 01:16:51,830
我们将在Pong 9中使用这一点 
And we're going to use this in Pong 9.

1467
01:16:51,830 --> 01:16:54,870
所以除了说明比分之外 我们还将
So beyond illustrating the score, we're going

1468
01:16:54,870 --> 01:16:59,370
开始跟踪的不仅仅是开始和播放状态 
to start keeping track of more than just the start and the play state.

1469
01:16:59,370 --> 01:17:02,560
我们实际上要开始对发球状态进行建模 
We're actually going to start modeling the serve state.

1470
01:17:02,560 --> 01:17:05,018
所以让我继续说明这是什么样子的 
And so let me go ahead and illustrate what this looks like.

1471
01:17:08,370 --> 01:17:12,630
因此 如果我们在这里 我只需按Enter键 
So if we're here, I just pressed Enter.

1472
01:17:12,630 --> 01:17:16,140
我们像往常一样从开始状态开始 但我按了Enter
We started at the start state as normal, but I pressed Enter

1473
01:17:16,140 --> 01:17:18,180
现在它写着一号玩家发球 
and now it says player one serve.

1474
01:17:18,180 --> 01:17:19,970
所以我们实际上是在提供服务 
So we're actually serving.

1475
01:17:19,970 --> 01:17:22,530
因此 如果我按照它的指示再次按Enter键 
And so if I press Enter again as it instructs me,

1476
01:17:22,530 --> 01:17:25,290
一号球员在左边 球应该移到右边 
player one is on the left, the ball should move to the right.

1477
01:17:25,290 --> 01:17:27,640
事实的确如此 
Which it does.

1478
01:17:27,640 --> 01:17:33,010
因此 作为二号玩家 我将继续努力 故意输掉比赛 
So I'm going to go ahead and lose on purpose as player two.

1479
01:17:33,010 --> 01:17:34,590
现在轮到二号选手发球了 
And now it's player two's serve.

1480
01:17:34,590 --> 01:17:38,370
因此 无论哪个角色 无论哪个球员输了 都应该再次发球 
So whichever character, whichever player loses should get to serve again.

1481
01:17:38,370 --> 01:17:40,560
现在如果我按Enter键 请注意当我们
And so now if I press Enter, note when we

1482
01:17:40,560 --> 01:17:42,960
如果是一号球员 球就会向右移动 
were player one, the ball moved to the right.

1483
01:17:42,960 --> 01:17:46,000
因此 对于第二名球员来说 球向左移动 
So for player two, the ball moves to the left.

1484
01:17:46,000 --> 01:17:49,260
因此 我们现在有了更多的互动 
So we have now a little bit more interaction.

1485
01:17:49,260 --> 01:17:51,150
我们有不同的州 
We have different states.

1486
01:17:51,150 --> 01:17:53,940
我们开始比赛 然后发球 我们打球 
We start off the game, and then we serve, and we play.

1487
01:17:53,940 --> 01:17:57,140
所以当舞会直播的时候 当我们真的在做这个的时候 
So when the ball's live, when we're actually doing this,

1488
01:17:57,140 --> 01:17:58,140
我们现在处于游戏状态 
we're in the play state.

1489
01:17:58,140 --> 01:17:59,800
现在我们处于服务状态 
Now we're in the serve state.

1490
01:17:59,800 --> 01:18:03,720
那么在这两个--
So what's the transition between the--

1491
01:18:03,720 --> 01:18:07,400
某种打球状态和发球状态？
sort of the play state and the serve state?

1492
01:18:07,400 --> 01:18:08,804
那里的过渡是什么？
What's the transition there?

1493
01:18:12,550 --> 01:18:13,950
我们得了一分 
We score a point.

1494
01:18:13,950 --> 01:18:17,800
因此 如果我们查看我们的状态图 并且我们处于播放状态 
So if we are looking at our state diagram and we're in the play state,

1495
01:18:17,800 --> 01:18:23,284
转换到发球状态是x玩家得了一分 
the transition to the serve state is x player scores a point.

1496
01:18:23,284 --> 01:18:25,450
然后 如果我们处于服务状态 转换
And then if we're in the serve state, the transition

1497
01:18:25,450 --> 01:18:29,180
有人按了Enter键 
is someone presses enter.

1498
01:18:29,180 --> 01:18:30,200
按下Enter键 
Enter key gets pressed.

1499
01:18:30,200 --> 01:18:33,110
这就是我们想要如何看待我们的游戏
And so that's how we want to think about our games

1500
01:18:33,110 --> 01:18:37,820
如果我们有一系列不同的逻辑 
if we have a bunch of different sets of, sort of logic,

1501
01:18:37,820 --> 01:18:42,500
我们可以从我们的游戏中拿出来 从概念上思考 
that we can sort of take out of our game and think about conceptually,

1502
01:18:42,500 --> 01:18:46,190
它允许我们将游戏分解成一系列不同的模式和状态 
it allows us to break our game up into a bunch of different modes and states,

1503
01:18:46,190 --> 01:18:49,370
而不是真的被所有这些变数负担过重
and not really get overburdened by all these variables

1504
01:18:49,370 --> 01:18:51,860
可能需要跟踪--或者我们处于什么状态？
that maybe need to keep track of-- or what state are we in?

1505
01:18:51,860 --> 01:18:53,090
比如 所有这些变量都在做什么？
Like what are all these variables doing?

1506
01:18:53,090 --> 01:18:55,460
我们将看看如何在更多的时间里解决这个问题
And we'll see how we can break this out in a more

1507
01:18:55,460 --> 01:18:57,469
未来几周的模块化时尚 
modular fashion in future weeks.

1508
01:18:57,469 --> 01:18:59,510
请注意 现在 目前我们所做的是
Note that right now, currently all we're doing is

1509
01:18:59,510 --> 01:19:04,010
我们在这里将状态变量设置为某个字符串 
we're setting a state variable to some string here,

1510
01:19:04,010 --> 01:19:05,990
只要有条件就可以了 
and just doing if conditions on it, which

1511
01:19:05,990 --> 01:19:08,960
对于小的例子来说 效果非常好 
works fantastically for small examples.

1512
01:19:08,960 --> 01:19:14,660
所以 如果 比如说 如果我们处于更新功能和游戏状态--
So if, like, for example, if we're in the update function and game state--

1513
01:19:14,660 --> 01:19:17,750
看 在这里我们说的是 如果游戏状态设置为服务 
see, over here we're saying if the game state is set to serve,

1514
01:19:17,750 --> 01:19:24,430
然后我们对所有变量进行初始化 
then we're initializing all of the variables.

1515
01:19:24,430 --> 01:19:27,650
如果游戏状态是PLAY 那么我们需要
And if the game state is play, then we need

1516
01:19:27,650 --> 01:19:31,200
在这里实际执行我们的逻辑 
to actually perform our logic here.

1517
01:19:31,200 --> 01:19:34,040
所以如果--如果我们在玩这个游戏 这将被称为 
So if the-- if we're in play, this is going to get called,

1518
01:19:34,040 --> 01:19:36,980
每一帧 我们要说 如果球与一号球员相撞 
each frame, and we're going to say, if ball collides with player one,

1519
01:19:36,980 --> 01:19:37,730
做所有这些事情 
do all this stuff.

1520
01:19:37,730 --> 01:19:42,560
然后 这让我们可以在某种程度上考虑我们的游戏 
And then this allows us to sort of think of our game.

1521
01:19:42,560 --> 01:19:46,160
这几乎就像在我们的更新函数中拥有单独的更新函数 
It's almost like having separate update functions within our update function.

1522
01:19:46,160 --> 01:19:49,220
我们将实际了解如何从一次更新中删除这些内容
And we'll actually see how we can take these out of one update

1523
01:19:49,220 --> 01:19:53,310
在未来几周使用实际的状态机类
function in future weeks with a actual state machine class

1524
01:19:53,310 --> 01:19:56,090
把事情实现得更抽象一点 
and implement things a little bit more abstractly.

1525
01:19:56,090 --> 01:20:01,260
但我要说的是 现在 无论何时我们想要 例如 
But suffice to say, now, whenever we want to like, for example,

1526
01:20:01,260 --> 01:20:04,280
做一个过渡 如果有人在这里得分 
make a transition, if someone scores here,

1527
01:20:04,280 --> 01:20:06,760
例如 如果我们要转到屏幕的左侧 
like if we're going to the left side of the screen,

1528
01:20:06,760 --> 01:20:09,320
它的球x小于零 
it's ball x is less than zero.

1529
01:20:09,320 --> 01:20:12,350
我们所要做的就是将这个状态设置为
All we have to do is just set this state to serve

1530
01:20:12,350 --> 01:20:16,040
然后 我们的更新功能将进行适当的更新 
and our update function is then going to update appropriately.

1531
01:20:16,040 --> 01:20:20,150
所以有什么关于状态机或国家的问题吗
So any questions on how sort of state machines or the state

1532
01:20:20,150 --> 01:20:23,196
在乒乓球的背景下工作？
works here in the context of Pong?

1533
01:20:23,196 --> 01:20:23,696
是 
Yes.

1534
01:20:23,696 --> 01:20:29,600
听众：所以状态机就是与国家的关系
AUDIENCE: So the state machine is the relationship to the state

1535
01:20:29,600 --> 01:20:34,520
抑或是国家的容器？
or is the container of the states?

1536
01:20:34,520 --> 01:20:37,550
科尔顿·奥格登：国家机器是一种--
COLTON OGDEN: The state machine is sort of a--

1537
01:20:37,550 --> 01:20:40,580
总体概念性地查看您的不同状态
the overall conceptual look at what your different states

1538
01:20:40,580 --> 01:20:42,680
是和他们的转变 是的 
are and their transitions, yes.

1539
01:20:42,680 --> 01:20:45,560
在接下来的几周里 我们不会实施状态机
And in future weeks we're not implementing a state machine

1540
01:20:45,560 --> 01:20:47,150
对象或类 
object or a class here.

1541
01:20:47,150 --> 01:20:50,120
但在接下来的几周里 我们将看到状态机类
But in future weeks, we will see the state machine class

1542
01:20:50,120 --> 01:20:53,240
管理不同状态之间的转换 
that manages transitions between different states in a more

1543
01:20:53,240 --> 01:20:54,910
模块化和干净的时尚 
modular and clean fashion.

1544
01:20:54,910 --> 01:20:57,140
我们在这里所做的就是我们的状态机
All we're doing here is our state machine

1545
01:20:57,140 --> 01:21:01,050
就是if语句 如果状态等于this 那么就这样做 
is just if statements and saying if the state is equal to this, then do this.

1546
01:21:01,050 --> 01:21:03,716
然后将状态更改为某个值 
And then change the state to some value.

1547
01:21:03,716 --> 01:21:05,911
观众：所以状态机是一个概念？
AUDIENCE: So the state machine is a concept?

1548
01:21:05,911 --> 01:21:07,160
科尔顿·奥格登：这是一个概念 
COLTON OGDEN: It is a concept.

1549
01:21:07,160 --> 01:21:07,940
是啊
Yeah.

1550
01:21:07,940 --> 01:21:13,880
但是下周我们将看到状态机作为一个对象的实现 
But we will see an implementation of a state machine as an object next week.

1551
01:21:13,880 --> 01:21:17,010
还有问题吗
Any more questions?

1552
01:21:17,010 --> 01:21:17,746
好的.
OK.

1553
01:21:17,746 --> 01:21:19,730
酷了
Cool.

1554
01:21:19,730 --> 01:21:22,850
目前 我们有得分 
So currently we have scoring.

1555
01:21:22,850 --> 01:21:26,180
正如我们看到的 参与人1和参与人2的得分
As we saw, the player one score and player two score are getting

1556
01:21:26,180 --> 01:21:28,820
现在递增 因此呈现在屏幕上
incremented now and, therefore, getting rendered to the screen

1557
01:21:28,820 --> 01:21:31,940
无论我们走到左边还是右边
whenever we go to the left or the right edge.

1558
01:21:31,940 --> 01:21:33,840
所以我们在记录分数 
So we're keeping track of score.

1559
01:21:33,840 --> 01:21:38,183
但是我们现在需要什么才能让某人赢呢？
But what do we need now in order for someone to win?

1560
01:21:38,183 --> 01:21:39,937
观众：[听不见] 
AUDIENCE: [INAUDIBLE].

1561
01:21:39,937 --> 01:21:40,770
科尔顿·奥格登：什么？
COLTON OGDEN: Sorry?

1562
01:21:40,770 --> 01:21:42,021
观众：[听不见] 
AUDIENCE: [INAUDIBLE].

1563
01:21:42,021 --> 01:21:43,820
科尔顿·奥格登：是的 
COLTON OGDEN: Yes it does.

1564
01:21:43,820 --> 01:21:44,630
没错
Exactly.

1565
01:21:44,630 --> 01:21:46,827
所以其实很简单 
So it's actually quite simple.

1566
01:21:46,827 --> 01:21:49,160
我们真正需要做的就是一个if语句 对吗？
All we need to really do is just an if statement, right?

1567
01:21:49,160 --> 01:21:54,260
如果某个人的得分等于某个值 10 那么某个玩家赢了 
If someone's score is equal to some value, 10, then some player has won.

1568
01:21:54,260 --> 01:22:00,290
如果我们看参与人 如果你看乒乓球10 我们去主区 
So if we look at player-- if you look at Pong 10, we go to main,

1569
01:22:00,290 --> 01:22:14,080
然后转到这里 第174行 还有第160行 
and go to here, line 174, and also line 160,

1570
01:22:14,080 --> 01:22:19,114
我们可以看到它的字面意思是在我们的逻辑中
we can see that all it literally is is in our logic

1571
01:22:19,114 --> 01:22:21,780
之前我们只是测试球是否
from before, where we're just testing to see whether the ball is

1572
01:22:21,780 --> 01:22:23,370
超出了左边或右边的边缘 
gone beyond the left or the right edge.

1573
01:22:23,370 --> 01:22:26,120
因为这是你需要做检查的地方
Because this is effectively where you need to do your check anyway

1574
01:22:26,120 --> 01:22:28,350
看看是否有人得分 
to see whether someone scored a point.

1575
01:22:28,350 --> 01:22:31,140
所以我们所做的就是在程序的这一部分增加逻辑
So all we're doing is adding logic to that part of the program

1576
01:22:31,140 --> 01:22:34,600
在我们增加他们的分数后说 
and saying after we increment their score.

1577
01:22:34,600 --> 01:22:38,182
如果它等于10 我们就设置一个值 叫做获胜玩家.
If it's equal to 10 we're setting a value called the winning player.

1578
01:22:38,182 --> 01:22:39,390
我们把它设为2 
We're going to set it to two.

1579
01:22:39,390 --> 01:22:44,130
如果ball.x小于0 那就意味着参与人1
So if the ball.x is less than zero, then that means that player one got

1580
01:22:44,130 --> 01:22:46,960
因为球越过了屏幕的左边 
scored on because it went pass the left edge of the screen.

1581
01:22:46,960 --> 01:22:50,640
因此 参与人2的得分应该上升 
Therefore, player two score should go up.

1582
01:22:50,640 --> 01:22:54,150
因此获胜的参与人也应该是 如果参与人2或者
And, therefore, the winning player should be, too, if the player two or--

1583
01:22:54,150 --> 01:22:56,430
2分等于10分 
two score is equal to 10.

1584
01:22:56,430 --> 01:23:00,180
在这种情况下 看 我们在这里 我们正在设置一个新的州完成 
And in this case, see, we're here, we're setting a new state done,

1585
01:23:00,180 --> 01:23:04,680
如果不是这样 或者如果他们的分数仍然低于10分 
and then if that's not the case, or if their score is still less than 10,

1586
01:23:04,680 --> 01:23:09,180
我们还是应该--我们应该把球放回发球位 然后重新设置球 
we should still-- we should set it back to serve, and then reset the ball.

1587
01:23:09,180 --> 01:23:13,450
所以如果我们转到我们的更新功能 这里--
And so if we go to our update function, here--

1588
01:23:13,450 --> 01:23:18,090
实际上 我们正在进行更新阶段的工作 
actually, we're doing it in our update phase.

1589
01:23:18,090 --> 01:23:22,320
因此 目前 如果它是完成状态 则球被重置
So, currently, if it's the done state, the ball gets reset

1590
01:23:22,320 --> 01:23:24,780
但在这种情况下 没有对球进行更新 
but no update is being applied to the ball in that case.

1591
01:23:24,780 --> 01:23:26,950
我们还有10分 
We still have scores 10.

1592
01:23:26,950 --> 01:23:30,090
它仍然会呈现分数 所以谁得到10分就得分
It'll still render the score, so score whoever's got 10

1593
01:23:30,090 --> 01:23:32,100
它会显示另一位选手的分数 
and it'll show the other player's score.

1594
01:23:32,100 --> 01:23:35,400
无论何时何地 实际的逻辑都适用于这里
And the actual logic that applies here, whenever

1595
01:23:35,400 --> 01:23:39,510
我们想要摆脱那种状态 就是在我们的爱情里 按键功能 
we want to break out of that state, is in our love.keypressed key function.

1596
01:23:39,510 --> 01:23:41,520
我们看到你在227线上 
We see you're on line 227.

1597
01:23:41,520 --> 01:23:46,140
如果游戏状态等于完成(我们之前将其设置为) 
If game state is equal to done, which we set it to before,

1598
01:23:46,140 --> 01:23:48,237
只有当他们按下
and this will only execute if they've pressed

1599
01:23:48,237 --> 01:23:50,070
进入或返回 所以它实际上是在等待
Enter or return, so it's effectively waiting

1600
01:23:50,070 --> 01:23:52,770
让他们按Enter或Return 
for them to press Enter or Return.

1601
01:23:52,770 --> 01:23:54,840
您想要将游戏保存设置回发球 
You want to set game save back to serve.

1602
01:23:54,840 --> 01:23:56,470
我们想要重置球 
We want to reset the ball.

1603
01:23:56,470 --> 01:23:58,540
我们希望将这些分数初始化为零 
We want to initialize those scores back to zero.

1604
01:23:58,540 --> 01:24:02,430
因此 我们正在有效地建立一个全新的游戏 
So we're setting up a brand new game, effectively.

1605
01:24:02,430 --> 01:24:06,650
如果获胜的玩家是一名 那么我们就把发球手分配给两名
If the winning player is one, then we'll give serving player to two

1606
01:24:06,650 --> 01:24:09,570
这样他们就能在下一场比赛中占据优势 
so that they have the advantage on the next game,

1607
01:24:09,570 --> 01:24:11,830
然后将其设置为1 
and then otherwise set it to one.

1608
01:24:11,830 --> 01:24:17,160
如果我们向下转到呈现函数 那么向下转到第275行 
And if we go down to our render function, so down to line 275,

1609
01:24:17,160 --> 01:24:21,789
如果我们处于完成状态 那么我们应该渲染到屏幕播放器
if we're in the done state, then we should render to the screen player

1610
01:24:21,789 --> 01:24:23,580
然后是获胜的球员 因为 记住 
and then winning player, because, remember,

1611
01:24:23,580 --> 01:24:26,230
我们把获胜的玩家设为1或2 这取决于--
we set winning player to one or two, depending on whether--

1612
01:24:26,230 --> 01:24:29,370
这取决于谁赢了 谁得了第十分 
depending on who won and who scored the tenth point.

1613
01:24:29,370 --> 01:24:35,880
我们会说一个或两个玩家赢了 然后我们会呈现出来 然后
We'll say player one or two wins, and we'll just render that and then

1614
01:24:35,880 --> 01:24:37,560
之后按Enter键重新启动 
press Enter to restart after that.

1615
01:24:37,560 --> 01:24:39,150
这就是这一点的逻辑 
And that's the logic for that.

1616
01:24:39,150 --> 01:24:41,700
我们可以在季后赛中看到这一点 
And we can see this in playoffs.

1617
01:24:41,700 --> 01:24:45,930
如果速度太慢 我们可能不需要跑完全程 
If it's too slow, we might not have to go through an entire run.

1618
01:24:45,930 --> 01:24:47,930
但我加快了.
But I sped up the--

1619
01:24:47,930 --> 01:24:50,520
哎呀--我真的想把球拿回来 
whoops-- I want to actually get the ball back.

1620
01:24:50,520 --> 01:24:53,360
我设置了速度 所以我们处于发球状态
I set up the speed so it's-- we're in the serve state,

1621
01:24:53,360 --> 01:24:57,570
我们处于比赛状态 球反弹回来了
we're in the play state, it's up-- the ball bounced back.

1622
01:24:57,570 --> 01:25:02,390
这将是一个有点乏味 但足以说 这是一个很大的回报 
It's going to be a bit tedious, but suffice to say, it's a big payoff.

1623
01:25:02,390 --> 01:25:02,890
别担心
Don't worry.

1624
01:25:06,050 --> 01:25:08,870
应该把速度调快一点
Should have set the speed a little faster.

1625
01:25:08,870 --> 01:25:09,550
快到了
Almost there.

1626
01:25:12,140 --> 01:25:14,520
气氛越来越紧张了
It's getting tense.

1627
01:25:14,520 --> 01:25:15,750
一号玩家赢了 
And player one wins.

1628
01:25:15,750 --> 01:25:19,590
所以我们--我们也把字体设置成更大的尺寸 在代码中 
So there we-- we're also setting the font to a larger size, and in the code

1629
01:25:19,590 --> 01:25:21,960
我创建了一个新的字体对象 
I create a new font object that's basically

1630
01:25:21,960 --> 01:25:26,430
在小字体和大字体之间 
between the small font and the score font, which is a large font.

1631
01:25:26,430 --> 01:25:28,590
所以是16号字体 
So 16 size font.

1632
01:25:28,590 --> 01:25:31,890
所以一号玩家赢了 这就是最终结果 
And so player one wins, and that's really all it boils down to.

1633
01:25:31,890 --> 01:25:35,910
我只是在跟踪你的计数器 确保当你这样做 
Just keeping track of your counter and just making sure that when you do

1634
01:25:35,910 --> 01:25:39,390
在你的逻辑中点击10来检测屏幕冲突 
hit 10 in your logic for detecting the screen collisions,

1635
01:25:39,390 --> 01:25:41,094
你设置的状态 
that you set the state to done.

1636
01:25:41,094 --> 01:25:44,010
如果状态为done 则只需要监视键盘输入
And if the state is done, then you just need to monitor keyboard input

1637
01:25:44,010 --> 01:25:46,830
看什么时候有人按回车键
and see whenever someone presses enter.

1638
01:25:46,830 --> 01:25:48,740
有人在我们的爱中按下回车键 
Someone press Enter in our love.keypressed,

1639
01:25:48,740 --> 01:25:50,580
它的作用是
it does the-- it has the effect of setting

1640
01:25:50,580 --> 01:25:53,742
是二号选手发球因为一号选手赢了 这样才公平.
player-- it's player two serve because player one won so that's only fair.

1641
01:25:53,742 --> 01:25:56,700
我们要按回车键发球然后我们开始一个全新的游戏 
We're going to press Enter to serve and then we begin a brand new game.

1642
01:25:56,700 --> 01:25:57,449
这很简单
And that's simple.

1643
01:25:57,449 --> 01:26:03,120
所以现在我们有了一个无限可玩的博弈 有一堆简单的状态 
So now we have an infinitely playable game with a bunch of simple states.

1644
01:26:03,120 --> 01:26:05,670
我们忽略了一个非常重要的细节 在我看来 
We're missing a very important detail, though, in my opinion,

1645
01:26:05,670 --> 01:26:06,390
这就是声音
and that's sound.

1646
01:26:06,390 --> 01:26:08,430
目前我们的游戏非常--
Currently, our game is just very--

1647
01:26:08,430 --> 01:26:10,990
这是伟大的 游戏的所有作品.
it's great, the gameplay all works.

1648
01:26:10,990 --> 01:26:13,980
一切都很好 只是缺少一点抛光 
Everything is working fine, but just missing a little polish.

1649
01:26:13,980 --> 01:26:14,970
所以我们要做的就是
And so what we're going to do is we're going

1650
01:26:14,970 --> 01:26:17,429
开始在游戏中加入音频 在我看来 
to start adding audio to the game, which is, in my opinion,

1651
01:26:17,429 --> 01:26:20,011
其中一个更有趣的事情是 
one of the more fun things to add because it also means you're

1652
01:26:20,011 --> 01:26:21,390
接近你的项目结束 
close to the end of your project.

1653
01:26:21,390 --> 01:26:25,150
Love.audio.newsource是一个我们要在这里看的函数 
Love.audio.newsource is a function we're going to look at here.

1654
01:26:25,150 --> 01:26:29,930
所有这一切都要做的是采取一个路径 然后可选的类型 
All this is going to do is take a path and then optionally a type.

1655
01:26:29,930 --> 01:26:31,980
这个路径是指向一个声音文件的
And this path is going to be to a sound file,

1656
01:26:31,980 --> 01:26:35,430
它将创建一个音频对象 你可以回放
and it's going to create an audio object that you can play back

1657
01:26:35,430 --> 01:26:37,590
在您的应用程序中的任何位置 
at any point in your application.

1658
01:26:37,590 --> 01:26:41,860
所以我们要有效地做的就是每当碰撞发生时 
So what we're going to effectively do is just whenever a collision happens,

1659
01:26:41,860 --> 01:26:46,020
根据碰撞的类型 我们只播放特定的声音 
depending on what type of collision it is, we'll just play a particular sound.

1660
01:26:46,020 --> 01:26:49,300
还有一个我真的很喜欢用来做这一切的程序
And a program that I really like to use for all of this,

1661
01:26:49,300 --> 01:26:51,660
我--我鼓励你们下载
and I-- what I encourage you guys to download

1662
01:26:51,660 --> 01:26:54,570
如果你想开始为你的项目修改你自己的声音 
if you want to start tinkering with your own sounds for your project,

1663
01:26:54,570 --> 01:26:57,300
是一个名为bfxr的程序 
is a program called bfxr.

1664
01:26:57,300 --> 01:26:58,885
它在Windows和Mac上是免费的 
It's free on Windows and Mac.

1665
01:26:58,885 --> 01:27:00,510
我不确定他们是否有Linux接口 
I'm not sure if they have a Linux port.

1666
01:27:00,510 --> 01:27:05,160
他们可能有一个类似程序的Linux移植 名为sfxr
They might have a Linux port of a similar program called sfxr

1667
01:27:05,160 --> 01:27:07,219
这就是这件事的基础 
which is what this is based off of.

1668
01:27:07,219 --> 01:27:10,260
但这样做只会产生一串随机的声音 
But what this allows you to do is just generate a bunch of random sounds.

1669
01:27:10,260 --> 01:27:13,770
我很快就可以为你们说明这一点 
And I can illustrate that shortly for you.

1670
01:27:13,770 --> 01:27:16,740
如果你想获取它 它在bfxr.net上 
If you would like to grab it, it's on bfxr.net.

1671
01:27:16,740 --> 01:27:19,310
这是一个超级快速的下载 而且--
It's a super quick download and--

1672
01:27:19,310 --> 01:27:26,890
在这里 我将实际--我将演示它 这样我们就可以看到它是如何进行的 
here, I'll actually-- I'll demonstrate it just so we can see how it plays out.

1673
01:27:26,890 --> 01:27:28,950
这就是界面 
So this is the interface.

1674
01:27:28,950 --> 01:27:30,510
确保我有一些音频 
Make sure I have some audio.

1675
01:27:30,510 --> 01:27:34,050
然后这里有很多不同的预置 
And then there is a lot of different presets here.

1676
01:27:34,050 --> 01:27:37,170
因此 有拾取斜线硬币 激光斜线射击 
So there's pickup slash coin, laser slash shoot.

1677
01:27:37,170 --> 01:27:39,750
它是为像这样的小游戏而设计的 
It's meant for sort of like small games like this,

1678
01:27:39,750 --> 01:27:45,229
比如在运行中实现原型音频类型的东西 
like implementing on the fly prototype audio type stuff.

1679
01:27:45,229 --> 01:27:46,770
但你可以看到 它只是实现了--
But you can see, it just implements--

1680
01:27:46,770 --> 01:27:49,140
我把音量调小一点 有点吵 
I'll turn that down, it's a little loud.

1681
01:27:49,140 --> 01:27:50,697
它--例如 我们有加电装置 
It-- we have power-ups, for example.

1682
01:27:50,697 --> 01:27:53,780
所以每次我点击它 它都会给我们带来随机的启动 
So every time I click on this, it's going to give us a random power-up so.

1683
01:27:53,780 --> 01:27:55,704
[电脑音效]
[COMPUTER SOUND EFFECTS]

1684
01:28:00,520 --> 01:28:05,340
然后随机化 你会得到各种各样奇怪的讨厌的东西 
And then randomized, you get all sorts of weird nasty stuff.

1685
01:28:05,340 --> 01:28:08,740
然后--我们将使用的内容是blip斜杠选择 
And then-- the stuff that we'll use is blip slash select.

1686
01:28:08,740 --> 01:28:13,060
我们In中的大多数东西都像界面和Pong You这样的游戏
Most of the things in our in like interfaces and games like Pong you

1687
01:28:13,060 --> 01:28:17,120
只是想要这样简单的声音 
just want simple sounds like this.

1688
01:28:17,120 --> 01:28:20,620
所以我已经完成了产生几个声音的工作
So I've already done the work of generating a few sounds

1689
01:28:20,620 --> 01:28:23,770
我觉得很合适 
that I thought fit pretty well.

1690
01:28:23,770 --> 01:28:28,785
接下来我会先给你看《乒乓球11》的代码 
I'll go ahead and show you the code first in Pong 11.

1691
01:28:28,785 --> 01:28:31,660
如果我们去--如果你会看到--如果你看一下目录结构 
If we go to-- if you'll see-- if you look at the directory structure,

1692
01:28:31,660 --> 01:28:33,220
您会看到我们有一个声音文件夹 
you'll see we have a sounds folder.

1693
01:28:33,220 --> 01:28:36,730
在声音文件夹中 我创建了三种声音 Ppale Hit 
In the sounds folder, I've created three sounds, paddle hit, which

1694
01:28:36,730 --> 01:28:39,160
是球拍击球的任何时候 
is anytime the paddle hits the ball.

1695
01:28:39,160 --> 01:28:41,740
得分 这是当任何时候--任何时候球
Score, which is when any-- anytime the ball

1696
01:28:41,740 --> 01:28:45,190
越过屏幕的左边界或右边界 
goes past the left or the right boundary of the screen.

1697
01:28:45,190 --> 01:28:47,680
然后撞墙 所以任何时候球触地
And then wall hit, so any time the ball touches

1698
01:28:47,680 --> 01:28:49,600
屏幕的顶部或底部 
the top or the bottom of the screen.

1699
01:28:49,600 --> 01:28:52,580
因此 这其中的逻辑非常简单 
And so the logic of this is extremely simple.

1700
01:28:52,580 --> 01:28:54,531
我们所需要做的就是--
All we need to do is whenever--

1701
01:28:54,531 --> 01:28:56,905
我们已经实施了 所以我们需要做的就是--
we already have it implemented, so all we need to do is--

1702
01:29:01,570 --> 01:29:07,002
哦 首先 我要说的是 这是一张桌子的很好的插图 
oh, first thing, I should say, and this is a good illustration of a table.

1703
01:29:07,002 --> 01:29:09,210
在未来 我们将开始更多地看到这种情况 
And we'll start to see this a lot more in the future.

1704
01:29:09,210 --> 01:29:11,950
我们在这堂课中并没有太多地使用桌子 
We didn't really use tables much in this lecture,

1705
01:29:11,950 --> 01:29:16,390
但表是Lua的一种BE ALL END ALL的数据结构 
but the table is Lua's like sort of be all, end all, data structure.

1706
01:29:16,390 --> 01:29:19,810
它是字典--Python字典 JavaScript对象 
It's the dictionary-- Python dictionary, JavaScript object.

1707
01:29:19,810 --> 01:29:23,020
它是一个数组 它是您所需的一切
It's an array, it's everything that you need for anything

1708
01:29:23,020 --> 01:29:24,830
超越Lua中的简单变量 
beyond simple variables in Lua.

1709
01:29:24,830 --> 01:29:28,360
它是一切事物的基础 甚至像其他库中的类一样 
It's what everything, even like classes in other libraries are made out of.

1710
01:29:28,360 --> 01:29:32,140
在本例中 我们只是在初始化一个名为Sound的表 
In this case, we're just initializing a table here called sounds,

1711
01:29:32,140 --> 01:29:35,410
我们传递了三个键 所以它可以--它可以接受键值对 
and we're passing in three keys so it takes-- it can take in key value pairs,

1712
01:29:35,410 --> 01:29:40,330
或者 您只需给它一个值列表 它就会为这些值创建索引
or you can just give it a list of values and it will create indices for them

1713
01:29:40,330 --> 01:29:42,280
含蓄地 
implicitly.

1714
01:29:42,280 --> 01:29:46,460
在这里 我们只是像您在Python或JavaScript中所做的那样传入 
Here, we're just passing in like you would do in Python or JavaScript.

1715
01:29:46,460 --> 01:29:50,740
Par Hit 请注意 它确实需要按顺序排列这些方括号
Paddle hit, and note that it does need these square brackets in order

1716
01:29:50,740 --> 01:29:55,870
来初始化表中的键值对--格式如下 
to initialize key value pairs in a table like-- in this format here.

1717
01:29:55,870 --> 01:29:58,740
Paddle Hit得到了Love 
Paddle hit gets love.audio.newsource.

1718
01:29:58,740 --> 01:30:00,490
在这种情况下 它只需要一条路径 
And in this case, it just takes in a path,

1719
01:30:00,490 --> 01:30:02,930
于是响起了斜桨头点波的声音 
so sounds slash paddle head dot wave.

1720
01:30:02,930 --> 01:30:05,530
我们给它的关键字--或字符串静态 
And we're giving it the key word-- or the string static,

1721
01:30:05,530 --> 01:30:08,690
这就是它的资产类型--
which is the type of asset it is--

1722
01:30:08,690 --> 01:30:09,610
它被存储为 
it's stored as.

1723
01:30:09,610 --> 01:30:12,734
因此 您既可以拥有静态音频资产 也可以拥有流音频资产 
So you can have either static or stream audio assets.

1724
01:30:12,734 --> 01:30:14,650
因此 如果它们是静态的 它们会加载到内存中
So if they're static, they're loaded in memory

1725
01:30:14,650 --> 01:30:17,191
它们被保存在内存中 用于执行您的程序 
and they're kept in memory for the execution of your program.

1726
01:30:17,191 --> 01:30:20,560
如果它们是流的 那么它们会根据需要在飞行中加载
If they're stream, then they're loaded on the fly as needed

1727
01:30:20,560 --> 01:30:21,670
被你的游戏引擎 
by your game engine.

1728
01:30:21,670 --> 01:30:24,100
和流媒体音频资源 如果您
And streamed audio assets can be helpful if you

1729
01:30:24,100 --> 01:30:28,037
有一个巨大的游戏 有大量的声音和像大型音频文件一样的长时间 
have a huge game with a ton of sounds and a long like large audio files.

1730
01:30:28,037 --> 01:30:30,370
你不一定想要把所有这些都保存在记忆中 
You don't want to keep all those in memory, necessarily,

1731
01:30:30,370 --> 01:30:33,670
因为这可能会占用很多、很多、很多兆或演出的音频 
because that could take up many, many, many megs or gigs of audio.

1732
01:30:33,670 --> 01:30:36,882
如果你是在运行中加载资产 
And if you're sort of loading assets on the fly,

1733
01:30:36,882 --> 01:30:38,590
如果你的游戏中有动态加载 
if you have dynamic loading in your game,

1734
01:30:38,590 --> 01:30:41,320
那么这也是你应该考虑的另一件事 
then that's another thing you should take into consideration.

1735
01:30:41,320 --> 01:30:43,810
在这种情况下 这些是非常小的声音文件 
In this case, these are very tiny sound files,

1736
01:30:43,810 --> 01:30:46,409
因为它们就像--就像几分之一秒长 
because they're like-- like a fraction of a second long.

1737
01:30:46,409 --> 01:30:49,450
所以我们只是将它们都设置为静态 这样它们就可以保存在内存中 
So we're just setting them all to static so they get preserved in memory,

1738
01:30:49,450 --> 01:30:52,160
我们只是把他们三个都加载到这张桌子上 
and we're just loading all three of them into this table.

1739
01:30:52,160 --> 01:30:56,530
如果我们稍后想要提到这些 我们所需要做的就是听起来--
And if we want to refer to these later on, all we need to do is sounds--

1740
01:30:56,530 --> 01:31:01,510
我们可以参考声音 PaddleHit 像这样 
we can either reference sounds.paddlehit, like that,

1741
01:31:01,510 --> 01:31:02,500
如果我们想的话 
if we wanted to.

1742
01:31:02,500 --> 01:31:08,050
因为默认情况下 Lua只给您一个点关键字 类似于JavaScript
Because by default, Lua just gives you a dot keyword, sort of the way JavaScript

1743
01:31:08,050 --> 01:31:11,830
它的对象是否与您传入的键同名 
does its objects, with the same name as the key that you passed in,

1744
01:31:11,830 --> 01:31:18,550
或者你可以用毕德式的方式来做 那就是 没有圆点 对不起--
or you can do it the Pythonic way, which is, without the dot, sorry--

1745
01:31:18,550 --> 01:31:23,060
只有方括号 现在有相同的- 这两个是等价的 
with just square brackets and now have the same of-- those two are equivalent.

1746
01:31:23,060 --> 01:31:27,280
不过 如果你决定在钥匙上留个空格 那就没用了 
It won't work, though, if you decided to put a space in your key,

1747
01:31:27,280 --> 01:31:30,640
它会的 我相信 它会--
it will, I believe, it will--

1748
01:31:30,640 --> 01:31:33,600
根本不会起作用 但它可能会注入下划线 
just won't work at all, but it may inject an underscore.

1749
01:31:33,600 --> 01:31:35,870
我得先测试一下 然后找出答案 
I'll have to test it out and find out.

1750
01:31:35,870 --> 01:31:40,330
但是 通常情况下 使用点并不是最佳实践
But, generally, it's not best practice to use dot

1751
01:31:40,330 --> 01:31:43,450
不管怎么说 你已经把钥匙排成一排了 
when you already have the keys lined up like this, anyway.

1752
01:31:43,450 --> 01:31:45,970
以及您可以使用您所使用的字符串
And what you can do with strings that you

1753
01:31:45,970 --> 01:31:49,600
不能使用点号表示法处理点号 
can't do with dot using the dot notation,

1754
01:31:49,600 --> 01:31:53,530
就是与您一起动态生成表的查找--
is dynamically generate a lookup of your table with you--

1755
01:31:53,530 --> 01:31:56,170
你可以用弦来做这件事 你--是的 
which you can do with strings, which you-- yeah,

1756
01:31:56,170 --> 01:32:00,460
因为在四循环中你不能在桌子上做四件事 
because you can't in a four loop do four something in table,

1757
01:32:00,460 --> 01:32:02,620
然后桌子上点了点东西 那是行不通的 
and then table dot something, that just won't work.

1758
01:32:02,620 --> 01:32:06,310
但你可以为你桌子上的每一件事做
But you can do for everything in your table

1759
01:32:06,310 --> 01:32:12,626
然后在您的表中查找键作为该值 该迭代值 
and then look up the key as that value, that iterated value in your table.

1760
01:32:12,626 --> 01:32:14,921
我们将在以后的课程中看到这方面的例子 
We'll see examples of that in future lectures.

1761
01:32:14,921 --> 01:32:16,670
但这只是一件需要牢记的事情 
But that's just something to keep in mind.

1762
01:32:16,670 --> 01:32:19,210
所以我们在这里有一张桌子 一张声音桌子 
So we have our table here, a sounds table.

1763
01:32:19,210 --> 01:32:22,490
哦 还有--我们的声音已经准备好了 它们加载在内存中 
Oh, and-- and we have our sounds ready, they're loaded in memory.

1764
01:32:22,490 --> 01:32:24,550
我们现在要做的就是
All we need to do now is wherever we have

1765
01:32:24,550 --> 01:32:28,370
任何事情 比如我们代码中的任何冲突 我们都会这样做 
anything that, like any collision in our code, we just do this.

1766
01:32:28,370 --> 01:32:30,970
就像桌子一样简单 
It's as simple as the table.

1767
01:32:30,970 --> 01:32:33,590
在我们想要的键上 冒号 这是Lua的
At the key that we want, colon, which is Lua's

1768
01:32:33,590 --> 01:32:38,560
调用类或表的函数的方式 
way of calling a function of a class or a table.

1769
01:32:38,560 --> 01:32:43,840
冒号播放 播放功能是新源音频的一部分
Colon play, and the play function is part of the new source audio

1770
01:32:43,840 --> 01:32:46,512
我们在桌子上创造的恋爱中的对象 
object in LOVE that we created in the table,

1771
01:32:46,512 --> 01:32:48,970
而这只会产生只播放一次的效果 
and that will just have the effect of just playing it once.

1772
01:32:48,970 --> 01:32:50,380
您可以将其设置为循环 
You can set it to looping.

1773
01:32:50,380 --> 01:32:54,662
您可以说出划桨的声音 将循环设置为真 
You can say the sounds paddle hit, set looping to true,

1774
01:32:54,662 --> 01:32:56,870
它会无限地一遍又一遍地播放 
and it will just infinitely play over and over again,

1775
01:32:56,870 --> 01:32:58,210
我们可不想听到这样的声音 
which we wouldn't want for a sound like this.

1776
01:32:58,210 --> 01:32:59,251
这听起来会令人讨厌 
It would sound obnoxious.

1777
01:32:59,251 --> 01:33:01,226
但如果你有一首音乐曲目 例如 
But if you have a music track, for example,

1778
01:33:01,226 --> 01:33:03,100
在某种程度上 或者类似的东西 你会
in a level, or something like that, you would

1779
01:33:03,100 --> 01:33:06,790
希望设置循环为真 这样当它最终结束时 
want set looping to be true so that when it finally ends,

1780
01:33:06,790 --> 01:33:11,500
你的用户不仅仅是在默默地玩游戏 
your user isn't just playing a game in silence.

1781
01:33:11,500 --> 01:33:14,810
所以我们用拍子击打 我们也用击墙 
So we're doing it with paddle hit, we're doing it with wall hit as well.

1782
01:33:14,810 --> 01:33:19,300
所以我给它们起了适当的名字 这样就很容易推断出它们的位置
So I've named them appropriately so that it's easy to infer where

1783
01:33:19,300 --> 01:33:21,730
以及声音文件被用于什么目的 
and for what purpose the sound files are used.

1784
01:33:21,730 --> 01:33:24,650
所以 当他们在上界或下界时 就玩围墙
So whenever they're at the upper or lower boundaries, play the wall

1785
01:33:24,650 --> 01:33:29,560
击打声音 然后每当球到达时
hit sound, and then whenever the ball reaches

1786
01:33:29,560 --> 01:33:31,450
屏幕的左边缘或右边缘 
the left or the right edge of the screen,

1787
01:33:31,450 --> 01:33:34,250
只要播放乐谱音效就行了 
just play the score sound effect.

1788
01:33:34,250 --> 01:33:39,490
所以如果我们玩我们的游戏 这一直是我最喜欢的部分之一
And so if we play our game, and this is always one of my more favorite parts

1789
01:33:39,490 --> 01:33:43,150
正在用音频玩游戏 因为它只会让
is playing the game with audio because it just makes

1790
01:33:43,150 --> 01:33:45,640
在我看来 这是一个很大的差异 
such a difference, in my opinion.

1791
01:33:45,640 --> 01:33:47,755
我们可以得到音效 
We get sound effects.

1792
01:33:47,755 --> 01:33:52,510
这是一件小事 而且很容易 但它增加了--它增加了很多味道 
It's a little thing, and it's very easy, but it adds-- it adds so much flavor.

1793
01:33:52,510 --> 01:33:54,520
然后(爆炸) 我们就开始了 
And then (explosion), and there we go.

1794
01:33:54,520 --> 01:33:58,060
然后我们的游戏实际上在这一点上实现了 
And then our game is practically implemented at this point.

1795
01:33:58,060 --> 01:33:59,890
再举一个例子 我会
There's just one more example that I would

1796
01:33:59,890 --> 01:34:02,681
我想给大家看一个小例子 因为所有的例子
like to show you guys, a small example, because all of the examples

1797
01:34:02,681 --> 01:34:08,020
到目前为止 RESIZE等于--SIZIZE等于FALSE 
thus far have had the resize equal-- resizable equals false.

1798
01:34:08,020 --> 01:34:11,870
在推送设置屏幕初始化器中输入某种键 
Sort of key in the push setup screen initializer,

1799
01:34:11,870 --> 01:34:15,700
如果你想玩一个可以调整窗口大小的游戏 
and in case you want to have a game where you can resize your window,

1800
01:34:15,700 --> 01:34:18,310
我们所需要做的就是调用一个名为love.resize的函数 
all we need to do is call a function called love.resize,

1801
01:34:18,310 --> 01:34:20,370
它需要一个宽度和一个高度 
which takes a width and a height.

1802
01:34:20,370 --> 01:34:23,140
而我们最终要做的是 
And what we're going to end up doing with that,

1803
01:34:23,140 --> 01:34:25,960
具体地说 对于我们的用例 因为我们使用推送 
specifically, for our use case, because we're using push,

1804
01:34:25,960 --> 01:34:30,730
我们要去乒乓球12号 
we're going to go to Pong 12.

1805
01:34:30,730 --> 01:34:40,170
如果我们进入主星 我们在85号线上看到 
And then if we go to main.lua we see here on line 85,

1806
01:34:40,170 --> 01:34:43,852
我现在已将可调整大小更改为等于True 因此它实际上
I've changed resizable to equal true now so that it will actually

1807
01:34:43,852 --> 01:34:45,310
允许我们调整应用程序的大小 
allow us to resize the application.

1808
01:34:45,310 --> 01:34:47,684
如果为假 则您甚至无法单击和拖动
If that's false, you won't even be able to click and drag

1809
01:34:47,684 --> 01:34:50,500
屏幕的下角 它就是不让你这么做 
the bottom corner of the screen, it just won't let you do it.

1810
01:34:50,500 --> 01:34:56,400
然后你所要做的就是调用Love 大小宽度高度 
And then all you have to do is call love.resizewidthheight,

1811
01:34:56,400 --> 01:34:59,160
然后传入随高度调整大小的Push 
and then pass in push resize with height.

1812
01:34:59,160 --> 01:35:03,810
因为引擎盖下面的推力会获得纹理并渲染到它上 
Because push underneath the hood takes a texture and renders to it,

1813
01:35:03,810 --> 01:35:05,700
然后把它放大以填满你的窗口 
and then upscaled it to fill your window,

1814
01:35:05,700 --> 01:35:08,826
所以它需要知道你当前的窗口尺寸是多少
and so it needs to know what your current window dimensions are so

1815
01:35:08,826 --> 01:35:10,950
它可以将其升级到合适的尺寸 
that it can upscale it to fit the right dimensions.

1816
01:35:10,950 --> 01:35:12,783
Push还增加了信箱之类的东西 
And push also adds things like letterboxing,

1817
01:35:12,783 --> 01:35:16,440
如果您想要保持完全相同的纵横比 这是很方便的 
which is convenient if you want to maintain the exact same aspect ratio.

1818
01:35:16,440 --> 01:35:19,050
在游戏中 你可能会有这样的用户界面
And in a game where maybe you have the UI that's

1819
01:35:19,050 --> 01:35:21,480
受应用程序大小的驱动 此函数
driven by the size of your application, this function

1820
01:35:21,480 --> 01:35:23,646
将是重要的 因为这样你就可以调整你的--
will be important because then you can resize your--

1821
01:35:23,646 --> 01:35:27,150
您可以适当地调整UI元素的大小和位置 
you can resize and reposition your UI elements appropriately.

1822
01:35:27,150 --> 01:35:30,990
因为如果你的游戏很小 也许你想要用户界面的某些部分
Because if your game is small, maybe you want certain parts of UI

1823
01:35:30,990 --> 01:35:33,030
隐形 或在不同的地方
to be invisible, or in a different location

1824
01:35:33,030 --> 01:35:36,210
总而言之 这样你就不会占用大量的屏幕空间 
altogether, just so that you don't take up a ton of screen space,

1825
01:35:36,210 --> 01:35:39,190
并且只是为了适应您的应用程序的所有可能用户 
and just to accommodate all possible users of your application.

1826
01:35:39,190 --> 01:35:43,610
但现在的影响是--如果我们进入乒乓球12
But that has the effect now of-- if we go into Pong 12

1827
01:35:43,610 --> 01:35:48,510
然后运行它 实际上 可能甚至不能使用但是--是的 
and then run it, actually, might not even be able to use the but-- yeah,

1828
01:35:48,510 --> 01:35:51,390
我现在就可以这么做了 
I can just do this now.

1829
01:35:51,390 --> 01:35:56,100
我可以调整它的大小 它将保持虚拟的宽度和高度
I can resize it, and it'll maintain the virtual width and height

1830
01:35:56,100 --> 01:36:01,240
我们之前设置的 因为这就像是最重要的
that we set it to before, because that's like first and foremost

1831
01:36:01,240 --> 01:36:03,420
无论推什么 它都会投递信箱
what push will do and it'll letterbox no matter

1832
01:36:03,420 --> 01:36:07,391
您的应用程序的大小是什么 以确保它保持这一方面
what size your application is to make sure that it maintains that aspect

1833
01:36:07,391 --> 01:36:07,890
比率
ratio.

1834
01:36:07,890 --> 01:36:10,380
所以 如果你在垂直或水平方向上都超过了这个纵横比 
So if you're beyond that aspect ratio vertically or horizontally,

1835
01:36:10,380 --> 01:36:12,270
你会得到适当的信箱 
you'll get the appropriate letterboxing for it.

1836
01:36:12,270 --> 01:36:13,311
所以这非常方便 
So it's super convenient.

1837
01:36:13,311 --> 01:36:19,020
你不必担心你的用户会得到超级扭曲的长宽比 
You don't have to worry about your users getting super distorted aspect ratios,

1838
01:36:19,020 --> 01:36:22,380
因为他们使用了某种不可预见的解决方案 
because they are using some sort of unforeseen resolution.

1839
01:36:22,380 --> 01:36:25,110
它将永远保持它 即使它是超级微小的
That will always maintain it even if it's super tiny

1840
01:36:25,110 --> 01:36:27,080
因为他们的显示器超薄 
because their monitor is super thin.

1841
01:36:27,080 --> 01:36:29,030
它将始终保持纵横比 
It will always maintain the aspect ratio.

1842
01:36:29,030 --> 01:36:33,460
但实际上 对于Pong来说 这差不多就是这些了 
But that's pretty much it for Pong, actually.

1843
01:36:33,460 --> 01:36:37,414
我们有一场完整的比赛 从头到尾 如果你有任何问题 
We have a complete game, start to finish, and if you have any questions,

1844
01:36:37,414 --> 01:36:38,580
我很乐意回答这些问题 
I'd be happy to answer them.

1845
01:36:41,550 --> 01:36:43,350
有什么问题吗？
Any questions?

1846
01:36:43,350 --> 01:36:43,850
凉爽的 
Cool.

1847
01:36:43,850 --> 01:36:44,100
好的 
All right.

1848
01:36:44,100 --> 01:36:46,400
好吧 我很高兴能把这门课的其余部分教给你们 
Well, I'm excited to teach the rest of this course to you guys.

1849
01:36:46,400 --> 01:36:47,620
我们只是触及了皮毛 
We've only scratched the surface.

1850
01:36:47,620 --> 01:36:48,786
我们还有更多的内容要讲 
We have a lot more to cover.

1851
01:36:48,786 --> 01:36:51,900
下周 我们将真正报道Flappy Bird
Next week, we'll actually be covering Flappy Bird

1852
01:36:51,900 --> 01:36:54,710
所以我们会得到一些漂亮的彩色图形 
so we'll get some nice colorful graphics, which

1853
01:36:54,710 --> 01:36:58,620
对我们今天的黑白美学来说是截然不同的 
is a stark difference to our black and white aesthetics today.

1854
01:36:58,620 --> 01:37:00,000
但对于Pong来说 就是这样 
But that's it for Pong.

1855
01:37:00,000 --> 01:37:02,297
所以感谢你们的光临 
So thanks for coming.
