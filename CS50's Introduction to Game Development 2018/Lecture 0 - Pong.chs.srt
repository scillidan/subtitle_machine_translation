1
00:00:00,000 --> 00:00:01,964
[音乐播放]

2
00:00:16,612 --> 00:00:17,570
大卫·马兰：好的 

3
00:00:17,570 --> 00:00:20,340
欢迎来到游戏开发入门 

4
00:00:20,340 --> 00:00:22,820
我叫大卫·马兰 这位是科尔顿·奥格登 

5
00:00:22,820 --> 00:00:25,160
这是一个只假设CS50这样的类的类

6
00:00:25,160 --> 00:00:28,160
哪一所大学和推广学校是计算机导论

7
00:00:28,160 --> 00:00:30,050
科学 但更普遍的是 我们只是假设

8
00:00:30,050 --> 00:00:32,689
你以前有过几乎所有语言的编程经验

9
00:00:32,689 --> 00:00:34,100
因此对一些人有一些安慰

10
00:00:34,100 --> 00:00:35,724
编程的基本结构 

11
00:00:35,724 --> 00:00:38,875
但我们假设没有Lua或Lab 2D或任何框架的背景

12
00:00:38,875 --> 00:00:40,250
我们会在课堂上用到 

13
00:00:40,250 --> 00:00:42,230
所有这一切都在前面 

14
00:00:42,230 --> 00:00:46,087
所以 如果你和我一样 你可能是伴随着某种电子游戏长大的 

15
00:00:46,087 --> 00:00:48,920
当你开始编程时 编程环境

16
00:00:48,920 --> 00:00:52,340
可能非常基于文本、黑白终端窗口等 

17
00:00:52,340 --> 00:00:55,580
也许你用Scratch或Alice之类的语言做了一些图形化的事情

18
00:00:55,580 --> 00:00:57,890
或者更远的地方 或者如果你身处网络世界 

19
00:00:57,890 --> 00:01:01,550
您已经制作了更多的图形化应用程序 但仍然非常静态 

20
00:01:01,550 --> 00:01:04,950
内容的种类出现在屏幕上 然后内容发生变化 以此类推 

21
00:01:04,950 --> 00:01:07,866
如果你是编程新手 这就不那么明显了

22
00:01:07,866 --> 00:01:10,340
你是如何去创造一些这样的游戏的

23
00:01:10,340 --> 00:01:12,410
从你们一起长大的昨天开始 

24
00:01:12,410 --> 00:01:15,350
哪里有更多的动画 哪里就有更多的异步性 

25
00:01:15,350 --> 00:01:17,210
很多事情同时发生 

26
00:01:17,210 --> 00:01:19,700
发生了很多事情 而你们都没有--

27
00:01:19,700 --> 00:01:21,740
不仅想要捕捉这种互动性 

28
00:01:21,740 --> 00:01:23,600
但也想要对那些

29
00:01:23,600 --> 00:01:25,308
发生了 特别是如果你有球员的话

30
00:01:25,308 --> 00:01:27,110
在你旁边的其他地方或在线上 

31
00:01:27,110 --> 00:01:29,210
因此 课程的结构将是

32
00:01:29,210 --> 00:01:32,309
是通过对这些不同的游戏的叙述 其中许多

33
00:01:32,309 --> 00:01:33,600
你可能扮演了你自己 

34
00:01:33,600 --> 00:01:35,450
但在这学期的课程中 我们潜水

35
00:01:35,450 --> 00:01:37,370
深入到每一场比赛的背景下 看看

36
00:01:37,370 --> 00:01:39,980
在一些基本的原则 通过这些结构 

37
00:01:39,980 --> 00:01:42,604
它们是建立起来的 并真正地把它们作为出发点 

38
00:01:42,604 --> 00:01:45,200
谈论这些不同的能力

39
00:01:45,200 --> 00:01:47,600
你可以把它融入到你自己的游戏中 

40
00:01:47,600 --> 00:01:49,970
最后 在整个学期 

41
00:01:49,970 --> 00:01:51,320
将是一系列里程碑 

42
00:01:51,320 --> 00:01:54,560
有些是以小作业的形式 

43
00:01:54,560 --> 00:01:58,170
最近的材料 并为你的成功做好准备 

44
00:01:58,170 --> 00:02:01,110
是更深入和更多地参与项目 因为 

45
00:02:01,110 --> 00:02:04,401
该项目是你将建立或扩展一些自己的游戏 

46
00:02:04,401 --> 00:02:07,400
然后这门课本身会在学期末达到高潮

47
00:02:07,400 --> 00:02:09,900
你们自己的期末项目 一个求婚的机会

48
00:02:09,900 --> 00:02:13,040
设计并实现一个游戏 

49
00:02:13,040 --> 00:02:14,330
课程的教训 

50
00:02:14,330 --> 00:02:16,880
所以当你几个月后离开这里的时候 

51
00:02:16,880 --> 00:02:19,020
你不仅玩了很多游戏

52
00:02:19,020 --> 00:02:21,522
但实际上你自己也造了几个 

53
00:02:21,522 --> 00:02:23,480
废话少说 请允许我把事情

54
00:02:23,480 --> 00:02:27,510
去科尔顿看一看 在去年的乒乓球上漫步 

55
00:02:27,510 --> 00:02:29,050
科尔顿·奥格登：谢谢 大卫 

56
00:02:29,050 --> 00:02:31,790
我很高兴能开始教你们这门课

57
00:02:31,790 --> 00:02:34,910
因为游戏开发让我

58
00:02:34,910 --> 00:02:36,520
编程的人

59
00:02:36,520 --> 00:02:40,910
我记得2006年或2007年在这里买了这本书 

60
00:02:40,910 --> 00:02:47,110
3D Game Programming All In One 这是一个3D游戏编程的外观 

61
00:02:47,110 --> 00:02:51,110
这是一个游戏引擎中的整体文本

62
00:02:51,110 --> 00:02:54,110
在2000年代后期很流行的一种叫做扭矩的技术 

63
00:02:54,110 --> 00:02:58,310
现在不流行了 但在当时很流行 

64
00:02:58,310 --> 00:03:00,200
and it used运用a language语言called叫TorqueScript扭矩.

65
00:03:00,200 --> 00:03:02,750
我记得我读过这本书 看到了所有的代码 

66
00:03:02,750 --> 00:03:05,010
and I had never seen看到like source源code码at all before 

67
00:03:05,010 --> 00:03:07,457
或者曾经接触过编程

68
00:03:07,457 --> 00:03:09,290
坦白说 我觉得这很吓人 

69
00:03:09,290 --> 00:03:13,400
因为我看了所有我不懂的语法 

70
00:03:13,400 --> 00:03:15,650
我对游戏开发一无所知 

71
00:03:15,650 --> 00:03:19,857
我从小到大一直在玩游戏 并被它迷住了 

72
00:03:19,857 --> 00:03:22,190
但当我开始更习惯使用电脑时

73
00:03:22,190 --> 00:03:23,939
我开始对它产生了更多的好奇

74
00:03:23,939 --> 00:03:25,940
并意识到这是一个主要的职业 

75
00:03:25,940 --> 00:03:27,770
我开始往下潜得更深一些 

76
00:03:27,770 --> 00:03:29,030
这是我的第一次尝试 

77
00:03:29,030 --> 00:03:32,060
在花了一点时间离开它之后

78
00:03:32,060 --> 00:03:34,820
在查看了TorqueScrip的源代码后 它

79
00:03:34,820 --> 00:03:38,240
相当神秘 有很多百分号和美元符号

80
00:03:38,240 --> 00:03:41,720
都是我还没想清楚的奇怪的事情 

81
00:03:41,720 --> 00:03:45,830
我又回到了那里 开始真正学习编程的基础知识

82
00:03:45,830 --> 00:03:48,980
以及其他语言 如Python、c和c++ 

83
00:03:48,980 --> 00:03:53,314
我逐渐变得非常喜欢编程和计算机科学 

84
00:03:53,314 --> 00:03:55,980
这只是一张当时扭矩的图像 

85
00:03:55,980 --> 00:03:59,330
这真的是Unity现在的前身 

86
00:03:59,330 --> 00:04:02,330
虽然 在我看来 统一做事情要好得多 

87
00:04:02,330 --> 00:04:05,270
它更容易使用 它使用的语言更时髦

88
00:04:05,270 --> 00:04:08,270
并且已经在其他领域的其他人流行和使用 

89
00:04:10,489 --> 00:04:13,030
因此 我们将在课程的末尾介绍“团结” 

90
00:04:13,030 --> 00:04:15,890
因此 我们将主要介绍2D游戏开发 

91
00:04:15,890 --> 00:04:18,589
但我们今天要讲的话题

92
00:04:18,589 --> 00:04:23,087
我们在Pong的背景下开始的时候 这里有一些要点 

93
00:04:23,087 --> 00:04:25,670
Lua 这将是我们主要使用的语言

94
00:04:25,670 --> 00:04:28,010
在整个课程中 这是一种非常动态的脚本语言

95
00:04:28,010 --> 00:04:29,750
类似于Python和Java脚本 

96
00:04:29,750 --> 00:04:33,290
我们将把Love 2D作为我们的主要游戏框架 它

97
00:04:33,290 --> 00:04:39,590
是一个运行库和一个公开其所有方法的框架

98
00:04:39,590 --> 00:04:41,630
用于绘图、音频、输入等 

99
00:04:41,630 --> 00:04:45,530
通过Lua 所以很容易非常快速地编写代码 

100
00:04:45,530 --> 00:04:46,910
但取得了非常好的效果 

101
00:04:46,910 --> 00:04:50,667
在我看来 他们框架的文档是一流的 

102
00:04:50,667 --> 00:04:53,000
今天我们将讨论几个基本原则

103
00:04:53,000 --> 00:04:54,960
当我们涉足游戏开发的时候 

104
00:04:54,960 --> 00:04:57,830
比如绘制形状、绘制文本、

105
00:04:57,830 --> 00:05:00,440
这两个都是乒乓球非常大的方面 

106
00:05:00,440 --> 00:05:03,500
是一个基于形状和文本的非常简单的游戏

107
00:05:03,500 --> 00:05:05,120
在屏幕上移动 

108
00:05:05,120 --> 00:05:09,350
我们将讨论增量时间和速度 这可能是增量时间

109
00:05:09,350 --> 00:05:11,587
可以说 最重要的变量之一

110
00:05:11,587 --> 00:05:14,420
我们在任何游戏框架或引擎中都会跟踪 这只是

111
00:05:14,420 --> 00:05:17,710
自最后一帧执行以来经过的时间量

112
00:05:17,710 --> 00:05:22,454
在我们的游戏中 以2D爱情来衡量 以秒为单位 几分之一秒 

113
00:05:22,454 --> 00:05:24,370
我们将谈论游戏状态 因为你

114
00:05:24,370 --> 00:05:25,660
在你的游戏中可以有一个状态 

115
00:05:25,660 --> 00:05:29,359
你可以在标题屏幕上 你可以在玩 你可以在菜单中 

116
00:05:29,359 --> 00:05:32,650
显然 这将非常重要 因为您需要不同的更新逻辑

117
00:05:32,650 --> 00:05:35,525
以及根据您所处的状态呈现逻辑 

118
00:05:35,525 --> 00:05:37,900
我们将讨论基本的面向对象编程 

119
00:05:37,900 --> 00:05:41,080
对于那些可能不熟悉来自C 

120
00:05:41,080 --> 00:05:45,640
它基本上是一种封装我们的数据、任何游戏对象的方式 

121
00:05:45,640 --> 00:05:49,150
以这样一种方式 与它们相关的变量

122
00:05:49,150 --> 00:05:52,370
与将对该数据进行操作的函数放在一起 

123
00:05:52,370 --> 00:05:55,330
所以不是所有变量都有20个不同的变量

124
00:05:55,330 --> 00:05:58,210
您必须在代码中跟踪这些不同的对象 

125
00:05:58,210 --> 00:06:01,000
每个单独的对象可以跟踪它自己的所有信息 

126
00:06:01,000 --> 00:06:04,240
比如它的位置 或者任何其他与它相关的东西 

127
00:06:04,240 --> 00:06:07,150
今天我们将讨论热门话题 主要是 

128
00:06:07,150 --> 00:06:09,280
在盒子碰撞的情况下 因为我们将

129
00:06:09,280 --> 00:06:11,989
说的是乒乓球 它只是一个球拍和一个球 

130
00:06:11,989 --> 00:06:13,030
这些都是长方形 

131
00:06:13,030 --> 00:06:16,600
它们将与所谓的轴对齐边界相撞--

132
00:06:16,600 --> 00:06:21,820
轴对齐的边界框 这使得计算两个框是否碰撞

133
00:06:21,820 --> 00:06:25,750
非常简单 与计算旋转命中框相反 

134
00:06:25,750 --> 00:06:27,190
这就有点复杂了 

135
00:06:27,190 --> 00:06:29,439
然后 最后 我们将用音效来打磨 

136
00:06:29,439 --> 00:06:32,620
因为在我看来 添加抛光层很重要

137
00:06:32,620 --> 00:06:36,670
它将所有这些联系在一起 让它感觉像一个更有凝聚力的整体 

138
00:06:36,670 --> 00:06:40,294
所以当我们继续下去的时候 我们需要做两件重要的事情

139
00:06:40,294 --> 00:06:43,210
下面是示例 稍后我将向您展示回购的链接 

140
00:06:43,210 --> 00:06:44,590
就是安装Love 2D 

141
00:06:44,590 --> 00:06:46,190
这是一个非常简单的过程 

142
00:06:46,190 --> 00:06:48,290
这里的第一个链接只是一个下载链接 

143
00:06:48,290 --> 00:06:50,920
因此 它适用于所有主流操作系统 

144
00:06:50,920 --> 00:06:53,620
因此 Linux、Mac和Windows都是如此 

145
00:06:53,620 --> 00:06:56,190
然后点击下面的入门链接

146
00:06:56,190 --> 00:06:58,300
将给你一些关于如何开始的小贴士 

147
00:06:58,300 --> 00:07:02,080
在你的Mac iAlias上的机器上运行它 

148
00:07:02,080 --> 00:07:07,240
它附带的应用程序中的实际运行时可执行文件 

149
00:07:07,240 --> 00:07:11,470
所以在我的个人资料中 我可以很容易地输入Love space

150
00:07:11,470 --> 00:07:15,167
任何包含主Dot Lua文件的目录中的Dot 

151
00:07:15,167 --> 00:07:16,750
我可以非常简单地在任何地方运行它 

152
00:07:16,750 --> 00:07:20,050
页面上有类似的操作说明 供其他操作使用

153
00:07:20,050 --> 00:07:20,770
系统 

154
00:07:20,770 --> 00:07:23,350
这是repo 里面有所有的源代码

155
00:07:23,350 --> 00:07:24,550
我们今天要用到的 

156
00:07:24,550 --> 00:07:28,780
我把它组织成一系列13种不同的传票

157
00:07:28,780 --> 00:07:32,560
这样你就可以跟随我们的脚步 我们可以从头开始在Pong的基础上发展 

158
00:07:32,560 --> 00:07:35,326
一直走到一个完全实现的游戏 

159
00:07:35,326 --> 00:07:37,450
所以我们首先要谈的是Lua是什么 

160
00:07:37,450 --> 00:07:40,160
我们将在课程的75%时间里使用Lua 

161
00:07:40,160 --> 00:07:42,370
它是一种非常流行的动态脚本语言 

162
00:07:42,370 --> 00:07:45,040
葡萄牙语是月亮的意思 它是在90年代初发明的

163
00:07:45,040 --> 00:07:48,250
作为主要的配置语言和运行时语言

164
00:07:48,250 --> 00:07:54,130
用于编译的代码库 以节省将代码添加到这些代码库的时间

165
00:07:54,130 --> 00:07:55,720
并重新编译它们 

166
00:07:55,720 --> 00:07:58,480
更快、更容易 尤其是在

167
00:07:58,480 --> 00:08:01,960
90年代计算机速度慢得多的时候 要曝光

168
00:08:01,960 --> 00:08:07,270
将您的应用程序的核心功能添加到Lua 这样您就可以

169
00:08:07,270 --> 00:08:11,500
动态运行它 然后与您的已编译代码动态交互 

170
00:08:11,500 --> 00:08:13,960
而不是重新编译和等待几分钟 

171
00:08:13,960 --> 00:08:19,150
可能是几个小时 只是为了获得一些新的行为 

172
00:08:19,150 --> 00:08:22,690
它是一种专注于表的概念的语言 

173
00:08:22,690 --> 00:08:26,060
除了基本变量之外 Lua中几乎所有的东西都是表 

174
00:08:26,060 --> 00:08:30,230
表在本质上是一个在Python语言中的词典或一个在JavaScript中的对象 

175
00:08:30,230 --> 00:08:31,790
非常相似 

176
00:08:31,790 --> 00:08:33,890
Intent 用于在更大的应用程序中嵌入使用 

177
00:08:33,890 --> 00:08:37,150
而Lua的本质就是想要

178
00:08:37,150 --> 00:08:39,460
在这些大型应用程序的上下文中使用

179
00:08:39,460 --> 00:08:42,130
这意味着它非常适合与游戏引擎交互 

180
00:08:42,130 --> 00:08:44,800
因为游戏引擎是代码库的完美例子

181
00:08:44,800 --> 00:08:48,850
这些代码传统上是出于速度目的而编译的代码 

182
00:08:48,850 --> 00:08:52,240
但必须添加次要功能可能会非常麻烦 

183
00:08:52,240 --> 00:08:56,680
然后重新编译 可能会让整个工作室花费几个小时 

184
00:08:56,680 --> 00:09:00,910
所以我们将使用Lua和一个编译的游戏框架Love 2D 

185
00:09:00,910 --> 00:09:03,880
让我们能够快速发展 

186
00:09:03,880 --> 00:09:06,700
它类似于JavaScript和Python 

187
00:09:06,700 --> 00:09:09,010
对于JavaScript来说 情况更是如此 

188
00:09:09,010 --> 00:09:11,230
它非常出色 因为它最初是

189
00:09:11,230 --> 00:09:15,070
旨在作为一种配置语言 以及--只是一种粘合层 

190
00:09:15,070 --> 00:09:19,870
它非常适合将数据和代码存储在一起 几乎一个都在同一个位置 

191
00:09:19,870 --> 00:09:24,700
所以Love 2D是一个快速的2D游戏开发--

192
00:09:24,700 --> 00:09:25,630
开发框架 

193
00:09:25,630 --> 00:09:28,790
它是用C++编译的 运行效率非常高 

194
00:09:28,790 --> 00:09:33,312
因为它是如此简单 尽管我们在卢阿州运行它 

195
00:09:33,312 --> 00:09:35,020
基本上可以作为你所有东西的模组

196
00:09:35,020 --> 00:09:37,061
将需要在2D游戏开发的背景下 

197
00:09:37,061 --> 00:09:40,690
只有2D游戏正式开发 尽管我认识的一些人

198
00:09:40,690 --> 00:09:44,840
正在进行微小的3D实验 但还没有正式的结果 

199
00:09:44,840 --> 00:09:47,872
但它有图形 键盘输入 数学 基本上 任何东西

200
00:09:47,872 --> 00:09:50,080
您可能希望在2D游戏开发的环境中使用 

201
00:09:50,080 --> 00:09:51,050
这是完全免费的 

202
00:09:51,050 --> 00:09:51,950
它是便携的 

203
00:09:51,950 --> 00:09:54,310
你甚至可以在移动设备上运行 也可以在网络上运行 

204
00:09:54,310 --> 00:09:57,400
而且它非常适合原型制作 即使你不一定

205
00:09:57,400 --> 00:10:01,420
想要在爱情2D中发布一款游戏 它很棒 简单快捷

206
00:10:01,420 --> 00:10:03,970
在爱的2D中制造一些东西 然后搬家

207
00:10:03,970 --> 00:10:05,920
无论是哪种框架或引擎

208
00:10:05,920 --> 00:10:08,870
你可能会在现实世界中用到 

209
00:10:08,870 --> 00:10:12,222
因此 在我们开始研究一些实际的具体代码之前 

210
00:10:12,222 --> 00:10:14,680
我认为我们应该看一看最基本的事情

211
00:10:14,680 --> 00:10:16,430
是什么叫游戏循环 

212
00:10:16,430 --> 00:10:21,420
因此 从根本上说 游戏只是一个无限循环 就像一段时间真或一段时间

213
00:10:21,420 --> 00:10:22,790
只有一次 

214
00:10:22,790 --> 00:10:27,200
只是在这种情况下 循环的每一次迭代我们都在执行一组步骤

215
00:10:27,200 --> 00:10:28,850
一次又一次的背靠背 

216
00:10:28,850 --> 00:10:31,480
我们正在处理输入 所以我们正在查看 让用户按下

217
00:10:31,480 --> 00:10:34,220
键盘上的一个键 他们摸过他们的操纵杆了吗 

218
00:10:34,220 --> 00:10:36,896
他们有没有移动鼠标 点击鼠标 

219
00:10:36,896 --> 00:10:39,020
如果他们有 我们需要将其添加到我们的更新中 

220
00:10:39,020 --> 00:10:42,061
我们需要跟踪这一点 然后更改游戏状态中的任何内容

221
00:10:42,061 --> 00:10:43,520
这依赖于这种投入 

222
00:10:43,520 --> 00:10:46,640
所以我们应该移动我们的球拍 我们应该检测碰撞 

223
00:10:46,640 --> 00:10:49,460
我们应该把所有这些都登记下来 然后无论更新了什么 

224
00:10:49,460 --> 00:10:51,410
我们想重现这一点 

225
00:10:51,410 --> 00:10:52,670
我们想要呈现它--

226
00:10:52,670 --> 00:10:55,190
在它改变的地方渲染 这样我们就有了--

227
00:10:55,190 --> 00:10:58,477
我们在屏幕上看到 在视觉上 东西实际上

228
00:10:58,477 --> 00:11:00,560
改变了我们的游戏世界 我们与之互动 

229
00:11:00,560 --> 00:11:03,260
我们有一种感觉 我们正在使用某种东西 

230
00:11:03,260 --> 00:11:07,430
与一些动态的东西互动 

231
00:11:07,430 --> 00:11:12,140
在2D游戏的背景下 看待世界的最基本方式

232
00:11:12,140 --> 00:11:14,720
是通过2D坐标系 这只是简单地

233
00:11:14,720 --> 00:11:18,949
就像我们在高中学的几何学一样 x轴和y轴 

234
00:11:18,949 --> 00:11:21,740
在这种情况下 它与我们通常所学的略有不同 

235
00:11:21,740 --> 00:11:26,360
在高中 我们倾向于学习XY起源 有点左下角的意思 

236
00:11:26,360 --> 00:11:30,650
正数向上 负数向下 正x向右 

237
00:11:30,650 --> 00:11:31,830
负x向左 

238
00:11:31,830 --> 00:11:34,280
但在这种情况下 我们实际上是从左上角开始 

239
00:11:34,280 --> 00:11:38,740
然后y正向下 y负向上 x正向右 

240
00:11:38,740 --> 00:11:40,640
X负数左转 

241
00:11:40,640 --> 00:11:42,980
以及我们想要在游戏中画出的所有东西

242
00:11:42,980 --> 00:11:45,350
需要有x和y坐标才能按顺序绘制

243
00:11:45,350 --> 00:11:48,170
以便在屏幕上直观地看到它 

244
00:11:48,170 --> 00:11:51,230
所以今天的目标是 我们将从一个相当低的水平开始

245
00:11:51,230 --> 00:11:55,670
并通过今天和未来的课堂上的例子来提升我们的能力 

246
00:11:55,670 --> 00:11:58,160
我们的第一场比赛可以说是最简单的比赛之一 

247
00:11:58,160 --> 00:12:00,920
而且 有史以来最著名的游戏之一 乒乓球 

248
00:12:00,920 --> 00:12:03,500
这部电影于1972年发行 

249
00:12:03,500 --> 00:12:05,499
乒乓球的要点是你有一把球拍

250
00:12:05,499 --> 00:12:08,540
在屏幕的左侧 在屏幕的右侧有一个桨 

251
00:12:08,540 --> 00:12:11,630
无论谁把球传过对手的球拍得10分

252
00:12:11,630 --> 00:12:14,510
在屏幕的边缘 赢了 

253
00:12:14,510 --> 00:12:19,220
所以今天在我们的演讲中 范围是我们想要 最重要的 

254
00:12:19,220 --> 00:12:22,640
在屏幕上画出形状 因为这是我们获得球和球的方式

255
00:12:22,640 --> 00:12:23,630
和划桨渲染 

256
00:12:23,630 --> 00:12:25,490
而这些只是简单的矩形 

257
00:12:25,490 --> 00:12:28,070
我们想要控制这些球拍的2D位置 

258
00:12:28,070 --> 00:12:32,630
因为我们想要他们上下移动 希望球也能移动 

259
00:12:32,630 --> 00:12:36,050
我们想要检测球拍和球之间的碰撞 

260
00:12:36,050 --> 00:12:38,780
因为这是我们让球偏离球拍的方法 

261
00:12:38,780 --> 00:12:40,790
并偏离天花板和地板 

262
00:12:40,790 --> 00:12:44,250
还有 我们如何检测它是否超出了屏幕的边缘 

263
00:12:44,250 --> 00:12:47,270
这样一位选手就能得一分 

264
00:12:47,270 --> 00:12:51,710
然后我们想要添加音效 以获得某种反馈

265
00:12:51,710 --> 00:12:54,660
把我们自己更多地投入到游戏中 

266
00:12:54,660 --> 00:12:57,380
然后是记分 因为比赛的最终目的

267
00:12:57,380 --> 00:12:59,780
就是打败你的对手 所以你想要一种方法

268
00:12:59,780 --> 00:13:02,840
看看谁先得了10分 

269
00:13:02,840 --> 00:13:06,590
因此 我们现在将在回购中查看一组示例 

270
00:13:06,590 --> 00:13:11,240
如果我们看一下Pong Zero 我已经将其命名为Day Zero更新 

271
00:13:11,240 --> 00:13:16,460
在许多游戏中 让游戏发布主要内容是一种趋势

272
00:13:16,460 --> 00:13:17,870
随着x的更新而更新 

273
00:13:17,870 --> 00:13:24,470
所以为了搞笑 我想我们把每个例子都叫在这里 

274
00:13:24,470 --> 00:13:26,220
《某事更新》 

275
00:13:26,220 --> 00:13:29,960
所以我要走进Pong Zero

276
00:13:29,960 --> 00:13:36,680
目录的repo 即GitHub repo 

277
00:13:36,680 --> 00:13:40,669
如果我们看的是Pong Zero 我们可以看到它

278
00:13:40,669 --> 00:13:41,960
这里写着 零日更新 

279
00:13:41,960 --> 00:13:44,990
我对每一件事都做了相当认真的评论 这样我们就可以--

280
00:13:44,990 --> 00:13:48,290
如果您正在阅读代码 您可以在某种程度上了解正在发生的事情 

281
00:13:48,290 --> 00:13:52,580
在第23行 我们将从声明开始

282
00:13:52,580 --> 00:13:54,039
窗口宽度和窗口高度 

283
00:13:54,039 --> 00:13:55,788
这些都是恒定的变量 

284
00:13:55,788 --> 00:13:58,230
在我们应用程序的其余部分中都可以访问 

285
00:13:58,230 --> 00:14:01,160
因此 我只是将1280x720设置为任意分辨率 

286
00:14:01,160 --> 00:14:03,770
这没什么大不了的 

287
00:14:03,770 --> 00:14:07,700
我们需要注意的一件重要的事情是第29行 

288
00:14:07,700 --> 00:14:12,470
我们使用的是一个名为love.Load的函数 而我实际上

289
00:14:12,470 --> 00:14:14,030
现在我们回到幻灯片上 

290
00:14:14,030 --> 00:14:15,988
我们将介绍几个函数 我将

291
00:14:15,988 --> 00:14:18,560
我会把它们看一遍 然后告诉你

292
00:14:18,560 --> 00:14:21,240
在我们详细查看代码之前 它们会做些什么 

293
00:14:21,240 --> 00:14:26,330
Load只是一个函数--由Love Love 2D 

294
00:14:26,330 --> 00:14:28,940
然后我们改写它 

295
00:14:28,940 --> 00:14:31,080
我们给它行为 我们告诉它该做什么 

296
00:14:31,080 --> 00:14:34,190
Love 2D将在我们的main.lua文件中查看它 

297
00:14:34,190 --> 00:14:37,460
如果我们正在查看Pong Zero 您将看到它只有一个main.lua文件 

298
00:14:37,460 --> 00:14:42,410
Love 2D只需要一个main.lua文件 并将运行main.lua文件 

299
00:14:42,410 --> 00:14:45,830
并且您可以从该main.lua引用目录中的任何其他文件

300
00:14:45,830 --> 00:14:46,360
文件 

301
00:14:46,360 --> 00:14:49,540
实际上 这是我们的自力更生 

302
00:14:49,540 --> 00:14:52,610
我们要用任何东西来替代Love.Load

303
00:14:52,610 --> 00:14:55,250
我们希望在应用程序的最开始执行 

304
00:14:55,250 --> 00:14:57,400
这只是一个启动功能 

305
00:14:57,400 --> 00:15:01,590
我们还可以定义上面的函数之外的所有行为 

306
00:15:01,590 --> 00:15:03,887
但在love.load中找到它是一个很好的做法

307
00:15:03,887 --> 00:15:05,720
以便阅读您的代码的人知道 

308
00:15:05,720 --> 00:15:08,990
好的 这是所有启动代码发生的地方 

309
00:15:08,990 --> 00:15:12,570
更新(DT)是一个非常重要的函数 

310
00:15:12,570 --> 00:15:14,720
该函数接受一个名为(Dt)的变量 

311
00:15:14,720 --> 00:15:17,164
爱在一个函数中传递它 

312
00:15:17,164 --> 00:15:19,330
你会用你自己的行为来覆盖它 

313
00:15:19,330 --> 00:15:23,530
爱将在每一帧中执行它 在增量时间内传递它 

314
00:15:23,530 --> 00:15:27,790
您可以在该函数中使用增量时间(DT

315
00:15:27,790 --> 00:15:32,680
根据经过的时间更改您的应用程序 

316
00:15:32,680 --> 00:15:36,670
(Dt)将始终是零点几秒 可能更多 

317
00:15:36,670 --> 00:15:38,320
这取决于您的计算机有多慢 

318
00:15:38,320 --> 00:15:41,410
但通常是六十分之一秒 

319
00:15:41,410 --> 00:15:43,930
你可以将游戏中的任何东西都按这个数值进行缩放

320
00:15:43,930 --> 00:15:47,560
以在所有帧速率上获得均匀的行为 

321
00:15:47,560 --> 00:15:52,180
Love.DRAW是其中的另一个重要功能--

322
00:15:52,180 --> 00:15:53,350
在更新和绘制之间 

323
00:15:53,350 --> 00:15:55,720
可以说 这两个功能中的两个是最重要的功能 

324
00:15:55,720 --> 00:15:58,120
Love.Drawing是我们要使用的函数

325
00:15:58,120 --> 00:16:02,996
定义有我们所有的绘制行为 我们的渲染行为在其中 

326
00:16:02,996 --> 00:16:05,620
这就是我们可以画球拍的地方 我们可以画球 

327
00:16:05,620 --> 00:16:07,411
然后更新是我们可以喜欢变化的地方

328
00:16:07,411 --> 00:16:09,840
划桨的位置等等 

329
00:16:09,840 --> 00:16:13,100
我们将在第一个示例中查看两个更重要的函数 

330
00:16:13,100 --> 00:16:19,799
Print tf是print tf和C的Love 2D类比 

331
00:16:19,799 --> 00:16:22,090
因为这张照片能让我们实际地画出来

332
00:16:22,090 --> 00:16:24,220
屏幕上 而不是控制台上 

333
00:16:24,220 --> 00:16:28,180
我们给它一个字符串形式的文本 以及一个x和y坐标 还可以选择

334
00:16:28,180 --> 00:16:32,890
宽度和对齐 它将在xy处绘制文本 

335
00:16:32,890 --> 00:16:35,500
但它也会考虑到宽度 

336
00:16:35,500 --> 00:16:37,720
它还将考虑到Align 

337
00:16:37,720 --> 00:16:41,840
With是要对齐的量 Align是对齐的模式 

338
00:16:41,840 --> 00:16:47,610
所以如果我们说x是零宽度 我们的窗口宽度 然后我们说居中对齐 

339
00:16:47,610 --> 00:16:51,250
它将在零和我们的窗口宽度之间移动 并居中对齐 

340
00:16:51,250 --> 00:16:54,460
这将产生居中对齐我们的文本的效果 

341
00:16:54,460 --> 00:16:57,100
但我们可以很容易地说 对 它就会对

342
00:16:57,100 --> 00:16:59,200
在这两者之间对齐 就会产生这样的效果

343
00:16:59,200 --> 00:17:01,033
渲染屏幕--渲染文本

344
00:17:01,033 --> 00:17:03,220
沿着屏幕的右边缘 

345
00:17:03,220 --> 00:17:06,760
最后 love.window.setmode获取一个宽度和一个高度

346
00:17:06,760 --> 00:17:08,260
和一些可选参数 

347
00:17:08,260 --> 00:17:11,730
这些参数是垂直同步和全屏 

348
00:17:11,730 --> 00:17:16,550
并将实际设置我们的窗口并将其渲染到屏幕上 

349
00:17:16,550 --> 00:17:21,400
所以如果我们回到这里的源代码 它--在第29行 

350
00:17:21,400 --> 00:17:23,599
我们正在覆盖love.load 

351
00:17:23,599 --> 00:17:27,670
我们传入了love.window.setmode、窗口宽度和窗口

352
00:17:27,670 --> 00:17:31,570
高度 我们将其定义为1280乘以720 

353
00:17:31,570 --> 00:17:33,220
我们路过一张桌子 

354
00:17:33,220 --> 00:17:36,280
这是表格的语法 这些花括号 

355
00:17:36,280 --> 00:17:39,920
我们定义键和值的方式就是用等号

356
00:17:39,920 --> 00:17:40,420
在那里 

357
00:17:40,420 --> 00:17:44,202
所以全屏显示为假 可调整大小显示为假 垂直同步显示为真 

358
00:17:44,202 --> 00:17:45,910
所以不会是全屏的 它是

359
00:17:45,910 --> 00:17:48,230
将是不可调整大小的 但它将是

360
00:17:48,230 --> 00:17:49,840
同步到我们监视器的刷新率 

361
00:17:49,840 --> 00:17:53,410
这就是垂直同步的地方 垂直同步的简称 

362
00:17:53,410 --> 00:17:56,740
然后在第40行 我们覆盖了Love 绘制 

363
00:17:56,740 --> 00:18:00,700
这里有love.graph ics.print tf函数 它们在 

364
00:18:00,700 --> 00:18:03,250
我们在说--我们正在传递字符串 你好 Pong 

365
00:18:03,250 --> 00:18:06,360
我们从x0开始 我们正在设置它

366
00:18:06,360 --> 00:18:10,090
在y窗口高度除以2减去6 

367
00:18:10,090 --> 00:18:13,220
因为Love 2D的默认字体大小是12像素高 

368
00:18:13,220 --> 00:18:15,220
所以我们把它提前了6点 所以它是完美的

369
00:18:15,220 --> 00:18:18,910
在屏幕上垂直居中 

370
00:18:18,910 --> 00:18:22,936
然后我们将对齐量、宽度设置为窗口宽度

371
00:18:22,936 --> 00:18:25,810
这样它就会在我们窗口的整个宽度内对齐它 

372
00:18:25,810 --> 00:18:27,620
现在我们将其设置为中心对齐 

373
00:18:27,620 --> 00:18:30,078
因此它将在我们的整个窗口内居中对齐

374
00:18:30,078 --> 00:18:31,230
从x0开始 

375
00:18:31,230 --> 00:18:36,280
所以如果我们去Pong Zero 然后我们实际运行它 

376
00:18:36,280 --> 00:18:38,080
它有这样做的效果 

377
00:18:38,080 --> 00:18:41,500
我们只是使用默认字体、默认大小进行渲染 

378
00:18:41,500 --> 00:18:44,230
你好 Pong 就在屏幕中央 

379
00:18:44,230 --> 00:18:47,290
所以不是一个非常令人兴奋的例子 但它

380
00:18:47,290 --> 00:18:51,400
正在展示LOVE 2D最重要的功能 

381
00:18:51,400 --> 00:18:55,060
这样我们就可以从稍微有趣的例子开始 

382
00:18:55,060 --> 00:18:59,270
所以 我们的第一个内容更新是低分辨率更新 

383
00:18:59,270 --> 00:19:03,590
所以我们正在开发乒乓球 而乒乓球是一项古老的游戏 

384
00:19:03,590 --> 00:19:06,280
它看起来不像我们刚才看到的例子

385
00:19:06,280 --> 00:19:09,410
字体分辨率相当高的地方 

386
00:19:09,410 --> 00:19:11,740
我们想要一些看起来更复古的东西 

387
00:19:11,740 --> 00:19:14,890
所以我们想要做的是得到我们的解决方案

388
00:19:14,890 --> 00:19:18,490
看起来像是1972年发布的一款游戏 

389
00:19:18,490 --> 00:19:22,220
所以我们要做的是看看这里更重要的几个函数 

390
00:19:22,220 --> 00:19:25,240
所以Pong One具有这些功能 

391
00:19:25,240 --> 00:19:28,470
所以love.graph ics.setDefaultFilter 

392
00:19:28,470 --> 00:19:32,710
这个函数 那个函数的目的是每次

393
00:19:32,710 --> 00:19:36,130
我们的应用程序中有一个字体或图像 

394
00:19:36,130 --> 00:19:39,010
默认情况下 它将应用于筛选器 

395
00:19:39,010 --> 00:19:41,186
默认情况下 它将使用双线性过滤器 

396
00:19:41,186 --> 00:19:43,060
那么会发生什么 它的影响是什么

397
00:19:43,060 --> 00:19:48,400
基本上 每当我们放大或缩小纹理时 

398
00:19:48,400 --> 00:19:51,130
它会认为--它会假设

399
00:19:51,130 --> 00:19:55,960
我们希望它稍微模糊一点 这样看起来就不会太像素化了 

400
00:19:55,960 --> 00:19:57,700
这在某些情况下是好的 

401
00:19:57,700 --> 00:20:01,362
对于更高分辨率的2D游戏开发 这很好 但正如我们将看到的那样 

402
00:20:01,362 --> 00:20:03,820
这在复古游戏的背景下并不是特别好 

403
00:20:03,820 --> 00:20:08,180
复古游戏有非常2D的 清晰的 像素化的美学 

404
00:20:08,180 --> 00:20:09,890
我们想要保留这一点 

405
00:20:09,890 --> 00:20:11,740
因此 这让我们可以设置默认过滤器 

406
00:20:11,740 --> 00:20:14,030
我们很快就会看到它的用法 

407
00:20:14,030 --> 00:20:17,130
另一个重要的--非常重要的功能是输入阶段

408
00:20:17,130 --> 00:20:21,150
在我们前面看到的游戏循环中 love.key(Key)是正在进行的

409
00:20:21,150 --> 00:20:24,610
让我们开始与游戏的这一方面互动 

410
00:20:24,610 --> 00:20:28,440
因此 Love在main.lua中使用的是一个回调函数love.keypresded(Key) 

411
00:20:28,440 --> 00:20:29,940
我们要覆盖它 

412
00:20:29,940 --> 00:20:31,980
它被传递到一个键中 该函数

413
00:20:31,980 --> 00:20:35,230
每当我们按下一个键时 就会被Love 2D呼叫 

414
00:20:35,230 --> 00:20:37,810
它将检测到按下的键 并调用此函数 

415
00:20:37,810 --> 00:20:39,810
无论我们在这里定义了什么 它都会这样称呼它 

416
00:20:39,810 --> 00:20:42,810
我们可以将其设置为接受特定的键

417
00:20:42,810 --> 00:20:46,030
并对该输入执行某些操作 它将获得一个字符串 

418
00:20:46,030 --> 00:20:49,320
所以如果我们说--如果我们按下退出键 

419
00:20:49,320 --> 00:20:52,390
键将等于该函数中的字符串转义 

420
00:20:52,390 --> 00:20:53,910
我们有权访问它 

421
00:20:53,910 --> 00:20:56,700
还有另一个重要的函数love.vent.Quit 

422
00:20:56,700 --> 00:20:59,760
这只有一个非常简单的效果 即退出应用程序 

423
00:20:59,760 --> 00:21:03,980
尽管我们可以在代码中调用它 而不是自己做 

424
00:21:03,980 --> 00:21:07,882
下面是一个纹理过滤的例子 

425
00:21:07,882 --> 00:21:09,840
点过滤与最近邻点过滤相同

426
00:21:09,840 --> 00:21:11,881
过滤 这就是我们将要使用的 

427
00:21:11,881 --> 00:21:15,400
右侧显示的是双线性过滤 它看起来非常模糊 

428
00:21:15,400 --> 00:21:18,890
这就是Love 2D默认应用于字体和纹理的方式 

429
00:21:21,510 --> 00:21:23,620
我们将在一个例子中看到这一点 

430
00:21:23,620 --> 00:21:25,810
我实际上可以用两种不同的风格来运行它 

431
00:21:25,810 --> 00:21:28,890
所以如果你去回购的Pong One 然后我们运行它 

432
00:21:28,890 --> 00:21:32,919
我们看到这里 你好 乒乓球现在被炸了 

433
00:21:32,919 --> 00:21:34,710
实际上 我们会看一些更多的代码 

434
00:21:34,710 --> 00:21:36,360
看看它为什么会被炸毁 

435
00:21:36,360 --> 00:21:42,870
但如果我们回到我们的代码 让我启动Pong One 

436
00:21:46,670 --> 00:21:52,150
转到Main Lua 然后我马上就解释一下 

437
00:21:52,150 --> 00:21:55,730
但让我注释掉这一点 我们将在这里看到区别 

438
00:21:55,730 --> 00:21:58,370
你可以看到它看起来模糊多了 

439
00:21:58,370 --> 00:22:00,930
这是默认的纹理过滤 

440
00:22:00,930 --> 00:22:04,400
就像我说的 它不仅适用于纹理 也适用于字体 

441
00:22:04,400 --> 00:22:06,150
而这并不是我们想要的美学 

442
00:22:06,150 --> 00:22:11,730
因此 让我们从顶部开始 详细了解一下Pong One 

443
00:22:11,730 --> 00:22:14,250
在第28行 我们正在收购一个图书馆 

444
00:22:14,250 --> 00:22:16,850
这就是你如何在你的爱情2D中获得一个图书馆

445
00:22:16,850 --> 00:22:18,740
申请 或者你的爱情申请 

446
00:22:18,740 --> 00:22:21,160
只需与库的名称相等即可 

447
00:22:21,160 --> 00:22:25,490
我们将使用推送来获取1280 x 720窗口

448
00:22:25,490 --> 00:22:31,490
并将其变成432×243的虚拟分辨率窗口 

449
00:22:31,490 --> 00:22:36,500
我们可以开始从更低分辨率的角度来看待我们的比赛 

450
00:22:36,500 --> 00:22:40,220
并以432 x 243像素进行思考 但仍将其渲染

451
00:22:40,220 --> 00:22:42,240
在一个任意大小的窗口中 

452
00:22:42,240 --> 00:22:47,060
在本例中 我们保留了以前看到的1280x720的窗口 

453
00:22:47,060 --> 00:22:51,770
如果您转到love.load函数 我们会看到在第47行使用了这个函数 

454
00:22:51,770 --> 00:22:54,410
我们现在不是love.window.setmode 而是

455
00:22:54,410 --> 00:22:59,000
使用推送设置屏幕、推送库设置屏幕功能 

456
00:22:59,000 --> 00:23:02,570
它需要一个虚拟的宽度 一个虚拟的高度 我们的常规窗口

457
00:23:02,570 --> 00:23:05,840
宽度和我们的窗口高度 然后是和以前一样的表 

458
00:23:05,840 --> 00:23:09,850
这样做的效果是设置了一个窗口 

459
00:23:09,850 --> 00:23:12,710
得到了1280乘720的具体尺寸 

460
00:23:12,710 --> 00:23:16,580
而是432x243的虚拟分辨率 

461
00:23:16,580 --> 00:23:20,480
所以现在 当它呈现时 就像我们很快会看到的那样 

462
00:23:20,480 --> 00:23:23,425
嗯 正如我们已经看到的 实际上 它被放大了 

463
00:23:23,425 --> 00:23:28,490
它的效果是给我们一个较低的分辨率 

464
00:23:28,490 --> 00:23:32,930
在第58行 如果我们看一下love.key按下的函数 

465
00:23:32,930 --> 00:23:37,400
我们放在那里 如果键等于字符串转义 

466
00:23:37,400 --> 00:23:39,500
然后是爱 事件 退出 

467
00:23:39,500 --> 00:23:41,030
所以现在我们有了输入处理 

468
00:23:41,030 --> 00:23:45,530
我们已经覆盖了Love 按下键(Key) 这是Love 2D将会看到的

469
00:23:45,530 --> 00:23:47,919
在我们的应用程序中 然后根据需要调用 

470
00:23:47,919 --> 00:23:49,460
然后我们只是往里面看 

471
00:23:49,460 --> 00:23:52,250
如果关键字是退出 那么就是love.vent.Quit 

472
00:23:52,250 --> 00:23:56,180
如果我运行这个应用程序 我现在可以按键盘上的Ess键

473
00:23:56,180 --> 00:23:59,780
只需退出它 而不必命令退出或点击

474
00:23:59,780 --> 00:24:03,450
Windows应用程序上的X 

475
00:24:03,450 --> 00:24:08,140
我们还更改了另外一件事 在第70行的love.Draw函数中 

476
00:24:08,140 --> 00:24:10,820
我们现在正在使用推送库 

477
00:24:10,820 --> 00:24:14,270
我们需要--它的功能有点像状态机 因为我们

478
00:24:14,270 --> 00:24:17,240
将其设置为使用推送以虚拟分辨率开始渲染

479
00:24:17,240 --> 00:24:21,176
应用开始 然后按应用结束 然后应用之间的任何内容 

480
00:24:21,176 --> 00:24:23,300
这实际上与Open Go的工作原理非常相似 

481
00:24:23,300 --> 00:24:25,110
我们不会涉及太多细节 

482
00:24:25,110 --> 00:24:30,860
但这在精神上与Open Go编程的效果非常相似 

483
00:24:30,860 --> 00:24:32,810
按应用开始 按应用结束 

484
00:24:32,810 --> 00:24:37,110
在这两者之间 无论我们称之为什么 都将以这个虚拟分辨率进行渲染 

485
00:24:37,110 --> 00:24:40,250
因此 我们调用相同的love.graph ics.print(F)函数 

486
00:24:40,250 --> 00:24:43,490
你好 零点乒乓球 虚拟高度除以2减6 

487
00:24:43,490 --> 00:24:44,810
相同的参数 

488
00:24:44,810 --> 00:24:48,680
它的效果是渲染仍然存在的一切

489
00:24:48,680 --> 00:24:53,840
皮肤上的旧别名--

490
00:24:53,840 --> 00:24:58,150
纹理过滤的效果就是让我们看到放大的文本 

491
00:24:58,150 --> 00:25:02,910
所以相同的文本 相同的大小 但现在我们的渲染窗口要小得多 

492
00:25:02,910 --> 00:25:04,550
所以--

493
00:25:04,550 --> 00:25:08,660
到目前为止 对这一切是如何运作的有什么问题吗？

494
00:25:08,660 --> 00:25:09,160
好的 

495
00:25:09,160 --> 00:25:10,580
太棒了 

496
00:25:10,580 --> 00:25:14,660
所以我们把文本直接放到了屏幕上 但我们离Pong还差得远

497
00:25:14,660 --> 00:25:16,910
然而 所以我认为第一件大事 就是

498
00:25:16,910 --> 00:25:20,210
让我们朝那个方向走得更近 这就是我们

499
00:25:20,210 --> 00:25:22,040
将调用矩形更新 

500
00:25:22,040 --> 00:25:26,080
所以我们应该看看一些重要的功能 

501
00:25:26,080 --> 00:25:27,800
Love.graph ics.newFont.

502
00:25:27,800 --> 00:25:30,860
我相信默认字体是Arial 

503
00:25:30,860 --> 00:25:33,819
我们不想让Arial出现在我们的应用程序中 因为我们需要一些

504
00:25:33,819 --> 00:25:35,110
这看起来有点复古 

505
00:25:35,110 --> 00:25:38,570
我们想要一些看起来更相关的东西 

506
00:25:38,570 --> 00:25:43,400
NewFont基本上将采用一个指向字体文件的路径

507
00:25:43,400 --> 00:25:49,050
在我们的文件夹中 如果您在Pong 2文件夹 

508
00:25:49,050 --> 00:25:53,420
您将看到一个Font.ttf文件和一个大小 

509
00:25:53,420 --> 00:25:55,760
因为我们实例化的每个字体对象

510
00:25:55,760 --> 00:25:59,240
需要有一个大小 因为字体对象是不变的 

511
00:25:59,240 --> 00:26:03,560
一旦构建 它们就不能更改 因此需要按大小进行分配

512
00:26:03,560 --> 00:26:05,560
按大小计算 

513
00:26:05,560 --> 00:26:08,540
SetFont将采用任何字体

514
00:26:08,540 --> 00:26:13,070
对象 我们可以在这里设置它

515
00:26:13,070 --> 00:26:17,630
它会将Love 2D中的活动字体设置为该字体 

516
00:26:17,630 --> 00:26:20,240
同样 爱情也是一台状态机

517
00:26:20,240 --> 00:26:25,520
与以前一样 它将在任何时候都具有活动字体 

518
00:26:25,520 --> 00:26:29,630
无论您调用什么打印函数 都将使用当前活动的字体 

519
00:26:29,630 --> 00:26:33,590
这也适用于您可能想要渲染到屏幕上的任何颜色 

520
00:26:33,590 --> 00:26:34,260
管他呢 

521
00:26:34,260 --> 00:26:37,070
如果您有一种字体 并且想要将其呈现为红色 

522
00:26:37,070 --> 00:26:42,080
你也需要一套LOVE 2D的主动色到红色 

523
00:26:42,080 --> 00:26:47,330
Clear是一个接受RGBA四元组的函数 

524
00:26:47,330 --> 00:26:49,956
并将以该颜色刷新屏幕 

525
00:26:49,956 --> 00:26:52,580
它只有一个简单的效果 就是用那种颜色擦拭屏幕 

526
00:26:52,580 --> 00:26:55,512
对于仅绘制纯色背景非常有用 

527
00:26:55,512 --> 00:26:58,220
然后是最后一个功能 可能是最重要的功能 

528
00:26:58,220 --> 00:27:00,322
是love.graph ics.Rectangle 

529
00:27:00,322 --> 00:27:02,030
这是我们将使用的第一个函数

530
00:27:02,030 --> 00:27:05,540
看 这实际上是在屏幕上绘制文本以外的东西 

531
00:27:05,540 --> 00:27:09,620
它采用一种模式 可以是填充或线条、x和y

532
00:27:09,620 --> 00:27:13,140
宽度和高度 它将在该模式下绘制一个矩形 

533
00:27:13,140 --> 00:27:16,610
所以要么是实心 要么是实心矩形 要么是线条矩形 

534
00:27:16,610 --> 00:27:19,550
它会--它会用宽度和高度把它画在xy处

535
00:27:19,550 --> 00:27:21,420
我们把它传进去 

536
00:27:21,420 --> 00:27:24,240
那么让我们继续下去 看看乒乓球2

537
00:27:24,240 --> 00:27:27,800
在那里我们可以看到这一点实际上得到了实施 

538
00:27:27,800 --> 00:27:31,640
所以Pong 2 我们有我们的Font.ttf 我已经把它包括在内了 

539
00:27:31,640 --> 00:27:33,179
然后是一条主流星 

540
00:27:33,179 --> 00:27:35,220
顺便说一句 我忘了提到最后一个例子 

541
00:27:35,220 --> 00:27:39,330
我们所需的PUSH库也在同一目录中 

542
00:27:39,330 --> 00:27:43,790
只要文件在目录中 您就可以要求 

543
00:27:43,790 --> 00:27:45,170
它会直接把它装上 

544
00:27:45,170 --> 00:27:46,670
您不必指定.lua 

545
00:27:46,670 --> 00:27:52,580
它假定当您需要某个字符串时 它后跟.lua后缀 

546
00:27:52,580 --> 00:27:56,780
所以我们在这里看的是Pong 2中的main.lua 矩形的更新 

547
00:27:56,780 --> 00:27:59,900
所以在第28行到第34行 都是一样的东西 

548
00:27:59,900 --> 00:28:00,800
我们正在获得推力 

549
00:28:00,800 --> 00:28:04,210
我们在虚拟和物理上都有自己的宽度和高度 

550
00:28:04,210 --> 00:28:08,120
在love.load函数中 我们位于第43行

551
00:28:08,120 --> 00:28:13,100
将小字体声明为love.graph ics.newFont 

552
00:28:13,100 --> 00:28:15,590
将路径指定为font.ttf 因为它就在那里

553
00:28:15,590 --> 00:28:17,720
在同一个目录中 大小为8 

554
00:28:17,720 --> 00:28:21,260
这将创建一个字体对象 小字体 然后我们就可以

555
00:28:21,260 --> 00:28:24,600
根据需要设置为活动字体 

556
00:28:24,600 --> 00:28:29,930
因此 如果我们深入到同一目录中的第78行 

557
00:28:29,930 --> 00:28:32,432
我们看到我们正在调用love.graph 清楚 

558
00:28:32,432 --> 00:28:33,890
所以我们用一种颜色来传递它 

559
00:28:33,890 --> 00:28:36,890
我在谷歌图片上试用了一些乒乓球的图片

560
00:28:36,890 --> 00:28:45,050
我看到了我喜欢的背景灰色 所以40 45 52 RGB 然后255

561
00:28:45,050 --> 00:28:49,727
意味着完全不透明 因此没有透明度 即Alpha分量 

562
00:28:49,727 --> 00:28:51,560
然后我们执行相同的打印 函数

563
00:28:51,560 --> 00:28:53,210
就像我们之前在81号线上做的那样 

564
00:28:53,210 --> 00:28:56,990
在第89行到第95行下面 我们实际上是

565
00:28:56,990 --> 00:28:59,600
调用love.graph ics.rectang.

566
00:28:59,600 --> 00:29:02,210
这是画两个球拍 然后是球 

567
00:29:02,210 --> 00:29:05,720
所以 注意 love.graph 矩形填充模式 

568
00:29:05,720 --> 00:29:09,320
因为我们希望球拍完全充满 球也是如此 

569
00:29:09,320 --> 00:29:14,450
我们给它的XY是1030 宽度高度是520 

570
00:29:14,450 --> 00:29:19,280
在992年 我们--这会产生一点影响

571
00:29:19,280 --> 00:29:23,270
从左上角移动 宽5个像素 高20个像素 

572
00:29:23,270 --> 00:29:26,300
在第92行 我们在做同样的事情 除了我们

573
00:29:26,300 --> 00:29:28,260
实际宽度减去10 

574
00:29:28,260 --> 00:29:32,040
所以它会移到我们屏幕的右边 虚拟宽度减去10 

575
00:29:32,040 --> 00:29:33,660
所以432减去10 

576
00:29:33,660 --> 00:29:36,260
所以是422 

577
00:29:36,260 --> 00:29:38,370
然后是虚拟身高减去50 

578
00:29:38,370 --> 00:29:41,382
所以这将是一个轻微的--

579
00:29:41,382 --> 00:29:43,840
它将从屏幕底部略微向上 

580
00:29:43,840 --> 00:29:47,540
所以我们有左上角和右下角的划桨 

581
00:29:47,540 --> 00:29:48,920
然后球就在中心了 

582
00:29:48,920 --> 00:29:52,070
所以我们坐着--做另一个图形--矩形调用 

583
00:29:52,070 --> 00:29:54,080
虚拟宽度减去2除以2 

584
00:29:54,080 --> 00:29:56,300
所以就在中间 减去2 因为我们的球

585
00:29:56,300 --> 00:29:58,550
将是两个像素宽乘以两个像素高 

586
00:29:58,550 --> 00:30:00,466
虚拟身高也是如此 减去2 

587
00:30:00,466 --> 00:30:03,080
我们的虚拟身高除以2 减去2 

588
00:30:03,080 --> 00:30:08,040
所以我将继续CD到Pong 2目录并运行它 

589
00:30:08,040 --> 00:30:11,790
这样的效果就是我们的新字体在中间 

590
00:30:11,790 --> 00:30:16,040
所以它看起来很好 复古 比以前的Arial字体更好 

591
00:30:16,040 --> 00:30:19,149
我们有一个长方形 5像素宽 20像素高 

592
00:30:19,149 --> 00:30:21,440
中间的一个球 4像素宽 

593
00:30:21,440 --> 00:30:23,940
像素高 右下角有一个桨 

594
00:30:23,940 --> 00:30:27,260
和左边的桨的尺寸一样 

595
00:30:27,260 --> 00:30:29,407
它看起来很像Pong 

596
00:30:29,407 --> 00:30:32,240
它一点也不互动 但我们可以感觉到

597
00:30:32,240 --> 00:30:33,781
我们希望我们的应用程序看起来像 

598
00:30:33,781 --> 00:30:35,930
我们已经大致勾勒出来了 

599
00:30:35,930 --> 00:30:41,160
有什么问题吗？

600
00:30:41,160 --> 00:30:41,660
好的.

601
00:30:41,660 --> 00:30:43,440
棒了

602
00:30:43,440 --> 00:30:44,340
3.我的超能力

603
00:30:44,340 --> 00:30:48,587
所以目前我们还没有与我们的应用程序进行交互 

604
00:30:48,587 --> 00:30:50,670
我们希望能够移动电极板 

605
00:30:50,670 --> 00:30:53,552
我们不想一直看着一张照片

606
00:30:53,552 --> 00:30:56,010
因此 桨更新将为我们解决这个问题 

607
00:30:56,010 --> 00:30:59,735
我们将得到第一种--除了按下Escape之外

608
00:30:59,735 --> 00:31:01,860
退出应用程序 我们将得到一个感觉 

609
00:31:01,860 --> 00:31:04,200
与之动态互动 

610
00:31:04,200 --> 00:31:07,620
所以我们在这个例子中要看的重要函数

611
00:31:07,620 --> 00:31:11,310
就是love. keyboard. isDownsomeKey

612
00:31:11,310 --> 00:31:13,597
这是一个布尔函数 

613
00:31:13,597 --> 00:31:16,680
它只是返回true或false取决于我们传入的密钥

614
00:31:16,680 --> 00:31:21,420
因为一根弦现在被压在这个框架上 

615
00:31:21,420 --> 00:31:23,980
所以它只返回true或false 

616
00:31:23,980 --> 00:31:27,030
让我们来看看演示 

617
00:31:27,030 --> 00:31:31,110
我们要继续前进 并拉上乒乓3 

618
00:31:31,110 --> 00:31:32,670
主路阿 他们进来了 

619
00:31:35,430 --> 00:31:39,640
注意第37行 如果你在看乒乓球3 我们有一个新的常数

620
00:31:39,640 --> 00:31:43,260
我们定义了桨速 它的值为200 

621
00:31:43,260 --> 00:31:46,279
这只是一个任意的值 我发现这是一个很好的速度 

622
00:31:46,279 --> 00:31:48,320
但这就是我们的桨移动的速度 

623
00:31:48,320 --> 00:31:50,280
我们将用时间增量来衡量它 

624
00:31:50,280 --> 00:31:53,670
乘以过去的秒数 

625
00:31:53,670 --> 00:31:56,100
通常 自上一帧起的几分之一秒 

626
00:31:56,100 --> 00:31:59,040
因此 它将移动相同的距离

627
00:31:59,040 --> 00:32:01,050
随着时间的推移 这取决于您的计算机是否

628
00:32:01,050 --> 00:32:05,230
以每秒10帧或每秒60帧运行 

629
00:32:05,230 --> 00:32:10,680
如果我们在第63行 我也设置了两个新变量 

630
00:32:10,680 --> 00:32:12,630
一号选手得分二号选手得分 

631
00:32:12,630 --> 00:32:14,550
它们都初始化为零 

632
00:32:14,550 --> 00:32:19,920
我们将在这个例子中添加一些乐谱的渲染 

633
00:32:19,920 --> 00:32:22,470
注意在第49行 我还添加了

634
00:32:22,470 --> 00:32:26,130
一种新的字体 它展示了如何根据字体的大小来区分字体

635
00:32:26,130 --> 00:32:27,660
因为它们是不可变的对象 

636
00:32:27,660 --> 00:32:30,090
分数字体得到love.graphics.newFont.

637
00:32:30,090 --> 00:32:35,430
完全一样的字体文件 但它是32像素大 因为字体-或分数

638
00:32:35,430 --> 00:32:38,947
当在Pong中渲染时 屏幕中间相当大 

639
00:32:38,947 --> 00:32:41,280
我们现在有两种不同的字体 

640
00:32:41,280 --> 00:32:44,210
一个用来传递我们的信息 一个用来传递我们的分数 

641
00:32:44,210 --> 00:32:47,460
它只会呈现这两个变量 参与人1的得分和参与人

642
00:32:47,460 --> 00:32:48,630
两百 

643
00:32:48,630 --> 00:32:52,260
然后我们也初始化了y值

644
00:32:52,260 --> 00:32:55,290
对于长方形 左边和右边的桨 

645
00:32:55,290 --> 00:32:58,410
我们需要跟踪他们的y位置 因为乒乓球中的球拍

646
00:32:58,410 --> 00:33:00,330
只能上下移动 

647
00:33:00,330 --> 00:33:02,787
所以参与人1 Y得到的值和之前一样

648
00:33:02,787 --> 00:33:05,370
当我们把矩形画到屏幕上时 我们初始化了它 

649
00:33:05,370 --> 00:33:07,740
它将从30日元开始 所以相当高 

650
00:33:07,740 --> 00:33:10,350
参与人2 y从很低的虚拟高度开始

651
00:33:10,350 --> 00:33:14,250
减去50 也就是432减去50

652
00:33:14,250 --> 00:33:17,760
所以在爱.更新 这是我们第一次实际使用的更新

653
00:33:17,760 --> 00:33:21,780
第75行的函数 带有传入的（dt）参数 

654
00:33:21,780 --> 00:33:24,320
请注意 记住 爱2D将为我们传递 

655
00:33:24,320 --> 00:33:27,570
但我们需要给它--我们需要定义它里面的行为 

656
00:33:27,570 --> 00:33:31,770
我们使用love.keyboard.isDown 并传入字符串w

657
00:33:31,770 --> 00:33:33,590
S为这第一个街区 

658
00:33:33,590 --> 00:33:36,000
这里的第一个块是一号选手的动作 

659
00:33:36,000 --> 00:33:40,680
所以 传统上 在计算机上WASD是移动的--

660
00:33:40,680 --> 00:33:43,950
在这个例子中 我们将允许我们自己移动两个球拍 

661
00:33:43,950 --> 00:33:46,170
因此 我们将使用w和S作为左桨 

662
00:33:46,170 --> 00:33:48,030
然后向上或向下划向右划桨 

663
00:33:48,030 --> 00:33:51,050
所以如果love.keyboard.isDown w 这意味着--

664
00:33:51,050 --> 00:33:54,660
或者我们现在正在按W键 玩家1Y

665
00:33:54,660 --> 00:34:00,040
等于它自己 加上负的划桨速度乘以增量时间 

666
00:34:00,040 --> 00:34:01,450
所以它会向上移动 

667
00:34:01,450 --> 00:34:04,924
它将采用负的划桨速度 乘以增量时间 

668
00:34:04,924 --> 00:34:06,840
然后把它加到我们的y值上 它将会有

669
00:34:06,840 --> 00:34:08,580
把我们的球拍向上移动的效果 

670
00:34:08,580 --> 00:34:10,469
而事实恰恰相反--

671
00:34:10,469 --> 00:34:13,480
在82行--如果我们按S键 

672
00:34:13,480 --> 00:34:17,870
我们需要以正的划桨速度来增加y 因为回想一下 

673
00:34:17,870 --> 00:34:19,560
Y轴运动是--

674
00:34:19,560 --> 00:34:22,359
上涨是负数 下跌是正数 

675
00:34:22,359 --> 00:34:24,900
我们用右边的球拍做同样的事情

676
00:34:24,900 --> 00:34:30,570
只是我们使用UP和DOWN作为love.keyboard.isDown的字符串 

677
00:34:30,570 --> 00:34:36,000
然后在下面的下面 我们正在渲染另外

678
00:34:36,000 --> 00:34:38,940
我们之前呈现的东西 现在也是比分 

679
00:34:38,940 --> 00:34:44,185
因此在第125行 请注意我们调用的是love.graph ics.setFont Scott Font 

680
00:34:44,185 --> 00:34:47,310
因为如果我们不调用它 它将使用上一种字体 

681
00:34:47,310 --> 00:34:49,830
默认情况下是8像素字体 因为我们设置了

682
00:34:49,830 --> 00:34:51,840
在我们的节目中排在首位 

683
00:34:51,840 --> 00:34:54,030
我们希望将其设置为乐谱字体 然后我们

684
00:34:54,030 --> 00:34:55,770
我想调用love.graph ics.print 

685
00:34:55,770 --> 00:34:59,520
在本例中 我只是在具体的地方打印它们 而不是使用printf 

686
00:34:59,520 --> 00:35:01,820
虚拟宽度除以2减去50 

687
00:35:01,820 --> 00:35:03,570
因此 无论我们如何调整窗口 它都是

688
00:35:03,570 --> 00:35:08,820
始终是窗口中心左侧的50个像素 

689
00:35:08,820 --> 00:35:12,040
和窗口中心右侧的30个像素

690
00:35:12,040 --> 00:35:16,780
如果我们给玩家两分的话 

691
00:35:16,780 --> 00:35:23,150
因此 如果我们进入Pong 3并运行它 它看起来和以前一样 

692
00:35:23,150 --> 00:35:26,880
请注意 我们现在在屏幕中间有一个分数 0和0 

693
00:35:26,880 --> 00:35:30,720
但是 更重要的是 我们可以上下移动我们的球拍 

694
00:35:30,720 --> 00:35:34,140
但有一个问题 那就是我可以移动到屏幕边缘之外 

695
00:35:34,140 --> 00:35:37,320
这不是我们在应用程序中想要的行为 

696
00:35:37,320 --> 00:35:40,310
所以我们有一些互动 它在向前发展 

697
00:35:40,310 --> 00:35:42,570
但不幸的是 我们还有很长的路要走 

698
00:35:42,570 --> 00:35:43,890
或者幸运的是 

699
00:35:43,890 --> 00:35:47,340
所以让我们继续来看看球的最新情况 

700
00:35:47,340 --> 00:35:52,710
所以我们有了桨 它们可以移动 它们可以移动到屏幕边缘之外 

701
00:35:52,710 --> 00:35:57,070
但是我们没有一个球--它只是坐在屏幕的中央 

702
00:35:57,070 --> 00:35:58,704
这不是我们要找的 

703
00:35:58,704 --> 00:36:01,620
我们想要一个可以在球拍之间弹跳的球 

704
00:36:01,620 --> 00:36:04,314
这样我们就可以得到一场真正的游戏 而不仅仅是移动球拍 

705
00:36:04,314 --> 00:36:06,480
所以我们要看几个重要的函数 

706
00:36:06,480 --> 00:36:09,250
我们将在这里随机第一次看到 

707
00:36:09,250 --> 00:36:13,710
所以在游戏中 随机数的产生是一件很常见的事情

708
00:36:13,710 --> 00:36:17,370
这样我们就可以在不同实例之间获得不可预测性和可变性

709
00:36:17,370 --> 00:36:18,982
在我们的比赛中 

710
00:36:18,982 --> 00:36:20,940
一个只属于Lua的重要功能 

711
00:36:20,940 --> 00:36:23,010
这不是爱情2D的事情 这只是Lua的事情 

712
00:36:23,010 --> 00:36:25,530
数学 随机种子数 

713
00:36:25,530 --> 00:36:28,620
你们中的许多人可能都听说过像种子这样的名字 

714
00:36:28,620 --> 00:36:30,990
就像一个随机数生成器 种子 这就是

715
00:36:30,990 --> 00:36:33,150
表示随机数生成器 

716
00:36:33,150 --> 00:36:35,310
因为它是伪随机的 所以它需要某种排序

717
00:36:35,310 --> 00:36:38,850
其所有随机数的起始值 

718
00:36:38,850 --> 00:36:42,330
它接受一个起始数字 它执行一些数学运算

719
00:36:42,330 --> 00:36:45,810
得出新的随机值 然后我们就可以

720
00:36:45,810 --> 00:36:46,990
在我们的游戏引擎中使用 

721
00:36:46,990 --> 00:36:49,396
但如果我们每次都给它相同的数字 

722
00:36:49,396 --> 00:36:52,270
它每次都会给我们相同的随机数 

723
00:36:52,270 --> 00:36:53,890
这意味着它根本不会是随机的 

724
00:36:53,890 --> 00:36:55,420
这将是非常一致的 

725
00:36:55,420 --> 00:36:58,530
因此 我们需要一种方法来生成随机数生成器 

726
00:36:58,530 --> 00:37:01,930
给它一个不同的初始值或种子 

727
00:37:01,930 --> 00:37:06,300
我们将用函数数学来实现这一点 随机种子 

728
00:37:06,300 --> 00:37:09,930
在这种情况下 时间是一个重要的函数 

729
00:37:09,930 --> 00:37:13,980
因为每次获得不同号码的一种非常常见的方法

730
00:37:13,980 --> 00:37:17,550
无论当前时间是什么时间 运行应用程序都是在传递它

731
00:37:17,550 --> 00:37:20,940
几秒钟内 因为通常是一个非常大的数字

732
00:37:20,940 --> 00:37:24,210
无论如何 每次运行游戏时都会有所不同 

733
00:37:24,210 --> 00:37:27,150
因为它的基础是 在大多数发动机的背景下 

734
00:37:27,150 --> 00:37:32,450
在Lua的上下文中 所谓的Unix纪元时间是零

735
00:37:32,450 --> 00:37:39,150
零UTC 1970年1月1日 这是一个巨大的数字 有9位或10位数长

736
00:37:39,150 --> 00:37:41,995
这种情况每时每刻都在改变 

737
00:37:41,995 --> 00:37:44,370
然后 为了真正利用这一切 

738
00:37:44,370 --> 00:37:46,119
我们需要一个函数来获得一个随机数 

739
00:37:46,119 --> 00:37:49,427
所以我们用数学 随机 它需要最小值和最大值 

740
00:37:49,427 --> 00:37:51,510
尽管从技术上讲 你不需要通过一分钟 

741
00:37:51,510 --> 00:37:56,670
如果不传递min 它只会隐式地将min作为1来使用 

742
00:37:56,670 --> 00:37:59,590
它将返回一个包含在该范围内的值 

743
00:37:59,590 --> 00:38:02,790
所以如果你说数学 随机一 50 它会给我们

744
00:38:02,790 --> 00:38:04,890
介于1和50之间的随机数 

745
00:38:04,890 --> 00:38:08,110
如果我们只说数学 随机50 它会做同样的事情 

746
00:38:08,110 --> 00:38:12,915
它会说 它会假设rmin为1 并给出一个介于1和50之间的值 

747
00:38:12,915 --> 00:38:14,790
然后是两个重要的数学函数

748
00:38:14,790 --> 00:38:18,450
这是非常基本的 但在几乎所有地方的游戏环境中都是有用的 

749
00:38:18,450 --> 00:38:21,750
它只是math.min 它返回两个值中较小的一个 

750
00:38:21,750 --> 00:38:24,200
和math.max 它转换两个值中较大的一个 

751
00:38:24,200 --> 00:38:29,260
我们将在将值限制在某个范围内的情况下看到这一点 

752
00:38:29,260 --> 00:38:31,600
那么 让我们来看看这里的一个演示 

753
00:38:31,600 --> 00:38:33,806
所以我要继续下去 打开Pong 4 

754
00:38:37,620 --> 00:38:39,710
然后看一下Main Lua 他们进入了 

755
00:38:42,570 --> 00:38:48,300
所以在第47行 我们看到我们正在调用数学 随机种子函数 和以前一样 

756
00:38:48,300 --> 00:38:52,380
注意 我们传入的是OS time 另一个函数调用 

757
00:38:52,380 --> 00:38:55,779
因为每次运行我们的应用程序时 OS的时间都会不同 

758
00:38:55,779 --> 00:38:57,570
所以我们每次都在播种我们的应用程序

759
00:38:57,570 --> 00:39:02,197
我们根据当前秒相对于0 0 0 

760
00:39:02,197 --> 00:39:04,537
零 1970年1月1日 

761
00:39:04,537 --> 00:39:06,870
我们每次跑步都会有所不同 

762
00:39:06,870 --> 00:39:10,800
假设我们不在同一秒内运行它 

763
00:39:10,800 --> 00:39:16,860
如果我们下到71号线和7号线--或者 对不起 67号线和68号线 

764
00:39:16,860 --> 00:39:18,420
我们现在有了--

765
00:39:18,420 --> 00:39:21,420
我们给我们的球一个起始值 

766
00:39:21,420 --> 00:39:23,800
因为我们想真正开始操控我们的球 

767
00:39:23,800 --> 00:39:27,300
所以我们给它一个X和一个Y 所以我们再次将它放在中心位置

768
00:39:27,300 --> 00:39:29,490
但现在 我们正在为它定义一个变量

769
00:39:29,490 --> 00:39:33,030
而不是用我们的Love静态地呈现它 graph 矩形

770
00:39:33,030 --> 00:39:35,286
函数 因为我们希望这种情况随着时间的推移而改变 

771
00:39:35,286 --> 00:39:37,660
我们想开始让我们的球在屏幕上移动 

772
00:39:37,660 --> 00:39:40,830
所以这些x和y变量现在开始改变 

773
00:39:40,830 --> 00:39:44,100
它们将相对于它的当前速度发生变化 

774
00:39:44,100 --> 00:39:48,840
它的速度将存储在球dx和球dy中 

775
00:39:48,840 --> 00:39:53,380
Dx和dy是增量x和增量y的常用缩写 

776
00:39:53,380 --> 00:39:55,500
这就是你表示速度的方式 

777
00:39:55,500 --> 00:39:59,100
所以我们要做的是 有效地取我们的增量x和增量

778
00:39:59,100 --> 00:40:01,672
并将它们一帧一帧地添加到我们的球上 

779
00:40:01,672 --> 00:40:03,630
这将产生更新的效果

780
00:40:03,630 --> 00:40:05,520
我们的球的位置有一定的价值 

781
00:40:05,520 --> 00:40:07,890
并将增量x和增量y分开

782
00:40:07,890 --> 00:40:12,662
会让我们的球有不同的角度 不同的轨迹 

783
00:40:12,662 --> 00:40:15,370
然后我们在这个应用程序中也做了另一件事 

784
00:40:15,370 --> 00:40:18,270
我们从游戏状态的概念开始 

785
00:40:18,270 --> 00:40:21,840
因为现在我们可以有一个初始状态 以及我们将拥有的

786
00:40:21,840 --> 00:40:23,040
是一种播放状态 

787
00:40:23,040 --> 00:40:25,320
在这个例子中 我们要做的就是

788
00:40:25,320 --> 00:40:28,607
在此应用程序中 启动状态为字符串 

789
00:40:28,607 --> 00:40:31,440
在未来的示例中 我们将使用所谓的状态机

790
00:40:31,440 --> 00:40:34,260
实际上把不同的州分成各自的州--

791
00:40:34,260 --> 00:40:35,770
放入他们自己的模块中 

792
00:40:35,770 --> 00:40:36,870
但在这场比赛的背景下 我们只是

793
00:40:36,870 --> 00:40:38,828
我将使用一个简单的字符串来说明

794
00:40:38,828 --> 00:40:42,180
它是如何工作的 当我们开始游戏时 我们将说出我们的第一个状态 

795
00:40:42,180 --> 00:40:46,650
应该是处于开始状态的开始字符串 

796
00:40:46,650 --> 00:40:49,440
所以在第86行 我们要做的是

797
00:40:49,440 --> 00:40:52,394
是解决我们在上一个例子中遇到的一个问题 

798
00:40:52,394 --> 00:40:55,560
操纵杆可能会移动到屏幕边缘之外 这不是行为

799
00:40:55,560 --> 00:40:56,820
这是我们应该允许的 

800
00:40:56,820 --> 00:41:02,640
所以我们将在0上调用math.max 同样的操作

801
00:41:02,640 --> 00:41:06,180
我们以前是这样做的 这将产生返回的效果 无论是哪一个

802
00:41:06,180 --> 00:41:08,260
这两个值中较大的一个 

803
00:41:08,260 --> 00:41:10,920
因此 如果值是--

804
00:41:10,920 --> 00:41:13,971
如果我们在y值上加上负的划桨速度

805
00:41:13,971 --> 00:41:15,720
它进入了负值范围 这是

806
00:41:15,720 --> 00:41:18,722
意味着它超出了屏幕的顶端 

807
00:41:18,722 --> 00:41:20,680
零将是这些值中较大的一个

808
00:41:20,680 --> 00:41:23,750
所以在这种情况下 它永远是零 Math.max返回

809
00:41:23,750 --> 00:41:25,000
两个值中较大的一个 

810
00:41:25,000 --> 00:41:27,416
所以它会有夹紧它的效果 这样它就永远不会

811
00:41:27,416 --> 00:41:29,520
位于顶部边缘上方 

812
00:41:29,520 --> 00:41:32,130
第96行的情况正好相反 在这里我们

813
00:41:32,130 --> 00:41:35,860
对虚拟高度减去20调用math.min 

814
00:41:35,860 --> 00:41:39,290
选手1.y加上划桨速度 增量乘以增量时间 

815
00:41:39,290 --> 00:41:41,790
这将具有相同的效果 它将返回

816
00:41:41,790 --> 00:41:43,560
这两个值中较小的一个 

817
00:41:43,560 --> 00:41:47,820
在这种情况下 如果我们超过了虚拟高度减去20 

818
00:41:47,820 --> 00:41:52,410
在屏幕底部移动了我们的球拍的大小 

819
00:41:52,410 --> 00:41:55,000
它将把它设置为虚拟高度减20 

820
00:41:55,000 --> 00:41:57,390
因此 我们永远不会低于这一点 

821
00:41:57,390 --> 00:42:01,470
我们也在为2号玩家做同样的事情 完全相同的逻辑 

822
00:42:01,470 --> 00:42:04,440
如果我们处于播放状态 我们就会

823
00:42:04,440 --> 00:42:07,069
来更新我们的球的位置 

824
00:42:07,069 --> 00:42:10,360
所以我们处于--如果我们处于开始状态 球是不会移动的 

825
00:42:10,360 --> 00:42:14,730
但如果我们处于播放状态 我们希望球x等于球x加球

826
00:42:14,730 --> 00:42:16,200
X乘以增量时间 

827
00:42:16,200 --> 00:42:19,440
请注意 Lua中没有速记

828
00:42:19,440 --> 00:42:23,520
为自身增加价值 这就是为什么我们称之为Ball

829
00:42:23,520 --> 00:42:26,340
等于球x 加上球x乘以增量时间 

830
00:42:26,340 --> 00:42:30,300
而不是简单地说球x+等于球x乘以增量时间 

831
00:42:30,300 --> 00:42:33,090
这只是他们做出的语言决定 

832
00:42:33,090 --> 00:42:35,760
但如果我们处于播放状态 这将是

833
00:42:35,760 --> 00:42:39,720
无论我们当前的球的速度是多少 都有缩放的效果--

834
00:42:39,720 --> 00:42:43,020
乘以增量时间 因此它保持与帧速率无关 

835
00:42:43,020 --> 00:42:45,930
然后把它加到球x和球y上 这会使它移位 

836
00:42:45,930 --> 00:42:53,300
我们在这里的170行得到了实际的结果--

837
00:42:53,300 --> 00:42:54,690
174.

838
00:42:54,690 --> 00:42:59,370
我们现在--不只是在屏幕上呈现纯平的数字 

839
00:42:59,370 --> 00:43:01,740
我们实际上是在使用球x和球y来渲染 

840
00:43:01,740 --> 00:43:05,190
如果我们处于播放状态 这些将会更新 

841
00:43:05,190 --> 00:43:13,740
但如果我们回到第127行 现在 我们在Love中 按键函数 

842
00:43:13,740 --> 00:43:15,420
所以我们从120号线开始 

843
00:43:15,420 --> 00:43:19,530
在我们刚刚有If键等于逸出之前 那么love.vent.it 

844
00:43:19,530 --> 00:43:22,620
但现在在第127行 我们要检查

845
00:43:22,620 --> 00:43:25,800
要查看该键是否等于Enter或Return 

846
00:43:25,800 --> 00:43:29,697
然后我们将使用它作为我们测试状态变化的方法 

847
00:43:29,697 --> 00:43:32,280
所以我们要说 如果游戏状态等于开始 

848
00:43:32,280 --> 00:43:35,670
一旦你按回车 游戏状态应该等于玩 

849
00:43:35,670 --> 00:43:37,960
否则 将其重新设置为开始 

850
00:43:37,960 --> 00:43:41,350
我们将它设置为开始 我们将重新初始化我们的x

851
00:43:41,350 --> 00:43:43,780
和y在中心 虚拟宽度除以2

852
00:43:43,780 --> 00:43:46,420
-2 虚拟高度除以2-2 

853
00:43:46,420 --> 00:43:51,040
我们再一次给它一个初始的随机起始速度 

854
00:43:51,040 --> 00:43:54,040
注意这里 这个数学 随机二等于--

855
00:43:54,040 --> 00:43:57,150
等于1和100 或负100 

856
00:43:57,150 --> 00:43:59,990
这只是Lua做三元运算的方式 

857
00:43:59,990 --> 00:44:03,400
所以在C语言中 你通常会有这样的--

858
00:44:03,400 --> 00:44:08,530
你会有点像数学 随机二等于一 

859
00:44:08,530 --> 00:44:13,030
你会有一个问号 100冒号 负100 

860
00:44:13,030 --> 00:44:14,830
这是一模一样的东西 但Lua不是

861
00:44:14,830 --> 00:44:18,850
有三进制操作的简写 所以我们用

862
00:44:18,850 --> 00:44:20,350
和或 

863
00:44:20,350 --> 00:44:24,310
我们使用逻辑运算来做同样的事情 

864
00:44:24,310 --> 00:44:28,660
注意这里我们也展示了数学 random可以

865
00:44:28,660 --> 00:44:30,760
一个参数或两个参数 

866
00:44:30,760 --> 00:44:32,757
在这种情况下 我们说的是数学 随机二 

867
00:44:32,757 --> 00:44:35,090
这意味着它会给我们一个介于1和2之间的值 

868
00:44:35,090 --> 00:44:36,370
所以五五分成 

869
00:44:36,370 --> 00:44:39,070
如果我们做负50-50 那意味着

870
00:44:39,070 --> 00:44:41,500
我们会得到一个介于负50和50之间的值 

871
00:44:41,500 --> 00:44:44,147
所以有效范围是100 

872
00:44:44,147 --> 00:44:46,980
如果我们运行应用程序 

873
00:44:46,980 --> 00:44:48,100
我们进入Pong 4 

874
00:44:50,970 --> 00:44:53,570
我们在开始状态 所以现在我们渲染--

875
00:44:53,570 --> 00:44:57,230
如果我们处于开始状态 它将被设置为呈现该消息 

876
00:44:57,230 --> 00:45:01,370
如果我们按下回车键 球会得到一个随机的速度--实际上

877
00:45:01,370 --> 00:45:03,710
一帧一帧地应用速度 

878
00:45:03,710 --> 00:45:05,360
它在update方法中更新 

879
00:45:05,360 --> 00:45:09,410
如果我们再次按Enter键 它将重置 我们将返回到开始状态 

880
00:45:09,410 --> 00:45:11,550
所以我们再做一次 它得到一个随机值 

881
00:45:11,550 --> 00:45:12,830
再来一次 随机值 

882
00:45:12,830 --> 00:45:13,860
随机值 

883
00:45:13,860 --> 00:45:17,030
所以每次我们得到一个不同的随机球值 

884
00:45:17,030 --> 00:45:24,230
但是如果我们试着运行它 或者试着与它互动 会发生什么呢？

885
00:45:24,230 --> 00:45:25,140
没什么

886
00:45:25,140 --> 00:45:26,207
直接穿过去 

887
00:45:26,207 --> 00:45:28,040
所以我们缺少了一个关键的部分 尽管我们

888
00:45:28,040 --> 00:45:32,210
实现了我们游戏引擎的核心组件 

889
00:45:32,210 --> 00:45:35,720
我们没有任何具体的游戏 没有任何互动 

890
00:45:35,720 --> 00:45:38,550
这是我们需要关注的一个主要部分 

891
00:45:38,550 --> 00:45:40,040
接下来

892
00:45:40,040 --> 00:45:42,170
在我们真正开始之前 

893
00:45:42,170 --> 00:45:46,880
我们来看看职业更新 乒乓5 

894
00:45:46,880 --> 00:45:52,640
所以为了更深入地了解

895
00:45:52,640 --> 00:45:55,130
为了更有效地扩展代码 我们需要

896
00:45:55,130 --> 00:45:58,200
开始从阶级的角度看问题 

897
00:45:58,200 --> 00:46:01,826
我们的球没有x和y 我们的桨也没有x和y 

898
00:46:01,826 --> 00:46:04,700
我们的球的Δ x Δ y 所有这些不同的变量 

899
00:46:04,700 --> 00:46:07,310
到处都是开始膨胀我们的代码 

900
00:46:07,310 --> 00:46:10,154
在我们为之疯狂之前 我们应该考虑一下

901
00:46:10,154 --> 00:46:13,070
我们怎样才能把这些数据放在一起 这样我们就可以只考虑

902
00:46:13,070 --> 00:46:15,530
我们的球拍或者我们的球体 

903
00:46:15,530 --> 00:46:17,780
所以我们使用所谓的类 

904
00:46:17,780 --> 00:46:21,110
如果不熟悉 类只是一种获取所有这些变量的方法

905
00:46:21,110 --> 00:46:25,490
我们到目前为止一直在使用 但把它们放在一个容器里 这样

906
00:46:25,490 --> 00:46:29,600
我们可以说 Paddle.x或Paddle--

907
00:46:29,600 --> 00:46:31,970
你知道 在这种情况下 是汽车 

908
00:46:31,970 --> 00:46:37,530
如果我们有一个名为Drive Car的函数 现在我们只需说Car 

909
00:46:37,530 --> 00:46:40,520
我们不一定要有与我们的价值观分开的功能 

910
00:46:40,520 --> 00:46:42,020
我们可以把它们放在一起 

911
00:46:42,020 --> 00:46:45,500
我们可以问我们的车目前的行驶里程是多少

912
00:46:45,500 --> 00:46:48,120
所有这些不同的变量无处不在 

913
00:46:48,120 --> 00:46:51,890
因此 这些课程实际上就是蓝图 

914
00:46:51,890 --> 00:46:53,390
使用它--定义一个类 

915
00:46:53,390 --> 00:46:55,970
你说 好吧 我的汽车课将会有

916
00:46:55,970 --> 00:46:58,400
A--它会有一个里程变量 

917
00:46:58,400 --> 00:47:02,081
它将有一个油漆变量 它将有一个品牌和一个型号 

918
00:47:02,081 --> 00:47:05,330
它将拥有所有这些东西 并将保持自己的状态 

919
00:47:05,330 --> 00:47:07,080
它将为我们保持这一切 

920
00:47:09,890 --> 00:47:10,970
如图所示 

921
00:47:10,970 --> 00:47:14,090
通常 这些就是所谓的字段 

922
00:47:14,090 --> 00:47:16,700
然后我们也会有方法 

923
00:47:16,700 --> 00:47:20,730
功能 而不是完全独立于这些数据 

924
00:47:20,730 --> 00:47:23,960
汽车现在基本上拥有自己的功能 

925
00:47:23,960 --> 00:47:28,337
它有自己的方法 称为驾驶 或转向 或按喇叭 等等 

926
00:47:28,337 --> 00:47:30,170
我们不需要一个名为的函数 

927
00:47:30,170 --> 00:47:35,090
比如 转弯 或者按喇叭等等 

928
00:47:35,090 --> 00:47:37,700
然后这门课实际上就是一张蓝图 

929
00:47:37,700 --> 00:47:40,550
好 我们很快就会看到如何定义一个类 

930
00:47:40,550 --> 00:47:44,617
但为了真正像一把桨一样拥有自己的数据集 

931
00:47:44,617 --> 00:47:47,450
我们需要定义另一个拥有自己的数据集的划桨--

932
00:47:47,450 --> 00:47:51,170
我们需要从这个类实例化、创建对象 

933
00:47:51,170 --> 00:47:54,440
基本上 使用这个类作为蓝图 但将其带到工厂

934
00:47:54,440 --> 00:47:57,470
并根据蓝图制造混凝土汽车 

935
00:47:57,470 --> 00:47:58,685
这些都是物件 

936
00:48:01,200 --> 00:48:03,195
就像这里看到的 我们的球拍和球

937
00:48:03,195 --> 00:48:05,880
都是做这件事的完美的简单用例 

938
00:48:05,880 --> 00:48:08,090
那么 让我们继续下去 看看乒乓球5 

939
00:48:14,481 --> 00:48:17,230
所以在Pong 5中 立即 如果你看一下目录结构 

940
00:48:17,230 --> 00:48:21,190
您可以看到 我们已经添加了一个球.lua和一个Paddle.lua 

941
00:48:21,190 --> 00:48:25,510
这是大多数面向对象编程语言的传统 

942
00:48:25,510 --> 00:48:31,180
正如它所称的 要将类名大写以便您可以区分

943
00:48:31,180 --> 00:48:37,400
类 例如 来自具体的对象、变量或函数 

944
00:48:37,400 --> 00:48:43,420
所以如果你去我们的主卢瓦 在第35行 

945
00:48:43,420 --> 00:48:46,700
我们需要一个名为类的库 它

946
00:48:46,700 --> 00:48:50,750
才能让我们真正创建这些类 

947
00:48:50,750 --> 00:48:52,400
因为班级不是原生的--

948
00:48:52,400 --> 00:48:55,310
它们在某种意义上是原生的Lua功能 

949
00:48:55,310 --> 00:48:59,900
但是Lua进行面向对象编程的方式有点复杂 

950
00:48:59,900 --> 00:49:04,190
一些人好心地建立了一个库 使它变得简单得多 

951
00:49:04,190 --> 00:49:07,430
与其他面向对象的语言有更密切的关系

952
00:49:07,430 --> 00:49:12,530
更主要的是编程 比如Java或C# 甚至是Python 

953
00:49:12,530 --> 00:49:16,370
允许我们以非常类似的方式使用关键字CLASS

954
00:49:16,370 --> 00:49:17,560
图书馆 

955
00:49:17,560 --> 00:49:22,749
在第39行和第43行 我们正在获取自己的代码、球拍和球 

956
00:49:22,749 --> 00:49:25,040
我们现在就来看看这些 所以我们

957
00:49:25,040 --> 00:49:27,330
可以看到班级是什么样子的 

958
00:49:27,330 --> 00:49:30,314
所以我要继续开一家--

959
00:49:33,200 --> 00:49:36,740
球文件 bal.lua 

960
00:49:36,740 --> 00:49:38,630
我们可以在这里看到我们所需要做的就是

961
00:49:38,630 --> 00:49:43,220
创建一个Ball类是 使用我们的类库 Ball获取类 

962
00:49:43,220 --> 00:49:45,050
然后是像这样的花括号 

963
00:49:45,050 --> 00:49:47,900
所以现在我们有了一个类对象 一个类表 

964
00:49:47,900 --> 00:49:50,780
实际上 因为Lua的一切都是一张桌子 

965
00:49:50,780 --> 00:49:53,030
但我们可以从物体的角度来考虑它 

966
00:49:53,030 --> 00:49:56,060
我们有一个名为Ball的类对象 然后我们

967
00:49:56,060 --> 00:49:59,520
可以开始定义属于此类的函数 

968
00:49:59,520 --> 00:50:03,230
因此 我们将定义所谓的构造函数或初始化函数

969
00:50:03,230 --> 00:50:04,820
在本例中 为初始值设定项 

970
00:50:04,820 --> 00:50:09,200
它将允许我们用任何我们想要的东西来初始化我们的球 

971
00:50:09,200 --> 00:50:11,930
在本例中 我们希望以x和y开头 

972
00:50:11,930 --> 00:50:13,610
宽度和高度 

973
00:50:13,610 --> 00:50:16,410
请注意 在这里我们有一个词叫“自我” 

974
00:50:16,410 --> 00:50:20,330
Self和This是面向对象编程语言中的常用词

975
00:50:20,330 --> 00:50:25,610
这意味着我们用这个类创建的任何对象都将是self 

976
00:50:25,610 --> 00:50:27,010
所以我们会看到--

977
00:50:27,010 --> 00:50:28,070
我们很快就会看到这一点 

978
00:50:28,070 --> 00:50:29,250
Self.x得到x 

979
00:50:29,250 --> 00:50:31,940
因此 无论我们使用此调用创建什么具体对象 

980
00:50:31,940 --> 00:50:36,320
这个init调用 将它的x设置为x 将y设置为y 设置其宽度 

981
00:50:36,320 --> 00:50:37,000
设置它的高度 

982
00:50:37,000 --> 00:50:38,240
那个特定的物体 

983
00:50:38,240 --> 00:50:39,980
赛尔夫 

984
00:50:39,980 --> 00:50:42,620
然后我们对增量y和增量x做同样的事情 

985
00:50:42,620 --> 00:50:46,460
只是我们正在设置这两个随机值 就像我们以前做的那样 

986
00:50:46,460 --> 00:50:49,910
Self.dy self.dx 

987
00:50:49,910 --> 00:50:54,890
它属于使用此init调用实例化的任何特定对象

988
00:50:54,890 --> 00:50:57,530
正如我们将在代码中看到的那样 

989
00:50:57,530 --> 00:51:01,070
为了简单起见 我们在这里只定义了一个重置函数 

990
00:51:01,070 --> 00:51:02,660
在我们有一个--

991
00:51:02,660 --> 00:51:06,150
几行代码将我们的球设置到屏幕中央

992
00:51:06,150 --> 00:51:07,580
给了它一个随机的速度 

993
00:51:07,580 --> 00:51:09,830
我们现在正在这样做 这是一种很好的排序方式

994
00:51:09,830 --> 00:51:11,810
重构出一组逻辑 

995
00:51:11,810 --> 00:51:15,260
我们正在创建一个名为Reset的函数 该函数在一个函数中完成所有这些操作

996
00:51:15,260 --> 00:51:19,250
调用 我们只是在Main函数中调用它 压缩我们的代码 

997
00:51:19,250 --> 00:51:22,130
然后请注意 我们现在有一个更新和一个呈现函数 

998
00:51:22,130 --> 00:51:24,440
我们将从我们自己的更新中调用这些

999
00:51:24,440 --> 00:51:27,560
和我们自己的绘制函数 以便每个对象

1000
00:51:27,560 --> 00:51:31,940
我们希望在我们的游戏中 每个实体 我们将在这个游戏的基础上

1001
00:51:31,940 --> 00:51:33,680
在未来的比赛中 

1002
00:51:33,680 --> 00:51:39,170
我们将只调用更新并呈现来自我们的main的所有内容 lua 

1003
00:51:39,170 --> 00:51:43,160
并将所有这些都交给每个单独的类和对象

1004
00:51:43,160 --> 00:51:46,670
所以我们不需要有一个Main Lua 这就像是800行代码 

1005
00:51:46,670 --> 00:51:50,480
我们只是在这里发布所有与球相关的更新 

1006
00:51:50,480 --> 00:51:53,720
以及所有与球相关的渲染代码 

1007
00:51:53,720 --> 00:51:56,090
调用每个单独的球更新和渲染 

1008
00:51:56,090 --> 00:51:59,630
节省了我们大量的重构时间 

1009
00:51:59,630 --> 00:52:01,655
如果我们看桨 我们也在做同样的事情 

1010
00:52:04,400 --> 00:52:06,410
划桨也是一门课

1011
00:52:06,410 --> 00:52:10,310
它得到了类库的原因.

1012
00:52:10,310 --> 00:52:13,910
同样的事情 xy加上高度 还有dy 

1013
00:52:13,910 --> 00:52:17,960
在这种情况下 我们只是将其初始化为零 这样我们就不会移动 

1014
00:52:17,960 --> 00:52:20,640
然后我们在这里调用update函数 

1015
00:52:20,640 --> 00:52:25,250
所以如果dy小于零 我们就像以前一样使用math.max函数 

1016
00:52:25,250 --> 00:52:29,630
与屏幕的顶部边缘 然后无论我们的y加上我们的当前dy

1017
00:52:29,630 --> 00:52:31,820
是Δ y 

1018
00:52:31,820 --> 00:52:34,880
然后这里 self.y得到math.min 虚拟高度

1019
00:52:34,880 --> 00:52:39,220
减去self.height self.y加上self.dy乘以delta time 

1020
00:52:39,220 --> 00:52:42,470
这就是我们之前看到的用桨的夹紧行为 只是现在 

1021
00:52:42,470 --> 00:52:45,660
我们把它从main函数中取出来放到update函数中

1022
00:52:45,660 --> 00:52:48,110
所以每个paddle调用它的更新 

1023
00:52:48,110 --> 00:52:49,700
我们的主文件中的代码 

1024
00:52:49,700 --> 00:52:52,622
然后它有自己的渲染功能 和桨一样 

1025
00:52:52,622 --> 00:52:55,580
球拍的渲染函数和球的渲染函数

1026
00:52:55,580 --> 00:52:57,380
实际上是一样的 

1027
00:52:57,380 --> 00:53:04,300
所以如果我们去到我们的主管道 我们--我们得到了桨

1028
00:53:04,300 --> 00:53:07,000
我们正在获取球 以便我们可以使用它们 

1029
00:53:07,000 --> 00:53:13,810
所以如果我们向下到第79行 而不是初始化我们的球dx或球dy 

1030
00:53:13,810 --> 00:53:18,520
球x 球y 桨y 玩家1 y 玩家2 y 

1031
00:53:18,520 --> 00:53:22,990
现在 我们有一个参与人是简单的桨10 35 20.

1032
00:53:22,990 --> 00:53:25,180
参与人2是球拍 虚拟宽度减10 

1033
00:53:25,180 --> 00:53:28,090
虚拟高度减30520

1034
00:53:28,090 --> 00:53:30,990
球是一个球 虚宽除以二减二 

1035
00:53:30,990 --> 00:53:33,385
虚高减二减二五是？两

1036
00:53:33,385 --> 00:53:35,170
负二四四

1037
00:53:35,170 --> 00:53:39,070
所以这些桨现在可以控制自己的x和y 自己的宽度

1038
00:53:39,070 --> 00:53:45,010
和高度 以及战斗--或者球对XY宽度有自己的控制

1039
00:53:45,010 --> 00:53:45,960
和身高 

1040
00:53:45,960 --> 00:53:48,650
而自我也适用于这个对象 

1041
00:53:48,650 --> 00:53:53,300
这就是我们之前看到的构造函数中的self 

1042
00:53:53,300 --> 00:53:55,630
所以即使是现在我们也可以直接呼叫--所以我们可以简单地

1043
00:53:55,630 --> 00:54:01,550
假设玩家1.x 玩家1.wide 玩家1.y 一切都包含在内 

1044
00:54:01,550 --> 00:54:04,055
我们不需要一百万个变量来跟踪

1045
00:54:04,055 --> 00:54:05,680
在我们比赛中发生的所有事情中 

1046
00:54:05,680 --> 00:54:08,890
随着规模的扩大 这一点将变得尤为重要 我们已经--

1047
00:54:08,890 --> 00:54:11,500
也许我们一次可以在屏幕上看到100个东西 

1048
00:54:11,500 --> 00:54:14,560
我们不希望100乘以x个变量

1049
00:54:14,560 --> 00:54:20,690
X是 不管它有多少我们需要跟踪的属性 

1050
00:54:20,690 --> 00:54:23,470
这都是同样的逻辑 除了 现在 我们

1051
00:54:23,470 --> 00:54:28,420
在我们的更新函数中调用玩家一更新和玩家二更新 

1052
00:54:28,420 --> 00:54:30,670
而不是让所有的逻辑都在里面 

1053
00:54:30,670 --> 00:54:33,342
他们在哪里移动 然后跟踪是否

1054
00:54:33,342 --> 00:54:36,050
否则 它们会越过屏幕的顶部和底部边缘 

1055
00:54:36,050 --> 00:54:39,370
然后 如果游戏状态是PLAY 我们现在只需要调用球更新 

1056
00:54:39,370 --> 00:54:43,210
而这些都是在三角洲时间内通过的 

1057
00:54:43,210 --> 00:54:45,120
然后这里也是一样的 

1058
00:54:45,120 --> 00:54:47,890
而不是用所有的逻辑来重申球

1059
00:54:47,890 --> 00:54:50,327
作为一段代码 我们把它取出来 我们重构了它 

1060
00:54:50,327 --> 00:54:52,660
我们把它放到球课上 现在我们要做的就是

1061
00:54:52,660 --> 00:54:56,470
只是一行代码 球或重置 

1062
00:54:56,470 --> 00:55:00,490
然后在我们的绘图函数的第169行 

1063
00:55:00,490 --> 00:55:04,060
我们只有一号玩家渲染 二号玩家渲染 球渲染 

1064
00:55:04,060 --> 00:55:06,925
后来 随着我们的规模扩大 我们制作游戏

1065
00:55:06,925 --> 00:55:09,550
屏幕上有更多的东西 更多的实体 

1066
00:55:09,550 --> 00:55:11,890
我们可以只在循环中进行这些渲染 

1067
00:55:11,890 --> 00:55:15,700
我们只能说 对于屏幕中的每个实体 只需呈现它 

1068
00:55:15,700 --> 00:55:18,340
对于我们屏幕中的每个实体 只需更新它 

1069
00:55:18,340 --> 00:55:21,190
我们可以压缩数千--数百行代码

1070
00:55:21,190 --> 00:55:25,030
通过推迟更新逻辑 只需几行代码

1071
00:55:25,030 --> 00:55:27,820
以及将逻辑呈现给每个单独的实体 

1072
00:55:27,820 --> 00:55:30,070
多亏了面向对象的编程 

1073
00:55:30,070 --> 00:55:33,370
这就是我们将如何使用类进行重构 

1074
00:55:33,370 --> 00:55:37,930
那么 到目前为止 对这一切是如何运作的有什么问题吗？

1075
00:55:40,640 --> 00:55:41,290
凉爽的 

1076
00:55:41,290 --> 00:55:44,170
我认为这是一个很好的观点 可以休息五分钟 

1077
00:55:44,170 --> 00:55:49,676
一旦我们回来 我们将讨论如何查看每秒的帧 

1078
00:55:49,676 --> 00:55:52,180
好的 

1079
00:55:52,180 --> 00:55:56,800
所以我们要花一分钟时间来看看一些小东西 

1080
00:55:56,800 --> 00:56:00,940
但通常情况是 在游戏中 如果我们

1081
00:56:00,940 --> 00:56:06,400
希望确保我们的性能与我们的应用程序一样运行良好 

1082
00:56:06,400 --> 00:56:08,940
我们想要--某种方式来监控我们的每秒帧数 

1083
00:56:08,940 --> 00:56:10,731
所以我想我应该花点时间

1084
00:56:10,731 --> 00:56:15,160
来快速地说明这一点 这样我们就可以在未来使用它 

1085
00:56:15,160 --> 00:56:18,830
对我们来说很重要的两个功能--

1086
00:56:18,830 --> 00:56:21,959
好的 第一个只是一个小小的化妆品

1087
00:56:21,959 --> 00:56:22,750
添加到应用程序 

1088
00:56:22,750 --> 00:56:25,720
这只是love.window.setTitle 

1089
00:56:25,720 --> 00:56:31,530
标题 到目前为止我们的申请 我不完全确定是什么--

1090
00:56:31,530 --> 00:56:35,110
它默认地说 我想它说--

1091
00:56:35,110 --> 00:56:36,650
上面写了什么--没有标题 

1092
00:56:36,650 --> 00:56:37,150
嗯 

1093
00:56:37,150 --> 00:56:41,410
所以这不是--这是一层或多或少的缺乏光泽 

1094
00:56:41,410 --> 00:56:43,820
如果能迅速解决这个问题 那就太好了 

1095
00:56:43,820 --> 00:56:47,937
所以我们将调用一个名为love.window.setTitle的函数 

1096
00:56:47,937 --> 00:56:49,520
这将很快解决这个问题 

1097
00:56:49,520 --> 00:56:52,900
我们可以让它看起来像是我们已经把细节记下来了 

1098
00:56:52,900 --> 00:56:57,160
然后 实际上将让我们决定是否

1099
00:56:57,160 --> 00:56:59,500
我们要么跑得很好 要么跑得很差

1100
00:56:59,500 --> 00:57:04,180
是一个名为love.timer.getfraMesperSecd.getFPS的函数 

1101
00:57:04,180 --> 00:57:07,700
这是爱无偿赐予我们的东西

1102
00:57:07,700 --> 00:57:09,950
让我们可以很容易地随心所欲地拍打它 

1103
00:57:09,950 --> 00:57:11,866
我们可以将其打印到控制台 或者我们可以

1104
00:57:11,866 --> 00:57:13,420
直接将其绘制到我们的应用程序 

1105
00:57:13,420 --> 00:57:15,640
在这种情况下 我们将执行后一种操作 

1106
00:57:15,640 --> 00:57:19,800
所以我要继续前进 去爱--

1107
00:57:19,800 --> 00:57:24,390
或者是我们主场的乒乓球6 

1108
00:57:24,390 --> 00:57:27,830
如果我们继续看这条线--

1109
00:57:32,190 --> 00:57:34,460
它在哪里--64行 

1110
00:57:34,460 --> 00:57:37,600
Love.window.setTitlePong 简单快捷 

1111
00:57:37,600 --> 00:57:39,770
现在 我们的窗口标题被适当地设置 

1112
00:57:39,770 --> 00:57:49,810
如果我们下到198号线 我已经决定

1113
00:57:49,810 --> 00:57:54,850
为了在一个单独的函数中对其进行拆分 

1114
00:57:54,850 --> 00:57:57,640
在第198行调用了Display FPS 

1115
00:57:57,640 --> 00:58:02,320
并且该函数是在行207上定义的 因此函数显示FPS 

1116
00:58:02,320 --> 00:58:03,570
不使用任何参数 

1117
00:58:03,570 --> 00:58:07,160
它的唯一目标是将我们当前的FPS绘制到屏幕上 

1118
00:58:07,160 --> 00:58:10,000
所以我们要将当前字体设置为小字体 

1119
00:58:10,000 --> 00:58:13,990
我们将设定我们的颜色--这就是我之前提到的 我们

1120
00:58:13,990 --> 00:58:19,090
可以将Love的渲染颜色设置为RGBA的四倍 

1121
00:58:19,090 --> 00:58:24,580
而我们画出的任何超出这一点的东西都会被画在--

1122
00:58:24,580 --> 00:58:27,140
不管是什么颜色 它都会被吸引过来 

1123
00:58:27,140 --> 00:58:32,485
所以 在这种情况下 我们给它红色 0,255 在绿色 0 蓝色 255

1124
00:58:32,485 --> 00:58:35,110
完全不透明 其效果是将我们的颜色设置为

1125
00:58:35,110 --> 00:58:36,640
完全是绿色的 

1126
00:58:36,640 --> 00:58:40,360
然后是love.raphics.print 我们目前的FPS--

1127
00:58:40,360 --> 00:58:45,700
字符串 然后是当前的FPS 即love.timer.getFPS 

1128
00:58:45,700 --> 00:58:49,590
但它会将其作为一个数字返回 并且默认情况下 

1129
00:58:49,590 --> 00:58:52,480
Lua不允许您连接字符串和数字 

1130
00:58:52,480 --> 00:58:55,790
所以我们要在这里连接这个运算符 

1131
00:58:55,790 --> 00:58:58,180
这是在Lua中进行字符串连接的方法 

1132
00:58:58,180 --> 00:59:00,013
我们将调用两个字符串函数 

1133
00:59:00,013 --> 00:59:01,792
所以我们来看看Love Timer.FPS 

1134
00:59:01,792 --> 00:59:03,500
我们要把它做成一根线 然后

1135
00:59:03,500 --> 00:59:05,110
我们将在这里将其连接起来 

1136
00:59:05,110 --> 00:59:08,832
然后我们将在该值上调用love.graph print 

1137
00:59:08,832 --> 00:59:10,540
然后我们会把它设为10 10 

1138
00:59:10,540 --> 00:59:14,360
所以把它从屏幕的左上角移一点 

1139
00:59:14,360 --> 00:59:18,310
因此 这将产生Go to Pong 6的效果 我们运行它 

1140
00:59:18,310 --> 00:59:20,587
我们现在可以看到它从0和52开始 因为它

1141
00:59:20,587 --> 00:59:22,420
必须在它之前收集几帧数据

1142
00:59:22,420 --> 00:59:25,090
有一个我们可以实际使用的数字 

1143
00:59:25,090 --> 00:59:32,011
但是我们看到FPS在60 所以我们的游戏运行 否则 还是一样的 

1144
00:59:32,011 --> 00:59:32,760
完全是随机的 

1145
00:59:32,760 --> 00:59:36,820
有点坏了 不过没关系 我们会修好的 

1146
00:59:36,820 --> 00:59:39,850
但目前我们有一个问题 那就是

1147
00:59:39,850 --> 00:59:43,210
我们的球直接穿过了我们的球拍 

1148
00:59:43,210 --> 00:59:45,274
那么 我们如何解决这个问题呢？

1149
00:59:49,070 --> 00:59:51,640
我们需要一些检测碰撞的方法 

1150
00:59:51,640 --> 00:59:59,350
因此 在2D游戏中 通常存在AA、BB碰撞检测的概念 

1151
00:59:59,350 --> 01:00:04,750
这是轴对齐边界框碰撞检测 它

1152
01:00:04,750 --> 01:00:09,124
意味着我们有边界框 只有矩形、四边形、

1153
01:00:09,124 --> 01:00:12,040
它们具有不旋转的x和y以及宽度和高度 

1154
01:00:12,040 --> 01:00:14,470
所以它们完全与我们的轴线对齐 

1155
01:00:14,470 --> 01:00:16,810
它们是完全平行垂直的 

1156
01:00:16,810 --> 01:00:22,660
所以我们能得到这个简单数学的唯一方法 AA-BB碰撞

1157
01:00:22,660 --> 01:00:25,982
如果我们的盒子没有旋转 检测工作就会起作用 

1158
01:00:25,982 --> 01:00:27,440
它们必须完全一致 

1159
01:00:27,440 --> 01:00:30,860
但如果是这样 我们有一个非常简单的算法 

1160
01:00:30,860 --> 01:00:34,600
那就是我们只是要确保我们的盒子没有边缘

1161
01:00:34,600 --> 01:00:39,290
在我们的--另一个矩形的相对边缘之外 

1162
01:00:39,290 --> 01:00:45,070
所以如果我们有一个矩形--我将在这里的屏幕上说明这一点 

1163
01:00:45,070 --> 01:00:47,290
我们有两个长方形 

1164
01:00:47,290 --> 01:00:53,380
如果这条顶边在这条边下面 我们知道

1165
01:00:53,380 --> 01:00:56,530
无论如何 它们不会相交--它们不会相交 

1166
01:00:56,530 --> 01:00:58,720
它不可能做到 因为它就在下面 

1167
01:00:58,720 --> 01:01:02,080
所以不管它在x轴和y轴上的什么位置 如果它在这里下面 

1168
01:01:02,080 --> 01:01:04,120
这不是撞车 

1169
01:01:04,120 --> 01:01:08,450
如果这条边在这个矩形的这一边 

1170
01:01:08,450 --> 01:01:11,950
我们也知道 这两个盒子不可能重叠 

1171
01:01:11,950 --> 01:01:15,340
它适用于每一条边 只要它是相对的边 

1172
01:01:15,340 --> 01:01:19,450
所以如果这条边在这条下面 如果这条边在这条上面 

1173
01:01:19,450 --> 01:01:22,240
如果这条边在右边 这条边在左边 

1174
01:01:22,240 --> 01:01:25,790
这意味着无论发生什么 这些盒子都不会碰撞 

1175
01:01:25,790 --> 01:01:28,600
所以我们可以简单地做四个条件 

1176
01:01:28,600 --> 01:01:38,500
我们可以说 如果rec1.x不大于rec2.x 加上rec2.wide 

1177
01:01:38,500 --> 01:01:43,900
并且rec1.x加上rec1.wide不小于rec2.x 

1178
01:01:43,900 --> 01:01:49,870
所以如果这两条边没有超出它们的相对边 y也是一样的 

1179
01:01:49,870 --> 01:01:55,090
Y加上rec1的高度 我们知道我们有碰撞 

1180
01:01:55,090 --> 01:01:59,830
我们知道这一点 因为我们还没有达到这些标准中的任何一项 

1181
01:01:59,830 --> 01:02:05,680
但我们知道 如果这不是真的 如果...

1182
01:02:05,680 --> 01:02:09,300
其中一条边没有超过另一条边 那么它--

1183
01:02:09,300 --> 01:02:10,820
我们确实发生了碰撞 

1184
01:02:10,820 --> 01:02:12,380
因此 这将是真的 

1185
01:02:12,380 --> 01:02:14,660
因此 我们将在代码中看到这一点 

1186
01:02:14,660 --> 01:02:26,200
Go to Pong 7 在第113行 我们有一个功能

1187
01:02:26,200 --> 01:02:29,300
我们称之为球碰撞 

1188
01:02:29,300 --> 01:02:31,684
我们的Ball类有一个名为Collides的函数 

1189
01:02:31,684 --> 01:02:33,850
那么让我们继续来看看我们的球课 

1190
01:02:40,070 --> 01:02:42,740
在本例中 我们将函数定义为

1191
01:02:42,740 --> 01:02:45,020
它接受一个划桨参数 所以它是

1192
01:02:45,020 --> 01:02:47,210
将与另一个矩形进行比较 该矩形

1193
01:02:47,210 --> 01:02:50,410
具有XY和宽度和高度 

1194
01:02:50,410 --> 01:02:57,470
我们说 如果rx大于划桨x 再加上划桨

1195
01:02:57,470 --> 01:03:01,850
宽度 这意味着如果RX大于右边缘 

1196
01:03:01,850 --> 01:03:04,880
所以如果我们的左上角大于--

1197
01:03:04,880 --> 01:03:08,250
或者就是我们的左边--比右边大 

1198
01:03:08,250 --> 01:03:10,190
我们知道我们不可能相撞 

1199
01:03:10,190 --> 01:03:16,130
如果它比其他矩形大 情况也是一样的 

1200
01:03:16,130 --> 01:03:20,250
Self.x加上self.wide 

1201
01:03:20,250 --> 01:03:21,350
不 对不起 

1202
01:03:21,350 --> 01:03:24,040
在这种情况下 如果球拍的x是--

1203
01:03:24,040 --> 01:03:26,840
它的操作基本相同 但从划桨的角度来看 

1204
01:03:26,840 --> 01:03:31,130
如果球拍大于右侧的矩形 

1205
01:03:31,130 --> 01:03:33,525
如果它沿着右侧更远地越过右侧边缘 

1206
01:03:33,525 --> 01:03:35,150
我们知道不可能发生碰撞 

1207
01:03:35,150 --> 01:03:36,470
这是不可能的 

1208
01:03:36,470 --> 01:03:38,270
Y也是如此 

1209
01:03:38,270 --> 01:03:42,050
如果y--self.y 那么这个球是y--

1210
01:03:42,050 --> 01:03:45,060
大于划桨的y 加上划桨高度 

1211
01:03:45,060 --> 01:03:47,420
所以如果它在桨的边缘以下 因为我们是

1212
01:03:47,420 --> 01:03:51,980
考虑到高度 或者如果划桨的y更大

1213
01:03:51,980 --> 01:03:57,140
比这个球的y加本身高 然后我们

1214
01:03:57,140 --> 01:04:00,440
要知道 这也不可能是碰撞 

1215
01:04:00,440 --> 01:04:03,206
但如果这不是真的 那么我们需要返回真 

1216
01:04:06,170 --> 01:04:11,050
所以如果我们回到主干道--不 那是错误的主干道 

1217
01:04:11,050 --> 01:04:16,840
我们回到Main 这里是Lua 

1218
01:04:16,840 --> 01:04:19,590
我们要把球打成碰撞球 

1219
01:04:19,590 --> 01:04:22,030
所以如果我们处于我们的游戏状态 如果我们处于--抱歉 

1220
01:04:22,030 --> 01:04:25,810
如果我们处于游戏状态 如果游戏状态等于游戏 

1221
01:04:25,810 --> 01:04:29,650
如果球与一号球员相撞 那么一号球员就是左桨 

1222
01:04:29,650 --> 01:04:36,400
因此 如果检测到碰撞 那么球.dx和dx就是我们的x速度 

1223
01:04:36,400 --> 01:04:39,500
所以它在x轴上移动的方向是什么 

1224
01:04:39,500 --> 01:04:44,230
所以如果它消失了 它就会向左移动--

1225
01:04:44,230 --> 01:04:46,067
如果我们检测到碰撞 

1226
01:04:46,067 --> 01:04:48,400
它是向左还是向右移动并不重要 

1227
01:04:48,400 --> 01:04:52,842
但我们需要--我们需要做的是将其设置为负值 

1228
01:04:52,842 --> 01:04:54,550
因为如果它向左移动 我们说--

1229
01:04:54,550 --> 01:04:59,380
假设它在负20像素处向左移动 我们设置为20 

1230
01:04:59,380 --> 01:05:01,840
DX现在是20 它将开始向右移动 

1231
01:05:01,840 --> 01:05:06,880
它会产生反转其x速度的效果

1232
01:05:06,880 --> 01:05:09,170
因此 扭转了它的方向 

1233
01:05:09,170 --> 01:05:12,280
但我们在这里用1.03倍做的

1234
01:05:12,280 --> 01:05:15,070
我们只是为了加快比赛速度而增加了一点 

1235
01:05:15,070 --> 01:05:18,460
因为我们不希望游戏进入永恒 只是有相同的速度 

1236
01:05:18,460 --> 01:05:20,230
这不会增加人们的兴奋感 

1237
01:05:20,230 --> 01:05:23,200
我们想要让事情继续下去 我们想要获得一些动力 

1238
01:05:23,200 --> 01:05:25,660
所以我们要做的就是把Ball.dx

1239
01:05:25,660 --> 01:05:30,707
等于它的负值乘以我们任意确定的定标器 

1240
01:05:30,707 --> 01:05:32,665
在这种情况下 我决定这应该是重点--

1241
01:05:32,665 --> 01:05:37,060
1.03 所以每次都会增加3% 

1242
01:05:37,060 --> 01:05:41,515
然后如果我们有一个--

1243
01:05:41,515 --> 01:05:45,760
我们的球--因为它被添加了 它的x速度

1244
01:05:45,760 --> 01:05:48,550
将每个帧添加到其位置 我们希望

1245
01:05:48,550 --> 01:05:52,620
以确保它不会像在我们的桨里面一样 

1246
01:05:52,620 --> 01:05:55,600
因为它可能会移动一定数量的像素

1247
01:05:55,600 --> 01:05:59,260
向左或向右 因为适用相同的操作 

1248
01:05:59,260 --> 01:06:01,750
因此 这两者有点像在彼此的顶部 

1249
01:06:01,750 --> 01:06:04,161
我们想要--我们想要改变它 我们想要重置它 

1250
01:06:04,161 --> 01:06:06,910
所以我们要做的是--因为它会检测到另一次碰撞

1251
01:06:06,910 --> 01:06:08,040
如果是这样的话马上就去 

1252
01:06:08,040 --> 01:06:10,270
如果它 在下一帧中 它在那个球拍内 

1253
01:06:10,270 --> 01:06:13,860
它会说它仍在与那把桨相撞

1254
01:06:13,860 --> 01:06:15,610
所以它会再次改变速度 

1255
01:06:15,610 --> 01:06:18,430
它将产生无限弹跳的效果

1256
01:06:18,430 --> 01:06:19,804
在划桨内来回摆动 

1257
01:06:19,804 --> 01:06:21,160
我们不希望这种情况发生 

1258
01:06:21,160 --> 01:06:23,466
因此 如果我们检测到碰撞 我们想要移动它 

1259
01:06:23,466 --> 01:06:26,590
我们想要确保它完全在拍子的碰撞框之外 

1260
01:06:26,590 --> 01:06:31,390
所以我们说的是 bal.x得到玩家1 x 加上5 

1261
01:06:31,390 --> 01:06:34,210
加5 因为这是桨的宽度 

1262
01:06:34,210 --> 01:06:38,401
所以这只有一次你检测到碰撞的效果 负集--

1263
01:06:38,401 --> 01:06:40,150
X速度变为负值 然后立即

1264
01:06:40,150 --> 01:06:44,830
把它向右移到左桨的右边 

1265
01:06:44,830 --> 01:06:47,170
我们在这里也在做同样的事情 

1266
01:06:47,170 --> 01:06:51,670
如果球撞上了一两个球 我们就是在做--我们在否定或颠倒

1267
01:06:51,670 --> 01:06:54,340
它的x速度 

1268
01:06:54,340 --> 01:06:57,520
然后--这是同样的手术 

1269
01:06:57,520 --> 01:07:01,360
但由于它是基于--左上角 

1270
01:07:01,360 --> 01:07:04,540
我们不能减去5% 那就说不通了 

1271
01:07:04,540 --> 01:07:07,840
我们要把它减去4 因为那是球的宽度 

1272
01:07:07,840 --> 01:07:11,310
所以如果我们把它减去5 我们就会有一个像素的空间 

1273
01:07:11,310 --> 01:07:15,010
我们在这个例子中加了5 因为我们是

1274
01:07:15,010 --> 01:07:16,667
从右边进来 

1275
01:07:16,667 --> 01:07:19,750
我们只想确保它在划桨的正确边缘 

1276
01:07:19,750 --> 01:07:22,240
所以我们将其设置为玩家1e.x 

1277
01:07:22,240 --> 01:07:25,960
在这种情况下 我们使用的是负四

1278
01:07:25,960 --> 01:07:28,210
因为这就是球的宽度 

1279
01:07:28,210 --> 01:07:30,995
所以我们想把它移到左边 球的宽度 

1280
01:07:30,995 --> 01:07:34,120
这将产生右桨的效果 如果发生碰撞 

1281
01:07:34,120 --> 01:07:36,520
它只会被移到另一边 右边--球

1282
01:07:36,520 --> 01:07:40,150
将在他们的两个边缘接触到球拍 

1283
01:07:40,150 --> 01:07:45,700
在第118行 我们解决了之前的问题 

1284
01:07:45,700 --> 01:07:48,580
发生在...

1285
01:07:48,580 --> 01:07:50,830
哦 对不起 我想的不是这个 

1286
01:07:50,830 --> 01:07:57,880
如果有碰撞 我们需要球的y速度

1287
01:07:57,880 --> 01:07:59,350
每次都是随机的

1288
01:07:59,350 --> 01:08:02,470
所以当我们玩这个游戏的时候

1289
01:08:02,470 --> 01:08:05,320
我们检测到两个电极板发生了碰撞

1290
01:08:05,320 --> 01:08:08,320
我们不想每次都从同一个角度来回

1291
01:08:08,320 --> 01:08:11,710
因为这个博弈会无限地重复

1292
01:08:11,710 --> 01:08:14,291
同样的角度会不断重复

1293
01:08:14,291 --> 01:08:15,290
我们不希望这样 

1294
01:08:15,290 --> 01:08:19,689
我们希望球从球拍上反弹的方式有一些变化 

1295
01:08:19,689 --> 01:08:22,130
所以这个方法的作用是 仍然在这个条件下 

1296
01:08:22,130 --> 01:08:25,210
如果球与一号玩家相撞

1297
01:08:25,210 --> 01:08:31,010
如果球的y轴速度为负 

1298
01:08:31,010 --> 01:08:32,740
那我们就想让它一直是负的

1299
01:08:32,740 --> 01:08:34,823
我们还是想要球--就像如果球来了

1300
01:08:34,823 --> 01:08:37,420
以一种向上的角度 它从球拍上弹开 

1301
01:08:37,420 --> 01:08:39,290
我们希望x速度移动 

1302
01:08:39,290 --> 01:08:42,819
我们希望它向相反的方向运动 但我们希望球继续向上运动 

1303
01:08:42,819 --> 01:08:45,069
我们不想让球反弹回来 

1304
01:08:45,069 --> 01:08:45,950
完全说不通

1305
01:08:45,950 --> 01:08:47,680
我们不想忽略y方向的速度 

1306
01:08:47,680 --> 01:08:49,638
所以我们保持y速度为负 

1307
01:08:49,638 --> 01:08:53,050
我们将它设置为10到150之间的负值 

1308
01:08:53,050 --> 01:08:54,050
这是武断的 

1309
01:08:54,050 --> 01:08:55,700
你可以随意设置

1310
01:08:55,700 --> 01:08:58,840
如果y方向的速度为正 我们也要做同样的事情 

1311
01:08:58,840 --> 01:09:02,229
我们想让球

1312
01:09:02,229 --> 01:09:07,510
如果球已经落下来了 我们希望它朝正方向运动 

1313
01:09:07,510 --> 01:09:10,569
所以我们在做同样的事情 

1314
01:09:10,569 --> 01:09:13,403
在参与人2的例子中也是一样的逻辑 

1315
01:09:13,403 --> 01:09:16,319
然后我以为我看到的是这个

1316
01:09:16,319 --> 01:09:20,649
但这就是我们如何解决屏幕的上下边界的问题 

1317
01:09:20,649 --> 01:09:21,149
对的

1318
01:09:21,149 --> 01:09:24,750
因为这是一件事来解决我们有桨的事实

1319
01:09:24,750 --> 01:09:27,720
现在让球偏转 但我们不想要球

1320
01:09:27,720 --> 01:09:30,270
要无限地高于屏幕的顶部边缘 

1321
01:09:30,270 --> 01:09:32,080
或屏幕的底边 

1322
01:09:32,080 --> 01:09:34,842
所以这只是一个简单的if条件 

1323
01:09:34,842 --> 01:09:37,050
我们只是说如果球小于或等于

1324
01:09:37,050 --> 01:09:40,407
零 这意味着如果球在屏幕的顶端 

1325
01:09:40,407 --> 01:09:42,240
只需将其设置为零 确保它不会

1326
01:09:42,240 --> 01:09:46,319
走到屏幕边缘上方 然后否定它的宽速度 

1327
01:09:46,319 --> 01:09:48,490
因此 它会立即开始向下 

1328
01:09:48,490 --> 01:09:50,273
是 

1329
01:09:50,273 --> 01:09:53,880
观众：这个问题是关于乒乓球7号第113行的 

1330
01:09:53,880 --> 01:09:57,270
难道球dx和y的移动不能

1331
01:09:57,270 --> 01:10:01,660
在做球碰撞功能时 如果有碰撞？

1332
01:10:01,660 --> 01:10:06,330
科尔顿·奥格登：如果球相撞 球的功能会发生变化--不 

1333
01:10:06,330 --> 01:10:08,580
撞球--碰撞功能

1334
01:10:08,580 --> 01:10:11,470
是--它只返回真或假 

1335
01:10:11,470 --> 01:10:14,520
所以它会是--

1336
01:10:14,520 --> 01:10:19,530
我的意思是 我认为你可以用这种方式重构它 

1337
01:10:19,530 --> 01:10:21,540
但碰撞的目的并不是为了

1338
01:10:21,540 --> 01:10:23,819
任何像那样的副作用 

1339
01:10:23,819 --> 01:10:25,860
它的唯一目的只是返回True或False 

1340
01:10:25,860 --> 01:10:28,651
因为我们可以做任何--我们可以有任何我们想要的行为 

1341
01:10:28,651 --> 01:10:31,560
在碰撞函数中 我们可能不一定想要移动球

1342
01:10:31,560 --> 01:10:33,601
或者做任何事情 我们可能只希望它返回TRUE

1343
01:10:33,601 --> 01:10:35,280
把一些东西打印到控制台上 

1344
01:10:35,280 --> 01:10:37,920
所以 我认为 从工程学的角度来看 

1345
01:10:37,920 --> 01:10:40,847
只要有一个简单的真或假函数就更有意义了 

1346
01:10:40,847 --> 01:10:43,680
然后确定你希望它如何真正影响你的比赛

1347
01:10:43,680 --> 01:10:48,310
在您的主函数或某个其他函数中声明 

1348
01:10:48,310 --> 01:10:48,810
好的 

1349
01:10:51,420 --> 01:10:53,570
所以 是的 我们去了这里 

1350
01:10:53,570 --> 01:10:57,660
屏幕的顶部边缘 然后是屏幕的底部边缘 

1351
01:10:57,660 --> 01:11:00,840
如果是球 那也是一样的东西 只是屏幕的底部边缘 

1352
01:11:00,840 --> 01:11:04,770
如果球Y大于或等于虚拟高度减4 

1353
01:11:04,770 --> 01:11:06,840
而我们做的实际上是四分之差 为什么？

1354
01:11:06,840 --> 01:11:08,190
观众：可能会卡在底部

1355
01:11:08,190 --> 01:11:09,450
科尔顿·奥格登：没错 

1356
01:11:09,450 --> 01:11:12,180
所以我们想确保我们写下--只要我们--

1357
01:11:12,180 --> 01:11:15,310
球的底边接触屏幕的底部 

1358
01:11:15,310 --> 01:11:18,720
我们想要检测碰撞 然后我们想说球 Y 那个--

1359
01:11:18,720 --> 01:11:22,290
获取虚拟高度减去4 以防超出底部边缘

1360
01:11:22,290 --> 01:11:25,600
根据经过了多少时间和速度有多大 

1361
01:11:25,600 --> 01:11:28,320
你想立刻把它立起来 这样它就在边缘

1362
01:11:28,320 --> 01:11:29,910
所以这是一次干净利落的反弹 

1363
01:11:29,910 --> 01:11:32,340
然后 我们想要同样地否定y速度

1364
01:11:32,340 --> 01:11:35,500
就像我们在上面做的那样 

1365
01:11:35,500 --> 01:11:46,160
因此 如果我们在这里运行我们的程序 Pong 7 看起来是一样的 

1366
01:11:46,160 --> 01:11:50,200
但现在球开始反弹了 

1367
01:11:50,200 --> 01:11:52,810
注意 它得到了一个否定的--它有一个随机的--它

1368
01:11:52,810 --> 01:11:54,601
看起来像是在底部边缘以下

1369
01:11:54,601 --> 01:11:57,760
因为显示器当前的分辨率是720 这是窗口分辨率 

1370
01:11:57,760 --> 01:11:59,740
但它也在从底部边缘反弹 

1371
01:11:59,740 --> 01:12:03,250
如果你注意到 每次的角度都有一点不同 

1372
01:12:03,250 --> 01:12:10,180
因为我们给它一个随机的y速度 a y--

1373
01:12:10,180 --> 01:12:10,680
嗯 

1374
01:12:10,680 --> 01:12:14,770
然后这就是影响--哦 我搞砸了 

1375
01:12:14,770 --> 01:12:17,784
我想要举例说明速度的提高 

1376
01:12:17,784 --> 01:12:19,450
这需要一点时间 

1377
01:12:19,450 --> 01:12:25,180
但每次它探测到碰撞 它就会扩大它的--

1378
01:12:25,180 --> 01:12:28,346
X速度增加了1.03倍 

1379
01:12:28,346 --> 01:12:30,220
所以它会让它更快一点 

1380
01:12:30,220 --> 01:12:31,840
现在 Y角有点太陡了 

1381
01:12:31,840 --> 01:12:33,950
所以这需要永远的时间来说明这一点 

1382
01:12:33,950 --> 01:12:37,190
但我们将在后面的示例中看到这一点 

1383
01:12:37,190 --> 01:12:42,290
因此 我们已经掌握了游戏的基本知识 

1384
01:12:42,290 --> 01:12:43,960
但我们如何计分呢？

1385
01:12:43,960 --> 01:12:47,518
决定我们如何在乒乓球项目上得分的因素是什么？

1386
01:12:47,518 --> 01:12:48,579
左或右 

1387
01:12:48,579 --> 01:12:51,120
只要它穿过屏幕的左边缘或右边缘 

1388
01:12:51,120 --> 01:12:53,635
那么 我们需要做些什么呢？

1389
01:12:53,635 --> 01:12:55,054
观众：[听不见]

1390
01:12:55,054 --> 01:12:57,000
科尔顿·奥格登：我们确实需要一个柜台 我们

1391
01:12:57,000 --> 01:12:59,700
还需要监控球是否有

1392
01:12:59,700 --> 01:13:03,720
与屏幕的左边界或右边界发生冲突 

1393
01:13:03,720 --> 01:13:06,150
然后让计数器递增 

1394
01:13:06,150 --> 01:13:08,970
所以我们接下来来看看乒乓球8

1395
01:13:08,970 --> 01:13:13,330
看看这是如何实施的 

1396
01:13:13,330 --> 01:13:18,352
我们在第88行和第89行有一些反变量 一号玩家得分 

1397
01:13:18,352 --> 01:13:19,060
二号玩家得分 

1398
01:13:19,060 --> 01:13:21,640
我们已经拥有它们很长时间了 但我们还没有用过它们 

1399
01:13:21,640 --> 01:13:23,440
我们只是用它们来画到屏幕上 

1400
01:13:23,440 --> 01:13:27,940
我们现在实际上要递增它们 并将它们显示为记分

1401
01:13:27,940 --> 01:13:31,390
我们代码中的变量 

1402
01:13:31,390 --> 01:13:33,290
我以为我已经在《乒乓球8》中实现了 

1403
01:13:33,290 --> 01:13:36,760
但我想我可能遗漏了分数的实际增量 

1404
01:13:36,760 --> 01:13:39,220
但这就是与这个例子相关的逻辑 

1405
01:13:39,220 --> 01:13:43,030
因此 如果bal.x小于零 这只是

1406
01:13:43,030 --> 01:13:48,430
意味着如果我们已经越过了屏幕的左边缘 

1407
01:13:48,430 --> 01:13:49,840
暂时忽略发球手 

1408
01:13:49,840 --> 01:13:52,640
重要的是 我们现在是在为二号选手得分 

1409
01:13:52,640 --> 01:13:54,580
获得玩家TWP分数 加1 

1410
01:13:54,580 --> 01:13:56,140
只是一个简单的增量 

1411
01:13:56,140 --> 01:13:57,880
然后我们重新设置球 

1412
01:13:57,880 --> 01:13:59,740
这里也是一样 

1413
01:13:59,740 --> 01:14:01,990
如果Ball.x大于虚拟宽度 

1414
01:14:01,990 --> 01:14:08,860
所以通过屏幕的右边缘 实际上它可能是--

1415
01:14:08,860 --> 01:14:12,120
如果球x加4大于虚拟宽度 

1416
01:14:12,120 --> 01:14:14,000
那么 它也会产生同样的效果 

1417
01:14:14,000 --> 01:14:16,947
但是 事实上 不是的 因为我们想确保

1418
01:14:16,947 --> 01:14:19,030
当他们得分时 我们根本看不到球 

1419
01:14:19,030 --> 01:14:20,488
所以 是的 这实际上是正确的 

1420
01:14:20,488 --> 01:14:23,920
如果Ball.x大于虚拟宽度 则发球手得到2 

1421
01:14:23,920 --> 01:14:25,895
一人得分等于一人一分加一 

1422
01:14:25,895 --> 01:14:27,520
然后我们要重置球 

1423
01:14:27,520 --> 01:14:29,050
发球手 

1424
01:14:29,050 --> 01:14:33,370
所以现在我们要谈的是服务的理念 

1425
01:14:33,370 --> 01:14:35,680
所以当我们开始游戏的时候--

1426
01:14:35,680 --> 01:14:37,328
那么让我们继续来看看--

1427
01:14:42,004 --> 01:14:44,920
我们现在要去Pong 所以我们要直接去Pong 9 

1428
01:14:44,920 --> 01:14:47,700
然后我们需要看看什么是状态机 

1429
01:14:47,700 --> 01:14:50,670
因此 目前在游戏中 我们已经讨论了一点状态 

1430
01:14:50,670 --> 01:14:53,700
我们已经进入了开始状态 这意味着比赛已经准备好了

1431
01:14:53,700 --> 01:14:56,857
只需按下Enter键 球就会以随机的方向飞出 

1432
01:14:56,857 --> 01:14:58,190
然后我们得到了播放状态 

1433
01:14:58,190 --> 01:15:02,490
比赛状态被设置为我们的球拍与球相互作用 

1434
01:15:02,490 --> 01:15:06,000
然后基本上记录下分数 

1435
01:15:06,000 --> 01:15:08,010
状态机非常重要 

1436
01:15:08,010 --> 01:15:11,400
这在游戏开发中是一个普遍存在的概念 

1437
01:15:11,400 --> 01:15:14,730
这只是意味着 我们如何监控我们所处的状态

1438
01:15:14,730 --> 01:15:19,050
以及这些状态之间发生了什么转变 以产生新的状态 

1439
01:15:19,050 --> 01:15:22,230
每个单独的州都有自己的逻辑 

1440
01:15:22,230 --> 01:15:26,220
通过将这些状态的逻辑分开 

1441
01:15:26,220 --> 01:15:32,820
我们可以将我们的代码扩展得更大 而不是针对--

1442
01:15:32,820 --> 01:15:36,270
这张特殊的图表是一个例子 说明了你可能会有什么状态

1443
01:15:36,270 --> 01:15:40,290
机器对于像马里奥这样的角色来说 你有一个躲避状态 一个释放

1444
01:15:40,290 --> 01:15:43,320
接受向下的状态--向内--就像向下的输入 

1445
01:15:43,320 --> 01:15:45,750
所以如果我们往下放 它就会变得站立 

1446
01:15:45,750 --> 01:15:49,130
所以在俯冲状态下 转换为松开向下键 

1447
01:15:49,130 --> 01:15:50,270
他站了起来 

1448
01:15:50,270 --> 01:15:52,140
站立键 按下向下键 

1449
01:15:52,140 --> 01:15:56,350
他开始躲避 这些都是状态和转变 

1450
01:15:56,350 --> 01:16:01,770
这些单独的状态是他行为的总体表现

1451
01:16:01,770 --> 01:16:03,080
基本上 总体上是这样的 

1452
01:16:03,080 --> 01:16:06,240
同样的逻辑也适用于我们的游戏 

1453
01:16:06,240 --> 01:16:09,090
我们有比赛状态 我们有发球状态 

1454
01:16:09,090 --> 01:16:11,010
我们想要在州立大学打一场比赛 

1455
01:16:11,010 --> 01:16:16,300
如果某人得了10分 那么它应该说 哦 获胜者是x 

1456
01:16:16,300 --> 01:16:19,290
你可以定义任意数量的状态 它--

1457
01:16:19,290 --> 01:16:22,540
这取决于你的模型 无论你想要开发什么游戏 

1458
01:16:22,540 --> 01:16:24,690
例如 就像超级马里奥有一个标题屏幕一样 

1459
01:16:24,690 --> 01:16:27,864
也许你的比赛已经达到了高分状态 

1460
01:16:27,864 --> 01:16:30,030
您想要显示游戏中的所有高分

1461
01:16:30,030 --> 01:16:35,470
我们将在下周的一堂课上展示这一点 

1462
01:16:35,470 --> 01:16:37,050
但这就是状态机的含义 

1463
01:16:37,050 --> 01:16:40,860
它只是--它可以同时处于任何一种特定的状态 

1464
01:16:40,860 --> 01:16:45,270
而这些转变让你可以在你的状态之间切换 

1465
01:16:45,270 --> 01:16:49,150
而且每个状态都有进出其他状态的转换 

1466
01:16:49,150 --> 01:16:51,830
我们将在Pong 9中使用这一点 

1467
01:16:51,830 --> 01:16:54,870
所以除了说明比分之外 我们还将

1468
01:16:54,870 --> 01:16:59,370
开始跟踪的不仅仅是开始和播放状态 

1469
01:16:59,370 --> 01:17:02,560
我们实际上要开始对发球状态进行建模 

1470
01:17:02,560 --> 01:17:05,018
所以让我继续说明这是什么样子的 

1471
01:17:08,370 --> 01:17:12,630
因此 如果我们在这里 我只需按Enter键 

1472
01:17:12,630 --> 01:17:16,140
我们像往常一样从开始状态开始 但我按了Enter

1473
01:17:16,140 --> 01:17:18,180
现在它写着一号玩家发球 

1474
01:17:18,180 --> 01:17:19,970
所以我们实际上是在提供服务 

1475
01:17:19,970 --> 01:17:22,530
因此 如果我按照它的指示再次按Enter键 

1476
01:17:22,530 --> 01:17:25,290
一号球员在左边 球应该移到右边 

1477
01:17:25,290 --> 01:17:27,640
事实的确如此 

1478
01:17:27,640 --> 01:17:33,010
因此 作为二号玩家 我将继续努力 故意输掉比赛 

1479
01:17:33,010 --> 01:17:34,590
现在轮到二号选手发球了 

1480
01:17:34,590 --> 01:17:38,370
因此 无论哪个角色 无论哪个球员输了 都应该再次发球 

1481
01:17:38,370 --> 01:17:40,560
现在如果我按Enter键 请注意当我们

1482
01:17:40,560 --> 01:17:42,960
如果是一号球员 球就会向右移动 

1483
01:17:42,960 --> 01:17:46,000
因此 对于第二名球员来说 球向左移动 

1484
01:17:46,000 --> 01:17:49,260
因此 我们现在有了更多的互动 

1485
01:17:49,260 --> 01:17:51,150
我们有不同的州 

1486
01:17:51,150 --> 01:17:53,940
我们开始比赛 然后发球 我们打球 

1487
01:17:53,940 --> 01:17:57,140
所以当舞会直播的时候 当我们真的在做这个的时候 

1488
01:17:57,140 --> 01:17:58,140
我们现在处于游戏状态 

1489
01:17:58,140 --> 01:17:59,800
现在我们处于服务状态 

1490
01:17:59,800 --> 01:18:03,720
那么在这两个--

1491
01:18:03,720 --> 01:18:07,400
某种打球状态和发球状态？

1492
01:18:07,400 --> 01:18:08,804
那里的过渡是什么？

1493
01:18:12,550 --> 01:18:13,950
我们得了一分 

1494
01:18:13,950 --> 01:18:17,800
因此 如果我们查看我们的状态图 并且我们处于播放状态 

1495
01:18:17,800 --> 01:18:23,284
转换到发球状态是x玩家得了一分 

1496
01:18:23,284 --> 01:18:25,450
然后 如果我们处于服务状态 转换

1497
01:18:25,450 --> 01:18:29,180
有人按了Enter键 

1498
01:18:29,180 --> 01:18:30,200
按下Enter键 

1499
01:18:30,200 --> 01:18:33,110
这就是我们想要如何看待我们的游戏

1500
01:18:33,110 --> 01:18:37,820
如果我们有一系列不同的逻辑 

1501
01:18:37,820 --> 01:18:42,500
我们可以从我们的游戏中拿出来 从概念上思考 

1502
01:18:42,500 --> 01:18:46,190
它允许我们将游戏分解成一系列不同的模式和状态 

1503
01:18:46,190 --> 01:18:49,370
而不是真的被所有这些变数负担过重

1504
01:18:49,370 --> 01:18:51,860
可能需要跟踪--或者我们处于什么状态？

1505
01:18:51,860 --> 01:18:53,090
比如 所有这些变量都在做什么？

1506
01:18:53,090 --> 01:18:55,460
我们将看看如何在更多的时间里解决这个问题

1507
01:18:55,460 --> 01:18:57,469
未来几周的模块化时尚 

1508
01:18:57,469 --> 01:18:59,510
请注意 现在 目前我们所做的是

1509
01:18:59,510 --> 01:19:04,010
我们在这里将状态变量设置为某个字符串 

1510
01:19:04,010 --> 01:19:05,990
只要有条件就可以了 

1511
01:19:05,990 --> 01:19:08,960
对于小的例子来说 效果非常好 

1512
01:19:08,960 --> 01:19:14,660
所以 如果 比如说 如果我们处于更新功能和游戏状态--

1513
01:19:14,660 --> 01:19:17,750
看 在这里我们说的是 如果游戏状态设置为服务 

1514
01:19:17,750 --> 01:19:24,430
然后我们对所有变量进行初始化 

1515
01:19:24,430 --> 01:19:27,650
如果游戏状态是PLAY 那么我们需要

1516
01:19:27,650 --> 01:19:31,200
在这里实际执行我们的逻辑 

1517
01:19:31,200 --> 01:19:34,040
所以如果--如果我们在玩这个游戏 这将被称为 

1518
01:19:34,040 --> 01:19:36,980
每一帧 我们要说 如果球与一号球员相撞 

1519
01:19:36,980 --> 01:19:37,730
做所有这些事情 

1520
01:19:37,730 --> 01:19:42,560
然后 这让我们可以在某种程度上考虑我们的游戏 

1521
01:19:42,560 --> 01:19:46,160
这几乎就像在我们的更新函数中拥有单独的更新函数 

1522
01:19:46,160 --> 01:19:49,220
我们将实际了解如何从一次更新中删除这些内容

1523
01:19:49,220 --> 01:19:53,310
在未来几周使用实际的状态机类

1524
01:19:53,310 --> 01:19:56,090
把事情实现得更抽象一点 

1525
01:19:56,090 --> 01:20:01,260
但我要说的是 现在 无论何时我们想要 例如 

1526
01:20:01,260 --> 01:20:04,280
做一个过渡 如果有人在这里得分 

1527
01:20:04,280 --> 01:20:06,760
例如 如果我们要转到屏幕的左侧 

1528
01:20:06,760 --> 01:20:09,320
它的球x小于零 

1529
01:20:09,320 --> 01:20:12,350
我们所要做的就是将这个状态设置为

1530
01:20:12,350 --> 01:20:16,040
然后 我们的更新功能将进行适当的更新 

1531
01:20:16,040 --> 01:20:20,150
所以有什么关于状态机或国家的问题吗

1532
01:20:20,150 --> 01:20:23,196
在乒乓球的背景下工作？

1533
01:20:23,196 --> 01:20:23,696
是 

1534
01:20:23,696 --> 01:20:29,600
听众：所以状态机就是与国家的关系

1535
01:20:29,600 --> 01:20:34,520
抑或是国家的容器？

1536
01:20:34,520 --> 01:20:37,550
科尔顿·奥格登：国家机器是一种--

1537
01:20:37,550 --> 01:20:40,580
总体概念性地查看您的不同状态

1538
01:20:40,580 --> 01:20:42,680
是和他们的转变 是的 

1539
01:20:42,680 --> 01:20:45,560
在接下来的几周里 我们不会实施状态机

1540
01:20:45,560 --> 01:20:47,150
对象或类 

1541
01:20:47,150 --> 01:20:50,120
但在接下来的几周里 我们将看到状态机类

1542
01:20:50,120 --> 01:20:53,240
管理不同状态之间的转换 

1543
01:20:53,240 --> 01:20:54,910
模块化和干净的时尚 

1544
01:20:54,910 --> 01:20:57,140
我们在这里所做的就是我们的状态机

1545
01:20:57,140 --> 01:21:01,050
就是if语句 如果状态等于this 那么就这样做 

1546
01:21:01,050 --> 01:21:03,716
然后将状态更改为某个值 

1547
01:21:03,716 --> 01:21:05,911
观众：所以状态机是一个概念？

1548
01:21:05,911 --> 01:21:07,160
科尔顿·奥格登：这是一个概念 

1549
01:21:07,160 --> 01:21:07,940
是啊

1550
01:21:07,940 --> 01:21:13,880
但是下周我们将看到状态机作为一个对象的实现 

1551
01:21:13,880 --> 01:21:17,010
还有问题吗

1552
01:21:17,010 --> 01:21:17,746
好的.

1553
01:21:17,746 --> 01:21:19,730
酷了

1554
01:21:19,730 --> 01:21:22,850
目前 我们有得分 

1555
01:21:22,850 --> 01:21:26,180
正如我们看到的 参与人1和参与人2的得分

1556
01:21:26,180 --> 01:21:28,820
现在递增 因此呈现在屏幕上

1557
01:21:28,820 --> 01:21:31,940
无论我们走到左边还是右边

1558
01:21:31,940 --> 01:21:33,840
所以我们在记录分数 

1559
01:21:33,840 --> 01:21:38,183
但是我们现在需要什么才能让某人赢呢？

1560
01:21:38,183 --> 01:21:39,937
观众：[听不见] 

1561
01:21:39,937 --> 01:21:40,770
科尔顿·奥格登：什么？

1562
01:21:40,770 --> 01:21:42,021
观众：[听不见] 

1563
01:21:42,021 --> 01:21:43,820
科尔顿·奥格登：是的 

1564
01:21:43,820 --> 01:21:44,630
没错

1565
01:21:44,630 --> 01:21:46,827
所以其实很简单 

1566
01:21:46,827 --> 01:21:49,160
我们真正需要做的就是一个if语句 对吗？

1567
01:21:49,160 --> 01:21:54,260
如果某个人的得分等于某个值 10 那么某个玩家赢了 

1568
01:21:54,260 --> 01:22:00,290
如果我们看参与人 如果你看乒乓球10 我们去主区 

1569
01:22:00,290 --> 01:22:14,080
然后转到这里 第174行 还有第160行 

1570
01:22:14,080 --> 01:22:19,114
我们可以看到它的字面意思是在我们的逻辑中

1571
01:22:19,114 --> 01:22:21,780
之前我们只是测试球是否

1572
01:22:21,780 --> 01:22:23,370
超出了左边或右边的边缘 

1573
01:22:23,370 --> 01:22:26,120
因为这是你需要做检查的地方

1574
01:22:26,120 --> 01:22:28,350
看看是否有人得分 

1575
01:22:28,350 --> 01:22:31,140
所以我们所做的就是在程序的这一部分增加逻辑

1576
01:22:31,140 --> 01:22:34,600
在我们增加他们的分数后说 

1577
01:22:34,600 --> 01:22:38,182
如果它等于10 我们就设置一个值 叫做获胜玩家.

1578
01:22:38,182 --> 01:22:39,390
我们把它设为2 

1579
01:22:39,390 --> 01:22:44,130
如果ball.x小于0 那就意味着参与人1

1580
01:22:44,130 --> 01:22:46,960
因为球越过了屏幕的左边 

1581
01:22:46,960 --> 01:22:50,640
因此 参与人2的得分应该上升 

1582
01:22:50,640 --> 01:22:54,150
因此获胜的参与人也应该是 如果参与人2或者

1583
01:22:54,150 --> 01:22:56,430
2分等于10分 

1584
01:22:56,430 --> 01:23:00,180
在这种情况下 看 我们在这里 我们正在设置一个新的州完成 

1585
01:23:00,180 --> 01:23:04,680
如果不是这样 或者如果他们的分数仍然低于10分 

1586
01:23:04,680 --> 01:23:09,180
我们还是应该--我们应该把球放回发球位 然后重新设置球 

1587
01:23:09,180 --> 01:23:13,450
所以如果我们转到我们的更新功能 这里--

1588
01:23:13,450 --> 01:23:18,090
实际上 我们正在进行更新阶段的工作 

1589
01:23:18,090 --> 01:23:22,320
因此 目前 如果它是完成状态 则球被重置

1590
01:23:22,320 --> 01:23:24,780
但在这种情况下 没有对球进行更新 

1591
01:23:24,780 --> 01:23:26,950
我们还有10分 

1592
01:23:26,950 --> 01:23:30,090
它仍然会呈现分数 所以谁得到10分就得分

1593
01:23:30,090 --> 01:23:32,100
它会显示另一位选手的分数 

1594
01:23:32,100 --> 01:23:35,400
无论何时何地 实际的逻辑都适用于这里

1595
01:23:35,400 --> 01:23:39,510
我们想要摆脱那种状态 就是在我们的爱情里 按键功能 

1596
01:23:39,510 --> 01:23:41,520
我们看到你在227线上 

1597
01:23:41,520 --> 01:23:46,140
如果游戏状态等于完成(我们之前将其设置为) 

1598
01:23:46,140 --> 01:23:48,237
只有当他们按下

1599
01:23:48,237 --> 01:23:50,070
进入或返回 所以它实际上是在等待

1600
01:23:50,070 --> 01:23:52,770
让他们按Enter或Return 

1601
01:23:52,770 --> 01:23:54,840
您想要将游戏保存设置回发球 

1602
01:23:54,840 --> 01:23:56,470
我们想要重置球 

1603
01:23:56,470 --> 01:23:58,540
我们希望将这些分数初始化为零 

1604
01:23:58,540 --> 01:24:02,430
因此 我们正在有效地建立一个全新的游戏 

1605
01:24:02,430 --> 01:24:06,650
如果获胜的玩家是一名 那么我们就把发球手分配给两名

1606
01:24:06,650 --> 01:24:09,570
这样他们就能在下一场比赛中占据优势 

1607
01:24:09,570 --> 01:24:11,830
然后将其设置为1 

1608
01:24:11,830 --> 01:24:17,160
如果我们向下转到呈现函数 那么向下转到第275行 

1609
01:24:17,160 --> 01:24:21,789
如果我们处于完成状态 那么我们应该渲染到屏幕播放器

1610
01:24:21,789 --> 01:24:23,580
然后是获胜的球员 因为 记住 

1611
01:24:23,580 --> 01:24:26,230
我们把获胜的玩家设为1或2 这取决于--

1612
01:24:26,230 --> 01:24:29,370
这取决于谁赢了 谁得了第十分 

1613
01:24:29,370 --> 01:24:35,880
我们会说一个或两个玩家赢了 然后我们会呈现出来 然后

1614
01:24:35,880 --> 01:24:37,560
之后按Enter键重新启动 

1615
01:24:37,560 --> 01:24:39,150
这就是这一点的逻辑 

1616
01:24:39,150 --> 01:24:41,700
我们可以在季后赛中看到这一点 

1617
01:24:41,700 --> 01:24:45,930
如果速度太慢 我们可能不需要跑完全程 

1618
01:24:45,930 --> 01:24:47,930
但我加快了.

1619
01:24:47,930 --> 01:24:50,520
哎呀--我真的想把球拿回来 

1620
01:24:50,520 --> 01:24:53,360
我设置了速度 所以我们处于发球状态

1621
01:24:53,360 --> 01:24:57,570
我们处于比赛状态 球反弹回来了

1622
01:24:57,570 --> 01:25:02,390
这将是一个有点乏味 但足以说 这是一个很大的回报 

1623
01:25:02,390 --> 01:25:02,890
别担心

1624
01:25:06,050 --> 01:25:08,870
应该把速度调快一点

1625
01:25:08,870 --> 01:25:09,550
快到了

1626
01:25:12,140 --> 01:25:14,520
气氛越来越紧张了

1627
01:25:14,520 --> 01:25:15,750
一号玩家赢了 

1628
01:25:15,750 --> 01:25:19,590
所以我们--我们也把字体设置成更大的尺寸 在代码中 

1629
01:25:19,590 --> 01:25:21,960
我创建了一个新的字体对象 

1630
01:25:21,960 --> 01:25:26,430
在小字体和大字体之间 

1631
01:25:26,430 --> 01:25:28,590
所以是16号字体 

1632
01:25:28,590 --> 01:25:31,890
所以一号玩家赢了 这就是最终结果 

1633
01:25:31,890 --> 01:25:35,910
我只是在跟踪你的计数器 确保当你这样做 

1634
01:25:35,910 --> 01:25:39,390
在你的逻辑中点击10来检测屏幕冲突 

1635
01:25:39,390 --> 01:25:41,094
你设置的状态 

1636
01:25:41,094 --> 01:25:44,010
如果状态为done 则只需要监视键盘输入

1637
01:25:44,010 --> 01:25:46,830
看什么时候有人按回车键

1638
01:25:46,830 --> 01:25:48,740
有人在我们的爱中按下回车键 

1639
01:25:48,740 --> 01:25:50,580
它的作用是

1640
01:25:50,580 --> 01:25:53,742
是二号选手发球因为一号选手赢了 这样才公平.

1641
01:25:53,742 --> 01:25:56,700
我们要按回车键发球然后我们开始一个全新的游戏 

1642
01:25:56,700 --> 01:25:57,449
这很简单

1643
01:25:57,449 --> 01:26:03,120
所以现在我们有了一个无限可玩的博弈 有一堆简单的状态 

1644
01:26:03,120 --> 01:26:05,670
我们忽略了一个非常重要的细节 在我看来 

1645
01:26:05,670 --> 01:26:06,390
这就是声音

1646
01:26:06,390 --> 01:26:08,430
目前我们的游戏非常--

1647
01:26:08,430 --> 01:26:10,990
这是伟大的 游戏的所有作品.

1648
01:26:10,990 --> 01:26:13,980
一切都很好 只是缺少一点抛光 

1649
01:26:13,980 --> 01:26:14,970
所以我们要做的就是

1650
01:26:14,970 --> 01:26:17,429
开始在游戏中加入音频 在我看来 

1651
01:26:17,429 --> 01:26:20,011
其中一个更有趣的事情是 

1652
01:26:20,011 --> 01:26:21,390
接近你的项目结束 

1653
01:26:21,390 --> 01:26:25,150
Love.audio.newsource是一个我们要在这里看的函数 

1654
01:26:25,150 --> 01:26:29,930
所有这一切都要做的是采取一个路径 然后可选的类型 

1655
01:26:29,930 --> 01:26:31,980
这个路径是指向一个声音文件的

1656
01:26:31,980 --> 01:26:35,430
它将创建一个音频对象 你可以回放

1657
01:26:35,430 --> 01:26:37,590
在您的应用程序中的任何位置 

1658
01:26:37,590 --> 01:26:41,860
所以我们要有效地做的就是每当碰撞发生时 

1659
01:26:41,860 --> 01:26:46,020
根据碰撞的类型 我们只播放特定的声音 

1660
01:26:46,020 --> 01:26:49,300
还有一个我真的很喜欢用来做这一切的程序

1661
01:26:49,300 --> 01:26:51,660
我--我鼓励你们下载

1662
01:26:51,660 --> 01:26:54,570
如果你想开始为你的项目修改你自己的声音 

1663
01:26:54,570 --> 01:26:57,300
是一个名为bfxr的程序 

1664
01:26:57,300 --> 01:26:58,885
它在Windows和Mac上是免费的 

1665
01:26:58,885 --> 01:27:00,510
我不确定他们是否有Linux接口 

1666
01:27:00,510 --> 01:27:05,160
他们可能有一个类似程序的Linux移植 名为sfxr

1667
01:27:05,160 --> 01:27:07,219
这就是这件事的基础 

1668
01:27:07,219 --> 01:27:10,260
但这样做只会产生一串随机的声音 

1669
01:27:10,260 --> 01:27:13,770
我很快就可以为你们说明这一点 

1670
01:27:13,770 --> 01:27:16,740
如果你想获取它 它在bfxr.net上 

1671
01:27:16,740 --> 01:27:19,310
这是一个超级快速的下载 而且--

1672
01:27:19,310 --> 01:27:26,890
在这里 我将实际--我将演示它 这样我们就可以看到它是如何进行的 

1673
01:27:26,890 --> 01:27:28,950
这就是界面 

1674
01:27:28,950 --> 01:27:30,510
确保我有一些音频 

1675
01:27:30,510 --> 01:27:34,050
然后这里有很多不同的预置 

1676
01:27:34,050 --> 01:27:37,170
因此 有拾取斜线硬币 激光斜线射击 

1677
01:27:37,170 --> 01:27:39,750
它是为像这样的小游戏而设计的 

1678
01:27:39,750 --> 01:27:45,229
比如在运行中实现原型音频类型的东西 

1679
01:27:45,229 --> 01:27:46,770
但你可以看到 它只是实现了--

1680
01:27:46,770 --> 01:27:49,140
我把音量调小一点 有点吵 

1681
01:27:49,140 --> 01:27:50,697
它--例如 我们有加电装置 

1682
01:27:50,697 --> 01:27:53,780
所以每次我点击它 它都会给我们带来随机的启动 

1683
01:27:53,780 --> 01:27:55,704
[电脑音效]

1684
01:28:00,520 --> 01:28:05,340
然后随机化 你会得到各种各样奇怪的讨厌的东西 

1685
01:28:05,340 --> 01:28:08,740
然后--我们将使用的内容是blip斜杠选择 

1686
01:28:08,740 --> 01:28:13,060
我们In中的大多数东西都像界面和Pong You这样的游戏

1687
01:28:13,060 --> 01:28:17,120
只是想要这样简单的声音 

1688
01:28:17,120 --> 01:28:20,620
所以我已经完成了产生几个声音的工作

1689
01:28:20,620 --> 01:28:23,770
我觉得很合适 

1690
01:28:23,770 --> 01:28:28,785
接下来我会先给你看《乒乓球11》的代码 

1691
01:28:28,785 --> 01:28:31,660
如果我们去--如果你会看到--如果你看一下目录结构 

1692
01:28:31,660 --> 01:28:33,220
您会看到我们有一个声音文件夹 

1693
01:28:33,220 --> 01:28:36,730
在声音文件夹中 我创建了三种声音 Ppale Hit 

1694
01:28:36,730 --> 01:28:39,160
是球拍击球的任何时候 

1695
01:28:39,160 --> 01:28:41,740
得分 这是当任何时候--任何时候球

1696
01:28:41,740 --> 01:28:45,190
越过屏幕的左边界或右边界 

1697
01:28:45,190 --> 01:28:47,680
然后撞墙 所以任何时候球触地

1698
01:28:47,680 --> 01:28:49,600
屏幕的顶部或底部 

1699
01:28:49,600 --> 01:28:52,580
因此 这其中的逻辑非常简单 

1700
01:28:52,580 --> 01:28:54,531
我们所需要做的就是--

1701
01:28:54,531 --> 01:28:56,905
我们已经实施了 所以我们需要做的就是--

1702
01:29:01,570 --> 01:29:07,002
哦 首先 我要说的是 这是一张桌子的很好的插图 

1703
01:29:07,002 --> 01:29:09,210
在未来 我们将开始更多地看到这种情况 

1704
01:29:09,210 --> 01:29:11,950
我们在这堂课中并没有太多地使用桌子 

1705
01:29:11,950 --> 01:29:16,390
但表是Lua的一种BE ALL END ALL的数据结构 

1706
01:29:16,390 --> 01:29:19,810
它是字典--Python字典 JavaScript对象 

1707
01:29:19,810 --> 01:29:23,020
它是一个数组 它是您所需的一切

1708
01:29:23,020 --> 01:29:24,830
超越Lua中的简单变量 

1709
01:29:24,830 --> 01:29:28,360
它是一切事物的基础 甚至像其他库中的类一样 

1710
01:29:28,360 --> 01:29:32,140
在本例中 我们只是在初始化一个名为Sound的表 

1711
01:29:32,140 --> 01:29:35,410
我们传递了三个键 所以它可以--它可以接受键值对 

1712
01:29:35,410 --> 01:29:40,330
或者 您只需给它一个值列表 它就会为这些值创建索引

1713
01:29:40,330 --> 01:29:42,280
含蓄地 

1714
01:29:42,280 --> 01:29:46,460
在这里 我们只是像您在Python或JavaScript中所做的那样传入 

1715
01:29:46,460 --> 01:29:50,740
Par Hit 请注意 它确实需要按顺序排列这些方括号

1716
01:29:50,740 --> 01:29:55,870
来初始化表中的键值对--格式如下 

1717
01:29:55,870 --> 01:29:58,740
Paddle Hit得到了Love 

1718
01:29:58,740 --> 01:30:00,490
在这种情况下 它只需要一条路径 

1719
01:30:00,490 --> 01:30:02,930
于是响起了斜桨头点波的声音 

1720
01:30:02,930 --> 01:30:05,530
我们给它的关键字--或字符串静态 

1721
01:30:05,530 --> 01:30:08,690
这就是它的资产类型--

1722
01:30:08,690 --> 01:30:09,610
它被存储为 

1723
01:30:09,610 --> 01:30:12,734
因此 您既可以拥有静态音频资产 也可以拥有流音频资产 

1724
01:30:12,734 --> 01:30:14,650
因此 如果它们是静态的 它们会加载到内存中

1725
01:30:14,650 --> 01:30:17,191
它们被保存在内存中 用于执行您的程序 

1726
01:30:17,191 --> 01:30:20,560
如果它们是流的 那么它们会根据需要在飞行中加载

1727
01:30:20,560 --> 01:30:21,670
被你的游戏引擎 

1728
01:30:21,670 --> 01:30:24,100
和流媒体音频资源 如果您

1729
01:30:24,100 --> 01:30:28,037
有一个巨大的游戏 有大量的声音和像大型音频文件一样的长时间 

1730
01:30:28,037 --> 01:30:30,370
你不一定想要把所有这些都保存在记忆中 

1731
01:30:30,370 --> 01:30:33,670
因为这可能会占用很多、很多、很多兆或演出的音频 

1732
01:30:33,670 --> 01:30:36,882
如果你是在运行中加载资产 

1733
01:30:36,882 --> 01:30:38,590
如果你的游戏中有动态加载 

1734
01:30:38,590 --> 01:30:41,320
那么这也是你应该考虑的另一件事 

1735
01:30:41,320 --> 01:30:43,810
在这种情况下 这些是非常小的声音文件 

1736
01:30:43,810 --> 01:30:46,409
因为它们就像--就像几分之一秒长 

1737
01:30:46,409 --> 01:30:49,450
所以我们只是将它们都设置为静态 这样它们就可以保存在内存中 

1738
01:30:49,450 --> 01:30:52,160
我们只是把他们三个都加载到这张桌子上 

1739
01:30:52,160 --> 01:30:56,530
如果我们稍后想要提到这些 我们所需要做的就是听起来--

1740
01:30:56,530 --> 01:31:01,510
我们可以参考声音 PaddleHit 像这样 

1741
01:31:01,510 --> 01:31:02,500
如果我们想的话 

1742
01:31:02,500 --> 01:31:08,050
因为默认情况下 Lua只给您一个点关键字 类似于JavaScript

1743
01:31:08,050 --> 01:31:11,830
它的对象是否与您传入的键同名 

1744
01:31:11,830 --> 01:31:18,550
或者你可以用毕德式的方式来做 那就是 没有圆点 对不起--

1745
01:31:18,550 --> 01:31:23,060
只有方括号 现在有相同的- 这两个是等价的 

1746
01:31:23,060 --> 01:31:27,280
不过 如果你决定在钥匙上留个空格 那就没用了 

1747
01:31:27,280 --> 01:31:30,640
它会的 我相信 它会--

1748
01:31:30,640 --> 01:31:33,600
根本不会起作用 但它可能会注入下划线 

1749
01:31:33,600 --> 01:31:35,870
我得先测试一下 然后找出答案 

1750
01:31:35,870 --> 01:31:40,330
但是 通常情况下 使用点并不是最佳实践

1751
01:31:40,330 --> 01:31:43,450
不管怎么说 你已经把钥匙排成一排了 

1752
01:31:43,450 --> 01:31:45,970
以及您可以使用您所使用的字符串

1753
01:31:45,970 --> 01:31:49,600
不能使用点号表示法处理点号 

1754
01:31:49,600 --> 01:31:53,530
就是与您一起动态生成表的查找--

1755
01:31:53,530 --> 01:31:56,170
你可以用弦来做这件事 你--是的 

1756
01:31:56,170 --> 01:32:00,460
因为在四循环中你不能在桌子上做四件事 

1757
01:32:00,460 --> 01:32:02,620
然后桌子上点了点东西 那是行不通的 

1758
01:32:02,620 --> 01:32:06,310
但你可以为你桌子上的每一件事做

1759
01:32:06,310 --> 01:32:12,626
然后在您的表中查找键作为该值 该迭代值 

1760
01:32:12,626 --> 01:32:14,921
我们将在以后的课程中看到这方面的例子 

1761
01:32:14,921 --> 01:32:16,670
但这只是一件需要牢记的事情 

1762
01:32:16,670 --> 01:32:19,210
所以我们在这里有一张桌子 一张声音桌子 

1763
01:32:19,210 --> 01:32:22,490
哦 还有--我们的声音已经准备好了 它们加载在内存中 

1764
01:32:22,490 --> 01:32:24,550
我们现在要做的就是

1765
01:32:24,550 --> 01:32:28,370
任何事情 比如我们代码中的任何冲突 我们都会这样做 

1766
01:32:28,370 --> 01:32:30,970
就像桌子一样简单 

1767
01:32:30,970 --> 01:32:33,590
在我们想要的键上 冒号 这是Lua的

1768
01:32:33,590 --> 01:32:38,560
调用类或表的函数的方式 

1769
01:32:38,560 --> 01:32:43,840
冒号播放 播放功能是新源音频的一部分

1770
01:32:43,840 --> 01:32:46,512
我们在桌子上创造的恋爱中的对象 

1771
01:32:46,512 --> 01:32:48,970
而这只会产生只播放一次的效果 

1772
01:32:48,970 --> 01:32:50,380
您可以将其设置为循环 

1773
01:32:50,380 --> 01:32:54,662
您可以说出划桨的声音 将循环设置为真 

1774
01:32:54,662 --> 01:32:56,870
它会无限地一遍又一遍地播放 

1775
01:32:56,870 --> 01:32:58,210
我们可不想听到这样的声音 

1776
01:32:58,210 --> 01:32:59,251
这听起来会令人讨厌 

1777
01:32:59,251 --> 01:33:01,226
但如果你有一首音乐曲目 例如 

1778
01:33:01,226 --> 01:33:03,100
在某种程度上 或者类似的东西 你会

1779
01:33:03,100 --> 01:33:06,790
希望设置循环为真 这样当它最终结束时 

1780
01:33:06,790 --> 01:33:11,500
你的用户不仅仅是在默默地玩游戏 

1781
01:33:11,500 --> 01:33:14,810
所以我们用拍子击打 我们也用击墙 

1782
01:33:14,810 --> 01:33:19,300
所以我给它们起了适当的名字 这样就很容易推断出它们的位置

1783
01:33:19,300 --> 01:33:21,730
以及声音文件被用于什么目的 

1784
01:33:21,730 --> 01:33:24,650
所以 当他们在上界或下界时 就玩围墙

1785
01:33:24,650 --> 01:33:29,560
击打声音 然后每当球到达时

1786
01:33:29,560 --> 01:33:31,450
屏幕的左边缘或右边缘 

1787
01:33:31,450 --> 01:33:34,250
只要播放乐谱音效就行了 

1788
01:33:34,250 --> 01:33:39,490
所以如果我们玩我们的游戏 这一直是我最喜欢的部分之一

1789
01:33:39,490 --> 01:33:43,150
正在用音频玩游戏 因为它只会让

1790
01:33:43,150 --> 01:33:45,640
在我看来 这是一个很大的差异 

1791
01:33:45,640 --> 01:33:47,755
我们可以得到音效 

1792
01:33:47,755 --> 01:33:52,510
这是一件小事 而且很容易 但它增加了--它增加了很多味道 

1793
01:33:52,510 --> 01:33:54,520
然后(爆炸) 我们就开始了 

1794
01:33:54,520 --> 01:33:58,060
然后我们的游戏实际上在这一点上实现了 

1795
01:33:58,060 --> 01:33:59,890
再举一个例子 我会

1796
01:33:59,890 --> 01:34:02,681
我想给大家看一个小例子 因为所有的例子

1797
01:34:02,681 --> 01:34:08,020
到目前为止 RESIZE等于--SIZIZE等于FALSE 

1798
01:34:08,020 --> 01:34:11,870
在推送设置屏幕初始化器中输入某种键 

1799
01:34:11,870 --> 01:34:15,700
如果你想玩一个可以调整窗口大小的游戏 

1800
01:34:15,700 --> 01:34:18,310
我们所需要做的就是调用一个名为love.resize的函数 

1801
01:34:18,310 --> 01:34:20,370
它需要一个宽度和一个高度 

1802
01:34:20,370 --> 01:34:23,140
而我们最终要做的是 

1803
01:34:23,140 --> 01:34:25,960
具体地说 对于我们的用例 因为我们使用推送 

1804
01:34:25,960 --> 01:34:30,730
我们要去乒乓球12号 

1805
01:34:30,730 --> 01:34:40,170
如果我们进入主星 我们在85号线上看到 

1806
01:34:40,170 --> 01:34:43,852
我现在已将可调整大小更改为等于True 因此它实际上

1807
01:34:43,852 --> 01:34:45,310
允许我们调整应用程序的大小 

1808
01:34:45,310 --> 01:34:47,684
如果为假 则您甚至无法单击和拖动

1809
01:34:47,684 --> 01:34:50,500
屏幕的下角 它就是不让你这么做 

1810
01:34:50,500 --> 01:34:56,400
然后你所要做的就是调用Love 大小宽度高度 

1811
01:34:56,400 --> 01:34:59,160
然后传入随高度调整大小的Push 

1812
01:34:59,160 --> 01:35:03,810
因为引擎盖下面的推力会获得纹理并渲染到它上 

1813
01:35:03,810 --> 01:35:05,700
然后把它放大以填满你的窗口 

1814
01:35:05,700 --> 01:35:08,826
所以它需要知道你当前的窗口尺寸是多少

1815
01:35:08,826 --> 01:35:10,950
它可以将其升级到合适的尺寸 

1816
01:35:10,950 --> 01:35:12,783
Push还增加了信箱之类的东西 

1817
01:35:12,783 --> 01:35:16,440
如果您想要保持完全相同的纵横比 这是很方便的 

1818
01:35:16,440 --> 01:35:19,050
在游戏中 你可能会有这样的用户界面

1819
01:35:19,050 --> 01:35:21,480
受应用程序大小的驱动 此函数

1820
01:35:21,480 --> 01:35:23,646
将是重要的 因为这样你就可以调整你的--

1821
01:35:23,646 --> 01:35:27,150
您可以适当地调整UI元素的大小和位置 

1822
01:35:27,150 --> 01:35:30,990
因为如果你的游戏很小 也许你想要用户界面的某些部分

1823
01:35:30,990 --> 01:35:33,030
隐形 或在不同的地方

1824
01:35:33,030 --> 01:35:36,210
总而言之 这样你就不会占用大量的屏幕空间 

1825
01:35:36,210 --> 01:35:39,190
并且只是为了适应您的应用程序的所有可能用户 

1826
01:35:39,190 --> 01:35:43,610
但现在的影响是--如果我们进入乒乓球12

1827
01:35:43,610 --> 01:35:48,510
然后运行它 实际上 可能甚至不能使用但是--是的 

1828
01:35:48,510 --> 01:35:51,390
我现在就可以这么做了 

1829
01:35:51,390 --> 01:35:56,100
我可以调整它的大小 它将保持虚拟的宽度和高度

1830
01:35:56,100 --> 01:36:01,240
我们之前设置的 因为这就像是最重要的

1831
01:36:01,240 --> 01:36:03,420
无论推什么 它都会投递信箱

1832
01:36:03,420 --> 01:36:07,391
您的应用程序的大小是什么 以确保它保持这一方面

1833
01:36:07,391 --> 01:36:07,890
比率

1834
01:36:07,890 --> 01:36:10,380
所以 如果你在垂直或水平方向上都超过了这个纵横比 

1835
01:36:10,380 --> 01:36:12,270
你会得到适当的信箱 

1836
01:36:12,270 --> 01:36:13,311
所以这非常方便 

1837
01:36:13,311 --> 01:36:19,020
你不必担心你的用户会得到超级扭曲的长宽比 

1838
01:36:19,020 --> 01:36:22,380
因为他们使用了某种不可预见的解决方案 

1839
01:36:22,380 --> 01:36:25,110
它将永远保持它 即使它是超级微小的

1840
01:36:25,110 --> 01:36:27,080
因为他们的显示器超薄 

1841
01:36:27,080 --> 01:36:29,030
它将始终保持纵横比 

1842
01:36:29,030 --> 01:36:33,460
但实际上 对于Pong来说 这差不多就是这些了 

1843
01:36:33,460 --> 01:36:37,414
我们有一场完整的比赛 从头到尾 如果你有任何问题 

1844
01:36:37,414 --> 01:36:38,580
我很乐意回答这些问题 

1845
01:36:41,550 --> 01:36:43,350
有什么问题吗？

1846
01:36:43,350 --> 01:36:43,850
凉爽的 

1847
01:36:43,850 --> 01:36:44,100
好的 

1848
01:36:44,100 --> 01:36:46,400
好吧 我很高兴能把这门课的其余部分教给你们 

1849
01:36:46,400 --> 01:36:47,620
我们只是触及了皮毛 

1850
01:36:47,620 --> 01:36:48,786
我们还有更多的内容要讲 

1851
01:36:48,786 --> 01:36:51,900
下周 我们将真正报道Flappy Bird

1852
01:36:51,900 --> 01:36:54,710
所以我们会得到一些漂亮的彩色图形 

1853
01:36:54,710 --> 01:36:58,620
对我们今天的黑白美学来说是截然不同的 

1854
01:36:58,620 --> 01:37:00,000
但对于Pong来说 就是这样 

1855
01:37:00,000 --> 01:37:02,297
所以感谢你们的光临 
