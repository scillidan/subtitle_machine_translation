1
00:00:16,290 --> 00:00:19,560
演讲者1：好的 欢迎来到GD 50 第7讲 

2
00:00:19,560 --> 00:00:22,950
这周我们将谈论我最喜欢的特许经营权之一 

3
00:00:22,950 --> 00:00:24,870
我童年的核心部分

4
00:00:24,870 --> 00:00:27,850
口袋妖怪 就像屏幕上的口袋妖怪球一样 

5
00:00:27,850 --> 00:00:32,280
我记得是在1997年 第一个口袋妖怪

6
00:00:32,280 --> 00:00:34,004
游戏名称：红与蓝

7
00:00:34,004 --> 00:00:36,420
我相信它是一年前在日本发布的 

8
00:00:36,420 --> 00:00:39,661
以红蓝绿三种颜色发布

9
00:00:39,661 --> 00:00:42,160
游戏的总体目标相当简单 

10
00:00:42,160 --> 00:00:43,284
你是个宠物小精灵训练师

11
00:00:43,284 --> 00:00:47,250
你的目标是走进这个世界 

12
00:00:47,250 --> 00:00:51,900
151种不同的生物

13
00:00:51,900 --> 00:00:56,460
口袋妖怪是基于一大堆不同类型的生物 

14
00:00:56,460 --> 00:01:00,170
在这里的截图显示 有一个Weepinbell战斗和Geodude 

15
00:01:00,170 --> 00:01:03,270
Geodude是岩石类型 Weepinbeel是草类型 

16
00:01:03,270 --> 00:01:05,280
你有不同类型的口袋妖怪 

17
00:01:05,280 --> 00:01:08,340
当他们互相争斗的时候 有些人比其他人更好 

18
00:01:08,340 --> 00:01:12,572
就像是石头剪子布的关系 

19
00:01:12,572 --> 00:01:14,280
这是一个非常上瘾的公式 

20
00:01:14,280 --> 00:01:17,100
你会有一队这样的生物 你抓来养大的

21
00:01:17,100 --> 00:01:20,670
和其他驯兽师战斗

22
00:01:20,670 --> 00:01:23,490
最棒的是你可以

23
00:01:23,490 --> 00:01:25,440
你可以和你的朋友打架

24
00:01:25,440 --> 00:01:28,200
或者和你抓到的朋友交换口袋妖怪

25
00:01:28,200 --> 00:01:30,200
你们经常互相分享故事

26
00:01:30,200 --> 00:01:32,991
你可能会遇到的各种稀有生物

27
00:01:32,991 --> 00:01:34,170
以及各种各样的东西 

28
00:01:34,170 --> 00:01:37,170
你会有一个定制的派对那是你的一部分 

29
00:01:37,170 --> 00:01:38,700
这就是Pokemon Red 

30
00:01:38,700 --> 00:01:40,160
该系列随着时间的推移而发展 

31
00:01:40,160 --> 00:01:43,368
这是几年前发布的《黄金与白银》的截图

32
00:01:43,368 --> 00:01:45,150
游戏机颜色Gameboy Color

33
00:01:45,150 --> 00:01:48,120
再次 这是为常规Gameboy发布的 

34
00:01:48,120 --> 00:01:51,180
金银引入了一系列新功能 包括育种 

35
00:01:51,180 --> 00:01:53,310
昼夜循环 还有很多其他的东西

36
00:01:53,310 --> 00:01:55,310
这成为了核心系列的一部分 

37
00:01:55,310 --> 00:01:58,500
这是Ruby和Sapphire 这是为了《游戏男孩》而准备的

38
00:01:58,500 --> 00:02:01,500
得到了一个重要的图形更新 但核心公式

39
00:02:01,500 --> 00:02:03,330
基本保持不变 

40
00:02:03,330 --> 00:02:08,130
这是钻石和珍珠 这是给DS的 

41
00:02:08,130 --> 00:02:11,730
它使用了两个屏幕 如上面和下面所示 

42
00:02:11,730 --> 00:02:14,460
这是黑与白 这是又向前迈进了一步

43
00:02:14,460 --> 00:02:18,060
因为它为世界各地引入了三维图形 

44
00:02:18,060 --> 00:02:21,960
因此 你可以在该系列中第一次看到某种3D效果 

45
00:02:21,960 --> 00:02:26,230
最近 我们看到了像X和Y这样的3DS游戏 

46
00:02:26,230 --> 00:02:29,940
如图所示 欧米茄蓝宝石 阿尔法红宝石--

47
00:02:29,940 --> 00:02:33,990
阿尔法蓝宝石和欧米茄红宝石 以及月亮和太阳 

48
00:02:33,990 --> 00:02:37,680
这是一个很好的例子 说明了为什么

49
00:02:37,680 --> 00:02:41,700
RPG类型的电子游戏 角色扮演游戏 

50
00:02:41,700 --> 00:02:44,880
尽管它在某种程度上是对这个公式的独特看法 

51
00:02:44,880 --> 00:02:47,760
但它允许我们 我们可以某种程度上剖析这个 并看看

52
00:02:47,760 --> 00:02:51,210
RPG是什么 口袋妖怪游戏又是什么

53
00:02:51,210 --> 00:02:52,860
做一个很酷的演示 

54
00:02:52,860 --> 00:02:54,943
因此 今天 我们将谈论一些新事物 

55
00:02:54,943 --> 00:02:58,800
在这个讲课示例中 我们的做法会有很大不同

56
00:02:58,800 --> 00:03:03,060
相对于其他例子 因为我们正在从国家过渡

57
00:03:03,060 --> 00:03:07,500
机器 并谈论一种称为状态堆栈的结构 该结构

58
00:03:07,500 --> 00:03:10,800
实际上是状态机的更高级版本 

59
00:03:10,800 --> 00:03:15,420
而在此之前 我们有一个状态机 它一次处于一个状态 

60
00:03:15,420 --> 00:03:19,560
因此 我们可能处于播放状态或开始状态或其他状态

61
00:03:19,560 --> 00:03:22,290
不 我们现在实际上可以有多个州

62
00:03:22,290 --> 00:03:25,920
它们并行地存在于一堆数据结构上 您已经

63
00:03:25,920 --> 00:03:29,110
在CS 50中可以看到 如果你已经采取了 我们可以有 

64
00:03:29,110 --> 00:03:32,070
例如 场状态、最底部的播放状态、

65
00:03:32,070 --> 00:03:36,180
它总是在那里 然后我们可以将状态推送到堆栈上

66
00:03:36,180 --> 00:03:39,120
正如我们所需要的 例如 对话状态

67
00:03:39,120 --> 00:03:41,410
这样我们就可以实际显示一些对话框 

68
00:03:41,410 --> 00:03:44,940
将一些文本放到屏幕上 而不是摆脱播放状态

69
00:03:44,940 --> 00:03:46,720
我们以前在那里吃过的 

70
00:03:46,720 --> 00:03:50,220
它允许我们同时渲染多个物体 

71
00:03:50,220 --> 00:03:52,530
然后也返回到先前的状态 

72
00:03:52,530 --> 00:03:55,060
而不是每次都完全创建新的状态

73
00:03:55,060 --> 00:03:57,040
我们想要做一个转变 

74
00:03:57,040 --> 00:03:58,860
我们将讨论基于转弯的系统 

75
00:03:58,860 --> 00:04:02,970
所以像精灵宝可梦和其他RPG一样 在那里

76
00:04:02,970 --> 00:04:06,210
通常是战斗系统 通常是

77
00:04:06,210 --> 00:04:09,090
在你打斗的这一特定类型中转身--你有

78
00:04:09,090 --> 00:04:11,605
一支球队或一个角色与另一支球队或另一支球队或另一支球队作战

79
00:04:11,605 --> 00:04:13,980
其他角色 你们轮流打架 

80
00:04:13,980 --> 00:04:16,846
你有无限的时间来做决定

81
00:04:16,846 --> 00:04:18,720
然后形成某种战略 关于如何

82
00:04:18,720 --> 00:04:20,490
你想要解决这个问题 

83
00:04:20,490 --> 00:04:23,340
我们将看到一个非常原始的基于转弯的系统 

84
00:04:23,340 --> 00:04:26,610
但今天是一个功能齐全的系统 

85
00:04:26,610 --> 00:04:32,250
这一类型的另一个重要方面是图形用户界面或图形用户界面

86
00:04:32,250 --> 00:04:33,510
因为它们被缩短了 

87
00:04:33,510 --> 00:04:37,740
面板、滚动条、文本框和菜单等

88
00:04:37,740 --> 00:04:42,270
这类东西让我们可以更直观地看到

89
00:04:42,270 --> 00:04:46,680
 并使我们能够更好地驾驭更复杂的游戏生态系统

90
00:04:46,680 --> 00:04:47,670
效率很高 

91
00:04:47,670 --> 00:04:50,820
为了把这一切联系在一起 RPG的机械师 

92
00:04:50,820 --> 00:04:53,700
我们将考虑升级和体验等内容

93
00:04:53,700 --> 00:04:57,720
以及如何计算一方对另一方造成的损害

94
00:04:57,720 --> 00:04:59,810
在战斗的整个过程中 

95
00:04:59,810 --> 00:05:04,170
因此 这将是一组相当复杂的例子 

96
00:05:04,170 --> 00:05:08,580
但作为一个整体 它相当说明了这一流派 

97
00:05:08,580 --> 00:05:11,790
所以我想演示一下我放在一起的例子 

98
00:05:11,790 --> 00:05:15,040
如果我能从观众中找个志愿者过来看看的话 

99
00:05:15,040 --> 00:05:18,120
托尼 那太棒了 太感谢你了 

100
00:05:18,120 --> 00:05:23,850
这就是我简单但功能齐全的精灵宝可梦的演示 

101
00:05:23,850 --> 00:05:27,760
所以如果你想进入或返回 

102
00:05:27,760 --> 00:05:29,630
所以这是一个

103
00:05:29,630 --> 00:05:30,930
所以这里我们有一个

104
00:05:30,930 --> 00:05:35,040
我们可以马上看到 我们有一个文本框和一个播放状态 

105
00:05:35,040 --> 00:05:36,340
就像我们以前那样

106
00:05:36,340 --> 00:05:41,034
所以这个文本框实际上是一个在地方之上的状态 

107
00:05:41,034 --> 00:05:43,950
所以你可以看到它有一些说明 如果你想按P 

108
00:05:43,950 --> 00:05:45,120
你可以治愈你的口袋妖怪

109
00:05:45,120 --> 00:05:46,730
您可以按Enter键取消 

110
00:05:46,730 --> 00:05:47,880
如果你继续按回车键 

111
00:05:47,880 --> 00:05:49,620
现在能够真正移动了 

112
00:05:49,620 --> 00:05:52,500
需要注意的是 输入实际上

113
00:05:52,500 --> 00:05:57,060
当对话在屏幕顶部时停止播放状态 

114
00:05:57,060 --> 00:06:01,110
你实际上不允许访问或更新这个底部状态 

115
00:06:01,110 --> 00:06:05,220
因为状态堆栈只允许输入到顶部状态 

116
00:06:05,220 --> 00:06:09,990
所以我把这个游戏限制在这个盒子里 

117
00:06:09,990 --> 00:06:13,830
但如果我们在这里的高草中行走 在口袋妖怪里 

118
00:06:13,830 --> 00:06:15,630
为了真正开始一次邂逅

119
00:06:15,630 --> 00:06:19,554
与另一个口袋妖怪或另一个野生口袋妖怪 你走在草地上 

120
00:06:19,554 --> 00:06:20,970
我们在草地上走了一圈 

121
00:06:20,970 --> 00:06:25,500
这种情况发生的概率是随机的 有十分之一的概率

122
00:06:25,500 --> 00:06:26,370
基本上

123
00:06:26,370 --> 00:06:28,310
原来是说有野竹子出现了 

124
00:06:28,310 --> 00:06:29,550
一个野生动物出现了 

125
00:06:29,550 --> 00:06:32,550
他是5级 我们是5级 应该是一个相当公平的战斗 

126
00:06:32,550 --> 00:06:34,982
你可以按回车键 它会说开始

127
00:06:34,982 --> 00:06:37,440
你的口袋妖怪的名字 在这个例子中是一个Aardart 

128
00:06:37,440 --> 00:06:39,410
现在是随机分配的

129
00:06:39,410 --> 00:06:41,160
所以再按一次回车键 

130
00:06:41,160 --> 00:06:43,360
现在我们可以看到右下角 我们有一个菜单 

131
00:06:43,360 --> 00:06:46,290
所以我们要么战斗要么逃跑 这两个选择 

132
00:06:46,290 --> 00:06:47,686
所以我们可以继续战斗 

133
00:06:47,686 --> 00:06:49,560
所以我们战斗 谁的口袋妖怪更高

134
00:06:49,560 --> 00:06:51,900
速度是第一位的 会造成伤害 

135
00:06:51,900 --> 00:06:55,287
很明显 我们造成的伤害更大 但他的速度更快 

136
00:06:55,287 --> 00:06:56,370
所以他会先来

137
00:06:56,370 --> 00:06:57,453
所以我们再打一次 

138
00:07:00,130 --> 00:07:03,050
我们应该能把他打晕 

139
00:07:03,050 --> 00:07:06,252
所以一旦我们这样做了 我们就得到了胜利的信息 我们得到了胜利的歌曲 

140
00:07:06,252 --> 00:07:08,460
如果我们按下回车键 

141
00:07:08,460 --> 00:07:10,320
因为打败了那个敌人 

142
00:07:10,320 --> 00:07:12,837
所以我们有相当多的经验 我们有65个XP 

143
00:07:12,837 --> 00:07:15,420
在底部栏中 我们可以看到我们有所有这些图形用户界面元素 

144
00:07:15,420 --> 00:07:19,380
我们这里有一个面板 我们有文本框 我们有进度条 

145
00:07:19,380 --> 00:07:24,360
所有这些部分结合在一起 给了我们某种基于回合的系统 

146
00:07:24,360 --> 00:07:27,420
所以在这之后 我们可能会升级 只是为了演示

147
00:07:27,420 --> 00:07:31,803
水平 这是这个游戏的RPG机械学的一部分 

148
00:07:31,803 --> 00:07:34,960
所以我们必须再按一次 

149
00:07:34,960 --> 00:07:35,770
我们做到了 非常完美 

150
00:07:35,770 --> 00:07:36,970
所以他们升级了 

151
00:07:36,970 --> 00:07:44,300
现在我们是级别6 所以我们可以看到进度条上方的6发生了变化 

152
00:07:44,300 --> 00:07:46,300
因此 现在每次都会变得更强大 

153
00:07:46,300 --> 00:07:49,258
统计数据没有在这里显示 这实际上是作业的一部分

154
00:07:49,258 --> 00:07:52,630
是创建一个菜单 它将实际显示您是如何升级的 

155
00:07:52,630 --> 00:07:54,550
实际增加的统计数据 

156
00:07:54,550 --> 00:07:57,400
但在引擎盖下 在幕后 

157
00:07:57,400 --> 00:07:59,680
你实际上得到了统计数据的增长 

158
00:07:59,680 --> 00:08:03,250
所以在这里我们可以看到 如果我们的HP一直降到零 

159
00:08:03,250 --> 00:08:04,090
我们晕倒了 

160
00:08:04,090 --> 00:08:06,730
当我们昏倒时 屏幕不是褪色为白色

161
00:08:06,730 --> 00:08:09,063
实际上会褪色为黑色 以说明区别

162
00:08:09,063 --> 00:08:11,040
在这两个转变之间 

163
00:08:11,040 --> 00:08:13,760
这样我们就可以无限期地玩下去 

164
00:08:13,760 --> 00:08:16,360
这个游戏会让你的精灵宝可梦完全恢复健康 

165
00:08:16,360 --> 00:08:18,274
因此 这将永远持续下去 

166
00:08:18,274 --> 00:08:20,440
这实际上就是模拟器 它只是

167
00:08:20,440 --> 00:08:22,480
一系列简单的无休止的战斗 

168
00:08:22,480 --> 00:08:24,450
草丛中有随机的精灵宝可梦 

169
00:08:24,450 --> 00:08:27,880
你总共可以打五场比赛 

170
00:08:27,880 --> 00:08:30,172
但构成这款游戏的所有核心要素都在这里 

171
00:08:30,172 --> 00:08:31,879
所以实际上 让我们也来演示一下跑步

172
00:08:31,879 --> 00:08:34,850
如果您不介意的话 让我们看看有没有什么不同 

173
00:08:34,850 --> 00:08:37,710
所以我们真的可以逃走 然后在战斗中我们会在那里被切断 

174
00:08:37,710 --> 00:08:39,880
我们不会得到任何XP 我们不会晕倒 但我们仍然

175
00:08:39,880 --> 00:08:41,419
回到播放状态 

176
00:08:41,419 --> 00:08:43,090
这就是精灵宝可梦的演示 

177
00:08:43,090 --> 00:08:45,925
非常感谢Tony前来演示它 

178
00:08:45,925 --> 00:08:53,427
嗯 这里涉及到很多东西 但正如我们将看到的 

179
00:08:53,427 --> 00:08:56,260
一旦我们实施了大量这样的基础性项目 

180
00:08:56,260 --> 00:09:00,040
开始对越来越多的这些进行分层并不是太困难

181
00:09:00,040 --> 00:09:02,860
让游戏变得更加丰富 

182
00:09:02,860 --> 00:09:05,562
事实上 我们的任务是--

183
00:09:05,562 --> 00:09:08,020
我们将在最后看到这一点 我将在最后回顾一下--

184
00:09:08,020 --> 00:09:12,040
但作业的目标是让你实现一个菜单--

185
00:09:12,040 --> 00:09:16,300
类似于我们看到的显示战斗和逃跑的菜单--

186
00:09:16,300 --> 00:09:19,330
这将显示您的每个统计数据的当前统计数据 

187
00:09:19,330 --> 00:09:22,080
有进攻、防守、速度和你的HP 

188
00:09:22,080 --> 00:09:25,960
它将显示您在升级前的状态 数量

189
00:09:25,960 --> 00:09:28,400
它将增加 然后是最终的金额 

190
00:09:28,400 --> 00:09:31,570
这有点类似于实际的精灵宝可梦游戏的工作原理 

191
00:09:31,570 --> 00:09:35,230
所以你可以看到 而不是仅仅看到 哦 我把我的级别从5增加到6 

192
00:09:35,230 --> 00:09:38,692
6到7 你可以看到 哦 我的力量从12增加到14 

193
00:09:38,692 --> 00:09:41,650
我更强壮一点 我会在下一场比赛中造成更大的伤害

194
00:09:41,650 --> 00:09:43,240
穿过 

195
00:09:43,240 --> 00:09:47,080
所以我们的目标是 我们要看看场上的状态 比赛

196
00:09:47,080 --> 00:09:49,190
状态和战斗状态 

197
00:09:49,190 --> 00:09:53,370
在大多数这类游戏中都有一个常见的二分法 

198
00:09:53,370 --> 00:09:55,930
无论是《最终幻想》、《寻龙诀》还是《精灵宝可梦》

199
00:09:55,930 --> 00:09:58,710
在有田野的地方 你在走来走去 

200
00:09:58,710 --> 00:10:02,440
你的角色与一个有NPC的游戏世界互动 穿过城镇 

201
00:10:02,440 --> 00:10:03,650
那你有什么 

202
00:10:03,650 --> 00:10:05,844
然后是战斗模式 一种战斗状态

203
00:10:05,844 --> 00:10:08,260
在那里你实际上是在与某种敌人作战 

204
00:10:08,260 --> 00:10:11,060
或一系列的敌人 一个党或一个单一的生物 

205
00:10:11,060 --> 00:10:14,080
因此 我们实现了这两种方法的简单版本 以说明

206
00:10:14,080 --> 00:10:17,770
以及它们之间的过渡 

207
00:10:17,770 --> 00:10:21,100
在我们开始之前 我想做另一种插头

208
00:10:21,100 --> 00:10:26,050
对于这本Howtomakeanrpg.com 这本书 我其实从中学到了很多

209
00:10:26,050 --> 00:10:28,510
以及在游戏开发环境中使用Lua 

210
00:10:28,510 --> 00:10:30,926
我在之前的一节课上提到了这一点 

211
00:10:30,926 --> 00:10:34,570
但如果你想更深入地研究其中的许多概念 

212
00:10:34,570 --> 00:10:38,320
为了对你可能如何做一些事情有一个感觉 比如剪辑场景 

213
00:10:38,320 --> 00:10:42,162
或者更复杂的战斗布局 更像是--

214
00:10:42,162 --> 00:10:44,620
它深入到了很多令人惊叹的事情的细节中 

215
00:10:44,620 --> 00:10:45,620
一定要去看看 

216
00:10:45,620 --> 00:10:49,060
它不是免费的 但如果你对这种类型感兴趣 就像我一样 

217
00:10:49,060 --> 00:10:50,880
这绝对是值得的 

218
00:10:50,880 --> 00:10:53,350
这是我们将成为的精灵床单的样子

219
00:10:53,350 --> 00:10:55,750
用于这种演示 

220
00:10:55,750 --> 00:10:58,586
除了精灵宝可梦 它们都是单独的纹理 

221
00:10:58,586 --> 00:11:00,460
在这里 我们使用一个简单的精灵工作表 它

222
00:11:00,460 --> 00:11:03,280
只有一堆瓷砖 大部分我们都没有用过 

223
00:11:03,280 --> 00:11:08,620
请注意 灌木丛和高高的草丛没有任何类型的背景 

224
00:11:08,620 --> 00:11:13,030
因此 我们需要分层 基本上

225
00:11:13,030 --> 00:11:17,260
有两个单独的瓷砖地图 而不是一个 我们上次没有做 

226
00:11:17,260 --> 00:11:22,180
我们重复使用了塞尔达演讲中使用的精灵纸 

227
00:11:22,180 --> 00:11:24,970
以前 我们用它来对付所有的敌人 骷髅 幽灵 

228
00:11:24,970 --> 00:11:26,090
还有泥巴 等等 

229
00:11:26,090 --> 00:11:28,750
但现在我们实际上是在它所包含的PC上使用它 

230
00:11:28,750 --> 00:11:34,060
具体地说 就是这里的男性全国人大 这是我们的主角 

231
00:11:34,060 --> 00:11:37,870
我们在本课程中使用的基础类

232
00:11:37,870 --> 00:11:42,130
其他的一切都围绕着它 让它发挥作用

233
00:11:42,130 --> 00:11:44,170
是状态堆栈 

234
00:11:44,170 --> 00:11:49,560
所以在此之前 我们拥有的是一个国家机器 对吧 

235
00:11:49,560 --> 00:11:51,530
我们一次只在一个州 

236
00:11:51,530 --> 00:11:55,090
所以你几乎可以想象 我们这里有一个盒子 

237
00:11:55,090 --> 00:11:57,190
而且它只有一个插座 

238
00:11:57,190 --> 00:11:59,710
然后我们总是看着这个插座 

239
00:11:59,710 --> 00:12:02,350
无论是游戏状态 还是战斗状态 

240
00:12:02,350 --> 00:12:05,500
或者某种形式的转变 

241
00:12:05,500 --> 00:12:08,710
现在我们正在过渡到这样的想法 相反 

242
00:12:08,710 --> 00:12:14,740
一次只能看到的一种状态 我们会把它堆叠起来 

243
00:12:14,740 --> 00:12:18,640
因此 我们可以做的是 不只是拥有一个 

244
00:12:18,640 --> 00:12:22,150
因此 我们可以一次呈现多个状态 对吗？

245
00:12:22,150 --> 00:12:27,460
让我们假设这就像赛场 对 或者是比赛状态 

246
00:12:27,460 --> 00:12:31,540
也许这就像是一场对话 或者别的什么 对吗？

247
00:12:31,540 --> 00:12:34,680
就像我们以前在现场看到的那样 我们有一个文本框 

248
00:12:34,680 --> 00:12:37,460
我们实际上可以把东西层层叠在一起 

249
00:12:37,460 --> 00:12:42,670
然后可能这就像是淡出 对 或者淡入 

250
00:12:42,670 --> 00:12:45,520
所以我们可以从播放状态开始 然后我们四处走动 

251
00:12:45,520 --> 00:12:47,320
我们和鼻咽癌里的人互动 

252
00:12:47,320 --> 00:12:50,590
不是将播放状态转换为对话状态 

253
00:12:50,590 --> 00:12:55,360
在我们之前的模型中 这将完全消除播放状态 

254
00:12:55,360 --> 00:12:58,960
因为一次只有一种状态可能是活动的 

255
00:12:58,960 --> 00:13:02,290
现在我们只需要呈现 无论堆栈中有多少个状态 

256
00:13:02,290 --> 00:13:05,660
我们只是根据它们被弹出的顺序按顺序呈现它们 

257
00:13:05,660 --> 00:13:09,610
我们会先渲染这个 基本上是自下而上渲染 

258
00:13:09,610 --> 00:13:12,130
呈现播放状态 然后是对话 然后是淡入 

259
00:13:12,130 --> 00:13:15,421
这将产生一系列不同的事情的效果 

260
00:13:15,421 --> 00:13:17,410
我们将在发行版中看到 

261
00:13:17,410 --> 00:13:21,430
但我们真的只需要一次更新一个州 

262
00:13:21,430 --> 00:13:26,620
对 因为如果我们激活了播放状态和对话状态

263
00:13:26,620 --> 00:13:29,950
以及淡入状态活动 按此顺序 作为堆栈 

264
00:13:29,950 --> 00:13:33,886
是的 我们是在推动行动 为了得到一些东西

265
00:13:33,886 --> 00:13:36,010
把它放到堆栈上称为推送 然后把它取出来

266
00:13:36,010 --> 00:13:38,140
如果不熟悉就被称为流行音乐 

267
00:13:38,140 --> 00:13:41,530
如果我们推动所有这些州前进 那么通常情况下 

268
00:13:41,530 --> 00:13:44,654
我们只需要更新上面的内容 对吗？

269
00:13:44,654 --> 00:13:46,570
例如 如果没有淡入 我们只有

270
00:13:46,570 --> 00:13:49,300
使对话状态处于活动状态 或对话和位置

271
00:13:49,300 --> 00:13:53,110
按照从上到下的顺序陈述 然后我们通常

272
00:13:53,110 --> 00:13:55,782
我不想让他更新播放状态的情况 

273
00:13:55,782 --> 00:13:58,240
我们只关心正在进行的对话 

274
00:13:58,240 --> 00:14:00,050
我们只想让它接受输入 

275
00:14:00,050 --> 00:14:02,050
当我们按空格键、Enter键或其他键时

276
00:14:02,050 --> 00:14:06,340
按钮清除该对话框状态 我们将其弹出 对

277
00:14:06,340 --> 00:14:08,070
然后我们又回到了游戏状态 

278
00:14:08,070 --> 00:14:10,810
那么我们只是在更新播放状态 

279
00:14:10,810 --> 00:14:14,649
因此能够更新最上面的内容 同时

280
00:14:14,649 --> 00:14:16,690
能够渲染底部的所有东西 

281
00:14:16,690 --> 00:14:18,760
这并不适用于所有的博弈公式 

282
00:14:18,760 --> 00:14:22,640
当然有一些游戏 你可以在其中进行对话和游戏状态

283
00:14:22,640 --> 00:14:28,050
两者都得到了更新 但仍在使用某种状态堆栈 

284
00:14:28,050 --> 00:14:31,780
你只是在以一种自上而下的方式更新事物 

285
00:14:31,780 --> 00:14:35,530
但这让我们可以做各种各样的事情 比如过渡 

286
00:14:35,530 --> 00:14:38,440
并保持--比如 我们有一个游戏状态

287
00:14:38,440 --> 00:14:40,840
我们可以在上面弹出一个战斗状态 

288
00:14:40,840 --> 00:14:43,270
我们看不到它下面的游戏状态 

289
00:14:43,270 --> 00:14:45,577
我们只看到战斗状态 这一切都在更新 

290
00:14:45,577 --> 00:14:47,410
但如果我们打开战斗状态 我们就

291
00:14:47,410 --> 00:14:49,510
就在我们刚刚处于游戏状态的地方 

292
00:14:49,510 --> 00:14:53,860
由于缺乏更好的词语 它从以前就保持了自己的状态 

293
00:14:53,860 --> 00:14:58,750
这是这个模型为我们提供的舒适的东西 

294
00:14:58,750 --> 00:15:01,120
所以这是某种程度上的基础课程

295
00:15:01,120 --> 00:15:03,190
在这个发行版中实现 这将允许

296
00:15:03,190 --> 00:15:06,080
让我们做各种很棒的事情 

297
00:15:06,080 --> 00:15:09,580
那么让我们继续下去 看看它是什么样子的 

298
00:15:09,580 --> 00:15:11,500
我在这里打开了州堆栈 

299
00:15:11,500 --> 00:15:15,460
所以状态堆栈在这里只有一组状态 

300
00:15:18,430 --> 00:15:20,530
然后 当我们想要插入一个状态时 

301
00:15:20,530 --> 00:15:23,540
它将位于状态堆栈的末尾 

302
00:15:23,540 --> 00:15:25,450
所以这将是最后一次--

303
00:15:25,450 --> 00:15:28,990
因此 如果我们将其视为表格中的一系列州 

304
00:15:28,990 --> 00:15:31,870
它将是表中最后一个索引 

305
00:15:31,870 --> 00:15:35,530
这将是我们的 我们堆栈的顶部 

306
00:15:35,530 --> 00:15:38,440
如果你愿意 你可以用相反的方式来实现这一点 

307
00:15:38,440 --> 00:15:44,890
只是更简单 因为你只需做一张简单的桌子 移走即可摆脱

308
00:15:44,890 --> 00:15:45,490
在--

309
00:15:48,100 --> 00:15:52,420
表 删除该表以消除最后一个状态

310
00:15:52,420 --> 00:15:54,280
而不需要把所有的东西都搬回去 

311
00:15:54,280 --> 00:15:57,940
所以如果我们从第一个索引开始 你必须把所有的东西都移回去 

312
00:15:57,940 --> 00:16:00,940
这也会有一点奇怪 因为你会从一个开始 

313
00:16:00,940 --> 00:16:03,070
然后事情就会向左转 

314
00:16:03,070 --> 00:16:07,690
但基本上 为了更新我们的最终状态 

315
00:16:07,690 --> 00:16:13,870
我们只在#self.States执行操作 无论我们的状态堆栈有多大 

316
00:16:13,870 --> 00:16:16,570
我们只是调用该状态的更新 

317
00:16:16,570 --> 00:16:19,420
然后处理人工智能就在这里 尽管我们没有使用它 

318
00:16:19,420 --> 00:16:21,640
但如果你有人工智能 事情就会是一样的

319
00:16:21,640 --> 00:16:26,950
基本上是对您所在州的人工智能的更新 

320
00:16:26,950 --> 00:16:29,500
而不是一次只呈现一种状态 

321
00:16:29,500 --> 00:16:32,140
我们在这里迭代我们所有的状态

322
00:16:32,140 --> 00:16:35,140
使用iPair 它将对它们进行数值迭代

323
00:16:35,140 --> 00:16:38,230
从一开始一直到最后 

324
00:16:38,230 --> 00:16:41,410
所以我们调用istate 并对其进行自我状态呈现 

325
00:16:41,410 --> 00:16:47,260
因此 这将使所有内容从前到后 或从下到上 

326
00:16:47,260 --> 00:16:49,060
并允许我们得到这个分层的外观

327
00:16:49,060 --> 00:16:51,268
例如 我们有一个游戏状态在下面进行 

328
00:16:51,268 --> 00:16:54,230
然后是上面的一段对话 

329
00:16:54,230 --> 00:16:56,230
或者我们有一个战斗状态在最顶端 

330
00:16:56,230 --> 00:16:59,410
也许战斗状态本身就推动了一场对话

331
00:16:59,410 --> 00:17:02,230
状态到堆栈的顶部 或一堆其他状态 

332
00:17:02,230 --> 00:17:05,410
一个过渡 你想要什么都行 

333
00:17:05,410 --> 00:17:08,290
要清除它 我们只需将表重置为空表 

334
00:17:08,290 --> 00:17:12,010
要推送状态 我们只需在该状态上执行插入操作 然后

335
00:17:12,010 --> 00:17:14,680
我们在该状态下调用Enter 

336
00:17:14,680 --> 00:17:19,240
正如我们以前所做的 有点类似于状态机 当我们更改状态时 

337
00:17:19,240 --> 00:17:21,369
我们会对它调用Enter和Exit 但现在我们

338
00:17:21,369 --> 00:17:23,050
当我们按下时 只需按回车键 

339
00:17:23,050 --> 00:17:26,470
然后 我们所要做的就是在任何地方调用Exit

340
00:17:26,470 --> 00:17:30,460
最后一个状态在我们的状态堆栈中 然后

341
00:17:30,460 --> 00:17:32,650
对self.States调用Table.Remove 

342
00:17:32,650 --> 00:17:36,790
默认情况下 当您在一个表上调用Table.Remove时 只需要一个表

343
00:17:36,790 --> 00:17:40,930
没有其他参数 它将删除所有

344
00:17:40,930 --> 00:17:43,165
最后一个索引是该表的索引 

345
00:17:43,165 --> 00:17:44,100
这说得通吗？

346
00:17:44,100 --> 00:17:46,558
有没有人对状态堆栈的工作原理有任何疑问？

347
00:17:49,300 --> 00:17:51,650
好的 太棒了 

348
00:17:51,650 --> 00:17:56,700
那么让我们来看看开始状态 

349
00:17:56,700 --> 00:17:59,980
这就是开始的日期 

350
00:18:03,850 --> 00:18:06,250
非常简单 我们只有几个文本标签 

351
00:18:06,250 --> 00:18:10,690
然后我们有一个随机分配的从左到右的精灵 

352
00:18:10,690 --> 00:18:14,724
我们认为我们是如何实现这场运动的？

353
00:18:14,724 --> 00:18:17,230
是的 定时器 然后我们就开始画画

354
00:18:17,230 --> 00:18:19,840
一个椭圆形 对 很简单 

355
00:18:19,840 --> 00:18:24,830
然后当我们按Enter键时 请注意转换 

356
00:18:24,830 --> 00:18:31,140
请注意 有一个淡入淡出到白色 然后淡出到透明 

357
00:18:31,140 --> 00:18:34,850
所以如果我们回想起我们看第三场比赛的时候 我们是怎么做的 

358
00:18:34,850 --> 00:18:36,792
我们还记得吗？

359
00:18:36,792 --> 00:18:40,110
观众：[听不见]

360
00:18:42,480 --> 00:18:44,930
演讲者1：没错 长方形存放在哪里？

361
00:18:50,090 --> 00:18:52,510
抱歉 对摄像机重复一遍 我们有一个长方形

362
00:18:52,510 --> 00:18:56,380
它充满了整个屏幕 我们只是在它的透明度之间补间 

363
00:18:56,380 --> 00:18:57,710
这是真的 

364
00:18:57,710 --> 00:19:01,120
不过 之前存储在那里的矩形

365
00:19:01,120 --> 00:19:04,570
当时处于活动状态的状态 就像开始日期一样 

366
00:19:04,570 --> 00:19:08,710
或者我认为开始游戏状态是它的名字 

367
00:19:08,710 --> 00:19:13,450
在过渡过程中不一定相关的实际状态 

368
00:19:13,450 --> 00:19:18,130
但使用状态堆栈 我们实际上可以将这一想法分离 

369
00:19:18,130 --> 00:19:21,580
我们可以采用过渡的概念 因为想象一下

370
00:19:21,580 --> 00:19:24,567
如果我们想要在每个单独的州之间进行转换

371
00:19:24,567 --> 00:19:25,900
在我们的游戏中存在的东西 对吗？

372
00:19:25,900 --> 00:19:28,233
如果我们想从战场过渡到战场 

373
00:19:28,233 --> 00:19:33,340
或者战场 或者任何我们可能想要的东西 比如开始

374
00:19:33,340 --> 00:19:36,820
到场上 我们需要在每一块中都有一个矩形

375
00:19:36,820 --> 00:19:39,580
我们正在跟踪的那些具有不透明性的 

376
00:19:39,580 --> 00:19:44,500
这并不一定与该州的目的密切相关 对吗？

377
00:19:44,500 --> 00:19:47,380
因此 因为我们现在有一个状态堆栈 所以我们实际上可以

378
00:19:47,380 --> 00:19:52,870
抽象出这个过渡的概念 并把它变成自己的状态 

379
00:19:52,870 --> 00:19:56,230
我们可以有一个过渡态 

380
00:19:56,230 --> 00:19:59,470
回想一下 因为我们只是将所有东西分层

381
00:19:59,470 --> 00:20:03,130
[?关闭？]所有这些状态 我们正在按顺序呈现它们 

382
00:20:03,130 --> 00:20:07,840
具有自己的状态 例如 不透明矩形 

383
00:20:07,840 --> 00:20:12,080
我们可以分层 把它压到堆栈上 然后渲染它 

384
00:20:12,080 --> 00:20:16,160
它会给我们带来这种转变的错觉 

385
00:20:16,160 --> 00:20:19,000
但我们实际上不需要让它成为国家的一部分

386
00:20:19,000 --> 00:20:21,380
我们正试图过渡出和进入的地方 

387
00:20:21,380 --> 00:20:23,720
这说得通吗？

388
00:20:23,720 --> 00:20:27,469
那么让我们来看看 举个例子 

389
00:20:27,469 --> 00:20:29,260
我们先来看看开始状态 

390
00:20:29,260 --> 00:20:32,920
只是为了让我们看看这是从哪里开始的 

391
00:20:32,920 --> 00:20:36,160
所以开始状态 我们开始一些音乐 我们有一个精灵 

392
00:20:36,160 --> 00:20:37,210
还有一个精灵x和y 

393
00:20:37,210 --> 00:20:40,570
实际上 这些值与正在移动的精灵有关 

394
00:20:40,570 --> 00:20:43,089
我们只有一个精灵从左向右移动 

395
00:20:43,089 --> 00:20:45,380
它只是被传送到屏幕的右边

396
00:20:45,380 --> 00:20:47,620
一旦它被带到一边 

397
00:20:47,620 --> 00:20:51,340
所以我们只有一个精灵 一个x和y 

398
00:20:51,340 --> 00:20:53,440
然后每隔三秒 就像我们在这里看到的那样 

399
00:20:53,440 --> 00:20:59,890
我们有一个回调函数 它将补间精灵x到负64

400
00:20:59,890 --> 00:21:03,370
超过0.2秒 真的很快 

401
00:21:03,370 --> 00:21:06,190
然后在完成后 将其传送到右侧 

402
00:21:06,190 --> 00:21:08,380
然后做同样的事情 但在它之间

403
00:21:08,380 --> 00:21:11,170
在0.2秒内到达中心 

404
00:21:11,170 --> 00:21:18,190
然后我们一按Enter或Return键 请注意 

405
00:21:18,190 --> 00:21:22,960
我们有gStateStack 而不再是gStateMachine 

406
00:21:22,960 --> 00:21:27,490
我们正在推动它在州内逐渐淡出 

407
00:21:27,490 --> 00:21:32,170
它接受一个RGB、一个持续时间和一个回调函数 

408
00:21:32,170 --> 00:21:38,080
现在 如果你看看main.lua 这是相关的 

409
00:21:38,080 --> 00:21:42,790
因为现在我们不再有状态机了 对吗？

410
00:21:42,790 --> 00:21:45,670
我们之前有一个全局状态机gStateMachine 

411
00:21:45,670 --> 00:21:49,450
我们会给它一个进入函数、匿名函数的索引列表 

412
00:21:49,450 --> 00:21:53,150
它们将返回一个状态的实例化 

413
00:21:53,150 --> 00:21:55,885
然后 当我们调用Change时 状态机将

414
00:21:55,885 --> 00:22:00,820
索引到其状态列表中 并调用匿名函数 

415
00:22:00,820 --> 00:22:04,090
这将导致将状态改变为某种状态

416
00:22:04,090 --> 00:22:07,000
我们已经实现为一个类 对吧？

417
00:22:07,000 --> 00:22:09,190
现在我们只需要创建一个状态栈 

418
00:22:09,190 --> 00:22:14,320
将一个新的起始状态推送到类中 

419
00:22:14,320 --> 00:22:18,220
所以这实际上是同样的事情 只是现在

420
00:22:18,220 --> 00:22:23,101
我们可以把事情放在开始状态 对吧 或者播放状态 

421
00:22:23,101 --> 00:22:25,850
或者任何我们想要的东西 我们永远也摆脱不了它 

422
00:22:25,850 --> 00:22:28,250
我是说 我们可以摆脱它 但我们不需要 

423
00:22:28,250 --> 00:22:32,680
对于游戏状态 特别是 我们希望它几乎永远不会

424
00:22:32,680 --> 00:22:35,260
从堆栈中弹出 因为

425
00:22:35,260 --> 00:22:36,960
保护我们所有的信息

426
00:22:36,960 --> 00:22:40,210
我们将回到默认状态来存储所有的角色信息 

427
00:22:40,210 --> 00:22:43,210
我们的口袋妖怪信息 无论我们还能

428
00:22:43,210 --> 00:22:46,690
想在这个游戏的外壳上添加一个库存 

429
00:22:46,690 --> 00:22:49,360
等等 一个世界性的国家 

430
00:22:49,360 --> 00:22:53,140
我们希望保持这一点 并在我们所有的战斗中保持一致

431
00:22:53,140 --> 00:22:54,580
国家等等 

432
00:22:54,580 --> 00:22:58,060
战斗状态会从那个世界获取信息 

433
00:22:58,060 --> 00:23:01,840
从游戏状态中 根据需要构建一场战斗 

434
00:23:01,840 --> 00:23:04,570
这有道理吗

435
00:23:04,570 --> 00:23:08,590
好了 现在我们实际上是 我们对main做的唯一真正的更改

436
00:23:08,590 --> 00:23:11,790
不再是一个状态机 现在我们有一个状态栈 

437
00:23:11,790 --> 00:23:14,230
我们要推动启动状态 

438
00:23:14,230 --> 00:23:18,790
有一些行为 就像我们之前实现的任何其他状态一样 

439
00:23:22,570 --> 00:23:29,560
我之前要讲的是起始状态的第36行 

440
00:23:29,560 --> 00:23:32,540
我们正在把另一个状态推入堆栈 

441
00:23:32,540 --> 00:23:36,951
所以已经有一个起始状态了 它是从起始状态本身内部

442
00:23:36,951 --> 00:23:37,450
事实上

443
00:23:40,279 --> 00:23:42,820
我们要把这个堆栈 它只有一层深 

444
00:23:42,820 --> 00:23:44,560
现在我们要把它变成两层深 

445
00:23:44,560 --> 00:23:46,360
所以现在我们要添加一个淡入状态 

446
00:23:46,360 --> 00:23:49,270
我们可以看到 淡入状态是一个RGB 

447
00:23:49,270 --> 00:23:52,160
有没有人猜到RGB与什么有关？

448
00:23:55,046 --> 00:23:58,425
观众：[听不见]

449
00:23:58,425 --> 00:24:00,800
演讲者1：你想用黑色还是白色来淡出？

450
00:24:00,800 --> 00:24:02,035
是的 任何颜色 

451
00:24:02,035 --> 00:24:04,660
如果我们愿意 我们可以把它变成红色 

452
00:24:04,660 --> 00:24:06,350
或褪色为蓝色 

453
00:24:06,350 --> 00:24:10,490
但我们不必为淡入淡出创建两个单独的类 

454
00:24:10,490 --> 00:24:13,850
淡入黑淡出黑淡出白

455
00:24:13,850 --> 00:24:16,760
我们可以给它一个颜色 

456
00:24:16,760 --> 00:24:20,360
我的意思是 我们甚至可以更进一步 

457
00:24:20,360 --> 00:24:23,960
并使其具有不透明性 这样我们就不需要淡入状态 

458
00:24:23,960 --> 00:24:26,690
或者淡出状态 我们只需要一个淡出状态 对吧

459
00:24:26,690 --> 00:24:30,110
褪色状态将决定 基于任何

460
00:24:30,110 --> 00:24:37,654
最后一个不透明度参数 我们给它 正确的方式淡入淡出 

461
00:24:37,654 --> 00:24:40,070
但在这种情况下 淡入状态

462
00:24:40,070 --> 00:24:44,090
并且淡出状态是人们知道去到0 人们知道去到255 

463
00:24:44,090 --> 00:24:46,700
这是唯一的关键区别 

464
00:24:46,700 --> 00:24:51,830
然后这个1 持续时间 对 我们需要告诉它褪色多久 

465
00:24:51,830 --> 00:24:55,610
最后一点是函数 

466
00:24:55,610 --> 00:24:59,960
我们给它一个匿名函数 这是一个回调函数 

467
00:24:59,960 --> 00:25:06,650
因为淡入状态本质上是异步状态 

468
00:25:06,650 --> 00:25:08,480
它的行为会随着时间的推移而改变 

469
00:25:08,480 --> 00:25:10,940
所以我们需要一种方式 我们需要告诉它 好的 

470
00:25:10,940 --> 00:25:14,360
当你完成了你正在做的事情 调用这段代码 

471
00:25:14,360 --> 00:25:19,010
这样我们就可以做一些事情 而不是立即 

472
00:25:19,010 --> 00:25:22,250
我们可以推迟它的执行 

473
00:25:22,250 --> 00:25:26,910
这是我们在这节课中会看到的共同点 

474
00:25:26,910 --> 00:25:29,870
因为我们也在类似的对话中实现了这一点 

475
00:25:29,870 --> 00:25:34,910
因为我们不知道用户什么时候会在对话框上按空格键

476
00:25:34,910 --> 00:25:36,630
把窗户关上

477
00:25:36,630 --> 00:25:39,320
但如果我们想要那扇窗 想要清除对话

478
00:25:39,320 --> 00:25:41,690
引发某种事件对吧

479
00:25:41,690 --> 00:25:44,830
例如 如果他们在战斗中按回车键 

480
00:25:44,830 --> 00:25:46,534
我们想让它进入下一个行动 

481
00:25:46,534 --> 00:25:48,700
我们不一定知道它什么时候会发生 

482
00:25:48,700 --> 00:25:54,770
所以我们只需要向对话状态传递一个匿名函数

483
00:25:54,770 --> 00:25:59,760
每当在该对话框上调用Close函数时 类都将调用

484
00:25:59,760 --> 00:26:00,260
州政府 

485
00:26:00,260 --> 00:26:03,170
它说 当关闭时 执行这个匿名函数 

486
00:26:03,170 --> 00:26:06,320
然后那个匿名函数就可以做你想做的任何事情 

487
00:26:06,320 --> 00:26:09,170
它可能会将其他几个状态弹出到堆栈上 

488
00:26:09,170 --> 00:26:12,057
但这就是允许我们链接异步行为的原因 

489
00:26:12,057 --> 00:26:12,890
这是这里的关键 

490
00:26:15,650 --> 00:26:18,800
所以这个匿名函数--所以我们现在来看一下

491
00:26:18,800 --> 00:26:23,340
在淡入状态 这样我们就可以看到这是什么样子的 

492
00:26:23,340 --> 00:26:26,360
所以我们在这里看到 褪色状态 对 吸收颜色 

493
00:26:26,360 --> 00:26:30,560
我们以前看到过 那将是我们褪色的颜色 

494
00:26:30,560 --> 00:26:34,580
我们实际执行转换所需的时间长度 

495
00:26:34,580 --> 00:26:46,390
我们用什么来过渡 我们认为 Timer Tweet 对吗？

496
00:26:46,390 --> 00:26:51,890
所以我们实际上要做的大部分事情

497
00:26:51,890 --> 00:26:55,150
在这堂课的整个过程中 都有异步行为 

498
00:26:55,150 --> 00:26:57,420
我们可以用定时器来实现它 这很好 

499
00:26:57,420 --> 00:27:01,600
它允许我们相当简洁和声明地告诉

500
00:27:01,600 --> 00:27:04,670
准确地说出了我们希望随着时间的推移而发生的事情 

501
00:27:04,670 --> 00:27:07,930
在这种情况下 我们将在一段时间内

502
00:27:07,930 --> 00:27:11,840
把我们自己的不透明度提高到255 

503
00:27:11,840 --> 00:27:15,627
所以淡入会淡入我们所有东西的全色

504
00:27:15,627 --> 00:27:16,210
已经把它给了 

505
00:27:16,210 --> 00:27:22,180
因此它将从0(默认情况下显示在这里)到255 

506
00:27:22,180 --> 00:27:27,550
然后我们一拍完那个小插曲 

507
00:27:27,550 --> 00:27:32,740
这就是我们弹出淡入状态的时候 

508
00:27:32,740 --> 00:27:35,920
我们将有效地把我们自己从州里跳出来 从堆栈中跳出来

509
00:27:35,920 --> 00:27:37,840
有效地 

510
00:27:37,840 --> 00:27:41,150
然后在这里 我们呼吁淡出完成 

511
00:27:41,150 --> 00:27:43,210
这就是匿名函数所在的位置 

512
00:27:43,210 --> 00:27:45,430
在淡入淡出时 完成被传递到这里 

513
00:27:45,430 --> 00:27:52,630
因此 通过将该函数放入补间操作的结束函数中 

514
00:27:52,630 --> 00:27:58,710
我们允许自己推迟我们在--中写的函数

515
00:27:58,710 --> 00:28:01,120
它处于启动状态 

516
00:28:01,120 --> 00:28:04,750
我们将此函数的执行推迟到补间操作之后

517
00:28:04,750 --> 00:28:05,700
发生了 

518
00:28:05,700 --> 00:28:08,220
这说得通吗？

519
00:28:08,220 --> 00:28:09,764
好的 太棒了 

520
00:28:09,764 --> 00:28:11,180
这实际上就是它的本质 

521
00:28:11,180 --> 00:28:13,970
这是一个共同的主题 如果你浏览一下发行版 我们会看到这一点 

522
00:28:13,970 --> 00:28:15,620
你会在很多地方看到它 

523
00:28:15,620 --> 00:28:17,870
匿名函数或回调函数

524
00:28:17,870 --> 00:28:24,860
而是被传递到对话和淡出之类的东西中 

525
00:28:24,860 --> 00:28:26,747
还有其他几个地方 

526
00:28:26,747 --> 00:28:28,580
例如 在轮流状态中 有

527
00:28:28,580 --> 00:28:30,920
也接受回调函数的函数 

528
00:28:30,920 --> 00:28:38,210
这是您可以有效地链接异步行为的方式

529
00:28:38,210 --> 00:28:41,105
随着时间的推移执行 而不是被阻塞 

530
00:28:41,105 --> 00:28:44,630
到目前为止 有没有人对这是如何运作的有任何疑问？

531
00:28:47,780 --> 00:28:51,980
好了 当淡入淡出后--

532
00:28:51,980 --> 00:28:54,440
我们仍然是这里的起点--

533
00:28:54,440 --> 00:28:58,820
在这一点上 淡出完成 我们正在执行这个匿名函数 

534
00:28:58,820 --> 00:29:09,840
在本例中 我们将从堆栈中弹出Start状态 

535
00:29:09,840 --> 00:29:12,570
然后我们要推动一个--

536
00:29:12,570 --> 00:29:15,780
我们要在这里做两个推力 

537
00:29:15,780 --> 00:29:20,960
一种是推动一种播放状态 这就是NPC[INAUDIBLE]

538
00:29:20,960 --> 00:29:23,210
走来走去的角色 

539
00:29:23,210 --> 00:29:27,294
还有一个就是推动对话状态 

540
00:29:27,294 --> 00:29:29,960
因此 这将产生的影响是 而不是我们

541
00:29:29,960 --> 00:29:33,150
立即进入玩耍状态 能够四处走动 

542
00:29:33,150 --> 00:29:35,634
我们实际上置身于一个

543
00:29:35,634 --> 00:29:37,550
有一条消息等着我们 我们有

544
00:29:37,550 --> 00:29:40,640
按Enter On以继续 

545
00:29:40,640 --> 00:29:45,230
当我们按回车键时 因为我们先按播放状态 

546
00:29:45,230 --> 00:29:47,410
然后是对话状态 对话状态

547
00:29:47,410 --> 00:29:49,670
在堆栈的顶部 对吧 因为

548
00:29:49,670 --> 00:29:53,060
就像一堆盘子一样被推上来 

549
00:29:53,060 --> 00:29:56,150
你把一个游戏状态牌放在底部 然后在上面放另一个牌 

550
00:29:56,150 --> 00:30:00,180
在这种情况下 这块板就是对话状态 

551
00:30:00,180 --> 00:30:02,330
而你只能与顶层互动--

552
00:30:02,330 --> 00:30:06,290
在此型号中 我们一次只更新顶板 

553
00:30:06,290 --> 00:30:08,630
很明显 我们可以制造一个更复杂的状态

554
00:30:08,630 --> 00:30:14,090
堆栈允许我们同时更新多层状态 

555
00:30:14,090 --> 00:30:19,940
但为了简单起见 我们只选择允许更新顶层 

556
00:30:19,940 --> 00:30:21,986
对话状态将是活动状态 

557
00:30:21,986 --> 00:30:23,360
它将接收输入 

558
00:30:23,360 --> 00:30:25,930
它们都将被渲染 所以我们

559
00:30:25,930 --> 00:30:27,680
要自下而上地渲染 

560
00:30:27,680 --> 00:30:28,940
我们将呈现播放状态 然后

561
00:30:28,940 --> 00:30:31,010
我们将呈现对话状态 但对话状态的

562
00:30:31,010 --> 00:30:31,910
会变得活跃起来 

563
00:30:31,910 --> 00:30:35,120
我们只能对该州的任何事情进行施压 

564
00:30:35,120 --> 00:30:40,550
最后 实际上 甚至超越了对话状态 

565
00:30:40,550 --> 00:30:43,500
我们正在推动另一个州 我们正在推动一个淡出的州 

566
00:30:43,500 --> 00:30:47,150
在这种情况下 它与淡出状态相反 

567
00:30:47,150 --> 00:30:51,170
它只需要一个RGB 我们将从255不透明度

568
00:30:51,170 --> 00:30:54,180
在这种情况下为零不透明度 

569
00:30:54,180 --> 00:31:00,470
因此 这使得我们能够做正确的事情 

570
00:31:00,470 --> 00:31:03,320
我们现在处于开始状态 按Enter键 

571
00:31:03,320 --> 00:31:06,860
这就是我们在州里的淡出 

572
00:31:06,860 --> 00:31:11,510
然后我们进入了游戏状态、对话状态和淡出状态

573
00:31:11,510 --> 00:31:15,440
所以你几乎会认为

574
00:31:15,440 --> 00:31:18,020
我们推入淡入 然后淡出 

575
00:31:18,020 --> 00:31:21,560
但我们必须先奠定基础 然后才能

576
00:31:21,560 --> 00:31:24,170
将淡出状态放在堆栈的顶部 

577
00:31:24,170 --> 00:31:27,720
对 因为最上面的层被更新了 

578
00:31:27,720 --> 00:31:30,890
所以我们必须把淡出状态放在所有这些状态之上 

579
00:31:30,890 --> 00:31:32,797
它会被更新 会淡出 

580
00:31:32,797 --> 00:31:34,880
然后我们回到我们推动的两个州

581
00:31:34,880 --> 00:31:36,870
在我们推入淡出状态之前 

582
00:31:36,870 --> 00:31:39,240
那是从那以后的事吗？

583
00:31:39,240 --> 00:31:40,300
好的 

584
00:31:40,300 --> 00:31:44,710
有没有人对这种流动是如何运作的有任何疑问？

585
00:31:44,710 --> 00:31:47,110
凉爽的 

586
00:31:47,110 --> 00:31:49,510
好吧 这就是背后的主旨 我的意思是 

587
00:31:49,510 --> 00:31:54,280
这基本上是我们今天所做的事情的核心

588
00:31:54,280 --> 00:31:56,890
是推送多个状态的状态堆栈 

589
00:31:56,890 --> 00:31:58,940
然后只需弄清楚正确的顺序

590
00:31:58,940 --> 00:32:02,710
需要把它们推进去才能得到你想要的外观 

591
00:32:02,710 --> 00:32:03,340
对吗？

592
00:32:03,340 --> 00:32:07,180
当我们处于开始状态时 我们按下淡出状态 

593
00:32:07,180 --> 00:32:08,430
或者更确切地说 是在状态中褪色 

594
00:32:08,430 --> 00:32:10,990
这将把我们带到白色 然后像排序

595
00:32:10,990 --> 00:32:17,440
几乎就像在幕后--在幕后 我们打开了一切 

596
00:32:17,440 --> 00:32:20,770
然后我们添加戏剧 对话 然后另一个淡出

597
00:32:20,770 --> 00:32:21,380
州政府 

598
00:32:21,380 --> 00:32:25,419
因此 你必须平衡你把东西放在一起的顺序

599
00:32:25,419 --> 00:32:26,710
以达到预期的效果 

600
00:32:26,710 --> 00:32:28,876
它不一定和你直觉上的一模一样

601
00:32:28,876 --> 00:32:32,110
想一想 直到你想到我们是如何更新和渲染的

602
00:32:32,110 --> 00:32:34,030
堆积如山的东西 

603
00:32:34,030 --> 00:32:38,195
所以这是我认为真正感到舒适的终极障碍

604
00:32:38,195 --> 00:32:41,320
但一旦你得到了它 其他的一切都会下降

605
00:32:41,320 --> 00:32:42,290
就位 

606
00:32:42,290 --> 00:32:46,600
以及丰富的异步函数 正如我们将介绍的

607
00:32:46,600 --> 00:32:49,660
我们很快就会看到图形用户界面 以及我们是如何实现

608
00:32:49,660 --> 00:32:51,590
很多基本的图形用户界面功能 

609
00:32:51,590 --> 00:32:54,460
其中很大一部分是非常、非常受回拨驱动的 

610
00:32:54,460 --> 00:32:58,012
只是因为它的本质是基于用户输入的 对吗？

611
00:32:58,012 --> 00:33:00,220
你不知道用户什么时候会做任何输入 

612
00:33:00,220 --> 00:33:04,240
因此 无论图形用户界面代码发生什么情况 请将其推迟

613
00:33:04,240 --> 00:33:08,140
在用户按空格键时所涉及的触发器的情况下 

614
00:33:08,140 --> 00:33:13,660
输入 然后调用已传递到该图形用户界面小部件中的函数 

615
00:33:13,660 --> 00:33:17,020
好了 我们来看看状态堆栈 

616
00:33:17,020 --> 00:33:20,270
我们已经看了开始状态 淡入状态 

617
00:33:20,270 --> 00:33:22,290
现在让我们来看看播放状态 

618
00:33:25,690 --> 00:33:26,624
所以游戏状态--

619
00:33:26,624 --> 00:33:28,540
这其中有很多实际上非常类似于

620
00:33:28,540 --> 00:33:35,080
我们回到了塞尔达 这是一款非常类似的自上而下的游戏 

621
00:33:35,080 --> 00:33:40,450
观点 唯一的区别是这种性质的RPG--

622
00:33:40,450 --> 00:33:42,730
《最终幻想》、《精灵宝可梦》、《寻龙诀》

623
00:33:42,730 --> 00:33:47,110
平铺到你移动的均匀程度就是平铺 

624
00:33:47,110 --> 00:33:51,620
因此 我们在这堂课中努力实现了这一点 

625
00:33:51,620 --> 00:33:57,340
所以当我们移动我们的球员 我们的角色时 

626
00:33:57,340 --> 00:34:02,660
例如 它没有像塞尔达那样的自由运动 

627
00:34:02,660 --> 00:34:03,950
所以我将演示这一点 

628
00:34:03,950 --> 00:34:07,360
所以我可以转到这里的场状态 播放状态 抱歉 

629
00:34:07,360 --> 00:34:09,969
然后当我移动时 如果我按向右 他

630
00:34:09,969 --> 00:34:13,850
以完美的栅格间隔朝该方向移动 

631
00:34:13,850 --> 00:34:16,690
所以如果我往上走 我的手就会立刻离开 

632
00:34:16,690 --> 00:34:20,980
他将继续前进 他将坚守在这个网格上 

633
00:34:20,980 --> 00:34:25,130
这只是这些游戏实现的一种趋势 

634
00:34:25,130 --> 00:34:29,139
它允许您与网格保持完美一致 并帮助您

635
00:34:29,139 --> 00:34:30,800
我想某些游戏--

636
00:34:30,800 --> 00:34:33,429
我认为这可能不是严格意义上的

637
00:34:33,429 --> 00:34:37,239
大多数选择实现这一点的游戏 

638
00:34:37,239 --> 00:34:41,500
我认为这是NES和GameBoy基于瓷砖的游戏的症状

639
00:34:41,500 --> 00:34:47,170
更易于设计和实现的时代 

640
00:34:47,170 --> 00:34:51,699
因为它们是非常基于磁贴的系统 

641
00:34:51,699 --> 00:34:55,030
但我的意思是 即使作为一种审美选择 我认为它也是有意义的 

642
00:34:55,030 --> 00:34:57,472
因为一切都非常完美地排列在一起 

643
00:34:57,472 --> 00:35:00,430
所以这就是这场比赛中球场状态的核心区别 

644
00:35:00,430 --> 00:35:09,160
那么 我们如何着手实现这样的网格对齐移动系统呢

645
00:35:09,160 --> 00:35:12,170
与我们的球员相比 我们在塞尔达是如何做到这一点的？

646
00:35:16,690 --> 00:35:18,862
我们是怎么想的--当然 是吗？

647
00:35:18,862 --> 00:35:23,200
观众：所以我们没有x和y 我们只有瓷砖的位置 

648
00:35:23,200 --> 00:35:26,410
演讲者1：所以你没有x和y 我们只有平铺位置 

649
00:35:26,410 --> 00:35:30,790
接近 我会说它更专注于瓷砖的位置 

650
00:35:30,790 --> 00:35:33,790
但你仍然需要一个x和一个y 因为你仍然

651
00:35:33,790 --> 00:35:37,142
需要在那个准确的位置画出那个精灵 

652
00:35:37,142 --> 00:35:38,250
对吧 托尼？

653
00:35:38,250 --> 00:35:42,400
观众：嗯 当你需要移动精灵的时候

654
00:35:42,400 --> 00:35:47,080
每次更新时都会移动 在两个磁贴位置之间进行补间 

655
00:35:47,080 --> 00:35:51,680
演讲者1：完全正确 所以与其移动精灵

656
00:35:51,680 --> 00:35:57,970
在每次更新的准确像素位置 您可以在收到输入时补间精灵

657
00:35:57,970 --> 00:35:59,950
到一个特定的位置 

658
00:35:59,950 --> 00:36:02,780
然后我们实际上也在这一点上停止了输入 

659
00:36:02,780 --> 00:36:08,020
当我们不完全处于给定的块时 我们没有任何输入的用处 

660
00:36:08,020 --> 00:36:12,170
所以当他有效地行走时 我们禁用输入 

661
00:36:12,170 --> 00:36:16,150
所以这是实现的 如果我们查看实体中的发行版

662
00:36:16,150 --> 00:36:19,318
同学们 这里有一个--

663
00:36:19,318 --> 00:36:20,350
我相信它就在这里--

664
00:36:24,660 --> 00:36:25,800
可能是玩家 等一下 

665
00:36:32,360 --> 00:36:35,030
哦 对不起 不是实体行走状态 不是实体 

666
00:36:35,030 --> 00:36:38,600
实体只是相关信息的容器 

667
00:36:38,600 --> 00:36:42,510
因此 在实体漫游状态下 我们尝试移动 

668
00:36:42,510 --> 00:36:45,395
因此 尝试移动所做的基本上是

669
00:36:45,395 --> 00:36:49,820
它看起来是为了确保我们在地图的范围内 对吗？

670
00:36:49,820 --> 00:36:51,970
然后 如果我们是--

671
00:36:51,970 --> 00:36:56,917
这个游戏中的每个实体现在都有一个地图y和x 以及一个常规的y和x 

672
00:36:56,917 --> 00:36:59,000
所以正规的y和x 我们仍然需要

673
00:36:59,000 --> 00:37:01,880
在地图上的特定位置绘制我们的精灵 

674
00:37:01,880 --> 00:37:09,320
我们仍然需要把它画在240多到230多之间 对吗？

675
00:37:09,320 --> 00:37:12,650
但我们需要一个地图x和一个地图y来表示 好的 

676
00:37:12,650 --> 00:37:15,680
精灵应该在地图上的这个位置 

677
00:37:15,680 --> 00:37:19,220
然后我们就把它夹在位置乘以16之间 

678
00:37:19,220 --> 00:37:22,610
这是位置加上或减去x或y

679
00:37:22,610 --> 00:37:26,000
乘以16 这将给出我们确切的x和y值

680
00:37:26,000 --> 00:37:27,480
需要把它画到地图上 

681
00:37:27,480 --> 00:37:28,980
这就是我们在这里做的事情 

682
00:37:28,980 --> 00:37:32,630
因此 我们将在输入时调用尝试移动 

683
00:37:32,630 --> 00:37:34,440
所以每当我们做任何输入时--

684
00:37:34,440 --> 00:37:39,950
这是在游戏者身上完成的 或者是游戏者 是的 游戏者

685
00:37:39,950 --> 00:37:41,900
闲置班级--

686
00:37:41,900 --> 00:37:43,820
玩家空闲状态 

687
00:37:43,820 --> 00:37:46,520
我们将动画更改为编写动画 

688
00:37:46,520 --> 00:37:48,710
然后我们得到了当前的地图x和y 

689
00:37:48,710 --> 00:37:51,410
然后根据玩家所看的方向 

690
00:37:51,410 --> 00:37:56,720
或者实体正在寻找 我们可以将其用于NPC类或类似的类 

691
00:37:56,720 --> 00:37:59,870
我们只需修改2x和2y即可 

692
00:37:59,870 --> 00:38:04,390
因此 2x和2y将是我们向16倍递增的值 

693
00:38:04,390 --> 00:38:05,950
对吗？

694
00:38:05,950 --> 00:38:10,940
因此 如果我们试图走出地图的边界 

695
00:38:10,940 --> 00:38:13,340
仅仅将我们改回空闲状态不会让我们这样做 

696
00:38:13,340 --> 00:38:19,620
否则 立即将地图y和地图x设置到该位置 

697
00:38:19,620 --> 00:38:22,880
对 因为这只是一个减或加一的运算 

698
00:38:22,880 --> 00:38:28,010
然后在0.5秒的过程中 实际上是补间到那个值 

699
00:38:28,010 --> 00:38:30,770
我们可以在这里看到 我们正在调整到瓷砖的大小 

700
00:38:30,770 --> 00:38:35,212
实际上是瓷砖大小减去自身的整体高度除以2 

701
00:38:35,212 --> 00:38:36,170
我们知道这是为什么吗？

702
00:38:40,820 --> 00:38:45,385
我们这样做 是因为如果我们观察现场 我们可以在这里看到 

703
00:38:45,385 --> 00:38:48,010
注意到我们并没有和草地完美地排成一条线 对吗？

704
00:38:48,010 --> 00:38:50,050
这有点像我们已经超过了它一半 

705
00:38:50,050 --> 00:38:53,050
因为这样看起来更自然一点 

706
00:38:53,050 --> 00:38:54,967
这就是大多数游戏的样子 

707
00:38:54,967 --> 00:38:56,800
如果你在这样的游戏中 你是

708
00:38:56,800 --> 00:38:58,821
比如靠墙走 

709
00:38:58,821 --> 00:39:00,820
这会让你看起来像是

710
00:39:00,820 --> 00:39:03,100
靠着墙 而不是某种

711
00:39:03,100 --> 00:39:06,880
在墙底的边缘 看起来有点不自然 

712
00:39:06,880 --> 00:39:12,290
这就是为什么我们在那里减去一半的身高 

713
00:39:12,290 --> 00:39:15,910
然后当我们完成的时候 我们实际上

714
00:39:15,910 --> 00:39:18,770
测试我们是否仍在按某个键 如果是 

715
00:39:18,770 --> 00:39:20,710
然后将我们的状态改变为再次行走 这

716
00:39:20,710 --> 00:39:24,727
我们将根据我们所关注的方向重复这个过程 

717
00:39:24,727 --> 00:39:25,810
实际上就是这样 

718
00:39:25,810 --> 00:39:28,462
这就是我们能够得到这种基于网格的运动的原因 

719
00:39:28,462 --> 00:39:29,920
对于这是如何工作的 有什么问题吗？

720
00:39:33,280 --> 00:39:33,780
凉爽的 

721
00:39:37,335 --> 00:39:43,200
让我们来看看比赛状态 让我们回到它 

722
00:39:43,200 --> 00:39:46,110
所以我们有一个级别 这个级别包含我们的实体 

723
00:39:46,110 --> 00:39:49,394
它可以包含我们所有的实体 无论是什么

724
00:39:49,394 --> 00:39:50,685
您希望它包含的对象 

725
00:39:53,190 --> 00:39:55,530
在这种情况下 当我们也处于播放状态时 

726
00:39:55,530 --> 00:39:57,279
我们要检查一下是否按P键 

727
00:39:57,279 --> 00:39:59,820
因为这就是召回 我们可以治愈我们的精灵宝可梦 

728
00:39:59,820 --> 00:40:05,410
只是一个小游戏黑客 只是为了让演示变得更容易一点 

729
00:40:05,410 --> 00:40:11,800
但如果我们按下P键 我们就会播放治愈音 我们拿出我们的.

730
00:40:11,800 --> 00:40:16,110
稍后我们会更详细地了解这一点 所有这些 

731
00:40:16,110 --> 00:40:24,090
但邮箱：self.vel.player.pa rty.pokemon@index1.Currenthp

732
00:40:24,090 --> 00:40:29,416
等于self.vel.player.party.pokemon@1.hp 

733
00:40:29,416 --> 00:40:32,040
所以不同的是 目前的惠普是你目前拥有的一切 

734
00:40:32,040 --> 00:40:33,330
你可能会受到伤害 

735
00:40:33,330 --> 00:40:35,730
无论你的最大生命值是多少 HP都是 

736
00:40:35,730 --> 00:40:38,860
简而言之 这就是你如何获得

737
00:40:38,860 --> 00:40:44,820
比如在比赛和RPG中的状态变化 以及健康和MP的差异 

738
00:40:44,820 --> 00:40:48,577
你必须记录所有这些东西的最大值和当前值 

739
00:40:48,577 --> 00:40:50,910
然后根据你是被抛光还是被调试 

740
00:40:50,910 --> 00:40:54,120
不管你是否受到了伤害 或者是否使用了咒语 

741
00:40:54,120 --> 00:40:56,610
你可以准确地反映出

742
00:40:56,610 --> 00:41:01,350
你的角色是 然后总是回到那个状态

743
00:41:01,350 --> 00:41:03,420
当你需要的时候 

744
00:41:03,420 --> 00:41:06,570
这里有趣的是 稍微复杂一点的事情

745
00:41:06,570 --> 00:41:10,350
当我们按P键时 我们想要显示一个对话框 上面写着 

746
00:41:10,350 --> 00:41:13,680
我将演示这一点 我们想显示一个对话框

747
00:41:13,680 --> 00:41:18,120
就像这个上面说的 我们按下P键 你的精灵宝可梦就被治愈了 对吧？

748
00:41:18,120 --> 00:41:19,200
现在我动不了了 

749
00:41:19,200 --> 00:41:20,790
我在按箭头键 

750
00:41:20,790 --> 00:41:23,430
我根本不能移动我的角色 因为这个对话框说--

751
00:41:23,430 --> 00:41:28,950
我们处于一个新状态 我们已经将一个新状态推送到状态堆栈中 

752
00:41:28,950 --> 00:41:32,380
这就是这里的对话状态 它取了一个值 

753
00:41:32,380 --> 00:41:37,030
因为它是堆栈的顶层 所以它不能更新 

754
00:41:37,030 --> 00:41:40,200
或者它正在更新 我们不能更新播放状态 对吧 

755
00:41:40,200 --> 00:41:44,850
基于我们如何建模我们的州堆栈操作 或者它是如何工作的 

756
00:41:44,850 --> 00:41:47,970
然后我一按回车键 它就弹出来了 

757
00:41:47,970 --> 00:41:49,030
我们刚刚把它搞定了 

758
00:41:49,030 --> 00:41:51,570
现在顶部的位置写着 我可以再次移动了 

759
00:41:51,570 --> 00:41:52,740
这就是正在发生的事情 

760
00:41:52,740 --> 00:42:02,700
因此 对话状态实际上在某种意义上非常类似于淡入淡出

761
00:42:02,700 --> 00:42:06,450
进入和淡出状态 请注意 它接受一个匿名函数 

762
00:42:06,450 --> 00:42:09,251
何时调用此匿名函数？

763
00:42:09,251 --> 00:42:09,750
我们知道吗？

764
00:42:12,750 --> 00:42:16,311
在什么结束的时候？

765
00:42:16,311 --> 00:42:18,600
观众：[听不见]

766
00:42:18,600 --> 00:42:24,790
演讲者1：是的 当用户关闭对话框时 正确 

767
00:42:24,790 --> 00:42:27,800
那么 让我们来看看对话状态 

768
00:42:27,800 --> 00:42:32,640
我们可以看到 它实际上很简单 很小 

769
00:42:32,640 --> 00:42:36,480
我们有一条短信和一个回电 对吗？

770
00:42:36,480 --> 00:42:39,600
这里使用的是文本 

771
00:42:39,600 --> 00:42:42,870
我们实例化 当我们开始研究图形用户界面时 我们将详细了解这一点 

772
00:42:42,870 --> 00:42:45,450
以及他们在这里实现的所有窗口小部件 

773
00:42:45,450 --> 00:42:52,020
该文本框被放置在硬编码位置 并且它接收该文本 

774
00:42:52,020 --> 00:42:56,490
然后我们将self.call回调设置为该回调函数 

775
00:42:56,490 --> 00:43:00,630
如果我们关闭了文本框 这意味着我们将

776
00:43:00,630 --> 00:43:03,990
查看self.extbox.isClosed 其中

777
00:43:03,990 --> 00:43:07,080
是Text Box类的函数 

778
00:43:07,080 --> 00:43:12,660
如果它已关闭 则执行self.allback 然后弹出

779
00:43:12,660 --> 00:43:15,870
堆栈的这个对话框状态 对吗？

780
00:43:15,870 --> 00:43:19,710
所以这在某种意义上是相似的 淡入淡出 

781
00:43:19,710 --> 00:43:21,430
然后它接受匿名函数 

782
00:43:21,430 --> 00:43:23,388
唯一的区别在于它是如何执行的 

783
00:43:23,388 --> 00:43:25,350
在淡入状态下 匿名函数

784
00:43:25,350 --> 00:43:28,160
在Finish函数结束时被调用 该函数

785
00:43:28,160 --> 00:43:30,100
是补间对象的一部分 

786
00:43:30,100 --> 00:43:33,840
在本例中 我们在以下情况下显式执行回调函数

787
00:43:33,840 --> 00:43:35,460
我们已关闭文本框 

788
00:43:35,460 --> 00:43:40,440
因此 我们等待用户输入 而不是等待某个异步操作

789
00:43:40,440 --> 00:43:42,570
才能完成 

790
00:43:42,570 --> 00:43:45,990
当然 我们称之为文本框呈现 

791
00:43:45,990 --> 00:43:49,566
然后 我们将很快看到所有这些方法都是这些小部件的一部分 

792
00:43:49,566 --> 00:43:52,690
但乍一看 这就是对话状态真正发生的一切 

793
00:43:52,690 --> 00:43:55,980
非常简单 使用我们已有的相同模式

794
00:43:55,980 --> 00:44:01,530
将未来的行为推迟到匿名函数 

795
00:44:01,530 --> 00:44:07,025
关于这是如何运作的 或者到目前为止 有什么问题吗？

796
00:44:07,025 --> 00:44:09,164
凉爽的 

797
00:44:09,164 --> 00:44:11,330
好了 让我们来回顾一下比赛状态 

798
00:44:11,330 --> 00:44:14,180
我相信我们快要完成比赛状态了 

799
00:44:14,180 --> 00:44:18,810
是的 所以一切 这基本上就是这个游戏中的游戏状态 

800
00:44:18,810 --> 00:44:22,170
然后 许多正在发生的事情也在一定程度上发生 

801
00:44:22,170 --> 00:44:29,000
所以简而言之 我们有两张地图 两层 对吧 

802
00:44:29,000 --> 00:44:32,990
因为瓷砖上的草是它自己的一种[？字母？]

803
00:44:32,990 --> 00:44:36,440
它的周围是透明的 

804
00:44:36,440 --> 00:44:40,100
我们保留了一层基层 下面是一层草 

805
00:44:40,100 --> 00:44:43,610
然后是一个单独的高草层 

806
00:44:43,610 --> 00:44:45,950
然后我们就可以看看

807
00:44:45,950 --> 00:44:51,260
当我们走过高高的草地时 我们就进入了玩家步行状态 

808
00:44:51,260 --> 00:44:55,076
然后我们需要做什么来开始一个随机相遇？

809
00:45:01,171 --> 00:45:01,670
- 是吗-是的

810
00:45:01,670 --> 00:45:04,710
观众：[听不见]

811
00:45:04,710 --> 00:45:07,040
主持人1：是的 我们是如何开始的？

812
00:45:07,040 --> 00:45:08,890
我们在找什么？

813
00:45:08,890 --> 00:45:11,297
一旦触发战斗状态我们就会立即进入战斗状态 

814
00:45:11,297 --> 00:45:12,380
但我们要怎么触发呢

815
00:45:12,380 --> 00:45:13,702
我们在找什么？

816
00:45:13,702 --> 00:45:17,750
观众：[听不见]球员在草地上 

817
00:45:17,750 --> 00:45:20,150
我不知道是不是因为要搬到新的草地上 

818
00:45:20,150 --> 00:45:22,870
还是在草地上度过的时光

819
00:45:22,870 --> 00:45:25,820
是的 我们做一个随机的机会 每当球员在草地上 

820
00:45:25,820 --> 00:45:29,539
每当它们开始在草地上行走的时候 

821
00:45:29,539 --> 00:45:31,330
但你可以用任何方式 你可以做到这一点

822
00:45:31,330 --> 00:45:33,830
当他们离开草地 走进草地的时候

823
00:45:33,830 --> 00:45:35,871
在这种情况下 每当你按下按钮 

824
00:45:35,871 --> 00:45:38,780
如果他们碰巧在草地上 它会随机选择 概率是十分之一

825
00:45:38,780 --> 00:45:43,130
如果它等于1 10%的几率会触发遭遇战 

826
00:45:43,130 --> 00:45:46,670
这就是触发随机遭遇的要点

827
00:45:46,670 --> 00:45:48,602
很多这样的游戏

828
00:45:48,602 --> 00:45:49,810
有些游戏是不同的 

829
00:45:49,810 --> 00:45:52,795
有时候你走得越多 

830
00:45:52,795 --> 00:45:55,670
他们会有一个计数器 说 哦 我走了100步 

831
00:45:55,670 --> 00:45:57,680
现在应该更有可能了

832
00:45:57,680 --> 00:46:01,700
有些游戏是完全随机的 十分之一 五分之一 

833
00:46:01,700 --> 00:46:05,210
这取决于开发者决定如何实现他们的游戏 

834
00:46:05,210 --> 00:46:08,540
前者更健壮一点 

835
00:46:08,540 --> 00:46:11,750
但为了简单起见 我们只选择math.random10等于1 

836
00:46:14,680 --> 00:46:19,410
所以 是的 我们在这里创建瓷砖地图 非常简单 

837
00:46:19,410 --> 00:46:26,630
然后 实际的随机遭遇发生在玩家步行状态 

838
00:46:26,630 --> 00:46:29,570
所以这里我们检查了相遇 

839
00:46:29,570 --> 00:46:33,800
当我们进入行走状态时 

840
00:46:33,800 --> 00:46:37,650
我们是按下按钮进入 还是走进去 

841
00:46:37,650 --> 00:46:40,190
调用整个函数 因为我们

842
00:46:40,190 --> 00:46:43,160
在状态机中转换到玩家行走状态 

843
00:46:43,160 --> 00:46:45,826
所有实体仍在使用常规状态机

844
00:46:45,826 --> 00:46:46,880
而不是状态堆栈 

845
00:46:46,880 --> 00:46:49,400
并不是这次演示所必需的 尽管我确信

846
00:46:49,400 --> 00:46:52,879
有一些对实体使用状态堆栈的用例 

847
00:46:52,879 --> 00:46:55,170
在本例中 我们只使用常规状态机 

848
00:46:55,170 --> 00:46:59,360
因此 当我们更改为Walk状态时 我们将调用Enter 正如我们所看到的 

849
00:46:59,360 --> 00:47:02,830
然后我们调用self check ForEncount 

850
00:47:02,830 --> 00:47:07,340
因此 自己 check ForEncount将设置一个标志

851
00:47:07,340 --> 00:47:14,290
如果我们基本上还没有开始一次遭遇 就会允许我们移动 

852
00:47:14,290 --> 00:47:17,525
如果我们已经检查了一次相遇 它会的 

853
00:47:17,525 --> 00:47:21,470
或者 如果我们触发了一次遭遇 它就会推入check ForEncount 

854
00:47:21,470 --> 00:47:26,310
它实际上会将战斗状态推送到堆栈上 

855
00:47:26,310 --> 00:47:30,900
所以check ForEncount基本上就是做我们之前说过的事情 

856
00:47:30,900 --> 00:47:34,957
如果是草层 因为我们有两层 

857
00:47:34,957 --> 00:47:37,040
对 我们有基层和草层 

858
00:47:37,040 --> 00:47:43,760
因此 如果yx所在的yx处的层是实体map x和map y 

859
00:47:43,760 --> 00:47:46,610
如果它的ID等于高草 

860
00:47:46,610 --> 00:47:50,750
我们只有一个全局常量表 叫做

861
00:47:50,750 --> 00:47:52,960
磁贴ID 其中包含所有这些ID 

862
00:47:52,960 --> 00:47:57,080
且math.随机性10等于1 OK 将实体状态改为空闲 

863
00:47:57,080 --> 00:48:00,500
所以不要让他们继续走下去 

864
00:48:00,500 --> 00:48:02,645
暂停现场音乐 而不是停止 

865
00:48:02,645 --> 00:48:06,380
这样 当我们稍后回到赛场并按下Play键时 

866
00:48:06,380 --> 00:48:09,980
它将处于与以前完全相同的位置 

867
00:48:09,980 --> 00:48:14,900
引发了战斗音乐 然后 我们已经看到了 在状态中褪色 

868
00:48:14,900 --> 00:48:16,940
推送到堆栈 对吗？

869
00:48:16,940 --> 00:48:19,945
所以超过一秒钟 我们就会褪色成白色 

870
00:48:19,945 --> 00:48:22,070
所以这将会有音乐开始的效果 

871
00:48:22,070 --> 00:48:23,960
但我们马上就会褪色成白色 这

872
00:48:23,960 --> 00:48:27,785
与大多数RPG的操作方式非常相似 

873
00:48:27,785 --> 00:48:29,660
然后我们有我们的回调函数 它

874
00:48:29,660 --> 00:48:32,720
会在淡入状态结束后立即执行 对吗？

875
00:48:32,720 --> 00:48:35,720
在这种情况下 推向战斗状态 

876
00:48:35,720 --> 00:48:37,900
战斗状态需要一个实体 而实体

877
00:48:37,900 --> 00:48:39,650
有我们所有的精灵宝可梦信息 那是

878
00:48:39,650 --> 00:48:41,710
为什么我们要让它进入战斗状态 

879
00:48:41,710 --> 00:48:44,290
所以战斗状态可以说 哦 你有什么精灵宝可梦？

880
00:48:44,290 --> 00:48:49,010
好的 我会看着你的派对说 好的 你的第一个精灵宝可梦

881
00:48:49,010 --> 00:48:52,520
这是不是把他送上战场 等等 对不对？

882
00:48:52,520 --> 00:48:56,180
最后 推入淡出状态 对

883
00:48:56,180 --> 00:49:02,570
因为现在我们已经将战斗状态置于播放状态之上 

884
00:49:02,570 --> 00:49:05,260
但我们想淡入其中 对吗？

885
00:49:05,260 --> 00:49:08,180
所以我们将淡出 我们将把战斗状态放在第一位 

886
00:49:08,180 --> 00:49:10,820
然后因为我们使用的是堆栈 所以我们

887
00:49:10,820 --> 00:49:14,450
把命运置于最上面的状态 然后淡出 

888
00:49:14,450 --> 00:49:15,990
把它从堆栈上弹出来 

889
00:49:15,990 --> 00:49:19,760
然后我们就有了我们刚刚推动的战斗状态 对吗？

890
00:49:19,760 --> 00:49:21,760
然后是自己 遭遇基金会在这里设定 

891
00:49:21,760 --> 00:49:25,130
这就是创造一次相遇 随机检查 

892
00:49:25,130 --> 00:49:27,760
把正确的事情推到堆栈下 战斗状态 

893
00:49:27,760 --> 00:49:30,200
淡出状态 淡入 淡出 

894
00:49:30,200 --> 00:49:32,900
然后你就可以走了 

895
00:49:32,900 --> 00:49:35,400
所以这实际上就是--

896
00:49:35,400 --> 00:49:41,600
在RPG中 它被称为场对战斗或遭遇状态 

897
00:49:41,600 --> 00:49:44,882
尽管我们在这里称之为Play State 但我们已经离开了赛场 

898
00:49:44,882 --> 00:49:46,590
在这一点上 我们已经进入了战斗 

899
00:49:46,590 --> 00:49:48,500
所以现在我们基本上已经看到了一切

900
00:49:48,500 --> 00:49:51,790
这个领域必须为我们提供 

901
00:49:51,790 --> 00:49:54,530
我们已经报道了所有与此相关的内容 

902
00:49:54,530 --> 00:49:59,030
所以我们现在休息5到10分钟 

903
00:49:59,030 --> 00:50:01,980
当我们休息回来的时候 

904
00:50:01,980 --> 00:50:04,640
我们将讨论图形用户界面元素、面板、文本框、

905
00:50:04,640 --> 00:50:09,470
然后我们将深入研究战斗状态的那种机制 

906
00:50:09,470 --> 00:50:12,600
好了 欢迎回到第七课 精灵宝可梦 

907
00:50:12,600 --> 00:50:14,960
所以在休息之前 我们讨论了比赛状态 

908
00:50:14,960 --> 00:50:17,280
我们谈到了更重要的州堆栈 

909
00:50:17,280 --> 00:50:20,870
然后我们讨论了匿名函数是如何

910
00:50:20,870 --> 00:50:25,500
这是我们如何获得大量异步

911
00:50:25,500 --> 00:50:29,820
和延迟行为 这在RPG中很常见 

912
00:50:29,820 --> 00:50:34,550
我的意思是 很多类型 很多复杂的类型 

913
00:50:34,550 --> 00:50:39,560
像这样的游戏的另一个重要部分是图形用户

914
00:50:39,560 --> 00:50:42,890
界面 或者简称为GUI 

915
00:50:42,890 --> 00:50:46,550
像屏幕上的面板 标签之类的东西 

916
00:50:46,550 --> 00:50:53,880
可以移动的文本标签 比如列表 文本框 滚动条 

917
00:50:53,880 --> 00:50:56,150
你可以变得更疯狂

918
00:50:56,150 --> 00:51:03,140
在这节课里 我们主要讨论面板 标签 

919
00:51:03,140 --> 00:51:05,870
文本框和滚动条

920
00:51:05,870 --> 00:51:08,760
而不是滚动条 

921
00:51:08,760 --> 00:51:12,220
但我认为第一个角落

922
00:51:12,220 --> 00:51:17,000
或者第一种类似keystone的GUI小部件 

923
00:51:17,000 --> 00:51:21,410
我们应该考虑的是陪审团

924
00:51:21,410 --> 00:51:27,203
”““那是一个小组 听不见 

925
00:51:33,330 --> 00:51:41,680
如果我们把这个放在一个博弈中

926
00:51:41,680 --> 00:51:44,500
就当这是一个面板吧

927
00:51:44,500 --> 00:51:47,710
所以这就是一个小组的全部 对吗？

928
00:51:47,710 --> 00:51:49,960
它只是一个长方形 

929
00:51:49,960 --> 00:51:54,107
它让我们可以--如果你在看大多数的用户界面 

930
00:51:54,107 --> 00:51:56,440
比如屏幕上的文本框 或者你在Facebook上

931
00:51:56,440 --> 00:52:00,250
你看到的几乎是任何东西 比如你的小信息

932
00:52:00,250 --> 00:52:03,520
窗户 很多这些东西在最核心的地方 最底层 

933
00:52:03,520 --> 00:52:05,530
基础部分只是一个面板 

934
00:52:05,530 --> 00:52:11,023
那么 有没有人猜到在Love 2D中 我们如何制作一个简单的面板？

935
00:52:11,023 --> 00:52:12,899
观众：两个不同颜色的长方形 

936
00:52:12,899 --> 00:52:14,814
两个不同颜色的长方形

937
00:52:14,814 --> 00:52:16,360
这就是我们最终的结果

938
00:52:16,360 --> 00:52:18,650
这就是我们制作面板的有效方法 

939
00:52:18,650 --> 00:52:24,100
还有另一种制作面板的方法 但我们不会在这节课上做 

940
00:52:24,100 --> 00:52:26,530
但它叫做

941
00:52:26,530 --> 00:52:30,640
我们把它作为一个叫做九补丁的结构 

942
00:52:30,640 --> 00:52:37,240
所以九号补丁是...

943
00:52:37,240 --> 00:52:41,000
想象一下这张小图片 它的大小任意 

944
00:52:41,000 --> 00:52:42,704
但它很小

945
00:52:42,704 --> 00:52:44,620
这和很多游戏

946
00:52:44,620 --> 00:52:48,220
实现了他们的面板或图形用户

947
00:52:48,220 --> 00:52:52,270
在80年代和90年代 我的意思是 到今天为止 很多游戏的界面 

948
00:52:52,270 --> 00:52:58,330
但回到硬件基本上是基于瓦片的时候 

949
00:52:58,330 --> 00:53:06,850
你可以把这样的一张图片 分成九块 

950
00:53:06,850 --> 00:53:11,060
九补丁是这个术语的来源 

951
00:53:11,060 --> 00:53:15,700
回忆一下 这和我们建造塞尔达传说中的地牢有点类似 

952
00:53:15,700 --> 00:53:20,950
你有角块 然后是顶部 底部 右侧和左侧 

953
00:53:20,950 --> 00:53:24,320
你只要把这些一层一层地铺上 

954
00:53:24,320 --> 00:53:28,000
第一个 右边 角块 

955
00:53:28,000 --> 00:53:33,580
然后你需要多少就多少

956
00:53:33,580 --> 00:53:36,220
来创造这个矩形 对吧

957
00:53:36,220 --> 00:53:39,040
想象一下我们创造了

958
00:53:39,040 --> 00:53:45,260
这些都是 如果我们能把它们想象成一堆瓷砖 对吧？

959
00:53:52,750 --> 00:53:55,120
想象一下我们把这些角块 

960
00:53:55,120 --> 00:53:58,240
这些是角上的碎片 我们每个都取了一个

961
00:53:58,240 --> 00:54:02,410
然后我们把这些边片 画一堆

962
00:54:02,410 --> 00:54:04,000
那样的

963
00:54:04,000 --> 00:54:06,730
然后我们把这个中心装饰品 然后我们

964
00:54:06,730 --> 00:54:11,260
可以将它分层 或者平铺几次 或者只是拉伸它 

965
00:54:11,260 --> 00:54:15,160
拉伸它会带来一系列的好处 

966
00:54:15,160 --> 00:54:18,660
关于你如何设置你的过滤器模式 love.graphics.setdefaultfilter 

967
00:54:18,660 --> 00:54:21,130
如果将其设置为“双线性”与“最接近” 

968
00:54:21,130 --> 00:54:23,230
你可以得到一个很好的渐变 

969
00:54:23,230 --> 00:54:26,020
如果你把它设置为最近的 你会得到一个很好的像素化的外观 

970
00:54:26,020 --> 00:54:29,761
但是你会经常看到这一点 Unity对此有很好的支持 

971
00:54:29,761 --> 00:54:32,260
拍一张可能比你想象的更复杂的照片

972
00:54:32,260 --> 00:54:34,100
只需要两个长方形 对吧

973
00:54:34,100 --> 00:54:37,780
一些有设计的东西 也许是渐变色 实际上

974
00:54:37,780 --> 00:54:40,270
层

975
00:54:40,270 --> 00:54:46,030
我的意思是 创建一个任意大小的文本框来满足您的需要 

976
00:54:46,030 --> 00:54:49,770
如果这些甚至不是增量或无论你的瓷砖大小

977
00:54:49,770 --> 00:54:53,680
是在你的9补丁 你可以只规模的顶部 底部 左侧和右侧

978
00:54:53,680 --> 00:54:56,690
也是为了保持它的比例 中心装饰 

979
00:54:56,690 --> 00:54:58,865
所以这就说得通了 

980
00:54:58,865 --> 00:55:01,240
这是很常见的 我们不会在我们的课程中使用它 

981
00:55:01,240 --> 00:55:06,182
但这是很多图形用户界面设计中非常、非常常见的一部分 

982
00:55:06,182 --> 00:55:09,390
在许多游戏中 如果你对游戏开发有更多的了解 你会看到很多这样的游戏 

983
00:55:09,390 --> 00:55:12,400
所以这绝对值得一谈 

984
00:55:12,400 --> 00:55:17,620
我们今天要讨论的另一个部分是文本框 

985
00:55:17,620 --> 00:55:20,814
所以我的意思是 关于文本框是什么 

986
00:55:20,814 --> 00:55:23,730
我们如何实现文本框 以及我们将如何实现文本框？

987
00:55:27,450 --> 00:55:33,000
那么 我们可以从什么基础工作开始呢？

988
00:55:33,000 --> 00:55:35,023
我们已经有了--是吗？

989
00:55:35,023 --> 00:55:37,765
观众：你只要用爱的印记就行了

990
00:55:37,765 --> 00:55:40,171
其中一个盒子上方的屏幕上 

991
00:55:40,171 --> 00:55:43,420
演讲者1：准确地说 就是在其中一个盒子上方的屏幕上印上爱的印记 

992
00:55:43,420 --> 00:55:44,280
是啊 

993
00:55:44,280 --> 00:55:49,800
所以维护一个文本项目的列表 对 文本 

994
00:55:49,800 --> 00:55:57,090
然后只需将它们绘制在面板内 就会有一个文本框 

995
00:55:57,090 --> 00:56:00,360
你已经接受了两个想法 并将它们混合在一起 

996
00:56:00,360 --> 00:56:03,080
精选是一回事 

997
00:56:03,080 --> 00:56:07,290
这是唯一的不同之处 就是有一个选择--

998
00:56:07,290 --> 00:56:10,720
因此 如果我们想一想 选择是另一回事 

999
00:56:10,720 --> 00:56:15,970
例如 菜单中我们有战斗 像奔跑一样 

1000
00:56:15,970 --> 00:56:20,880
它可能是在一个更充实的游戏中 我们有一个项目的东西 

1001
00:56:20,880 --> 00:56:21,840
对吗？

1002
00:56:21,840 --> 00:56:25,830
所以这是一份有效的菜单 

1003
00:56:25,830 --> 00:56:28,650
它与我们在文本框中得到的非常相似 

1004
00:56:28,650 --> 00:56:32,910
但它有一系列的元素 战斗 物品 奔跑 

1005
00:56:32,910 --> 00:56:40,170
它们没有设置为换行 它们不是一个连续的文本集 

1006
00:56:40,170 --> 00:56:42,420
这只是一堆东西 

1007
00:56:42,420 --> 00:56:45,870
精选的好处是你可以

1008
00:56:45,870 --> 00:56:49,830
在你的选择上有一个光标 对吗？

1009
00:56:49,830 --> 00:56:53,052
然后我们需要联想到什么 比如 

1010
00:56:53,052 --> 00:56:54,760
如果我们想让这件事真正起作用 

1011
00:56:54,760 --> 00:56:57,220
如果我们想一想我们到目前为止所做的事情 

1012
00:56:57,220 --> 00:56:59,220
我们如何着手实现功能

1013
00:56:59,220 --> 00:57:00,680
有这样的选择吗？

1014
00:57:00,680 --> 00:57:04,353
比如 在我们的选择中 哪些条目需要与每个条目相关联？

1015
00:57:08,430 --> 00:57:09,910
回调函数 对吗？

1016
00:57:09,910 --> 00:57:11,680
就像我们处理其他一切一样 

1017
00:57:11,680 --> 00:57:15,690
如果你这里有一个战斗物品 每一个 如果我们考虑到选择

1018
00:57:15,690 --> 00:57:19,110
因为这只是我们所看到的这一部分 

1019
00:57:19,110 --> 00:57:22,700
对 因为这个背景部分只是一个面板 我们不在乎这个 

1020
00:57:22,700 --> 00:57:24,450
目前我们关心的是选择 

1021
00:57:24,450 --> 00:57:27,250
选择的是项目和箭头 对吗？

1022
00:57:27,250 --> 00:57:30,630
正如我们将在作业中看到的 你的目标实际上

1023
00:57:30,630 --> 00:57:33,750
接受选择并去掉箭头功能 

1024
00:57:33,750 --> 00:57:36,060
因为对于这个任务 你不需要

1025
00:57:36,060 --> 00:57:40,620
或者想要激活选择 激活光标 

1026
00:57:40,620 --> 00:57:43,620
你只想要一份物品清单 

1027
00:57:43,620 --> 00:57:52,570
但根据光标指向的内容以及我们按回车键之类的 

1028
00:57:52,570 --> 00:57:55,770
我们应该为所选内容编制索引 然后

1029
00:57:55,770 --> 00:57:59,680
执行与这些项中的每一项关联的回调 

1030
00:57:59,680 --> 00:58:02,400
这就是我们可以从选择中提取行为的方法 

1031
00:58:02,400 --> 00:58:05,410
而不仅仅是我们呈现在屏幕上的东西的列表 

1032
00:58:05,410 --> 00:58:08,340
如果我们打架了 我们按了Enter 这是一个回调

1033
00:58:08,340 --> 00:58:12,247
设置为可能将某个状态推送到堆栈上 该堆栈

1034
00:58:12,247 --> 00:58:15,330
会在屏幕上引发两个实体之间的互动 对吗？

1035
00:58:15,330 --> 00:58:17,010
第一个会攻击第二个 

1036
00:58:17,010 --> 00:58:18,600
第二个会攻击第一个 

1037
00:58:18,600 --> 00:58:21,766
这是它自己的一组异步状态 它们做着自己的事情 

1038
00:58:21,766 --> 00:58:24,750
但它是通过一个匿名函数启动的

1039
00:58:24,750 --> 00:58:27,980
我们都和这些东西联系在一起了 对吗？

1040
00:58:27,980 --> 00:58:32,460
一个项推送另一个状态 这类似于项的迷你状态 然后您

1041
00:58:32,460 --> 00:58:36,240
打开一套全新的菜单 您可以查看您的所有项目 

1042
00:58:36,240 --> 00:58:40,246
每一项都有一个与之关联的回调 对吗？

1043
00:58:40,246 --> 00:58:42,120
您的药水有关联的回调

1044
00:58:42,120 --> 00:58:45,750
这就是说 当我点击这个时 默认情况下 

1045
00:58:45,750 --> 00:58:48,120
只要恢复我的激活的精灵宝可梦的惠普 

1046
00:58:48,120 --> 00:58:50,070
或者让我来选择恢复的对象 

1047
00:58:50,070 --> 00:58:53,960
因此 推送另一个状态 就像选择一个精灵宝可梦

1048
00:58:53,960 --> 00:58:58,120
屏幕上有它自己的一组与每个回调相关联的回调 

1049
00:58:58,120 --> 00:59:01,911
它只是为了得到所有这种复杂的行为

1050
00:59:01,911 --> 00:59:04,410
这是你需要的 它最终真的只是推动各州

1051
00:59:04,410 --> 00:59:07,290
并将回调函数添加到所有这些不同的选项

1052
00:59:07,290 --> 00:59:09,570
你可以选择 

1053
00:59:09,570 --> 00:59:13,589
然后跑 推一个淡入淡出状态 然后弹出这个状态 

1054
00:59:13,589 --> 00:59:14,880
然后推入淡出状态 

1055
00:59:14,880 --> 00:59:16,380
这就是我们所做的一切 

1056
00:59:16,380 --> 00:59:20,250
下面我们来看看所有这些图形用户界面小部件

1057
00:59:20,250 --> 00:59:24,060
这只是一个概念性的外观 但我们很快就会看到

1058
00:59:24,060 --> 00:59:25,830
在一些实际的实现中 

1059
00:59:25,830 --> 00:59:34,060
最后一个我想看的是进度条 

1060
00:59:34,060 --> 00:59:37,350
以进度条为例 我们的惠普

1061
00:59:37,350 --> 00:59:45,000
在实际战斗中看到的 当我们受到伤害时 它从右到右

1062
00:59:45,000 --> 00:59:46,009
左边 

1063
00:59:46,009 --> 00:59:48,300
有没有人猜测我们是如何实现进度条的？

1064
00:59:48,300 --> 00:59:48,914
什么事 托尼？

1065
00:59:48,914 --> 00:59:50,534
观众：再一次 两个长方形 

1066
00:59:50,534 --> 00:59:52,200
演讲者1：两个长方形 没错 

1067
00:59:52,200 --> 00:59:55,860
一个 然后是Love2D中关于矩形的好事情

1068
00:59:55,860 --> 01:00:00,840
您可以将它们的边缘设置为圆角或不圆角

1069
01:00:00,840 --> 01:00:02,760
通过可选参数 

1070
01:00:02,760 --> 01:00:05,760
所以没有比矩形更复杂的东西

1071
01:00:05,760 --> 01:00:09,917
我们可以创造出这种近乎椭圆形的进程

1072
01:00:09,917 --> 01:00:11,250
条形图 非常简单的进度条 

1073
01:00:11,250 --> 01:00:14,310
一个是红色的 对 红色是背景 

1074
01:00:14,310 --> 01:00:15,870
然后画出轮廓 黑色 

1075
01:00:15,870 --> 01:00:18,780
并且其中一个被设置为填充第一个参数 

1076
01:00:18,780 --> 01:00:21,850
其中一个参数设置为与第一个参数成直线 

1077
01:00:21,850 --> 01:00:24,750
现在 我们如何开始制作动画 

1078
01:00:24,750 --> 01:00:29,080
当我们受到伤害时 我们如何激活生命值的下降？

1079
01:00:29,080 --> 01:00:29,580
是?

1080
01:00:29,580 --> 01:00:31,597
观众：在宽度之间 

1081
01:00:31,597 --> 01:00:33,180
扬声器1：正好在宽度之间 

1082
01:00:33,180 --> 01:00:34,560
我们要对它做些什么补充？

1083
01:00:34,560 --> 01:00:36,626
我们要怎么补齐它呢？

1084
01:00:36,626 --> 01:00:38,792
我们如何计算我们需要对它进行多少补间？

1085
01:00:38,792 --> 01:00:44,536
观众：嗯 你可以让你的宽度和你的健康相抵 

1086
01:00:44,536 --> 01:00:47,160
扬声器1：如果您的宽度设置为等于您剩余的健康 

1087
01:00:47,160 --> 01:00:49,860
那么你的健康状况可能是10岁 

1088
01:00:49,860 --> 01:00:52,860
你想要你的健康条有100个像素

1089
01:00:52,860 --> 01:00:54,585
龙 这是怎么回事 但工作？

1090
01:00:54,585 --> 01:00:55,740
观众：乘 

1091
01:00:55,740 --> 01:00:57,810
你可以乘它 但如果你

1092
01:00:57,810 --> 01:01:01,260
知道进度条的宽度

1093
01:01:01,260 --> 01:01:05,760
你可以用宽度乘以最大值的比率

1094
01:01:05,760 --> 01:01:12,030
你的HP值 或者抱歉 你当前HP与最大HP的比率 

1095
01:01:12,030 --> 01:01:12,990
对吧？

1096
01:01:12,990 --> 01:01:16,200
所以如果你少了--如果你有50 HP 你少了5 HP 

1097
01:01:16,200 --> 01:01:18,240
你的比率是45/50

1098
01:01:18,240 --> 01:01:22,950
如果你把它乘以宽度 你就得到了精确的宽度

1099
01:01:22,950 --> 01:01:26,625
不管你想让酒吧有多宽

1100
01:01:26,625 --> 01:01:29,250
如果你想要1,000像素 或者50像素 

1101
01:01:29,250 --> 01:01:35,569
只要你把当前健康值乘以最大健康值乘以宽度 

1102
01:01:35,569 --> 01:01:37,110
无论如何你都会得到那个比率

1103
01:01:37,110 --> 01:01:38,764
这有道理吗

1104
01:01:38,764 --> 01:01:39,590
酷了

1105
01:01:39,590 --> 01:01:43,140
这就是我们看到的所有GUI小部件 它们是如何排序的

1106
01:01:43,140 --> 01:01:46,630
与我们正在做的事情有关 

1107
01:01:46,630 --> 01:01:48,760
我们将在这里看看它们的实现 

1108
01:01:48,760 --> 01:01:51,141
所以我要打开面板 

1109
01:01:51,141 --> 01:01:52,890
我会讲得稍微快一点

1110
01:01:52,890 --> 01:01:57,150
所以我们可以进入战斗的核心 

1111
01:01:57,150 --> 01:02:03,420
面板就像我们之前说的 只有两个矩形 对吧？

1112
01:02:03,420 --> 01:02:06,000
它在一个高度内取xy 

1113
01:02:06,000 --> 01:02:08,060
然后我们画两个矩形 

1114
01:02:08,060 --> 01:02:09,750
一个比另一个大 

1115
01:02:09,750 --> 01:02:12,930
底部矩形略大于顶部矩形 

1116
01:02:12,930 --> 01:02:16,010
第一个矩形是白色的 

1117
01:02:16,010 --> 01:02:21,020
然后...抱歉抱歉

1118
01:02:21,020 --> 01:02:23,810
我们在一个高度内有一个xy 

1119
01:02:23,810 --> 01:02:26,120
然后我们在屏幕上画两个矩形 

1120
01:02:26,120 --> 01:02:29,330
我们有一个背景矩形 它首先被绘制出来 

1121
01:02:29,330 --> 01:02:32,840
也就是面板的整个xy宽度和高度 

1122
01:02:32,840 --> 01:02:36,290
然后我们用白色画出来 然后画

1123
01:02:36,290 --> 01:02:39,500
在这个游戏中 我们用同样的颜色画所有的东西 

1124
01:02:39,500 --> 01:02:40,760
但我们可以改变颜色

1125
01:02:40,760 --> 01:02:42,900
如果我们想让它参数化 我们可以这么做 

1126
01:02:42,900 --> 01:02:46,070
我们可以设置 我们可以在构造函数中有一个颜色选项 

1127
01:02:46,070 --> 01:02:49,190
我们不是这样做的 我们只是把所有东西都画成同样的颜色 

1128
01:02:49,190 --> 01:02:51,510
但这就是你获得定制菜单的方式 

1129
01:02:51,510 --> 01:02:54,694
有些RPG可以让你这么做 

1130
01:02:54,694 --> 01:02:57,860
然后我们在这里做的是我们只是在一个稍微小一点的范围内

1131
01:02:57,860 --> 01:02:58,730
边界 

1132
01:02:58,730 --> 01:03:02,179
所以在x和y上只小了两个像素 

1133
01:03:02,179 --> 01:03:04,220
你要画第二个矩形的地方 

1134
01:03:04,220 --> 01:03:06,950
这是一种灰色的深色 

1135
01:03:06,950 --> 01:03:09,425
这是一个小组 这就是小组的全部 

1136
01:03:09,425 --> 01:03:11,300
然后我们可以只有一个名为

1137
01:03:11,300 --> 01:03:14,430
切换 将其设置为可见或不可见 

1138
01:03:14,430 --> 01:03:19,130
如果它是可见的 就把它扔掉 如果它是可见的 对不起 就画出来 

1139
01:03:19,130 --> 01:03:21,560
否则 在渲染时不要绘制任何内容 

1140
01:03:21,560 --> 01:03:23,240
简而言之 这就是一个面板 

1141
01:03:23,240 --> 01:03:26,160
有什么问题吗？

1142
01:03:26,160 --> 01:03:26,960
凉爽的 

1143
01:03:26,960 --> 01:03:32,160
所以接下来我们要看的是文本框 

1144
01:03:32,160 --> 01:03:33,290
所以有一个文本框--

1145
01:03:33,290 --> 01:03:37,340
因此 文本框比面板稍微复杂一些 

1146
01:03:37,340 --> 01:03:41,990
简而言之 文本框需要接受一些任意的文本正文 

1147
01:03:41,990 --> 01:03:45,590
它需要根据文本框的宽度对其进行分割 

1148
01:03:45,590 --> 01:03:49,070
如果它超过了文本框的高度 

1149
01:03:49,070 --> 01:03:54,710
对 理想情况下 你应该翻页你的文字 这样你就可以按空格键 

1150
01:03:54,710 --> 01:04:00,020
输入并浏览多页文本 直到用完所有文本 

1151
01:04:00,020 --> 01:04:06,170
最后再按一次Enter键 就可以去掉那个文本框 

1152
01:04:06,170 --> 01:04:11,210
所以我们这里有一个面板 我们有XY的宽度和高度

1153
01:04:11,210 --> 01:04:12,710
在文本框的构造函数中 

1154
01:04:12,710 --> 01:04:14,349
我们也有我们的文本 

1155
01:04:14,349 --> 01:04:16,640
然后我们有一个字体 如果我们想要明确地决定

1156
01:04:16,640 --> 01:04:19,490
我们要使用的字体 

1157
01:04:19,490 --> 01:04:25,190
在这种情况下 或者在逃亡中 我们会说

1158
01:04:25,190 --> 01:04:30,530
我们实例化一个XY宽度和高度的面板 不要太花哨 

1159
01:04:30,530 --> 01:04:35,510
然后是幻想的部分 稍微复杂的部分

1160
01:04:35,510 --> 01:04:38,330
在这里的第20行 我们说 下划线

1161
01:04:38,330 --> 01:04:46,170
Self.extChucks得到的是self.font、getWrap、self.text、self.width减去12 

1162
01:04:46,170 --> 01:04:49,190
有谁知道这个函数是做什么的 或者想猜一猜？

1163
01:04:55,190 --> 01:04:55,690
是?

1164
01:04:55,690 --> 01:04:58,023
观众：这就是你说的那个页面吗？

1165
01:04:58,023 --> 01:05:01,192
演讲者1：没错 这就是文本的分页 

1166
01:05:01,192 --> 01:05:02,650
更确切地说是文本的组块 

1167
01:05:02,650 --> 01:05:07,060
不是文本的分页 而是文本的组块 这

1168
01:05:07,060 --> 01:05:08,650
我们将使用来对文本进行分页 

1169
01:05:08,650 --> 01:05:12,430
所以我们取了一些你知道的任意大的文本 

1170
01:05:12,430 --> 01:05:16,060
它可以像我们想要的那样大 并且给定--

1171
01:05:16,060 --> 01:05:20,090
这实际上是Love2D字体对象的一个函数 

1172
01:05:20,090 --> 01:05:23,020
这是Love2D给我们的 

1173
01:05:23,020 --> 01:05:26,350
GET WRAP将返回两个值 第二个值

1174
01:05:26,350 --> 01:05:32,620
是主体大体被分成的所有文本片段

1175
01:05:32,620 --> 01:05:33,770
根据宽度 

1176
01:05:33,770 --> 01:05:37,270
所以这个自身宽度是负12 这就是宽度

1177
01:05:37,270 --> 01:05:39,917
它将把我们的文本分成多个块 

1178
01:05:39,917 --> 01:05:42,250
它可能略小于 因为它将它分开

1179
01:05:42,250 --> 01:05:44,740
基于这个词 

1180
01:05:44,740 --> 01:05:51,280
但是 任何文本都不会超过自身宽度减去12宽度 

1181
01:05:51,280 --> 01:05:57,040
这将允许我们在文本中呈现几行文本

1182
01:05:57,040 --> 01:06:01,420
盒子 他们永远不会超过边界 对吗？

1183
01:06:01,420 --> 01:06:05,770
因此 分页功能实际上将在下一块中实现 

1184
01:06:05,770 --> 01:06:09,400
因此 我们在[？]的末尾称自己为Next针织？]功能 

1185
01:06:09,400 --> 01:06:13,750
然后Self下一步基本上检查一下 好的 我们在课文的末尾吗？

1186
01:06:13,750 --> 01:06:16,350
如果是 那么我们将不会显示任何文本 

1187
01:06:16,350 --> 01:06:18,450
我们要把窗户关上 

1188
01:06:18,450 --> 01:06:20,110
我们要关闭电池板 

1189
01:06:20,110 --> 01:06:24,470
但如果我们没有在文本的末尾 就像我们仍然得到文本一样 

1190
01:06:24,470 --> 01:06:26,830
我们想要做的是新桌子 

1191
01:06:26,830 --> 01:06:30,940
然后我们将进行最多三次迭代 

1192
01:06:30,940 --> 01:06:33,220
我们跟踪我们在块中的位置 对吗？

1193
01:06:33,220 --> 01:06:36,827
我们得到的文本块等于所有这些块 对吧 

1194
01:06:36,827 --> 01:06:38,410
这可能是一个任意的数字 

1195
01:06:38,410 --> 01:06:41,719
可能只有一块 可能有30块 对吧？

1196
01:06:41,719 --> 01:06:43,510
我们需要一个柜台来记录我们在哪里

1197
01:06:43,510 --> 01:06:47,530
都是基于我们所在的页面 对吧 

1198
01:06:47,530 --> 01:06:51,680
以及到目前为止我们在屏幕上渲染了多少行 

1199
01:06:51,680 --> 01:06:55,030
所以从i开始 我得到了块计数器 

1200
01:06:55,030 --> 01:06:57,100
并且块计数器将递增3

1201
01:06:57,100 --> 01:07:00,430
每次我们调用下一块 也就是每一页 

1202
01:07:00,430 --> 01:07:04,030
我们也可以很容易地将这一页称为下一页 

1203
01:07:04,030 --> 01:07:05,950
它将插入到Chchks表中

1204
01:07:05,950 --> 01:07:08,560
我们刚刚创建的 self.extChucks at i 

1205
01:07:08,560 --> 01:07:12,250
一旦我们达到了区块总数

1206
01:07:12,250 --> 01:07:16,420
我们从Get WRAP返回的 我们将标记文本结束

1207
01:07:16,420 --> 01:07:19,990
是真的 然后我们会把它退回 

1208
01:07:19,990 --> 01:07:22,300
因此 最终 我们将会

1209
01:07:22,300 --> 01:07:26,920
将等于我们从Font Get WRAP中获得的区块数量 

1210
01:07:26,920 --> 01:07:28,300
对吗？

1211
01:07:28,300 --> 01:07:31,585
一旦我们做到了 这将是Next的信号

1212
01:07:31,585 --> 01:07:34,570
是时候关闭文本框了 因为文本结束了

1213
01:07:34,570 --> 01:07:38,920
将在最后一个分块过程结束时设置为True 

1214
01:07:38,920 --> 01:07:41,562
然后我们可以看到 当我们更新文本框时 

1215
01:07:41,562 --> 01:07:43,520
当它在堆栈的顶部时 

1216
01:07:43,520 --> 01:07:47,000
记住 我们要找的是空格键或回车键

1217
01:07:47,000 --> 01:07:48,880
然后我们就给赛尔夫打个电话 

1218
01:07:48,880 --> 01:07:53,170
这将产生最终关闭我们的文本框的效果 

1219
01:07:53,170 --> 01:07:56,230
然后是封闭式召回 我们之前看过 我们检查过

1220
01:07:56,230 --> 01:07:59,300
要查看文本框是否关闭？

1221
01:07:59,300 --> 01:08:01,270
这只是我们在这里设置的一面旗帜 

1222
01:08:01,270 --> 01:08:06,280
然后出于渲染的目的 我们首先渲染面板 

1223
01:08:06,280 --> 01:08:10,750
然后对于我们的每个展示块 我们最多只有三个

1224
01:08:10,750 --> 01:08:16,480
一次显示块 这由下一个块函数设置 

1225
01:08:16,480 --> 01:08:22,569
我们只需将其打印到屏幕上 使用i作为y的乘数 

1226
01:08:22,569 --> 01:08:29,439
这将产生两到三条线 i i+1 i+2 

1227
01:08:29,439 --> 01:08:31,899
对文本框的工作原理有任何疑问吗？

1228
01:08:34,460 --> 01:08:36,939
当然 这比小组的工作要多一点 

1229
01:08:36,939 --> 01:08:38,470
但这相当直截了当 

1230
01:08:38,470 --> 01:08:40,960
我们只是在保存一堆文字信息的清单 

1231
01:08:40,960 --> 01:08:46,200
然后我们只是根据文本的宽度对它们进行分块

1232
01:08:46,200 --> 01:08:48,100
盒子是 它的尺寸 

1233
01:08:50,710 --> 01:08:53,040
然后让我们来看看这个精选 

1234
01:08:53,040 --> 01:09:01,240
因此 选择基本上就是带有光标的文本项列表 对吗？

1235
01:09:01,240 --> 01:09:04,540
就像我之前说的 当我们看着那边的屏幕时 

1236
01:09:04,540 --> 01:09:08,890
每个文本项都有一个文本值和一个回调函数 

1237
01:09:08,890 --> 01:09:10,840
回调函数使我们能够

1238
01:09:10,840 --> 01:09:16,130
要将行为分配给该选择对象 而不仅仅是显示内容 

1239
01:09:16,130 --> 01:09:16,630
对吗？

1240
01:09:16,630 --> 01:09:18,921
因为当你有一个菜单 当你有一个选择

1241
01:09:18,921 --> 01:09:22,479
你选择了一些东西 你希望行为发生 对吗？

1242
01:09:22,479 --> 01:09:26,439
因此 这些条目中的每一个inde.Items都会有一个回调函数 

1243
01:09:29,939 --> 01:09:32,649
然后在这里 当我们更新选择时 我们正在做的是

1244
01:09:32,649 --> 01:09:35,398
我们正在更新我们当前选择的内容 这就是

1245
01:09:35,398 --> 01:09:38,740
介于1和该选择中的项目数之间的数字 以确保

1246
01:09:38,740 --> 01:09:42,590
如果我们在一 我们去负一 我们回到底部 

1247
01:09:42,590 --> 01:09:45,310
如果我们按下时处于底部 而我们向上 

1248
01:09:45,310 --> 01:09:47,240
我们回到顶端 

1249
01:09:47,240 --> 01:09:51,880
我们演奏声音 可爱 诸如此类的东西 

1250
01:09:51,880 --> 01:09:52,979
然后对于每一个--

1251
01:09:52,979 --> 01:09:56,440
对于我们在这里的选择 从一项到多项 

1252
01:09:56,440 --> 01:09:58,720
我们计算我们需要多少填充物 

1253
01:09:58,720 --> 01:10:01,480
然后我们将光标画在我们当前的选择上 

1254
01:10:01,480 --> 01:10:06,700
然后我们根据i绘制每个项目 不管我们的间隙宽度是多少

1255
01:10:06,700 --> 01:10:08,680
我们的小组 我们将其分配给小组 

1256
01:10:08,680 --> 01:10:11,920
所以我们把小组分成几部分 然后基本上

1257
01:10:11,920 --> 01:10:14,650
跟踪当前y的位置并绘制

1258
01:10:14,650 --> 01:10:17,620
实际选定内容和光标(如果是

1259
01:10:17,620 --> 01:10:19,300
将当前选定内容添加到屏幕上 

1260
01:10:21,820 --> 01:10:25,060
关于精选的工作原理有什么问题吗？

1261
01:10:29,740 --> 01:10:35,260
请注意 如果我们按下Return 如果我们的选择正在更新 

1262
01:10:35,260 --> 01:10:40,450
Self.Items at self.CurrentSelection.onSelect 

1263
01:10:40,450 --> 01:10:44,680
因此 预计该项将具有onSelect函数 该函数

1264
01:10:44,680 --> 01:10:47,560
是回调函数 

1265
01:10:47,560 --> 01:10:50,259
好的 最后 我们来看一下菜单 

1266
01:10:50,259 --> 01:10:52,300
然后我们最后来看看这场战斗 

1267
01:10:52,300 --> 01:10:55,420
这就是所有的一切都与这一切联系在一起的地方 

1268
01:10:55,420 --> 01:10:56,810
就这么定了 

1269
01:10:56,810 --> 01:10:59,600
然后我们再讨论作业 

1270
01:10:59,600 --> 01:11:01,660
因此 菜单是一个面板和一个选项 

1271
01:11:01,660 --> 01:11:05,770
这就是这款游戏中菜单背后的主旨 

1272
01:11:05,770 --> 01:11:07,930
你可以把菜单定义为有很多东西 

1273
01:11:07,930 --> 01:11:11,620
菜单可能会变得更复杂 但在本例中 

1274
01:11:11,620 --> 01:11:15,190
在这个实现中 我们只是说菜单是一种选择

1275
01:11:15,190 --> 01:11:17,950
以及一块拼装成一件物品的面板 

1276
01:11:17,950 --> 01:11:24,810
我们在比赛中看到了这一点 如果我们是？]我要运行它 

1277
01:11:24,810 --> 01:11:26,910
这只是一个文本框 

1278
01:11:26,910 --> 01:11:28,557
去寻找一场战斗 

1279
01:11:32,050 --> 01:11:33,077
好了 这是一场战斗 

1280
01:11:33,077 --> 01:11:35,410
这只是底部的一个空面板 普通的面板 

1281
01:11:35,410 --> 01:11:36,410
但现在它是一个文本框 

1282
01:11:36,410 --> 01:11:38,710
我们将文本框压入堆栈 

1283
01:11:38,710 --> 01:11:40,840
将另一个文本框推入堆栈 

1284
01:11:40,840 --> 01:11:42,710
这是一份菜单 

1285
01:11:42,710 --> 01:11:45,910
请注意 其中有一个光标 还有

1286
01:11:45,910 --> 01:11:47,890
嵌入到面板中的选定内容 

1287
01:11:47,890 --> 01:11:50,380
其中的每一项 打斗和逃跑 

1288
01:11:50,380 --> 01:11:54,440
它们有一个与之关联的回调 

1289
01:11:54,440 --> 01:11:56,950
战斗回调的目的是触发一个新状态

1290
01:11:56,950 --> 01:12:02,830
其中两个精灵宝可梦在连锁行为中相互异步攻击

1291
01:12:02,830 --> 01:12:03,760
一个接一个 

1292
01:12:03,760 --> 01:12:07,720
然后Run推动对话 然后推动淡入淡出状态 

1293
01:12:07,720 --> 01:12:11,650
然后弹出这两个按钮 然后按下淡出状态

1294
01:12:11,650 --> 01:12:13,330
并将我们带回游戏状态 

1295
01:12:13,330 --> 01:12:15,330
所以这实际上就是正在发生的事情 那就是

1296
01:12:15,330 --> 01:12:18,130
菜单是什么样子的一个例子 

1297
01:12:18,130 --> 01:12:21,970
这样就有了一个菜单 只是一个选项和一个面板放在一起 

1298
01:12:21,970 --> 01:12:26,650
当我们绘制菜单时 先绘制面板 然后绘制所选内容 

1299
01:12:26,650 --> 01:12:29,860
然后当我们更新菜单时 我们只更新选项 

1300
01:12:29,860 --> 01:12:32,305
因为那才是我们所关心的 

1301
01:12:32,305 --> 01:12:34,060
基本上就是这样 

1302
01:12:34,060 --> 01:12:37,810
所以菜单本身会有一个定义 这个定义

1303
01:12:37,810 --> 01:12:41,362
应该有项目 该项目将被传递到选择 

1304
01:12:44,140 --> 01:12:46,105
差不多就是这样 就是这样--

1305
01:12:46,105 --> 01:12:47,580
哦 还有进度条 

1306
01:12:47,580 --> 01:12:51,440
当我们到达实际战斗状态时 我们将查看进度条 

1307
01:12:51,440 --> 01:12:55,390
现在 让我们来看看几个类和数据结构

1308
01:12:55,390 --> 01:12:57,800
这与精灵宝可梦本身有关 

1309
01:12:57,800 --> 01:13:00,670
所以如果你把派对看成是头等舱的话 非常

1310
01:13:00,670 --> 01:13:03,250
简单的类 字面意思就是这个--

1311
01:13:03,250 --> 01:13:07,060
在这一点上 self.pokemon是定义的 pokemon只是一个容器 

1312
01:13:07,060 --> 01:13:09,970
你可以拿着这个

1313
01:13:09,970 --> 01:13:12,640
我的意思是 即使在我认为是一场完整的比赛中 

1314
01:13:12,640 --> 01:13:15,850
你真的不需要比这更多的东西了 

1315
01:13:15,850 --> 01:13:18,230
但是 如果您需要对这个想法进行进一步的扩展

1316
01:13:18,230 --> 01:13:21,700
你知道 保留为派对而存在的元数据 

1317
01:13:21,700 --> 01:13:24,340
这将是一种完美的方式 

1318
01:13:24,340 --> 01:13:31,390
实际的口袋妖怪类本身并不比有效的多很多

1319
01:13:31,390 --> 01:13:33,400
一堆统计数据 

1320
01:13:33,400 --> 01:13:36,240
这就是RPG的很多特点 

1321
01:13:36,240 --> 01:13:38,876
这种类型--它主要是数字 

1322
01:13:38,876 --> 01:13:40,750
你只是在把数字和数字进行比较

1323
01:13:40,750 --> 01:13:42,640
然后加入一卷骰子 

1324
01:13:42,640 --> 01:13:46,690
实际上 这就是《地下城与龙》的大部分内容 

1325
01:13:46,690 --> 01:13:47,696
那就是--是吗？

1326
01:13:47,696 --> 01:13:49,630
观众：储存是不是更有意义？

1327
01:13:49,630 --> 01:13:57,100
只需每个级别和初始级别的增量 这样您就可以有更少的变量？

1328
01:13:57,100 --> 01:13:58,460
演讲者1：再说一遍 

1329
01:13:58,460 --> 01:14:00,376
观众：这不是更有意义吗？

1330
01:14:00,376 --> 01:14:03,150
存储您的HP和每个级别的所有内容

1331
01:14:03,150 --> 01:14:06,490
要存储每个区域的初始统计数据 

1332
01:14:06,490 --> 01:14:09,990
以及每一关你会涨多少钱 

1333
01:14:09,990 --> 01:14:14,080
演讲者1：把你增加的钱存起来会更有意义吗？

1334
01:14:14,080 --> 01:14:16,450
为你的精灵宝可梦每一级？

1335
01:14:16,450 --> 01:14:19,070
是的 这就是我们正在做的 

1336
01:14:19,070 --> 01:14:20,800
所以我们有一个基地--

1337
01:14:20,800 --> 01:14:24,910
在这种情况下 统计数据的拆分是这样的 对吗？

1338
01:14:24,910 --> 01:14:28,860
我们有基础HP、基础攻击、基础防御和基础速度 

1339
01:14:28,860 --> 01:14:31,600
1级精灵有--0级精灵

1340
01:14:31,600 --> 01:14:35,800
有这个物种的这些统计数据 对吗？

1341
01:14:35,800 --> 01:14:39,430
每一个竹子或我们选择的任何精灵宝可梦

1342
01:14:39,430 --> 01:14:42,820
会有我们分配给它的任何东西作为它的基础HP 

1343
01:14:42,820 --> 01:14:45,280
基地 进攻 基地防御 基地速度 

1344
01:14:45,280 --> 01:14:50,500
然后关于精灵宝可梦和我的意思是 很多RPG

1345
01:14:50,500 --> 01:14:52,660
会做这件事 但我们需要一些方法

1346
01:14:52,660 --> 01:14:58,420
以一种必然不确定的方式升级精灵宝可梦 

1347
01:14:58,420 --> 01:15:02,782
就像两只升级的小猪可能有不同的统计数据 对吗？

1348
01:15:02,782 --> 01:15:04,990
其中一个的攻击率可能比另一个略高 

1349
01:15:04,990 --> 01:15:07,240
其中一个人的防御能力可能略高于另一个人 

1350
01:15:07,240 --> 01:15:11,020
我们使用所谓的静脉注射来完成这项工作 这就是精灵宝可梦本身所做的事情 

1351
01:15:11,020 --> 01:15:13,450
它是个人价值的缩写 这是一种

1352
01:15:13,450 --> 01:15:16,810
就像你的精灵宝可梦的DNA一样 对吧？

1353
01:15:16,810 --> 01:15:23,420
所以这个HP IV与你的基础攻击、基础速度、基础等等是分开的 

1354
01:15:23,420 --> 01:15:26,890
基本上 每次都会将其与掷骰子进行比较

1355
01:15:26,890 --> 01:15:28,480
你升级了三次 

1356
01:15:31,610 --> 01:15:34,330
这就是我对它进行编程的方式 不一定

1357
01:15:34,330 --> 01:15:38,890
精灵宝可梦本身是如何做到这一点的 但你要掷骰子六次 

1358
01:15:38,890 --> 01:15:42,760
或者三次 一到六次 就像正常的死亡一样 

1359
01:15:42,760 --> 01:15:49,630
然后你会看看这个卷曲是否比你的静脉注射更大 对吗？

1360
01:15:49,630 --> 01:15:55,990
或者它会检查你的静脉输液是否小于或等于掷骰子 

1361
01:15:55,990 --> 01:15:57,560
如果是的话 

1362
01:15:57,560 --> 01:16:00,640
或者抱歉 如果它大于或等于掷骰子 

1363
01:16:00,640 --> 01:16:06,580
如果是 它将为这三个掷骰子将该统计信息加1 

1364
01:16:06,580 --> 01:16:11,500
因此 您最多可以再获得三个 或者您可以增加状态

1365
01:16:11,500 --> 01:16:14,200
每级最多三次 

1366
01:16:14,200 --> 01:16:16,990
但你最多只能打五针 

1367
01:16:16,990 --> 01:16:23,056
所以你是在6的情况下滚动 而你偶尔不会滚动6 

1368
01:16:23,056 --> 01:16:27,970
它会检查静脉输液是否

1369
01:16:27,970 --> 01:16:29,800
大于或等于掷骰子 

1370
01:16:29,800 --> 01:16:32,650
如果它不大于或等于事件中的掷骰子

1371
01:16:32,650 --> 01:16:36,430
如果是六分 或者静脉注射到四分

1372
01:16:36,430 --> 01:16:39,700
例如 这意味着五分或六分会反对它 

1373
01:16:39,700 --> 01:16:41,770
那么它就不会得到统计数据的增长 

1374
01:16:41,770 --> 01:16:44,920
这是实现这个基于DNA的系统的一种简单方式 

1375
01:16:44,920 --> 01:16:47,320
它是随机的 但它是加权的 对吗？

1376
01:16:47,320 --> 01:16:50,050
如果你有更高的静脉输液 你有更高的可能性

1377
01:16:50,050 --> 01:16:53,350
大于或等于掷骰子的 

1378
01:16:53,350 --> 01:16:55,960
这就是我们如何实现统计增加 

1379
01:16:55,960 --> 01:17:03,130
然后我们需要一种方法来跟踪我们的统计数据 

1380
01:17:03,130 --> 01:17:04,660
比如我们的实际数据

1381
01:17:04,660 --> 01:17:07,330
所以我们的实际HP 我们的实际攻击 我们的实际防御 

1382
01:17:07,330 --> 01:17:10,165
和一层一层计算出来的实际速度

1383
01:17:10,165 --> 01:17:11,665
我们需要一种方法来跟踪它 

1384
01:17:11,665 --> 01:17:14,190
我们需要等级 我们需要当前的XP 然后

1385
01:17:14,190 --> 01:17:15,940
我们需要我们的经验值

1386
01:17:15,940 --> 01:17:19,270
一级一级地越升越高 就像你在这里看到的 

1387
01:17:19,270 --> 01:17:24,520
因为它吸收了自我 水平乘以自我 水平 

1388
01:17:24,520 --> 01:17:28,150
然后乘以5乘以0.75 

1389
01:17:28,150 --> 01:17:29,470
现在的HP 

1390
01:17:32,340 --> 01:17:38,230
所以我们并不是一层一层地存储我们的价值 

1391
01:17:38,230 --> 01:17:42,220
我们需要基地 因为我们需要知道我们的基地是什么 

1392
01:17:42,220 --> 01:17:46,910
我的意思是 我们可以有效地全局引用这些变量 

1393
01:17:46,910 --> 01:17:49,810
但在这一点上 效率提升很小 

1394
01:17:49,810 --> 01:17:52,300
但我们需要静脉注射我们需要...

1395
01:17:52,300 --> 01:17:56,050
我是说 我们需要静脉注射的参考资料 我们需要基础HP的参考资料 

1396
01:17:56,050 --> 01:18:01,750
我们需要跟踪我们的实际数据 

1397
01:18:01,750 --> 01:18:04,210
然后我们现在的HP总是 因为我们现在的HP

1398
01:18:04,210 --> 01:18:07,010
可能与我们的实际HP不同 

1399
01:18:07,010 --> 01:18:10,690
在实际的游戏中 你可以有你的进攻 防守 

1400
01:18:10,690 --> 01:18:13,960
和速度也会随着比赛而变化 因为你

1401
01:18:13,960 --> 01:18:17,770
降低你的速度 降低你的攻击 

1402
01:18:17,770 --> 01:18:19,450
降低你的防御等等

1403
01:18:19,450 --> 01:18:21,200
在这种情况下 我们还没有实现这一点 

1404
01:18:21,200 --> 01:18:23,459
所以我们没有当前的攻击和防御

1405
01:18:23,459 --> 01:18:26,500
但是在一个更完整的实现中 你会有这样的事情 

1406
01:18:26,500 --> 01:18:28,125
这算是回答了你的问题吗

1407
01:18:28,125 --> 01:18:29,290
这是徒劳的吗？

1408
01:18:29,290 --> 01:18:29,790
好的.

1409
01:18:32,390 --> 01:18:35,020
这是升级代码 

1410
01:18:35,020 --> 01:18:38,200
就像我说的 掷三次骰子 一比三 

1411
01:18:38,200 --> 01:18:43,450
如果6小于或等于IV 那么它可能是6 在这种情况下 

1412
01:18:43,450 --> 01:18:47,160
它将大于最大IV可能的值 

1413
01:18:47,160 --> 01:18:52,150
静脉注射的范围从1到5 但如果它小于或等于静脉注射 

1414
01:18:52,150 --> 01:18:54,250
那我们就认为这是统计学上的增长

1415
01:18:54,250 --> 01:19:03,490
这是一个加权的奇数 用来确定我们是否得到统计数据的提升 

1416
01:19:03,490 --> 01:19:07,340
它对每个统计数据都这样做 然后返回所有增加的数据 

1417
01:19:07,340 --> 01:19:11,590
这是相关的 这一行95表示惠普的收益增加 

1418
01:19:11,590 --> 01:19:13,540
回击增加进攻 增加防守 

1419
01:19:13,540 --> 01:19:16,690
这将与作业7相关 因为您的目标是

1420
01:19:16,690 --> 01:19:20,650
在战斗中将这些增加并实际显示给这个用户

1421
01:19:20,650 --> 01:19:23,560
说明他或她什么时候取得胜利

1422
01:19:23,560 --> 01:19:25,310
并且已经达到了一个级别 

1423
01:19:25,310 --> 01:19:29,740
您将显示一个菜单 其中的选项包含所有这些内容 

1424
01:19:29,740 --> 01:19:30,970
你需要这个值 

1425
01:19:30,970 --> 01:19:36,550
所以它在这里返回这些值 您将以任何方式调用此函数

1426
01:19:36,550 --> 01:19:39,390
从你的战斗状态统计数据升级 

1427
01:19:39,390 --> 01:19:45,310
或者我们将调用Level Up 它返回self stats Level Up 

1428
01:19:45,310 --> 01:19:47,630
这就是精灵宝可梦的全部 

1429
01:19:47,630 --> 01:19:50,700
它实际上主要是一种数据结构 

1430
01:19:50,700 --> 01:19:57,640
我们在战斗中用它来有效地来回掷骰子 

1431
01:19:57,640 --> 01:20:05,650
有胜利者和失败者 然后通过这种方式获得经验值和增益等级 

1432
01:20:05,650 --> 01:20:09,490
那么 关于Pokemon对象类是如何工作的 有什么问题吗？

1433
01:20:12,370 --> 01:20:13,962
凉爽的 

1434
01:20:13,962 --> 01:20:16,670
我们将快速了解一下实际定义是什么样子 

1435
01:20:16,670 --> 01:20:18,240
你大概可以猜到 

1436
01:20:18,240 --> 01:20:20,870
这很简单 只是关键的名字 

1437
01:20:20,870 --> 01:20:24,300
然后我们有真正的名字 我们有精灵的名字 

1438
01:20:24,300 --> 01:20:26,810
我们有HP 攻击 防御--

1439
01:20:26,810 --> 01:20:29,390
所有被放入实际物体中的东西 

1440
01:20:29,390 --> 01:20:31,700
它们需要在定义中被引用 

1441
01:20:31,700 --> 01:20:34,101
所以精灵宝可梦最终只是这样 他们

1442
01:20:34,101 --> 01:20:37,100
就是数据 对 这就是我们在上一节课中谈到的 数据

1443
01:20:37,100 --> 01:20:38,210
驱动设计 

1444
01:20:38,210 --> 01:20:40,220
你能拿到的口袋妖怪就越多

1445
01:20:40,220 --> 01:20:44,210
把它们做成精灵宝可梦或任何东西 

1446
01:20:44,210 --> 01:20:47,270
并将其转换为易于编写的数据结构 

1447
01:20:47,270 --> 01:20:49,040
您就越容易添加更多内容 

1448
01:20:49,040 --> 01:20:53,304
我们可以很容易地补充说 创建150个这样的设备不会花太长时间 

1449
01:20:53,304 --> 01:20:55,220
我是说 他们不会那么有趣的 

1450
01:20:55,220 --> 01:20:58,200
因为我们还没有实施行动 

1451
01:20:58,200 --> 01:21:03,800
但在一个理想的世界里 我们会找到一种方法来将移动也建模为数据 

1452
01:21:03,800 --> 01:21:07,610
因此 您可以将移动链接到您的数据结构 

1453
01:21:07,610 --> 01:21:09,410
像这样给你的精灵宝可梦对象 

1454
01:21:09,410 --> 01:21:10,936
是的 托尼 你有问题吗？

1455
01:21:10,936 --> 01:21:13,310
听众：嗯 我只是想提一下这个悖论

1456
01:21:13,310 --> 01:21:15,150
关于这一点 游戏是非常好的 

1457
01:21:15,150 --> 01:21:16,832
[听不见]

1458
01:21:16,832 --> 01:21:18,290
演讲者1：哦 就像十字军吗？

1459
01:21:18,290 --> 01:21:18,915
观众：是的 

1460
01:21:21,960 --> 01:21:25,590
演讲者1：评论是Paradox Games非常好的数据驱动设计 

1461
01:21:25,590 --> 01:21:28,417
我猜你已经查过他们的档案了吧？

1462
01:21:28,417 --> 01:21:30,250
观众：在某种程度上 这也只是

1463
01:21:30,250 --> 01:21:33,927
如果你玩他们的游戏一段时间 它无处不在 在一定程度上

1464
01:21:33,927 --> 01:21:36,260
有时他们会把源代码放在维基上 

1465
01:21:36,260 --> 01:21:37,880
演讲者1：哦 是的 

1466
01:21:37,880 --> 01:21:40,340
是的 不 这只是一个很好的游戏设计 

1467
01:21:40,340 --> 01:21:41,880
最终 如果你想--

1468
01:21:41,880 --> 01:21:44,660
而且他们的游戏很大 他们有很多内容 

1469
01:21:44,660 --> 01:21:46,901
如果你想在你的游戏中有很多内容 

1470
01:21:46,901 --> 01:21:49,400
你需要找到一种方法减轻程序员的负担

1471
01:21:49,400 --> 01:21:51,316
并把它放在设计师身上 或者至少让

1472
01:21:51,316 --> 01:21:53,650
这对程序员来说更容易 因为编写源代码

1473
01:21:53,650 --> 01:21:56,899
整天调试源代码 特别是对于非常复杂的事情

1474
01:21:56,899 --> 01:21:57,740
这不是一件容易的事 

1475
01:21:57,740 --> 01:22:01,100
而且这最终也不是我们想要做的事情 对吗？

1476
01:22:01,100 --> 01:22:04,610
对我来说 在10行代码中创建一个新生物要容易得多

1477
01:22:04,610 --> 01:22:10,700
在这里感觉很好 而不是硬编码很多这样的东西 

1478
01:22:10,700 --> 01:22:11,780
对吗？

1479
01:22:11,780 --> 01:22:17,000
因此 将尽可能多的数据转换为数据应该是您的最终目标 

1480
01:22:17,000 --> 01:22:19,670
所以这就是精灵宝可梦防御者的样子 

1481
01:22:19,670 --> 01:22:21,565
在我们进入实际战斗之前 我们想要

1482
01:22:21,565 --> 01:22:23,420
来看看什么是战斗精灵 

1483
01:22:23,420 --> 01:22:27,470
所以战斗精灵就是呈现在屏幕上的东西 对吗？

1484
01:22:27,470 --> 01:22:29,720
所以我们来看看这个 

1485
01:22:29,720 --> 01:22:33,920
那不是战斗精灵 而是几乎是战斗精灵 

1486
01:22:33,920 --> 01:22:35,900
那只是一种质感 

1487
01:22:35,900 --> 01:22:43,160
因此 如果我们陷入一场战斗 速度缓慢但却是肯定的 

1488
01:22:43,160 --> 01:22:46,850
好了 这些是战斗精灵 它们看起来没什么不同

1489
01:22:46,850 --> 01:22:48,980
比普通的雪碧还多 而且它们也没有那么多

1490
01:22:48,980 --> 01:22:50,630
不同于普通的雪碧 

1491
01:22:50,630 --> 01:22:55,940
但它们有一些重要的功能 主要是那些功能

1492
01:22:55,940 --> 01:23:01,760
其中一个是闪烁的 然后是不透明的 对吗？

1493
01:23:01,760 --> 01:23:07,730
因此 为了做到这两点 我们需要存储某种类型的数据

1494
01:23:07,730 --> 01:23:09,850
在我们的精灵里 对吗？

1495
01:23:09,850 --> 01:23:10,964
是?

1496
01:23:10,964 --> 01:23:14,470
观众：塞尔达的无敌闪光灯 

1497
01:23:14,470 --> 01:23:15,470
演讲者1：是的 完全正确 

1498
01:23:15,470 --> 01:23:18,050
我们在塞尔达使用的无懈可击的闪光 

1499
01:23:18,050 --> 01:23:24,560
对敌人来说 或者我应该说 对被攻击的人来说 是的 

1500
01:23:24,560 --> 01:23:28,080
他们正在存储一面不透明的旗帜 

1501
01:23:28,080 --> 01:23:32,730
他们的对象中存储了一个不透明标志 我们可以对其进行补间 

1502
01:23:32,730 --> 01:23:34,730
我们可以随着时间的推移分分合合 

1503
01:23:34,730 --> 01:23:38,074
当塞尔达的实体受到伤害时 我们就是这么做的 

1504
01:23:38,074 --> 01:23:40,615
我们把它设置为无懈可击 虽然它是无懈可击的 

1505
01:23:40,615 --> 01:23:42,320
它在断断续续地闪烁 

1506
01:23:42,320 --> 01:23:47,930
但我们不能用闪烁着白色的精灵做到这一点 

1507
01:23:47,930 --> 01:23:52,970
因为这不是真正的白旗 对吧？

1508
01:23:52,970 --> 01:23:55,760
我们不能只用一面旗帜就把东西变成全白的 

1509
01:23:55,760 --> 01:23:59,060
这是我们实际上需要使用着色器的东西 

1510
01:23:59,060 --> 01:24:03,200
这是一个着色器 我们不会深入到这方面的太多细节 

1511
01:24:03,200 --> 01:24:07,520
着色器相当复杂 一开始有点神秘 

1512
01:24:07,520 --> 01:24:10,340
但它们实际上是一个小程序 

1513
01:24:10,340 --> 01:24:13,520
在你的显卡上运行 当你在画东西的时候 它会看起来

1514
01:24:13,520 --> 01:24:16,400
它会查看每个像素 具体取决于您使用的着色器类型 

1515
01:24:16,400 --> 01:24:19,130
但为了演示 我们将查看每个像素

1516
01:24:19,130 --> 01:24:23,510
你正在绘制到屏幕上 并执行某种功能

1517
01:24:23,510 --> 01:24:27,890
并产生一个新的值 对吗？

1518
01:24:27,890 --> 01:24:31,610
这就是你如何让很多疯狂的可怕的事情发生 

1519
01:24:31,610 --> 01:24:34,350
但这可能是相当疯狂的 

1520
01:24:34,350 --> 01:24:39,482
Shader Toy 我认为是一个拥有大量非常酷的--

1521
01:24:39,482 --> 01:24:42,440
我不会因为我不记得名字就把它拔出来 

1522
01:24:42,440 --> 01:24:44,000
我相信这是着色器玩具 

1523
01:24:44,000 --> 01:24:47,041
有一个网站 人们在那里发布他们编写的所有着色器 

1524
01:24:47,041 --> 01:24:49,460
你可以看到很多非常疯狂的东西 

1525
01:24:49,460 --> 01:24:53,720
这是您无法想象的 仅用这样的代码就可以

1526
01:24:53,720 --> 01:24:56,150
有效地 查看像素的位置

1527
01:24:56,150 --> 01:24:58,670
和[？图片？]在屏幕上什么的 

1528
01:24:58,670 --> 01:25:05,450
但这实际上是一个白色着色器 这个着色器的目标是

1529
01:25:05,450 --> 01:25:07,490
就是把一个精灵完全变白 

1530
01:25:07,490 --> 01:25:10,610
这就是该着色器的所有目标 

1531
01:25:10,610 --> 01:25:14,390
所以它得到了一个叫做白色因子的浮点 哪个[？你会吗？]就这么说吧 

1532
01:25:14,390 --> 01:25:17,240
那么白人因素实际上就是

1533
01:25:17,240 --> 01:25:20,810
会被归结为RGB是什么

1534
01:25:20,810 --> 01:25:25,350
当着色器处于活动状态时 我们绘制的任何像素 

1535
01:25:25,350 --> 01:25:29,990
这样做的效果是 如果它等于1 那么就是白色因子 

1536
01:25:29,990 --> 01:25:32,720
这是关于着色器和许多这类东西的事情 

1537
01:25:32,720 --> 01:25:35,240
着色器中的许多数据结构

1538
01:25:35,240 --> 01:25:37,890
基于从0到1的浮点数 

1539
01:25:37,890 --> 01:25:43,790
因此 如果我们将某物的RGB赋给vec 3 即1 即111 

1540
01:25:43,790 --> 01:25:46,520
那将是255,255,255 

1541
01:25:46,520 --> 01:25:50,660
所以 那个像素RGB是白色的 纯白的 对吧？

1542
01:25:50,660 --> 01:25:58,460
所以我们在这里做的是在我们的战斗精灵上 自己眨眼

1543
01:25:58,460 --> 01:26:01,775
1或0 记住 这是Lua[？Turnerri？]行动 

1544
01:26:01,775 --> 01:26:07,070
所以我们说 如果自我眨眼是真的 那么另一个是零 

1545
01:26:07,070 --> 01:26:15,860
因此 发送我们的着色器基于任何值本身的白色因素 闪烁 

1546
01:26:15,860 --> 01:26:19,700
这将产生着色器获得1或0的效果 

1547
01:26:19,700 --> 01:26:22,400
并将1或0加到那个精灵的RGB上 

1548
01:26:22,400 --> 01:26:25,670
如果闪烁设置为真 则精灵的

1549
01:26:25,670 --> 01:26:29,270
基本上是在255,255,255的每个像素上绘制 

1550
01:26:29,270 --> 01:26:33,500
否则 它将使用该图像的像素值绘制

1551
01:26:33,500 --> 01:26:35,085
在那个位置 

1552
01:26:35,085 --> 01:26:37,220
这说得通吗？

1553
01:26:37,220 --> 01:26:37,907
好的 

1554
01:26:37,907 --> 01:26:39,740
语法有点奇怪 但那是

1555
01:26:39,740 --> 01:26:42,020
在此着色器中发生的情况 

1556
01:26:42,020 --> 01:26:44,540
这里有一个我找到着色器的链接 

1557
01:26:44,540 --> 01:26:47,960
但这是一个非常简单的着色器 

1558
01:26:47,960 --> 01:26:50,840
可能是您可以编写的最简单的着色器之一 

1559
01:26:50,840 --> 01:26:55,460
但这是一个很好的例子 说明了您可以使用着色器做什么 而且非常简单 

1560
01:26:55,460 --> 01:26:59,210
这很好 因为你可以用纹理坐标做数学运算

1561
01:26:59,210 --> 01:27:02,060
以此为基础 或者像素坐标 并在此基础上进行数学运算 

1562
01:27:02,060 --> 01:27:04,910
例如 在您的文件中 您可以像正弦函数一样传入

1563
01:27:04,910 --> 01:27:09,379
并使正弦函数对子画面RG或B值执行运算

1564
01:27:09,379 --> 01:27:10,670
做各种很酷的事情 

1565
01:27:10,670 --> 01:27:14,154
它真的很整洁 就像着色器的可能性是无限的 

1566
01:27:14,154 --> 01:27:16,070
但这就是我们让它眨眼的方式 因为你

1567
01:27:16,070 --> 01:27:18,410
除了这个 我不能这么做--

1568
01:27:18,410 --> 01:27:21,830
我是说 可能有一些奇怪的方法也能让它起作用 

1569
01:27:21,830 --> 01:27:28,820
但这可能是让我们的精灵闪烁白色的最简单的方法 

1570
01:27:28,820 --> 01:27:36,890
所以自我 眨眼只会得到一个计时器 每0.1个或其他什么 

1571
01:27:36,890 --> 01:27:41,010
我们将在攻击状态下看到这一点 

1572
01:27:41,010 --> 01:27:45,350
但那会闪到自己 在真与假之间眨眼 

1573
01:27:45,350 --> 01:27:49,150
它会一次又一次地否定自己 

1574
01:27:49,150 --> 01:27:51,590
好了 这就是战斗精灵 

1575
01:27:51,590 --> 01:27:56,180
最后我们要看的是另一个非常简单的类 对手 

1576
01:27:56,180 --> 01:27:59,370
所有的对手就是它有一个政党 仅此而已 

1577
01:27:59,370 --> 01:28:01,370
但在一场全面的比赛中 你的对手

1578
01:28:01,370 --> 01:28:03,680
可能会有一个像训练师一样的精灵 

1579
01:28:03,680 --> 01:28:06,185
一条信息 它说 就像一个完整的派对

1580
01:28:06,185 --> 01:28:08,810
精灵宝可梦 当你打败它时 它会给你带来黄金价值 

1581
01:28:08,810 --> 01:28:09,643
各种各样的事情 

1582
01:28:09,643 --> 01:28:12,020
但它在这里只是作为一个简单的说明 

1583
01:28:12,020 --> 01:28:12,520
嗯?

1584
01:28:12,520 --> 01:28:14,925
观众：[听不见]用一种方法来应对失败

1585
01:28:14,925 --> 01:28:17,540
如果你想让它崩溃的话

1586
01:28:17,540 --> 01:28:19,266
房间或类似的东西 

1587
01:28:19,266 --> 01:28:21,260
这将是你可以做的另一件事 

1588
01:28:21,260 --> 01:28:22,260
演讲者1：哦 一种方法？

1589
01:28:22,260 --> 01:28:26,780
是的 我们可以把一种方法和一种叫做失败的对手联系起来 

1590
01:28:26,780 --> 01:28:29,959
或者什么都不会做武断的事情 把房间弄塌 

1591
01:28:29,959 --> 01:28:30,500
或者是其他原因 

1592
01:28:30,500 --> 01:28:31,910
是的 绝对的 

1593
01:28:31,910 --> 01:28:34,250
或者甚至推动一个新的状态 就像传送

1594
01:28:34,250 --> 01:28:36,299
世界地图上的一个新位置 

1595
01:28:36,299 --> 01:28:38,090
也许我们就像淘汰了精英四人组

1596
01:28:38,090 --> 01:28:42,590
想要传送到喜欢的结束字幕 确切地说 

1597
01:28:42,590 --> 01:28:45,150
无限的可能性 

1598
01:28:45,150 --> 01:28:48,860
那么让我们继续下去看看吧 我们还有20分钟的时间

1599
01:28:48,860 --> 01:28:49,390
或者说离开了 

1600
01:28:49,390 --> 01:28:51,764
我们来看看战斗状态 因为这场战斗

1601
01:28:51,764 --> 01:28:56,930
州和他们所处的州可能是更复杂的一面

1602
01:28:56,930 --> 01:28:59,340
这是如何运作的 

1603
01:28:59,340 --> 01:29:03,282
所以在战斗状态下 我们有一个玩家 我们有一个底部面板 底部面板

1604
01:29:03,282 --> 01:29:05,240
因为当我们仅仅为了这一部分而启动州时 

1605
01:29:05,240 --> 01:29:08,720
但除此之外 我们总是把事情往上推 

1606
01:29:08,720 --> 01:29:14,200
不管我们是否已经开始战斗 因为当我们逐渐淡出时--

1607
01:29:14,200 --> 01:29:16,700
抱歉 是的 

1608
01:29:16,700 --> 01:29:28,710
因为当我们初始化这个状态时 我们还会将淡出状态添加到它上面 

1609
01:29:28,710 --> 01:29:32,930
但我们不想触发精灵宝可梦的滑行

1610
01:29:32,930 --> 01:29:35,360
从左到右 直到该状态被弹出 

1611
01:29:35,360 --> 01:29:38,600
因此 我们在这里有一个标志 它将在第一次更新时设置为真

1612
01:29:38,600 --> 01:29:39,500
迭代 

1613
01:29:39,500 --> 01:29:41,450
然后 当它设置为真时 我们将

1614
01:29:41,450 --> 01:29:44,180
实际上 在精灵宝可梦从左到右之间 

1615
01:29:44,180 --> 01:29:46,610
并启动所有其他类型的异步进程

1616
01:29:46,610 --> 01:29:50,250
在那之后存在的 

1617
01:29:50,250 --> 01:29:56,330
但让我们再来看看这场战斗 看看发生了什么 

1618
01:29:56,330 --> 01:29:58,940
所以我要一直走下去 直到我投入战斗 

1619
01:29:58,940 --> 01:29:59,910
好了 这是一场战斗 

1620
01:29:59,910 --> 01:30:05,200
所以请注意 淡入发生在--

1621
01:30:05,200 --> 01:30:08,160
当淡出开始时 滑行就会发生 对吧 

1622
01:30:08,160 --> 01:30:10,402
一旦褪色结束 我应该说 

1623
01:30:10,402 --> 01:30:12,360
我们会在屏幕上弹出一条信息 对吗？

1624
01:30:12,360 --> 01:30:14,550
它说出现了一个狂野的X 

1625
01:30:14,550 --> 01:30:16,040
对 那就是敌人的精灵宝可梦 

1626
01:30:16,040 --> 01:30:17,370
我们按了回车键 

1627
01:30:17,370 --> 01:30:19,140
把这个关小一点 

1628
01:30:19,140 --> 01:30:21,930
我们按回车键 然后弹出另一个--

1629
01:30:21,930 --> 01:30:24,600
将另一个状态推送到堆栈上 另一个战斗消息 

1630
01:30:24,600 --> 01:30:26,100
与对话状态非常相似 

1631
01:30:26,100 --> 01:30:30,030
说加油我们的精灵宝可梦 

1632
01:30:30,030 --> 01:30:34,080
然后我们把菜单推到屏幕上 对吗？

1633
01:30:34,080 --> 01:30:37,190
我们有一个菜单 上面写着 要么战斗 要么逃跑 可供选择 

1634
01:30:37,190 --> 01:30:39,230
这是一份菜单 里面有很多选择 

1635
01:30:39,230 --> 01:30:42,420
然后 现在 这是堆栈的顶部 对吗？

1636
01:30:42,420 --> 01:30:44,470
所以这是唯一得到输入的东西 

1637
01:30:44,470 --> 01:30:48,096
其他一切都在它下面渲染 但没有任何东西得到输入 

1638
01:30:48,096 --> 01:30:49,970
因此 我们可以选择要么战斗 要么逃跑 

1639
01:30:49,970 --> 01:30:51,170
比方说我们打架 

1640
01:30:51,170 --> 01:30:55,802
我们战斗 我们现在有了一个新的状态 我们处于攻击状态 

1641
01:30:55,802 --> 01:30:57,010
刚刚发生了几件事 

1642
01:30:57,010 --> 01:31:01,880
那么 一旦我们启动攻击状态 会发生什么？

1643
01:31:01,880 --> 01:31:02,380
嗯?

1644
01:31:02,380 --> 01:31:04,745
观众：你会看到一个文本框 上面写着 x攻击y 

1645
01:31:04,745 --> 01:31:06,870
演讲者1：是的 所以我们要做的第一件事

1646
01:31:06,870 --> 01:31:10,385
是一个文本框 上面写着 x攻击y 其中

1647
01:31:10,385 --> 01:31:12,510
要么是我们 要么是对手 因为这是

1648
01:31:12,510 --> 01:31:14,700
根据谁的速度更快 

1649
01:31:14,700 --> 01:31:16,612
接下来会发生什么呢？

1650
01:31:16,612 --> 01:31:17,950
观众：[听不见] 

1651
01:31:17,950 --> 01:31:19,140
演讲者1：是的 确实如此 

1652
01:31:19,140 --> 01:31:21,600
所以让我们现在就来看看它 告诉你

1653
01:31:21,600 --> 01:31:24,750
告诉我文本框一弹出到底会发生什么 

1654
01:31:27,750 --> 01:31:30,940
那么发生在那里的碎片是什么呢？

1655
01:31:30,940 --> 01:31:31,800
观众：闪电侠 

1656
01:31:31,800 --> 01:31:34,260
演讲者1：好的 袭击者闪烁白色 

1657
01:31:34,260 --> 01:31:36,220
对 这就是我们看到的着色器 

1658
01:31:36,220 --> 01:31:38,080
这是着色器闪烁和关闭 

1659
01:31:38,080 --> 01:31:41,970
有一些计时器显示 每隔0.1秒 闪烁或关闭 

1660
01:31:41,970 --> 01:31:43,610
然后会发生什么呢？

1661
01:31:43,610 --> 01:31:46,660
观众：那么伤害就已经造成了 [听不见]..

1662
01:31:46,660 --> 01:31:50,220
演讲者1：嗯 伤害已经造成了 是的 但是在视觉上发生了什么

1663
01:31:50,220 --> 01:31:53,669
当白色闪烁的时候？

1664
01:31:53,669 --> 01:31:54,960
观众：另一个在眨眼 

1665
01:31:54,960 --> 01:31:56,293
扬声器1：另一个在眨眼 

1666
01:31:56,293 --> 01:31:59,415
另一个是什么在眨眼？

1667
01:31:59,415 --> 01:32:00,390
观众：我不确定 

1668
01:32:00,390 --> 01:32:02,067
演讲者1：所以这是不透明的 对吗？

1669
01:32:02,067 --> 01:32:05,150
所以请记住 我们正在做的事情与刚才对白人所做的完全相同 

1670
01:32:05,150 --> 01:32:08,900
眨眼 但我们每0.1秒就调整一次

1671
01:32:08,900 --> 01:32:11,750
保卫精灵宝可梦的不透明 

1672
01:32:11,750 --> 01:32:13,677
然后我们就会受到损害 

1673
01:32:13,677 --> 01:32:15,260
那么当我们受到伤害时会发生什么呢？

1674
01:32:15,260 --> 01:32:17,520
观众：基本上是相反的 

1675
01:32:17,520 --> 01:32:20,510
演讲者1：嗯 当东西受到损坏时 什么会被激活？

1676
01:32:20,510 --> 01:32:22,880
我们已经制作了闪烁的动画 我们制作了不透明度的动画 

1677
01:32:22,880 --> 01:32:24,550
观众：[听不见] 

1678
01:32:24,550 --> 01:32:26,240
演讲者1：健康条下降了 对吧？

1679
01:32:26,240 --> 01:32:28,100
所以我们把几件事联系在一起 

1680
01:32:28,100 --> 01:32:32,760
我们在链接--首先 我们每0.1秒做一次 共六次 

1681
01:32:32,760 --> 01:32:34,430
闪烁白色 

1682
01:32:34,430 --> 01:32:37,982
然后眨眼另一件不透明的东西 对吗？

1683
01:32:37,982 --> 01:32:40,190
我们同时也在播放音效 

1684
01:32:40,190 --> 01:32:43,190
我们正在为攻击播放音效 为命中播放音效 

1685
01:32:43,190 --> 01:32:46,750
一旦完成 就在健康吧之间 对吧？

1686
01:32:46,750 --> 01:32:51,050
所以我们已经修改了防御精灵宝可梦的生命值 

1687
01:32:51,050 --> 01:32:54,856
然后在第一个过程之后发生什么 在那个过程完成之后 

1688
01:32:57,724 --> 01:32:59,640
观众：对另一边重复一遍？

1689
01:32:59,640 --> 01:33:04,410
演讲者1：完全正确 重复完全相同的事情 但在另一边 

1690
01:33:04,410 --> 01:33:06,530
但我们在这两者之间做了什么呢？

1691
01:33:06,530 --> 01:33:07,530
我们得做点什么 

1692
01:33:07,530 --> 01:33:08,730
观众：检查是否有人死亡 

1693
01:33:08,730 --> 01:33:10,646
演讲者1：准确地说 检查是否有人死亡 

1694
01:33:10,646 --> 01:33:12,840
如果有人死了--

1695
01:33:12,840 --> 01:33:14,890
假设我们死了 会发生什么？

1696
01:33:14,890 --> 01:33:16,710
观众：[听不见] 

1697
01:33:16,710 --> 01:33:19,140
演讲者1：嗯 我们是的 我们回到播放状态 

1698
01:33:19,140 --> 01:33:22,170
我们淡出到黑色 然后我们回到播放状态 

1699
01:33:22,170 --> 01:33:24,536
如果我们消灭敌人会发生什么？

1700
01:33:24,536 --> 01:33:25,894
观众：转到这个屏幕 

1701
01:33:25,894 --> 01:33:28,060
演讲者1：没错 这个屏幕上会发生什么？

1702
01:33:28,060 --> 01:33:29,750
那么 第一件发生的事情是什么？

1703
01:33:29,750 --> 01:33:32,387
那么 回想一下 精灵宝可梦死的时候发生了什么？

1704
01:33:32,387 --> 01:33:32,970
发生了什么？

1705
01:33:32,970 --> 01:33:34,678
观众：它从站台上掉了下来 

1706
01:33:34,678 --> 01:33:39,060
演讲者1：没错 所以这可能是他的y值的一个区间 

1707
01:33:39,060 --> 01:33:40,550
然后会发生什么呢？

1708
01:33:40,550 --> 01:33:42,270
观众：[听不见] 

1709
01:33:42,270 --> 01:33:46,120
演讲者1：没错 我们把一个战斗信息状态推到了屏幕上 

1710
01:33:46,120 --> 01:33:48,756
然后当我们按Enter键时会发生什么？

1711
01:33:48,756 --> 01:33:50,301
观众：[听不见] 

1712
01:33:50,301 --> 01:33:52,050
演讲者1：刚才发生了什么？

1713
01:33:52,050 --> 01:33:53,758
观众：[听不见]文本框上写着 

1714
01:33:53,758 --> 01:33:55,400
你得到了所有的经验点 

1715
01:33:55,400 --> 01:33:57,645
然后你的XP就会升级 

1716
01:33:57,645 --> 01:33:59,751
大概 它会检查你是否升级了 

1717
01:33:59,751 --> 01:34:00,750
演讲者1：是的 正确 

1718
01:34:00,750 --> 01:34:03,600
观众：[听不见]调高音量 

1719
01:34:03,600 --> 01:34:05,610
演讲者1：完全正确 所以当推动对话时

1720
01:34:05,610 --> 01:34:09,980
在屏幕上显示你获得了x个经验点 XP酒吧的青少年 

1721
01:34:09,980 --> 01:34:10,620
对吗？

1722
01:34:10,620 --> 01:34:15,740
我们已经达到了当前XP与下一级XP的比率 

1723
01:34:15,740 --> 01:34:19,780
我们以这种方式制作文本栏动画 或以这种方式制作进度条 

1724
01:34:19,780 --> 01:34:23,820
然后我们把州内的淡入淡出 对 变成白色 

1725
01:34:23,820 --> 01:34:27,360
然后我们必须把所有东西都从堆栈中取出 

1726
01:34:27,360 --> 01:34:32,417
然后将淡出状态推送到堆栈的顶部 

1727
01:34:32,417 --> 01:34:34,000
然后我们又回到了游戏状态 

1728
01:34:34,000 --> 01:34:41,610
但如果我们真的升级了 我们需要播放正确的音乐 播放正确的声音 

1729
01:34:41,610 --> 01:34:45,370
然后赋值的一部分实际上是 在那个确切的函数中 

1730
01:34:45,370 --> 01:34:48,432
你需要添加一些行为来做什么？

1731
01:34:48,432 --> 01:34:50,892
观众：[听不见]基本上是显示变化 

1732
01:34:50,892 --> 01:34:51,720
以及新的一个将会是什么 

1733
01:34:51,720 --> 01:34:53,886
演讲者1：是的 我们需要做些什么呢？

1734
01:34:53,886 --> 01:34:55,650
我们需要做什么才能做到这一点？

1735
01:34:55,650 --> 01:34:57,790
观众：[？解释 ？]它叫什么来着？

1736
01:34:57,790 --> 01:35:00,680
选择框 但基本没有选择部分 

1737
01:35:00,680 --> 01:35:03,900
演讲者1：是的 所以一旦我们采取了--一旦我们升级了

1738
01:35:03,900 --> 01:35:07,680
我们处于战斗状态的胜利状态 对吧 

1739
01:35:07,680 --> 01:35:13,560
我们需要推送一个新状态 一个新的菜单状态 

1740
01:35:13,560 --> 01:35:17,160
拥有所有这些统计数据以及它们增加的数量 

1741
01:35:17,160 --> 01:35:19,920
然后当我们按回车键时 大概我们

1742
01:35:19,920 --> 01:35:24,090
应该把它弹出来 然后把其他的都弹回播放状态 

1743
01:35:24,090 --> 01:35:26,310
然后像往常一样淡入 

1744
01:35:26,310 --> 01:35:29,310
简而言之 这就是战斗状态 

1745
01:35:29,310 --> 01:35:32,850
很多东西都在等待着彼此的输入和其他东西

1746
01:35:32,850 --> 01:35:33,660
就像那样 

1747
01:35:33,660 --> 01:35:37,985
但相当容易理解 只是因为它的许多内容非常简单

1748
01:35:37,985 --> 01:35:40,110
只是一遍又一遍地链接在一起的东西

1749
01:35:40,110 --> 01:35:42,480
再次产生这种有趣的行为 

1750
01:35:45,070 --> 01:35:47,320
所以我们这里有精灵 回想一下精灵是什么

1751
01:35:47,320 --> 01:35:49,380
我们需要对它们进行动画处理 

1752
01:35:49,380 --> 01:35:52,860
我们有健康条 也就是进度条 

1753
01:35:52,860 --> 01:35:55,890
就是两个长方形--

1754
01:35:55,890 --> 01:35:59,520
一条线 一条黑线 和一条填充在线下的填充 

1755
01:35:59,520 --> 01:36:06,000
这样我们就能知道少了多少 对吧？

1756
01:36:06,000 --> 01:36:08,290
我们得到了宽度、高度和颜色 

1757
01:36:08,290 --> 01:36:10,470
我们可以给进度条添加任何我们想要的颜色 

1758
01:36:10,470 --> 01:36:13,710
这就是我们如何区分健康吧和XP

1759
01:36:13,710 --> 01:36:14,370
酒吧 

1760
01:36:14,370 --> 01:36:17,619
我们只画一个红色和一个蓝色 然后把它们画在不同的地方 对吧 

1761
01:36:17,619 --> 01:36:20,220
但它们都是进步的标杆 

1762
01:36:20,220 --> 01:36:21,570
然后他们就会得到一个价值 

1763
01:36:21,570 --> 01:36:28,050
它们的值决定了矩形的大小

1764
01:36:28,050 --> 01:36:29,130
是按比例调整的 

1765
01:36:29,130 --> 01:36:33,390
最大值就是应该按顺序除以多少

1766
01:36:33,390 --> 01:36:36,420
以求出总宽度的比率--

1767
01:36:36,420 --> 01:36:38,640
一个总宽度的定标器 这将允许我们

1768
01:36:38,640 --> 01:36:41,580
以获得丢失的数量的感觉 

1769
01:36:43,875 --> 01:36:45,930
然后一个球员圈x 对手圈

1770
01:36:45,930 --> 01:36:51,180
X代表省略号 只是实际口袋妖怪的图形细节 

1771
01:36:51,180 --> 01:36:54,690
这样我们就可以得到他们的数据 这样我们就可以真正地掷骰子 或者不掷骰子

1772
01:36:54,690 --> 01:36:58,230
在这种情况下确实掷骰子 但这样我们就可以加或减

1773
01:36:58,230 --> 01:36:59,790
惠普以进攻和防守为基础 

1774
01:37:03,570 --> 01:37:06,030
这就是最新的情况 所以把扳机滑进去 

1775
01:37:06,030 --> 01:37:09,470
因此 触发滑动所做的是一秒钟的补间 

1776
01:37:09,470 --> 01:37:10,720
你说过的 对吧？

1777
01:37:10,720 --> 01:37:14,410
精灵宝可梦从左到右 或者从左到右 从右到左 

1778
01:37:14,410 --> 01:37:18,330
有x个值 只需一秒钟就可以补齐 

1779
01:37:18,330 --> 01:37:22,360
一旦完成 我们将触发开始对话 

1780
01:37:22,360 --> 01:37:26,760
因此 开始对话是将战斗消息状态推送到堆栈上 

1781
01:37:26,760 --> 01:37:30,500
战斗消息状态类似于对话状态 因为它获取一个字符串

1782
01:37:30,500 --> 01:37:33,300
在这里 一个狂野的东西出现了 

1783
01:37:33,300 --> 01:37:36,690
一旦我们按回车键 它就会得到一个回调函数 

1784
01:37:36,690 --> 01:37:41,520
回调函数本身就是战斗消息状态的又一次推送

1785
01:37:41,520 --> 01:37:43,900
上面写着 去吧 然后是我们的精灵宝可梦 

1786
01:37:43,900 --> 01:37:47,460
请注意 我们在这里引用的是self.opcient.party.pokemon 

1787
01:37:47,460 --> 01:37:52,560
在那里使用self.player.party.pokemon来获取实际名称 

1788
01:37:52,560 --> 01:37:59,790
然后一旦我们弹出 然后我们在这里按下战斗菜单状态 

1789
01:37:59,790 --> 01:38:00,660
对吗？

1790
01:38:00,660 --> 01:38:02,820
那么 让我们来看看战斗菜单状态 

1791
01:38:02,820 --> 01:38:06,660
这很有趣 因为这就是我们真正定义的

1792
01:38:06,660 --> 01:38:08,880
我们菜单的行为是有效的 对吗？

1793
01:38:08,880 --> 01:38:12,080
回想一下 我们需要一些东西来告诉我们当我们按下Fight时会发生什么 

1794
01:38:12,080 --> 01:38:13,950
以及当我们单击Run时会发生什么 

1795
01:38:13,950 --> 01:38:16,830
因此 当我们点击Fight时 请注意此处的项目 

1796
01:38:16,830 --> 01:38:20,810
对 self.warflemenu获得菜单 并且菜单需要项目 

1797
01:38:20,810 --> 01:38:30,180
这项关键字 这张桌子直接输入到选择中 对吗？

1798
01:38:30,180 --> 01:38:33,300
和选择 它希望记住 一篇文字 

1799
01:38:33,300 --> 01:38:36,179
因为它必须知道在该索引处呈现什么 

1800
01:38:36,179 --> 01:38:37,470
然后是ON SELECT功能 

1801
01:38:37,470 --> 01:38:39,261
而On SELECT函数是回调

1802
01:38:39,261 --> 01:38:42,990
当您在该特定位置按Enter键时执行的

1803
01:38:42,990 --> 01:38:43,960
在菜单上 

1804
01:38:43,960 --> 01:38:48,300
在这种情况下 战斗 它所做的是弹出这个战斗菜单状态

1805
01:38:48,300 --> 01:38:51,180
我们不再需要菜单了 打开它吧 

1806
01:38:51,180 --> 01:38:54,120
然后推动一个新的转弯状态 

1807
01:38:54,120 --> 01:38:58,830
然后在这个游戏中轮流状态是精灵宝可梦相互战斗 那就是

1808
01:38:58,830 --> 01:39:00,250
转弯状态是什么 

1809
01:39:00,250 --> 01:39:03,030
例如 它可以被称为战斗状态 

1810
01:39:03,030 --> 01:39:05,080
但Take Turn State的用途更多一点 

1811
01:39:05,080 --> 01:39:07,850
如果我们想制造一个精灵宝可梦想要运行

1812
01:39:07,850 --> 01:39:10,590
敌人想跑 我们想打 对吧？

1813
01:39:10,590 --> 01:39:13,680
但你不能总是跑 所以他们应该试着跑 

1814
01:39:13,680 --> 01:39:15,480
然后我们仍然可以和他们战斗 

1815
01:39:15,480 --> 01:39:18,595
或者他们可以使用物品 或者我们可以使用物品 对吗？

1816
01:39:18,595 --> 01:39:20,470
你可以做很多不同的事情 

1817
01:39:20,470 --> 01:39:24,096
或者我们想向他们扔一个弹子球 如果我们失败了 

1818
01:39:24,096 --> 01:39:25,470
那他们就应该和我们战斗 对吗？

1819
01:39:25,470 --> 01:39:27,930
轮流只是一种通用状态

1820
01:39:27,930 --> 01:39:31,050
我们可以改变用途 无论我们有什么用途

1821
01:39:31,050 --> 01:39:35,190
想要与我们和对手之间的任何互动 

1822
01:39:35,190 --> 01:39:38,370
无论是打架 逃跑 还是使用物品 抓住他们 任何

1823
01:39:38,370 --> 01:39:39,900
这些东西的组合 

1824
01:39:39,900 --> 01:39:43,020
但在这种情况下 为了这个例子 为了简单起见 

1825
01:39:43,020 --> 01:39:44,940
我们只实施了战斗 

1826
01:39:44,940 --> 01:39:49,219
我们和对手在这种状态下相互战斗 这是

1827
01:39:49,219 --> 01:39:51,510
一人攻击另一人 然后我们检查死亡人数

1828
01:39:51,510 --> 01:39:52,740
介于两者之间 

1829
01:39:52,740 --> 01:39:57,990
然后走向胜利或伪装取决于哪一种是正确的 

1830
01:39:57,990 --> 01:40:00,030
如果有的话 

1831
01:40:00,030 --> 01:40:01,930
跑步则略有不同 

1832
01:40:01,930 --> 01:40:07,890
因此 如果我们运行 我已经将其编程为100% 它将100%地工作 

1833
01:40:07,890 --> 01:40:10,600
在精灵宝可梦中 你实际上有机会运行

1834
01:40:10,600 --> 01:40:12,860
根据你和你的敌人之间的三角洲 

1835
01:40:12,860 --> 01:40:16,740
因此 如果他们比你强大 你实际上并不能保证会逃走 

1836
01:40:16,740 --> 01:40:23,400
所以我们在我的实现中所做的是 我们只是弹出战斗菜单 

1837
01:40:23,400 --> 01:40:24,670
所以它不见了 

1838
01:40:24,670 --> 01:40:30,880
然后我们推 你成功逃到了屏幕上 这就是战斗信息 

1839
01:40:30,880 --> 01:40:36,870
但这与我们展示的其他战斗信息有所不同 

1840
01:40:36,870 --> 01:40:40,490
我的意思是 这并不是真的不同 但这是值得记住的事情 

1841
01:40:40,490 --> 01:40:43,100
所以我要投入一场战斗 

1842
01:40:45,912 --> 01:40:48,870
首先 通过你刚才在屏幕上看到的信息 

1843
01:40:48,870 --> 01:40:50,430
我必须真的按回车键 对吗？

1844
01:40:50,430 --> 01:40:53,490
我通过按Enter键显式删除了它 

1845
01:40:56,490 --> 01:40:58,382
对于这些信息来说也是如此 

1846
01:40:58,382 --> 01:41:00,090
在我按Enter键之前 它什么都不会做 

1847
01:41:00,090 --> 01:41:03,570
所以我按Enter键 然后我按Enter键 它就这样做了 

1848
01:41:03,570 --> 01:41:06,510
但请注意当我点击Run时的不同 

1849
01:41:06,510 --> 01:41:10,230
我要按下Run 我逃走了 它会自己跑的 

1850
01:41:10,230 --> 01:41:14,235
它不是在等待输入 对吧？

1851
01:41:14,235 --> 01:41:16,159
那么我们是如何实现这一点的呢？

1852
01:41:19,540 --> 01:41:20,155
嗯?

1853
01:41:20,155 --> 01:41:24,680
观众：使用定时器 你会自动

1854
01:41:24,680 --> 01:41:29,010
像之后那样做 而不是等待您的输入 

1855
01:41:29,010 --> 01:41:31,330
您只需等待计时器结束 

1856
01:41:31,330 --> 01:41:34,570
演讲者1：没错 所以我们使用计时器 然后当计时器结束时 

1857
01:41:34,570 --> 01:41:40,390
我们弹出战斗信息 就像我们按回车键弹出它一样 

1858
01:41:40,390 --> 01:41:43,080
这面假旗让我们可以这么做 

1859
01:41:43,080 --> 01:41:46,870
我们按假和假是 我们可以输入或不？

1860
01:41:46,870 --> 01:41:47,890
但我们不能 

1861
01:41:47,890 --> 01:41:51,230
所以实际上 如果我们在这之后不做任何计时器的事情 

1862
01:41:51,230 --> 01:41:54,400
我们刚刚做了一个假旗 战斗信息将永远存在 

1863
01:41:54,400 --> 01:41:56,400
我们永远也摆脱不了

1864
01:41:56,400 --> 01:41:58,420
它会永远卡住 

1865
01:41:58,420 --> 01:42:03,610
所以我们要负责任地说 好吧 我们要放一个计时器 

1866
01:42:03,610 --> 01:42:08,800
我们将在0.5秒后立即调用timer 

1867
01:42:08,800 --> 01:42:11,110
我们要在州内推行一种淡化 

1868
01:42:11,110 --> 01:42:15,190
然后我们要做这两个弹出操作 一旦它消失了

1869
01:42:15,190 --> 01:42:16,180
发生了

1870
01:42:16,180 --> 01:42:19,960
第一次弹出会弹出一条信息 对吧 这条信息

1871
01:42:19,960 --> 01:42:22,910
我们没有通过输入弹出 

1872
01:42:22,910 --> 01:42:26,350
所以这实际上是垃圾收集 在某种意义上 对我们来说 

1873
01:42:26,350 --> 01:42:31,150
它丢弃了我们不能自动丢弃的信息 

1874
01:42:31,150 --> 01:42:33,940
然后我们要进入战斗状态 对吧

1875
01:42:33,940 --> 01:42:38,860
所以跑步会推送战斗信息 触发一个补间计时器

1876
01:42:38,860 --> 01:42:44,440
我们的计时器 五秒钟后 对不起 按下淡入状态 

1877
01:42:44,440 --> 01:42:48,010
然后在状态淡出完成后 弹出这两个状态 

1878
01:42:48,010 --> 01:42:53,420
消息和战斗状态将我们带回到游戏状态 

1879
01:42:53,420 --> 01:42:56,360
一切结束后我们就去那里 

1880
01:42:56,360 --> 01:43:00,880
这就是战斗菜单状态中的所有内容 

1881
01:43:00,880 --> 01:43:04,120
任何问题 以如何战斗菜单工程 战斗之间的区别

1882
01:43:04,120 --> 01:43:08,340
以及它们是如何运作的

1883
01:43:08,340 --> 01:43:09,560
好的.

1884
01:43:09,560 --> 01:43:13,730
让我们来看看

1885
01:43:13,730 --> 01:43:19,700
国家 这是最后一块 也是最大的一块 

1886
01:43:19,700 --> 01:43:24,090
这是与任务最相关的 

1887
01:43:24,090 --> 01:43:28,250
所以我们保持一个参考 口袋妖怪是第一个或第二个去 

1888
01:43:28,250 --> 01:43:31,460
哪个精灵是第一个或第二个 哪个进度条是

1889
01:43:31,460 --> 01:43:33,400
第一个或第二个到这里来 

1890
01:43:33,400 --> 01:43:36,020
就像我说的 我们这样做是基于速度 

1891
01:43:36,020 --> 01:43:40,400
所以无论哪个精灵宝可梦更快 我们也可以

1892
01:43:40,400 --> 01:43:45,330
只是通过保持精灵和进步 让这一切变得更短了

1893
01:43:45,330 --> 01:43:49,400
BAR作为Pokemon对象或类的成员 

1894
01:43:49,400 --> 01:43:53,150
但由于他们是分开的 就像我们不一定

1895
01:43:53,150 --> 01:43:56,870
我想让一个口袋妖怪一直引用它的进度条 

1896
01:43:56,870 --> 01:43:58,025
或者我的意思是 你可以 

1897
01:43:58,025 --> 01:43:59,900
没有什么能阻止你去做这件事 

1898
01:43:59,900 --> 01:44:04,020
它只会用来缩短这里的代码 

1899
01:44:04,020 --> 01:44:10,640
但我们需要保持对此的引用 这样我们才能在这里调用攻击 

1900
01:44:10,640 --> 01:44:16,400
这是这一大块代码的两次 而不需要

1901
01:44:16,400 --> 01:44:18,560
将所有代码复制两次 

1902
01:44:18,560 --> 01:44:21,076
这说得通吗？

1903
01:44:21,076 --> 01:44:22,450
托尼 你有什么问题吗？

1904
01:44:22,450 --> 01:44:24,800
观众：嗯 我只是在想 你也许可以

1905
01:44:24,800 --> 01:44:26,716
将其放入帮助器函数中 您只需

1906
01:44:26,716 --> 01:44:29,260
更改您传递它的顺序 

1907
01:44:29,260 --> 01:44:30,090
演讲者1：什么？

1908
01:44:30,090 --> 01:44:30,640
再说一遍 

1909
01:44:30,640 --> 01:44:33,870
观众：我只是觉得 我想你可以接受代码 

1910
01:44:33,870 --> 01:44:36,373
我想 你可以避免重复这一点 

1911
01:44:36,373 --> 01:44:40,000
因为它只是颠倒了 所以你可以做的是--

1912
01:44:40,000 --> 01:44:44,620
如果你传入一个帮助器函数 你只需要 

1913
01:44:44,620 --> 01:44:48,350
而不是先通过它--

1914
01:44:48,350 --> 01:44:50,730
对手精灵宝可梦 玩家精灵宝可梦 

1915
01:44:50,730 --> 01:44:53,504
你会通过它 玩家精灵宝可梦 对手精灵宝可梦 

1916
01:44:53,504 --> 01:44:55,132
我认为这可能会奏效 

1917
01:44:55,132 --> 01:44:57,590
演讲者1：好吧 你也要考虑到--

1918
01:44:57,590 --> 01:45:04,060
所以评论是 你可以传给玩家口袋妖怪和对手

1919
01:45:04,060 --> 01:45:08,355
将精灵宝可梦转化为一个函数 然后在该函数中反转它们 

1920
01:45:08,355 --> 01:45:10,480
我认为 要尊重它们 扭转它们 

1921
01:45:10,480 --> 01:45:13,780
但精灵与精灵精灵是分离的 

1922
01:45:13,780 --> 01:45:17,170
进度条也与精灵宝可梦分离 

1923
01:45:17,170 --> 01:45:27,790
所以我们可以通过将这四个东西放在这里来缩短它

1924
01:45:27,790 --> 01:45:31,030
精灵宝可梦对象 但严格来说它们并不是

1925
01:45:31,030 --> 01:45:34,180
与精灵宝可梦对象的操作相关 

1926
01:45:34,180 --> 01:45:39,740
这让精灵宝可梦的物件有点

1927
01:45:39,740 --> 01:45:43,586
也 基本上不够抽象或足够轻量级 

1928
01:45:43,586 --> 01:45:45,460
它只是为了达到这一点的目的 

1929
01:45:45,460 --> 01:45:47,660
只需缩短这一小段代码 

1930
01:45:47,660 --> 01:45:53,020
可能有一种更优雅的方式来做到这一点 但很难说 

1931
01:45:53,020 --> 01:45:56,550
如果这个代码变得更大 也许 

1932
01:45:56,550 --> 01:45:58,690
但其主旨基本上是拥有

1933
01:45:58,690 --> 01:46:04,380
指向任何Pokemon、进度条和精灵的指针应该首先操作

1934
01:46:04,380 --> 01:46:06,790
在攻击中 而不是在第二次行动中 

1935
01:46:06,790 --> 01:46:10,730
然后 两人将根据谁是第一个 谁是谁的顺序交换拳头

1936
01:46:10,730 --> 01:46:12,530
第二 

1937
01:46:12,530 --> 01:46:14,560
所以当我们进入转弯状态时 我们是

1938
01:46:14,560 --> 01:46:18,730
将触发攻击 这里是函数攻击 我们将在

1939
01:46:18,730 --> 01:46:22,210
第一 第二 第一 第二 第一 第二

1940
01:46:22,210 --> 01:46:24,760
雪碧和进度条 

1941
01:46:24,760 --> 01:46:27,850
然后是匿名函数 它被执行为

1942
01:46:27,850 --> 01:46:31,810
一旦攻击结束 对吗？

1943
01:46:31,810 --> 01:46:35,800
所以这是一个代码 它将弹出一条在攻击中被推送的消息 

1944
01:46:35,800 --> 01:46:39,040
然后这就是我们真正检查死亡人数的地方 对吗？

1945
01:46:39,040 --> 01:46:42,380
它将决定我们是走向胜利还是走向黯淡的屏幕 

1946
01:46:42,380 --> 01:46:44,920
如果不是 如果是 我们就回来 

1947
01:46:44,920 --> 01:46:47,186
如果没有 我们将进行另一次攻击 但请看 

1948
01:46:47,186 --> 01:46:48,310
现在一切都颠倒过来了 

1949
01:46:48,310 --> 01:46:53,281
现在是第二 第一 第二 第一 第二 第一 

1950
01:46:53,281 --> 01:46:55,030
所以我们有相同的功能 自我攻击 

1951
01:46:55,030 --> 01:46:57,130
这只会收留袭击者 

1952
01:46:57,130 --> 01:47:00,310
它实际上是 攻击者 防御者 攻击者 防御者 攻击者 

1953
01:47:00,310 --> 01:47:05,860
精灵精灵和进度条的后卫 

1954
01:47:05,860 --> 01:47:09,350
所以这里的攻击函数首先推动一个--

1955
01:47:09,350 --> 01:47:10,120
好吧 好吧 

1956
01:47:10,120 --> 01:47:11,329
攻击是什么--

1957
01:47:11,329 --> 01:47:12,620
让我们再复习一遍 

1958
01:47:12,620 --> 01:47:18,279
我们认为攻击功能按顺序执行什么操作 

1959
01:47:18,279 --> 01:47:20,070
我们刚刚报道了他们 但是什么？

1960
01:47:20,070 --> 01:47:24,070
当一种东西攻击另一种东西时 发生的顺序是什么？

1961
01:47:24,070 --> 01:47:25,188
嗯?

1962
01:47:25,188 --> 01:47:27,235
观众：袭击者呈白色闪烁 

1963
01:47:27,235 --> 01:47:28,645
扬声器1：攻击者呈白色闪烁 

1964
01:47:28,645 --> 01:47:33,900
观众：然后防守者眨眼表示不透明 

1965
01:47:33,900 --> 01:47:36,626
演讲者1：防御者切换它的不透明度 

1966
01:47:36,626 --> 01:47:38,244
观众：健康吧也缩水了 

1967
01:47:38,244 --> 01:47:39,494
演讲者1：健康吧缩小了 

1968
01:47:42,850 --> 01:47:45,570
没错 然后基本上就是为了进攻了 对吧？

1969
01:47:45,570 --> 01:47:49,690
眨眼 播放声音 眨眼 播放声音 缩小酒吧 

1970
01:47:49,690 --> 01:47:52,810
同时 我们也在破坏这一功能 

1971
01:47:52,810 --> 01:47:55,450
事实上 我们必须改变精灵宝可梦的状态 

1972
01:47:59,590 --> 01:48:02,150
所以这实际上就是它开始的地方 对吗？

1973
01:48:02,150 --> 01:48:05,557
我们将战斗消息状态放到堆栈上 

1974
01:48:05,557 --> 01:48:07,390
攻击者名称攻击防御者名称 

1975
01:48:10,510 --> 01:48:15,490
请注意 它会像Run消息一样变为FALSE

1976
01:48:15,490 --> 01:48:17,830
是的 因为我们这里不接受输入 

1977
01:48:17,830 --> 01:48:25,870
但这实际上取决于我们 它在进入状态的第42行完成 

1978
01:48:25,870 --> 01:48:32,260
但我们将在0.5秒后播放攻击动画 

1979
01:48:32,260 --> 01:48:36,400
因此 每0.1秒就启动一次声音 

1980
01:48:36,400 --> 01:48:39,340
我们会记住精灵身上闪烁的旗帜 

1981
01:48:39,340 --> 01:48:42,980
我们将通过不将其设置为自身来切换它 

1982
01:48:42,980 --> 01:48:46,290
因此 如果某个东西不是它本身 如果它是真实的价值 它就会变得虚假 

1983
01:48:46,290 --> 01:48:48,340
如果它是假的 它就会变成真的 

1984
01:48:48,340 --> 01:48:51,100
所以基本上 在真与假之间来回切换 

1985
01:48:51,100 --> 01:48:53,530
限制为六个 对 因为记住 每一份遗嘱

1986
01:48:53,530 --> 01:48:56,200
无限期地做某件事 

1987
01:48:56,200 --> 01:49:00,700
除非您传入某个值的限制 在本例中 限制为6 

1988
01:49:00,700 --> 01:49:04,870
所以我们说 只执行这段代码六次 只眨眼六次 对吧 

1989
01:49:04,870 --> 01:49:07,690
只切换六次 眨眼三次 对吧 

1990
01:49:07,690 --> 01:49:09,800
因为它必须时断时续 

1991
01:49:09,800 --> 01:49:12,550
然后 当这六次迭代完成后 

1992
01:49:12,550 --> 01:49:16,360
我们在该Timer对象上调用已完成的函数 

1993
01:49:16,360 --> 01:49:18,156
这是一种诚实的行为 

1994
01:49:18,156 --> 01:49:22,542
一旦发生这种情况 我们就做不透明的部分 对吗？

1995
01:49:22,542 --> 01:49:25,250
我们对进攻者眨眼 所以现在我们要对防守者眨眼 

1996
01:49:25,250 --> 01:49:27,760
所以我们播放热门音乐 

1997
01:49:27,760 --> 01:49:32,110
我们做的和刚才对眨眼时做的完全一样 只是现在 

1998
01:49:32,110 --> 01:49:37,480
每0.1秒 我们将其不透明度设置为64或255 

1999
01:49:37,480 --> 01:49:40,900
取决于其不透明度的值 对吗？

2000
01:49:40,900 --> 01:49:43,240
所以我们在64到255之间切换 

2001
01:49:43,240 --> 01:49:47,050
六个极限 取一个函数 计算损害 

2002
01:49:47,050 --> 01:49:53,210
我们刚刚非常简单地做到了 进攻减去防守 对 到1

2003
01:49:53,210 --> 01:49:53,710
尽管如此 

2004
01:49:53,710 --> 01:49:55,918
因此 如果防守实际上高于进攻 

2005
01:49:55,918 --> 01:49:58,000
但仍会造成至少一次伤害 

2006
01:49:58,000 --> 01:50:03,370
然后在0.5秒内 我们拿起防守杆 

2007
01:50:03,370 --> 01:50:08,650
我们的价值等于他们当前的生命值减去伤害 对吗？

2008
01:50:08,650 --> 01:50:15,580
然后它将设置在进度条中 设置它的值 

2009
01:50:15,580 --> 01:50:21,460
即使进度条落后于州政府 

2010
01:50:21,460 --> 01:50:24,760
对 它在堆栈的底部 因为它处于战斗状态 

2011
01:50:24,760 --> 01:50:27,000
我们目前正处于转弯状态 

2012
01:50:27,000 --> 01:50:30,580
而是因为我们仍在操纵该州的价值观 

2013
01:50:30,580 --> 01:50:33,640
我们正在呈现每个州 我们实际上仍然在操纵

2014
01:50:33,640 --> 01:50:37,040
不管它不在堆栈的顶部这一事实 该状态 

2015
01:50:37,040 --> 01:50:43,510
所以这允许我们缩小精灵宝可梦进度条 不管它是什么

2016
01:50:43,510 --> 01:50:45,360
不管是不是在股票的顶端 

2017
01:50:45,360 --> 01:50:47,800
一旦结束了 一旦结束了 

2018
01:50:47,800 --> 01:50:49,591
实际上将当前的HP设置为该值 

2019
01:50:49,591 --> 01:50:52,450
因为我们只调整了进度条的值 即

2020
01:50:52,450 --> 01:50:55,277
独立于精灵宝可梦的价值 

2021
01:50:55,277 --> 01:50:56,860
然后 攻击就结束了 

2022
01:50:56,860 --> 01:50:59,300
攻击在这一点上完全结束了 

2023
01:50:59,300 --> 01:51:02,940
关于袭击是如何运作的 有什么问题吗？

2024
01:51:02,940 --> 01:51:06,610
基本上就是一串十几岁的孩子 

2025
01:51:06,610 --> 01:51:10,110
所以我们进行一次攻击 然后检查死亡人数是下一个功能 

2026
01:51:10,110 --> 01:51:14,400
我们快结束了 我要快点走了 现在是7：30 

2027
01:51:14,400 --> 01:51:18,540
检查死亡是玩家口袋妖怪当前的HP小于等于0 

2028
01:51:18,540 --> 01:51:21,540
还是对手精灵宝可梦目前的HP小于等于零 

2029
01:51:21,540 --> 01:51:24,750
如果前者是真的 我们需要晕倒 如果后者是真的 

2030
01:51:24,750 --> 01:51:25,860
我们需要走向胜利 

2031
01:51:25,860 --> 01:51:32,880
所以晕倒实际上是一种战斗状态 对 当它说 你晕倒了 

2032
01:51:32,880 --> 01:51:33,817
然后呢？

2033
01:51:33,817 --> 01:51:36,799
还记得我们晕倒的时候会发生什么吗？

2034
01:51:36,799 --> 01:51:41,780
观众：[听不见]文本框 然后就离开了 

2035
01:51:41,780 --> 01:51:44,051
演讲者1：它离开了 你还记得怎么走吗？

2036
01:51:44,051 --> 01:51:46,550
例如 它离开是因为它与逃跑不同？

2037
01:51:46,550 --> 01:51:48,790
观众：[听不见] 

2038
01:51:48,790 --> 01:51:50,672
演讲者1：嗯 除此之外 从美学上讲 

2039
01:51:50,672 --> 01:51:52,130
你还记得有什么不同吗？

2040
01:51:52,130 --> 01:51:55,119
观众：(听不见)我认为 这和黑人不同 

2041
01:51:55,119 --> 01:51:55,910
演讲者1：的确如此 

2042
01:51:55,910 --> 01:51:57,081
相反 它会褪色为黑色 

2043
01:51:57,081 --> 01:51:59,330
所以这就是我们在晕倒时如何区分

2044
01:51:59,330 --> 01:52:00,891
而不是我们逃跑的时候 

2045
01:52:00,891 --> 01:52:02,390
这就是我们在这里做的事情 

2046
01:52:02,390 --> 01:52:06,580
请注意 状态RGB中的淡入度为零 所有这些 

2047
01:52:06,580 --> 01:52:12,890
因此 它将淡入到000255 而不是255255,255,255 

2048
01:52:12,890 --> 01:52:17,000
所以这将是一个黑色淡入与白色淡入 

2049
01:52:17,000 --> 01:52:18,217
然后一旦我们--

2050
01:52:18,217 --> 01:52:20,300
这只是我实现的一种方式

2051
01:52:20,300 --> 01:52:21,883
我们可以无限期地继续比赛 

2052
01:52:21,883 --> 01:52:25,790
但一旦完成 让玩家口袋妖怪完全恢复健康 

2053
01:52:25,790 --> 01:52:27,740
恢复所有现场音乐的内容 

2054
01:52:27,740 --> 01:52:31,851
一旦我们推入淡出状态 000 

2055
01:52:31,851 --> 01:52:34,910
然后我们又回到了赛场 让我们继续前进 

2056
01:52:34,910 --> 01:52:38,360
注意 这里它接受一个函数 在淡出状态完成之后 

2057
01:52:38,360 --> 01:52:42,620
一旦淡出完成--所以只要我们回到播放状态 

2058
01:52:42,620 --> 01:52:44,630
按下对话状态 上面写着：您的精灵宝可梦

2059
01:52:44,630 --> 01:52:47,300
已完全恢复 请重试 

2060
01:52:47,300 --> 01:52:49,770
这将根据上下文 我们将[INAUDIBLE]

2061
01:52:49,770 --> 01:52:51,374
按Enter键跳过它 

2062
01:52:51,374 --> 01:52:52,040
那是在晕倒 

2063
01:52:54,620 --> 01:52:58,070
胜利稍微更有活力一些 

2064
01:52:58,070 --> 01:53:02,748
所以胜利就是--你还记得当我们取得胜利时会发生什么吗？

2065
01:53:06,644 --> 01:53:11,027
观众：嗯 它还得检查调平 

2066
01:53:11,027 --> 01:53:17,500
它说 你已经击败了你的对手 然后你的XP条增加了 

2067
01:53:17,500 --> 01:53:20,212
如果你升级了 它会告诉你你升级了 

2068
01:53:20,212 --> 01:53:21,480
然后它就离开了 

2069
01:53:21,480 --> 01:53:27,850
演讲者1：它告诉你你打败了你的对手 XP条增加了 

2070
01:53:27,850 --> 01:53:30,700
检查上一级 然后离开 

2071
01:53:30,700 --> 01:53:35,810
在显示或不显示升级消息后 它离开 

2072
01:53:35,810 --> 01:53:39,460
准确地说 它会将所有东西弹回播放状态 

2073
01:53:39,460 --> 01:53:42,070
所以请记住 发生的第一件事

2074
01:53:42,070 --> 01:53:46,780
尽管如此 对手精灵在0.2秒的过程中被打了补丁 

2075
01:53:46,780 --> 01:53:49,040
它的y值等于虚拟高度 这意味着 

2076
01:53:49,040 --> 01:53:50,998
一直到屏幕的底部 对吗？

2077
01:53:50,998 --> 01:53:56,050
典型的从精灵宝可梦中击败你的对手的动画 

2078
01:53:56,050 --> 01:53:58,420
一旦完成 播放胜利的音乐 

2079
01:53:58,420 --> 01:54:01,190
推送一个战斗信息状态 上面写着 胜利 对吗？

2080
01:54:01,190 --> 01:54:04,860
一旦它从堆栈中弹出 计算XP 

2081
01:54:04,860 --> 01:54:09,330
也就是说 我刚刚选择了任意加和那个精灵宝可梦时代的所有IV

2082
01:54:09,330 --> 01:54:12,500
它是Level 这就是你得到的XP 

2083
01:54:12,500 --> 01:54:18,340
推送一个状态 上面写着 你赢得了xXP 对吗？

2084
01:54:18,340 --> 01:54:21,985
它是假的 所以这意味着它不接受输入 

2085
01:54:21,985 --> 01:54:24,610
因此 这意味着这取决于我们 以便将其从堆栈中弹出 

2086
01:54:24,610 --> 01:54:29,830
所以1.5秒后 我们播放一段声音 然后我们在XP栏向上移动 

2087
01:54:29,830 --> 01:54:31,120
对吗？

2088
01:54:31,120 --> 01:54:34,470
这就是发生在这里的事情 self.bustleState.playerxpbar 

2089
01:54:34,470 --> 01:54:40,210
我们正在调整数学 人 XP和XP的人 

2090
01:54:40,210 --> 01:54:45,850
或者XP升级 因为如果我们不这样做 它可能会越过XP条的边缘 

2091
01:54:45,850 --> 01:54:49,240
因为我们可以把我们的经验提升到一个水平 对吗？

2092
01:54:49,240 --> 01:54:52,330
假设我们有10个经验值 直到我们达到一个等级 我们可以获得20个经验值 

2093
01:54:52,330 --> 01:54:53,860
我们会落入10XP的圈套 

2094
01:54:53,860 --> 01:54:58,450
因此 我们不想在XP栏的边缘之外补间XP栏 

2095
01:54:58,450 --> 01:55:00,110
这将是一个图形故障 

2096
01:55:00,110 --> 01:55:05,410
所以算一算 我们的XP加上XP 我们的XP达到了水平 

2097
01:55:05,410 --> 01:55:08,740
它将取两个值中较小的一个 

2098
01:55:08,740 --> 01:55:12,250
一旦完成 它被补齐 我们将弹出消息 

2099
01:55:12,250 --> 01:55:15,760
然后我们将实际添加XP 级别更高 

2100
01:55:15,760 --> 01:55:19,390
因此 如果XP大于XP to Level 这就是我们升级的地方 

2101
01:55:19,390 --> 01:55:26,260
播放声音 将XP设置为当前XP减去2级XP 

2102
01:55:26,260 --> 01:55:30,130
这意味着我们会有一些结转 对吗？

2103
01:55:30,130 --> 01:55:32,060
然后实际调用Level Up函数 

2104
01:55:32,060 --> 01:55:35,230
这就是--

2105
01:55:35,230 --> 01:55:37,990
哦 还有 在那之后 祝贺你 你升级了 

2106
01:55:37,990 --> 01:55:40,570
淡出白色 这只是一个白色淡出这里 

2107
01:55:40,570 --> 01:55:43,360
我用了两次 所以我为它做了一个函数 

2108
01:55:43,360 --> 01:55:46,300
只是在状态中推动淡入淡出 

2109
01:55:46,300 --> 01:55:50,440
停止胜利的音乐 播放田野音乐 流行 推入淡出状态 

2110
01:55:50,440 --> 01:55:56,110
所以不管怎样 当我们取得胜利时 我们会把淡出的颜色变成白色 

2111
01:55:56,110 --> 01:55:58,360
或者我们会把淡出称为白色 对吗？

2112
01:55:58,360 --> 01:56:02,920
所以推送战斗信息状态 然后尽快

2113
01:56:02,920 --> 01:56:06,370
当我们按回车键时 因为我们升级了 淡出为白色 

2114
01:56:06,370 --> 01:56:08,690
如果我们没有升级 但我们还是取得了胜利 

2115
01:56:08,690 --> 01:56:10,360
我们仍然需要淡出白色 

2116
01:56:10,360 --> 01:56:13,280
这就是你们的作业 作业7 

2117
01:56:13,280 --> 01:56:17,517
作业7是 注意我们已经升级了self.playerPokemon级别 

2118
01:56:17,517 --> 01:56:19,600
我们需要在这里做的关键事情是

2119
01:56:19,600 --> 01:56:23,020
就是添加一个菜单 显示我们是如何升级的 

2120
01:56:23,020 --> 01:56:27,160
如果您还记得 playerPokemon Level Up会返回所有统计数据

2121
01:56:27,160 --> 01:56:29,260
你已经提升了这个级别 

2122
01:56:29,260 --> 01:56:34,980
所以你可以显示一个菜单 上面只写着 你的惠普加那个金额 对吗？

2123
01:56:34,980 --> 01:56:36,480
您将获得所有四个值 

2124
01:56:36,480 --> 01:56:38,650
它将爆炸式增长到所有这四个值 

2125
01:56:38,650 --> 01:56:42,460
然后你将创造一场新的战斗--

2126
01:56:42,460 --> 01:56:46,330
或者不是新的战斗菜单 而是你想要的任何新菜单 

2127
01:56:46,330 --> 01:56:51,760
但可能在物品垂直高度的右侧 

2128
01:56:51,760 --> 01:56:53,890
这里唯一的区别 唯一的关键

2129
01:56:53,890 --> 01:56:55,930
你将会考虑到

2130
01:56:55,930 --> 01:56:59,290
是 我会回到幻灯片 因为我们实际上

2131
01:56:59,290 --> 01:57:01,660
在这一点上完成了代码的检查 

2132
01:57:01,660 --> 01:57:07,180
但是选择项 你实际上不能选择任何东西 

2133
01:57:07,180 --> 01:57:09,220
这将是纯粹的视觉效果 

2134
01:57:09,220 --> 01:57:12,520
因此 您需要编辑所选内容才能选择

2135
01:57:12,520 --> 01:57:13,504
没有光标 

2136
01:57:13,504 --> 01:57:15,670
这一点在规范中有详细说明 实际上

2137
01:57:15,670 --> 01:57:17,330
在今天的讲座前发布 

2138
01:57:17,330 --> 01:57:18,910
所以你可以看看这个 

2139
01:57:18,910 --> 01:57:21,760
但您需要对选择进行更改 

2140
01:57:21,760 --> 01:57:23,070
但所有的碎片都在那里 

2141
01:57:23,070 --> 01:57:24,945
这应该是一项相当容易的任务 只要

2142
01:57:24,945 --> 01:57:28,390
当你了解这些州是如何运作的 菜单是如何运作的 

2143
01:57:28,390 --> 01:57:33,040
以及如何基于这些值创建菜单 

2144
01:57:33,040 --> 01:57:35,320
以及如何从Level Up中实际获取值 

2145
01:57:35,320 --> 01:57:38,830
因此 一些我们没有讨论的、我们没有实现的缺失功能

2146
01:57:38,830 --> 01:57:41,380
例如 屏幕的详细程度 

2147
01:57:41,380 --> 01:57:45,040
抓怪兽是你的任务 对吧？

2148
01:57:45,040 --> 01:57:49,150
在整个过程中我们只有一个精灵宝可梦的派对 

2149
01:57:49,150 --> 01:57:53,500
但可以说 这项运动的主要吸引力之一是能够捕捉到更多 

2150
01:57:53,500 --> 01:57:57,790
所以这将是一些需要添加的东西 需要对可能添加到游戏中的内容进行优先排序 

2151
01:57:57,790 --> 01:58:00,880
一个现场菜单 可以真正看到你捕捉到的所有精灵宝可梦 

2152
01:58:00,880 --> 01:58:04,390
这会很好 这样你就可以真正看到他们有多少惠普 

2153
01:58:04,390 --> 01:58:07,330
在物品库存中 因为游戏 常规游戏中都有物品 

2154
01:58:07,330 --> 01:58:10,420
你可以使用魔药 你可以找到金块

2155
01:58:10,420 --> 01:58:12,370
你卖了一大笔钱 

2156
01:58:12,370 --> 01:58:15,702
不同的能力 目前我们基本上只有一次战斗行动 

2157
01:58:15,702 --> 01:58:16,660
这就像是铲球 

2158
01:58:16,660 --> 01:58:19,240
而游戏本身 常规的游戏也有

2159
01:58:19,240 --> 01:58:22,270
就像100多个具有基本属性的不同动作一样 

2160
01:58:22,270 --> 01:58:25,600
做不同的事情 造成地位的影响 

2161
01:58:25,600 --> 01:58:27,250
提高你或你的对手的威力 

2162
01:58:27,250 --> 01:58:30,790
所以加入这些是很有吸引力的 也许是

2163
01:58:30,790 --> 01:58:33,814
能够将它们表示为适合的数据 

2164
01:58:33,814 --> 01:58:36,730
你可以在游戏中遇到的训练者 他们有自己的预设

2165
01:58:36,730 --> 01:58:38,954
或者随机化的精灵宝可梦去战斗 

2166
01:58:38,954 --> 01:58:41,620
怪物进化 因为这是最有趣的事情之一

2167
01:58:41,620 --> 01:58:43,661
是拿着一个非常虚弱的精灵宝可梦 就像提高

2168
01:58:43,661 --> 01:58:46,850
它变得非常强大 并在一定程度上进化 

2169
01:58:46,850 --> 01:58:52,870
城镇 路线 其他水平 不仅仅是我们的基本正方形区域 

2170
01:58:52,870 --> 01:58:55,600
怪物繁殖 在第二季中介绍 

2171
01:58:55,600 --> 01:58:58,050
这样你就可以拿到两个精灵宝可梦

2172
01:58:58,050 --> 01:59:02,074
为了得到一个拥有非常好的统计数据的鸡蛋或者一个非常稀有的精灵宝可梦 

2173
01:59:02,074 --> 01:59:04,990
然后就像一个昼夜循环 也许就是不同的精灵宝可梦出现的地方

2174
01:59:04,990 --> 01:59:06,560
在一天中的不同时间 

2175
01:59:06,560 --> 01:59:11,680
所以你被激励在不同时间打球

2176
01:59:11,680 --> 01:59:14,590
就是为了这个目的 

2177
01:59:14,590 --> 01:59:16,450
但精灵宝可梦就到此为止了 

2178
01:59:16,450 --> 01:59:19,030
下周 我们将真正深入到“团结”中去 

2179
01:59:19,030 --> 01:59:23,200
所以我们实际上已经完成了爱情2D 这是非常有趣的 

2180
01:59:23,200 --> 01:59:26,090
但现在我们将探讨如何制作3D游戏 

2181
01:59:26,090 --> 01:59:28,840
这是我们下周将制作的游戏的截图 

2182
01:59:28,840 --> 01:59:32,470
这是一种3D侧滚Flappy Bird风格的直升机

2183
01:59:32,470 --> 01:59:38,590
这款游戏是根据著名的网络游戏《直升机游戏》改编的 

2184
01:59:38,590 --> 01:59:44,250
它可以说是Flappy Bird的早期祖先之一 

2185
01:59:44,250 --> 01:59:46,990
在维基百科的页面上 实际上也是这样说的 

2186
01:59:46,990 --> 01:59:51,452
我记得打球 那是在2007年 或者2006年 或者类似的事情 

2187
01:59:51,452 --> 01:59:54,160
但你在这个游戏中的目标--这是一个修改后的版本--

2188
01:59:54,160 --> 01:59:58,130
你的目标是你的--一切都是3D的 但它是一个侧面滚动的视角 

2189
01:59:58,130 --> 02:00:01,570
因此 这被称为2.5D 因为这个原因 

2190
02:00:01,570 --> 02:00:04,360
你控制着一架直升机 你就是那架紫色直升机 

2191
02:00:04,360 --> 02:00:07,670
你的目标是在一个无限滚动的世界里 

2192
02:00:07,670 --> 02:00:11,760
因此 我们将重温无限滚动 但在3D中 请避开摩天大楼 

2193
02:00:11,760 --> 02:00:15,880
所以你可以看到那里有一座绿色的摩天大楼 造型简陋 

2194
02:00:15,880 --> 02:00:18,880
收集硬币 你可以看到那里有一枚硬币 这是一枚3D硬币 

2195
02:00:18,880 --> 02:00:20,440
它将永远在旋转 

2196
02:00:20,440 --> 02:00:22,570
你的硬币在右上角 

2197
02:00:22,570 --> 02:00:24,880
你会看到一个无限滚动的背景 

2198
02:00:24,880 --> 02:00:26,740
然后你会有随机的喷气式飞机

2199
02:00:26,740 --> 02:00:31,090
在你上方飞翔 给你另一种层次或维度

2200
02:00:31,090 --> 02:00:32,950
需要注意的障碍 

2201
02:00:32,950 --> 02:00:36,910
这将教会我们很多关于团结是如何运作的基础知识 

2202
02:00:36,910 --> 02:00:41,110
所以我们可以开始进入更有趣的事情 比如第一人称

2203
02:00:41,110 --> 02:00:43,090
就像是核心探险游戏 

2204
02:00:43,090 --> 02:00:45,820
最后 当我们在门户网站的学期结束时 

2205
02:00:45,820 --> 02:00:48,130
我们将在那里看几件奇特的东西 

2206
02:00:48,130 --> 02:00:49,380
但精灵宝可梦就到此为止了 

2207
02:00:49,380 --> 02:00:51,255
感谢你们的光临 我们下次再见

2208
02:00:51,255 --> 02:00:52,430
时间到了 
