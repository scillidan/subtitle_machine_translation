1
00:00:16,290 --> 00:00:19,560
演讲者1：好的 欢迎来到GD 50 第7讲 
SPEAKER 1: All right, welcome to GD 50, lecture 7.

2
00:00:19,560 --> 00:00:22,950
这周我们将谈论我最喜欢的特许经营权之一 
This week we'll be talking about one of my favorite franchises of all time,

3
00:00:22,950 --> 00:00:24,870
我童年的核心部分
a core part of my childhood--

4
00:00:24,870 --> 00:00:27,850
口袋妖怪 就像屏幕上的口袋妖怪球一样 
Pokemon as shown by the Poke Ball on the screen there.

5
00:00:27,850 --> 00:00:32,280
我记得是在1997年 第一个口袋妖怪
So back in 1997 I think it was, the first Pokemon

6
00:00:32,280 --> 00:00:34,004
游戏名称：红与蓝
game was released, Red and Blue.

7
00:00:34,004 --> 00:00:36,420
我相信它是一年前在日本发布的 
I believe it was released a year earlier in Japan where it

8
00:00:36,420 --> 00:00:39,661
以红蓝绿三种颜色发布
was released as Red, Blue, and Green.

9
00:00:39,661 --> 00:00:42,160
游戏的总体目标相当简单 
And the overall goal of the game was fairly straightforward.

10
00:00:42,160 --> 00:00:43,284
你是个宠物小精灵训练师
You were a Pokemon trainer.

11
00:00:43,284 --> 00:00:47,250
你的目标是走进这个世界 
Your goal was to go out into the world and try and capture

12
00:00:47,250 --> 00:00:51,900
151种不同的生物
any number of 151 different types of these creatures called

13
00:00:51,900 --> 00:00:56,460
口袋妖怪是基于一大堆不同类型的生物 
Pokemon that were based on a whole bunch of different types of creatures.

14
00:00:56,460 --> 00:01:00,170
在这里的截图显示 有一个Weepinbell战斗和Geodude 
Shown in the screenshot here, there's a Weepinbell fighting and Geodude.

15
00:01:00,170 --> 00:01:03,270
Geodude是岩石类型 Weepinbeel是草类型 
A Geodude was a rock type, Weepinbeel was a grass type.

16
00:01:03,270 --> 00:01:05,280
你有不同类型的口袋妖怪 
You had different types of Pokemon.

17
00:01:05,280 --> 00:01:08,340
当他们互相争斗的时候 有些人比其他人更好 
When they fight each other, some types were better than other types,

18
00:01:08,340 --> 00:01:12,572
就像是石头剪子布的关系 
like this sort of very large rock, paper, scissors relationship.

19
00:01:12,572 --> 00:01:14,280
这是一个非常上瘾的公式 
And it was just a very addicting formula.

20
00:01:14,280 --> 00:01:17,100
你会有一队这样的生物 你抓来养大的
You'd have a team of these creatures that you had caught and raised

21
00:01:17,100 --> 00:01:20,670
和其他驯兽师战斗
and battled, and you'd fight other trainers.

22
00:01:20,670 --> 00:01:23,490
最棒的是你可以
And the awesome part of this was you could go

23
00:01:23,490 --> 00:01:25,440
你可以和你的朋友打架
and you could actually fight your friends,

24
00:01:25,440 --> 00:01:28,200
或者和你抓到的朋友交换口袋妖怪
or trade Pokemon with your friends that they had caught.

25
00:01:28,200 --> 00:01:30,200
你们经常互相分享故事
And you would often share stories back and forth

26
00:01:30,200 --> 00:01:32,991
你可能会遇到的各种稀有生物
about the different rare creatures that you would have encountered,

27
00:01:32,991 --> 00:01:34,170
以及各种各样的东西 
and all sorts of things.

28
00:01:34,170 --> 00:01:37,170
你会有一个定制的派对那是你的一部分 
You'd have a customized party that was sort of a part of you.

29
00:01:37,170 --> 00:01:38,700
这就是Pokemon Red 
And so this is Pokemon Red.

30
00:01:38,700 --> 00:01:40,160
该系列随着时间的推移而发展 
The series has evolved over time.

31
00:01:40,160 --> 00:01:43,368
这是几年前发布的《黄金与白银》的截图
This is a screenshot of Gold and Silver, which was released a couple of years

32
00:01:43,368 --> 00:01:45,150
游戏机颜色Gameboy Color
afterwards for the Gameboy Color.

33
00:01:45,150 --> 00:01:48,120
再次 这是为常规Gameboy发布的 
Again, this was released for the regular Gameboy.

34
00:01:48,120 --> 00:01:51,180
金银引入了一系列新功能 包括育种 
Gold and Silver introduced a bunch of new features including breeding,

35
00:01:51,180 --> 00:01:53,310
昼夜循环 还有很多其他的东西
and a day, night cycle, and a lot of other things

36
00:01:53,310 --> 00:01:55,310
这成为了核心系列的一部分 
that became part of the core series.

37
00:01:55,310 --> 00:01:58,500
这是Ruby和Sapphire 这是为了《游戏男孩》而准备的
Here is Ruby and Sapphire, which was for the Gameboy Advance

38
00:01:58,500 --> 00:02:01,500
得到了一个重要的图形更新 但核心公式
and got a significant graphical update, but the core formula

39
00:02:01,500 --> 00:02:03,330
基本保持不变 
stayed much the same.

40
00:02:03,330 --> 00:02:08,130
这是钻石和珍珠 这是给DS的 
Here is Diamond and Pearl, which is for the DS, which

41
00:02:08,130 --> 00:02:11,730
它使用了两个屏幕 如上面和下面所示 
it made use of two screens, as seen on the top and bottom there.

42
00:02:11,730 --> 00:02:14,460
这是黑与白 这是又向前迈进了一步
Here is Black and White, which was another step forward

43
00:02:14,460 --> 00:02:18,060
因为它为世界各地引入了三维图形 
in that it introduced three dimensional graphics for the over world,

44
00:02:18,060 --> 00:02:21,960
因此 你可以在该系列中第一次看到某种3D效果 
so you could actually see some sort of 3D for the first time in the franchise.

45
00:02:21,960 --> 00:02:26,230
最近 我们看到了像X和Y这样的3DS游戏 
And then more recently, we've seen for the 3DS, games like X and Y,

46
00:02:26,230 --> 00:02:29,940
如图所示 欧米茄蓝宝石 阿尔法红宝石--
which is shown here, and Omega Sapphire, Alpha Ruby--

47
00:02:29,940 --> 00:02:33,990
阿尔法蓝宝石和欧米茄红宝石 以及月亮和太阳 
Alpha Sapphire and Omega Ruby, and Moon and Sun.

48
00:02:33,990 --> 00:02:37,680
这是一个很好的例子 说明了为什么
And so this is a great illustration of why

49
00:02:37,680 --> 00:02:41,700
RPG类型的电子游戏 角色扮演游戏 
the RPG genre of video games, role playing game,

50
00:02:41,700 --> 00:02:44,880
尽管它在某种程度上是对这个公式的独特看法 
even though it's sort of its own unique take on the formula.

51
00:02:44,880 --> 00:02:47,760
但它允许我们 我们可以某种程度上剖析这个 并看看
But it allows us to, we can sort of dissect this and take a look

52
00:02:47,760 --> 00:02:51,210
RPG是什么 口袋妖怪游戏又是什么
at what makes an RPG and what makes a Pokemon game altogether

53
00:02:51,210 --> 00:02:52,860
做一个很酷的演示 
for a nice cool demonstration.

54
00:02:52,860 --> 00:02:54,943
因此 今天 我们将谈论一些新事物 
So today, we'll be talking about a few new things.

55
00:02:54,943 --> 00:02:58,800
在这个讲课示例中 我们的做法会有很大不同
We'll be doing things a lot differently in this lecture example

56
00:02:58,800 --> 00:03:03,060
相对于其他例子 因为我们正在从国家过渡
relative to other examples, because we're transitioning away from the state

57
00:03:03,060 --> 00:03:07,500
机器 并谈论一种称为状态堆栈的结构 该结构
machine and talking about a construct called the state stack, which

58
00:03:07,500 --> 00:03:10,800
实际上是状态机的更高级版本 
is effectively a more advanced version of the state machine.

59
00:03:10,800 --> 00:03:15,420
而在此之前 我们有一个状态机 它一次处于一个状态 
Whereas before, we had a state machine that was in one state at a time,

60
00:03:15,420 --> 00:03:19,560
因此 我们可能处于播放状态或开始状态或其他状态
whereby we could be in the play state or the start state or what

61
00:03:19,560 --> 00:03:22,290
不 我们现在实际上可以有多个州
not, we can now actually have multiple states

62
00:03:22,290 --> 00:03:25,920
它们并行地存在于一堆数据结构上 您已经
that exist in parallel that are on a stack of data structure, which you've

63
00:03:25,920 --> 00:03:29,110
在CS 50中可以看到 如果你已经采取了 我们可以有 
seen in CS 50 if you've taken, where we can have,

64
00:03:29,110 --> 00:03:32,070
例如 场状态、最底部的播放状态、
for example, the field state, the play state at the very bottom,

65
00:03:32,070 --> 00:03:36,180
它总是在那里 然后我们可以将状态推送到堆栈上
which is always there, and then we can push states onto the stack

66
00:03:36,180 --> 00:03:39,120
正如我们所需要的 例如 对话状态
as we need to for example, a dialog state

67
00:03:39,120 --> 00:03:41,410
这样我们就可以实际显示一些对话框 
so that we can actually display some dialog,

68
00:03:41,410 --> 00:03:44,940
将一些文本放到屏幕上 而不是摆脱播放状态
some text to the screen without getting rid of the play state

69
00:03:44,940 --> 00:03:46,720
我们以前在那里吃过的 
that we had there before.

70
00:03:46,720 --> 00:03:50,220
它允许我们同时渲染多个物体 
It allows us to render multiple things at the same time,

71
00:03:50,220 --> 00:03:52,530
然后也返回到先前的状态 
and then also return back to prior states,

72
00:03:52,530 --> 00:03:55,060
而不是每次都完全创建新的状态
rather than completely create new states every time

73
00:03:55,060 --> 00:03:57,040
我们想要做一个转变 
we want to make a transition.

74
00:03:57,040 --> 00:03:58,860
我们将讨论基于转弯的系统 
We'll be talking about turn based systems.

75
00:03:58,860 --> 00:04:02,970
所以像精灵宝可梦和其他RPG一样 在那里
So an RPGs like Pokemon and others, there

76
00:04:02,970 --> 00:04:06,210
通常是战斗系统 通常是
are often battle systems that are usually

77
00:04:06,210 --> 00:04:09,090
在你打斗的这一特定类型中转身--你有
turn based in this particular genre where you're fighting-- you have

78
00:04:09,090 --> 00:04:11,605
一支球队或一个角色与另一支球队或另一支球队或另一支球队作战
one team or one character fighting against against one other team or one

79
00:04:11,605 --> 00:04:13,980
其他角色 你们轮流打架 
other character, and you take turns fighting each other.

80
00:04:13,980 --> 00:04:16,846
你有无限的时间来做决定
And you have an indefinite amount of time to make your decision

81
00:04:16,846 --> 00:04:18,720
然后形成某种战略 关于如何
and then form some sort of strategy as to how

82
00:04:18,720 --> 00:04:20,490
你想要解决这个问题 
you want to approach the problem.

83
00:04:20,490 --> 00:04:23,340
我们将看到一个非常原始的基于转弯的系统 
We'll be taking a look at a very primitive turn based system,

84
00:04:23,340 --> 00:04:26,610
但今天是一个功能齐全的系统 
but a fully functional one today.

85
00:04:26,610 --> 00:04:32,250
这一类型的另一个重要方面是图形用户界面或图形用户界面
Another huge aspect of this genre is graphical user interfaces or GUIs

86
00:04:32,250 --> 00:04:33,510
因为它们被缩短了 
as they're shortened.

87
00:04:33,510 --> 00:04:37,740
面板、滚动条、文本框和菜单等
Things like panels, and scroll bars, and text boxes, and menus, all

88
00:04:37,740 --> 00:04:42,270
这类东西让我们可以更直观地看到
sorts of these things that allow us to get a more visual sort of look

89
00:04:42,270 --> 00:04:46,680
 并使我们能够更好地驾驭更复杂的游戏生态系统
at our data, and allow us to navigate a much more complex game ecosystem more

90
00:04:46,680 --> 00:04:47,670
效率很高 
efficiently.

91
00:04:47,670 --> 00:04:50,820
为了把这一切联系在一起 RPG的机械师 
And to tie it all together, RPG mechanics at large,

92
00:04:50,820 --> 00:04:53,700
我们将考虑升级和体验等内容
we'll be looking at things like leveling up and experience

93
00:04:53,700 --> 00:04:57,720
以及如何计算一方对另一方造成的损害
and how to calculate the damage that one party does to the other party

94
00:04:57,720 --> 00:04:59,810
在战斗的整个过程中 
throughout the course of a battle.

95
00:04:59,810 --> 00:05:04,170
因此 这将是一组相当复杂的例子 
And so it will be a fairly complicated set of examples,

96
00:05:04,170 --> 00:05:08,580
但作为一个整体 它相当说明了这一流派 
but fairly illustrative of the genre as a whole.

97
00:05:08,580 --> 00:05:11,790
所以我想演示一下我放在一起的例子 
So I'd like to demonstrate sort of the example that I put together.

98
00:05:11,790 --> 00:05:15,040
如果我能从观众中找个志愿者过来看看的话 
If I could get a volunteer from the audience to come up and take a look.

99
00:05:15,040 --> 00:05:18,120
托尼 那太棒了 太感谢你了 
Tony that'd be awesome, thank you so much.

100
00:05:18,120 --> 00:05:23,850
这就是我简单但功能齐全的精灵宝可梦的演示 
So this is my simple but fully featured, more or less, demonstration of Pokemon.

101
00:05:23,850 --> 00:05:27,760
所以如果你想进入或返回 
So if you want to enter or return.

102
00:05:27,760 --> 00:05:29,630
所以这是一个
So this is a--

103
00:05:29,630 --> 00:05:30,930
所以这里我们有一个
so here we have a--

104
00:05:30,930 --> 00:05:35,040
我们可以马上看到 我们有一个文本框和一个播放状态 
we can see right off the bat, we have a text box and a play state

105
00:05:35,040 --> 00:05:36,340
就像我们以前那样
like we did before.

106
00:05:36,340 --> 00:05:41,034
所以这个文本框实际上是一个在地方之上的状态 
So this text box is actually a state that's layered above the place.

107
00:05:41,034 --> 00:05:43,950
所以你可以看到它有一些说明 如果你想按P 
So you can see it has some instructions about, if you want to press P,

108
00:05:43,950 --> 00:05:45,120
你可以治愈你的口袋妖怪
you can heal your Pokemon.

109
00:05:45,120 --> 00:05:46,730
您可以按Enter键取消 
You can press Enter to dismiss.

110
00:05:46,730 --> 00:05:47,880
如果你继续按回车键 
So if you go ahead and press Enter, you'll

111
00:05:47,880 --> 00:05:49,620
现在能够真正移动了 
be able to actually move around now.

112
00:05:49,620 --> 00:05:52,500
需要注意的是 输入实际上
And so something to note is before, input was actually

113
00:05:52,500 --> 00:05:57,060
当对话在屏幕顶部时停止播放状态 
halted while the dialogue was on the top of the screen for the play state.

114
00:05:57,060 --> 00:06:01,110
你实际上不允许访问或更新这个底部状态 
You're actually not allowed to access or update this bottom state,

115
00:06:01,110 --> 00:06:05,220
因为状态堆栈只允许输入到顶部状态 
because the state stack is only allowing input to the top state.

116
00:06:05,220 --> 00:06:09,990
所以我把这个游戏限制在这个盒子里 
And so I have limited the play here just to this box,

117
00:06:09,990 --> 00:06:13,830
但如果我们在这里的高草中行走 在口袋妖怪里 
but if we walk in the tall grass down here, in Pokemon,

118
00:06:13,830 --> 00:06:15,630
为了真正开始一次邂逅
in order to actually initiate an encounter

119
00:06:15,630 --> 00:06:19,554
与另一个口袋妖怪或另一个野生口袋妖怪 你走在草地上 
with another Pokemon or another wild Pokemon, you walk in the grass.

120
00:06:19,554 --> 00:06:20,970
我们在草地上走了一圈 
So here we've walked in the grass.

121
00:06:20,970 --> 00:06:25,500
这种情况发生的概率是随机的 有十分之一的概率
There's a random chance for this to happen, there's a 1 in 10 chance

122
00:06:25,500 --> 00:06:26,370
基本上
basically.

123
00:06:26,370 --> 00:06:28,310
原来是说有野竹子出现了 
So it's saying that a wild Bamboon appeared.

124
00:06:28,310 --> 00:06:29,550
一个野生动物出现了 
So a wild creature appeared.

125
00:06:29,550 --> 00:06:32,550
他是5级 我们是5级 应该是一个相当公平的战斗 
He's level 5, we're level 5, should be a fairly even battle.

126
00:06:32,550 --> 00:06:34,982
你可以按回车键 它会说开始
So you can press Enter, and it will say go

127
00:06:34,982 --> 00:06:37,440
你的口袋妖怪的名字 在这个例子中是一个Aardart 
the name of your Pokemon, which is an Aardart in this case,

128
00:06:37,440 --> 00:06:39,410
现在是随机分配的
and it's randomly allocated at the moment.

129
00:06:39,410 --> 00:06:41,160
所以再按一次回车键 
So go ahead and press Enter one more time.

130
00:06:41,160 --> 00:06:43,360
现在我们可以看到右下角 我们有一个菜单 
Now we can see on the bottom right, we have a menu.

131
00:06:43,360 --> 00:06:46,290
所以我们要么战斗要么逃跑 这两个选择 
So we can fight or we can run, so those two choices.

132
00:06:46,290 --> 00:06:47,686
所以我们可以继续战斗 
So we can go ahead and fight.

133
00:06:47,686 --> 00:06:49,560
所以我们战斗 谁的口袋妖怪更高
So we fight, whichever Pokemon has the higher

134
00:06:49,560 --> 00:06:51,900
速度是第一位的 会造成伤害 
speed will go first and do damage.

135
00:06:51,900 --> 00:06:55,287
很明显 我们造成的伤害更大 但他的速度更快 
We obviously, do a lot more damage, but he's a little bit faster,

136
00:06:55,287 --> 00:06:56,370
所以他会先来
so he's going to go first.

137
00:06:56,370 --> 00:06:57,453
所以我们再打一次 
So we fight one more time.

138
00:07:00,130 --> 00:07:03,050
我们应该能把他打晕 
We should be able to knock him out.

139
00:07:03,050 --> 00:07:06,252
所以一旦我们这样做了 我们就得到了胜利的信息 我们得到了胜利的歌曲 
So as soon as we do, we get a victory message, we get a victory song.

140
00:07:06,252 --> 00:07:08,460
如果我们按下回车键 
If we press Enter, we'll actually get some experience

141
00:07:08,460 --> 00:07:10,320
因为打败了那个敌人 
for defeating that enemy.

142
00:07:10,320 --> 00:07:12,837
所以我们有相当多的经验 我们有65个XP 
So we've got quite a bit of experience, we got 65 XP.

143
00:07:12,837 --> 00:07:15,420
在底部栏中 我们可以看到我们有所有这些图形用户界面元素 
In that bottom bar, we can see we have all these GUI elements,

144
00:07:15,420 --> 00:07:19,380
我们这里有一个面板 我们有文本框 我们有进度条 
we've got a panel here, we have text boxes, we have progress bars,

145
00:07:19,380 --> 00:07:24,360
所有这些部分结合在一起 给了我们某种基于回合的系统 
all these pieces are coming together to give us sort of this turn based system.

146
00:07:24,360 --> 00:07:27,420
所以在这之后 我们可能会升级 只是为了演示
And so after this, we may level up just to demonstrate

147
00:07:27,420 --> 00:07:31,803
水平 这是这个游戏的RPG机械学的一部分 
leveling, which is part of the RPG mechanic side of this game.

148
00:07:31,803 --> 00:07:34,960
所以我们必须再按一次 
So we have to press this one more time.

149
00:07:34,960 --> 00:07:35,770
我们做到了 非常完美 
We did, perfectly.

150
00:07:35,770 --> 00:07:36,970
所以他们升级了 
So they leveled up.

151
00:07:36,970 --> 00:07:44,300
现在我们是级别6 所以我们可以看到进度条上方的6发生了变化 
And so now we're level 6, so we can see the 6 changed above our progress bars.

152
00:07:44,300 --> 00:07:46,300
因此 现在每次都会变得更强大 
So now will be a little bit stronger every time.

153
00:07:46,300 --> 00:07:49,258
统计数据没有在这里显示 这实际上是作业的一部分
And the stats aren't shown here, it's actually a part of the assignment

154
00:07:49,258 --> 00:07:52,630
是创建一个菜单 它将实际显示您是如何升级的 
is to create a menu that will actually show you how you leveled up,

155
00:07:52,630 --> 00:07:54,550
实际增加的统计数据 
what stats actually increased.

156
00:07:54,550 --> 00:07:57,400
但在引擎盖下 在幕后 
But underneath the hood, behind the scenes,

157
00:07:57,400 --> 00:07:59,680
你实际上得到了统计数据的增长 
you actually are getting stat increases.

158
00:07:59,680 --> 00:08:03,250
所以在这里我们可以看到 如果我们的HP一直降到零 
And so here we can see that if we our HP goes all the way down to zero,

159
00:08:03,250 --> 00:08:04,090
我们晕倒了 
we faint.

160
00:08:04,090 --> 00:08:06,730
当我们昏倒时 屏幕不是褪色为白色
And when we faint, the screen instead of fading to white

161
00:08:06,730 --> 00:08:09,063
实际上会褪色为黑色 以说明区别
will actually fade to black to illustrate the difference

162
00:08:09,063 --> 00:08:11,040
在这两个转变之间 
between the two transitions.

163
00:08:11,040 --> 00:08:13,760
这样我们就可以无限期地玩下去 
And so that we can keep playing indefinitely,

164
00:08:13,760 --> 00:08:16,360
这个游戏会让你的精灵宝可梦完全恢复健康 
the game will restore your Pokemon back to full health.

165
00:08:16,360 --> 00:08:18,274
因此 这将永远持续下去 
And so this will go on forever.

166
00:08:18,274 --> 00:08:20,440
这实际上就是模拟器 它只是
This is effectively what the simulator is, it's just

167
00:08:20,440 --> 00:08:22,480
一系列简单的无休止的战斗 
a simple series of infinite battles.

168
00:08:22,480 --> 00:08:24,450
草丛中有随机的精灵宝可梦 
There are random Pokemon in the grass.

169
00:08:24,450 --> 00:08:27,880
你总共可以打五场比赛 
There's five total that you can fight.

170
00:08:27,880 --> 00:08:30,172
但构成这款游戏的所有核心要素都在这里 
But all the core pieces of what make the game are here.

171
00:08:30,172 --> 00:08:31,879
所以实际上 让我们也来演示一下跑步
So actually, let's illustrate running too

172
00:08:31,879 --> 00:08:34,850
如果您不介意的话 让我们看看有没有什么不同 
if you wouldn't mind, just so that we can see if there is a difference.

173
00:08:34,850 --> 00:08:37,710
所以我们真的可以逃走 然后在战斗中我们会在那里被切断 
So we can actually flee, and then battle we'll get cut short there.

174
00:08:37,710 --> 00:08:39,880
我们不会得到任何XP 我们不会晕倒 但我们仍然
We won't get any XP, we won't faint, but we still

175
00:08:39,880 --> 00:08:41,419
回到播放状态 
get taken back to the play state.

176
00:08:41,419 --> 00:08:43,090
这就是精灵宝可梦的演示 
So that's all for the Pokemon demo.

177
00:08:43,090 --> 00:08:45,925
非常感谢Tony前来演示它 
Thanks so much Tony for coming up to demo it.

178
00:08:45,925 --> 00:08:53,427
嗯 这里涉及到很多东西 但正如我们将看到的 
Well, there's a lot of pieces involved here, but as we will see,

179
00:08:53,427 --> 00:08:56,260
一旦我们实施了大量这样的基础性项目 
once we have a lot of these sort of foundational pieces implemented,

180
00:08:56,260 --> 00:09:00,040
开始对越来越多的这些进行分层并不是太困难
it's not too difficult to start layering more and more of these

181
00:09:00,040 --> 00:09:02,860
让游戏变得更加丰富 
onto the game to make it even more rich.

182
00:09:02,860 --> 00:09:05,562
事实上 我们的任务是--
In fact, the assignment is to--

183
00:09:05,562 --> 00:09:08,020
我们将在最后看到这一点 我将在最后回顾一下--
and we'll see this at the end, I'll recap this at the end--

184
00:09:08,020 --> 00:09:12,040
但作业的目标是让你实现一个菜单--
but the assignments goal is for you to implement a menu--

185
00:09:12,040 --> 00:09:16,300
类似于我们看到的显示战斗和逃跑的菜单--
similar to the menu that we saw where fight and run were shown--

186
00:09:16,300 --> 00:09:19,330
这将显示您的每个统计数据的当前统计数据 
that will show you what your current stat is for each of your stats,

187
00:09:19,330 --> 00:09:22,080
有进攻、防守、速度和你的HP 
there's attack, defense, speed, and your HP.

188
00:09:22,080 --> 00:09:25,960
它将显示您在升级前的状态 数量
It will show you what your stat is before leveling, the amount

189
00:09:25,960 --> 00:09:28,400
它将增加 然后是最终的金额 
that it will increase by, and then the final amount,

190
00:09:28,400 --> 00:09:31,570
这有点类似于实际的精灵宝可梦游戏的工作原理 
which is sort of similar to how the actual Pokemon games work,

191
00:09:31,570 --> 00:09:35,230
所以你可以看到 而不是仅仅看到 哦 我把我的级别从5增加到6 
so you can see rather than just seeing, oh I increased my level from 5 to 6,

192
00:09:35,230 --> 00:09:38,692
6到7 你可以看到 哦 我的力量从12增加到14 
6 to 7, you can see, oh, my strength increased from 12 to 14.

193
00:09:38,692 --> 00:09:41,650
我更强壮一点 我会在下一场比赛中造成更大的伤害
I'm a little bit stronger, I'm going to do more damage on the next play

194
00:09:41,650 --> 00:09:43,240
穿过 
through.

195
00:09:43,240 --> 00:09:47,080
所以我们的目标是 我们要看看场上的状态 比赛
So our goal here, we're going to take a look at the field state, the play

196
00:09:47,080 --> 00:09:49,190
状态和战斗状态 
state, and the battle state.

197
00:09:49,190 --> 00:09:53,370
在大多数这类游戏中都有一个常见的二分法 
And there's a common dichotomy in most of these sorts of games,

198
00:09:53,370 --> 00:09:55,930
无论是《最终幻想》、《寻龙诀》还是《精灵宝可梦》
be it Final Fantasy, or Dragon Quest, or Pokemon

199
00:09:55,930 --> 00:09:58,710
在有田野的地方 你在走来走去 
where there is a field, where you are walking around,

200
00:09:58,710 --> 00:10:02,440
你的角色与一个有NPC的游戏世界互动 穿过城镇 
you're character interacting with a game world with NPCs, going through towns,

201
00:10:02,440 --> 00:10:03,650
那你有什么 
and what have you.

202
00:10:03,650 --> 00:10:05,844
然后是战斗模式 一种战斗状态
And then a battle mode, sort of a battle state

203
00:10:05,844 --> 00:10:08,260
在那里你实际上是在与某种敌人作战 
where you're actually fighting against some sort of enemy,

204
00:10:08,260 --> 00:10:11,060
或一系列的敌人 一个党或一个单一的生物 
or a series of enemies, a party or a single creature.

205
00:10:11,060 --> 00:10:14,080
因此 我们实现了这两种方法的简单版本 以说明
And so we've implemented simple versions of both of these to illustrate

206
00:10:14,080 --> 00:10:17,770
以及它们之间的过渡 
and also the transitions between them.

207
00:10:17,770 --> 00:10:21,100
在我们开始之前 我想做另一种插头
Before we start, I want to make another sort of plug

208
00:10:21,100 --> 00:10:26,050
对于这本Howtomakeanrpg.com 这本书 我其实从中学到了很多
for this howtomakeanrpg.com, this book, I actually learned a lot from this

209
00:10:26,050 --> 00:10:28,510
以及在游戏开发环境中使用Lua 
and about using LUA in the context of game development.

210
00:10:28,510 --> 00:10:30,926
我在之前的一节课上提到了这一点 
And I pitched this I think in one of the earlier lectures,

211
00:10:30,926 --> 00:10:34,570
但如果你想更深入地研究其中的许多概念 
but if you want a deeper dive into a lot of these constructs,

212
00:10:34,570 --> 00:10:38,320
为了对你可能如何做一些事情有一个感觉 比如剪辑场景 
and to sort of get a sense for how you might do something like cut scenes,

213
00:10:38,320 --> 00:10:42,162
或者更复杂的战斗布局 更像是--
or more complicated battle layouts, and a lot more like--

214
00:10:42,162 --> 00:10:44,620
它深入到了很多令人惊叹的事情的细节中 
it goes into a lot of detail about a lot of awesome things,

215
00:10:44,620 --> 00:10:45,620
一定要去看看 
definitely check it out.

216
00:10:45,620 --> 00:10:49,060
它不是免费的 但如果你对这种类型感兴趣 就像我一样 
It's not free, but if you're interested in this genre, which I am,

217
00:10:49,060 --> 00:10:50,880
这绝对是值得的 
it's definitely worthwhile.

218
00:10:50,880 --> 00:10:53,350
这是我们将成为的精灵床单的样子
Here's what the sprite sheets look like that we'll be

219
00:10:53,350 --> 00:10:55,750
用于这种演示 
using for this sort of demonstration.

220
00:10:55,750 --> 00:10:58,586
除了精灵宝可梦 它们都是单独的纹理 
The Pokemon aside, which are individual textures.

221
00:10:58,586 --> 00:11:00,460
在这里 我们使用一个简单的精灵工作表 它
Here we're using a simple sprite sheet, which

222
00:11:00,460 --> 00:11:03,280
只有一堆瓷砖 大部分我们都没有用过 
just has a bunch of tiles, most of which we did not use.

223
00:11:03,280 --> 00:11:08,620
请注意 灌木丛和高高的草丛没有任何类型的背景 
Note that the bush, the tall grass is not on any sort of background.

224
00:11:08,620 --> 00:11:13,030
因此 我们需要分层 基本上
And therefore, we need to layer, basically

225
00:11:13,030 --> 00:11:17,260
有两个单独的瓷砖地图 而不是一个 我们上次没有做 
have two separate tile maps as opposed to one, which we didn't do last time.

226
00:11:17,260 --> 00:11:22,180
我们重复使用了塞尔达演讲中使用的精灵纸 
And we were reusing the sprite sheet that we used in the Zelda lecture.

227
00:11:22,180 --> 00:11:24,970
以前 我们用它来对付所有的敌人 骷髅 幽灵 
Before, we used it for all the enemies, the skeletons, ghosts,

228
00:11:24,970 --> 00:11:26,090
还有泥巴 等等 
and slimes, et cetera.

229
00:11:26,090 --> 00:11:28,750
但现在我们实际上是在它所包含的PC上使用它 
But now we're actually using it for the PCs that it contains.

230
00:11:28,750 --> 00:11:34,060
具体地说 就是这里的男性全国人大 这是我们的主角 
Specifically, just the male NPC here, which is our main character.

231
00:11:34,060 --> 00:11:37,870
我们在本课程中使用的基础类
The foundational class that we're using in this lecture

232
00:11:37,870 --> 00:11:42,130
其他的一切都围绕着它 让它发挥作用
that sort of everything else revolves around and makes this work

233
00:11:42,130 --> 00:11:44,170
是状态堆栈 
is the state stack.

234
00:11:44,170 --> 00:11:49,560
所以在此之前 我们拥有的是一个国家机器 对吧 
And so before, what we had was a state machine, right,

235
00:11:49,560 --> 00:11:51,530
我们一次只在一个州 
where we were in one state at a time.

236
00:11:51,530 --> 00:11:55,090
所以你几乎可以想象 我们这里有一个盒子 
So you can almost think of it like, we have a box here,

237
00:11:55,090 --> 00:11:57,190
而且它只有一个插座 
and it just has one socket.

238
00:11:57,190 --> 00:11:59,710
然后我们总是看着这个插座 
And then we're always looking at this one socket,

239
00:11:59,710 --> 00:12:02,350
无论是游戏状态 还是战斗状态 
whether it's the play state, or the battle state,

240
00:12:02,350 --> 00:12:05,500
或者某种形式的转变 
or a transition of some kind.

241
00:12:05,500 --> 00:12:08,710
现在我们正在过渡到这样的想法 相反 
And now we're transitioning into the idea of, instead,

242
00:12:08,710 --> 00:12:14,740
一次只能看到的一种状态 我们会把它堆叠起来 
of just one state that we can only see at once, we'll make it a stack.

243
00:12:14,740 --> 00:12:18,640
因此 我们可以做的是 不只是拥有一个 
And so what we can do with this is, rather than just having one,

244
00:12:18,640 --> 00:12:22,150
因此 我们可以一次呈现多个状态 对吗？
we can therefore render multiple states at a time, right?

245
00:12:22,150 --> 00:12:27,460
让我们假设这就像赛场 对 或者是比赛状态 
So let's say this is like the field, right, or the play state.

246
00:12:27,460 --> 00:12:31,540
也许这就像是一场对话 或者别的什么 对吗？
And then maybe this is like a dialogue, or something, right?

247
00:12:31,540 --> 00:12:34,680
就像我们以前在现场看到的那样 我们有一个文本框 
Like we saw before in the field, we had a text box.

248
00:12:34,680 --> 00:12:37,460
我们实际上可以把东西层层叠在一起 
We can actually layer things on top of each other.

249
00:12:37,460 --> 00:12:42,670
然后可能这就像是淡出 对 或者淡入 
And then maybe this is like a fade out, right, or a fade in.

250
00:12:42,670 --> 00:12:45,520
所以我们可以从播放状态开始 然后我们四处走动 
So we start with the play state maybe, and we're walking around,

251
00:12:45,520 --> 00:12:47,320
我们和鼻咽癌里的人互动 
and we interact with in NPC.

252
00:12:47,320 --> 00:12:50,590
不是将播放状态转换为对话状态 
Rather than transition the play state to a dialog state,

253
00:12:50,590 --> 00:12:55,360
在我们之前的模型中 这将完全消除播放状态 
which would, in our previous model, completely eliminate the play state,

254
00:12:55,360 --> 00:12:58,960
因为一次只有一种状态可能是活动的 
because there's only one state that could be active at a time.

255
00:12:58,960 --> 00:13:02,290
现在我们只需要呈现 无论堆栈中有多少个状态 
Now we just render, however many states we have in our stack,

256
00:13:02,290 --> 00:13:05,660
我们只是根据它们被弹出的顺序按顺序呈现它们 
we just render them sequentially based on the order that they were popped in.

257
00:13:05,660 --> 00:13:09,610
我们会先渲染这个 基本上是自下而上渲染 
We would rendered this first, we basically render from the bottom up.

258
00:13:09,610 --> 00:13:12,130
呈现播放状态 然后是对话 然后是淡入 
Render the play state, then the dialogue, then the fade in.

259
00:13:12,130 --> 00:13:15,421
这将产生一系列不同的事情的效果 
And this will have the effect of doing a whole bunch of different things, which

260
00:13:15,421 --> 00:13:17,410
我们将在发行版中看到 
we'll see in the distro.

261
00:13:17,410 --> 00:13:21,430
但我们真的只需要一次更新一个州 
But we only really ever need to update one state at a time,

262
00:13:21,430 --> 00:13:26,620
对 因为如果我们激活了播放状态和对话状态
right, because if we have the play state active and the dialog state active

263
00:13:26,620 --> 00:13:29,950
以及淡入状态活动 按此顺序 作为堆栈 
and the fade in state active, in this order, as a stack,

264
00:13:29,950 --> 00:13:33,886
是的 我们是在推动行动 为了得到一些东西
right, we were pushing the operation for pushing for getting something

265
00:13:33,886 --> 00:13:36,010
把它放到堆栈上称为推送 然后把它取出来
onto the stack is called a push, and getting it off

266
00:13:36,010 --> 00:13:38,140
如果不熟悉就被称为流行音乐 
is called a pop if unfamiliar.

267
00:13:38,140 --> 00:13:41,530
如果我们推动所有这些州前进 那么通常情况下 
If we're pushing all of these states on, then usually,

268
00:13:41,530 --> 00:13:44,654
我们只需要更新上面的内容 对吗？
we only need to update whatever's on top, right?

269
00:13:44,654 --> 00:13:46,570
例如 如果没有淡入 我们只有
If there's no fade in for example, and we only

270
00:13:46,570 --> 00:13:49,300
使对话状态处于活动状态 或对话和位置
have a dialog state active, or a dialogue and a place

271
00:13:49,300 --> 00:13:53,110
按照从上到下的顺序陈述 然后我们通常
state in that order top to bottom, then we usually

272
00:13:53,110 --> 00:13:55,782
我不想让他更新播放状态的情况 
don't want him update what's going on in the play state.

273
00:13:55,782 --> 00:13:58,240
我们只关心正在进行的对话 
We're only concerned with the dialogue that's taking place.

274
00:13:58,240 --> 00:14:00,050
我们只想让它接受输入 
We only want that to take input.

275
00:14:00,050 --> 00:14:02,050
当我们按空格键、Enter键或其他键时
And when we press Spacebar, Enter, or whatever

276
00:14:02,050 --> 00:14:06,340
按钮清除该对话框状态 我们将其弹出 对
button clears that dialog state, we pop it off, right,

277
00:14:06,340 --> 00:14:08,070
然后我们又回到了游戏状态 
and then we're back to the play state.

278
00:14:08,070 --> 00:14:10,810
那么我们只是在更新播放状态 
Then we're just updating the play state.

279
00:14:10,810 --> 00:14:14,649
因此能够更新最上面的内容 同时
And so being able to update just what's on top while

280
00:14:14,649 --> 00:14:16,690
能够渲染底部的所有东西 
being able to render everything that's on bottom.

281
00:14:16,690 --> 00:14:18,760
这并不适用于所有的博弈公式 
And this doesn't hold true for all game formulas,

282
00:14:18,760 --> 00:14:22,640
当然有一些游戏 你可以在其中进行对话和游戏状态
there's certainly some games where you can have a dialogue and a play state

283
00:14:22,640 --> 00:14:28,050
两者都得到了更新 但仍在使用某种状态堆栈 
both get updated, but that's still using a state stack of sorts,

284
00:14:28,050 --> 00:14:31,780
你只是在以一种自上而下的方式更新事物 
you're just then updating things in a top down way.

285
00:14:31,780 --> 00:14:35,530
但这让我们可以做各种各样的事情 比如过渡 
But this allows us to do all kinds of things like transitions,

286
00:14:35,530 --> 00:14:38,440
并保持--比如 我们有一个游戏状态
and preserving-- like for example, the fact that we have a play state

287
00:14:38,440 --> 00:14:40,840
我们可以在上面弹出一个战斗状态 
and we can pop a battle state on top of that,

288
00:14:40,840 --> 00:14:43,270
我们看不到它下面的游戏状态 
where we don't see the play state underneath it,

289
00:14:43,270 --> 00:14:45,577
我们只看到战斗状态 这一切都在更新 
we only see the battle state, and that's all updating.

290
00:14:45,577 --> 00:14:47,410
但如果我们打开战斗状态 我们就
But it is we pop the battle state off, we're

291
00:14:47,410 --> 00:14:49,510
就在我们刚刚处于游戏状态的地方 
right back where we just were in the play state.

292
00:14:49,510 --> 00:14:53,860
由于缺乏更好的词语 它从以前就保持了自己的状态 
It's preserved its state, for lack of a better word, from before.

293
00:14:53,860 --> 00:14:58,750
这是这个模型为我们提供的舒适的东西 
And this is something that this model affords us comfortably.

294
00:14:58,750 --> 00:15:01,120
所以这是某种程度上的基础课程
And so that's sort of the foundational class that's

295
00:15:01,120 --> 00:15:03,190
在这个发行版中实现 这将允许
implemented in this distro, which will allow

296
00:15:03,190 --> 00:15:06,080
让我们做各种很棒的事情 
us to do all kinds of awesome things.

297
00:15:06,080 --> 00:15:09,580
那么让我们继续下去 看看它是什么样子的 
So let's go ahead and take a look at what that looks like.

298
00:15:09,580 --> 00:15:11,500
我在这里打开了州堆栈 
I have state stack open here.

299
00:15:11,500 --> 00:15:15,460
所以状态堆栈在这里只有一组状态 
So state stack has just a set of states here.

300
00:15:18,430 --> 00:15:20,530
然后 当我们想要插入一个状态时 
And then whenever we want to insert a state,

301
00:15:20,530 --> 00:15:23,540
它将位于状态堆栈的末尾 
it's going to be at the end of the state stack.

302
00:15:23,540 --> 00:15:25,450
所以这将是最后一次--
So it's going to be whatever the last--

303
00:15:25,450 --> 00:15:28,990
因此 如果我们将其视为表格中的一系列州 
so if we're looking at it as a series of states in a table,

304
00:15:28,990 --> 00:15:31,870
它将是表中最后一个索引 
it'll be whatever the last index is in the table.

305
00:15:31,870 --> 00:15:35,530
这将是我们的 我们堆栈的顶部 
That will be our, the top of our stack.

306
00:15:35,530 --> 00:15:38,440
如果你愿意 你可以用相反的方式来实现这一点 
And you can implement this either way in reverse if you wanted to.

307
00:15:38,440 --> 00:15:44,890
只是更简单 因为你只需做一张简单的桌子 移走即可摆脱
It's just easier, because you can just do a simple table.remove to get rid

308
00:15:44,890 --> 00:15:45,490
在--
of the--

309
00:15:48,100 --> 00:15:52,420
表 删除该表以消除最后一个状态
table.remove on that table to get rid of the last state

310
00:15:52,420 --> 00:15:54,280
而不需要把所有的东西都搬回去 
without having to shift back everything.

311
00:15:54,280 --> 00:15:57,940
所以如果我们从第一个索引开始 你必须把所有的东西都移回去 
So if we did it starting at index one, you'd have to shift everything back.

312
00:15:57,940 --> 00:16:00,940
这也会有一点奇怪 因为你会从一个开始 
And it would also be a little bit weird, because you would start at one,

313
00:16:00,940 --> 00:16:03,070
然后事情就会向左转 
and then things would go left.

314
00:16:03,070 --> 00:16:07,690
但基本上 为了更新我们的最终状态 
But basically, in order to update whatever our end state is,

315
00:16:07,690 --> 00:16:13,870
我们只在#self.States执行操作 无论我们的状态堆栈有多大 
we just do at #self.states, which will be however large our state stack is,

316
00:16:13,870 --> 00:16:16,570
我们只是调用该状态的更新 
we just call update on that state.

317
00:16:16,570 --> 00:16:19,420
然后处理人工智能就在这里 尽管我们没有使用它 
And then process AI is here, although we're not using it.

318
00:16:19,420 --> 00:16:21,640
但如果你有人工智能 事情就会是一样的
But if you had AI, it would be the same thing

319
00:16:21,640 --> 00:16:26,950
基本上是对您所在州的人工智能的更新 
as basically an update for artificial intelligence for your state.

320
00:16:26,950 --> 00:16:29,500
而不是一次只呈现一种状态 
Rather than rendering just one state at a time,

321
00:16:29,500 --> 00:16:32,140
我们在这里迭代我们所有的状态
we iterate through all of our states here

322
00:16:32,140 --> 00:16:35,140
使用iPair 它将对它们进行数值迭代
using ipairs, which will iterate through them numerically

323
00:16:35,140 --> 00:16:38,230
从一开始一直到最后 
starting at one going to the end.

324
00:16:38,230 --> 00:16:41,410
所以我们调用istate 并对其进行自我状态呈现 
So we call for istate, and ipairs of self.state, render it,

325
00:16:41,410 --> 00:16:47,260
因此 这将使所有内容从前到后 或从下到上 
so that will render everything back to front, or bottom to top,

326
00:16:47,260 --> 00:16:49,060
并允许我们得到这个分层的外观
and allow us to get this layered look where

327
00:16:49,060 --> 00:16:51,268
例如 我们有一个游戏状态在下面进行 
we have a play state going on underneath for example,

328
00:16:51,268 --> 00:16:54,230
然后是上面的一段对话 
and then a dialogue on top.

329
00:16:54,230 --> 00:16:56,230
或者我们有一个战斗状态在最顶端 
Or we have a battle state going at the very top,

330
00:16:56,230 --> 00:16:59,410
也许战斗状态本身就推动了一场对话
and maybe that battle state itself pushes a dialogue

331
00:16:59,410 --> 00:17:02,230
状态到堆栈的顶部 或一堆其他状态 
state to the top of the stack, or a bunch of other states,

332
00:17:02,230 --> 00:17:05,410
一个过渡 你想要什么都行 
a transition, whatever you would like.

333
00:17:05,410 --> 00:17:08,290
要清除它 我们只需将表重置为空表 
To clear it, we just reset the table to an empty table.

334
00:17:08,290 --> 00:17:12,010
要推送状态 我们只需在该状态上执行插入操作 然后
To push a state, we just do an insert on that state, and then

335
00:17:12,010 --> 00:17:14,680
我们在该状态下调用Enter 
we call enter on that state.

336
00:17:14,680 --> 00:17:19,240
正如我们以前所做的 有点类似于状态机 当我们更改状态时 
As we did before, sort of similarly with state machine, when we changed a state,

337
00:17:19,240 --> 00:17:21,369
我们会对它调用Enter和Exit 但现在我们
we would call enter on it and exit, but now we're

338
00:17:21,369 --> 00:17:23,050
当我们按下时 只需按回车键 
just calling enter when we push.

339
00:17:23,050 --> 00:17:26,470
然后 我们所要做的就是在任何地方调用Exit
And then to pop, all we do is call exit on whatever

340
00:17:26,470 --> 00:17:30,460
最后一个状态在我们的状态堆栈中 然后
the last state is in our state stack, and then just

341
00:17:30,460 --> 00:17:32,650
对self.States调用Table.Remove 
call table.remove on self.states.

342
00:17:32,650 --> 00:17:36,790
默认情况下 当您在一个表上调用Table.Remove时 只需要一个表
And by default, when you call table.remove on a table, just a table

343
00:17:36,790 --> 00:17:40,930
没有其他参数 它将删除所有
with no other arguments, it'll remove whatever

344
00:17:40,930 --> 00:17:43,165
最后一个索引是该表的索引 
the last index is of that table.

345
00:17:43,165 --> 00:17:44,100
这说得通吗？
Does that makes sense?

346
00:17:44,100 --> 00:17:46,558
有没有人对状态堆栈的工作原理有任何疑问？
Anybody have any questions as to how the state stack works?

347
00:17:49,300 --> 00:17:51,650
好的 太棒了 
All right, awesome.

348
00:17:51,650 --> 00:17:56,700
那么让我们来看看开始状态 
So let's take a look then at the start state.

349
00:17:56,700 --> 00:17:59,980
这就是开始的日期 
So this is the start date.

350
00:18:03,850 --> 00:18:06,250
非常简单 我们只有几个文本标签 
Fairly simple, we just have a couple of text labels,

351
00:18:06,250 --> 00:18:10,690
然后我们有一个随机分配的从左到右的精灵 
and then we have just a randomly assigned sprite going left to right.

352
00:18:10,690 --> 00:18:14,724
我们认为我们是如何实现这场运动的？
How do we think we're achieving the movement?

353
00:18:14,724 --> 00:18:17,230
是的 定时器 然后我们就开始画画
Yep, timer.tween, and then we're just drawing

354
00:18:17,230 --> 00:18:19,840
一个椭圆形 对 很简单 
an ellipse, right, pretty simple.

355
00:18:19,840 --> 00:18:24,830
然后当我们按Enter键时 请注意转换 
And then when we press Enter, note the transition.

356
00:18:24,830 --> 00:18:31,140
请注意 有一个淡入淡出到白色 然后淡出到透明 
Notice that there's a fade to white, and then fade to transparent.

357
00:18:31,140 --> 00:18:34,850
所以如果我们回想起我们看第三场比赛的时候 我们是怎么做的 
And so if we recall from when we looked at match three, how do we do this,

358
00:18:34,850 --> 00:18:36,792
我们还记得吗？
do we remember?

359
00:18:36,792 --> 00:18:40,110
观众：[听不见]
AUDIENCE: [INAUDIBLE]

360
00:18:42,480 --> 00:18:44,930
演讲者1：没错 长方形存放在哪里？
SPEAKER 1: Exactly, and the rectangle was stored where?

361
00:18:50,090 --> 00:18:52,510
抱歉 对摄像机重复一遍 我们有一个长方形
Sorry, to repeat for the camera, we had a rectangle

362
00:18:52,510 --> 00:18:56,380
它充满了整个屏幕 我们只是在它的透明度之间补间 
that filled the entire screen, and we just tween the transparency for it,

363
00:18:56,380 --> 00:18:57,710
这是真的 
which is true.

364
00:18:57,710 --> 00:19:01,120
不过 之前存储在那里的矩形
The rectangle there before though was stored

365
00:19:01,120 --> 00:19:04,570
当时处于活动状态的状态 就像开始日期一样 
in whatever state was active at the time, which was like the start date,

366
00:19:04,570 --> 00:19:08,710
或者我认为开始游戏状态是它的名字 
or the I think begin game state was the name.

367
00:19:08,710 --> 00:19:13,450
在过渡过程中不一定相关的实际状态 
The actual state that wasn't necessarily relevant at the transition.

368
00:19:13,450 --> 00:19:18,130
但使用状态堆栈 我们实际上可以将这一想法分离 
But using a state stack, we can actually decouple this idea.

369
00:19:18,130 --> 00:19:21,580
我们可以采用过渡的概念 因为想象一下
We can take the concept of a transition, and because imagine

370
00:19:21,580 --> 00:19:24,567
如果我们想要在每个单独的州之间进行转换
if we wanted to make a transition between every single state

371
00:19:24,567 --> 00:19:25,900
在我们的游戏中存在的东西 对吗？
that existed in our game, right?

372
00:19:25,900 --> 00:19:28,233
如果我们想从战场过渡到战场 
If we wanted to transition from the battle to the field,

373
00:19:28,233 --> 00:19:33,340
或者战场 或者任何我们可能想要的东西 比如开始
or the field to the battle, or whatever else we might want, like the start

374
00:19:33,340 --> 00:19:36,820
到场上 我们需要在每一块中都有一个矩形
to the field, we would need a rectangle in every single one

375
00:19:36,820 --> 00:19:39,580
我们正在跟踪的那些具有不透明性的 
of those that has an opacity that we're keeping track of.

376
00:19:39,580 --> 00:19:44,500
这并不一定与该州的目的密切相关 对吗？
And that's not necessarily germane to the purpose of that state, right?

377
00:19:44,500 --> 00:19:47,380
因此 因为我们现在有一个状态堆栈 所以我们实际上可以
So because we now have a state stack, we can actually

378
00:19:47,380 --> 00:19:52,870
抽象出这个过渡的概念 并把它变成自己的状态 
abstract out this idea of a transition, and turn it into its own state.

379
00:19:52,870 --> 00:19:56,230
我们可以有一个过渡态 
We can have a transition state.

380
00:19:56,230 --> 00:19:59,470
回想一下 因为我们只是将所有东西分层
And recall that since we're just layering everything

381
00:19:59,470 --> 00:20:03,130
[?关闭？]所有这些状态 我们正在按顺序呈现它们 
[? off ?] all these states, and we're rendering them sequentially,

382
00:20:03,130 --> 00:20:07,840
具有自己的状态 例如 不透明矩形 
having a state that possesses it's own for example, opacity rectangle,

383
00:20:07,840 --> 00:20:12,080
我们可以分层 把它压到堆栈上 然后渲染它 
we can just layer that, push that onto the stack, and render that,

384
00:20:12,080 --> 00:20:16,160
它会给我们带来这种转变的错觉 
and it'll give us the illusion of having this transition.

385
00:20:16,160 --> 00:20:19,000
但我们实际上不需要让它成为国家的一部分
But we don't need to actually have it be part of the state

386
00:20:19,000 --> 00:20:21,380
我们正试图过渡出和进入的地方 
that we're trying to transition out of and into.

387
00:20:21,380 --> 00:20:23,720
这说得通吗？
Does that make sense?

388
00:20:23,720 --> 00:20:27,469
那么让我们来看看 举个例子 
So let's take a look, for example, at the--

389
00:20:27,469 --> 00:20:29,260
我们先来看看开始状态 
let's take a look at the start state first,

390
00:20:29,260 --> 00:20:32,920
只是为了让我们看看这是从哪里开始的 
just so we can see where that actually gets kicked off.

391
00:20:32,920 --> 00:20:36,160
所以开始状态 我们开始一些音乐 我们有一个精灵 
So the start state, we kick off some music, we have a sprite,

392
00:20:36,160 --> 00:20:37,210
还有一个精灵x和y 
and a sprite x and y.

393
00:20:37,210 --> 00:20:40,570
实际上 这些值与正在移动的精灵有关 
These are values that are relevant to the sprite that's moving, actually,

394
00:20:40,570 --> 00:20:43,089
我们只有一个精灵从左向右移动 
we only have one sprite ever moving left to right.

395
00:20:43,089 --> 00:20:45,380
它只是被传送到屏幕的右边
It just gets teleported to the right edge of the screen

396
00:20:45,380 --> 00:20:47,620
一旦它被带到一边 
as soon as it gets taken to one edge.

397
00:20:47,620 --> 00:20:51,340
所以我们只有一个精灵 一个x和y 
So we only have one sprite, one x and y.

398
00:20:51,340 --> 00:20:53,440
然后每隔三秒 就像我们在这里看到的那样 
And then every three seconds as we see here,

399
00:20:53,440 --> 00:20:59,890
我们有一个回调函数 它将补间精灵x到负64
we have a callback function that will tween the sprites x to negative 64

400
00:20:59,890 --> 00:21:03,370
超过0.2秒 真的很快 
over 0.2 seconds, so really quickly.

401
00:21:03,370 --> 00:21:06,190
然后在完成后 将其传送到右侧 
And then on finish, teleport it to the right.

402
00:21:06,190 --> 00:21:08,380
然后做同样的事情 但在它之间
And then do the same exact thing, but tween it

403
00:21:08,380 --> 00:21:11,170
在0.2秒内到达中心 
to the center over 0.2 seconds.

404
00:21:11,170 --> 00:21:18,190
然后我们一按Enter或Return键 请注意 
And then as soon as we press Enter or Return, note this here,

405
00:21:18,190 --> 00:21:22,960
我们有gStateStack 而不再是gStateMachine 
we have gStateStack, not a gStateMachine anymore,

406
00:21:22,960 --> 00:21:27,490
我们正在推动它在州内逐渐淡出 
and we're pushing on to it a fade in state,

407
00:21:27,490 --> 00:21:32,170
它接受一个RGB、一个持续时间和一个回调函数 
which takes an RGB, a duration, and a callback function.

408
00:21:32,170 --> 00:21:38,080
现在 如果你看看main.lua 这是相关的 
Now if you look at main.lua, this is relevant,

409
00:21:38,080 --> 00:21:42,790
因为现在我们不再有状态机了 对吗？
because now we no longer have a state machine, right?

410
00:21:42,790 --> 00:21:45,670
我们之前有一个全局状态机gStateMachine 
We previously had a global state machine, gStateMachine.

411
00:21:45,670 --> 00:21:49,450
我们会给它一个进入函数、匿名函数的索引列表 
We would give it a list of indexes into functions, anonymous functions.

412
00:21:49,450 --> 00:21:53,150
它们将返回一个状态的实例化 
Those would return the instantiation of a state.

413
00:21:53,150 --> 00:21:55,885
然后 当我们调用Change时 状态机将
And then when we called change, the state machine will

414
00:21:55,885 --> 00:22:00,820
索引到其状态列表中 并调用匿名函数 
index into its list of states, and call that anonymous function,

415
00:22:00,820 --> 00:22:04,090
这将导致将状态改变为某种状态
which would have the result of changing the state to some state

416
00:22:04,090 --> 00:22:07,000
我们已经实现为一个类 对吧？
that we've implemented as a class, right?

417
00:22:07,000 --> 00:22:09,190
现在我们只需要创建一个状态栈 
Now we just create a state stack and we just

418
00:22:09,190 --> 00:22:14,320
将一个新的起始状态推送到类中 
push a new start state onto the class.

419
00:22:14,320 --> 00:22:18,220
所以这实际上是同样的事情 只是现在
And so what this will do is effectively the same thing, only now

420
00:22:18,220 --> 00:22:23,101
我们可以把事情放在开始状态 对吧 或者播放状态 
we can layer things onto the start state, right, or play state,

421
00:22:23,101 --> 00:22:25,850
或者任何我们想要的东西 我们永远也摆脱不了它 
or whatever we want to, and we're not going to ever get rid of it.

422
00:22:25,850 --> 00:22:28,250
我是说 我们可以摆脱它 但我们不需要 
I mean, we can get rid of it, but we don't have to.

423
00:22:28,250 --> 00:22:32,680
对于游戏状态 特别是 我们希望它几乎永远不会
For the play state, especially, we want that to pretty much never get

424
00:22:32,680 --> 00:22:35,260
从堆栈中弹出 因为
popped off the stack, because that's going

425
00:22:35,260 --> 00:22:36,960
保护我们所有的信息
to preserve all of our information.

426
00:22:36,960 --> 00:22:40,210
我们将回到默认状态来存储所有的角色信息 
We're going to default back to that to store all of our character information,

427
00:22:40,210 --> 00:22:43,210
我们的口袋妖怪信息 无论我们还能
our Pokemon information, whatever else we might

428
00:22:43,210 --> 00:22:46,690
想在这个游戏的外壳上添加一个库存 
want to add onto this shell of a game in inventory,

429
00:22:46,690 --> 00:22:49,360
等等 一个世界性的国家 
et cetera, a world state at large.

430
00:22:49,360 --> 00:22:53,140
我们希望保持这一点 并在我们所有的战斗中保持一致
We want to preserve that and keep that consistent across all of our battle

431
00:22:53,140 --> 00:22:54,580
国家等等 
states and so forth.

432
00:22:54,580 --> 00:22:58,060
战斗状态会从那个世界获取信息 
And the battle states will just pull information from that world,

433
00:22:58,060 --> 00:23:01,840
从游戏状态中 根据需要构建一场战斗 
from that play state, and construct a battle as needed.

434
00:23:01,840 --> 00:23:04,570
这有道理吗
Does that makes sense?

435
00:23:04,570 --> 00:23:08,590
好了 现在我们实际上是 我们对main做的唯一真正的更改
OK, so here we're effectively, the only real changes we've made to main

436
00:23:08,590 --> 00:23:11,790
不再是一个状态机 现在我们有一个状态栈 
are no longer a state machine, now we have a state stack,

437
00:23:11,790 --> 00:23:14,230
我们要推动启动状态 
going to push start state, that start state

438
00:23:14,230 --> 00:23:18,790
有一些行为 就像我们之前实现的任何其他状态一样 
has some behavior just like any other state that we've implemented before.

439
00:23:22,570 --> 00:23:29,560
我之前要讲的是起始状态的第36行 
And what I was about to get into before was here on line 36 of the start state,

440
00:23:29,560 --> 00:23:32,540
我们正在把另一个状态推入堆栈 
we're pushing another state onto the stack.

441
00:23:32,540 --> 00:23:36,951
所以已经有一个起始状态了 它是从起始状态本身内部
So there's already a start state, and it's from within the start state itself

442
00:23:36,951 --> 00:23:37,450
事实上
actually.

443
00:23:40,279 --> 00:23:42,820
我们要把这个堆栈 它只有一层深 
We're going to take that stack, which is just one level deep,

444
00:23:42,820 --> 00:23:44,560
现在我们要把它变成两层深 
and then we're going to make it two levels deep now.

445
00:23:44,560 --> 00:23:46,360
所以现在我们要添加一个淡入状态 
So now we're going to add a fade in state.

446
00:23:46,360 --> 00:23:49,270
我们可以看到 淡入状态是一个RGB 
And the fade in state as we can see, takes in an RGB.

447
00:23:49,270 --> 00:23:52,160
有没有人猜到RGB与什么有关？
Does anybody have a guess as to what the RGB is relevant for?

448
00:23:55,046 --> 00:23:58,425
观众：[听不见]
AUDIENCE: [INAUDIBLE]

449
00:23:58,425 --> 00:24:00,800
演讲者1：你想用黑色还是白色来淡出？
SPEAKER 1: To whether you want to fade in black or white?

450
00:24:00,800 --> 00:24:02,035
是的 任何颜色 
Yes, any color.

451
00:24:02,035 --> 00:24:04,660
如果我们愿意 我们可以把它变成红色 
We can make this, we can make it a fade to red if we wanted to,

452
00:24:04,660 --> 00:24:06,350
或褪色为蓝色 
or fade to blue.

453
00:24:06,350 --> 00:24:10,490
但我们不必为淡入淡出创建两个单独的类 
But we don't have to create two separate classes for a fade in white,

454
00:24:10,490 --> 00:24:13,850
淡入黑淡出黑淡出白
fade in black, fade out black, fade out white.

455
00:24:13,850 --> 00:24:16,760
我们可以给它一个颜色 
We can just give it a color.

456
00:24:16,760 --> 00:24:20,360
我的意思是 我们甚至可以更进一步 
And then I mean, we could even go a level further with this,

457
00:24:20,360 --> 00:24:23,960
并使其具有不透明性 这样我们就不需要淡入状态 
and make it take in an opacity as well, so that we don't need a fade in state,

458
00:24:23,960 --> 00:24:26,690
或者淡出状态 我们只需要一个淡出状态 对吧
or a fade out state, we just need a fade state, right?

459
00:24:26,690 --> 00:24:30,110
褪色状态将决定 基于任何
And the fade state will determine, based on whatever

460
00:24:30,110 --> 00:24:37,654
最后一个不透明度参数 我们给它 正确的方式淡入淡出 
last opacity parameter we give it, the right way to fade in and out.

461
00:24:37,654 --> 00:24:40,070
但在这种情况下 淡入状态
But in this case, the difference between the fade in state

462
00:24:40,070 --> 00:24:44,090
并且淡出状态是人们知道去到0 人们知道去到255 
and the fade out state is one knows to go to 0, one knows to go to 255.

463
00:24:44,090 --> 00:24:46,700
这是唯一的关键区别 
That's really the only key difference.

464
00:24:46,700 --> 00:24:51,830
然后这个1 持续时间 对 我们需要告诉它褪色多久 
And then this 1, the duration, right, we need to tell it how long to fade.

465
00:24:51,830 --> 00:24:55,610
最后一点是函数 
And then this last bit here is a function.

466
00:24:55,610 --> 00:24:59,960
我们给它一个匿名函数 这是一个回调函数 
We're giving it an anonymous function, this is a callback function,

467
00:24:59,960 --> 00:25:06,650
因为淡入状态本质上是异步状态 
because the fade in state by nature is an asynchronous state.

468
00:25:06,650 --> 00:25:08,480
它的行为会随着时间的推移而改变 
It does its behavior over time.

469
00:25:08,480 --> 00:25:10,940
所以我们需要一种方式 我们需要告诉它 好的 
So we need a way, we need to tell it, OK,

470
00:25:10,940 --> 00:25:14,360
当你完成了你正在做的事情 调用这段代码 
when you finished doing what you're doing, call this bit of code

471
00:25:14,360 --> 00:25:19,010
这样我们就可以做一些事情 而不是立即 
here, so that we can do something not immediately,

472
00:25:19,010 --> 00:25:22,250
我们可以推迟它的执行 
we can sort of defer its execution till later.

473
00:25:22,250 --> 00:25:26,910
这是我们在这节课中会看到的共同点 
And this is something that we'll see common throughout this lecture,

474
00:25:26,910 --> 00:25:29,870
因为我们也在类似的对话中实现了这一点 
because we have this implemented also in like dialogue for example,

475
00:25:29,870 --> 00:25:34,910
因为我们不知道用户什么时候会在对话框上按空格键
because we don't know when the user is going to press Spacebar on the dialog

476
00:25:34,910 --> 00:25:36,630
把窗户关上
state and clear the window.

477
00:25:36,630 --> 00:25:39,320
但如果我们想要那扇窗 想要清除对话
But what if we want that window, the clearing of that dialog

478
00:25:39,320 --> 00:25:41,690
引发某种事件对吧
to trigger some sort of event, right?

479
00:25:41,690 --> 00:25:44,830
例如 如果他们在战斗中按回车键 
For example, if they press Enter when they're in the battle,

480
00:25:44,830 --> 00:25:46,534
我们想让它进入下一个行动 
we want it to go to the next action.

481
00:25:46,534 --> 00:25:48,700
我们不一定知道它什么时候会发生 
We don't necessarily know when it's going to happen,

482
00:25:48,700 --> 00:25:54,770
所以我们只需要向对话状态传递一个匿名函数
so we'll just pass in an anonymous function to that dialogue state

483
00:25:54,770 --> 00:25:59,760
每当在该对话框上调用Close函数时 类都将调用
that the class will call whenever the close function is called on that dialog

484
00:25:59,760 --> 00:26:00,260
州政府 
state.

485
00:26:00,260 --> 00:26:03,170
它说 当关闭时 执行这个匿名函数 
It says, when closed, execute this anonymous function.

486
00:26:03,170 --> 00:26:06,320
然后那个匿名函数就可以做你想做的任何事情 
And then that anonymous function can do whatever you want to do.

487
00:26:06,320 --> 00:26:09,170
它可能会将其他几个状态弹出到堆栈上 
It could pop another other several states onto the stack.

488
00:26:09,170 --> 00:26:12,057
但这就是允许我们链接异步行为的原因 
But this is what allows us to chain asynchronous behavior.

489
00:26:12,057 --> 00:26:12,890
这是这里的关键 
That's the key here.

490
00:26:15,650 --> 00:26:18,800
所以这个匿名函数--所以我们现在来看一下
So this anonymous function-- so we'll take a look now actually

491
00:26:18,800 --> 00:26:23,340
在淡入状态 这样我们就可以看到这是什么样子的 
at the fade in state, just so we can see what this looks like.

492
00:26:23,340 --> 00:26:26,360
所以我们在这里看到 褪色状态 对 吸收颜色 
So we see here, fade in state, right, takes in the color.

493
00:26:26,360 --> 00:26:30,560
我们以前看到过 那将是我们褪色的颜色 
We saw before, that will be the color we fade to.

494
00:26:30,560 --> 00:26:34,580
我们实际执行转换所需的时间长度 
The length of time that it'll take us to actually perform the transition.

495
00:26:34,580 --> 00:26:46,390
我们用什么来过渡 我们认为 Timer Tweet 对吗？
And what are we using for the transition do we think, timer.tween, right?

496
00:26:46,390 --> 00:26:51,890
所以我们实际上要做的大部分事情
So most everything that we'll do actually

497
00:26:51,890 --> 00:26:55,150
在这堂课的整个过程中 都有异步行为 
throughout the course of this lecture that has asynchronous behavior,

498
00:26:55,150 --> 00:26:57,420
我们可以用定时器来实现它 这很好 
we can implement it with timer, which is nice.

499
00:26:57,420 --> 00:27:01,600
它允许我们相当简洁和声明地告诉
It allows us to fairly succinctly and declaratively tell

500
00:27:01,600 --> 00:27:04,670
准确地说出了我们希望随着时间的推移而发生的事情 
right out what exactly we want to have happen over time.

501
00:27:04,670 --> 00:27:07,930
在这种情况下 我们将在一段时间内
In this case, we're going to tween over the course of time

502
00:27:07,930 --> 00:27:11,840
把我们自己的不透明度提高到255 
the opacity of our self to 255.

503
00:27:11,840 --> 00:27:15,627
所以淡入会淡入我们所有东西的全色
So the fade in is going to fade into the full color of whatever we

504
00:27:15,627 --> 00:27:16,210
已经把它给了 
have given it.

505
00:27:16,210 --> 00:27:22,180
因此它将从0(默认情况下显示在这里)到255 
So it's going to go from 0, which is shown here by default, to 255.

506
00:27:22,180 --> 00:27:27,550
然后我们一拍完那个小插曲 
And then as soon as we finish that tween,

507
00:27:27,550 --> 00:27:32,740
这就是我们弹出淡入状态的时候 
that is when we pop the fade in state.

508
00:27:32,740 --> 00:27:35,920
我们将有效地把我们自己从州里跳出来 从堆栈中跳出来
We're going to pop ourselves off the state effectively, off the stack

509
00:27:35,920 --> 00:27:37,840
有效地 
effectively.

510
00:27:37,840 --> 00:27:41,150
然后在这里 我们呼吁淡出完成 
And then here, we're calling on fade complete.

511
00:27:41,150 --> 00:27:43,210
这就是匿名函数所在的位置 
And that's where the anonymous function is.

512
00:27:43,210 --> 00:27:45,430
在淡入淡出时 完成被传递到这里 
On fade complete is passed in here.

513
00:27:45,430 --> 00:27:52,630
因此 通过将该函数放入补间操作的结束函数中 
So by putting that function into the finish function of the tween operation,

514
00:27:52,630 --> 00:27:58,710
我们允许自己推迟我们在--中写的函数
we've allowed ourselves to defer that function that we've written up in the--

515
00:27:58,710 --> 00:28:01,120
它处于启动状态 
it's in the start state.

516
00:28:01,120 --> 00:28:04,750
我们将此函数的执行推迟到补间操作之后
We defer the execution of this function until after that tween operation

517
00:28:04,750 --> 00:28:05,700
发生了 
takes place.

518
00:28:05,700 --> 00:28:08,220
这说得通吗？
Does that make sense?

519
00:28:08,220 --> 00:28:09,764
好的 太棒了 
OK, awesome.

520
00:28:09,764 --> 00:28:11,180
这实际上就是它的本质 
And that's effectively what it is.

521
00:28:11,180 --> 00:28:13,970
这是一个共同的主题 如果你浏览一下发行版 我们会看到这一点 
And that's a common theme that we'll see if you're looking through the distro,

522
00:28:13,970 --> 00:28:15,620
你会在很多地方看到它 
you'll see it in a lot of places.

523
00:28:15,620 --> 00:28:17,870
匿名函数或回调函数
Anonymous functions or callback functions

524
00:28:17,870 --> 00:28:24,860
而是被传递到对话和淡出之类的东西中 
rather being passed into things like the dialogs, and the fades,

525
00:28:24,860 --> 00:28:26,747
还有其他几个地方 
and a few other places.

526
00:28:26,747 --> 00:28:28,580
例如 在轮流状态中 有
In the take turns state for example, there's

527
00:28:28,580 --> 00:28:30,920
也接受回调函数的函数 
a function that takes in at a callback function as well.

528
00:28:30,920 --> 00:28:38,210
这是您可以有效地链接异步行为的方式
And that's effectively how you can chain asynchronous behavior that

529
00:28:38,210 --> 00:28:41,105
随着时间的推移执行 而不是被阻塞 
executes over time, rather than it being blocking.

530
00:28:41,105 --> 00:28:44,630
到目前为止 有没有人对这是如何运作的有任何疑问？
Does anybody have any questions so far as to how this works, at all?

531
00:28:47,780 --> 00:28:51,980
好了 当淡入淡出后--
All right, so when the fade is done--

532
00:28:51,980 --> 00:28:54,440
我们仍然是这里的起点--
we're still the start state here--

533
00:28:54,440 --> 00:28:58,820
在这一点上 淡出完成 我们正在执行这个匿名函数 
at this point, the fade is done, we're executing this anonymous function.

534
00:28:58,820 --> 00:29:09,840
在本例中 我们将从堆栈中弹出Start状态 
We're going to pop the start state off of the stack in this case.

535
00:29:09,840 --> 00:29:12,570
然后我们要推动一个--
And then we're going to push a--

536
00:29:12,570 --> 00:29:15,780
我们要在这里做两个推力 
we're going to do two pushes here.

537
00:29:15,780 --> 00:29:20,960
一种是推动一种播放状态 这就是NPC[INAUDIBLE]
One is to push a play state, which recall is where the NPC [INAUDIBLE]

538
00:29:20,960 --> 00:29:23,210
走来走去的角色 
character walking around.

539
00:29:23,210 --> 00:29:27,294
还有一个就是推动对话状态 
And another one is to push a dialogue state.

540
00:29:27,294 --> 00:29:29,960
因此 这将产生的影响是 而不是我们
And so what this will have the effect of doing is rather than us

541
00:29:29,960 --> 00:29:33,150
立即进入玩耍状态 能够四处走动 
immediately going into the play state and being able to walk around,

542
00:29:33,150 --> 00:29:35,634
我们实际上置身于一个
we're actually put right into a world where

543
00:29:35,634 --> 00:29:37,550
有一条消息等着我们 我们有
there is a message waiting for us that we have

544
00:29:37,550 --> 00:29:40,640
按Enter On以继续 
to press Enter on in order to continue.

545
00:29:40,640 --> 00:29:45,230
当我们按回车键时 因为我们先按播放状态 
And when we press Enter, because we're pushing the play state first,

546
00:29:45,230 --> 00:29:47,410
然后是对话状态 对话状态
and then the dialogue state, the dialogue state

547
00:29:47,410 --> 00:29:49,670
在堆栈的顶部 对吧 因为
is at the top of the stack, right, because things

548
00:29:49,670 --> 00:29:53,060
就像一堆盘子一样被推上来 
get pushed onto like a stack of plates.

549
00:29:53,060 --> 00:29:56,150
你把一个游戏状态牌放在底部 然后在上面放另一个牌 
You put a play state plate on the bottom and then another plate on top,

550
00:29:56,150 --> 00:30:00,180
在这种情况下 这块板就是对话状态 
and that plate is the dialogue state in this case.

551
00:30:00,180 --> 00:30:02,330
而你只能与顶层互动--
And you can only interact with the top--

552
00:30:02,330 --> 00:30:06,290
在此型号中 我们一次只更新顶板 
we're only updating the top plate at once in this model.

553
00:30:06,290 --> 00:30:08,630
很明显 我们可以制造一个更复杂的状态
We could obviously make a more complicated state

554
00:30:08,630 --> 00:30:14,090
堆栈允许我们同时更新多层状态 
stack that allows us to have several layers of states being updated at once,

555
00:30:14,090 --> 00:30:19,940
但为了简单起见 我们只选择允许更新顶层 
but for simplicity, we only opted to allow the top layer to be updated.

556
00:30:19,940 --> 00:30:21,986
对话状态将是活动状态 
The dialog state is going to be the active state,

557
00:30:21,986 --> 00:30:23,360
它将接收输入 
it's going to be receiving input.

558
00:30:23,360 --> 00:30:25,930
它们都将被渲染 所以我们
All of them are going to be rendered, so we're

559
00:30:25,930 --> 00:30:27,680
要自下而上地渲染 
going to render things from the bottom up.

560
00:30:27,680 --> 00:30:28,940
我们将呈现播放状态 然后
We're going to render the play state, then

561
00:30:28,940 --> 00:30:31,010
我们将呈现对话状态 但对话状态的
we're going to render the dialog state, but the dialog state's

562
00:30:31,010 --> 00:30:31,910
会变得活跃起来 
going to be active.

563
00:30:31,910 --> 00:30:35,120
我们只能对该州的任何事情进行施压 
We're only going to be able to press anything on that state.

564
00:30:35,120 --> 00:30:40,550
最后 实际上 甚至超越了对话状态 
And then lastly, actually, even beyond the dialogue state,

565
00:30:40,550 --> 00:30:43,500
我们正在推动另一个州 我们正在推动一个淡出的州 
we're pushing another state, we're pushing a fade out state.

566
00:30:43,500 --> 00:30:47,150
在这种情况下 它与淡出状态相反 
And in this case, it's the opposite of the fade in state,

567
00:30:47,150 --> 00:30:51,170
它只需要一个RGB 我们将从255不透明度
it just takes in an RGB, and we'll go from 255 opacity

568
00:30:51,170 --> 00:30:54,180
在这种情况下为零不透明度 
to zero opacity in that case.

569
00:30:54,180 --> 00:31:00,470
因此 这使得我们能够做正确的事情 
And so what that allows us to do for playing right,

570
00:31:00,470 --> 00:31:03,320
我们现在处于开始状态 按Enter键 
we're here in the start state, pressing Enter.

571
00:31:03,320 --> 00:31:06,860
这就是我们在州里的淡出 
That's our fade in state was there.

572
00:31:06,860 --> 00:31:11,510
然后我们进入了游戏状态、对话状态和淡出状态
And then we pushed to the play state and the dialogue state and the fade

573
00:31:11,510 --> 00:31:15,440
所以你几乎会认为
out state at once, so you would almost think

574
00:31:15,440 --> 00:31:18,020
我们推入淡入 然后淡出 
that we push a fade in and then the fade out,

575
00:31:18,020 --> 00:31:21,560
但我们必须先奠定基础 然后才能
but we have to lay that foundation before we

576
00:31:21,560 --> 00:31:24,170
将淡出状态放在堆栈的顶部 
put the fade out state on top of the stack,

577
00:31:24,170 --> 00:31:27,720
对 因为最上面的层被更新了 
right, because the top layer gets updated.

578
00:31:27,720 --> 00:31:30,890
所以我们必须把淡出状态放在所有这些状态之上 
So we have to push the fade out state on top of all of those.

579
00:31:30,890 --> 00:31:32,797
它会被更新 会淡出 
That will get updated, that will fade out,

580
00:31:32,797 --> 00:31:34,880
然后我们回到我们推动的两个州
and then we're back to the two states that we push

581
00:31:34,880 --> 00:31:36,870
在我们推入淡出状态之前 
before we pushed the fadeout state.

582
00:31:36,870 --> 00:31:39,240
那是从那以后的事吗？
Does that make since?

583
00:31:39,240 --> 00:31:40,300
好的 
OK.

584
00:31:40,300 --> 00:31:44,710
有没有人对这种流动是如何运作的有任何疑问？
Does anybody have any questions as to how that sort of flow works?

585
00:31:44,710 --> 00:31:47,110
凉爽的 
Cool.

586
00:31:47,110 --> 00:31:49,510
好吧 这就是背后的主旨 我的意思是 
All right, so that's the gist behind, I mean,

587
00:31:49,510 --> 00:31:54,280
这基本上是我们今天所做的事情的核心
that's essentially the core of what we're doing today

588
00:31:54,280 --> 00:31:56,890
是推送多个状态的状态堆栈 
is the state stack pushing multiple states.

589
00:31:56,890 --> 00:31:58,940
然后只需弄清楚正确的顺序
And then just figuring out the right order

590
00:31:58,940 --> 00:32:02,710
需要把它们推进去才能得到你想要的外观 
the need to push them in to get the desired appearance that you want,

591
00:32:02,710 --> 00:32:03,340
对吗？
right?

592
00:32:03,340 --> 00:32:07,180
当我们处于开始状态时 我们按下淡出状态 
We push the fade out state while we're in the start state,

593
00:32:07,180 --> 00:32:08,430
或者更确切地说 是在状态中褪色 
or fade in state rather.

594
00:32:08,430 --> 00:32:10,990
这将把我们带到白色 然后像排序
That will take us to white, and then like sort

595
00:32:10,990 --> 00:32:17,440
几乎就像在幕后--在幕后 我们打开了一切 
of, almost like underneath the-- behind the curtain, we're popping everything,

596
00:32:17,440 --> 00:32:20,770
然后我们添加戏剧 对话 然后另一个淡出
and then we're adding the play, dialogue, and then another fade out

597
00:32:20,770 --> 00:32:21,380
州政府 
state.

598
00:32:21,380 --> 00:32:25,419
因此 你必须平衡你把东西放在一起的顺序
And so you sort of have to balance the order that you put things in in order

599
00:32:25,419 --> 00:32:26,710
以达到预期的效果 
to achieve the desired results.

600
00:32:26,710 --> 00:32:28,876
它不一定和你直觉上的一模一样
It may not necessarily be exactly as you intuitively

601
00:32:28,876 --> 00:32:32,110
想一想 直到你想到我们是如何更新和渲染的
think until you think about just how we're updating and rendering

602
00:32:32,110 --> 00:32:34,030
堆积如山的东西 
things on a stack.

603
00:32:34,030 --> 00:32:38,195
所以这是我认为真正感到舒适的终极障碍
And so that's the ultimate hurdle I think in really getting comfortable

604
00:32:38,195 --> 00:32:41,320
但一旦你得到了它 其他的一切都会下降
with the distro, but once you've gotten that, everything else sort of falls

605
00:32:41,320 --> 00:32:42,290
就位 
into place.

606
00:32:42,290 --> 00:32:46,600
以及丰富的异步函数 正如我们将介绍的
That and the sort of abundance of asynchronous functions, as we'll

607
00:32:46,600 --> 00:32:49,660
我们很快就会看到图形用户界面 以及我们是如何实现
see pretty shortly when we look at GUIs, and how we've implemented

608
00:32:49,660 --> 00:32:51,590
很多基本的图形用户界面功能 
a lot of basic GUI functionality.

609
00:32:51,590 --> 00:32:54,460
其中很大一部分是非常、非常受回拨驱动的 
A lot of that is very, very call back driven,

610
00:32:54,460 --> 00:32:58,012
只是因为它的本质是基于用户输入的 对吗？
just because of the nature of it being based on user input, right?

611
00:32:58,012 --> 00:33:00,220
你不知道用户什么时候会做任何输入 
You don't know when the user's going to do any input,

612
00:33:00,220 --> 00:33:04,240
因此 无论图形用户界面代码发生什么情况 请将其推迟
so defer whatever happens with that GUI code

613
00:33:04,240 --> 00:33:08,140
在用户按空格键时所涉及的触发器的情况下 
with the triggers involved when the user presses Spacebar,

614
00:33:08,140 --> 00:33:13,660
输入 然后调用已传递到该图形用户界面小部件中的函数 
Enter, and then call that function that you've passed into that GUI widget.

615
00:33:13,660 --> 00:33:17,020
好了 我们来看看状态堆栈 
All right, so we've taken a look at the state stack.

616
00:33:17,020 --> 00:33:20,270
我们已经看了开始状态 淡入状态 
We've taken a look at the start state, the fade in state,

617
00:33:20,270 --> 00:33:22,290
现在让我们来看看播放状态 
let's take a look now at the play state.

618
00:33:25,690 --> 00:33:26,624
所以游戏状态--
So the play state--

619
00:33:26,624 --> 00:33:28,540
这其中有很多实际上非常类似于
a lot of this is actually very similar to what

620
00:33:28,540 --> 00:33:35,080
我们回到了塞尔达 这是一款非常类似的自上而下的游戏 
we did back with Zelda, which is a very similar type of game top down.

621
00:33:35,080 --> 00:33:40,450
观点 唯一的区别是这种性质的RPG--
View, the only difference really with that was RPGs of this nature--

622
00:33:40,450 --> 00:33:42,730
《最终幻想》、《精灵宝可梦》、《寻龙诀》
Final Fantasy, Pokemon, Dragon Quest, they're

623
00:33:42,730 --> 00:33:47,110
平铺到你移动的均匀程度就是平铺 
tile based to the degree of even your movement is tile based.

624
00:33:47,110 --> 00:33:51,620
因此 我们在这堂课中努力实现了这一点 
And so we've striven to implement that with this lecture.

625
00:33:51,620 --> 00:33:57,340
所以当我们移动我们的球员 我们的角色时 
So when we move our player, our character,

626
00:33:57,340 --> 00:34:02,660
例如 它没有像塞尔达那样的自由运动 
it doesn't have free motion like we did with Zelda for example.

627
00:34:02,660 --> 00:34:03,950
所以我将演示这一点 
So I'll demonstrate this.

628
00:34:03,950 --> 00:34:07,360
所以我可以转到这里的场状态 播放状态 抱歉 
So I can go to the field state here, the play state, sorry.

629
00:34:07,360 --> 00:34:09,969
然后当我移动时 如果我按向右 他
And then when I move, if I press right, he

630
00:34:09,969 --> 00:34:13,850
以完美的栅格间隔朝该方向移动 
moves in that direction at a perfect grid interval.

631
00:34:13,850 --> 00:34:16,690
所以如果我往上走 我的手就会立刻离开 
So if I move up, I'm taking my hand instantly away,

632
00:34:16,690 --> 00:34:20,980
他将继续前进 他将坚守在这个网格上 
he's going to keep moving, and he's going to stick hard set to this grid.

633
00:34:20,980 --> 00:34:25,130
这只是这些游戏实现的一种趋势 
And that's just a sort of trend that these games have implemented.

634
00:34:25,130 --> 00:34:29,139
它允许您与网格保持完美一致 并帮助您
It allows you to stay perfectly aligned with the grid, and helps you

635
00:34:29,139 --> 00:34:30,800
我想某些游戏--
I guess certain game--

636
00:34:30,800 --> 00:34:33,429
我认为这可能不是严格意义上的
I don't think it's strictly necessary for probably

637
00:34:33,429 --> 00:34:37,239
大多数选择实现这一点的游戏 
most of the games that choose to implement this.

638
00:34:37,239 --> 00:34:41,500
我认为这是NES和GameBoy基于瓷砖的游戏的症状
I think it was a symptom of tile based games from the NES and Gameboy

639
00:34:41,500 --> 00:34:47,170
更易于设计和实现的时代 
era being easier to design and implement,

640
00:34:47,170 --> 00:34:51,699
因为它们是非常基于磁贴的系统 
because they're very tile based systems.

641
00:34:51,699 --> 00:34:55,030
但我的意思是 即使作为一种审美选择 我认为它也是有意义的 
But I mean, even as an aesthetic choice, I suppose it makes sense,

642
00:34:55,030 --> 00:34:57,472
因为一切都非常完美地排列在一起 
because everything aligns very perfectly.

643
00:34:57,472 --> 00:35:00,430
所以这就是这场比赛中球场状态的核心区别 
So that's the core difference really with the field state in this game.

644
00:35:00,430 --> 00:35:09,160
那么 我们如何着手实现这样的网格对齐移动系统呢
So how can we go about implementing a grid aligned movement system like this

645
00:35:09,160 --> 00:35:12,170
与我们的球员相比 我们在塞尔达是如何做到这一点的？
with our player relative to how we did it in Zelda for example?

646
00:35:16,690 --> 00:35:18,862
我们是怎么想的--当然 是吗？
How do we think-- sure yeah?

647
00:35:18,862 --> 00:35:23,200
观众：所以我们没有x和y 我们只有瓷砖的位置 
AUDIENCE: So we don't x and y's, we just have the tile positions.

648
00:35:23,200 --> 00:35:26,410
演讲者1：所以你没有x和y 我们只有平铺位置 
SPEAKER 1: So you don't have x and y's, we just have the tile positions.

649
00:35:26,410 --> 00:35:30,790
接近 我会说它更专注于瓷砖的位置 
Close, I would say it's more focused on the tile positions,

650
00:35:30,790 --> 00:35:33,790
但你仍然需要一个x和一个y 因为你仍然
but you still do need an x and a y, because you still

651
00:35:33,790 --> 00:35:37,142
需要在那个准确的位置画出那个精灵 
need to draw that sprite at that exact position.

652
00:35:37,142 --> 00:35:38,250
对吧 托尼？
Right, yes Tony?

653
00:35:38,250 --> 00:35:42,400
观众：嗯 当你需要移动精灵的时候
AUDIENCE: Well, when you need to move the sprite, instead

654
00:35:42,400 --> 00:35:47,080
每次更新时都会移动 在两个磁贴位置之间进行补间 
of moving at every update, you tween it between the two tile locations.

655
00:35:47,080 --> 00:35:51,680
演讲者1：完全正确 所以与其移动精灵
SPEAKER 1: Exactly, so rather than moving the sprite

656
00:35:51,680 --> 00:35:57,970
在每次更新的准确像素位置 您可以在收到输入时补间精灵
at exact pixel positions per update, you tween the sprite when you receive input

657
00:35:57,970 --> 00:35:59,950
到一个特定的位置 
to a specific location.

658
00:35:59,950 --> 00:36:02,780
然后我们实际上也在这一点上停止了输入 
And then we actually stop input at that point as well.

659
00:36:02,780 --> 00:36:08,020
当我们不完全处于给定的块时 我们没有任何输入的用处 
There's no use for us having any input when we're not exactly at a given tile,

660
00:36:08,020 --> 00:36:12,170
所以当他有效地行走时 我们禁用输入 
so we disable input while he's walking effectively.

661
00:36:12,170 --> 00:36:16,150
所以这是实现的 如果我们查看实体中的发行版
And so this is implemented, if we're looking at the distro in the entity

662
00:36:16,150 --> 00:36:19,318
同学们 这里有一个--
class, there is a--

663
00:36:19,318 --> 00:36:20,350
我相信它就在这里--
I believe it's in here--

664
00:36:24,660 --> 00:36:25,800
可能是玩家 等一下 
maybe player, hold on.

665
00:36:32,360 --> 00:36:35,030
哦 对不起 不是实体行走状态 不是实体 
Oh sorry, no it's entity walk state, not the entity.

666
00:36:35,030 --> 00:36:38,600
实体只是相关信息的容器 
Entity is just a container for the information that's relevant.

667
00:36:38,600 --> 00:36:42,510
因此 在实体漫游状态下 我们尝试移动 
So here in the entity walk state, we have attempt move.

668
00:36:42,510 --> 00:36:45,395
因此 尝试移动所做的基本上是
And so what attempt move does is essentially

669
00:36:45,395 --> 00:36:49,820
它看起来是为了确保我们在地图的范围内 对吗？
it looks to make sure that we're within the bounds of the map, right?

670
00:36:49,820 --> 00:36:51,970
然后 如果我们是--
And then if we are--

671
00:36:51,970 --> 00:36:56,917
这个游戏中的每个实体现在都有一个地图y和x 以及一个常规的y和x 
every entity in this game now has a map y and x, and a regular y and x.

672
00:36:56,917 --> 00:36:59,000
所以正规的y和x 我们仍然需要
And so the regular y and x, we still need in order

673
00:36:59,000 --> 00:37:01,880
在地图上的特定位置绘制我们的精灵 
to draw our sprite at a specific location on the map.

674
00:37:01,880 --> 00:37:09,320
我们仍然需要把它画在240多到230多之间 对吗？
We still need to draw it going between 240 something and 230 something, right?

675
00:37:09,320 --> 00:37:12,650
但我们需要一个地图x和一个地图y来表示 好的 
But we need a map x and a map y to basically say, OK,

676
00:37:12,650 --> 00:37:15,680
精灵应该在地图上的这个位置 
the sprite should be at this position on the map.

677
00:37:15,680 --> 00:37:19,220
然后我们就把它夹在位置乘以16之间 
And then we'll just tween it between that position times 16,

678
00:37:19,220 --> 00:37:22,610
这是位置加上或减去x或y
and it's the position plus or minus x or y

679
00:37:22,610 --> 00:37:26,000
乘以16 这将给出我们确切的x和y值
times 16, which will give us the exact x and y value that we

680
00:37:26,000 --> 00:37:27,480
需要把它画到地图上 
need to draw it onto the map.

681
00:37:27,480 --> 00:37:28,980
这就是我们在这里做的事情 
And so that's what we're doing here.

682
00:37:28,980 --> 00:37:32,630
因此 我们将在输入时调用尝试移动 
So were going to call attempt move on input.

683
00:37:32,630 --> 00:37:34,440
所以每当我们做任何输入时--
So anytime we do any input--

684
00:37:34,440 --> 00:37:39,950
这是在游戏者身上完成的 或者是游戏者 是的 游戏者
and this is done in the player like idle, or player, yeah, player

685
00:37:39,950 --> 00:37:41,900
闲置班级--
idle class--

686
00:37:41,900 --> 00:37:43,820
玩家空闲状态 
player idle state.

687
00:37:43,820 --> 00:37:46,520
我们将动画更改为编写动画 
We change the animation to write animation.

688
00:37:46,520 --> 00:37:48,710
然后我们得到了当前的地图x和y 
And then we get it's current map x and y.

689
00:37:48,710 --> 00:37:51,410
然后根据玩家所看的方向 
And then based on whatever direction the player is looking,

690
00:37:51,410 --> 00:37:56,720
或者实体正在寻找 我们可以将其用于NPC类或类似的类 
or the entity is looking, we could use this for an NPC class, or the like.

691
00:37:56,720 --> 00:37:59,870
我们只需修改2x和2y即可 
We just modify our 2x and 2y.

692
00:37:59,870 --> 00:38:04,390
因此 2x和2y将是我们向16倍递增的值 
So to 2x and 2y is going to be the value that we're tweening towards times 16,

693
00:38:04,390 --> 00:38:05,950
对吗？
right?

694
00:38:05,950 --> 00:38:10,940
因此 如果我们试图走出地图的边界 
And so if we're trying to go outside the map boundaries,

695
00:38:10,940 --> 00:38:13,340
仅仅将我们改回空闲状态不会让我们这样做 
just changing us back to idle won't let us do that.

696
00:38:13,340 --> 00:38:19,620
否则 立即将地图y和地图x设置到该位置 
Otherwise, set our map y and map x to that position immediately,

697
00:38:19,620 --> 00:38:22,880
对 因为这只是一个减或加一的运算 
right, because that's just a minus or plus one operation.

698
00:38:22,880 --> 00:38:28,010
然后在0.5秒的过程中 实际上是补间到那个值 
And then over the course of 0.5 seconds, actually tween to that value.

699
00:38:28,010 --> 00:38:30,770
我们可以在这里看到 我们正在调整到瓷砖的大小 
And we can see here, we're tweening to the tile size,

700
00:38:30,770 --> 00:38:35,212
实际上是瓷砖大小减去自身的整体高度除以2 
and actually to the tile size minus self.entity.height divided by 2.

701
00:38:35,212 --> 00:38:36,170
我们知道这是为什么吗？
Do we know why that is?

702
00:38:40,820 --> 00:38:45,385
我们这样做 是因为如果我们观察现场 我们可以在这里看到 
We do that, because if we're looking at the field, we can see here,

703
00:38:45,385 --> 00:38:48,010
注意到我们并没有和草地完美地排成一条线 对吗？
notice that we're not perfectly lined up with the grass, right?

704
00:38:48,010 --> 00:38:50,050
这有点像我们已经超过了它一半 
It's kind of like we're halfway above it,

705
00:38:50,050 --> 00:38:53,050
因为这样看起来更自然一点 
because it looks just a little bit more natural this way,

706
00:38:53,050 --> 00:38:54,967
这就是大多数游戏的样子 
this is how most sort of games look.

707
00:38:54,967 --> 00:38:56,800
如果你在这样的游戏中 你是
And if you're in a game like this and you're

708
00:38:56,800 --> 00:38:58,821
比如靠墙走 
like walking up against a wall for example,

709
00:38:58,821 --> 00:39:00,820
这会让你看起来像是
this will allow you to sort of look as if you're

710
00:39:00,820 --> 00:39:03,100
靠着墙 而不是某种
up against the wall rather than sort of being

711
00:39:03,100 --> 00:39:06,880
在墙底的边缘 看起来有点不自然 
at the edge of where the bottom of the wall is, and kind of looks unnatural.

712
00:39:06,880 --> 00:39:12,290
这就是为什么我们在那里减去一半的身高 
Hence why we minus 1/2 our height right there.

713
00:39:12,290 --> 00:39:15,910
然后当我们完成的时候 我们实际上
And then when we're finished, we actually

714
00:39:15,910 --> 00:39:18,770
测试我们是否仍在按某个键 如果是 
test to see whether we're still pressing a key, and if we are,

715
00:39:18,770 --> 00:39:20,710
然后将我们的状态改变为再次行走 这
then change our state to walk again, which

716
00:39:20,710 --> 00:39:24,727
我们将根据我们所关注的方向重复这个过程 
we'll just repeat this process depending on which direction we're looking at.

717
00:39:24,727 --> 00:39:25,810
实际上就是这样 
And that's effectively it.

718
00:39:25,810 --> 00:39:28,462
这就是我们能够得到这种基于网格的运动的原因 
And that's what allows us to get this grid based movement.

719
00:39:28,462 --> 00:39:29,920
对于这是如何工作的 有什么问题吗？
Any questions as to how this works?

720
00:39:33,280 --> 00:39:33,780
凉爽的 
Cool.

721
00:39:37,335 --> 00:39:43,200
让我们来看看比赛状态 让我们回到它 
Let's take a look then at the play state, let's go back to it.

722
00:39:43,200 --> 00:39:46,110
所以我们有一个级别 这个级别包含我们的实体 
So we have a level, the level contains our entity,

723
00:39:46,110 --> 00:39:49,394
它可以包含我们所有的实体 无论是什么
and it can contain all of our entities, and whatever

724
00:39:49,394 --> 00:39:50,685
您希望它包含的对象 
objects you want it to contain.

725
00:39:53,190 --> 00:39:55,530
在这种情况下 当我们也处于播放状态时 
In this case, when we're in the play state as well,

726
00:39:55,530 --> 00:39:57,279
我们要检查一下是否按P键 
we're going to check to see if we press P,

727
00:39:57,279 --> 00:39:59,820
因为这就是召回 我们可以治愈我们的精灵宝可梦 
because that's recall, where we can heal our Pokemon,

728
00:39:59,820 --> 00:40:05,410
只是一个小游戏黑客 只是为了让演示变得更容易一点 
just a little game hack just to make demoing it a little bit easier.

729
00:40:05,410 --> 00:40:11,800
但如果我们按下P键 我们就会播放治愈音 我们拿出我们的.
But if we press P, we play the heal sound, we take our--

730
00:40:11,800 --> 00:40:16,110
稍后我们会更详细地了解这一点 所有这些 
and we'll look a little bit more detail as to this, all this in a little bit.

731
00:40:16,110 --> 00:40:24,090
但邮箱：self.vel.player.pa rty.pokemon@index1.Currenthp
But self.level.player.pa rty.pokemon@index1.currenthp

732
00:40:24,090 --> 00:40:29,416
等于self.vel.player.party.pokemon@1.hp 
equals self.level.player.party.pokemon@1.hp.

733
00:40:29,416 --> 00:40:32,040
所以不同的是 目前的惠普是你目前拥有的一切 
So the difference is current HP is whatever you currently have,

734
00:40:32,040 --> 00:40:33,330
你可能会受到伤害 
you could have taken damage.

735
00:40:33,330 --> 00:40:35,730
无论你的最大生命值是多少 HP都是 
HP is whatever your max HP is.

736
00:40:35,730 --> 00:40:38,860
简而言之 这就是你如何获得
And this is like in a nutshell how you get

737
00:40:38,860 --> 00:40:44,820
比如在比赛和RPG中的状态变化 以及健康和MP的差异 
like stat changes in games and RPGs, and health and mp differences.

738
00:40:44,820 --> 00:40:48,577
你必须记录所有这些东西的最大值和当前值 
You've got to keep track of a max and a current value for all of those things,

739
00:40:48,577 --> 00:40:50,910
然后根据你是被抛光还是被调试 
and then depending on whether you're buffed or debugged,

740
00:40:50,910 --> 00:40:54,120
不管你是否受到了伤害 或者是否使用了咒语 
or whether you have taken damage or not, or used spells or not,

741
00:40:54,120 --> 00:40:56,610
你可以准确地反映出
you can have an accurate reflection of where

742
00:40:56,610 --> 00:41:01,350
你的角色是 然后总是回到那个状态
your character is and then always return back to that state

743
00:41:01,350 --> 00:41:03,420
当你需要的时候 
whenever you need to.

744
00:41:03,420 --> 00:41:06,570
这里有趣的是 稍微复杂一点的事情
The interesting thing here, the slightly more complicated thing

745
00:41:06,570 --> 00:41:10,350
当我们按P键时 我们想要显示一个对话框 上面写着 
is when we press P, we want to show a dialog that says,

746
00:41:10,350 --> 00:41:13,680
我将演示这一点 我们想显示一个对话框
and I'll demonstrate this, we want to show a dialog just

747
00:41:13,680 --> 00:41:18,120
就像这个上面说的 我们按下P键 你的精灵宝可梦就被治愈了 对吧？
like this one that says, we press P, your Pokemon has been healed, right?

748
00:41:18,120 --> 00:41:19,200
现在我动不了了 
Now I can't move.

749
00:41:19,200 --> 00:41:20,790
我在按箭头键 
I'm pressing the arrow keys.

750
00:41:20,790 --> 00:41:23,430
我根本不能移动我的角色 因为这个对话框说--
I can't move my character at all, because this dialog state--

751
00:41:23,430 --> 00:41:28,950
我们处于一个新状态 我们已经将一个新状态推送到状态堆栈中 
we're in a new state, well, we've pushed a new state onto the state stack.

752
00:41:28,950 --> 00:41:32,380
这就是这里的对话状态 它取了一个值 
And that's the dialog state here, which has taken a value.

753
00:41:32,380 --> 00:41:37,030
因为它是堆栈的顶层 所以它不能更新 
And because it's the top layer of the stack, it can't get updated,

754
00:41:37,030 --> 00:41:40,200
或者它正在更新 我们不能更新播放状态 对吧 
or it's being updated, and we can't update the play state, right,

755
00:41:40,200 --> 00:41:44,850
基于我们如何建模我们的州堆栈操作 或者它是如何工作的 
based on how we've modeled our state stacks operation, or how it works.

756
00:41:44,850 --> 00:41:47,970
然后我一按回车键 它就弹出来了 
And then as soon as I press Enter, it gets popped off,

757
00:41:47,970 --> 00:41:49,030
我们刚刚把它搞定了 
we've just popped it off.

758
00:41:49,030 --> 00:41:51,570
现在顶部的位置写着 我可以再次移动了 
Now the place states at the top, I can move again.

759
00:41:51,570 --> 00:41:52,740
这就是正在发生的事情 
So that's what's going on.

760
00:41:52,740 --> 00:42:02,700
因此 对话状态实际上在某种意义上非常类似于淡入淡出
So the dialog state then is actually very similar in a sense, to the fade

761
00:42:02,700 --> 00:42:06,450
进入和淡出状态 请注意 它接受一个匿名函数 
in and fade out state in that, notice that it takes an anonymous function.

762
00:42:06,450 --> 00:42:09,251
何时调用此匿名函数？
When does this anonymous function get called?

763
00:42:09,251 --> 00:42:09,750
我们知道吗？
Do we know?

764
00:42:12,750 --> 00:42:16,311
在什么结束的时候？
At the end of what?

765
00:42:16,311 --> 00:42:18,600
观众：[听不见]
AUDIENCE: [INAUDIBLE]

766
00:42:18,600 --> 00:42:24,790
演讲者1：是的 当用户关闭对话框时 正确 
SPEAKER 1: Yeah, well, when the user closes the dialog box, correct.

767
00:42:24,790 --> 00:42:27,800
那么 让我们来看看对话状态 
So let's take a look at the dialog state then.

768
00:42:27,800 --> 00:42:32,640
我们可以看到 它实际上很简单 很小 
And we can see, it's actually pretty simple, it's pretty small.

769
00:42:32,640 --> 00:42:36,480
我们有一条短信和一个回电 对吗？
We have a text that it takes and a callback, right?

770
00:42:36,480 --> 00:42:39,600
这里使用的是文本 
The text is used here.

771
00:42:39,600 --> 00:42:42,870
我们实例化 当我们开始研究图形用户界面时 我们将详细了解这一点 
We instantiate, and this we'll see in detail when we start looking at GUIs,

772
00:42:42,870 --> 00:42:45,450
以及他们在这里实现的所有窗口小部件 
and all the widgets they've implemented here.

773
00:42:45,450 --> 00:42:52,020
该文本框被放置在硬编码位置 并且它接收该文本 
This text box gets put at a hard coded position, and it receives this text.

774
00:42:52,020 --> 00:42:56,490
然后我们将self.call回调设置为该回调函数 
And then we set our self.callback to that callback function.

775
00:42:56,490 --> 00:43:00,630
如果我们关闭了文本框 这意味着我们将
If we have closed the text box, meaning, we're

776
00:43:00,630 --> 00:43:03,990
查看self.extbox.isClosed 其中
looking to see at self.textbox.isClosed, which

777
00:43:03,990 --> 00:43:07,080
是Text Box类的函数 
is a function of the text box class.

778
00:43:07,080 --> 00:43:12,660
如果它已关闭 则执行self.allback 然后弹出
If it's closed, then execute self.callback, and then pop

779
00:43:12,660 --> 00:43:15,870
堆栈的这个对话框状态 对吗？
this dialog state of the stack, right?

780
00:43:15,870 --> 00:43:19,710
所以这在某种意义上是相似的 淡入淡出 
So it's similar in a sense, to the fade in and fade out,

781
00:43:19,710 --> 00:43:21,430
然后它接受匿名函数 
and then it takes anonymous function.

782
00:43:21,430 --> 00:43:23,388
唯一的区别在于它是如何执行的 
The only difference is in how it gets executed.

783
00:43:23,388 --> 00:43:25,350
在淡入状态下 匿名函数
With the fade in state, the anonymous function

784
00:43:25,350 --> 00:43:28,160
在Finish函数结束时被调用 该函数
was called at the end of the finish function, which

785
00:43:28,160 --> 00:43:30,100
是补间对象的一部分 
is part of the tween object.

786
00:43:30,100 --> 00:43:33,840
在本例中 我们在以下情况下显式执行回调函数
In this case, we're executing the callback function explicitly when

787
00:43:33,840 --> 00:43:35,460
我们已关闭文本框 
we've closed the text box.

788
00:43:35,460 --> 00:43:40,440
因此 我们等待用户输入 而不是等待某个异步操作
So we're waiting for user input versus waiting for some asynchronous operation

789
00:43:40,440 --> 00:43:42,570
才能完成 
to finish.

790
00:43:42,570 --> 00:43:45,990
当然 我们称之为文本框呈现 
And then of course, we call text box render,

791
00:43:45,990 --> 00:43:49,566
然后 我们将很快看到所有这些方法都是这些小部件的一部分 
and then we'll see all of these methods shortly as part of these widgets,

792
00:43:49,566 --> 00:43:52,690
但乍一看 这就是对话状态真正发生的一切 
but at a glance, this is all that's really happening with the dialog state.

793
00:43:52,690 --> 00:43:55,980
非常简单 使用我们已有的相同模式
Very simple, using the same pattern that we've

794
00:43:55,980 --> 00:44:01,530
将未来的行为推迟到匿名函数 
seen of deferring future behavior to anonymous functions.

795
00:44:01,530 --> 00:44:07,025
关于这是如何运作的 或者到目前为止 有什么问题吗？
Any questions as to how this works, or anything so far?

796
00:44:07,025 --> 00:44:09,164
凉爽的 
Cool.

797
00:44:09,164 --> 00:44:11,330
好了 让我们来回顾一下比赛状态 
All right, let's take a look back at the play state,

798
00:44:11,330 --> 00:44:14,180
我相信我们快要完成比赛状态了 
I believe we're getting close to being finished with the play state.

799
00:44:14,180 --> 00:44:18,810
是的 所以一切 这基本上就是这个游戏中的游戏状态 
Yes, so everything, that's basically what the play state is in this game.

800
00:44:18,810 --> 00:44:22,170
然后 许多正在发生的事情也在一定程度上发生 
And then a lot of what's going on takes place in a level as well.

801
00:44:22,170 --> 00:44:29,000
所以简而言之 我们有两张地图 两层 对吧 
So in a nutshell, we have two maps, two layers, right,

802
00:44:29,000 --> 00:44:32,990
因为瓷砖上的草是它自己的一种[？字母？]
because the grass in the tile sheet is its own sort of [? alphaed ?]

803
00:44:32,990 --> 00:44:36,440
它的周围是透明的 
out object, it's got transparency around it.

804
00:44:36,440 --> 00:44:40,100
我们保留了一层基层 下面是一层草 
We keep a layer of the base, a layer of the grass underneath,

805
00:44:40,100 --> 00:44:43,610
然后是一个单独的高草层 
and then a separate layer for the tall grass.

806
00:44:43,610 --> 00:44:45,950
然后我们就可以看看
And then we can just look and to see when

807
00:44:45,950 --> 00:44:51,260
当我们走过高高的草地时 我们就进入了玩家步行状态 
we're walking in the player walk state when we've walked over tall grass.

808
00:44:51,260 --> 00:44:55,076
然后我们需要做什么来开始一个随机相遇？
And then what do we need to do to start a random encounter?

809
00:45:01,171 --> 00:45:01,670
- 是吗-是的
Yes?

810
00:45:01,670 --> 00:45:04,710
观众：[听不见]
AUDIENCE: [INAUDIBLE]

811
00:45:04,710 --> 00:45:07,040
主持人1：是的 我们是如何开始的？
SPEAKER 1: Yes, how do we initiated though?

812
00:45:07,040 --> 00:45:08,890
我们在找什么？
That what are we looking for?

813
00:45:08,890 --> 00:45:11,297
一旦触发战斗状态我们就会立即进入战斗状态 
We do push a battle state as soon as we've triggered one,

814
00:45:11,297 --> 00:45:12,380
但我们要怎么触发呢
but how do we trigger one?

815
00:45:12,380 --> 00:45:13,702
我们在找什么？
What are we looking for?

816
00:45:13,702 --> 00:45:17,750
观众：[听不见]球员在草地上 
AUDIENCE: [INAUDIBLE] player is in the grass.

817
00:45:17,750 --> 00:45:20,150
我不知道是不是因为要搬到新的草地上 
I don't know if it's on moving to a new grass,

818
00:45:20,150 --> 00:45:22,870
还是在草地上度过的时光
or if it's time spent in the grass.

819
00:45:22,870 --> 00:45:25,820
是的 我们做一个随机的机会 每当球员在草地上 
Yeah, we do a random chance whenever the players on grass.

820
00:45:25,820 --> 00:45:29,539
每当它们开始在草地上行走的时候 
And it's whenever they start to walk and there on grass in this case.

821
00:45:29,539 --> 00:45:31,330
但你可以用任何方式 你可以做到这一点
But you can do it either way, you can do it

822
00:45:31,330 --> 00:45:33,830
当他们离开草地 走进草地的时候
when they're leaving the grass, walking into the grass.

823
00:45:33,830 --> 00:45:35,871
在这种情况下 每当你按下按钮 
In this case, it's whenever you press the button,

824
00:45:35,871 --> 00:45:38,780
如果他们碰巧在草地上 它会随机选择 概率是十分之一
and they happen to be on grass, it'll do a random chance, one in 10.

825
00:45:38,780 --> 00:45:43,130
如果它等于1 10%的几率会触发遭遇战 
And if it's equal to 1, 10% chance it'll trigger an encounter.

826
00:45:43,130 --> 00:45:46,670
这就是触发随机遭遇的要点
So that's the gist behind triggering a random encounter,

827
00:45:46,670 --> 00:45:48,602
很多这样的游戏
and a lot of these games really--

828
00:45:48,602 --> 00:45:49,810
有些游戏是不同的 
some games do it differently.

829
00:45:49,810 --> 00:45:52,795
有时候你走得越多 
They'll sometimes make it more likely the more steps you've taken,

830
00:45:52,795 --> 00:45:55,670
他们会有一个计数器 说 哦 我走了100步 
they'll like sort of keep a counter to say, oh, I've taken 100 steps,

831
00:45:55,670 --> 00:45:57,680
现在应该更有可能了
it should be a lot more likely now.

832
00:45:57,680 --> 00:46:01,700
有些游戏是完全随机的 十分之一 五分之一 
Some games will just be completely random, 1 in 10, 1 in 5,

833
00:46:01,700 --> 00:46:05,210
这取决于开发者决定如何实现他们的游戏 
depending on how the developers decided to implement their game.

834
00:46:05,210 --> 00:46:08,540
前者更健壮一点 
The former is a bit more robust.

835
00:46:08,540 --> 00:46:11,750
但为了简单起见 我们只选择math.random10等于1 
But for simplicity, we just chose, math.random10 equals 1.

836
00:46:14,680 --> 00:46:19,410
所以 是的 我们在这里创建瓷砖地图 非常简单 
So yeah, we create the tile maps here, pretty straightforward.

837
00:46:19,410 --> 00:46:26,630
然后 实际的随机遭遇发生在玩家步行状态 
And then the actual random encountering takes place in the player walk state.

838
00:46:26,630 --> 00:46:29,570
所以这里我们检查了相遇 
So here we have check for encounter.

839
00:46:29,570 --> 00:46:33,800
当我们进入行走状态时 
And so what this does is whenever we enter the walk state, which

840
00:46:33,800 --> 00:46:37,650
我们是按下按钮进入 还是走进去 
is we press the button to enter, or to walk,

841
00:46:37,650 --> 00:46:40,190
调用整个函数 因为我们
this entire function gets called, because we

842
00:46:40,190 --> 00:46:43,160
在状态机中转换到玩家行走状态 
do the transition to the player walk state in the state machine.

843
00:46:43,160 --> 00:46:45,826
所有实体仍在使用常规状态机
All of the entities are still using just a regular state machine

844
00:46:45,826 --> 00:46:46,880
而不是状态堆栈 
not a state stack.

845
00:46:46,880 --> 00:46:49,400
并不是这次演示所必需的 尽管我确信
Wasn't necessary for this demonstration, though I'm sure

846
00:46:49,400 --> 00:46:52,879
有一些对实体使用状态堆栈的用例 
there are some used cases for using a state stack for an entity.

847
00:46:52,879 --> 00:46:55,170
在本例中 我们只使用常规状态机 
In this case, we're just using a regular state machine.

848
00:46:55,170 --> 00:46:59,360
因此 当我们更改为Walk状态时 我们将调用Enter 正如我们所看到的 
So when we change to the walk state, we are calling enter as we've seen.

849
00:46:59,360 --> 00:47:02,830
然后我们调用self check ForEncount 
And then we call self, checkForEncounter.

850
00:47:02,830 --> 00:47:07,340
因此 自己 check ForEncount将设置一个标志
And so self, checkForEncounter will set a flag

851
00:47:07,340 --> 00:47:14,290
如果我们基本上还没有开始一次遭遇 就会允许我们移动 
if we have not started an encounter basically and will allow us to move.

852
00:47:14,290 --> 00:47:17,525
如果我们已经检查了一次相遇 它会的 
And if we have checked for an encounter, it will,

853
00:47:17,525 --> 00:47:21,470
或者 如果我们触发了一次遭遇 它就会推入check ForEncount 
or if we have triggered an encounter, it will push in checkForEncounter,

854
00:47:21,470 --> 00:47:26,310
它实际上会将战斗状态推送到堆栈上 
it'll actually push a battle state onto the stack.

855
00:47:26,310 --> 00:47:30,900
所以check ForEncount基本上就是做我们之前说过的事情 
So checkForEncounter just basically does what we said before.

856
00:47:30,900 --> 00:47:34,957
如果是草层 因为我们有两层 
If the grass layer, because we have two layers,

857
00:47:34,957 --> 00:47:37,040
对 我们有基层和草层 
right, we have the base layer and the grass layer.

858
00:47:37,040 --> 00:47:43,760
因此 如果yx所在的yx处的层是实体map x和map y 
So if the layer at yx where yx is are entities map x and map y.

859
00:47:43,760 --> 00:47:46,610
如果它的ID等于高草 
If the ID of that is equal to tall grass,

860
00:47:46,610 --> 00:47:50,750
我们只有一个全局常量表 叫做
and we have just a global constant table called

861
00:47:50,750 --> 00:47:52,960
磁贴ID 其中包含所有这些ID 
Tile IDs, which has all these IDs.

862
00:47:52,960 --> 00:47:57,080
且math.随机性10等于1 OK 将实体状态改为空闲 
And math.random10 is equal to 1, OK, change the entity state to idle,

863
00:47:57,080 --> 00:48:00,500
所以不要让他们继续走下去 
so don't let them keep walking.

864
00:48:00,500 --> 00:48:02,645
暂停现场音乐 而不是停止 
Pause the field music rather than stopping,

865
00:48:02,645 --> 00:48:06,380
这样 当我们稍后回到赛场并按下Play键时 
so that way when we come back to the field later and we press play,

866
00:48:06,380 --> 00:48:09,980
它将处于与以前完全相同的位置 
it will be at the exact point that it was before.

867
00:48:09,980 --> 00:48:14,900
引发了战斗音乐 然后 我们已经看到了 在状态中褪色 
Triggered the battle music, and then, we've seen this already, fade in state,

868
00:48:14,900 --> 00:48:16,940
推送到堆栈 对吗？
push to the stack, right?

869
00:48:16,940 --> 00:48:19,945
所以超过一秒钟 我们就会褪色成白色 
So over one second, we're going to fade to white.

870
00:48:19,945 --> 00:48:22,070
所以这将会有音乐开始的效果 
So this will have the effect of the music starting,

871
00:48:22,070 --> 00:48:23,960
但我们马上就会褪色成白色 这
but we're fading to white right away, which

872
00:48:23,960 --> 00:48:27,785
与大多数RPG的操作方式非常相似 
is very sort of similar to how most RPGs do it.

873
00:48:27,785 --> 00:48:29,660
然后我们有我们的回调函数 它
And then we have our callback function, which

874
00:48:29,660 --> 00:48:32,720
会在淡入状态结束后立即执行 对吗？
will execute as soon as the fade in state's done, right?

875
00:48:32,720 --> 00:48:35,720
在这种情况下 推向战斗状态 
In this case, push to battle state.

876
00:48:35,720 --> 00:48:37,900
战斗状态需要一个实体 而实体
Battle state takes an entity, and the entity

877
00:48:37,900 --> 00:48:39,650
有我们所有的精灵宝可梦信息 那是
has all of our Pokemon information, that's

878
00:48:39,650 --> 00:48:41,710
为什么我们要让它进入战斗状态 
why we're passing that into the battle state.

879
00:48:41,710 --> 00:48:44,290
所以战斗状态可以说 哦 你有什么精灵宝可梦？
So the battle state can say, oh, what Pokemon do you have?

880
00:48:44,290 --> 00:48:49,010
好的 我会看着你的派对说 好的 你的第一个精灵宝可梦
OK, I'll be able to look at your party and say, OK, your first Pokemon

881
00:48:49,010 --> 00:48:52,520
这是不是把他送上战场 等等 对不对？
is this, send him out to battle, et cetera, right?

882
00:48:52,520 --> 00:48:56,180
最后 推入淡出状态 对
And then lastly, push a fade out state, right,

883
00:48:56,180 --> 00:49:02,570
因为现在我们已经将战斗状态置于播放状态之上 
because now we've got the battle state on top of the play state,

884
00:49:02,570 --> 00:49:05,260
但我们想淡入其中 对吗？
but we want to fade into it, right?

885
00:49:05,260 --> 00:49:08,180
所以我们将淡出 我们将把战斗状态放在第一位 
So we're going to fade, we're going to put the battle state first,

886
00:49:08,180 --> 00:49:10,820
然后因为我们使用的是堆栈 所以我们
and then because we're using a stack, we're

887
00:49:10,820 --> 00:49:14,450
把命运置于最上面的状态 然后淡出 
going to put the fate out state on top of that, and then fade out to that,

888
00:49:14,450 --> 00:49:15,990
把它从堆栈上弹出来 
pop that off the stack.

889
00:49:15,990 --> 00:49:19,760
然后我们就有了我们刚刚推动的战斗状态 对吗？
And then we have our battle state that we just pushed, right?

890
00:49:19,760 --> 00:49:21,760
然后是自己 遭遇基金会在这里设定 
And then self.encounterFound get's set here.

891
00:49:21,760 --> 00:49:25,130
这就是创造一次相遇 随机检查 
And that's creating an encounter, checking randomly,

892
00:49:25,130 --> 00:49:27,760
把正确的事情推到堆栈下 战斗状态 
pushing the right things under the stack, battle state,

893
00:49:27,760 --> 00:49:30,200
淡出状态 淡入 淡出 
fade state, fade in, fade out.

894
00:49:30,200 --> 00:49:32,900
然后你就可以走了 
And then you're set to go.

895
00:49:32,900 --> 00:49:35,400
所以这实际上就是--
So that's effectively what the--

896
00:49:35,400 --> 00:49:41,600
在RPG中 它被称为场对战斗或遭遇状态 
it's known in RPGs as the field versus the battle or encounter state.

897
00:49:41,600 --> 00:49:44,882
尽管我们在这里称之为Play State 但我们已经离开了赛场 
Even though we're calling it play state here, we've left the field,

898
00:49:44,882 --> 00:49:46,590
在这一点上 我们已经进入了战斗 
we've gone into the battle at this point.

899
00:49:46,590 --> 00:49:48,500
所以现在我们基本上已经看到了一切
And so now we've seen basically everything

900
00:49:48,500 --> 00:49:51,790
这个领域必须为我们提供 
that the field has to offer us.

901
00:49:51,790 --> 00:49:54,530
我们已经报道了所有与此相关的内容 
And we've covered everything that's relevant there.

902
00:49:54,530 --> 00:49:59,030
所以我们现在休息5到10分钟 
So we're going to take a break now for five to 10 minutes,

903
00:49:59,030 --> 00:50:01,980
当我们休息回来的时候 
and then when we get back from the break,

904
00:50:01,980 --> 00:50:04,640
我们将讨论图形用户界面元素、面板、文本框、
we'll talk about GUI elements, panels, text boxes,

905
00:50:04,640 --> 00:50:09,470
然后我们将深入研究战斗状态的那种机制 
and then we'll dive into the sort of mechanics of the battle state.

906
00:50:09,470 --> 00:50:12,600
好了 欢迎回到第七课 精灵宝可梦 
All right, welcome back to lecture 7, Pokemon.

907
00:50:12,600 --> 00:50:14,960
所以在休息之前 我们讨论了比赛状态 
So before the break, we talked about the play state,

908
00:50:14,960 --> 00:50:17,280
我们谈到了更重要的州堆栈 
we talked about the states stack more importantly,

909
00:50:17,280 --> 00:50:20,870
然后我们讨论了匿名函数是如何
and then we talked about how a anonymous functions are

910
00:50:20,870 --> 00:50:25,500
这是我们如何获得大量异步
sort of the backbone to how we get a lot of this asynchronous

911
00:50:25,500 --> 00:50:29,820
和延迟行为 这在RPG中很常见 
and deferred behavior for our game, which is very common in RPGs,

912
00:50:29,820 --> 00:50:34,550
我的意思是 很多类型 很多复杂的类型 
and I mean, a lot of genres, a lot of complicated genres of this sort.

913
00:50:34,550 --> 00:50:39,560
像这样的游戏的另一个重要部分是图形用户
Another big key part of games like this are the graphical user

914
00:50:39,560 --> 00:50:42,890
界面 或者简称为GUI 
interfaces, or GUIs as they're shortened to.

915
00:50:42,890 --> 00:50:46,550
像屏幕上的面板 标签之类的东西 
Things like panels on the screen, things like labels--

916
00:50:46,550 --> 00:50:53,880
可以移动的文本标签 比如列表 文本框 滚动条 
text labels that move around, things like lists, text boxes, scroll bars,

917
00:50:53,880 --> 00:50:56,150
你可以变得更疯狂
and you can get a lot crazier with it.

918
00:50:56,150 --> 00:51:03,140
在这节课里 我们主要讨论面板 标签 
In this particular lecture, we'll be talking mostly about panels, labels,

919
00:51:03,140 --> 00:51:05,870
文本框和滚动条
text boxes, and scroll bars--

920
00:51:05,870 --> 00:51:08,760
而不是滚动条 
progress bars rather, not scroll bars.

921
00:51:08,760 --> 00:51:12,220
但我认为第一个角落
But the sort of the first I think corner--

922
00:51:12,220 --> 00:51:17,000
或者第一种类似keystone的GUI小部件 
or the first sort of like keystone GUI widget

923
00:51:17,000 --> 00:51:21,410
我们应该考虑的是陪审团
that we should take into consideration is the panel.

924
00:51:21,410 --> 00:51:27,203
”““那是一个小组 听不见 
So a panel is [INAUDIBLE].

925
00:51:33,330 --> 00:51:41,680
如果我们把这个放在一个博弈中
So if we look at this in a game--

926
00:51:41,680 --> 00:51:44,500
就当这是一个面板吧
just pretend this is a panel I guess.

927
00:51:44,500 --> 00:51:47,710
所以这就是一个小组的全部 对吗？
So this is effectively all a panel is, right?

928
00:51:47,710 --> 00:51:49,960
它只是一个长方形 
It's just sort of a rectangle.

929
00:51:49,960 --> 00:51:54,107
它让我们可以--如果你在看大多数的用户界面 
It allows us to-- if you're looking at most user interfaces,

930
00:51:54,107 --> 00:51:56,440
比如屏幕上的文本框 或者你在Facebook上
like text boxes on your screen, or if you're on Facebook

931
00:51:56,440 --> 00:52:00,250
你看到的几乎是任何东西 比如你的小信息
and you're looking at almost anything, like your little message

932
00:52:00,250 --> 00:52:03,520
窗户 很多这些东西在最核心的地方 最底层 
window, a lot of those things at the very core, the very bottom,

933
00:52:03,520 --> 00:52:05,530
基础部分只是一个面板 
the foundational part is just a panel.

934
00:52:05,530 --> 00:52:11,023
那么 有没有人猜到在Love 2D中 我们如何制作一个简单的面板？
So any guesses to how in Love2D, we can make a simple panel?

935
00:52:11,023 --> 00:52:12,899
观众：两个不同颜色的长方形 
AUDIENCE: Two rectangles of different colors.

936
00:52:12,899 --> 00:52:14,814
两个不同颜色的长方形
SPEAKER 1: Two rectangles of different colors,

937
00:52:14,814 --> 00:52:16,360
这就是我们最终的结果
that's exactly what we end up doing.

938
00:52:16,360 --> 00:52:18,650
这就是我们制作面板的有效方法 
So that's effectively how we can make a panel.

939
00:52:18,650 --> 00:52:24,100
还有另一种制作面板的方法 但我们不会在这节课上做 
There's another way of making a panel, which we won't do in this lecture,

940
00:52:24,100 --> 00:52:26,530
但它叫做
but it's called--

941
00:52:26,530 --> 00:52:30,640
我们把它作为一个叫做九补丁的结构 
we use as a construct called a nine patch.

942
00:52:30,640 --> 00:52:37,240
所以九号补丁是...
So a nine patch is--

943
00:52:37,240 --> 00:52:41,000
想象一下这张小图片 它的大小任意 
imagine taking this little image here, and it's of some arbitrary size,

944
00:52:41,000 --> 00:52:42,704
但它很小
but it's very small.

945
00:52:42,704 --> 00:52:44,620
这和很多游戏
And this is very similar to how a lot of games

946
00:52:44,620 --> 00:52:48,220
实现了他们的面板或图形用户
implemented their panels or their graphical user

947
00:52:48,220 --> 00:52:52,270
在80年代和90年代 我的意思是 到今天为止 很多游戏的界面 
interfaces back in the 80s and 90s, I mean, to a lot of games till this day.

948
00:52:52,270 --> 00:52:58,330
但回到硬件基本上是基于瓦片的时候 
But back when hardware was fundamentally tile based,

949
00:52:58,330 --> 00:53:06,850
你可以把这样的一张图片 分成九块 
you could take a image like this, split it up into nine pieces--

950
00:53:06,850 --> 00:53:11,060
九补丁是这个术语的来源 
nine patch is where the terminology comes from.

951
00:53:11,060 --> 00:53:15,700
回忆一下 这和我们建造塞尔达传说中的地牢有点类似 
And sort of similar to how we actually constructed the Zelda dungeon, recall,

952
00:53:15,700 --> 00:53:20,950
你有角块 然后是顶部 底部 右侧和左侧 
where you have corner pieces, and then a top, bottom, right, and left side.

953
00:53:20,950 --> 00:53:24,320
你只要把这些一层一层地铺上 
You just layer this, one of each of these,

954
00:53:24,320 --> 00:53:28,000
第一个 右边 角块 
first off, right, of the corner pieces.

955
00:53:28,000 --> 00:53:33,580
然后你需要多少就多少
And then however many you need of these on the sides

956
00:53:33,580 --> 00:53:36,220
来创造这个矩形 对吧
to create this rectangle, right?

957
00:53:36,220 --> 00:53:39,040
想象一下我们创造了
So imagine we've created--

958
00:53:39,040 --> 00:53:45,260
这些都是 如果我们能把它们想象成一堆瓷砖 对吧？
these are all, if we can visualize these as being a bunch of tiles, right?

959
00:53:52,750 --> 00:53:55,120
想象一下我们把这些角块 
So just imagine that we've taken these corner pieces,

960
00:53:55,120 --> 00:53:58,240
这些是角上的碎片 我们每个都取了一个
these are the corner pieces, we've taken one of each of those.

961
00:53:58,240 --> 00:54:02,410
然后我们把这些边片 画一堆
And then we take these side pieces, and we just like draw a bunch of them

962
00:54:02,410 --> 00:54:04,000
那样的
like that.

963
00:54:04,000 --> 00:54:06,730
然后我们把这个中心装饰品 然后我们
And then we take this centerpiece, and then we

964
00:54:06,730 --> 00:54:11,260
可以将它分层 或者平铺几次 或者只是拉伸它 
can either layer it, or tile it a bunch of times, or just stretch it.

965
00:54:11,260 --> 00:54:15,160
拉伸它会带来一系列的好处 
And stretching it has a bunch of nice bonuses associated with it depending

966
00:54:15,160 --> 00:54:18,660
关于你如何设置你的过滤器模式 love.graphics.setdefaultfilter 
on how you've set your filter mode, love.graphics.setdefaultfilter,

967
00:54:18,660 --> 00:54:21,130
如果将其设置为“双线性”与“最接近” 
if you set it to bilinear versus nearest,

968
00:54:21,130 --> 00:54:23,230
你可以得到一个很好的渐变 
you can actually get a nice gradient.

969
00:54:23,230 --> 00:54:26,020
如果你把它设置为最近的 你会得到一个很好的像素化的外观 
And if you set it to nearest, you get a nice pixelated look.

970
00:54:26,020 --> 00:54:29,761
但是你会经常看到这一点 Unity对此有很好的支持 
But you'll see this often, and Unity has nice support for this.

971
00:54:29,761 --> 00:54:32,260
拍一张可能比你想象的更复杂的照片
Take an image that has maybe more complicated than you could

972
00:54:32,260 --> 00:54:34,100
只需要两个长方形 对吧
get with just two rectangles, right?

973
00:54:34,100 --> 00:54:37,780
一些有设计的东西 也许是渐变色 实际上
Something that actually has a design and maybe a gradient color, and actually

974
00:54:37,780 --> 00:54:40,270
层
layer--

975
00:54:40,270 --> 00:54:46,030
我的意思是 创建一个任意大小的文本框来满足您的需要 
I mean, create a arbitrarily sized text box to fit your needs.

976
00:54:46,030 --> 00:54:49,770
如果这些甚至不是增量或无论你的瓷砖大小
And if these aren't even increments or whatever your tile size

977
00:54:49,770 --> 00:54:53,680
是在你的9补丁 你可以只规模的顶部 底部 左侧和右侧
is on your 9 patch, you could just scale the top, bottom, left, and right side

978
00:54:53,680 --> 00:54:56,690
也是为了保持它的比例 中心装饰 
as well just to keep it scaled, the centerpiece.

979
00:54:56,690 --> 00:54:58,865
所以这就说得通了 
So does that makes sense.

980
00:54:58,865 --> 00:55:01,240
这是很常见的 我们不会在我们的课程中使用它 
So this is common, we won't be using that in our lecture,

981
00:55:01,240 --> 00:55:06,182
但这是很多图形用户界面设计中非常、非常常见的一部分 
but it's a very, very common piece to a lot of graphical user interface design.

982
00:55:06,182 --> 00:55:09,390
在许多游戏中 如果你对游戏开发有更多的了解 你会看到很多这样的游戏 
In a lot of games, you'll see it a lot if you get more into game development,

983
00:55:09,390 --> 00:55:12,400
所以这绝对值得一谈 
so it's definitely worth talking about.

984
00:55:12,400 --> 00:55:17,620
我们今天要讨论的另一个部分是文本框 
Another piece that we'll be talking about today is the text box.

985
00:55:17,620 --> 00:55:20,814
所以我的意思是 关于文本框是什么 
So I mean, what's a guess as to what the text box,

986
00:55:20,814 --> 00:55:23,730
我们如何实现文本框 以及我们将如何实现文本框？
how we can implement a text box, and how we will implement a text box?

987
00:55:27,450 --> 00:55:33,000
那么 我们可以从什么基础工作开始呢？
So what foundational piece can we start with?

988
00:55:33,000 --> 00:55:35,023
我们已经有了--是吗？
We already have-- yeah?

989
00:55:35,023 --> 00:55:37,765
观众：你只要用爱的印记就行了
AUDIENCE: You just put use the love print

990
00:55:37,765 --> 00:55:40,171
其中一个盒子上方的屏幕上 
to the screen over one of those boxes.

991
00:55:40,171 --> 00:55:43,420
演讲者1：准确地说 就是在其中一个盒子上方的屏幕上印上爱的印记 
SPEAKER 1: So use the love print to the screen over one of the boxes, exactly.

992
00:55:43,420 --> 00:55:44,280
是啊 
Yep.

993
00:55:44,280 --> 00:55:49,800
所以维护一个文本项目的列表 对 文本 
So maintain a list of text items, right, text.

994
00:55:49,800 --> 00:55:57,090
然后只需将它们绘制在面板内 就会有一个文本框 
And then just draw them inside a panel, and there's a text box.

995
00:55:57,090 --> 00:56:00,360
你已经接受了两个想法 并将它们混合在一起 
You've taken two ideas, and sort of mix them together.

996
00:56:00,360 --> 00:56:03,080
精选是一回事 
A selection is kind of the same thing.

997
00:56:03,080 --> 00:56:07,290
这是唯一的不同之处 就是有一个选择--
It's a the only difference being that with a selection--

998
00:56:07,290 --> 00:56:10,720
因此 如果我们想一想 选择是另一回事 
so a selection is another thing if we think about,

999
00:56:10,720 --> 00:56:15,970
例如 菜单中我们有战斗 像奔跑一样 
for example a menu where we have fight, and like run,

1000
00:56:15,970 --> 00:56:20,880
它可能是在一个更充实的游戏中 我们有一个项目的东西 
and it may be in a more fleshed out game, we have like an item thing,

1001
00:56:20,880 --> 00:56:21,840
对吗？
right?

1002
00:56:21,840 --> 00:56:25,830
所以这是一份有效的菜单 
So that's a menu effectively.

1003
00:56:25,830 --> 00:56:28,650
它与我们在文本框中得到的非常相似 
It is very similar to what we get with a text box,

1004
00:56:28,650 --> 00:56:32,910
但它有一系列的元素 战斗 物品 奔跑 
but it's got a set of ingredients here, fight, item, run,

1005
00:56:32,910 --> 00:56:40,170
它们没有设置为换行 它们不是一个连续的文本集 
which they aren't set to wrap, they're not one like contiguous set of text.

1006
00:56:40,170 --> 00:56:42,420
这只是一堆东西 
It's just a bunch of items.

1007
00:56:42,420 --> 00:56:45,870
精选的好处是你可以
And then nice thing about a selection is that you can

1008
00:56:45,870 --> 00:56:49,830
在你的选择上有一个光标 对吗？
have a cursor on your selection, right?

1009
00:56:49,830 --> 00:56:53,052
然后我们需要联想到什么 比如 
And then what do we need to associate with like, for example,

1010
00:56:53,052 --> 00:56:54,760
如果我们想让这件事真正起作用 
if we want this to actually do something,

1011
00:56:54,760 --> 00:56:57,220
如果我们想一想我们到目前为止所做的事情 
and if we think about what we've been doing so far,

1012
00:56:57,220 --> 00:56:59,220
我们如何着手实现功能
how do we go about implementing functionality

1013
00:56:59,220 --> 00:57:00,680
有这样的选择吗？
with a selection like this?

1014
00:57:00,680 --> 00:57:04,353
比如 在我们的选择中 哪些条目需要与每个条目相关联？
Like what needs to get associated with each of those entries in our selection?

1015
00:57:08,430 --> 00:57:09,910
回调函数 对吗？
Callback function, right?

1016
00:57:09,910 --> 00:57:11,680
就像我们处理其他一切一样 
Just as we've done with everything else.

1017
00:57:11,680 --> 00:57:15,690
如果你这里有一个战斗物品 每一个 如果我们考虑到选择
If you have a fight item here, each of these, if we think of the selection

1018
00:57:15,690 --> 00:57:19,110
因为这只是我们所看到的这一部分 
as being just this part of what we're looking at,

1019
00:57:19,110 --> 00:57:22,700
对 因为这个背景部分只是一个面板 我们不在乎这个 
right, because this background part is just a panel, we don't care about that.

1020
00:57:22,700 --> 00:57:24,450
目前我们关心的是选择 
We care about the selection at the moment.

1021
00:57:24,450 --> 00:57:27,250
选择的是项目和箭头 对吗？
The selection is the items and the arrow, right?

1022
00:57:27,250 --> 00:57:30,630
正如我们将在作业中看到的 你的目标实际上
When as we'll see in the assignment, your goal will actually

1023
00:57:30,630 --> 00:57:33,750
接受选择并去掉箭头功能 
be to take selection and get rid of the arrow functionality,

1024
00:57:33,750 --> 00:57:36,060
因为对于这个任务 你不需要
because for the assignment, you don't need

1025
00:57:36,060 --> 00:57:40,620
或者想要激活选择 激活光标 
or want to have a selection active, a cursor active.

1026
00:57:40,620 --> 00:57:43,620
你只想要一份物品清单 
You just want a list of things.

1027
00:57:43,620 --> 00:57:52,570
但根据光标指向的内容以及我们按回车键之类的 
But based on what the cursor is pointing at and when we press Enter or whatnot,

1028
00:57:52,570 --> 00:57:55,770
我们应该为所选内容编制索引 然后
we should index into the selection, and then

1029
00:57:55,770 --> 00:57:59,680
执行与这些项中的每一项关联的回调 
execute a callback that's associated with each of these items.

1030
00:57:59,680 --> 00:58:02,400
这就是我们可以从选择中提取行为的方法 
And that's how we can get behavior out of the selection,

1031
00:58:02,400 --> 00:58:05,410
而不仅仅是我们呈现在屏幕上的东西的列表 
rather than just being a list of things that we render to the screen.

1032
00:58:05,410 --> 00:58:08,340
如果我们打架了 我们按了Enter 这是一个回调
If we have fight, and we click Enter, a callback

1033
00:58:08,340 --> 00:58:12,247
设置为可能将某个状态推送到堆栈上 该堆栈
is set to maybe push a state onto the stack that

1034
00:58:12,247 --> 00:58:15,330
会在屏幕上引发两个实体之间的互动 对吗？
will trigger an interaction between the two entities on the screen, right?

1035
00:58:15,330 --> 00:58:17,010
第一个会攻击第二个 
The first one will attack the second one,

1036
00:58:17,010 --> 00:58:18,600
第二个会攻击第一个 
the second one will attack the first one.

1037
00:58:18,600 --> 00:58:21,766
这是它自己的一组异步状态 它们做着自己的事情 
And that's sort of its own asynchronous set of states that do its own thing,

1038
00:58:21,766 --> 00:58:24,750
但它是通过一个匿名函数启动的
but it's kicked off via an anonymous function

1039
00:58:24,750 --> 00:58:27,980
我们都和这些东西联系在一起了 对吗？
that we've associated with each of these things, right?

1040
00:58:27,980 --> 00:58:32,460
一个项推送另一个状态 这类似于项的迷你状态 然后您
An item pushes another state, which is like an item mini state, where then you

1041
00:58:32,460 --> 00:58:36,240
打开一套全新的菜单 您可以查看您的所有项目 
open up a brand new set of menus that you can look through all your items,

1042
00:58:36,240 --> 00:58:40,246
每一项都有一个与之关联的回调 对吗？
and each of those items has a callback associated with it, right?

1043
00:58:40,246 --> 00:58:42,120
您的药水有关联的回调
Your potion has a callback associated with it

1044
00:58:42,120 --> 00:58:45,750
这就是说 当我点击这个时 默认情况下 
that says, when I click on this, either by default,

1045
00:58:45,750 --> 00:58:48,120
只要恢复我的激活的精灵宝可梦的惠普 
just restore the HP of my active Pokemon,

1046
00:58:48,120 --> 00:58:50,070
或者让我来选择恢复的对象 
or let me choose who to restore.

1047
00:58:50,070 --> 00:58:53,960
因此 推送另一个状态 就像选择一个精灵宝可梦
So therefore, push another state, which is like a select Pokemon

1048
00:58:53,960 --> 00:58:58,120
屏幕上有它自己的一组与每个回调相关联的回调 
screen with its own set of callbacks associated with each of those.

1049
00:58:58,120 --> 00:59:01,911
它只是为了得到所有这种复杂的行为
It's just in order to get all of this sort of complicated behavior

1050
00:59:01,911 --> 00:59:04,410
这是你需要的 它最终真的只是推动各州
that you need to, it's really ultimately just pushing states

1051
00:59:04,410 --> 00:59:07,290
并将回调函数添加到所有这些不同的选项
and adding callback functions to all of these different options

1052
00:59:07,290 --> 00:59:09,570
你可以选择 
that you can select.

1053
00:59:09,570 --> 00:59:13,589
然后跑 推一个淡入淡出状态 然后弹出这个状态 
And then run, push a fade state, and then pop this state,

1054
00:59:13,589 --> 00:59:14,880
然后推入淡出状态 
and then push a fade out state.

1055
00:59:14,880 --> 00:59:16,380
这就是我们所做的一切 
And that's really all we're doing.

1056
00:59:16,380 --> 00:59:20,250
下面我们来看看所有这些图形用户界面小部件
And so this look at all of these GUI widgets

1057
00:59:20,250 --> 00:59:24,060
这只是一个概念性的外观 但我们很快就会看到
here is just sort of a conceptual look, but we'll take a look very shortly

1058
00:59:24,060 --> 00:59:25,830
在一些实际的实现中 
at some actual implementation.

1059
00:59:25,830 --> 00:59:34,060
最后一个我想看的是进度条 
The last one that I want to look at is the progress bar.

1060
00:59:34,060 --> 00:59:37,350
以进度条为例 我们的惠普
So a progress bar for example, the HP that we've

1061
00:59:37,350 --> 00:59:45,000
在实际战斗中看到的 当我们受到伤害时 它从右到右
seen in the actual battle where when we take damage, it goes from right to

1062
00:59:45,000 --> 00:59:46,009
左边 
left.

1063
00:59:46,009 --> 00:59:48,300
有没有人猜测我们是如何实现进度条的？
Any guesses as to how we've implemented a progress bar?

1064
00:59:48,300 --> 00:59:48,914
什么事 托尼？
Yes, Tony?

1065
00:59:48,914 --> 00:59:50,534
观众：再一次 两个长方形 
AUDIENCE: Once again, two rectangles.

1066
00:59:50,534 --> 00:59:52,200
演讲者1：两个长方形 没错 
SPEAKER 1: Two rectangles, yes, exactly.

1067
00:59:52,200 --> 00:59:55,860
一个 然后是Love2D中关于矩形的好事情
One, and then the nice thing about rectangles in Love2D

1068
00:59:55,860 --> 01:00:00,840
您可以将它们的边缘设置为圆角或不圆角
is you can set the edges on them to be rounded or not

1069
01:00:00,840 --> 01:00:02,760
通过可选参数 
via an optional parameter.

1070
01:00:02,760 --> 01:00:05,760
所以没有比矩形更复杂的东西
So without anything more complicated than a rectangle

1071
01:00:05,760 --> 01:00:09,917
我们可以创造出这种近乎椭圆形的进程
we can just create these sort of almost ellipsoid progress

1072
01:00:09,917 --> 01:00:11,250
条形图 非常简单的进度条 
bars, very simple progress bars.

1073
01:00:11,250 --> 01:00:14,310
一个是红色的 对 红色是背景 
Ones the red, right, the red that's the background.

1074
01:00:14,310 --> 01:00:15,870
然后画出轮廓 黑色 
And then ones the outline, the black.

1075
01:00:15,870 --> 01:00:18,780
并且其中一个被设置为填充第一个参数 
And one is set to fill with the first parameter,

1076
01:00:18,780 --> 01:00:21,850
其中一个参数设置为与第一个参数成直线 
one's set to line with the first parameter.

1077
01:00:21,850 --> 01:00:24,750
现在 我们如何开始制作动画 
Now how do we go about animating whether or not,

1078
01:00:24,750 --> 01:00:29,080
当我们受到伤害时 我们如何激活生命值的下降？
how do we animate the decreasing amount of health when we take damage?

1079
01:00:29,080 --> 01:00:29,580
是?
Yes?

1080
01:00:29,580 --> 01:00:31,597
观众：在宽度之间 
AUDIENCE: Between the width.

1081
01:00:31,597 --> 01:00:33,180
扬声器1：正好在宽度之间 
SPEAKER 1: Between the width, exactly.

1082
01:00:33,180 --> 01:00:34,560
我们要对它做些什么补充？
And what are we tweening it by?

1083
01:00:34,560 --> 01:00:36,626
我们要怎么补齐它呢？
How are we tweening it?

1084
01:00:36,626 --> 01:00:38,792
我们如何计算我们需要对它进行多少补间？
How would we calculate how much we need to tween it?

1085
01:00:38,792 --> 01:00:44,536
观众：嗯 你可以让你的宽度和你的健康相抵 
AUDIENCE: Well, you could just have your width equal your health remaining.

1086
01:00:44,536 --> 01:00:47,160
扬声器1：如果您的宽度设置为等于您剩余的健康 
SPEAKER 1: If your width is set to equal your health remaining,

1087
01:00:47,160 --> 01:00:49,860
那么你的健康状况可能是10岁 
then your health is maybe 10.

1088
01:00:49,860 --> 01:00:52,860
你想要你的健康条有100个像素
And you want your health bar to be like 100 pixels

1089
01:00:52,860 --> 01:00:54,585
龙 这是怎么回事 但工作？
long, how is that going to work though?

1090
01:00:54,585 --> 01:00:55,740
观众：乘 
AUDIENCE: Multiply it.

1091
01:00:55,740 --> 01:00:57,810
你可以乘它 但如果你
SPEAKER 1: You could multiply it, but if you

1092
01:00:57,810 --> 01:01:01,260
知道进度条的宽度
know the width that you want your progress bar to be,

1093
01:01:01,260 --> 01:01:05,760
你可以用宽度乘以最大值的比率
you can just multiply the width by the ratio of the max

1094
01:01:05,760 --> 01:01:12,030
你的HP值 或者抱歉 你当前HP与最大HP的比率 
value of your HP, or sorry, the ratio of your current HP over your max HP,

1095
01:01:12,030 --> 01:01:12,990
对吧？
right?

1096
01:01:12,990 --> 01:01:16,200
所以如果你少了--如果你有50 HP 你少了5 HP 
So if you're missing-- if you have 50 HP, and you're missing 5 HP,

1097
01:01:16,200 --> 01:01:18,240
你的比率是45/50
your ratio is 45 over 50.

1098
01:01:18,240 --> 01:01:22,950
如果你把它乘以宽度 你就得到了精确的宽度
And if you multiply that by your width, you get the exact amount of width

1099
01:01:22,950 --> 01:01:26,625
不管你想让酒吧有多宽
that you need regardless of how wide you want the bar to be,

1100
01:01:26,625 --> 01:01:29,250
如果你想要1,000像素 或者50像素 
if you want to be 1,000 pixels, if you want it to be 50 pixels,

1101
01:01:29,250 --> 01:01:35,569
只要你把当前健康值乘以最大健康值乘以宽度 
as long as you multiply current health over max health times the width,

1102
01:01:35,569 --> 01:01:37,110
无论如何你都会得到那个比率
you'll get that ratio no matter what.

1103
01:01:37,110 --> 01:01:38,764
这有道理吗
Does that makes sense?

1104
01:01:38,764 --> 01:01:39,590
酷了
Cool.

1105
01:01:39,590 --> 01:01:43,140
这就是我们看到的所有GUI小部件 它们是如何排序的
So that's a look at all the GUI widgets that we're looking at, how they sort

1106
01:01:43,140 --> 01:01:46,630
与我们正在做的事情有关 
relate to what we're doing.

1107
01:01:46,630 --> 01:01:48,760
我们将在这里看看它们的实现 
We'll take a look at their implementation here.

1108
01:01:48,760 --> 01:01:51,141
所以我要打开面板 
So I'm going to go ahead and open up the panel.

1109
01:01:51,141 --> 01:01:52,890
我会讲得稍微快一点
And I'm going to move a little bit quickly

1110
01:01:52,890 --> 01:01:57,150
所以我们可以进入战斗的核心 
so we can get into sort of the meat of the battle here.

1111
01:01:57,150 --> 01:02:03,420
面板就像我们之前说的 只有两个矩形 对吧？
The panel is as we've said before just two rectangles, right?

1112
01:02:03,420 --> 01:02:06,000
它在一个高度内取xy 
It takes in an xy within a height.

1113
01:02:06,000 --> 01:02:08,060
然后我们画两个矩形 
And then we would just draw two rectangles.

1114
01:02:08,060 --> 01:02:09,750
一个比另一个大 
One is larger than the other.

1115
01:02:09,750 --> 01:02:12,930
底部矩形略大于顶部矩形 
The bottom rectangle is slightly larger than the top rectangle.

1116
01:02:12,930 --> 01:02:16,010
第一个矩形是白色的 
So the first rectangle gets drawn and it's whitish.

1117
01:02:16,010 --> 01:02:21,020
然后...抱歉抱歉
And then-- oh, I'm sorry, sorry about that.

1118
01:02:21,020 --> 01:02:23,810
我们在一个高度内有一个xy 
We have a xy within a height.

1119
01:02:23,810 --> 01:02:26,120
然后我们在屏幕上画两个矩形 
And then we're drawing two rectangles to the screen.

1120
01:02:26,120 --> 01:02:29,330
我们有一个背景矩形 它首先被绘制出来 
We have the background rectangle, which is drawn first,

1121
01:02:29,330 --> 01:02:32,840
也就是面板的整个xy宽度和高度 
which is going to be the full xy width and height of the panel.

1122
01:02:32,840 --> 01:02:36,290
然后我们用白色画出来 然后画
And then we're going to draw that at a white color, and then draw--

1123
01:02:36,290 --> 01:02:39,500
在这个游戏中 我们用同样的颜色画所有的东西 
in the context of this game-- we're drawing everything at the same color,

1124
01:02:39,500 --> 01:02:40,760
但我们可以改变颜色
but we can change the color.

1125
01:02:40,760 --> 01:02:42,900
如果我们想让它参数化 我们可以这么做 
If we wanted to parameterize it, we could do that.

1126
01:02:42,900 --> 01:02:46,070
我们可以设置 我们可以在构造函数中有一个颜色选项 
We could set, we could have a color option here in the constructor.

1127
01:02:46,070 --> 01:02:49,190
我们不是这样做的 我们只是把所有东西都画成同样的颜色 
We're not doing that, we're just drawing everything the same color.

1128
01:02:49,190 --> 01:02:51,510
但这就是你获得定制菜单的方式 
But that's how you would get like customized menus,

1129
01:02:51,510 --> 01:02:54,694
有些RPG可以让你这么做 
some RPGs let you do that.

1130
01:02:54,694 --> 01:02:57,860
然后我们在这里做的是我们只是在一个稍微小一点的范围内
And then what we're doing here is we're just within a small slightly smaller

1131
01:02:57,860 --> 01:02:58,730
边界 
boundary.

1132
01:02:58,730 --> 01:03:02,179
所以在x和y上只小了两个像素 
So just two pixels smaller on the x and y.

1133
01:03:02,179 --> 01:03:04,220
你要画第二个矩形的地方 
Where you are going to draw the second rectangle,

1134
01:03:04,220 --> 01:03:06,950
这是一种灰色的深色 
which is a kind of dark shade of gray.

1135
01:03:06,950 --> 01:03:09,425
这是一个小组 这就是小组的全部 
And that is a panel, that is all panel is.

1136
01:03:09,425 --> 01:03:11,300
然后我们可以只有一个名为
And then we could just have a function called

1137
01:03:11,300 --> 01:03:14,430
切换 将其设置为可见或不可见 
toggle, which sets it to visible or not visible.

1138
01:03:14,430 --> 01:03:19,130
如果它是可见的 就把它扔掉 如果它是可见的 对不起 就画出来 
And if it's visible, get rid of it, or if it's visible, sorry, draw it.

1139
01:03:19,130 --> 01:03:21,560
否则 在渲染时不要绘制任何内容 
Otherwise, don't draw anything when it gets rendered.

1140
01:03:21,560 --> 01:03:23,240
简而言之 这就是一个面板 
So that's a panel in a nutshell.

1141
01:03:23,240 --> 01:03:26,160
有什么问题吗？
Any questions?

1142
01:03:26,160 --> 01:03:26,960
凉爽的 
Cool.

1143
01:03:26,960 --> 01:03:32,160
所以接下来我们要看的是文本框 
So the next thing that we should look at is the text box.

1144
01:03:32,160 --> 01:03:33,290
所以有一个文本框--
So a text box--

1145
01:03:33,290 --> 01:03:37,340
因此 文本框比面板稍微复杂一些 
so the text box is a little bit more complicated than a panel.

1146
01:03:37,340 --> 01:03:41,990
简而言之 文本框需要接受一些任意的文本正文 
A text box in a nutshell needs to take in some arbitrary body of text,

1147
01:03:41,990 --> 01:03:45,590
它需要根据文本框的宽度对其进行分割 
and it needs to chop it up based on how wide your text box is.

1148
01:03:45,590 --> 01:03:49,070
如果它超过了文本框的高度 
And if it surpasses the height of your text box,

1149
01:03:49,070 --> 01:03:54,710
对 理想情况下 你应该翻页你的文字 这样你就可以按空格键 
right, ideally, you should page your text so that you can press Space bar,

1150
01:03:54,710 --> 01:04:00,020
输入并浏览多页文本 直到用完所有文本 
Enter and go through pages of text until you've exhausted all of your text.

1151
01:04:00,020 --> 01:04:06,170
最后再按一次Enter键 就可以去掉那个文本框 
And you press Enter one last time, and you get rid of that text box.

1152
01:04:06,170 --> 01:04:11,210
所以我们这里有一个面板 我们有XY的宽度和高度
And so we have a panel here, which we have an xy width and height

1153
01:04:11,210 --> 01:04:12,710
在文本框的构造函数中 
in our constructor for the text box.

1154
01:04:12,710 --> 01:04:14,349
我们也有我们的文本 
And we have our text as well.

1155
01:04:14,349 --> 01:04:16,640
然后我们有一个字体 如果我们想要明确地决定
And then we have a font if we want to explicitly decide

1156
01:04:16,640 --> 01:04:19,490
我们要使用的字体 
what font we want to use.

1157
01:04:19,490 --> 01:04:25,190
在这种情况下 或者在逃亡中 我们会说
In this case, or at large, we're going to say

1158
01:04:25,190 --> 01:04:30,530
我们实例化一个XY宽度和高度的面板 不要太花哨 
that we instantiate a panel at xy width and height, nothing too fancy.

1159
01:04:30,530 --> 01:04:35,510
然后是幻想的部分 稍微复杂的部分
And then the fancyish part, the slightly more complicated part

1160
01:04:35,510 --> 01:04:38,330
在这里的第20行 我们说 下划线
is here on line 20 where we say, underscore

1161
01:04:38,330 --> 01:04:46,170
Self.extChucks得到的是self.font、getWrap、self.text、self.width减去12 
self.textChucks gets self.font, getWrap, self.text, self.width minus 12.

1162
01:04:46,170 --> 01:04:49,190
有谁知道这个函数是做什么的 或者想猜一猜？
So anybody know what this function does or want to take a guess?

1163
01:04:55,190 --> 01:04:55,690
是?
Yes?

1164
01:04:55,690 --> 01:04:58,023
观众：这就是你说的那个页面吗？
AUDIENCE: Is that the page thing you were talking about?

1165
01:04:58,023 --> 01:05:01,192
演讲者1：没错 这就是文本的分页 
SPEAKER 1: Exactly, it's the paging of the text.

1166
01:05:01,192 --> 01:05:02,650
更确切地说是文本的组块 
Is the chunking of the text rather.

1167
01:05:02,650 --> 01:05:07,060
不是文本的分页 而是文本的组块 这
Not the paging of the text, so much as is the chunking of the text, which

1168
01:05:07,060 --> 01:05:08,650
我们将使用来对文本进行分页 
we will use to page the text.

1169
01:05:08,650 --> 01:05:12,430
所以我们取了一些你知道的任意大的文本 
So we take some you know arbitrarily large body of text,

1170
01:05:12,430 --> 01:05:16,060
它可以像我们想要的那样大 并且给定--
it can be as large as we want it to be, and given--

1171
01:05:16,060 --> 01:05:20,090
这实际上是Love2D字体对象的一个函数 
this is actually a function of to Love2D font object.

1172
01:05:20,090 --> 01:05:23,020
这是Love2D给我们的 
So this is given to us from Love2D.

1173
01:05:23,020 --> 01:05:26,350
GET WRAP将返回两个值 第二个值
Get wrap will return two values, the second of which

1174
01:05:26,350 --> 01:05:32,620
是主体大体被分成的所有文本片段
is all of the pieces of text that the main big body is divided into

1175
01:05:32,620 --> 01:05:33,770
根据宽度 
based on the width.

1176
01:05:33,770 --> 01:05:37,270
所以这个自身宽度是负12 这就是宽度
So this self.width of minus 12, that's how wide

1177
01:05:37,270 --> 01:05:39,917
它将把我们的文本分成多个块 
it's going to divide our text into chunks of up to,

1178
01:05:39,917 --> 01:05:42,250
它可能略小于 因为它将它分开
it could be slightly smaller than, because it divides it

1179
01:05:42,250 --> 01:05:44,740
基于这个词 
based on the word.

1180
01:05:44,740 --> 01:05:51,280
但是 任何文本都不会超过自身宽度减去12宽度 
But no piece of text will ever exceed self.width minus 12 width.

1181
01:05:51,280 --> 01:05:57,040
这将允许我们在文本中呈现几行文本
And this will allow us to then render several lines of text within our text

1182
01:05:57,040 --> 01:06:01,420
盒子 他们永远不会超过边界 对吗？
box, and they will never exceed the boundary, right?

1183
01:06:01,420 --> 01:06:05,770
因此 分页功能实际上将在下一块中实现 
And so the paging functionality is actually in next chunks.

1184
01:06:05,770 --> 01:06:09,400
因此 我们在[？]的末尾称自己为Next针织？]功能 
So we call self next here at the end of [? knitt ?] function.

1185
01:06:09,400 --> 01:06:13,750
然后Self下一步基本上检查一下 好的 我们在课文的末尾吗？
And then self next basically checks to see, OK, are we at the end of the text?

1186
01:06:13,750 --> 01:06:16,350
如果是 那么我们将不会显示任何文本 
If we are, then we're not going to display any text,

1187
01:06:16,350 --> 01:06:18,450
我们要把窗户关上 
and we're going to close the window.

1188
01:06:18,450 --> 01:06:20,110
我们要关闭电池板 
We're going to close the panel.

1189
01:06:20,110 --> 01:06:24,470
但如果我们没有在文本的末尾 就像我们仍然得到文本一样 
But if we are not at the end of the text, like we still get text left,

1190
01:06:24,470 --> 01:06:26,830
我们想要做的是新桌子 
what we want to do is new table.

1191
01:06:26,830 --> 01:06:30,940
然后我们将进行最多三次迭代 
And then we're going to, up to three iterations,

1192
01:06:30,940 --> 01:06:33,220
我们跟踪我们在块中的位置 对吗？
we keep track of where we are in our chunks, right?

1193
01:06:33,220 --> 01:06:36,827
我们得到的文本块等于所有这些块 对吧 
We get self.text chunks equal to all of those chunks, right.

1194
01:06:36,827 --> 01:06:38,410
这可能是一个任意的数字 
And that could be an arbitrary number.

1195
01:06:38,410 --> 01:06:41,719
可能只有一块 可能有30块 对吧？
It can be only one chunk, there could be like 30 chunks, right?

1196
01:06:41,719 --> 01:06:43,510
我们需要一个柜台来记录我们在哪里
We need a counter to keep track of where we

1197
01:06:43,510 --> 01:06:47,530
都是基于我们所在的页面 对吧 
are in terms of like based on what page we're on, right,

1198
01:06:47,530 --> 01:06:51,680
以及到目前为止我们在屏幕上渲染了多少行 
and however many lines we rendered to the screen thus far.

1199
01:06:51,680 --> 01:06:55,030
所以从i开始 我得到了块计数器 
So starting at I, and I get's chunk counter,

1200
01:06:55,030 --> 01:06:57,100
并且块计数器将递增3
and chunk counter will get incremented by three

1201
01:06:57,100 --> 01:07:00,430
每次我们调用下一块 也就是每一页 
every time we call next chunks, which is every page.

1202
01:07:00,430 --> 01:07:04,030
我们也可以很容易地将这一页称为下一页 
We could have easily just called this next page as well.

1203
01:07:04,030 --> 01:07:05,950
它将插入到Chchks表中
It's going to insert into that chunks table

1204
01:07:05,950 --> 01:07:08,560
我们刚刚创建的 self.extChucks at i 
that we just created, self.textChucks at i.

1205
01:07:08,560 --> 01:07:12,250
一旦我们达到了区块总数
And once we've reached the number of chunks total

1206
01:07:12,250 --> 01:07:16,420
我们从Get WRAP返回的 我们将标记文本结束
that we returned from get wrap, we're going to flag end of text

1207
01:07:16,420 --> 01:07:19,990
是真的 然后我们会把它退回 
as being true, and then we're going to return it.

1208
01:07:19,990 --> 01:07:22,300
因此 最终 我们将会
And so what this will do is, eventually, we're

1209
01:07:22,300 --> 01:07:26,920
将等于我们从Font Get WRAP中获得的区块数量 
going to be equal to the number of chunks that we got from font get wrap,

1210
01:07:26,920 --> 01:07:28,300
对吗？
right?

1211
01:07:28,300 --> 01:07:31,585
一旦我们做到了 这将是Next的信号
And once we are, that will signal with next

1212
01:07:31,585 --> 01:07:34,570
是时候关闭文本框了 因为文本结束了
that it's time to close the text box, because end of text

1213
01:07:34,570 --> 01:07:38,920
将在最后一个分块过程结束时设置为True 
will have been set to true at the end of that last chunking process.

1214
01:07:38,920 --> 01:07:41,562
然后我们可以看到 当我们更新文本框时 
And then we can see here, when we update text box,

1215
01:07:41,562 --> 01:07:43,520
当它在堆栈的顶部时 
and that whenever it's on the top of the stack,

1216
01:07:43,520 --> 01:07:47,000
记住 我们要找的是空格键或回车键
remember, we're looking for a Space or an Enter press,

1217
01:07:47,000 --> 01:07:48,880
然后我们就给赛尔夫打个电话 
and then we just call self next.

1218
01:07:48,880 --> 01:07:53,170
这将产生最终关闭我们的文本框的效果 
And that will have the effect of eventually closing our text box.

1219
01:07:53,170 --> 01:07:56,230
然后是封闭式召回 我们之前看过 我们检查过
And then is closed recall, we looked at that earlier, we checked

1220
01:07:56,230 --> 01:07:59,300
要查看文本框是否关闭？
to see it is the text box closed?

1221
01:07:59,300 --> 01:08:01,270
这只是我们在这里设置的一面旗帜 
And that's just a flag that we set here.

1222
01:08:01,270 --> 01:08:06,280
然后出于渲染的目的 我们首先渲染面板 
And then for rendering purposes, we render the panel first.

1223
01:08:06,280 --> 01:08:10,750
然后对于我们的每个展示块 我们最多只有三个
And then for each of our displaying chunks, so we only have up to three

1224
01:08:10,750 --> 01:08:16,480
一次显示块 这由下一个块函数设置 
displaying chunks at one time, which gets set by the next chunks function.

1225
01:08:16,480 --> 01:08:22,569
我们只需将其打印到屏幕上 使用i作为y的乘数 
We just print that to the screen using i as a multiplier on our y.

1226
01:08:22,569 --> 01:08:29,439
这将产生两到三条线 i i+1 i+2 
And so that will render up two or three lines, i, i plus 1, i plus 2.

1227
01:08:29,439 --> 01:08:31,899
对文本框的工作原理有任何疑问吗？
Any questions as to how the text box works?

1228
01:08:34,460 --> 01:08:36,939
当然 这比小组的工作要多一点 
It's a little more work than the panel for sure,

1229
01:08:36,939 --> 01:08:38,470
但这相当直截了当 
but it's fairly straightforward.

1230
01:08:38,470 --> 01:08:40,960
我们只是在保存一堆文字信息的清单 
We're just keeping a list of a bunch of text things,

1231
01:08:40,960 --> 01:08:46,200
然后我们只是根据文本的宽度对它们进行分块
and then we're just chunking them based on how wide the text

1232
01:08:46,200 --> 01:08:48,100
盒子是 它的尺寸 
box is, the dimensions thereof.

1233
01:08:50,710 --> 01:08:53,040
然后让我们来看看这个精选 
And then let's take one look at this selection.

1234
01:08:53,040 --> 01:09:01,240
因此 选择基本上就是带有光标的文本项列表 对吗？
So a selection is basically, a list of text items with a cursor, right?

1235
01:09:01,240 --> 01:09:04,540
就像我之前说的 当我们看着那边的屏幕时 
And as I said before when we were looking at the screen over there,

1236
01:09:04,540 --> 01:09:08,890
每个文本项都有一个文本值和一个回调函数 
each of those text items has a text value and a callback function.

1237
01:09:08,890 --> 01:09:10,840
回调函数使我们能够
And the callback function is what allows us

1238
01:09:10,840 --> 01:09:16,130
要将行为分配给该选择对象 而不仅仅是显示内容 
to assign behavior to this selection object beyond just displaying things,

1239
01:09:16,130 --> 01:09:16,630
对吗？
right?

1240
01:09:16,630 --> 01:09:18,921
因为当你有一个菜单 当你有一个选择
Because when you have a menu, when you have a selection

1241
01:09:18,921 --> 01:09:22,479
你选择了一些东西 你希望行为发生 对吗？
and you select something, you want behavior to happen, right?

1242
01:09:22,479 --> 01:09:26,439
因此 这些条目中的每一个inde.Items都会有一个回调函数 
So each of these items indef.items will expect to have a callback function.

1243
01:09:29,939 --> 01:09:32,649
然后在这里 当我们更新选择时 我们正在做的是
And then here, when we update the selection, what we're doing

1244
01:09:32,649 --> 01:09:35,398
我们正在更新我们当前选择的内容 这就是
is we're updating whatever our current selection is, which is just

1245
01:09:35,398 --> 01:09:38,740
介于1和该选择中的项目数之间的数字 以确保
a number between 1 and the number of items in that selection making sure

1246
01:09:38,740 --> 01:09:42,590
如果我们在一 我们去负一 我们回到底部 
that if we're at one and we go minus one, that we go back to the bottom.

1247
01:09:42,590 --> 01:09:45,310
如果我们按下时处于底部 而我们向上 
And if we're at the bottom when we press, and we go up,

1248
01:09:45,310 --> 01:09:47,240
我们回到顶端 
we go back to the top.

1249
01:09:47,240 --> 01:09:51,880
我们演奏声音 可爱 诸如此类的东西 
And we play sounds, cutesy, things like that.

1250
01:09:51,880 --> 01:09:52,979
然后对于每一个--
And then for each--

1251
01:09:52,979 --> 01:09:56,440
对于我们在这里的选择 从一项到多项 
and for our selection here, from one to number of items,

1252
01:09:56,440 --> 01:09:58,720
我们计算我们需要多少填充物 
we calculate how much padding that we need.

1253
01:09:58,720 --> 01:10:01,480
然后我们将光标画在我们当前的选择上 
And we draw the cursor at our current selection,

1254
01:10:01,480 --> 01:10:06,700
然后我们根据i绘制每个项目 不管我们的间隙宽度是多少
and then we draw each item based on i and whatever our gap width is

1255
01:10:06,700 --> 01:10:08,680
我们的小组 我们将其分配给小组 
of our panel, which we assign it to.

1256
01:10:08,680 --> 01:10:11,920
所以我们把小组分成几部分 然后基本上
So we divide our panel up, and then basically just

1257
01:10:11,920 --> 01:10:14,650
跟踪当前y的位置并绘制
keep track of where current y is and draw

1258
01:10:14,650 --> 01:10:17,620
实际选定内容和光标(如果是
the actual selection and the cursor if that's

1259
01:10:17,620 --> 01:10:19,300
将当前选定内容添加到屏幕上 
the current selection to the screen.

1260
01:10:21,820 --> 01:10:25,060
关于精选的工作原理有什么问题吗？
Any questions as to how a selection sort of works?

1261
01:10:29,740 --> 01:10:35,260
请注意 如果我们按下Return 如果我们的选择正在更新 
Notice here, if we press Return, if our selection is being updated,

1262
01:10:35,260 --> 01:10:40,450
Self.Items at self.CurrentSelection.onSelect 
self.items at self.currentSelection.onSelect.

1263
01:10:40,450 --> 01:10:44,680
因此 预计该项将具有onSelect函数 该函数
So it's expected that that item will have an onSelect function, which

1264
01:10:44,680 --> 01:10:47,560
是回调函数 
is that callback function.

1265
01:10:47,560 --> 01:10:50,259
好的 最后 我们来看一下菜单 
OK, and lastly, we'll take a look at the menu.

1266
01:10:50,259 --> 01:10:52,300
然后我们最后来看看这场战斗 
And then we'll finally take a look at the battle,

1267
01:10:52,300 --> 01:10:55,420
这就是所有的一切都与这一切联系在一起的地方 
which is where sort of everything kind of comes together with all of this.

1268
01:10:55,420 --> 01:10:56,810
就这么定了 
And that'll be it.

1269
01:10:56,810 --> 01:10:59,600
然后我们再讨论作业 
And then we'll talk about the assignment.

1270
01:10:59,600 --> 01:11:01,660
因此 菜单是一个面板和一个选项 
So the menu is a panel and a selection together.

1271
01:11:01,660 --> 01:11:05,770
这就是这款游戏中菜单背后的主旨 
That's the gist behind what a menu is in this game.

1272
01:11:05,770 --> 01:11:07,930
你可以把菜单定义为有很多东西 
You can define a menu to be a lot of things,

1273
01:11:07,930 --> 01:11:11,620
菜单可能会变得更复杂 但在本例中 
and you can get a lot more complicated with a menu, but in this example,

1274
01:11:11,620 --> 01:11:15,190
在这个实现中 我们只是说菜单是一种选择
in this implementation, we're just saying a menu is a selection

1275
01:11:15,190 --> 01:11:17,950
以及一块拼装成一件物品的面板 
and a panel put together as one item.

1276
01:11:17,950 --> 01:11:24,810
我们在比赛中看到了这一点 如果我们是？]我要运行它 
And we've seen it in the game, [? if we're ?] going to run it.

1277
01:11:24,810 --> 01:11:26,910
这只是一个文本框 
That's just a text box.

1278
01:11:26,910 --> 01:11:28,557
去寻找一场战斗 
Going to look for a battle.

1279
01:11:32,050 --> 01:11:33,077
好了 这是一场战斗 
OK, so here's a battle.

1280
01:11:33,077 --> 01:11:35,410
这只是底部的一个空面板 普通的面板 
That's just an empty panel at the bottom, regular panel,

1281
01:11:35,410 --> 01:11:36,410
但现在它是一个文本框 
but now it's a text box.

1282
01:11:36,410 --> 01:11:38,710
我们将文本框压入堆栈 
We push the text box onto the stack.

1283
01:11:38,710 --> 01:11:40,840
将另一个文本框推入堆栈 
Push another text box onto the stack.

1284
01:11:40,840 --> 01:11:42,710
这是一份菜单 
And so this is a menu right here.

1285
01:11:42,710 --> 01:11:45,910
请注意 其中有一个光标 还有
Notice that there is a cursor and there's

1286
01:11:45,910 --> 01:11:47,890
嵌入到面板中的选定内容 
a selection embedded within a panel.

1287
01:11:47,890 --> 01:11:50,380
其中的每一项 打斗和逃跑 
And each of those items, the fight and the run,

1288
01:11:50,380 --> 01:11:54,440
它们有一个与之关联的回调 
those have a callback associated with them.

1289
01:11:54,440 --> 01:11:56,950
战斗回调的目的是触发一个新状态
The purpose of the fight callback is to trigger a new state

1290
01:11:56,950 --> 01:12:02,830
其中两个精灵宝可梦在连锁行为中相互异步攻击
where the two Pokemon asynchronously attack each other, in chain behavior

1291
01:12:02,830 --> 01:12:03,760
一个接一个 
one after the other.

1292
01:12:03,760 --> 01:12:07,720
然后Run推动对话 然后推动淡入淡出状态 
And then run pushes a dialogue, then pushes a fade state,

1293
01:12:07,720 --> 01:12:11,650
然后弹出这两个按钮 然后按下淡出状态
then pops both of them, and then pushes a fade out state

1294
01:12:11,650 --> 01:12:13,330
并将我们带回游戏状态 
and puts us back to the play state.

1295
01:12:13,330 --> 01:12:15,330
所以这实际上就是正在发生的事情 那就是
So that's effectively what's going on and that's

1296
01:12:15,330 --> 01:12:18,130
菜单是什么样子的一个例子 
an example of what the menu looked like.

1297
01:12:18,130 --> 01:12:21,970
这样就有了一个菜单 只是一个选项和一个面板放在一起 
And so a menu, just a selection with a panel put together.

1298
01:12:21,970 --> 01:12:26,650
当我们绘制菜单时 先绘制面板 然后绘制所选内容 
When we draw the menu, we draw the panel and then the selection.

1299
01:12:26,650 --> 01:12:29,860
然后当我们更新菜单时 我们只更新选项 
And then when we update the menu, we only update the selection,

1300
01:12:29,860 --> 01:12:32,305
因为那才是我们所关心的 
because that's all we care about.

1301
01:12:32,305 --> 01:12:34,060
基本上就是这样 
And that's basically it.

1302
01:12:34,060 --> 01:12:37,810
所以菜单本身会有一个定义 这个定义
And so the menu itself will get a def, that def

1303
01:12:37,810 --> 01:12:41,362
应该有项目 该项目将被传递到选择 
should have items, that items will get passed to the selection.

1304
01:12:44,140 --> 01:12:46,105
差不多就是这样 就是这样--
That's pretty much, that's it for the--

1305
01:12:46,105 --> 01:12:47,580
哦 还有进度条 
oh, progress bar as well.

1306
01:12:47,580 --> 01:12:51,440
当我们到达实际战斗状态时 我们将查看进度条 
We'll look at progress bars when we get to the actual battle state.

1307
01:12:51,440 --> 01:12:55,390
现在 让我们来看看几个类和数据结构
So now, let's take a look at a few of the classes and data structures

1308
01:12:55,390 --> 01:12:57,800
这与精灵宝可梦本身有关 
that are pertinent to the Pokemon themselves.

1309
01:12:57,800 --> 01:13:00,670
所以如果你把派对看成是头等舱的话 非常
So if you look at party as are first class, very

1310
01:13:00,670 --> 01:13:03,250
简单的类 字面意思就是这个--
simple class, literally just this--

1311
01:13:03,250 --> 01:13:07,060
在这一点上 self.pokemon是定义的 pokemon只是一个容器 
self.pokemon is def.pokemon is just a container at this point.

1312
01:13:07,060 --> 01:13:09,970
你可以拿着这个
You can take this--

1313
01:13:09,970 --> 01:13:12,640
我的意思是 即使在我认为是一场完整的比赛中 
I mean, even in I think a fully fleshed game,

1314
01:13:12,640 --> 01:13:15,850
你真的不需要比这更多的东西了 
you wouldn't really need much more than just this.

1315
01:13:15,850 --> 01:13:18,230
但是 如果您需要对这个想法进行进一步的扩展
But if you needed to expand upon this idea at all

1316
01:13:18,230 --> 01:13:21,700
你知道 保留为派对而存在的元数据 
and you know preserve metadata that exists for the party,

1317
01:13:21,700 --> 01:13:24,340
这将是一种完美的方式 
this would be a perfect way to do it.

1318
01:13:24,340 --> 01:13:31,390
实际的口袋妖怪类本身并不比有效的多很多
The actual pokemon class itself is not a whole lot more than effectively

1319
01:13:31,390 --> 01:13:33,400
一堆统计数据 
a bunch of stats.

1320
01:13:33,400 --> 01:13:36,240
这就是RPG的很多特点 
And that's a lot of what an RPG is.

1321
01:13:36,240 --> 01:13:38,876
这种类型--它主要是数字 
This genre is-- it's mostly just numbers.

1322
01:13:38,876 --> 01:13:40,750
你只是在把数字和数字进行比较
You're just comparing numbers against numbers

1323
01:13:40,750 --> 01:13:42,640
然后加入一卷骰子 
and then adding a roll of the dice.

1324
01:13:42,640 --> 01:13:46,690
实际上 这就是《地下城与龙》的大部分内容 
That's effectively, that's what Dungeons &amp; Dragons, a lot of it is.

1325
01:13:46,690 --> 01:13:47,696
那就是--是吗？
And that's-- yes?

1326
01:13:47,696 --> 01:13:49,630
观众：储存是不是更有意义？
AUDIENCE: Would it make more sense to store

1327
01:13:49,630 --> 01:13:57,100
只需每个级别和初始级别的增量 这样您就可以有更少的变量？
just delta per level and your initial one, so you can have fewer variables?

1328
01:13:57,100 --> 01:13:58,460
演讲者1：再说一遍 
SPEAKER 1: Say it one more time.

1329
01:13:58,460 --> 01:14:00,376
观众：这不是更有意义吗？
AUDIENCE: Wouldn't it make more sense, instead

1330
01:14:00,376 --> 01:14:03,150
存储您的HP和每个级别的所有内容
of storing your HP and everything for each level

1331
01:14:03,150 --> 01:14:06,490
要存储每个区域的初始统计数据 
to store your initial stats in each area,

1332
01:14:06,490 --> 01:14:09,990
以及每一关你会涨多少钱 
and how much you would go up per level.

1333
01:14:09,990 --> 01:14:14,080
演讲者1：把你增加的钱存起来会更有意义吗？
SPEAKER 1: Would it make more sense to store the amount that you go up

1334
01:14:14,080 --> 01:14:16,450
为你的精灵宝可梦每一级？
per level for your Pokemon?

1335
01:14:16,450 --> 01:14:19,070
是的 这就是我们正在做的 
Yes, that is what we're doing.

1336
01:14:19,070 --> 01:14:20,800
所以我们有一个基地--
So we have a base--

1337
01:14:20,800 --> 01:14:24,910
在这种情况下 统计数据的拆分是这样的 对吗？
so here's how the split works for the stats in this case, right?

1338
01:14:24,910 --> 01:14:28,860
我们有基础HP、基础攻击、基础防御和基础速度 
We have base HP, base attack, base defense, and base speed.

1339
01:14:28,860 --> 01:14:31,600
1级精灵有--0级精灵
A level 1 Pokemon has-- a level 0 Pokemon

1340
01:14:31,600 --> 01:14:35,800
有这个物种的这些统计数据 对吗？
has these stats of this species, right?

1341
01:14:35,800 --> 01:14:39,430
每一个竹子或我们选择的任何精灵宝可梦
Every Bamboon or whatever Pokemon that we choose

1342
01:14:39,430 --> 01:14:42,820
会有我们分配给它的任何东西作为它的基础HP 
will have whatever we've allocated it to be it's base HP,

1343
01:14:42,820 --> 01:14:45,280
基地 进攻 基地防御 基地速度 
base, attack, base defense, base speed.

1344
01:14:45,280 --> 01:14:50,500
然后关于精灵宝可梦和我的意思是 很多RPG
And then the thing about Pokemon and I mean, a lot of RPGs

1345
01:14:50,500 --> 01:14:52,660
会做这件事 但我们需要一些方法
will sort of do this thing, but we need some way

1346
01:14:52,660 --> 01:14:58,420
以一种必然不确定的方式升级精灵宝可梦 
of leveling up the Pokemon in an necessarily non-deterministic way.

1347
01:14:58,420 --> 01:15:02,782
就像两只升级的小猪可能有不同的统计数据 对吗？
Like two Piggies that level up may not have the same stats, right?

1348
01:15:02,782 --> 01:15:04,990
其中一个的攻击率可能比另一个略高 
One might have slightly higher attack than the other,

1349
01:15:04,990 --> 01:15:07,240
其中一个人的防御能力可能略高于另一个人 
one might have slightly higher defense than the other.

1350
01:15:07,240 --> 01:15:11,020
我们使用所谓的静脉注射来完成这项工作 这就是精灵宝可梦本身所做的事情 
We do this using what's called an IV, and that's what Pokemon itself does.

1351
01:15:11,020 --> 01:15:13,450
它是个人价值的缩写 这是一种
And it's short for individual value, this is sort of

1352
01:15:13,450 --> 01:15:16,810
就像你的精灵宝可梦的DNA一样 对吧？
like the DNA of your Pokemon, right?

1353
01:15:16,810 --> 01:15:23,420
所以这个HP IV与你的基础攻击、基础速度、基础等等是分开的 
So this HP IV is separate from your base attack, base speed, base et cetera.

1354
01:15:23,420 --> 01:15:26,890
基本上 每次都会将其与掷骰子进行比较
And this basically, it gets compared against a dice roll every time

1355
01:15:26,890 --> 01:15:28,480
你升级了三次 
you level up three times.

1356
01:15:31,610 --> 01:15:34,330
这就是我对它进行编程的方式 不一定
And this is how I've programmed it, it's not necessarily

1357
01:15:34,330 --> 01:15:38,890
精灵宝可梦本身是如何做到这一点的 但你要掷骰子六次 
how Pokemon itself does it, but you will roll a dice six times,

1358
01:15:38,890 --> 01:15:42,760
或者三次 一到六次 就像正常的死亡一样 
or three times, one through six like a normal die.

1359
01:15:42,760 --> 01:15:49,630
然后你会看看这个卷曲是否比你的静脉注射更大 对吗？
And you'll look to see if that roll is greater than your IV, right?

1360
01:15:49,630 --> 01:15:55,990
或者它会检查你的静脉输液是否小于或等于掷骰子 
Or it'll check to see whether your IV is less than or equal to that dice roll.

1361
01:15:55,990 --> 01:15:57,560
如果是的话 
And if it is--

1362
01:15:57,560 --> 01:16:00,640
或者抱歉 如果它大于或等于掷骰子 
or sorry, if it's greater than or equal to that dice roll.

1363
01:16:00,640 --> 01:16:06,580
如果是 它将为这三个掷骰子将该统计信息加1 
And if it is, it will increment that stat by 1 for those three dice rolls.

1364
01:16:06,580 --> 01:16:11,500
因此 您最多可以再获得三个 或者您可以增加状态
So you can get up to three more, or you can increase the stat

1365
01:16:11,500 --> 01:16:14,200
每级最多三次 
by up to three times per level.

1366
01:16:14,200 --> 01:16:16,990
但你最多只能打五针 
But you can only have an IV up to five.

1367
01:16:16,990 --> 01:16:23,056
所以你是在6的情况下滚动 而你偶尔不会滚动6 
So you're rolling against a six, and you will occasionally not roll a 6.

1368
01:16:23,056 --> 01:16:27,970
它会检查静脉输液是否
It checks to see whether or not the IV is

1369
01:16:27,970 --> 01:16:29,800
大于或等于掷骰子 
greater than or equal to the dice roll.

1370
01:16:29,800 --> 01:16:32,650
如果它不大于或等于事件中的掷骰子
And if it's not greater than or equal to the dice roll in the event

1371
01:16:32,650 --> 01:16:36,430
如果是六分 或者静脉注射到四分
that it is a six, or if the IV is up to a four

1372
01:16:36,430 --> 01:16:39,700
例如 这意味着五分或六分会反对它 
for example, which means a five or six will go against it,

1373
01:16:39,700 --> 01:16:41,770
那么它就不会得到统计数据的增长 
then it will not get a stat increase.

1374
01:16:41,770 --> 01:16:44,920
这是实现这个基于DNA的系统的一种简单方式 
And this is a sort of simple way of implementing this DNA based system.

1375
01:16:44,920 --> 01:16:47,320
它是随机的 但它是加权的 对吗？
It's randomized, but it's a weighted, right?

1376
01:16:47,320 --> 01:16:50,050
如果你有更高的静脉输液 你有更高的可能性
If you have a higher IV, you have a higher likelihood

1377
01:16:50,050 --> 01:16:53,350
大于或等于掷骰子的 
of being greater than or equal to the dice roll.

1378
01:16:53,350 --> 01:16:55,960
这就是我们如何实现统计增加 
And so that's how we implement stat increases.

1379
01:16:55,960 --> 01:17:03,130
然后我们需要一种方法来跟踪我们的统计数据 
And then we need a way of keeping track of what our stats are,

1380
01:17:03,130 --> 01:17:04,660
比如我们的实际数据
like our actual stats.

1381
01:17:04,660 --> 01:17:07,330
所以我们的实际HP 我们的实际攻击 我们的实际防御 
So our actual HP, our actual attack, our actual defense,

1382
01:17:07,330 --> 01:17:10,165
和一层一层计算出来的实际速度
and actual speed that's been calculated level by level,

1383
01:17:10,165 --> 01:17:11,665
我们需要一种方法来跟踪它 
we need a way to keep track of that.

1384
01:17:11,665 --> 01:17:14,190
我们需要等级 我们需要当前的XP 然后
We need level, we need our current XP, and then

1385
01:17:14,190 --> 01:17:15,940
我们需要我们的经验值
we need our-- and the amount of XP to gain

1386
01:17:15,940 --> 01:17:19,270
一级一级地越升越高 就像你在这里看到的 
a level, which will get higher and higher per level, as you can see here,

1387
01:17:19,270 --> 01:17:24,520
因为它吸收了自我 水平乘以自我 水平 
because it takes in the self.level times self.level.

1388
01:17:24,520 --> 01:17:28,150
然后乘以5乘以0.75 
And then it multiplies that by five times 0.75.

1389
01:17:28,150 --> 01:17:29,470
现在的HP 
And then your current HP.

1390
01:17:32,340 --> 01:17:38,230
所以我们并不是一层一层地存储我们的价值 
So we're really not storing our value level by level,

1391
01:17:38,230 --> 01:17:42,220
我们需要基地 因为我们需要知道我们的基地是什么 
we need the base because we need to know what our base was.

1392
01:17:42,220 --> 01:17:46,910
我的意思是 我们可以有效地全局引用这些变量 
I mean, we could effectively globally reference these variables,

1393
01:17:46,910 --> 01:17:49,810
但在这一点上 效率提升很小 
but it's minor efficiency gains at that point.

1394
01:17:49,810 --> 01:17:52,300
但我们需要静脉注射我们需要...
But we need the IVs and we need the--

1395
01:17:52,300 --> 01:17:56,050
我是说 我们需要静脉注射的参考资料 我们需要基础HP的参考资料 
I mean, we need a reference to the IVs, we need a reference to the base HP,

1396
01:17:56,050 --> 01:18:01,750
我们需要跟踪我们的实际数据 
and we need to keep track of whatever our actual stats are,

1397
01:18:01,750 --> 01:18:04,210
然后我们现在的HP总是 因为我们现在的HP
and then our current HP always, because our current HP

1398
01:18:04,210 --> 01:18:07,010
可能与我们的实际HP不同 
can differ from our actual HP.

1399
01:18:07,010 --> 01:18:10,690
在实际的游戏中 你可以有你的进攻 防守 
And in the actual game, you can have your attack, defense,

1400
01:18:10,690 --> 01:18:13,960
和速度也会随着比赛而变化 因为你
and speed also vary match by match, because you

1401
01:18:13,960 --> 01:18:17,770
降低你的速度 降低你的攻击 
have moves that lower your speed, lower your attack,

1402
01:18:17,770 --> 01:18:19,450
降低你的防御等等
lower your defense, et cetera.

1403
01:18:19,450 --> 01:18:21,200
在这种情况下 我们还没有实现这一点 
In this case, we haven't implemented that,

1404
01:18:21,200 --> 01:18:23,459
所以我们没有当前的攻击和防御
so we don't have a current attack, current defense.

1405
01:18:23,459 --> 01:18:26,500
但是在一个更完整的实现中 你会有这样的事情 
But in a more complete implementation, you would have that sort of thing.

1406
01:18:26,500 --> 01:18:28,125
这算是回答了你的问题吗
Does that sort of answer your question?

1407
01:18:28,125 --> 01:18:29,290
这是徒劳的吗？
Is that in the right vain?

1408
01:18:29,290 --> 01:18:29,790
好的.
OK.

1409
01:18:32,390 --> 01:18:35,020
这是升级代码 
And so here's the level up code.

1410
01:18:35,020 --> 01:18:38,200
就像我说的 掷三次骰子 一比三 
So like I said, three dice rolls, one to three.

1411
01:18:38,200 --> 01:18:43,450
如果6小于或等于IV 那么它可能是6 在这种情况下 
If six is less than or equal to our IV, so it could be a six, in which case,

1412
01:18:43,450 --> 01:18:47,160
它将大于最大IV可能的值 
it would be greater than what are max IV could possibly be.

1413
01:18:47,160 --> 01:18:52,150
静脉注射的范围从1到5 但如果它小于或等于静脉注射 
IVs range from one to five, but if it's less than or equal to that IV,

1414
01:18:52,150 --> 01:18:54,250
那我们就认为这是统计学上的增长
then we're going to consider that a stat increase.

1415
01:18:54,250 --> 01:19:03,490
这是一个加权的奇数 用来确定我们是否得到统计数据的提升 
It's a weighted odd to determine whether or not we get a stat boost.

1416
01:19:03,490 --> 01:19:07,340
它对每个统计数据都这样做 然后返回所有增加的数据 
And it does this for every stat, and then it returns all of the increases.

1417
01:19:07,340 --> 01:19:11,590
这是相关的 这一行95表示惠普的收益增加 
And this is relevant, this line 95 for a return HP increase,

1418
01:19:11,590 --> 01:19:13,540
回击增加进攻 增加防守 
return attack increase, defense increase.

1419
01:19:13,540 --> 01:19:16,690
这将与作业7相关 因为您的目标是
This will be relevant for assignment 7, because your goal is

1420
01:19:16,690 --> 01:19:20,650
在战斗中将这些增加并实际显示给这个用户
to take these increases and actually display them to this user in the battle

1421
01:19:20,650 --> 01:19:23,560
说明他或她什么时候取得胜利
state when he gets a victory, or he or she gets a victory

1422
01:19:23,560 --> 01:19:25,310
并且已经达到了一个级别 
and has gained a level.

1423
01:19:25,310 --> 01:19:29,740
您将显示一个菜单 其中的选项包含所有这些内容 
You will display a menu with a selection that has all of these things,

1424
01:19:29,740 --> 01:19:30,970
你需要这个值 
and you'll need this value.

1425
01:19:30,970 --> 01:19:36,550
所以它在这里返回这些值 您将以任何方式调用此函数
So it returns these values here, and you'll be calling this function any way

1426
01:19:36,550 --> 01:19:39,390
从你的战斗状态统计数据升级 
from your battle state stats level up.

1427
01:19:39,390 --> 01:19:45,310
或者我们将调用Level Up 它返回self stats Level Up 
Or we'll be calling level up rather, which returns self stats level up.

1428
01:19:45,310 --> 01:19:47,630
这就是精灵宝可梦的全部 
And that's all a Pokemon is.

1429
01:19:47,630 --> 01:19:50,700
它实际上主要是一种数据结构 
It's effectively mostly a data structure.

1430
01:19:50,700 --> 01:19:57,640
我们在战斗中用它来有效地来回掷骰子 
And we use this in our battles to throw dice effectively back and forth,

1431
01:19:57,640 --> 01:20:05,650
有胜利者和失败者 然后通过这种方式获得经验值和增益等级 
and have a victor and a loser, and then gain XP and gain levels that way.

1432
01:20:05,650 --> 01:20:09,490
那么 关于Pokemon对象类是如何工作的 有什么问题吗？
So any questions as to how a Pokemon object class works?

1433
01:20:12,370 --> 01:20:13,962
凉爽的 
Cool.

1434
01:20:13,962 --> 01:20:16,670
我们将快速了解一下实际定义是什么样子 
We'll take a quick look at what the actual definitions look like,

1435
01:20:16,670 --> 01:20:18,240
你大概可以猜到 
which you can probably take a guess.

1436
01:20:18,240 --> 01:20:20,870
这很简单 只是关键的名字 
It's very simple, just key names.

1437
01:20:20,870 --> 01:20:24,300
然后我们有真正的名字 我们有精灵的名字 
And then we have the actual name, we have the sprite names,

1438
01:20:24,300 --> 01:20:26,810
我们有HP 攻击 防御--
we have the HP, attack, defense--

1439
01:20:26,810 --> 01:20:29,390
所有被放入实际物体中的东西 
all the things that get put into the actual object,

1440
01:20:29,390 --> 01:20:31,700
它们需要在定义中被引用 
they need a reference to in the definitions.

1441
01:20:31,700 --> 01:20:34,101
所以精灵宝可梦最终只是这样 他们
And so Pokemon ultimately are just this, they're

1442
01:20:34,101 --> 01:20:37,100
就是数据 对 这就是我们在上一节课中谈到的 数据
just data, right, which is what we talked about in a prior lecture, data

1443
01:20:37,100 --> 01:20:38,210
驱动设计 
driven design.

1444
01:20:38,210 --> 01:20:40,220
你能拿到的口袋妖怪就越多
The more you can take all of your Pokemon

1445
01:20:40,220 --> 01:20:44,210
把它们做成精灵宝可梦或任何东西 
and make them into, or anything, Pokemon or any object,

1446
01:20:44,210 --> 01:20:47,270
并将其转换为易于编写的数据结构 
and turn it into an easy to write data structure like this,

1447
01:20:47,270 --> 01:20:49,040
您就越容易添加更多内容 
the easier it is for you to add more.

1448
01:20:49,040 --> 01:20:53,304
我们可以很容易地补充说 创建150个这样的设备不会花太长时间 
We could easily add, it wouldn't take too long to create 150 of these.

1449
01:20:53,304 --> 01:20:55,220
我是说 他们不会那么有趣的 
I mean, they wouldn't be all that interesting,

1450
01:20:55,220 --> 01:20:58,200
因为我们还没有实施行动 
because we don't have moves implemented yet.

1451
01:20:58,200 --> 01:21:03,800
但在一个理想的世界里 我们会找到一种方法来将移动也建模为数据 
But in an ideal world, we'd find a way to also model moves as data,

1452
01:21:03,800 --> 01:21:07,610
因此 您可以将移动链接到您的数据结构 
and therefore, you can just link moves to your data structure,

1453
01:21:07,610 --> 01:21:09,410
像这样给你的精灵宝可梦对象 
to your Pokemon object like this.

1454
01:21:09,410 --> 01:21:10,936
是的 托尼 你有问题吗？
Yes Tony, did you have a question?

1455
01:21:10,936 --> 01:21:13,310
听众：嗯 我只是想提一下这个悖论
AUDIENCE: Well, I just wanted to mention that the paradox

1456
01:21:13,310 --> 01:21:15,150
关于这一点 游戏是非常好的 
games are very good about that.

1457
01:21:15,150 --> 01:21:16,832
[听不见]
[INAUDIBLE]

1458
01:21:16,832 --> 01:21:18,290
演讲者1：哦 就像十字军吗？
SPEAKER 1: Oh, like Crusader Kings?

1459
01:21:18,290 --> 01:21:18,915
观众：是的 
AUDIENCE: Yeah.

1460
01:21:21,960 --> 01:21:25,590
演讲者1：评论是Paradox Games非常好的数据驱动设计 
SPEAKER 1: The comment was Paradox Games are very good about data driven design.

1461
01:21:25,590 --> 01:21:28,417
我猜你已经查过他们的档案了吧？
I'm assuming you've dug through their files?

1462
01:21:28,417 --> 01:21:30,250
观众：在某种程度上 这也只是
AUDIENCE: To some extent, and also it's just

1463
01:21:30,250 --> 01:21:33,927
如果你玩他们的游戏一段时间 它无处不在 在一定程度上
if you play their games for awhile, it's everywhere, like to the extent

1464
01:21:33,927 --> 01:21:36,260
有时他们会把源代码放在维基上 
that sometimes on the Wiki, they put the source code up.

1465
01:21:36,260 --> 01:21:37,880
演讲者1：哦 是的 
SPEAKER 1: Oh, yeah.

1466
01:21:37,880 --> 01:21:40,340
是的 不 这只是一个很好的游戏设计 
Yeah, no, it's just good game design.

1467
01:21:40,340 --> 01:21:41,880
最终 如果你想--
Ultimately, if you want to--

1468
01:21:41,880 --> 01:21:44,660
而且他们的游戏很大 他们有很多内容 
and their games are large, they have a lot of content.

1469
01:21:44,660 --> 01:21:46,901
如果你想在你的游戏中有很多内容 
If you want to have a lot of content in your game,

1470
01:21:46,901 --> 01:21:49,400
你需要找到一种方法减轻程序员的负担
you need to find a way to take the burden off the programmer

1471
01:21:49,400 --> 01:21:51,316
并把它放在设计师身上 或者至少让
and put it onto the designer, or at least make

1472
01:21:51,316 --> 01:21:53,650
这对程序员来说更容易 因为编写源代码
it easier for the programmer, because making source code

1473
01:21:53,650 --> 01:21:56,899
整天调试源代码 特别是对于非常复杂的事情
and debugging source code all day long, especially for very complicated things

1474
01:21:56,899 --> 01:21:57,740
这不是一件容易的事 
is not easy.

1475
01:21:57,740 --> 01:22:01,100
而且这最终也不是我们想要做的事情 对吗？
And it's ultimately not a desired thing to do, right?

1476
01:22:01,100 --> 01:22:04,610
对我来说 在10行代码中创建一个新生物要容易得多
It's a lot easier for me to whip up a new creature in 10 lines of code

1477
01:22:04,610 --> 01:22:10,700
在这里感觉很好 而不是硬编码很多这样的东西 
here and feel good about it than hard coding a lot of these sort of things,

1478
01:22:10,700 --> 01:22:11,780
对吗？
right?

1479
01:22:11,780 --> 01:22:17,000
因此 将尽可能多的数据转换为数据应该是您的最终目标 
So shifting as much of it to data as you possibly can should be your end goal.

1480
01:22:17,000 --> 01:22:19,670
所以这就是精灵宝可梦防御者的样子 
So that's what Pokemon defs look like.

1481
01:22:19,670 --> 01:22:21,565
在我们进入实际战斗之前 我们想要
Before we get into the actual battle, we want

1482
01:22:21,565 --> 01:22:23,420
来看看什么是战斗精灵 
to take a look at what a battle sprite is.

1483
01:22:23,420 --> 01:22:27,470
所以战斗精灵就是呈现在屏幕上的东西 对吗？
So a battle sprite is what was rendering onto the screen, right?

1484
01:22:27,470 --> 01:22:29,720
所以我们来看看这个 
So we take a look here.

1485
01:22:29,720 --> 01:22:33,920
那不是战斗精灵 而是几乎是战斗精灵 
That's not a battle sprite, but almost a battle sprite.

1486
01:22:33,920 --> 01:22:35,900
那只是一种质感 
That was just a texture.

1487
01:22:35,900 --> 01:22:43,160
因此 如果我们陷入一场战斗 速度缓慢但却是肯定的 
So if we get into a battle, slowly but surely.

1488
01:22:43,160 --> 01:22:46,850
好了 这些是战斗精灵 它们看起来没什么不同
All right, so these are battle sprites, and they don't look much different

1489
01:22:46,850 --> 01:22:48,980
比普通的雪碧还多 而且它们也没有那么多
than a regular sprite, and they're not that much

1490
01:22:48,980 --> 01:22:50,630
不同于普通的雪碧 
different than a regular sprite.

1491
01:22:50,630 --> 01:22:55,940
但它们有一些重要的功能 主要是那些功能
But they have some functionality that's important, mainly that functionality

1492
01:22:55,940 --> 01:23:01,760
其中一个是闪烁的 然后是不透明的 对吗？
where one is flashing, and then one was being opaque, right?

1493
01:23:01,760 --> 01:23:07,730
因此 为了做到这两点 我们需要存储某种类型的数据
So in order to do both of those things, we need to store some sort of data

1494
01:23:07,730 --> 01:23:09,850
在我们的精灵里 对吗？
within our sprite, right?

1495
01:23:09,850 --> 01:23:10,964
是?
Yes?

1496
01:23:10,964 --> 01:23:14,470
观众：塞尔达的无敌闪光灯 
AUDIENCE: Zelda for the invulnerability flashing.

1497
01:23:14,470 --> 01:23:15,470
演讲者1：是的 完全正确 
SPEAKER 1: Yes, exactly.

1498
01:23:15,470 --> 01:23:18,050
我们在塞尔达使用的无懈可击的闪光 
For what we used in Zelda for the invulnerability flashing.

1499
01:23:18,050 --> 01:23:24,560
对敌人来说 或者我应该说 对被攻击的人来说 是的 
For the enemy, or I should say, for whoever is getting attacked, yes.

1500
01:23:24,560 --> 01:23:28,080
他们正在存储一面不透明的旗帜 
They are getting an opacity flag stored.

1501
01:23:28,080 --> 01:23:32,730
他们的对象中存储了一个不透明标志 我们可以对其进行补间 
They have an opacity flag stored in their object that we can tween, right,

1502
01:23:32,730 --> 01:23:34,730
我们可以随着时间的推移分分合合 
we can tween on and off over the course of time.

1503
01:23:34,730 --> 01:23:38,074
当塞尔达的实体受到伤害时 我们就是这么做的 
That's what we did with the entity in Zelda when it took damage.

1504
01:23:38,074 --> 01:23:40,615
我们把它设置为无懈可击 虽然它是无懈可击的 
And we set it to invulnerable, and while it was invulnerable,

1505
01:23:40,615 --> 01:23:42,320
它在断断续续地闪烁 
it was flashing on and off.

1506
01:23:42,320 --> 01:23:47,930
但我们不能用闪烁着白色的精灵做到这一点 
But we can't necessarily do that with the sprite that's blinking white,

1507
01:23:47,930 --> 01:23:52,970
因为这不是真正的白旗 对吧？
because there's not really a like white flag, right?

1508
01:23:52,970 --> 01:23:55,760
我们不能只用一面旗帜就把东西变成全白的 
We can't make something completely white with just a flag.

1509
01:23:55,760 --> 01:23:59,060
这是我们实际上需要使用着色器的东西 
That's something that we actually need to use a shader for.

1510
01:23:59,060 --> 01:24:03,200
这是一个着色器 我们不会深入到这方面的太多细节 
And so a shader, and we're not going to get into too much detail about this,

1511
01:24:03,200 --> 01:24:07,520
着色器相当复杂 一开始有点神秘 
shaders are pretty complex, a little arcane at first.

1512
01:24:07,520 --> 01:24:10,340
但它们实际上是一个小程序 
But what they are is effectively a little program that

1513
01:24:10,340 --> 01:24:13,520
在你的显卡上运行 当你在画东西的时候 它会看起来
runs on your graphics card, and that looks at when you're drawing something,

1514
01:24:13,520 --> 01:24:16,400
它会查看每个像素 具体取决于您使用的着色器类型 
it looks at every pixel depending on what kind of shader you're doing.

1515
01:24:16,400 --> 01:24:19,130
但为了演示 我们将查看每个像素
But for the sake of this demonstration, we'll look at every pixel

1516
01:24:19,130 --> 01:24:23,510
你正在绘制到屏幕上 并执行某种功能
that you're drawing to the screen, and perform some sort of function

1517
01:24:23,510 --> 01:24:27,890
并产生一个新的值 对吗？
on that pixel, and produce a new value, right?

1518
01:24:27,890 --> 01:24:31,610
这就是你如何让很多疯狂的可怕的事情发生 
And this is how you get a lot of really crazy awesome things to happen,

1519
01:24:31,610 --> 01:24:34,350
但这可能是相当疯狂的 
but it can be pretty insane.

1520
01:24:34,350 --> 01:24:39,482
Shader Toy 我认为是一个拥有大量非常酷的--
Shader Toy, I think is the website that has a ton of really cool--

1521
01:24:39,482 --> 01:24:42,440
我不会因为我不记得名字就把它拔出来 
I'm not going to pull it up now, just 'cause I don't remember the name,

1522
01:24:42,440 --> 01:24:44,000
我相信这是着色器玩具 
I believe it's shader toy.

1523
01:24:44,000 --> 01:24:47,041
有一个网站 人们在那里发布他们编写的所有着色器 
There's a website where people post all the shaders that they've written,

1524
01:24:47,041 --> 01:24:49,460
你可以看到很多非常疯狂的东西 
and you can see a lot of really crazy stuff, things

1525
01:24:49,460 --> 01:24:53,720
这是您无法想象的 仅用这样的代码就可以
that you would never imagined were possible with just code like this

1526
01:24:53,720 --> 01:24:56,150
有效地 查看像素的位置
effectively, looking at positions of pixels

1527
01:24:56,150 --> 01:24:58,670
和[？图片？]在屏幕上什么的 
and [? pictures ?] on the screen and whatnot.

1528
01:24:58,670 --> 01:25:05,450
但这实际上是一个白色着色器 这个着色器的目标是
But effectively what this does, this is a white shader, the goal of this shader

1529
01:25:05,450 --> 01:25:07,490
就是把一个精灵完全变白 
is to just turn a sprite completely white.

1530
01:25:07,490 --> 01:25:10,610
这就是该着色器的所有目标 
That's all the goal of this shader is.

1531
01:25:10,610 --> 01:25:14,390
所以它得到了一个叫做白色因子的浮点 哪个[？你会吗？]就这么说吧 
So it gets a float called white factor, which [? you'd ?] say here.

1532
01:25:14,390 --> 01:25:17,240
那么白人因素实际上就是
And then white factor effectively is just

1533
01:25:17,240 --> 01:25:20,810
会被归结为RGB是什么
going to be summed onto whatever the RGB is

1534
01:25:20,810 --> 01:25:25,350
当着色器处于活动状态时 我们绘制的任何像素 
of that pixel, whatever pixel that we're drawing when the shader is active.

1535
01:25:25,350 --> 01:25:29,990
这样做的效果是 如果它等于1 那么就是白色因子 
What that has the effect of doing is, white factor, if it's equal to 1.

1536
01:25:29,990 --> 01:25:32,720
这是关于着色器和许多这类东西的事情 
Here's the thing about shaders and a lot of this stuff,

1537
01:25:32,720 --> 01:25:35,240
着色器中的许多数据结构
a lot of the data structures within shaders

1538
01:25:35,240 --> 01:25:37,890
基于从0到1的浮点数 
are based on floats that are from zero to one.

1539
01:25:37,890 --> 01:25:43,790
因此 如果我们将某物的RGB赋给vec 3 即1 即111 
So if we assign the RGB of something to a vec 3 that's 1, which is 111,

1540
01:25:43,790 --> 01:25:46,520
那将是255,255,255 
that's going to be 255, 255, 255.

1541
01:25:46,520 --> 01:25:50,660
所以 那个像素RGB是白色的 纯白的 对吧？
Therefore, that pixels RGB is white, pure white, right?

1542
01:25:50,660 --> 01:25:58,460
所以我们在这里做的是在我们的战斗精灵上 自己眨眼
And so what we're doing here is on our battle sprite, self.blinking

1543
01:25:58,460 --> 01:26:01,775
1或0 记住 这是Lua[？Turnerri？]行动 
and one or zero, remember, that's the LUA [? turnerri ?] operations.

1544
01:26:01,775 --> 01:26:07,070
所以我们说 如果自我眨眼是真的 那么另一个是零 
So we're saying, if self.blinking is true, one else zero.

1545
01:26:07,070 --> 01:26:15,860
因此 发送我们的着色器基于任何值本身的白色因素 闪烁 
So send our shader white factor based on whatever value self.blinking is.

1546
01:26:15,860 --> 01:26:19,700
这将产生着色器获得1或0的效果 
And so that will have the effect of the shader getting a one or a zero,

1547
01:26:19,700 --> 01:26:22,400
并将1或0加到那个精灵的RGB上 
and adding a one or a zero to the RGB of that sprite.

1548
01:26:22,400 --> 01:26:25,670
如果闪烁设置为真 则精灵的
And if blinking is set to true, the sprite's

1549
01:26:25,670 --> 01:26:29,270
基本上是在255,255,255的每个像素上绘制 
going to basically be drawn every pixel at 255, 255, 255.

1550
01:26:29,270 --> 01:26:33,500
否则 它将使用该图像的像素值绘制
Otherwise, it'll get drawn with whatever that image's pixel value is

1551
01:26:33,500 --> 01:26:35,085
在那个位置 
at that position.

1552
01:26:35,085 --> 01:26:37,220
这说得通吗？
Does that makes sense?

1553
01:26:37,220 --> 01:26:37,907
好的 
OK.

1554
01:26:37,907 --> 01:26:39,740
语法有点奇怪 但那是
The syntax is a little bit weird, but that's

1555
01:26:39,740 --> 01:26:42,020
在此着色器中发生的情况 
what's happening here in this shader.

1556
01:26:42,020 --> 01:26:44,540
这里有一个我找到着色器的链接 
And there's a link here where I found the shader,

1557
01:26:44,540 --> 01:26:47,960
但这是一个非常简单的着色器 
but it's a very simple, very simple shader,

1558
01:26:47,960 --> 01:26:50,840
可能是您可以编写的最简单的着色器之一 
probably like one of the simplest shaders you could write.

1559
01:26:50,840 --> 01:26:55,460
但这是一个很好的例子 说明了您可以使用着色器做什么 而且非常简单 
But it's a great example of what you can do with a shader, and pretty simply.

1560
01:26:55,460 --> 01:26:59,210
这很好 因为你可以用纹理坐标做数学运算
And it's nice, because you can take like texture coordinates and do math

1561
01:26:59,210 --> 01:27:02,060
以此为基础 或者像素坐标 并在此基础上进行数学运算 
based on that, or pixel coordinates and do math based on that.

1562
01:27:02,060 --> 01:27:04,910
例如 在您的文件中 您可以像正弦函数一样传入
You can pass in like a sine function for example, in your file,

1563
01:27:04,910 --> 01:27:09,379
并使正弦函数对子画面RG或B值执行运算
and have that sine function perform work on like RG or B value of your sprite

1564
01:27:09,379 --> 01:27:10,670
做各种很酷的事情 
and do all kinds of cool stuff.

1565
01:27:10,670 --> 01:27:14,154
它真的很整洁 就像着色器的可能性是无限的 
It's really neat, like the possibilities are limitless with shaders.

1566
01:27:14,154 --> 01:27:16,070
但这就是我们让它眨眼的方式 因为你
But that's how we get it to blink, because you

1567
01:27:16,070 --> 01:27:18,410
除了这个 我不能这么做--
can't do that outside of this--

1568
01:27:18,410 --> 01:27:21,830
我是说 可能有一些奇怪的方法也能让它起作用 
I mean, there's probably some weird way could get it to work as well,

1569
01:27:21,830 --> 01:27:28,820
但这可能是让我们的精灵闪烁白色的最简单的方法 
but this is probably the simplest way we can get our sprites blinking white.

1570
01:27:28,820 --> 01:27:36,890
所以自我 眨眼只会得到一个计时器 每0.1个或其他什么 
And so self.blinking just gets a timer.every0.1 or whatever.

1571
01:27:36,890 --> 01:27:41,010
我们将在攻击状态下看到这一点 
We'll actually see that in the attack state.

1572
01:27:41,010 --> 01:27:45,350
但那会闪到自己 在真与假之间眨眼 
But that'll flick to self.blinking between true and false.

1573
01:27:45,350 --> 01:27:49,150
它会一次又一次地否定自己 
It'll negate itself over and over again.

1574
01:27:49,150 --> 01:27:51,590
好了 这就是战斗精灵 
All right, so that's the battle sprite.

1575
01:27:51,590 --> 01:27:56,180
最后我们要看的是另一个非常简单的类 对手 
Last thing we'll look at is another extremely simple class, opponent.

1576
01:27:56,180 --> 01:27:59,370
所有的对手就是它有一个政党 仅此而已 
All the opponent is is it has a party, that's it.

1577
01:27:59,370 --> 01:28:01,370
但在一场全面的比赛中 你的对手
But in a fully fleshed game, your opponent

1578
01:28:01,370 --> 01:28:03,680
可能会有一个像训练师一样的精灵 
might have a like trainer sprite.

1579
01:28:03,680 --> 01:28:06,185
一条信息 它说 就像一个完整的派对
A message that it says, like a full party

1580
01:28:06,185 --> 01:28:08,810
精灵宝可梦 当你打败它时 它会给你带来黄金价值 
of Pokemon, a gold value that will give you when you defeat it,

1581
01:28:08,810 --> 01:28:09,643
各种各样的事情 
all kinds of things.

1582
01:28:09,643 --> 01:28:12,020
但它在这里只是作为一个简单的说明 
But it's here just as a simple illustration.

1583
01:28:12,020 --> 01:28:12,520
嗯?
Yeah?

1584
01:28:12,520 --> 01:28:14,925
观众：[听不见]用一种方法来应对失败
AUDIENCE: [INAUDIBLE] put a method for on defeat

1585
01:28:14,925 --> 01:28:17,540
如果你想让它崩溃的话
if you want to maybe have it kind of collapse

1586
01:28:17,540 --> 01:28:19,266
房间或类似的东西 
the room or something like that.

1587
01:28:19,266 --> 01:28:21,260
这将是你可以做的另一件事 
That would be another thing that you could do.

1588
01:28:21,260 --> 01:28:22,260
演讲者1：哦 一种方法？
SPEAKER 1: Oh, a method?

1589
01:28:22,260 --> 01:28:26,780
是的 我们可以把一种方法和一种叫做失败的对手联系起来 
Yeah, we can associate a method with an opponent called on defeat,

1590
01:28:26,780 --> 01:28:29,959
或者什么都不会做武断的事情 把房间弄塌 
or whatnot that will do arbitrary things, collapse the room,

1591
01:28:29,959 --> 01:28:30,500
或者是其他原因 
or otherwise.

1592
01:28:30,500 --> 01:28:31,910
是的 绝对的 
Yes, absolutely.

1593
01:28:31,910 --> 01:28:34,250
或者甚至推动一个新的状态 就像传送
Or even push a new state, like to like teleport

1594
01:28:34,250 --> 01:28:36,299
世界地图上的一个新位置 
us to a new location in the world map.

1595
01:28:36,299 --> 01:28:38,090
也许我们就像淘汰了精英四人组
Maybe we like cleared the elite four and we

1596
01:28:38,090 --> 01:28:42,590
想要传送到喜欢的结束字幕 确切地说 
want to get teleported to like the end credits, exactly.

1597
01:28:42,590 --> 01:28:45,150
无限的可能性 
Limitless possibility.

1598
01:28:45,150 --> 01:28:48,860
那么让我们继续下去看看吧 我们还有20分钟的时间
So let's go ahead and take a look now while we have just like 20 more minutes

1599
01:28:48,860 --> 01:28:49,390
或者说离开了 
or so left.

1600
01:28:49,390 --> 01:28:51,764
我们来看看战斗状态 因为这场战斗
We'll take a look at the battle state, because the battle

1601
01:28:51,764 --> 01:28:56,930
州和他们所处的州可能是更复杂的一面
state and the states that they're in are probably the more complicated side

1602
01:28:56,930 --> 01:28:59,340
这是如何运作的 
of how this works.

1603
01:28:59,340 --> 01:29:03,282
所以在战斗状态下 我们有一个玩家 我们有一个底部面板 底部面板
So a battle state, we have a player, we have a bottom panel, the bottom panel

1604
01:29:03,282 --> 01:29:05,240
因为当我们仅仅为了这一部分而启动州时 
for when we start the state just for that part,

1605
01:29:05,240 --> 01:29:08,720
但除此之外 我们总是把事情往上推 
but otherwise, we're always pushing things onto it.

1606
01:29:08,720 --> 01:29:14,200
不管我们是否已经开始战斗 因为当我们逐渐淡出时--
Whether we've started the battle or not, because when we are fading in--

1607
01:29:14,200 --> 01:29:16,700
抱歉 是的 
sorry, yeah.

1608
01:29:16,700 --> 01:29:28,710
因为当我们初始化这个状态时 我们还会将淡出状态添加到它上面 
Because when we initialize this state, we also push a fadeout state onto it.

1609
01:29:28,710 --> 01:29:32,930
但我们不想触发精灵宝可梦的滑行
But we don't want to trigger the tween of the Pokemon sliding

1610
01:29:32,930 --> 01:29:35,360
从左到右 直到该状态被弹出 
from left to right until after that state gets popped.

1611
01:29:35,360 --> 01:29:38,600
因此 我们在这里有一个标志 它将在第一次更新时设置为真
So we have a flag here, which will get set to true on the very first update

1612
01:29:38,600 --> 01:29:39,500
迭代 
iteration.

1613
01:29:39,500 --> 01:29:41,450
然后 当它设置为真时 我们将
And then when that gets set to true, we'll

1614
01:29:41,450 --> 01:29:44,180
实际上 在精灵宝可梦从左到右之间 
actually tween the Pokemon going left to right,

1615
01:29:44,180 --> 01:29:46,610
并启动所有其他类型的异步进程
and kick off all the other sort of asynchronous processes

1616
01:29:46,610 --> 01:29:50,250
在那之后存在的 
that exist thereafter.

1617
01:29:50,250 --> 01:29:56,330
但让我们再来看看这场战斗 看看发生了什么 
But let's look at the battle one more time just to see what's going on.

1618
01:29:56,330 --> 01:29:58,940
所以我要一直走下去 直到我投入战斗 
So I'm going to walk until I get into a battle.

1619
01:29:58,940 --> 01:29:59,910
好了 这是一场战斗 
OK, we got a battle.

1620
01:29:59,910 --> 01:30:05,200
所以请注意 淡入发生在--
So notice here, the fade in happens as soon as the--

1621
01:30:05,200 --> 01:30:08,160
当淡出开始时 滑行就会发生 对吧 
the slide in happens as soon as the fade starts, right,

1622
01:30:08,160 --> 01:30:10,402
一旦褪色结束 我应该说 
as soon as the fade finishes, I should say.

1623
01:30:10,402 --> 01:30:12,360
我们会在屏幕上弹出一条信息 对吗？
We get a message popped onto the screen, right?

1624
01:30:12,360 --> 01:30:14,550
它说出现了一个狂野的X 
It says a wild X appears.

1625
01:30:14,550 --> 01:30:16,040
对 那就是敌人的精灵宝可梦 
Right, that's the enemy Pokemon.

1626
01:30:16,040 --> 01:30:17,370
我们按了回车键 
We hit Enter.

1627
01:30:17,370 --> 01:30:19,140
把这个关小一点 
Turn this down a little bit.

1628
01:30:19,140 --> 01:30:21,930
我们按回车键 然后弹出另一个--
We hit Enter, and then we pop another--

1629
01:30:21,930 --> 01:30:24,600
将另一个状态推送到堆栈上 另一个战斗消息 
push another state onto the stack, another battle message, which

1630
01:30:24,600 --> 01:30:26,100
与对话状态非常相似 
is very similar to a dialog state.

1631
01:30:26,100 --> 01:30:30,030
说加油我们的精灵宝可梦 
Says go our Pokemon.

1632
01:30:30,030 --> 01:30:34,080
然后我们把菜单推到屏幕上 对吗？
And then we push a menu onto the screen, right?

1633
01:30:34,080 --> 01:30:37,190
我们有一个菜单 上面写着 要么战斗 要么逃跑 可供选择 
We've got a menu that says, fight or run, a selection.

1634
01:30:37,190 --> 01:30:39,230
这是一份菜单 里面有很多选择 
It's a menu, which has a selection.

1635
01:30:39,230 --> 01:30:42,420
然后 现在 这是堆栈的顶部 对吗？
And then now, this is the top of the stack, right?

1636
01:30:42,420 --> 01:30:44,470
所以这是唯一得到输入的东西 
So it's the only thing getting input.

1637
01:30:44,470 --> 01:30:48,096
其他一切都在它下面渲染 但没有任何东西得到输入 
Everything else is rendering beneath it, but nothing's getting input.

1638
01:30:48,096 --> 01:30:49,970
因此 我们可以选择要么战斗 要么逃跑 
So we have the option to either fight or run.

1639
01:30:49,970 --> 01:30:51,170
比方说我们打架 
Let's say we fight.

1640
01:30:51,170 --> 01:30:55,802
我们战斗 我们现在有了一个新的状态 我们处于攻击状态 
We fight, we got a new state now, we're in an attack state.

1641
01:30:55,802 --> 01:30:57,010
刚刚发生了几件事 
Several things just happened.

1642
01:30:57,010 --> 01:31:01,880
那么 一旦我们启动攻击状态 会发生什么？
So what happens as soon as we kick off the attack state?

1643
01:31:01,880 --> 01:31:02,380
嗯?
Yeah?

1644
01:31:02,380 --> 01:31:04,745
观众：你会看到一个文本框 上面写着 x攻击y 
AUDIENCE: You get a text box saying, x attacked y.

1645
01:31:04,745 --> 01:31:06,870
演讲者1：是的 所以我们要做的第一件事
SPEAKER 1: Yep, so the first thing we have happened

1646
01:31:06,870 --> 01:31:10,385
是一个文本框 上面写着 x攻击y 其中
is, a text box that says, x attacked y, where

1647
01:31:10,385 --> 01:31:12,510
要么是我们 要么是对手 因为这是
it could be either us or the opponent, because it's

1648
01:31:12,510 --> 01:31:14,700
根据谁的速度更快 
based on whoever has the higher speed.

1649
01:31:14,700 --> 01:31:16,612
接下来会发生什么呢？
And then what happens next?

1650
01:31:16,612 --> 01:31:17,950
观众：[听不见] 
AUDIENCE: [INAUDIBLE].

1651
01:31:17,950 --> 01:31:19,140
演讲者1：是的 确实如此 
SPEAKER 1: Well, it does.

1652
01:31:19,140 --> 01:31:21,600
所以让我们现在就来看看它 告诉你
So let's take a look at it right now and tell

1653
01:31:21,600 --> 01:31:24,750
告诉我文本框一弹出到底会发生什么 
me what exactly happens as soon as the text box pops up.

1654
01:31:27,750 --> 01:31:30,940
那么发生在那里的碎片是什么呢？
So what were the pieces that happened there?

1655
01:31:30,940 --> 01:31:31,800
观众：闪电侠 
AUDIENCE: Flash.

1656
01:31:31,800 --> 01:31:34,260
演讲者1：好的 袭击者闪烁白色 
SPEAKER 1: OK, so the attacker flashes white,

1657
01:31:34,260 --> 01:31:36,220
对 这就是我们看到的着色器 
right, which is the shader that we looked at.

1658
01:31:36,220 --> 01:31:38,080
这是着色器闪烁和关闭 
That's the shader blinking on and off.

1659
01:31:38,080 --> 01:31:41,970
有一些计时器显示 每隔0.1秒 闪烁或关闭 
There's some timer that says, every 0.1 seconds, blink on or off.

1660
01:31:41,970 --> 01:31:43,610
然后会发生什么呢？
And then what happens?

1661
01:31:43,610 --> 01:31:46,660
观众：那么伤害就已经造成了 [听不见]..
AUDIENCE: Then the damage is dealt. [INAUDIBLE]..

1662
01:31:46,660 --> 01:31:50,220
演讲者1：嗯 伤害已经造成了 是的 但是在视觉上发生了什么
SPEAKER 1: Well, damage is dealt, yes, but what happens visually as soon

1663
01:31:50,220 --> 01:31:53,669
当白色闪烁的时候？
as the white blinks?

1664
01:31:53,669 --> 01:31:54,960
观众：另一个在眨眼 
AUDIENCE: The other one blinks.

1665
01:31:54,960 --> 01:31:56,293
扬声器1：另一个在眨眼 
SPEAKER 1: The other one blinks.

1666
01:31:56,293 --> 01:31:59,415
另一个是什么在眨眼？
What's the other one blinking?

1667
01:31:59,415 --> 01:32:00,390
观众：我不确定 
AUDIENCE: I'm not sure.

1668
01:32:00,390 --> 01:32:02,067
演讲者1：所以这是不透明的 对吗？
SPEAKER 1: So it's opacity, right?

1669
01:32:02,067 --> 01:32:05,150
所以请记住 我们正在做的事情与刚才对白人所做的完全相同 
So remember, we're doing the exact same thing we just did with that white,

1670
01:32:05,150 --> 01:32:08,900
眨眼 但我们每0.1秒就调整一次
with the blinking, but we're tweening every 0.1 seconds

1671
01:32:08,900 --> 01:32:11,750
保卫精灵宝可梦的不透明 
the opacity of the defending Pokemon.

1672
01:32:11,750 --> 01:32:13,677
然后我们就会受到损害 
And then we take damage.

1673
01:32:13,677 --> 01:32:15,260
那么当我们受到伤害时会发生什么呢？
Then what happens when we take damage?

1674
01:32:15,260 --> 01:32:17,520
观众：基本上是相反的 
AUDIENCE: The reverse basically.

1675
01:32:17,520 --> 01:32:20,510
演讲者1：嗯 当东西受到损坏时 什么会被激活？
SPEAKER 1: Well, what gets animated when the thing takes damage?

1676
01:32:20,510 --> 01:32:22,880
我们已经制作了闪烁的动画 我们制作了不透明度的动画 
We've animated the blinking, we've animated the opacity.

1677
01:32:22,880 --> 01:32:24,550
观众：[听不见] 
AUDIENCE: [INAUDIBLE].

1678
01:32:24,550 --> 01:32:26,240
演讲者1：健康条下降了 对吧？
SPEAKER 1: The health bar drops, right?

1679
01:32:26,240 --> 01:32:28,100
所以我们把几件事联系在一起 
So we're chaining several things together.

1680
01:32:28,100 --> 01:32:32,760
我们在链接--首先 我们每0.1秒做一次 共六次 
We're chaining-- first, we're doing them every 0.1 seconds for six times,

1681
01:32:32,760 --> 01:32:34,430
闪烁白色 
blink white.

1682
01:32:34,430 --> 01:32:37,982
然后眨眼另一件不透明的东西 对吗？
Then blink the other thing opacity, right?

1683
01:32:37,982 --> 01:32:40,190
我们同时也在播放音效 
And we're playing sound effects at the same time too,

1684
01:32:40,190 --> 01:32:43,190
我们正在为攻击播放音效 为命中播放音效 
we're playing a sound effect for the attack, sound effect for the hit.

1685
01:32:43,190 --> 01:32:46,750
一旦完成 就在健康吧之间 对吧？
And then once that's finished, tween the health bar, right?

1686
01:32:46,750 --> 01:32:51,050
所以我们已经修改了防御精灵宝可梦的生命值 
So we've modified the health of the defending Pokemon.

1687
01:32:51,050 --> 01:32:54,856
然后在第一个过程之后发生什么 在那个过程完成之后 
And then what happens after the first one, after that process is finished.

1688
01:32:57,724 --> 01:32:59,640
观众：对另一边重复一遍？
AUDIENCE: Repeat for the other side?

1689
01:32:59,640 --> 01:33:04,410
演讲者1：完全正确 重复完全相同的事情 但在另一边 
SPEAKER 1: Exactly, repeat the exact same thing, but for the other side.

1690
01:33:04,410 --> 01:33:06,530
但我们在这两者之间做了什么呢？
But what are we doing in between each of those?

1691
01:33:06,530 --> 01:33:07,530
我们得做点什么 
We have to do something.

1692
01:33:07,530 --> 01:33:08,730
观众：检查是否有人死亡 
AUDIENCE: Checking if somebody dies.

1693
01:33:08,730 --> 01:33:10,646
演讲者1：准确地说 检查是否有人死亡 
SPEAKER 1: Checking if somebody dies, exactly.

1694
01:33:10,646 --> 01:33:12,840
如果有人死了--
And if somebody dies--

1695
01:33:12,840 --> 01:33:14,890
假设我们死了 会发生什么？
let's say we die, what happens?

1696
01:33:14,890 --> 01:33:16,710
观众：[听不见] 
AUDIENCE: [INAUDIBLE].

1697
01:33:16,710 --> 01:33:19,140
演讲者1：嗯 我们是的 我们回到播放状态 
SPEAKER 1: Well, we yeah, we go back to the play state.

1698
01:33:19,140 --> 01:33:22,170
我们淡出到黑色 然后我们回到播放状态 
We fade out to black, and then we go back to the play state.

1699
01:33:22,170 --> 01:33:24,536
如果我们消灭敌人会发生什么？
What happens if we knock out the enemy?

1700
01:33:24,536 --> 01:33:25,894
观众：转到这个屏幕 
AUDIENCE: Go to this screen.

1701
01:33:25,894 --> 01:33:28,060
演讲者1：没错 这个屏幕上会发生什么？
SPEAKER 1: Exactly, and what happens on this screen?

1702
01:33:28,060 --> 01:33:29,750
那么 第一件发生的事情是什么？
So what's the first thing that happens?

1703
01:33:29,750 --> 01:33:32,387
那么 回想一下 精灵宝可梦死的时候发生了什么？
Well, so recall, what happened when the Pokemon died?

1704
01:33:32,387 --> 01:33:32,970
发生了什么？
What happened?

1705
01:33:32,970 --> 01:33:34,678
观众：它从站台上掉了下来 
AUDIENCE: It fell off its platform thing.

1706
01:33:34,678 --> 01:33:39,060
演讲者1：没错 所以这可能是他的y值的一个区间 
SPEAKER 1: Exactly, so that's a tween probably, right, on his y value.

1707
01:33:39,060 --> 01:33:40,550
然后会发生什么呢？
Then what happens?

1708
01:33:40,550 --> 01:33:42,270
观众：[听不见] 
AUDIENCE: [INAUDIBLE].

1709
01:33:42,270 --> 01:33:46,120
演讲者1：没错 我们把一个战斗信息状态推到了屏幕上 
SPEAKER 1: Exactly, we've pushed a battle message state onto the screen.

1710
01:33:46,120 --> 01:33:48,756
然后当我们按Enter键时会发生什么？
And then what happens when we press Enter?

1711
01:33:48,756 --> 01:33:50,301
观众：[听不见] 
AUDIENCE: [INAUDIBLE].

1712
01:33:50,301 --> 01:33:52,050
演讲者1：刚才发生了什么？
SPEAKER 1: What just happened right there?

1713
01:33:52,050 --> 01:33:53,758
观众：[听不见]文本框上写着 
AUDIENCE: [INAUDIBLE] text box that says,

1714
01:33:53,758 --> 01:33:55,400
你得到了所有的经验点 
you earned whatever experience points.

1715
01:33:55,400 --> 01:33:57,645
然后你的XP就会升级 
Then you get your XP goes up.

1716
01:33:57,645 --> 01:33:59,751
大概 它会检查你是否升级了 
And presumably, it checks if you leveled up.

1717
01:33:59,751 --> 01:34:00,750
演讲者1：是的 正确 
SPEAKER 1: Yes, correct.

1718
01:34:00,750 --> 01:34:03,600
观众：[听不见]调高音量 
AUDIENCE: [INAUDIBLE] to level up.

1719
01:34:03,600 --> 01:34:05,610
演讲者1：完全正确 所以当推动对话时
SPEAKER 1: Exactly, so when push a dialogue

1720
01:34:05,610 --> 01:34:09,980
在屏幕上显示你获得了x个经验点 XP酒吧的青少年 
to the screen that says you've earned x experience points, the XP bar tweens,

1721
01:34:09,980 --> 01:34:10,620
对吗？
right?

1722
01:34:10,620 --> 01:34:15,740
我们已经达到了当前XP与下一级XP的比率 
We've gone up to however our ratio of current XP to next level XP is.

1723
01:34:15,740 --> 01:34:19,780
我们以这种方式制作文本栏动画 或以这种方式制作进度条 
We animate our text bar that way, or progress bar that way.

1724
01:34:19,780 --> 01:34:23,820
然后我们把州内的淡入淡出 对 变成白色 
Then we push a fade in state, right, to white.

1725
01:34:23,820 --> 01:34:27,360
然后我们必须把所有东西都从堆栈中取出 
And then we have to pop everything off the stack,

1726
01:34:27,360 --> 01:34:32,417
然后将淡出状态推送到堆栈的顶部 
and then push a fade out state to the top of the stack,

1727
01:34:32,417 --> 01:34:34,000
然后我们又回到了游戏状态 
and then we're back to the play state.

1728
01:34:34,000 --> 01:34:41,610
但如果我们真的升级了 我们需要播放正确的音乐 播放正确的声音 
But if we do level up, we need to play the right music, play the right sound,

1729
01:34:41,610 --> 01:34:45,370
然后赋值的一部分实际上是 在那个确切的函数中 
and then part of the assignment will be actually, in that exact function,

1730
01:34:45,370 --> 01:34:48,432
你需要添加一些行为来做什么？
you're going to need to add some behavior that will do what?

1731
01:34:48,432 --> 01:34:50,892
观众：[听不见]基本上是显示变化 
AUDIENCE: [INAUDIBLE] display the change basically,

1732
01:34:50,892 --> 01:34:51,720
以及新的一个将会是什么 
and what the new one will be.

1733
01:34:51,720 --> 01:34:53,886
演讲者1：是的 我们需要做些什么呢？
SPEAKER 1: Yes, and what are we going to need to do.

1734
01:34:53,886 --> 01:34:55,650
我们需要做什么才能做到这一点？
What will we need to do in order to?

1735
01:34:55,650 --> 01:34:57,790
观众：[？解释 ？]它叫什么来着？
AUDIENCE: [? Explain, ?] what was it called?

1736
01:34:57,790 --> 01:35:00,680
选择框 但基本没有选择部分 
The selection box, but without the selection part basically.

1737
01:35:00,680 --> 01:35:03,900
演讲者1：是的 所以一旦我们采取了--一旦我们升级了
SPEAKER 1: Yes, so once we've taken-- once we've leveled up

1738
01:35:03,900 --> 01:35:07,680
我们处于战斗状态的胜利状态 对吧 
and we're in that victory state of the battle state, right,

1739
01:35:07,680 --> 01:35:13,560
我们需要推送一个新状态 一个新的菜单状态 
we need to push a new state, a new menu state, which

1740
01:35:13,560 --> 01:35:17,160
拥有所有这些统计数据以及它们增加的数量 
has all of those stats and the amount that they've increased.

1741
01:35:17,160 --> 01:35:19,920
然后当我们按回车键时 大概我们
And then when we press Enter, presumably, we

1742
01:35:19,920 --> 01:35:24,090
应该把它弹出来 然后把其他的都弹回播放状态 
should pop that off, and then pop everything else back to the play state,

1743
01:35:24,090 --> 01:35:26,310
然后像往常一样淡入 
and then do the fade in as normal.

1744
01:35:26,310 --> 01:35:29,310
简而言之 这就是战斗状态 
And that is the battle state in a nutshell,

1745
01:35:29,310 --> 01:35:32,850
很多东西都在等待着彼此的输入和其他东西
a lot of pieces that sort of are waiting on each other and input and stuff

1746
01:35:32,850 --> 01:35:33,660
就像那样 
like that.

1747
01:35:33,660 --> 01:35:37,985
但相当容易理解 只是因为它的许多内容非常简单
But fairly easy to understand, just because a lot of it is very simple

1748
01:35:37,985 --> 01:35:40,110
只是一遍又一遍地链接在一起的东西
things that are just chained together over and over

1749
01:35:40,110 --> 01:35:42,480
再次产生这种有趣的行为 
again to produce this sort of interesting behavior.

1750
01:35:45,070 --> 01:35:47,320
所以我们这里有精灵 回想一下精灵是什么
So here we have sprites, recall the sprites are what

1751
01:35:47,320 --> 01:35:49,380
我们需要对它们进行动画处理 
we're going to need to animate those.

1752
01:35:49,380 --> 01:35:52,860
我们有健康条 也就是进度条 
We have health bars, which are progress bars, which

1753
01:35:52,860 --> 01:35:55,890
就是两个长方形--
are just two rectangles that are--

1754
01:35:55,890 --> 01:35:59,520
一条线 一条黑线 和一条填充在线下的填充 
ones a line, a black line, and ones a fill that fills beneath the line,

1755
01:35:59,520 --> 01:36:06,000
这样我们就能知道少了多少 对吧？
so that we get a sense of how much is missing, right?

1756
01:36:06,000 --> 01:36:08,290
我们得到了宽度、高度和颜色 
We get the width, the height, a color.

1757
01:36:08,290 --> 01:36:10,470
我们可以给进度条添加任何我们想要的颜色 
We can give our progress bar any color we want to,

1758
01:36:10,470 --> 01:36:13,710
这就是我们如何区分健康吧和XP
which is how we get the difference between, say, a health bar and an XP

1759
01:36:13,710 --> 01:36:14,370
酒吧 
bar.

1760
01:36:14,370 --> 01:36:17,619
我们只画一个红色和一个蓝色 然后把它们画在不同的地方 对吧 
We just make one red and one blue, and we draw them in different spots, right,

1761
01:36:17,619 --> 01:36:20,220
但它们都是进步的标杆 
but they're both equally progress bars.

1762
01:36:20,220 --> 01:36:21,570
然后他们就会得到一个价值 
And then they get a value.

1763
01:36:21,570 --> 01:36:28,050
它们的值决定了矩形的大小
Their value is whatever sort of determines how much of the rectangle

1764
01:36:28,050 --> 01:36:29,130
是按比例调整的 
is scaled.

1765
01:36:29,130 --> 01:36:33,390
最大值就是应该按顺序除以多少
And the max is how much that should be divided by in order

1766
01:36:33,390 --> 01:36:36,420
以求出总宽度的比率--
to produce a ratio for the total width--

1767
01:36:36,420 --> 01:36:38,640
一个总宽度的定标器 这将允许我们
a scaler for the total width, which will allow us

1768
01:36:38,640 --> 01:36:41,580
以获得丢失的数量的感觉 
to get the sense of an amount missing.

1769
01:36:43,875 --> 01:36:45,930
然后一个球员圈x 对手圈
And then a player circle x, opponent circle

1770
01:36:45,930 --> 01:36:51,180
X代表省略号 只是实际口袋妖怪的图形细节 
x for the ellipses, just the graphical details for the actual Pokemon,

1771
01:36:51,180 --> 01:36:54,690
这样我们就可以得到他们的数据 这样我们就可以真正地掷骰子 或者不掷骰子
so that we can get their stats, so that we can actually do dice rolls, or not

1772
01:36:54,690 --> 01:36:58,230
在这种情况下确实掷骰子 但这样我们就可以加或减
really dice rolls in this case, but so that we can add or subtract

1773
01:36:58,230 --> 01:36:59,790
惠普以进攻和防守为基础 
HP based on attack and defense.

1774
01:37:03,570 --> 01:37:06,030
这就是最新的情况 所以把扳机滑进去 
And so here was the update, so trigger slide in.

1775
01:37:06,030 --> 01:37:09,470
因此 触发滑动所做的是一秒钟的补间 
So what trigger slide in does, is a one second tween,

1776
01:37:09,470 --> 01:37:10,720
你说过的 对吧？
which you talked about, right?

1777
01:37:10,720 --> 01:37:14,410
精灵宝可梦从左到右 或者从左到右 从右到左 
The Pokemon going left to right, or left to right, right to left.

1778
01:37:14,410 --> 01:37:18,330
有x个值 只需一秒钟就可以补齐 
There x values, just tweening in over one second.

1779
01:37:18,330 --> 01:37:22,360
一旦完成 我们将触发开始对话 
As soon as that's finished, we're going to trigger starting dialogue.

1780
01:37:22,360 --> 01:37:26,760
因此 开始对话是将战斗消息状态推送到堆栈上 
So the starting dialogue is push a battle message state onto the stack.

1781
01:37:26,760 --> 01:37:30,500
战斗消息状态类似于对话状态 因为它获取一个字符串
The battle message state is just like a dialogue state in that it gets a string

1782
01:37:30,500 --> 01:37:33,300
在这里 一个狂野的东西出现了 
here, so a wild something appears.

1783
01:37:33,300 --> 01:37:36,690
一旦我们按回车键 它就会得到一个回调函数 
It gets a callback function for once we press Enter on that.

1784
01:37:36,690 --> 01:37:41,520
回调函数本身就是战斗消息状态的又一次推送
And the callback function is itself another push of a battle message state

1785
01:37:41,520 --> 01:37:43,900
上面写着 去吧 然后是我们的精灵宝可梦 
that says, go, and then our Pokemon.

1786
01:37:43,900 --> 01:37:47,460
请注意 我们在这里引用的是self.opcient.party.pokemon 
So notice that we're referencing the self.opponent.party.pokemon there,

1787
01:37:47,460 --> 01:37:52,560
在那里使用self.player.party.pokemon来获取实际名称 
and self.player.party.pokemon there to get the actual name.

1788
01:37:52,560 --> 01:37:59,790
然后一旦我们弹出 然后我们在这里按下战斗菜单状态 
And then once we've popped that off, then we push a battle menu state here,

1789
01:37:59,790 --> 01:38:00,660
对吗？
right?

1790
01:38:00,660 --> 01:38:02,820
那么 让我们来看看战斗菜单状态 
So let's take a look at the battle menu state.

1791
01:38:02,820 --> 01:38:06,660
这很有趣 因为这就是我们真正定义的
So this is interesting, because this is where we actually define

1792
01:38:06,660 --> 01:38:08,880
我们菜单的行为是有效的 对吗？
the behavior for our menu works, right?

1793
01:38:08,880 --> 01:38:12,080
回想一下 我们需要一些东西来告诉我们当我们按下Fight时会发生什么 
Recall, we need something to tells us what happens when we press Fight,

1794
01:38:12,080 --> 01:38:13,950
以及当我们单击Run时会发生什么 
and what happens when we click Run.

1795
01:38:13,950 --> 01:38:16,830
因此 当我们点击Fight时 请注意此处的项目 
So when we click Fight, notice here items,

1796
01:38:16,830 --> 01:38:20,810
对 self.warflemenu获得菜单 并且菜单需要项目 
right, self.battlemenu gets menu, and menu expects items.

1797
01:38:20,810 --> 01:38:30,180
这项关键字 这张桌子直接输入到选择中 对吗？
This items key, this table gets fed right into the selection, right?

1798
01:38:30,180 --> 01:38:33,300
和选择 它希望记住 一篇文字 
And the selection, it expects remember, a text,

1799
01:38:33,300 --> 01:38:36,179
因为它必须知道在该索引处呈现什么 
because it has to know what to render at that index.

1800
01:38:36,179 --> 01:38:37,470
然后是ON SELECT功能 
And then an on select function.

1801
01:38:37,470 --> 01:38:39,261
而On SELECT函数是回调
And that on select function is the callback

1802
01:38:39,261 --> 01:38:42,990
当您在该特定位置按Enter键时执行的
that gets executed when you press Enter at that particular location

1803
01:38:42,990 --> 01:38:43,960
在菜单上 
in the menu.

1804
01:38:43,960 --> 01:38:48,300
在这种情况下 战斗 它所做的是弹出这个战斗菜单状态
In this case, fight, what that does is it pops this battle menu state where

1805
01:38:48,300 --> 01:38:51,180
我们不再需要菜单了 打开它吧 
we no longer need the menu, so pop it.

1806
01:38:51,180 --> 01:38:54,120
然后推动一个新的转弯状态 
And then push a new take turn state.

1807
01:38:54,120 --> 01:38:58,830
然后在这个游戏中轮流状态是精灵宝可梦相互战斗 那就是
And then take turn state in this game is the Pokemon fighting each other, that's

1808
01:38:58,830 --> 01:39:00,250
转弯状态是什么 
what the take turn state is.

1809
01:39:00,250 --> 01:39:03,030
例如 它可以被称为战斗状态 
And it could have been called fight state, for example,

1810
01:39:03,030 --> 01:39:05,080
但Take Turn State的用途更多一点 
but take turn state is a little more versatile.

1811
01:39:05,080 --> 01:39:07,850
如果我们想制造一个精灵宝可梦想要运行
If we wanted to maybe make, maybe one Pokemon wants to run,

1812
01:39:07,850 --> 01:39:10,590
敌人想跑 我们想打 对吧？
the enemy wants to run and we want to fight, right?

1813
01:39:10,590 --> 01:39:13,680
但你不能总是跑 所以他们应该试着跑 
But you can't always run, so they should try to run,

1814
01:39:13,680 --> 01:39:15,480
然后我们仍然可以和他们战斗 
and then we can still fight them.

1815
01:39:15,480 --> 01:39:18,595
或者他们可以使用物品 或者我们可以使用物品 对吗？
Or they can use an item, or we can use an item, right?

1816
01:39:18,595 --> 01:39:20,470
你可以做很多不同的事情 
There's a lot of different things you can do.

1817
01:39:20,470 --> 01:39:24,096
或者我们想向他们扔一个弹子球 如果我们失败了 
Or we want to throw a Poke ball at them, and if we fail,

1818
01:39:24,096 --> 01:39:25,470
那他们就应该和我们战斗 对吗？
then they should fight us, right?

1819
01:39:25,470 --> 01:39:27,930
轮流只是一种通用状态
Take turn is just a general purpose state

1820
01:39:27,930 --> 01:39:31,050
我们可以改变用途 无论我们有什么用途
that we could repurpose for whatever use we

1821
01:39:31,050 --> 01:39:35,190
想要与我们和对手之间的任何互动 
want to with any interaction between us and the opponent,

1822
01:39:35,190 --> 01:39:38,370
无论是打架 逃跑 还是使用物品 抓住他们 任何
whether it's fighting, running away, or using items, catching them, any

1823
01:39:38,370 --> 01:39:39,900
这些东西的组合 
of these combinations of things.

1824
01:39:39,900 --> 01:39:43,020
但在这种情况下 为了这个例子 为了简单起见 
But in this case, for the sake of this example, for simplicity,

1825
01:39:43,020 --> 01:39:44,940
我们只实施了战斗 
we've only implemented fighting.

1826
01:39:44,940 --> 01:39:49,219
我们和对手在这种状态下相互战斗 这是
The we and the opponent fight each other during this state, which

1827
01:39:49,219 --> 01:39:51,510
一人攻击另一人 然后我们检查死亡人数
is, one attacks the other, and then we check for deaths

1828
01:39:51,510 --> 01:39:52,740
介于两者之间 
in between both of those.

1829
01:39:52,740 --> 01:39:57,990
然后走向胜利或伪装取决于哪一种是正确的 
And then go to victory or feinting depending on which of those holds true,

1830
01:39:57,990 --> 01:40:00,030
如果有的话 
if either.

1831
01:40:00,030 --> 01:40:01,930
跑步则略有不同 
Running is slightly different.

1832
01:40:01,930 --> 01:40:07,890
因此 如果我们运行 我已经将其编程为100% 它将100%地工作 
So if we run, I've programmed it to be 100%, it will 100% of the time work.

1833
01:40:07,890 --> 01:40:10,600
在精灵宝可梦中 你实际上有机会运行
In Pokemon, you actually have a chance to run

1834
01:40:10,600 --> 01:40:12,860
根据你和你的敌人之间的三角洲 
based on what the delta is between you and your enemy.

1835
01:40:12,860 --> 01:40:16,740
因此 如果他们比你强大 你实际上并不能保证会逃走 
So if they're stronger than you, you actually aren't guaranteed to run away.

1836
01:40:16,740 --> 01:40:23,400
所以我们在我的实现中所做的是 我们只是弹出战斗菜单 
So what we do here in my implementation is, we just pop the battle menu,

1837
01:40:23,400 --> 01:40:24,670
所以它不见了 
so it's gone.

1838
01:40:24,670 --> 01:40:30,880
然后我们推 你成功逃到了屏幕上 这就是战斗信息 
And then we push, you fled successfully to the screen, this battle message.

1839
01:40:30,880 --> 01:40:36,870
但这与我们展示的其他战斗信息有所不同 
But there's a difference here versus the other battle messages that we've shown.

1840
01:40:36,870 --> 01:40:40,490
我的意思是 这并不是真的不同 但这是值得记住的事情 
I mean, it's not really different, but it's something to keep in mind.

1841
01:40:40,490 --> 01:40:43,100
所以我要投入一场战斗 
So I'm going to get into a battle.

1842
01:40:45,912 --> 01:40:48,870
首先 通过你刚才在屏幕上看到的信息 
And so first of all, with that message that you just saw on the screen,

1843
01:40:48,870 --> 01:40:50,430
我必须真的按回车键 对吗？
I had to actually press Enter, right?

1844
01:40:50,430 --> 01:40:53,490
我通过按Enter键显式删除了它 
I discarded it explicitly by pressing Enter.

1845
01:40:56,490 --> 01:40:58,382
对于这些信息来说也是如此 
And that holds true also for these messages.

1846
01:40:58,382 --> 01:41:00,090
在我按Enter键之前 它什么都不会做 
It won't do anything until I press Enter.

1847
01:41:00,090 --> 01:41:03,570
所以我按Enter键 然后我按Enter键 它就这样做了 
So I press Enter, and then I press Enter, and it does it's thing.

1848
01:41:03,570 --> 01:41:06,510
但请注意当我点击Run时的不同 
But notice the difference between when I hit Run.

1849
01:41:06,510 --> 01:41:10,230
我要按下Run 我逃走了 它会自己跑的 
I'm going to hit Run, I fled, and it does it on its own.

1850
01:41:10,230 --> 01:41:14,235
它不是在等待输入 对吧？
It's not waiting for input, right?

1851
01:41:14,235 --> 01:41:16,159
那么我们是如何实现这一点的呢？
So how have we implemented that?

1852
01:41:19,540 --> 01:41:20,155
嗯?
Yeah?

1853
01:41:20,155 --> 01:41:24,680
观众：使用定时器 你会自动
AUDIENCE: Using timer, you'd automatically

1854
01:41:24,680 --> 01:41:29,010
像之后那样做 而不是等待您的输入 
do it the same way you would afterwards, instead of waiting for you input,

1855
01:41:29,010 --> 01:41:31,330
您只需等待计时器结束 
you just wait for the timer to end.

1856
01:41:31,330 --> 01:41:34,570
演讲者1：没错 所以我们使用计时器 然后当计时器结束时 
SPEAKER 1: Exactly, so we use a timer, and then when the timer is finished,

1857
01:41:34,570 --> 01:41:40,390
我们弹出战斗信息 就像我们按回车键弹出它一样 
we pop the battle message just like we would have popped it by pressing Enter.

1858
01:41:40,390 --> 01:41:43,080
这面假旗让我们可以这么做 
This false flag is what allows us to do that.

1859
01:41:43,080 --> 01:41:46,870
我们按假和假是 我们可以输入或不？
We press false and false is, can we input or not?

1860
01:41:46,870 --> 01:41:47,890
但我们不能 
And we can't.

1861
01:41:47,890 --> 01:41:51,230
所以实际上 如果我们在这之后不做任何计时器的事情 
So actually, if we didn't do any timer thing after this,

1862
01:41:51,230 --> 01:41:54,400
我们刚刚做了一个假旗 战斗信息将永远存在 
and we just did that false flag, the battle message would be there forever,

1863
01:41:54,400 --> 01:41:56,400
我们永远也摆脱不了
and we could never get rid of it, ever.

1864
01:41:56,400 --> 01:41:58,420
它会永远卡住 
It would get stuck forever.

1865
01:41:58,420 --> 01:42:03,610
所以我们要负责任地说 好吧 我们要放一个计时器 
So we got to be responsible and say, OK, we're going to put a timer,

1866
01:42:03,610 --> 01:42:08,800
我们将在0.5秒后立即调用timer 
we're going to call timer.after 0.5 seconds immediately after that.

1867
01:42:08,800 --> 01:42:11,110
我们要在州内推行一种淡化 
We're going to push a fade in state.

1868
01:42:11,110 --> 01:42:15,190
然后我们要做这两个弹出操作 一旦它消失了
And then we're going to do these two pop operations here as soon as that fade in

1869
01:42:15,190 --> 01:42:16,180
发生了
happens.

1870
01:42:16,180 --> 01:42:19,960
第一次弹出会弹出一条信息 对吧 这条信息
This first pop will pop the message, right, this message here

1871
01:42:19,960 --> 01:42:22,910
我们没有通过输入弹出 
that we didn't pop through input.

1872
01:42:22,910 --> 01:42:26,350
所以这实际上是垃圾收集 在某种意义上 对我们来说 
So this is actually garbage collecting, in a sense, for us.

1873
01:42:26,350 --> 01:42:31,150
它丢弃了我们不能自动丢弃的信息 
It's discarding the message that we couldn't discard automatically.

1874
01:42:31,150 --> 01:42:33,940
然后我们要进入战斗状态 对吧
And then we're going to pop the battle state, right?

1875
01:42:33,940 --> 01:42:38,860
所以跑步会推送战斗信息 触发一个补间计时器
So running will push the battle message, trigger a timer tween

1876
01:42:38,860 --> 01:42:44,440
我们的计时器 五秒钟后 对不起 按下淡入状态 
for our timer.after five seconds, sorry, push a fade in state.

1877
01:42:44,440 --> 01:42:48,010
然后在状态淡出完成后 弹出这两个状态 
And then after the fade in states done, then pop both of those states.

1878
01:42:48,010 --> 01:42:53,420
消息和战斗状态将我们带回到游戏状态 
The message and the battle state take us back to the play state.

1879
01:42:53,420 --> 01:42:56,360
一切结束后我们就去那里 
And that's where we'll be as soon as that's all done.

1880
01:42:56,360 --> 01:43:00,880
这就是战斗菜单状态中的所有内容 
And that's all that's in the battle menu state.

1881
01:43:00,880 --> 01:43:04,120
任何问题 以如何战斗菜单工程 战斗之间的区别
Any questions as to how the battle menu works, the difference between fight

1882
01:43:04,120 --> 01:43:08,340
以及它们是如何运作的
and run and sort of how those operate?

1883
01:43:08,340 --> 01:43:09,560
好的.
OK.

1884
01:43:09,560 --> 01:43:13,730
让我们来看看
So let's take a look then at the take turn

1885
01:43:13,730 --> 01:43:19,700
国家 这是最后一块 也是最大的一块 
state, which is the last piece and the largest piece I would say.

1886
01:43:19,700 --> 01:43:24,090
这是与任务最相关的 
This is the most relevant to the assignment.

1887
01:43:24,090 --> 01:43:28,250
所以我们保持一个参考 口袋妖怪是第一个或第二个去 
So we maintain a reference to which Pokemon is first or second to go,

1888
01:43:28,250 --> 01:43:31,460
哪个精灵是第一个或第二个 哪个进度条是
which sprite is first or second to go, and which progress bar is

1889
01:43:31,460 --> 01:43:33,400
第一个或第二个到这里来 
first or second to go up here.

1890
01:43:33,400 --> 01:43:36,020
就像我说的 我们这样做是基于速度 
And we do that, like I said, based on speed.

1891
01:43:36,020 --> 01:43:40,400
所以无论哪个精灵宝可梦更快 我们也可以
So whichever Pokemon is faster, and we could have also

1892
01:43:40,400 --> 01:43:45,330
只是通过保持精灵和进步 让这一切变得更短了
made this a little bit shorter, just by keeping the sprites and the progress

1893
01:43:45,330 --> 01:43:49,400
BAR作为Pokemon对象或类的成员 
bars as members of the Pokemon object, or the class,

1894
01:43:49,400 --> 01:43:53,150
但由于他们是分开的 就像我们不一定
but since they're kind of separated, like we don't necessarily

1895
01:43:53,150 --> 01:43:56,870
我想让一个口袋妖怪一直引用它的进度条 
want a Pokemon to have a reference to it's progress bar at all times,

1896
01:43:56,870 --> 01:43:58,025
或者我的意思是 你可以 
or I mean, you could.

1897
01:43:58,025 --> 01:43:59,900
没有什么能阻止你去做这件事 
There's nothing preventing you from doing it.

1898
01:43:59,900 --> 01:44:04,020
它只会用来缩短这里的代码 
It would only serve the purpose of shortening this code here.

1899
01:44:04,020 --> 01:44:10,640
但我们需要保持对此的引用 这样我们才能在这里调用攻击 
But we need to keep a reference to this so that we can call attack here,

1900
01:44:10,640 --> 01:44:16,400
这是这一大块代码的两次 而不需要
which is this large bit of code twice, without needing

1901
01:44:16,400 --> 01:44:18,560
将所有代码复制两次 
to duplicate all of that code twice.

1902
01:44:18,560 --> 01:44:21,076
这说得通吗？
Does that makes sense?

1903
01:44:21,076 --> 01:44:22,450
托尼 你有什么问题吗？
So Tony, did you have a question?

1904
01:44:22,450 --> 01:44:24,800
观众：嗯 我只是在想 你也许可以
AUDIENCE: Well, I was just thinking, you could probably

1905
01:44:24,800 --> 01:44:26,716
将其放入帮助器函数中 您只需
put that into a helper function where you just

1906
01:44:26,716 --> 01:44:29,260
更改您传递它的顺序 
change the order you pass it in.

1907
01:44:29,260 --> 01:44:30,090
演讲者1：什么？
SPEAKER 1: Sorry?

1908
01:44:30,090 --> 01:44:30,640
再说一遍 
Say it again.

1909
01:44:30,640 --> 01:44:33,870
观众：我只是觉得 我想你可以接受代码 
AUDIENCE: I just kind of feel like, I guess you could take the code,

1910
01:44:33,870 --> 01:44:36,373
我想 你可以避免重复这一点 
and you could avoid duplicating that I guess.

1911
01:44:36,373 --> 01:44:40,000
因为它只是颠倒了 所以你可以做的是--
'Cause it's just reversed, so what you could do is you could--

1912
01:44:40,000 --> 01:44:44,620
如果你传入一个帮助器函数 你只需要 
if you passed into a helper function, which you would just,

1913
01:44:44,620 --> 01:44:48,350
而不是先通过它--
instead of passing it first--

1914
01:44:48,350 --> 01:44:50,730
对手精灵宝可梦 玩家精灵宝可梦 
instead of passing it, opponent Pokemon, player Pokemon,

1915
01:44:50,730 --> 01:44:53,504
你会通过它 玩家精灵宝可梦 对手精灵宝可梦 
you would pass it, player Pokemon, opponent Pokemon.

1916
01:44:53,504 --> 01:44:55,132
我认为这可能会奏效 
And that would probably work I think.

1917
01:44:55,132 --> 01:44:57,590
演讲者1：好吧 你也要考虑到--
SPEAKER 1: Well, you also have to take into consideration--

1918
01:44:57,590 --> 01:45:04,060
所以评论是 你可以传给玩家口袋妖怪和对手
so the comment was, you could pass in the player Pokemon and the opponent

1919
01:45:04,060 --> 01:45:08,355
将精灵宝可梦转化为一个函数 然后在该函数中反转它们 
Pokemon into a function, and then you reverse them in that function,

1920
01:45:08,355 --> 01:45:10,480
我认为 要尊重它们 扭转它们 
I'm assuming, have reverence them and reverse them.

1921
01:45:10,480 --> 01:45:13,780
但精灵与精灵精灵是分离的 
But the sprites are decoupled from the Pokemon,

1922
01:45:13,780 --> 01:45:17,170
进度条也与精灵宝可梦分离 
and the progress bars are also decoupled from the Pokemon.

1923
01:45:17,170 --> 01:45:27,790
所以我们可以通过将这四个东西放在这里来缩短它
So we could shorten this by making these four things here fields

1924
01:45:27,790 --> 01:45:31,030
精灵宝可梦对象 但严格来说它们并不是
of the Pokemon objects, but they're not strictly

1925
01:45:31,030 --> 01:45:34,180
与精灵宝可梦对象的操作相关 
pertinent to the operation of the Pokemon object.

1926
01:45:34,180 --> 01:45:39,740
这让精灵宝可梦的物件有点
And it sort of kind of makes the Pokemon objects a little

1927
01:45:39,740 --> 01:45:43,586
也 基本上不够抽象或足够轻量级 
too, not basically abstract or lightweight enough,

1928
01:45:43,586 --> 01:45:45,460
它只是为了达到这一点的目的 
and it only serves the purpose of this point,

1929
01:45:45,460 --> 01:45:47,660
只需缩短这一小段代码 
of just shortening this bit of code.

1930
01:45:47,660 --> 01:45:53,020
可能有一种更优雅的方式来做到这一点 但很难说 
There's probably a more elegant way to do it, but it's hard to say.

1931
01:45:53,020 --> 01:45:56,550
如果这个代码变得更大 也许 
If this code were to get larger, maybe.

1932
01:45:56,550 --> 01:45:58,690
但其主旨基本上是拥有
But the gist of this is basically to have

1933
01:45:58,690 --> 01:46:04,380
指向任何Pokemon、进度条和精灵的指针应该首先操作
a pointer to whatever Pokemon, progress bars, and sprites should operate first

1934
01:46:04,380 --> 01:46:06,790
在攻击中 而不是在第二次行动中 
in the attack versus what should operate second.

1935
01:46:06,790 --> 01:46:10,730
然后 两人将根据谁是第一个 谁是谁的顺序交换拳头
And then the two will trade blows in order based on who's first and who

1936
01:46:10,730 --> 01:46:12,530
第二 
second.

1937
01:46:12,530 --> 01:46:14,560
所以当我们进入转弯状态时 我们是
So when we enter the take turn state, we're

1938
01:46:14,560 --> 01:46:18,730
将触发攻击 这里是函数攻击 我们将在
going to trigger that attack, here this function attack, which we'll take in

1939
01:46:18,730 --> 01:46:22,210
第一 第二 第一 第二 第一 第二
first, second, first, second, first, second for the Pokemon

1940
01:46:22,210 --> 01:46:24,760
雪碧和进度条 
sprite and progress bars.

1941
01:46:24,760 --> 01:46:27,850
然后是匿名函数 它被执行为
And then anonymous function, which get's executed as

1942
01:46:27,850 --> 01:46:31,810
一旦攻击结束 对吗？
soon as the attack is finished, right?

1943
01:46:31,810 --> 01:46:35,800
所以这是一个代码 它将弹出一条在攻击中被推送的消息 
So this is a code that will pop a message that gets pushed in attack,

1944
01:46:35,800 --> 01:46:39,040
然后这就是我们真正检查死亡人数的地方 对吗？
and then this is where we actually check deaths, right?

1945
01:46:39,040 --> 01:46:42,380
它将决定我们是走向胜利还是走向黯淡的屏幕 
And it will determine whether we go to victory or faint screen or not.

1946
01:46:42,380 --> 01:46:44,920
如果不是 如果是 我们就回来 
If not, and we return if so.

1947
01:46:44,920 --> 01:46:47,186
如果没有 我们将进行另一次攻击 但请看 
If not, we're going to do another attack, but see,

1948
01:46:47,186 --> 01:46:48,310
现在一切都颠倒过来了 
everything is reversed now.

1949
01:46:48,310 --> 01:46:53,281
现在是第二 第一 第二 第一 第二 第一 
Now it's second, first, second, first, second, first.

1950
01:46:53,281 --> 01:46:55,030
所以我们有相同的功能 自我攻击 
So we have the same function, self attack,

1951
01:46:55,030 --> 01:46:57,130
这只会收留袭击者 
which just takes in the attacker.

1952
01:46:57,130 --> 01:47:00,310
它实际上是 攻击者 防御者 攻击者 防御者 攻击者 
And it's effectively, attacker, defender, attacker, defender, attacker,

1953
01:47:00,310 --> 01:47:05,860
精灵精灵和进度条的后卫 
defender for the Pokemon sprites and progress bars.

1954
01:47:05,860 --> 01:47:09,350
所以这里的攻击函数首先推动一个--
And so the attack function here first pushes a--

1955
01:47:09,350 --> 01:47:10,120
好吧 好吧 
well, OK.

1956
01:47:10,120 --> 01:47:11,329
攻击是什么--
What does the attack--

1957
01:47:11,329 --> 01:47:12,620
让我们再复习一遍 
let's go over it one more time.

1958
01:47:12,620 --> 01:47:18,279
我们认为攻击功能按顺序执行什么操作 
What do we think the attack function does in order.

1959
01:47:18,279 --> 01:47:20,070
我们刚刚报道了他们 但是什么？
We covered them just a moment ago, but what

1960
01:47:20,070 --> 01:47:24,070
当一种东西攻击另一种东西时 发生的顺序是什么？
was the order that happens when something attacks another thing?

1961
01:47:24,070 --> 01:47:25,188
嗯?
Yeah?

1962
01:47:25,188 --> 01:47:27,235
观众：袭击者呈白色闪烁 
AUDIENCE: The attacker blinks white.

1963
01:47:27,235 --> 01:47:28,645
扬声器1：攻击者呈白色闪烁 
SPEAKER 1: Attacker blinks white.

1964
01:47:28,645 --> 01:47:33,900
观众：然后防守者眨眼表示不透明 
AUDIENCE: Then the defender blinks opacity.

1965
01:47:33,900 --> 01:47:36,626
演讲者1：防御者切换它的不透明度 
SPEAKER 1: The defender toggles it's opacity.

1966
01:47:36,626 --> 01:47:38,244
观众：健康吧也缩水了 
AUDIENCE: And the health bar shrinks.

1967
01:47:38,244 --> 01:47:39,494
演讲者1：健康吧缩小了 
SPEAKER 1: Health bar shrinks.

1968
01:47:42,850 --> 01:47:45,570
没错 然后基本上就是为了进攻了 对吧？
Exactly, and then that's basically it for attack, right?

1969
01:47:45,570 --> 01:47:49,690
眨眼 播放声音 眨眼 播放声音 缩小酒吧 
Blink, play a sound, blink, play a sound, shrink the bar,

1970
01:47:49,690 --> 01:47:52,810
同时 我们也在破坏这一功能 
and also we're doing damage in that function as well.

1971
01:47:52,810 --> 01:47:55,450
事实上 我们必须改变精灵宝可梦的状态 
We actually have to change the status of the Pokemon.

1972
01:47:59,590 --> 01:48:02,150
所以这实际上就是它开始的地方 对吗？
So this is effectively where it starts, right?

1973
01:48:02,150 --> 01:48:05,557
我们将战斗消息状态放到堆栈上 
We place a battle message state onto the stack that says,

1974
01:48:05,557 --> 01:48:07,390
攻击者名称攻击防御者名称 
the attacker name attacks the defender name.

1975
01:48:10,510 --> 01:48:15,490
请注意 它会像Run消息一样变为FALSE
Notice that it gets false just like the run message

1976
01:48:15,490 --> 01:48:17,830
是的 因为我们这里不接受输入 
did, because we're not accepting input here.

1977
01:48:17,830 --> 01:48:25,870
但这实际上取决于我们 它在进入状态的第42行完成 
But it's up to us actually, it done up here at line 42 of the enter state.

1978
01:48:25,870 --> 01:48:32,260
但我们将在0.5秒后播放攻击动画 
But we're going to after 0.5 seconds, play the attack animation.

1979
01:48:32,260 --> 01:48:36,400
因此 每0.1秒就启动一次声音 
So power up sound every 0.1 second.

1980
01:48:36,400 --> 01:48:39,340
我们会记住精灵身上闪烁的旗帜 
We're going to member the blinking flag on the sprite,

1981
01:48:39,340 --> 01:48:42,980
我们将通过不将其设置为自身来切换它 
we're going to toggle it by setting it not to itself.

1982
01:48:42,980 --> 01:48:46,290
因此 如果某个东西不是它本身 如果它是真实的价值 它就会变得虚假 
So if something is not itself, if it's a truthy value, it becomes falsy,

1983
01:48:46,290 --> 01:48:48,340
如果它是假的 它就会变成真的 
if it's falsy, it becomes truthy.

1984
01:48:48,340 --> 01:48:51,100
所以基本上 在真与假之间来回切换 
So basically, toggling between true and false.

1985
01:48:51,100 --> 01:48:53,530
限制为六个 对 因为记住 每一份遗嘱
Limit of six, right, because remember, every will

1986
01:48:53,530 --> 01:48:56,200
无限期地做某件事 
do something every amount of time indefinitely,

1987
01:48:56,200 --> 01:49:00,700
除非您传入某个值的限制 在本例中 限制为6 
unless you pass in a limit of some value, in this case, a limit of six.

1988
01:49:00,700 --> 01:49:04,870
所以我们说 只执行这段代码六次 只眨眼六次 对吧 
So we're saying, only execute this code six times, only blink six times, right,

1989
01:49:04,870 --> 01:49:07,690
只切换六次 眨眼三次 对吧 
only toggle six times, blink three times, right,

1990
01:49:07,690 --> 01:49:09,800
因为它必须时断时续 
because it has to go on and off.

1991
01:49:09,800 --> 01:49:12,550
然后 当这六次迭代完成后 
And then as soon as those six iterations are completed,

1992
01:49:12,550 --> 01:49:16,360
我们在该Timer对象上调用已完成的函数 
we call the finished function on that timer object,

1993
01:49:16,360 --> 01:49:18,156
这是一种诚实的行为 
which takes an honest function.

1994
01:49:18,156 --> 01:49:22,542
一旦发生这种情况 我们就做不透明的部分 对吗？
As soon as that happens, we do the opacity bit, right?

1995
01:49:22,542 --> 01:49:25,250
我们对进攻者眨眼 所以现在我们要对防守者眨眼 
We blinked the attackers, so now we've got to blink the defender.

1996
01:49:25,250 --> 01:49:27,760
所以我们播放热门音乐 
So we play the hit sound.

1997
01:49:27,760 --> 01:49:32,110
我们做的和刚才对眨眼时做的完全一样 只是现在 
We do the exact same thing that we just did for the blinking, only now,

1998
01:49:32,110 --> 01:49:37,480
每0.1秒 我们将其不透明度设置为64或255 
every 0.1 second, we are setting its opacity to either 64 or 255,

1999
01:49:37,480 --> 01:49:40,900
取决于其不透明度的值 对吗？
depending on what the value of its opacity is, right?

2000
01:49:40,900 --> 01:49:43,240
所以我们在64到255之间切换 
So we are toggling between 64 and 255.

2001
01:49:43,240 --> 01:49:47,050
六个极限 取一个函数 计算损害 
Limit of six, take a function, calculate damage,

2002
01:49:47,050 --> 01:49:53,210
我们刚刚非常简单地做到了 进攻减去防守 对 到1
which we've just very simply done it, attack minus defense, right, up to 1

2003
01:49:53,210 --> 01:49:53,710
尽管如此 
though.

2004
01:49:53,710 --> 01:49:55,918
因此 如果防守实际上高于进攻 
So if the defense is actually higher than the attack,

2005
01:49:55,918 --> 01:49:58,000
但仍会造成至少一次伤害 
which will still do at least one damage.

2006
01:49:58,000 --> 01:50:03,370
然后在0.5秒内 我们拿起防守杆 
And then over 0.5 seconds, we take the defenders bar,

2007
01:50:03,370 --> 01:50:08,650
我们的价值等于他们当前的生命值减去伤害 对吗？
and we tween the value equal to their current HP minus damage, right?

2008
01:50:08,650 --> 01:50:15,580
然后它将设置在进度条中 设置它的值 
And then that will set in the bar, in the progress bar, it'll set its value.

2009
01:50:15,580 --> 01:50:21,460
即使进度条落后于州政府 
And even though the progress bar is behind state wise,

2010
01:50:21,460 --> 01:50:24,760
对 它在堆栈的底部 因为它处于战斗状态 
right, it's on the bottom of the stack, because it's on the battle state.

2011
01:50:24,760 --> 01:50:27,000
我们目前正处于转弯状态 
And we're in currently the take turn state,

2012
01:50:27,000 --> 01:50:30,580
而是因为我们仍在操纵该州的价值观 
but because we're still manipulating the values of that state,

2013
01:50:30,580 --> 01:50:33,640
我们正在呈现每个州 我们实际上仍然在操纵
and we're rendering every state, we're actually still manipulating

2014
01:50:33,640 --> 01:50:37,040
不管它不在堆栈的顶部这一事实 该状态 
that state regardless of the fact that it's not on the top of the stack.

2015
01:50:37,040 --> 01:50:43,510
所以这允许我们缩小精灵宝可梦进度条 不管它是什么
So that allows us to shrink that Pokemon's progress bar regardless of it

2016
01:50:43,510 --> 01:50:45,360
不管是不是在股票的顶端 
being on the top of the stock or not.

2017
01:50:45,360 --> 01:50:47,800
一旦结束了 一旦结束了 
Then once that's finished, once the tween is finished,

2018
01:50:47,800 --> 01:50:49,591
实际上将当前的HP设置为该值 
actually set the current HP to that amount,

2019
01:50:49,591 --> 01:50:52,450
因为我们只调整了进度条的值 即
because we're only tweening the progress bar's value, which is

2020
01:50:52,450 --> 01:50:55,277
独立于精灵宝可梦的价值 
independent from the Pokemon's value.

2021
01:50:55,277 --> 01:50:56,860
然后 攻击就结束了 
And then that's the end of the attack.

2022
01:50:56,860 --> 01:50:59,300
攻击在这一点上完全结束了 
The attack is completely finished at that point.

2023
01:50:59,300 --> 01:51:02,940
关于袭击是如何运作的 有什么问题吗？
So any questions as to how the attack works?

2024
01:51:02,940 --> 01:51:06,610
基本上就是一串十几岁的孩子 
Just a chain of tweens basically.

2025
01:51:06,610 --> 01:51:10,110
所以我们进行一次攻击 然后检查死亡人数是下一个功能 
So we do an attack, then check deaths is the next function.

2026
01:51:10,110 --> 01:51:14,400
我们快结束了 我要快点走了 现在是7：30 
And we're almost finished, I'm going to kind of go quickly here, it's at 7:30.

2027
01:51:14,400 --> 01:51:18,540
检查死亡是玩家口袋妖怪当前的HP小于等于0 
Check deaths is the player Pokemon current HP less and equal to 0,

2028
01:51:18,540 --> 01:51:21,540
还是对手精灵宝可梦目前的HP小于等于零 
or is the opponent Pokemon current HP less and equal to zero.

2029
01:51:21,540 --> 01:51:24,750
如果前者是真的 我们需要晕倒 如果后者是真的 
If the former's true, we need to faint, and if the latter is true,

2030
01:51:24,750 --> 01:51:25,860
我们需要走向胜利 
we need to go to victory.

2031
01:51:25,860 --> 01:51:32,880
所以晕倒实际上是一种战斗状态 对 当它说 你晕倒了 
So faint is effectively a battle state, right, when it says, you fainted.

2032
01:51:32,880 --> 01:51:33,817
然后呢？
And then what?

2033
01:51:33,817 --> 01:51:36,799
还记得我们晕倒的时候会发生什么吗？
Remember what happens when we faint?

2034
01:51:36,799 --> 01:51:41,780
观众：[听不见]文本框 然后就离开了 
AUDIENCE: [INAUDIBLE] text box, and then it leaves.

2035
01:51:41,780 --> 01:51:44,051
演讲者1：它离开了 你还记得怎么走吗？
SPEAKER 1: It leaves, do you remember how

2036
01:51:44,051 --> 01:51:46,550
例如 它离开是因为它与逃跑不同？
it leaves as it differs from like running away, for example?

2037
01:51:46,550 --> 01:51:48,790
观众：[听不见] 
AUDIENCE: [INAUDIBLE].

2038
01:51:48,790 --> 01:51:50,672
演讲者1：嗯 除此之外 从美学上讲 
SPEAKER 1: Well, beyond that, aesthetically,

2039
01:51:50,672 --> 01:51:52,130
你还记得有什么不同吗？
do you remember how it's different?

2040
01:51:52,130 --> 01:51:55,119
观众：(听不见)我认为 这和黑人不同 
AUDIENCE: [INAUDIBLE] differently to black, I think.

2041
01:51:55,119 --> 01:51:55,910
演讲者1：的确如此 
SPEAKER 1: It does.

2042
01:51:55,910 --> 01:51:57,081
相反 它会褪色为黑色 
It fades to black instead.

2043
01:51:57,081 --> 01:51:59,330
所以这就是我们在晕倒时如何区分
So that's how we can differentiate when we're fainting

2044
01:51:59,330 --> 01:52:00,891
而不是我们逃跑的时候 
versus when we're running away.

2045
01:52:00,891 --> 01:52:02,390
这就是我们在这里做的事情 
And so that's what we're doing here.

2046
01:52:02,390 --> 01:52:06,580
请注意 状态RGB中的淡入度为零 所有这些 
Notice that the fade in state RGB is zero, all of those.

2047
01:52:06,580 --> 01:52:12,890
因此 它将淡入到000255 而不是255255,255,255 
So it's going to fade in to 000255, as opposed to 255, 255, 255, 255.

2048
01:52:12,890 --> 01:52:17,000
所以这将是一个黑色淡入与白色淡入 
So it's going to be a black fade in versus a white fade in.

2049
01:52:17,000 --> 01:52:18,217
然后一旦我们--
And then once we've--

2050
01:52:18,217 --> 01:52:20,300
这只是我实现的一种方式
this it just sort of a thing that I implemented so

2051
01:52:20,300 --> 01:52:21,883
我们可以无限期地继续比赛 
that we can keep playing indefinitely.

2052
01:52:21,883 --> 01:52:25,790
但一旦完成 让玩家口袋妖怪完全恢复健康 
But once that's finished, restore the player Pokemon to full health,

2053
01:52:25,790 --> 01:52:27,740
恢复所有现场音乐的内容 
resume all the field music stuff.

2054
01:52:27,740 --> 01:52:31,851
一旦我们推入淡出状态 000 
And then once we've pushed a fade out state, 000,

2055
01:52:31,851 --> 01:52:34,910
然后我们又回到了赛场 让我们继续前进 
and then we've gone back to the field, let's push.

2056
01:52:34,910 --> 01:52:38,360
注意 这里它接受一个函数 在淡出状态完成之后 
Notice that here it takes a function, right, after the fade out state's done.

2057
01:52:38,360 --> 01:52:42,620
一旦淡出完成--所以只要我们回到播放状态 
Once the fade out is finished-- so as soon as we're back to the play state,

2058
01:52:42,620 --> 01:52:44,630
按下对话状态 上面写着：您的精灵宝可梦
push a dialogue state that says, your Pokemon

2059
01:52:44,630 --> 01:52:47,300
已完全恢复 请重试 
has been fully restored, try again.

2060
01:52:47,300 --> 01:52:49,770
这将根据上下文 我们将[INAUDIBLE]
Which will take the context, and we'll [INAUDIBLE]

2061
01:52:49,770 --> 01:52:51,374
按Enter键跳过它 
to press Enter to get past it.

2062
01:52:51,374 --> 01:52:52,040
那是在晕倒 
That's fainting.

2063
01:52:54,620 --> 01:52:58,070
胜利稍微更有活力一些 
Victory is a little bit more robust.

2064
01:52:58,070 --> 01:53:02,748
所以胜利就是--你还记得当我们取得胜利时会发生什么吗？
So victory is-- do you remember what happen when we get a victory?

2065
01:53:06,644 --> 01:53:11,027
观众：嗯 它还得检查调平 
AUDIENCE: Well, it has to check leveling up as well.

2066
01:53:11,027 --> 01:53:17,500
它说 你已经击败了你的对手 然后你的XP条增加了 
It says, you've defeated your opponent, then your XP bar increases.

2067
01:53:17,500 --> 01:53:20,212
如果你升级了 它会告诉你你升级了 
Then if you've leveled up, it tells you that you leveled up,

2068
01:53:20,212 --> 01:53:21,480
然后它就离开了 
and then it leaves.

2069
01:53:21,480 --> 01:53:27,850
演讲者1：它告诉你你打败了你的对手 XP条增加了 
SPEAKER 1: So it tells you you defeated your opponent, XP bar increases,

2070
01:53:27,850 --> 01:53:30,700
检查上一级 然后离开 
checks for a level up, and then leaves.

2071
01:53:30,700 --> 01:53:35,810
在显示或不显示升级消息后 它离开 
After displaying the level up message or not, it leaves.

2072
01:53:35,810 --> 01:53:39,460
准确地说 它会将所有东西弹回播放状态 
It pops everything back to the play state, exactly.

2073
01:53:39,460 --> 01:53:42,070
所以请记住 发生的第一件事
So remember, the very first thing that happens

2074
01:53:42,070 --> 01:53:46,780
尽管如此 对手精灵在0.2秒的过程中被打了补丁 
though, the opponent sprite gets tweened over the course of 0.2 seconds,

2075
01:53:46,780 --> 01:53:49,040
它的y值等于虚拟高度 这意味着 
it's y value to virtual height, which means,

2076
01:53:49,040 --> 01:53:50,998
一直到屏幕的底部 对吗？
all the way to the bottom of the screen, right?

2077
01:53:50,998 --> 01:53:56,050
典型的从精灵宝可梦中击败你的对手的动画 
The typical defeated your opponent from Pokemon sort of animation.

2078
01:53:56,050 --> 01:53:58,420
一旦完成 播放胜利的音乐 
Once that's finished, play victory music,

2079
01:53:58,420 --> 01:54:01,190
推送一个战斗信息状态 上面写着 胜利 对吗？
push a battle message state that says, victory, right?

2080
01:54:01,190 --> 01:54:04,860
一旦它从堆栈中弹出 计算XP 
Once that's popped of the stack, calculate the XP,

2081
01:54:04,860 --> 01:54:09,330
也就是说 我刚刚选择了任意加和那个精灵宝可梦时代的所有IV
which is, I just chose arbitrarily sum all the IVs of that Pokemon times

2082
01:54:09,330 --> 01:54:12,500
它是Level 这就是你得到的XP 
it's level, and that's the XP you got.

2083
01:54:12,500 --> 01:54:18,340
推送一个状态 上面写着 你赢得了xXP 对吗？
Push a state that says, you earned x XP, right?

2084
01:54:18,340 --> 01:54:21,985
它是假的 所以这意味着它不接受输入 
It's false, so that means it doesn't take input.

2085
01:54:21,985 --> 01:54:24,610
因此 这意味着这取决于我们 以便将其从堆栈中弹出 
So that means it's up to us in order to pop that off the stack.

2086
01:54:24,610 --> 01:54:29,830
所以1.5秒后 我们播放一段声音 然后我们在XP栏向上移动 
So after 1.5 seconds, we play a sound, and then we tween that XP bar going up,

2087
01:54:29,830 --> 01:54:31,120
对吗？
right?

2088
01:54:31,120 --> 01:54:34,470
这就是发生在这里的事情 self.bustleState.playerxpbar 
So that's what's going on here, self.battleState.playerxpbar,

2089
01:54:34,470 --> 01:54:40,210
我们正在调整数学 人 XP和XP的人 
we're tweening of the math.men, of the XP plus XP,

2090
01:54:40,210 --> 01:54:45,850
或者XP升级 因为如果我们不这样做 它可能会越过XP条的边缘 
or XP to level, because if we don't, it could go past the edge of the XP bar,

2091
01:54:45,850 --> 01:54:49,240
因为我们可以把我们的经验提升到一个水平 对吗？
because we could go over our XP to level, right?

2092
01:54:49,240 --> 01:54:52,330
假设我们有10个经验值 直到我们达到一个等级 我们可以获得20个经验值 
Let's say we have 10 XP till we gain a level, we could gain 20 XP.

2093
01:54:52,330 --> 01:54:53,860
我们会落入10XP的圈套 
We'd be 10 XP overboard.

2094
01:54:53,860 --> 01:54:58,450
因此 我们不想在XP栏的边缘之外补间XP栏 
So we don't want to tween our XP bar past the edge of the XP bar,

2095
01:54:58,450 --> 01:55:00,110
这将是一个图形故障 
it would be a graphical glitch.

2096
01:55:00,110 --> 01:55:05,410
所以算一算 我们的XP加上XP 我们的XP达到了水平 
So a math.men our XP plus XP, and our XP to level,

2097
01:55:05,410 --> 01:55:08,740
它将取两个值中较小的一个 
which will take the lesser of the two values.

2098
01:55:08,740 --> 01:55:12,250
一旦完成 它被补齐 我们将弹出消息 
Once that's done, it's tweened, we're going to pop the message off,

2099
01:55:12,250 --> 01:55:15,760
然后我们将实际添加XP 级别更高 
and then we're going to actually add the XP, level up.

2100
01:55:15,760 --> 01:55:19,390
因此 如果XP大于XP to Level 这就是我们升级的地方 
So this is where we level up if the XP is greater than XP to level.

2101
01:55:19,390 --> 01:55:26,260
播放声音 将XP设置为当前XP减去2级XP 
Play a sound, set the XP to the current XP minus our 2 level XP,

2102
01:55:26,260 --> 01:55:30,130
这意味着我们会有一些结转 对吗？
which will mean that we'll have some carry over, right?

2103
01:55:30,130 --> 01:55:32,060
然后实际调用Level Up函数 
And then actually call the level up function.

2104
01:55:32,060 --> 01:55:35,230
这就是--
Now here is where--

2105
01:55:35,230 --> 01:55:37,990
哦 还有 在那之后 祝贺你 你升级了 
oh, and also after that, congratulations, you've leveled up.

2106
01:55:37,990 --> 01:55:40,570
淡出白色 这只是一个白色淡出这里 
Fadeout white, which is just a white fade out here.

2107
01:55:40,570 --> 01:55:43,360
我用了两次 所以我为它做了一个函数 
I used it twice, so I made a function for it.

2108
01:55:43,360 --> 01:55:46,300
只是在状态中推动淡入淡出 
Just pushes a fade in state.

2109
01:55:46,300 --> 01:55:50,440
停止胜利的音乐 播放田野音乐 流行 推入淡出状态 
Stop the victory music, play the field music, pop, push a fade out state.

2110
01:55:50,440 --> 01:55:56,110
所以不管怎样 当我们取得胜利时 我们会把淡出的颜色变成白色 
So either way, when we've got a victory, we're going to push a fade out white,

2111
01:55:56,110 --> 01:55:58,360
或者我们会把淡出称为白色 对吗？
or we're going to call fade out white, correct?

2112
01:55:58,360 --> 01:56:02,920
所以推送战斗信息状态 然后尽快
So push a battle message state, and then as soon

2113
01:56:02,920 --> 01:56:06,370
当我们按回车键时 因为我们升级了 淡出为白色 
as we press Enter, because we leveled up, fade out to white.

2114
01:56:06,370 --> 01:56:08,690
如果我们没有升级 但我们还是取得了胜利 
And if we didn't level up, but we still got to victory,

2115
01:56:08,690 --> 01:56:10,360
我们仍然需要淡出白色 
we still need to fade out white.

2116
01:56:10,360 --> 01:56:13,280
这就是你们的作业 作业7 
And so this is where your assignment is, assignment 7.

2117
01:56:13,280 --> 01:56:17,517
作业7是 注意我们已经升级了self.playerPokemon级别 
Assignments 7 is, notice that we have self.playerPokemon level up.

2118
01:56:17,517 --> 01:56:19,600
我们需要在这里做的关键事情是
The key thing that we are going to need to do here

2119
01:56:19,600 --> 01:56:23,020
就是添加一个菜单 显示我们是如何升级的 
is add a menu that shows us how we leveled up.

2120
01:56:23,020 --> 01:56:27,160
如果您还记得 playerPokemon Level Up会返回所有统计数据
And if you recall, playerPokemon level up returns all the stats

2121
01:56:27,160 --> 01:56:29,260
你已经提升了这个级别 
that you've increased this level.

2122
01:56:29,260 --> 01:56:34,980
所以你可以显示一个菜单 上面只写着 你的惠普加那个金额 对吗？
So you can show a menu that just says, your HP plus that amount, right?

2123
01:56:34,980 --> 01:56:36,480
您将获得所有四个值 
You're going to get all four values.

2124
01:56:36,480 --> 01:56:38,650
它将爆炸式增长到所有这四个值 
It's going to explode to all four of those values.

2125
01:56:38,650 --> 01:56:42,460
然后你将创造一场新的战斗--
And then you're going to create a new battle--

2126
01:56:42,460 --> 01:56:46,330
或者不是新的战斗菜单 而是你想要的任何新菜单 
or not new battle menu, but a new menu of whatever you want,

2127
01:56:46,330 --> 01:56:51,760
但可能在物品垂直高度的右侧 
but probably on the right side of some vertical height for items.

2128
01:56:51,760 --> 01:56:53,890
这里唯一的区别 唯一的关键
The only difference here, the only key thing

2129
01:56:53,890 --> 01:56:55,930
你将会考虑到
that you're going to take into consideration

2130
01:56:55,930 --> 01:56:59,290
是 我会回到幻灯片 因为我们实际上
is, and I'll go back to the slides, because we're actually

2131
01:56:59,290 --> 01:57:01,660
在这一点上完成了代码的检查 
done at this point going over the code.

2132
01:57:01,660 --> 01:57:07,180
但是选择项 你实际上不能选择任何东西 
But the selection items, you won't be able to actually select anything,

2133
01:57:07,180 --> 01:57:09,220
这将是纯粹的视觉效果 
it's just going to be purely visual.

2134
01:57:09,220 --> 01:57:12,520
因此 您需要编辑所选内容才能选择
So you're going to need to edit selection to have the option

2135
01:57:12,520 --> 01:57:13,504
没有光标 
to not have a cursor.

2136
01:57:13,504 --> 01:57:15,670
这一点在规范中有详细说明 实际上
And this is detailed in the spec, which was actually

2137
01:57:15,670 --> 01:57:17,330
在今天的讲座前发布 
released before lecture today.

2138
01:57:17,330 --> 01:57:18,910
所以你可以看看这个 
So you can take a look at that.

2139
01:57:18,910 --> 01:57:21,760
但您需要对选择进行更改 
But you'll need to make a change to selection.

2140
01:57:21,760 --> 01:57:23,070
但所有的碎片都在那里 
But all the pieces are there.

2141
01:57:23,070 --> 01:57:24,945
这应该是一项相当容易的任务 只要
It should be a fairly easy assignment as long

2142
01:57:24,945 --> 01:57:28,390
当你了解这些州是如何运作的 菜单是如何运作的 
as you understand how the states work, how the menu works,

2143
01:57:28,390 --> 01:57:33,040
以及如何基于这些值创建菜单 
and how to create a menu based on those values,

2144
01:57:33,040 --> 01:57:35,320
以及如何从Level Up中实际获取值 
and how to actually get the values from level up.

2145
01:57:35,320 --> 01:57:38,830
因此 一些我们没有讨论的、我们没有实现的缺失功能
So some missing features that we didn't talk about, which we didn't implement

2146
01:57:38,830 --> 01:57:41,380
例如 屏幕的详细程度 
are, for example, the detailed level of screen,

2147
01:57:41,380 --> 01:57:45,040
抓怪兽是你的任务 对吧？
which is your assignment, monster catching, right?

2148
01:57:45,040 --> 01:57:49,150
在整个过程中我们只有一个精灵宝可梦的派对 
We only have a party of one Pokemon throughout this whole entire thing,

2149
01:57:49,150 --> 01:57:53,500
但可以说 这项运动的主要吸引力之一是能够捕捉到更多 
but one of the arguably main appeals of the game is to be able to catch more.

2150
01:57:53,500 --> 01:57:57,790
所以这将是一些需要添加的东西 需要对可能添加到游戏中的内容进行优先排序 
So that would be something to add, to prioritize probably adding to the game.

2151
01:57:57,790 --> 01:58:00,880
一个现场菜单 可以真正看到你捕捉到的所有精灵宝可梦 
A field menu so can actually look at all the Pokemon you've caught.

2152
01:58:00,880 --> 01:58:04,390
这会很好 这样你就可以真正看到他们有多少惠普 
That would be nice, so you can actually see how much HP they have.

2153
01:58:04,390 --> 01:58:07,330
在物品库存中 因为游戏 常规游戏中都有物品 
In item inventory, because the game, the regular games have items.

2154
01:58:07,330 --> 01:58:10,420
你可以使用魔药 你可以找到金块
You can use potions, you can find gold nuggets

2155
01:58:10,420 --> 01:58:12,370
你卖了一大笔钱 
that you sell for a ton of money.

2156
01:58:12,370 --> 01:58:15,702
不同的能力 目前我们基本上只有一次战斗行动 
Different abilities, currently we only have basically one fight operation,

2157
01:58:15,702 --> 01:58:16,660
这就像是铲球 
which is like a tackle.

2158
01:58:16,660 --> 01:58:19,240
而游戏本身 常规的游戏也有
And the game itself, the regular game has

2159
01:58:19,240 --> 01:58:22,270
就像100多个具有基本属性的不同动作一样 
like over 100 different moves that have elemental attributes,

2160
01:58:22,270 --> 01:58:25,600
做不同的事情 造成地位的影响 
and do different things, and cause status effects,

2161
01:58:25,600 --> 01:58:27,250
提高你或你的对手的威力 
buff you or your opponent.

2162
01:58:27,250 --> 01:58:30,790
所以加入这些是很有吸引力的 也许是
So adding those is appealing, and maybe being

2163
01:58:30,790 --> 01:58:33,814
能够将它们表示为适合的数据 
able to represent them as data is nice to.

2164
01:58:33,814 --> 01:58:36,730
你可以在游戏中遇到的训练者 他们有自己的预设
Trainers that you can encounter in the game that have their own preset

2165
01:58:36,730 --> 01:58:38,954
或者随机化的精灵宝可梦去战斗 
or randomized Pokemon for to fight.

2166
01:58:38,954 --> 01:58:41,620
怪物进化 因为这是最有趣的事情之一
Monster evolution, because that's like one of the funnest things

2167
01:58:41,620 --> 01:58:43,661
是拿着一个非常虚弱的精灵宝可梦 就像提高
is taking a really weak Pokemon, and like raising

2168
01:58:43,661 --> 01:58:46,850
它变得非常强大 并在一定程度上进化 
it to become really strong, and evolving it at a certain level.

2169
01:58:46,850 --> 01:58:52,870
城镇 路线 其他水平 不仅仅是我们的基本正方形区域 
Towns, routes, other levels beyond just our basic square area.

2170
01:58:52,870 --> 01:58:55,600
怪物繁殖 在第二季中介绍 
Monster breeding, which is introduced in the second series,

2171
01:58:55,600 --> 01:58:58,050
这样你就可以拿到两个精灵宝可梦
so that you can take two Pokemon and have a chance

2172
01:58:58,050 --> 01:59:02,074
为了得到一个拥有非常好的统计数据的鸡蛋或者一个非常稀有的精灵宝可梦 
to get an egg with really good stats or a really rare Pokemon from it.

2173
01:59:02,074 --> 01:59:04,990
然后就像一个昼夜循环 也许就是不同的精灵宝可梦出现的地方
And then like a day night cycle maybe where different Pokemon come out

2174
01:59:04,990 --> 01:59:06,560
在一天中的不同时间 
at different times of the day.

2175
01:59:06,560 --> 01:59:11,680
所以你被激励在不同时间打球
So you are incentivize to play at different times

2176
01:59:11,680 --> 01:59:14,590
就是为了这个目的 
of the day for that purpose.

2177
01:59:14,590 --> 01:59:16,450
但精灵宝可梦就到此为止了 
But that was it for Pokemon.

2178
01:59:16,450 --> 01:59:19,030
下周 我们将真正深入到“团结”中去 
Next week we'll actually be diving into Unity.

2179
01:59:19,030 --> 01:59:23,200
所以我们实际上已经完成了爱情2D 这是非常有趣的 
So we're actually done with LOVE 2D, which is a lot of fun,

2180
01:59:23,200 --> 01:59:26,090
但现在我们将探讨如何制作3D游戏 
but now we'll be going into how to make 3D games.

2181
01:59:26,090 --> 01:59:28,840
这是我们下周将制作的游戏的截图 
So this is a screenshot from the game we'll be making next week,

2182
01:59:28,840 --> 01:59:32,470
这是一种3D侧滚Flappy Bird风格的直升机
which is a 3D sort of side scrolling Flappy Bird esque helicopter

2183
01:59:32,470 --> 01:59:38,590
这款游戏是根据著名的网络游戏《直升机游戏》改编的 
game based on a famous web game called Helicopter Game.

2184
01:59:38,590 --> 01:59:44,250
它可以说是Flappy Bird的早期祖先之一 
And it was sort of one of the early ancestors to Flappy Bird.

2185
01:59:44,250 --> 01:59:46,990
在维基百科的页面上 实际上也是这样说的 
On the Wikipedia page, it actually says that too.

2186
01:59:46,990 --> 01:59:51,452
我记得打球 那是在2007年 或者2006年 或者类似的事情 
I remember playing, it was back in like 2007, or 2006, or something like that.

2187
01:59:51,452 --> 01:59:54,160
但你在这个游戏中的目标--这是一个修改后的版本--
But your goal in this game-- this is a modified version of that--

2188
01:59:54,160 --> 01:59:58,130
你的目标是你的--一切都是3D的 但它是一个侧面滚动的视角 
your goal is your-- everything is 3D, but it's a side scrolling perspective.

2189
01:59:58,130 --> 02:00:01,570
因此 这被称为2.5D 因为这个原因 
So this is called 2.5D for that reason.

2190
02:00:01,570 --> 02:00:04,360
你控制着一架直升机 你就是那架紫色直升机 
You're controlling a helicopter, you're the purple helicopter.

2191
02:00:04,360 --> 02:00:07,670
你的目标是在一个无限滚动的世界里 
And your goal is to in an infinitely scrolling world.

2192
02:00:07,670 --> 02:00:11,760
因此 我们将重温无限滚动 但在3D中 请避开摩天大楼 
So we'll revisit infinite scrolling, but in 3D, avoid skyscrapers.

2193
02:00:11,760 --> 02:00:15,880
所以你可以看到那里有一座绿色的摩天大楼 造型简陋 
So you can see there is a green skyscraper, crudely modeled.

2194
02:00:15,880 --> 02:00:18,880
收集硬币 你可以看到那里有一枚硬币 这是一枚3D硬币 
Collect coins, so you can see there's a coin there, it's a 3D coin,

2195
02:00:18,880 --> 02:00:20,440
它将永远在旋转 
it will always be spinning.

2196
02:00:20,440 --> 02:00:22,570
你的硬币在右上角 
Your coins are up at the top right.

2197
02:00:22,570 --> 02:00:24,880
你会看到一个无限滚动的背景 
You'll see a background that's infinitely scrolling.

2198
02:00:24,880 --> 02:00:26,740
然后你会有随机的喷气式飞机
And then you'll have jets that will randomly

2199
02:00:26,740 --> 02:00:31,090
在你上方飞翔 给你另一种层次或维度
fly above you to sort of give you another sort of layer or dimension

2200
02:00:31,090 --> 02:00:32,950
需要注意的障碍 
of obstacles to watch out for.

2201
02:00:32,950 --> 02:00:36,910
这将教会我们很多关于团结是如何运作的基础知识 
And this will teach us a lot of the basics of how unity works,

2202
02:00:36,910 --> 02:00:41,110
所以我们可以开始进入更有趣的事情 比如第一人称
so we can start getting into even more interesting things like a first person

2203
02:00:41,110 --> 02:00:43,090
就像是核心探险游戏 
like sort of core exploration game.

2204
02:00:43,090 --> 02:00:45,820
最后 当我们在门户网站的学期结束时 
And then lastly, when we end the semester with Portal,

2205
02:00:45,820 --> 02:00:48,130
我们将在那里看几件奇特的东西 
we'll look at a couple of fancy things there.

2206
02:00:48,130 --> 02:00:49,380
但精灵宝可梦就到此为止了 
But that was it for Pokemon.

2207
02:00:49,380 --> 02:00:51,255
感谢你们的光临 我们下次再见
Thanks for coming, and I'll see you guys next

2208
02:00:51,255 --> 02:00:52,430
时间到了 
time.
