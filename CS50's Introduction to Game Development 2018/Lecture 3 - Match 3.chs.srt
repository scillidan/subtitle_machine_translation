1
00:00:00,000 --> 00:00:01,984
[音乐播放]

2
00:00:16,390 --> 00:00:17,170
演讲者1：你好 

3
00:00:17,170 --> 00:00:19,810
欢迎来到GD50的第三讲 

4
00:00:19,810 --> 00:00:24,940
今天 我们将讨论第三场比赛 如小方块所示

5
00:00:24,940 --> 00:00:27,190
就在滑梯上 

6
00:00:27,190 --> 00:00:29,950
第三场比赛比2001年稍早一些 

7
00:00:29,950 --> 00:00:32,860
但出现的第一场重要比赛是

8
00:00:32,860 --> 00:00:39,092
屏幕上显示的是《第三场比赛》的一种风格 

9
00:00:39,092 --> 00:00:41,050
这是一个更现代的宝石化身 

10
00:00:41,050 --> 00:00:43,090
但它最初是在2001年出版的 

11
00:00:43,090 --> 00:00:46,130
这实际上是一款网络浏览器游戏 公式非常简单 

12
00:00:46,130 --> 00:00:52,630
前提是你有一个由不同颜色或形状的物品组成的网格 

13
00:00:52,630 --> 00:00:54,820
通常很小 像八乘八 或者更小 

14
00:00:54,820 --> 00:00:57,850
你的目标就是 正如名字所说 简单地匹配三个或更多

15
00:00:57,850 --> 00:00:59,470
他们排成一排 

16
00:00:59,470 --> 00:01:02,140
如果你这样做了 你会得到一定数量的积分 

17
00:01:02,140 --> 00:01:05,080
匹配三个以上通常会给你更多的分数 或者是额外的奖励 

18
00:01:05,080 --> 00:01:10,150
当你匹配三个时 这些块就会从网格中消失 

19
00:01:10,150 --> 00:01:12,280
它们将被更多的街区取代 

20
00:01:12,280 --> 00:01:15,490
还有你挖洞的那些 它们上面的积木

21
00:01:15,490 --> 00:01:17,269
会通过重力坠落 

22
00:01:17,269 --> 00:01:19,310
这是这一公式更现代的化身 

23
00:01:19,310 --> 00:01:22,260
这是糖果粉碎传奇 我想大多数人都知道 

24
00:01:22,260 --> 00:01:28,690
它在移动设备上大受欢迎 在2013、2012年左右 

25
00:01:28,690 --> 00:01:32,380
这可能是最新推出的大型比赛3风格的游戏 

26
00:01:32,380 --> 00:01:34,360
但也有很多其他的观点--

27
00:01:34,360 --> 00:01:36,910
不同的版本 试图添加新的功能和东西 

28
00:01:36,910 --> 00:01:40,449
这是我们今天要做的游戏 我将向你们展示如何 

29
00:01:40,449 --> 00:01:42,490
我们还将介绍一些其他方面的内容 

30
00:01:42,490 --> 00:01:45,070
所以今天的话题 我们首先要讲的是

31
00:01:45,070 --> 00:01:49,450
最重要的是 动态语言的一个基本概念 许多动态语言 

32
00:01:49,450 --> 00:01:50,584
还有卢亚 

33
00:01:50,584 --> 00:01:52,750
它被称为匿名函数 它们是函数

34
00:01:52,750 --> 00:01:56,540
是第一类的 这意味着它们作为数据类型运行 

35
00:01:56,540 --> 00:01:58,700
所以我们可以用这些东西做一些奇特的事情 

36
00:01:58,700 --> 00:02:00,640
补丁 这意味着只拿一样东西 

37
00:02:00,640 --> 00:02:04,870
并将其值内插在从1开始的两个值之间 

38
00:02:04,870 --> 00:02:08,120
随着时间的推移目标价值 这在游戏中是非常重要的事情 

39
00:02:08,120 --> 00:02:09,740
你可以做一些事情 比如移动物体 

40
00:02:09,740 --> 00:02:11,740
我们还可以对它们的不透明度进行补间 

41
00:02:11,740 --> 00:02:16,340
只是一种异步行为 以及异步变量操作 

42
00:02:16,340 --> 00:02:17,710
定时器 非常重要 

43
00:02:17,710 --> 00:02:20,500
我们可以按一定的时间间隔对某事进行计时 

44
00:02:20,500 --> 00:02:22,720
或者在一段时间过去之后

45
00:02:22,720 --> 00:02:27,280
为了让我们克服存储不同时间变量的想法 

46
00:02:27,280 --> 00:02:30,840
或不同的计数器 并分开 并保留

47
00:02:30,840 --> 00:02:32,090
会帮我们处理这件事的 

48
00:02:32,090 --> 00:02:34,630
我们将看看如何使用特定的库来做到这一点 

49
00:02:34,630 --> 00:02:39,780
然后我们将了解比赛3的实际细节 以及如何解决比赛 

50
00:02:39,780 --> 00:02:41,200
以及如何解释这一点 

51
00:02:41,200 --> 00:02:45,010
填入网格 说明我们实际解决匹配的时间 

52
00:02:45,010 --> 00:02:46,960
一旦我们这样做了 就重新填充它 

53
00:02:46,960 --> 00:02:49,240
我们将讨论如何在程序上做到这一点 

54
00:02:49,240 --> 00:02:53,080
我认为 与Breakout更程序化的布局相比 这非常简单

55
00:02:53,080 --> 00:02:58,040
系统 但它仍然是随机性的 我们将讨论这一点 

56
00:02:58,040 --> 00:03:00,820
最后 如果我们有时间 我们将谈论精灵艺术 

57
00:03:00,820 --> 00:03:04,210
和调色板 这是你在做2D游戏时最基本的东西

58
00:03:04,210 --> 00:03:09,220
发展 以及这个和Breakout的精灵单子

59
00:03:09,220 --> 00:03:14,170
利用的是故意使用有限的一组颜色的想法 

60
00:03:14,170 --> 00:03:16,790
一个用于创建2D艺术的调色板 还有

61
00:03:16,790 --> 00:03:20,650
有很多非常酷的 令人印象深刻的事情 我们可以用它来做 

62
00:03:20,650 --> 00:03:25,550
但首先 我想展示一下我们今天在课堂上要讲的内容 

63
00:03:25,550 --> 00:03:28,300
因此 我将进入我的目录 

64
00:03:28,300 --> 00:03:30,370
确保我在正确的地方 我确实是

65
00:03:30,370 --> 00:03:33,310
这是分发代码的一部分 它是在线的 

66
00:03:33,310 --> 00:03:36,370
所以有一个第三场比赛的目录 

67
00:03:36,370 --> 00:03:39,250
有没有人愿意来课堂上演示一下？

68
00:03:42,701 --> 00:03:45,691
好的 [？托尼 ？]上来吧 

69
00:03:45,691 --> 00:03:48,690
好的 只要你准备好了 继续 然后点击这里的Return 

70
00:03:51,510 --> 00:03:52,920
[游戏音乐播放]

71
00:03:52,920 --> 00:03:55,640
好的 这就是我实现的Match 3 

72
00:03:55,640 --> 00:03:58,620
它使用了一套不同的瓷砖 

73
00:03:58,620 --> 00:04:02,220
我们有一些东西正在随着时间的推移而变化 

74
00:04:02,220 --> 00:04:03,650
它是基于箭头键的 

75
00:04:07,280 --> 00:04:10,490
因此 如果在任何瓷砖上按Enter键 就可以用另一个瓷砖翻转它 

76
00:04:10,490 --> 00:04:12,660
在这种情况下 它不一定是匹配的 

77
00:04:12,660 --> 00:04:16,065
所以你可以--是的 

78
00:04:16,065 --> 00:04:17,690
是啊 你的冲浪板有点不走运 

79
00:04:17,690 --> 00:04:19,898
在那里 在最下面 我看到有几个--

80
00:04:19,898 --> 00:04:22,610
一些棕色的 你可以搭配在一起 

81
00:04:22,610 --> 00:04:26,579
因此 一旦你将它们匹配在一起 瓷砖就会下来重新填充 

82
00:04:26,579 --> 00:04:27,620
上面会有新的瓷砖 

83
00:04:30,605 --> 00:04:32,730
所以请注意 我们在左边也有一个计时器 

84
00:04:32,730 --> 00:04:33,810
这是一些正在倒计时的东西 

85
00:04:33,810 --> 00:04:37,470
我们将看看我们将使用的库是如何实际完成的 而不是

86
00:04:37,470 --> 00:04:41,850
涉及管理计数器变量 随着时间的推移跟踪它 

87
00:04:47,540 --> 00:04:50,540
很多游戏实际上会实现它 所以你必须--你只能 

88
00:04:50,540 --> 00:04:52,623
事实上 这将是作业的一部分 

89
00:04:52,623 --> 00:04:56,160
只有在创建匹配的情况下 您才能移动瓷砖 

90
00:04:56,160 --> 00:04:57,730
在这种情况下 有一个--

91
00:04:57,730 --> 00:05:00,980
我们可以看到计时器倒计时 然后一旦你--是的 

92
00:05:00,980 --> 00:05:03,270
如果你没有越过球门 比赛就结束了 

93
00:05:03,270 --> 00:05:04,936
但还是谢谢你 [？托尼 ？]我很感激 

94
00:05:04,936 --> 00:05:05,940
观众：没问题 

95
00:05:05,940 --> 00:05:07,773
演讲者1：简而言之 这就是游戏 

96
00:05:07,773 --> 00:05:09,720
我想指出的另一件事是

97
00:05:09,720 --> 00:05:13,200
转场、白色转场 然后是关卡文字 

98
00:05:13,200 --> 00:05:16,020
这些都是用我们将使用的定时器完成的 

99
00:05:16,020 --> 00:05:18,540
和青少年 我们将在这里的课堂上讨论

100
00:05:18,540 --> 00:05:20,505
作为我们早期的一些例子 

101
00:05:20,505 --> 00:05:23,130
但有很多东西我们还没有触及 但也

102
00:05:23,130 --> 00:05:24,060
我们拥有的东西很多 

103
00:05:24,060 --> 00:05:29,140
它使用精灵和精灵薄片 我们以前也做过这样的事情 

104
00:05:29,140 --> 00:05:32,430
我们切碎一张精灵薄片 然后拿出任何一个四边形

105
00:05:32,430 --> 00:05:34,370
你需要的 并将它们吸引到屏幕上 

106
00:05:34,370 --> 00:05:38,640
这是我们的目标 那就是我们有一个带有第三场比赛的标题屏幕 

107
00:05:38,640 --> 00:05:40,080
在这种情况下 开始和退出游戏 

108
00:05:40,080 --> 00:05:40,954
稍微简单一点 

109
00:05:40,954 --> 00:05:43,780
这一次没有高分 因为我们已经讨论过了 

110
00:05:43,780 --> 00:05:45,490
但我们也有一个水平屏幕 

111
00:05:45,490 --> 00:05:48,150
它告诉我们 在我们真正开始比赛之前 我们处于什么水平 

112
00:05:48,150 --> 00:05:51,030
将会有一个带有文本的过渡框 

113
00:05:51,030 --> 00:05:54,270
它会掉下来 停下来 然后再下来 

114
00:05:54,270 --> 00:05:59,280
所以几乎就像链行为 我们也会看到我们如何实现它 

115
00:05:59,280 --> 00:06:03,510
最后 在底部是我们的主游戏屏幕 

116
00:06:03,510 --> 00:06:05,700
我们有一个级别 一个比分 然后是一个进球 

117
00:06:05,700 --> 00:06:10,090
如果你在计时器用完之前得到了目标点数 

118
00:06:10,090 --> 00:06:12,180
然后你转到2级 3级 4级 

119
00:06:12,180 --> 00:06:16,477
而且每次分数都会增加一个倍数 

120
00:06:16,477 --> 00:06:18,810
所以我今天要谈的第一件事

121
00:06:18,810 --> 00:06:22,590
我们实际上是如何使用更多的东西来获得计时器行为的

122
00:06:22,590 --> 00:06:25,260
不仅仅是跟踪一些我们设置为0的变量 

123
00:06:25,260 --> 00:06:28,210
然后在每次更新时都添加DT 

124
00:06:28,210 --> 00:06:31,230
有一个更好的方法来做到这一点 但首先 我们为什么不

125
00:06:31,230 --> 00:06:33,510
继续 看一下定时器0 

126
00:06:33,510 --> 00:06:37,330
所以我要做的是进入timer0目录 

127
00:06:37,330 --> 00:06:40,380
我要运行它 我们可以在屏幕中央看到 

128
00:06:40,380 --> 00:06:41,550
只是一个非常简单的--

129
00:06:41,550 --> 00:06:44,460
只是一个标签 上面只写着计时器 然后是x秒 

130
00:06:44,460 --> 00:06:49,290
很明显 x每秒都在随时间递增 

131
00:06:49,290 --> 00:06:53,250
那么 粗略地说 有什么简单的方法可以实现这一点呢？

132
00:06:56,208 --> 00:07:00,152
观众：你喜欢Flappy Bird中的随机数吗？

133
00:07:00,152 --> 00:07:04,096
[听不见]如果你只记录你的德尔塔质数

134
00:07:04,096 --> 00:07:11,491
然后把它加到外部的某个变量上 你还做了别的什么？

135
00:07:11,491 --> 00:07:16,025
您甚至可以只显示变量[INAUDIBLE]..

136
00:07:16,025 --> 00:07:16,650
演讲者1：是的 

137
00:07:16,650 --> 00:07:23,700
因此响应是保留一些您在更新中使用dT修改变量 

138
00:07:23,700 --> 00:07:25,110
或显示变量 

139
00:07:25,110 --> 00:07:26,370
是啊 这绝对是一种方法 

140
00:07:26,370 --> 00:07:26,820
你有没有--

141
00:07:26,820 --> 00:07:29,444
观众：是的 我只是想说 保持一个浮动变量 

142
00:07:29,444 --> 00:07:32,146
并不断地向它添加一个DT 并显示它 

143
00:07:32,146 --> 00:07:33,880
但显示截断的版本 

144
00:07:33,880 --> 00:07:34,740
演讲者1：是的 

145
00:07:34,740 --> 00:07:39,730
所以保持一个浮点型变量 但只截断它的增量时间 

146
00:07:39,730 --> 00:07:41,260
你当然可以这么做 

147
00:07:41,260 --> 00:07:44,240
我们将在这里看看我是如何做到的 

148
00:07:44,240 --> 00:07:45,720
这与此非常相似 

149
00:07:45,720 --> 00:07:47,220
不过 这不是一个正确的目录 

150
00:07:47,220 --> 00:07:50,679
所以它在main中的定时器0中 

151
00:07:50,679 --> 00:07:51,720
所以我们确实有一个变量 

152
00:07:51,720 --> 00:07:57,360
所以这里的当前秒 我们将跟踪它 1 2 

153
00:07:57,360 --> 00:08:02,112
Lua实际上没有截断浮点数的概念

154
00:08:02,112 --> 00:08:04,320
因为当你取一个浮点数时 

155
00:08:04,320 --> 00:08:06,411
你把它做成一串 你实际上

156
00:08:06,411 --> 00:08:08,160
必须在它的以下位置进行字符串替换

157
00:08:08,160 --> 00:08:14,104
您可以使用一个名为g SUB的函数来手动去除最后一部分

158
00:08:14,104 --> 00:08:16,770
因为它并没有真正区分整型和浮点型 

159
00:08:16,770 --> 00:08:19,790
它只有一个数字数据类型 

160
00:08:19,790 --> 00:08:22,080
但我们可以通过跟踪

161
00:08:22,080 --> 00:08:24,690
不管我们是否已经度过了一定的时间长度

162
00:08:24,690 --> 00:08:27,840
因为我们知道DT是在几秒钟内给我们的 

163
00:08:27,840 --> 00:08:32,010
我们只需添加变量 然后每次我们

164
00:08:32,010 --> 00:08:34,470
超过1 因为它给了我们--

165
00:08:34,470 --> 00:08:39,330
它通常会给你0.013 无论是1/60或大约1/60秒

166
00:08:39,330 --> 00:08:40,169
是 

167
00:08:40,169 --> 00:08:44,560
一旦计时器--我们将保持一个计时器变量--等于1 

168
00:08:44,560 --> 00:08:47,400
我们只需将当前秒递增1 

169
00:08:47,400 --> 00:08:49,586
然后我们将计时器设置回0 然后

170
00:08:49,586 --> 00:08:51,210
我们只是一遍又一遍地重复 

171
00:08:51,210 --> 00:08:54,960
我们将实际使用模数 所以如果我们略高于1秒 

172
00:08:54,960 --> 00:08:56,400
我们可以解释这一点 

173
00:08:56,400 --> 00:08:57,090
我们这里就是这么做的 

174
00:08:57,090 --> 00:08:59,630
所以第二个计时器得到第二个计时器加上增量时间 

175
00:08:59,630 --> 00:09:01,000
然后如果它大于1 

176
00:09:01,000 --> 00:09:04,920
因此 如果已经过了整整一秒 只需增加当前秒 

177
00:09:04,920 --> 00:09:07,480
然后以1为模对第二个计时器取模 

178
00:09:07,480 --> 00:09:10,240
Lua有一点不同 因为大多数语言只允许

179
00:09:10,240 --> 00:09:13,771
如果某件事是一个整数 你可以对它取模 但因为没有微分 

180
00:09:13,771 --> 00:09:15,520
你可以对浮点数取模 你会

181
00:09:15,520 --> 00:09:17,350
获取剩余的浮点值 

182
00:09:17,350 --> 00:09:21,035
这就是真正做到这一点的基本方式 

183
00:09:21,035 --> 00:09:22,910
但它有几个地方不对劲 

184
00:09:22,910 --> 00:09:26,714
那么 有没有人想建议一下什么是潜在的糟糕或不可扩展的

185
00:09:26,714 --> 00:09:27,880
关于这种方法？

186
00:09:32,921 --> 00:09:34,670
好的 我给你看计时器 这样我们就可以

187
00:09:34,670 --> 00:09:40,080
让我们了解一下 这件事是如何很快失控的 

188
00:09:40,080 --> 00:09:42,890
让我们假设--首先 我将运行计时器1 

189
00:09:42,890 --> 00:09:49,820
让我们进入计时器1 注意现在我们有五个标签 

190
00:09:49,820 --> 00:09:51,800
它们以不同的间隔运行 

191
00:09:51,800 --> 00:09:55,130
第一个计时器每1秒递增一次 

192
00:09:55,130 --> 00:09:58,010
第二定时器每4秒递增一次 

193
00:09:58,010 --> 00:10:03,800
第三个是每4秒递增一次 然后依次递增 3 然后2 

194
00:10:03,800 --> 00:10:08,009
因此 如果我们想要做我们刚刚做过的相同的方法 

195
00:10:08,009 --> 00:10:09,050
这就是我们要做的 

196
00:10:09,050 --> 00:10:12,802
我们有五个变量 五个定时器 

197
00:10:12,802 --> 00:10:14,760
因为我们想要记录一下

198
00:10:14,760 --> 00:10:17,504
不只是一秒钟的事情 

199
00:10:17,504 --> 00:10:19,670
仅仅把这些都放在一张桌子上并不是一件非常容易的事情 

200
00:10:19,670 --> 00:10:22,790
并对其进行迭代 并使用您的迭代逻辑来执行此操作 

201
00:10:22,790 --> 00:10:27,470
我们实际上 因为它们是某种随机的 谁知道是什么顺序 

202
00:10:27,470 --> 00:10:33,830
定时器2用2秒 好的 定时器3用4秒 定时器4用3 然后2 

203
00:10:33,830 --> 00:10:37,209
您必须以难以管理的方式将所有这些都放在单独的变量中 

204
00:10:37,209 --> 00:10:37,834
[?什么事 托尼？]

205
00:10:37,834 --> 00:10:41,706
观众：你能不能只用一秒钟的计时器 甚至一个变量 

206
00:10:41,706 --> 00:10:46,605
然后就在显示器上[INAUDIBLE]

207
00:10:46,605 --> 00:10:47,480
演讲者1：你可以 

208
00:10:47,480 --> 00:10:49,010
是啊 在这种情况下 你可以 

209
00:10:49,010 --> 00:10:54,170
再说一次 Lua的展示 当你--

210
00:10:54,170 --> 00:10:56,645
你得做g潜水艇 还有一些奇怪的弦乐动作 

211
00:10:56,645 --> 00:10:57,770
但是的 你可以做到这一点 

212
00:10:57,770 --> 00:11:01,682
观众：难道你不能只做模1 然后把这个值作为一个字符串吗？

213
00:11:01,682 --> 00:11:04,130
这相当于截断吗？

214
00:11:04,130 --> 00:11:07,970
扬声器1：模1仍然会给你浮点值

215
00:11:07,970 --> 00:11:09,750
因为只有一种数字类型 

216
00:11:09,750 --> 00:11:14,950
所以如果我们把1.00157除以1 我们会得到0.00157 

217
00:11:14,950 --> 00:11:16,450
观众：哦 

218
00:11:16,450 --> 00:11:17,450
好的 

219
00:11:17,450 --> 00:11:21,080
如果你从那个值中减去 我不知道 

220
00:11:21,080 --> 00:11:24,860
所以我想这是一个减去模1的值 

221
00:11:24,860 --> 00:11:25,910
演讲者1：是的 

222
00:11:25,910 --> 00:11:29,030
有人建议我们使用模数 而且我们也可以 

223
00:11:29,030 --> 00:11:33,589
简而言之 我们可以 但如果我们不仅仅是

224
00:11:33,589 --> 00:11:34,880
将值打印到屏幕上 

225
00:11:34,880 --> 00:11:38,840
如果我们有10种不同的东西 比如10种不同的生物

226
00:11:38,840 --> 00:11:40,926
随着时间的推移做着不同的事情 

227
00:11:40,926 --> 00:11:43,550
我们不一定要为每个人都保留一个计时器 

228
00:11:43,550 --> 00:11:44,799
以及每一件事 

229
00:11:44,799 --> 00:11:47,510
在这样一个简单的例子中 是的 可能有一个--

230
00:11:47,510 --> 00:11:49,820
故意说 它也有点复杂 只是

231
00:11:49,820 --> 00:11:50,960
来说明这个问题 

232
00:11:50,960 --> 00:11:54,770
但没错 这是有捷径的 但根本的问题是

233
00:11:54,770 --> 00:12:00,840
我们如何才能摆脱对某件事有五个不同的计时器？

234
00:12:00,840 --> 00:12:02,590
顺便说一句 我将转到下一张幻灯片 

235
00:12:02,590 --> 00:12:03,548
计时器0 简单的方法 

236
00:12:03,548 --> 00:12:05,080
计时器1 丑陋的方式 

237
00:12:05,080 --> 00:12:10,860
Timer2是我发现的使用这个生态系统的干净方式 

238
00:12:10,860 --> 00:12:14,090
有一个很棒的库 你可以自己实现它 

239
00:12:14,090 --> 00:12:17,180
基本的想法是有一个全局计时器

240
00:12:17,180 --> 00:12:20,570
对象 然后管理所有这些不同的事情

241
00:12:20,570 --> 00:12:25,625
在使用我之前提到的匿名函数的能力时 

242
00:12:25,625 --> 00:12:27,000
我将向你们展示这是如何运作的 

243
00:12:27,000 --> 00:12:32,627
因此 在定时器2的Main.Lua中 我们有一组间隔 

244
00:12:32,627 --> 00:12:33,710
我们有一套柜台 

245
00:12:36,530 --> 00:12:42,620
然后我们在这里做的是 我们只是说我得到了1到5 

246
00:12:42,620 --> 00:12:45,427
我们正在调用一个函数调用定时器 

247
00:12:45,427 --> 00:12:47,510
因此 如果您熟悉JavaScript编程 

248
00:12:47,510 --> 00:12:49,310
有一个设定的区间函数 它让

249
00:12:49,310 --> 00:12:52,582
你每隔一段时间就会做一件事 

250
00:12:52,582 --> 00:12:54,290
所以 首先 定时器只是一个库 

251
00:12:54,290 --> 00:12:55,456
我们只是在这里需要它 

252
00:12:55,456 --> 00:13:01,040
它是刀子生态系统的一部分 然后

253
00:13:01,040 --> 00:13:04,940
在这里 我们有几个函数：timer.each和timer.After

254
00:13:04,940 --> 00:13:06,530
我们会用到的 

255
00:13:06,530 --> 00:13:09,440
基本上 它所做的就是你把它

256
00:13:09,440 --> 00:13:12,190
一段时间--计时器 每秒钟 

257
00:13:12,190 --> 00:13:14,809
它是以秒为单位的 你可以给它几秒 

258
00:13:14,809 --> 00:13:17,600
您在这里传递的只是一个函数 一个匿名函数 

259
00:13:17,600 --> 00:13:21,410
它没有名字 但因为Lua和许多动态语言

260
00:13:21,410 --> 00:13:24,750
把职能当做一等公民对待 就像对待

261
00:13:24,750 --> 00:13:30,770
调用 因为它们是数据类型 所以只需将它们传递给函数即可 

262
00:13:30,770 --> 00:13:33,320
这使得我们可以像这样做 否则就不会这样做

263
00:13:33,320 --> 00:13:34,700
做起来有点棘手 

264
00:13:34,700 --> 00:13:37,640
我们可以说 在这段时间之后 

265
00:13:37,640 --> 00:13:41,180
假设我们已经建立了一些结构 它可能只是存储

266
00:13:41,180 --> 00:13:45,650
一张桌子 里面有一堆东西 里面有一段时间 

267
00:13:45,650 --> 00:13:47,840
只需稍后调用这段代码 

268
00:13:47,840 --> 00:13:49,730
它被称为回调函数 

269
00:13:49,730 --> 00:13:52,688
我们只是要把它打回去 然后我们就这么做 

270
00:13:52,688 --> 00:13:55,460
我们会说计数器I得到计数器i加1 

271
00:13:55,460 --> 00:13:59,322
所以我们有所有这些间隔 和所有这些计数器 

272
00:13:59,322 --> 00:14:01,280
因此 基本上 它将为我们管理这一点 

273
00:14:01,280 --> 00:14:04,430
现在我们没有五个变量了 

274
00:14:04,430 --> 00:14:07,630
你确实必须设置你想要的任何东西 

275
00:14:07,630 --> 00:14:09,630
这是你的 这是你的原始人 

276
00:14:09,630 --> 00:14:14,245
你只需要时间的长短 取决于你的问题 

277
00:14:14,245 --> 00:14:15,620
在这种情况下 这就是我们所需要的 

278
00:14:15,620 --> 00:14:18,160
您可能需要更多 这取决于您想要用Timer做什么 

279
00:14:18,160 --> 00:14:20,785
但在这种情况下 我们只想随着时间的推移增加价值 

280
00:14:20,785 --> 00:14:23,734
所以记下计数器 然后记录下时间间隔 

281
00:14:23,734 --> 00:14:26,150
然后我们的代码就从我不知道有多少行 

282
00:14:26,150 --> 00:14:27,860
它要大得多 

283
00:14:27,860 --> 00:14:35,860
我认为是96行 减少到98行 减少到70行 

284
00:14:35,860 --> 00:14:37,800
这是令人难以置信的可伸缩性 

285
00:14:37,800 --> 00:14:41,550
例如 如果我们想要添加另一个8 

286
00:14:41,550 --> 00:14:44,370
我们只需要加8 然后就是那个 

287
00:14:44,370 --> 00:14:48,830
我想我也得这么做 

288
00:14:48,830 --> 00:14:54,750
我得到5到6个 然后你想--需要我的电脑

289
00:14:54,750 --> 00:14:58,260
来关闭我的用户 这样我就可以进行更改 

290
00:14:58,260 --> 00:15:01,090
我们很快就会知道我是不是搞砸了 

291
00:15:05,180 --> 00:15:08,190
所以 是的 基本上我们现在把一切都推迟到Timer了 

292
00:15:08,190 --> 00:15:12,327
我们得到了完全相同的行为 但代码长度要短得多 

293
00:15:12,327 --> 00:15:14,160
好的是 它非常具有说明性 

294
00:15:14,160 --> 00:15:18,330
我们可以说 好的 每一秒 我想要这一大块行为

295
00:15:18,330 --> 00:15:18,840
会发生的 

296
00:15:18,840 --> 00:15:22,440
我不需要看到好的 我在上面有计时器 我在这里有计数器 

297
00:15:22,440 --> 00:15:25,810
好的 在我的DRAW函数中 好的 我必须画出所有这些 

298
00:15:25,810 --> 00:15:30,045
它是迭代的 它是陈述性的 这是最终目标 

299
00:15:30,045 --> 00:15:32,170
在这里 在最底层 它确实起到了作用 

300
00:15:32,170 --> 00:15:34,630
现在它每八秒工作一次 这很好 

301
00:15:34,630 --> 00:15:37,200
一 二 开始了 

302
00:15:37,200 --> 00:15:39,570
超级容易扩展 

303
00:15:39,570 --> 00:15:42,510
我们将在这个习题集中大量使用它 

304
00:15:42,510 --> 00:15:46,350
在未来的演讲中也是如此 只是因为这比保持

305
00:15:46,350 --> 00:15:50,550
追踪一堆反变数 

306
00:15:50,550 --> 00:15:52,780
我们在这里看到的还有另一个功能--

307
00:15:52,780 --> 00:15:56,670
计时器 之后 因为有时你只想等待一段时间 

308
00:15:56,670 --> 00:16:00,720
也许你每隔1秒就有5秒的时间想要一个炸弹滴答作响 

309
00:16:00,720 --> 00:16:03,521
然后5秒后 你想让它爆炸 

310
00:16:03,521 --> 00:16:06,520
你也可以用我们很快会看到的另一个函数来模拟它 

311
00:16:06,520 --> 00:16:12,477
但这可能是两个基于时间的核心函数 

312
00:16:12,477 --> 00:16:15,060
你可以在这里访问这个URL 可以看到刀库 

313
00:16:15,060 --> 00:16:17,950
有一大堆非常好的模块 

314
00:16:17,950 --> 00:16:20,280
我们只是碰巧使用了定时器 它是

315
00:16:20,280 --> 00:16:24,240
补间 以及之后的每一个功能主要是在这个问题上 

316
00:16:24,240 --> 00:16:28,020
但我们将在塞尔达使用另一个名为Event的词[？P-集合 ？]哪里

317
00:16:28,020 --> 00:16:31,250
我们实际上研究了如何调度事件、触发器和其他东西 

318
00:16:31,250 --> 00:16:33,120
并防止我们检查每一帧画面 

319
00:16:33,120 --> 00:16:34,770
哦 我们要做什么？

320
00:16:34,770 --> 00:16:38,350
如果某个墙被打破了 这个框架 然后这样做 

321
00:16:38,350 --> 00:16:40,770
我们可以只调度一个事件我们炸了一堵墙 

322
00:16:40,770 --> 00:16:42,900
我们会讲到那个的 

323
00:16:42,900 --> 00:16:46,970
对于这两种模式的不同之处以及它们的工作原理 有什么疑问吗？

324
00:16:49,490 --> 00:16:51,480
好的 酷 

325
00:16:51,480 --> 00:16:56,070
接下来我想看看--这样我们就可以把它联系起来 

326
00:16:56,070 --> 00:16:58,550
非常快 如果我们想的话 

327
00:16:58,550 --> 00:17:02,940
第三场比赛--哎呀 还有一个计时器

328
00:17:02,940 --> 00:17:06,859
操纵屏幕上的文本 

329
00:17:06,859 --> 00:17:12,318
所有字母都在--这是游戏代码的开始状态 

330
00:17:12,318 --> 00:17:14,609
所有这些字母都有一种与之相关的颜色 

331
00:17:14,609 --> 00:17:17,940
但它们是有计时器的 所以每隔0.075秒 

332
00:17:17,940 --> 00:17:20,183
它们会变成另一种颜色 再变成另一种颜色 

333
00:17:20,183 --> 00:17:22,349
这样我们就不必记录每一封信

334
00:17:22,349 --> 00:17:24,359
单独的颜色 以及它的计时器 

335
00:17:24,359 --> 00:17:27,630
我们可以把它们全部换掉 

336
00:17:27,630 --> 00:17:33,030
如果我们开始游戏 计时器上的其他东西 计时器 

337
00:17:33,030 --> 00:17:36,060
实际上 在那里 这只是减少了一些价值 

338
00:17:36,060 --> 00:17:39,434
每一秒 将计时器减1 就是这样 

339
00:17:39,434 --> 00:17:42,600
我们不需要保留任何东西--我们不需要说什么 除了

340
00:17:42,600 --> 00:17:47,350
这就是使用这种模型的真正好处 

341
00:17:47,350 --> 00:17:51,420
还有一件事 你们可能也注意到了 我会再讲一遍 

342
00:17:51,420 --> 00:17:55,800
这是淡出 淡入 还有那个动画 

343
00:17:55,800 --> 00:17:57,900
这些都是随着时间的推移而发生的事情 

344
00:17:57,900 --> 00:18:01,290
我们实际上并不--我们可以在某种程度上操纵它们 

345
00:18:01,290 --> 00:18:03,660
我们可以跟踪它的某种计数器 

346
00:18:03,660 --> 00:18:07,890
我们也可以说在这段时间内 将这个值更改为这个值 

347
00:18:07,890 --> 00:18:11,050
这是一种更容易对问题进行心理建模的方法 

348
00:18:11,050 --> 00:18:14,220
因此 我们将对此进行说明 

349
00:18:14,220 --> 00:18:16,200
首先 我要去tween0 

350
00:18:16,200 --> 00:18:19,300
所以tween0是做某事的简单方法 

351
00:18:19,300 --> 00:18:23,760
所以我要在这里用Flappy Bird来说明补间

352
00:18:23,760 --> 00:18:24,830
从左到右 

353
00:18:24,830 --> 00:18:29,070
所以在上面 这就是当你打印数字时发生的事情 顺便说一句 

354
00:18:29,070 --> 00:18:29,850
只是默认情况下 

355
00:18:29,850 --> 00:18:32,910
因此 如果你想截断它 是的 你

356
00:18:32,910 --> 00:18:37,829
我想 根据它的大小 能不能把前两个放在一起 

357
00:18:37,829 --> 00:18:40,620
这将产生仅将其显示为整数的效果 

358
00:18:40,620 --> 00:18:44,220
但我们可以看到 在两秒钟的时间里 我们有--

359
00:18:44,220 --> 00:18:47,400
有一点重叠只是因为增量时间可以

360
00:18:47,400 --> 00:18:51,420
两秒多一点 当你加到它的时候 因为它只是

361
00:18:51,420 --> 00:18:55,439
添加自上一帧以来浮点经过的时间长度 

362
00:18:55,439 --> 00:18:58,480
在本例中 我们只是将其相加 直到它大于或等于2 

363
00:18:58,480 --> 00:19:02,335
所以在这种情况下 我们在实际结束的时候是0.01除以2 

364
00:19:02,335 --> 00:19:03,960
有些迭代会比这更少 

365
00:19:03,960 --> 00:19:06,180
所以这一次将是--

366
00:19:06,180 --> 00:19:08,370
是啊 看 那个还不到2.01 

367
00:19:08,370 --> 00:19:11,010
这取决于你的电脑和你的规格 

368
00:19:11,010 --> 00:19:13,320
但Flappy Bird从最左边开始 

369
00:19:13,320 --> 00:19:16,110
所以他有一个x坐标 然后在最后 

370
00:19:16,110 --> 00:19:17,590
他有另一个X坐标 

371
00:19:17,590 --> 00:19:21,735
那么简单的解决方案是什么？

372
00:19:28,750 --> 00:19:32,060
我们知道我们希望这段时间超过两秒 

373
00:19:32,060 --> 00:19:35,550
所以我们可以做的是 我要把tween0拉出来 

374
00:19:42,536 --> 00:19:44,910
在这里 它是2秒的常量

375
00:19:44,910 --> 00:19:46,865
出于这个例子的考虑 

376
00:19:46,865 --> 00:19:48,930
这里是一个精灵 只是一个简单的图像 

377
00:19:48,930 --> 00:19:53,610
这一次我把所有东西都放在一个代码文件中 而不是破坏它

378
00:19:53,610 --> 00:19:57,849
为了简单起见 我们将其划分为子类 因为这些都是非常小的示例 

379
00:19:57,849 --> 00:19:59,140
但我们将其设置为x和y 

380
00:19:59,140 --> 00:20:01,056
哦 顺便说一句 这是另一个Lua的把戏 

381
00:20:01,056 --> 00:20:05,490
您可以在此处使用逗号将两个变量赋给两个值 

382
00:20:05,490 --> 00:20:08,720
因此flappyX逗号flappyY得到0 然后是VIRTUAL_HEIGH

383
00:20:08,720 --> 00:20:10,440
除以2减8 

384
00:20:10,440 --> 00:20:15,484
将这个x设置为0 我们在这里有一个计时器 然后它就是x的终点 

385
00:20:15,484 --> 00:20:17,400
所以我们希望它在屏幕的末尾结束 

386
00:20:17,400 --> 00:20:20,880
所以我们会说虚拟宽度减去他的宽度 然后

387
00:20:20,880 --> 00:20:24,150
这是让项目开始进行的常见样板 

388
00:20:24,150 --> 00:20:30,390
如果它小于移动持续时间--所以如果计时器是0升到2 

389
00:20:30,390 --> 00:20:37,950
但还不到2 我们要加上dT 然后我们要 

390
00:20:37,950 --> 00:20:43,230
基本上 将其分配给末端x中的最低者 

391
00:20:43,230 --> 00:20:49,500
所以它永远不会高于结束x 或者结束x乘以计时器的比率

392
00:20:49,500 --> 00:20:51,030
超过移动持续时间 

393
00:20:51,030 --> 00:20:54,480
所以计时器超过移动持续时间 如果它小于2 

394
00:20:54,480 --> 00:20:59,070
这将是一些值 一些分数小于1 

395
00:20:59,070 --> 00:21:01,620
因此 它基本上只是按比例进行扩展 

396
00:21:01,620 --> 00:21:07,780
这取决于我们将计时器移到0到2之间的距离 

397
00:21:07,780 --> 00:21:09,710
因此 这只是一次规模操作 

398
00:21:09,710 --> 00:21:13,680
这只在从左向右移动物体的情况下才起作用 

399
00:21:13,680 --> 00:21:18,480
或者从0到其他值 但这是一种粗略的、基本的说明方法

400
00:21:18,480 --> 00:21:20,261
一个非常基本的补间操作 

401
00:21:20,261 --> 00:21:21,510
这就是它的本质 

402
00:21:21,510 --> 00:21:25,440
它是时间流逝时间的乘数 

403
00:21:25,440 --> 00:21:28,770
而不是我们实际期待的流逝时间 

404
00:21:28,770 --> 00:21:31,830
而这又一次产生了这样的效果--

405
00:21:31,830 --> 00:21:35,750
它正在调整比率 因为它的计时器超过了移动的持续时间 

406
00:21:35,750 --> 00:21:38,130
它是大于2的东西 但不完全是2除以2 

407
00:21:38,130 --> 00:21:42,690
直到它等于2除以2 并且是1 那么end x乘以1就是end x 

408
00:21:42,690 --> 00:21:47,670
但在此之前 它将是末端x的某个分数 介于0和末端x之间 

409
00:21:47,670 --> 00:21:51,960
所以它的效果是给了我们一个非常基本的补丁 但它有一点--

410
00:21:51,960 --> 00:21:54,810
我们这里有一点事情要处理 

411
00:21:54,810 --> 00:21:56,670
感觉并不是很干净 

412
00:21:56,670 --> 00:22:00,360
你们对这是怎么回事有什么疑问吗？

413
00:22:00,360 --> 00:22:01,800
好的 

414
00:22:01,800 --> 00:22:04,450
所以我们要从这里开始 

415
00:22:04,450 --> 00:22:11,460
因此 首先 有没有想过这可能不是超级可扩展的 

416
00:22:11,460 --> 00:22:13,080
回过头来看最后一个例子？

417
00:22:17,850 --> 00:22:20,699
观众：我想就像以前的情况一样 

418
00:22:20,699 --> 00:22:22,615
让很多物体在屏幕上移动 

419
00:22:22,615 --> 00:22:25,698
演讲者1：是的 如果你的索引对于每个人来说都是不同的呢？

420
00:22:25,698 --> 00:22:28,470
然后你就会有一团乱麻 

421
00:22:28,470 --> 00:22:31,020
如果我们有这样的东西呢？

422
00:22:34,110 --> 00:22:39,090
您不会想要跟踪x的结尾 

423
00:22:39,090 --> 00:22:41,596
它们碰巧都有相同的末端x 

424
00:22:41,596 --> 00:22:43,470
但请注意 它们的移动速度不同 

425
00:22:43,470 --> 00:22:47,025
它们都在以某种随机的数量移动 

426
00:22:47,025 --> 00:22:48,240
观众：一共有几个？

427
00:22:48,240 --> 00:22:52,680
演讲者1：有1000个 

428
00:22:52,680 --> 00:22:54,840
如果我们愿意 我们可以变得更疯狂 

429
00:22:54,840 --> 00:22:58,540
这是一件有趣的事情 就是压力测试 

430
00:22:58,540 --> 00:23:04,000
所以如果我转到Tween1 然后转到Main 最大计时器是10 

431
00:23:04,000 --> 00:23:06,540
所以我们的意思是 尽可能长的时间

432
00:23:06,540 --> 00:23:11,130
任何一只鸟从左到右都需要10秒 

433
00:23:11,130 --> 00:23:14,310
因此 在这里 我们使用基于表的方法 

434
00:23:14,310 --> 00:23:17,830
我们实际上在跟踪1000只鸟 我们说 

435
00:23:17,830 --> 00:23:20,220
好的 这里有一张从1到1,000的空桌 

436
00:23:20,220 --> 00:23:23,480
添加一只新的鸟 在本例中 我们不会添加鸟对象或任何东西 

437
00:23:23,480 --> 00:23:24,750
这只是一张桌子 

438
00:23:24,750 --> 00:23:26,970
它们都是从x=0开始的 左侧 

439
00:23:26,970 --> 00:23:28,485
他们的y是随机的 

440
00:23:28,485 --> 00:23:31,360
因此 它们可以位于屏幕顶部和底部之间的任何位置 

441
00:23:31,360 --> 00:23:32,484
因此 虚拟高度减去24 

442
00:23:32,484 --> 00:23:34,710
24正好是精灵的高度 

443
00:23:34,710 --> 00:23:37,677
我应该把Flappy Sprite Get Height放在那里 

444
00:23:37,677 --> 00:23:40,010
然后是利率 他们都会有自己的利率 

445
00:23:40,010 --> 00:23:41,370
所以Rate得到了数学 随机的 

446
00:23:41,370 --> 00:23:44,790
Math.随机数 没有传入任何值

447
00:23:44,790 --> 00:23:52,030
为您提供一个介于0和0.999999之间的小数值 

448
00:23:52,030 --> 00:23:55,500
这样做的效果是数学 只有两个值的随机数 

449
00:23:55,500 --> 00:23:58,500
如果你通过10和50 它会给你10到50 

450
00:23:58,500 --> 00:24:00,880
但它们始终是整数值 

451
00:24:00,880 --> 00:24:03,830
你不能说像10.0和50.0 然后假设它

452
00:24:03,830 --> 00:24:05,330
都会知道你在说什么 

453
00:24:05,330 --> 00:24:06,790
它只会是整数 

454
00:24:06,790 --> 00:24:08,880
因此 如果你给它一个值 它就会知道 

455
00:24:08,880 --> 00:24:13,050
好的 你是在要求我的浮点数介于0和0.999999之间 

456
00:24:13,050 --> 00:24:16,230
这将作为我们的价值的小数部分

457
00:24:16,230 --> 00:24:20,500
可能希望使用传入了值的math.Ranb来生成 

458
00:24:20,500 --> 00:24:24,870
所以在这里 我们说好的 数学 随机 定时器_最大值减1 

459
00:24:24,870 --> 00:24:26,580
因此 Timer_Max为9 

460
00:24:26,580 --> 00:24:29,460
所以我们的最大定时器是10 抱歉 

461
00:24:29,460 --> 00:24:33,630
所以如果我们减去1 这就是数学 随机10 

462
00:24:33,630 --> 00:24:37,170
所以我们将得到一个介于1和9之间的值 

463
00:24:37,170 --> 00:24:38,880
因此Timer_Max减去1等于9 

464
00:24:38,880 --> 00:24:39,990
如果我说的是10个 对不起 

465
00:24:39,990 --> 00:24:43,260
Timer_Max是10 Timer_Max减1是9 但是

466
00:24:43,260 --> 00:24:46,500
加上数学 随机的 一些分数 

467
00:24:46,500 --> 00:24:49,110
所以无论我们在1之间选择什么值--

468
00:24:49,110 --> 00:24:53,460
实际上在--是的 在1到9之间 

469
00:24:53,460 --> 00:24:58,170
它将是那个价值 指向一些东西 

470
00:24:58,170 --> 00:24:59,670
所以这就是你如何变得随机的--

471
00:24:59,670 --> 00:25:01,378
基本上 在一天结束的时候 这是

472
00:25:01,378 --> 00:25:07,265
如何在Lua和Love2D中获得随机浮点数 

473
00:25:07,265 --> 00:25:08,140
这说得通吗？

474
00:25:08,140 --> 00:25:09,723
你们对此有什么问题吗？

475
00:25:09,723 --> 00:25:12,420
观众：所以你的最终比率可能是从0到--

476
00:25:12,420 --> 00:25:15,461
演讲者1：最终的速率是从1到--在这个例子中 

477
00:25:15,461 --> 00:25:19,620
1%到9.999999 

478
00:25:19,620 --> 00:25:22,450
如果我们希望它是0 我们可以这样做 

479
00:25:22,450 --> 00:25:26,520
这将给我们带来一个效果 就是取我们得到的任何东西 然后减去1 

480
00:25:26,520 --> 00:25:32,070
所以现在它将在0到8.999999之间 

481
00:25:32,070 --> 00:25:32,970
如果我们这样做--

482
00:25:35,650 --> 00:25:39,890
观众：难道每个数学随机数都不能以0结束吗？

483
00:25:39,890 --> 00:25:43,110
演讲者1：不 因为数学随机 如果你传入一个值 

484
00:25:43,110 --> 00:25:46,036
它总是从1到某个值 

485
00:25:46,036 --> 00:25:50,310
问题是 如果您传入一个值 Math.Random会给您0吗？

486
00:25:50,310 --> 00:25:54,560
而在默认情况下 math.Random会给出1和其他值之间的值 

487
00:25:54,560 --> 00:25:57,027
这就是我们这么做的原因 

488
00:25:57,027 --> 00:25:58,110
这不是我们这么做的原因 

489
00:25:58,110 --> 00:26:00,990
我们这样做是为了添加分数部分 这样我们就可以得到

490
00:26:00,990 --> 00:26:04,110
分数浮动在某个值之间 

491
00:26:04,110 --> 00:26:07,132
但没错 如果你想让它介于0和其他值之间 

492
00:26:07,132 --> 00:26:09,090
你只需从最终结果中减去1

493
00:26:09,090 --> 00:26:12,900
因为我们知道我们总是会得到从1到某个值 

494
00:26:12,900 --> 00:26:15,120
如果你从1减去 你永远不会低于0 

495
00:26:15,120 --> 00:26:17,799
它总是从0到其他值 然后在这种情况下 

496
00:26:17,799 --> 00:26:19,590
我们可能只会去掉负1

497
00:26:19,590 --> 00:26:26,640
从TIMER_MAX开始 因此在本例中将介于0和9.999999之间 

498
00:26:26,640 --> 00:26:29,732
但作为一个设计决定 我这样做是为了让我们总是

499
00:26:29,732 --> 00:26:31,440
至少有一个比率1 因为这样它就

500
00:26:31,440 --> 00:26:36,820
如果气温在0.005左右 可能会变得非常非常慢 

501
00:26:36,820 --> 00:26:37,860
你不会想要这样的 

502
00:26:37,860 --> 00:26:38,651
这将需要很长一段时间 

503
00:26:42,510 --> 00:26:45,680
好的 我们有一个计时器 

504
00:26:45,680 --> 00:26:50,095
在这种情况下 我们还没有使用knife.Timer 

505
00:26:50,095 --> 00:26:53,220
基本上 在更新中 我们只是说只要计时器最大值小于--

506
00:26:53,220 --> 00:26:55,980
计时器小于最大计时器 

507
00:26:55,980 --> 00:27:00,560
只有当我们没有超过最大计时器时 这个更新逻辑才会运行 

508
00:27:00,560 --> 00:27:04,532
增加它 然后对于每一只鸟 基本上 我们是

509
00:27:04,532 --> 00:27:06,990
做我们以前做过的事情 只是我们用了

510
00:27:06,990 --> 00:27:09,770
以那只鸟的速率作为比例因子 

511
00:27:09,770 --> 00:27:13,560
是的 这个比率的分母 就是

512
00:27:13,560 --> 00:27:16,710
将会使所有这些鸟类成倍增加

513
00:27:16,710 --> 00:27:19,230
个别 基于他们自己的利率 而不是

514
00:27:19,230 --> 00:27:23,190
一些全球利率 如果这是有意义的话 

515
00:27:23,190 --> 00:27:27,260
然后在这里 我们只是用它们自己的x和y来画它们 

516
00:27:27,260 --> 00:27:30,630
再说一次 我们只是在储存鸟类

517
00:27:30,630 --> 00:27:32,670
在本例中是包含几个变量的表 

518
00:27:32,670 --> 00:27:36,540
这只是一个非常简单的外壳 它的效果是--

519
00:27:36,540 --> 00:27:41,570
哦 我想做的一件事就是在那里加一个0 

520
00:27:41,570 --> 00:27:43,890
我每次都要这么做 因为我没有

521
00:27:43,890 --> 00:27:45,802
适当设置我的权限 

522
00:27:45,802 --> 00:27:47,510
但现在将有10,000只鸟 

523
00:27:47,510 --> 00:27:50,260
所以让我们来看看这是什么样子 

524
00:27:50,260 --> 00:27:53,820
所以它看起来很相似 实际上 但现在它更浓缩了 

525
00:27:53,820 --> 00:27:55,950
我没有注意到帧速率下降 

526
00:27:55,950 --> 00:28:04,340
如果我们愿意 我们可以去love.raw和love.graph ics.print tf

527
00:28:04,340 --> 00:28:15,396
在FPS 然后到字符串 love.timer.getFPS 然后

528
00:28:15,396 --> 00:28:24,330
让我们将其设置为4 然后虚拟高度减去16 

529
00:28:24,330 --> 00:28:26,220
然后又得再来一次 

530
00:28:26,220 --> 00:28:28,990
这应该具有为我们提供帧速率的效果 

531
00:28:28,990 --> 00:28:34,580
所以我们真的可以进行压力测试 看看--

532
00:28:34,580 --> 00:28:35,080
噢 

533
00:28:35,080 --> 00:28:36,670
我犯了一个错 

534
00:28:36,670 --> 00:28:37,440
好的 让我想想 

535
00:28:37,440 --> 00:28:38,820
我做了什么？

536
00:28:38,820 --> 00:28:40,830
推啊 开始啊 

537
00:28:40,830 --> 00:28:42,030
我猜我错过了一个...

538
00:28:42,030 --> 00:28:43,176
是啊 我错过了一个...

539
00:28:46,830 --> 00:28:51,970
这样做 然后这样做 然后再保存一次 

540
00:28:51,970 --> 00:28:52,760
真对不起 

541
00:28:52,760 --> 00:28:54,968
不会有太多这样的编辑 但我想

542
00:28:54,968 --> 00:28:56,670
这将是一个有趣的说明 

543
00:28:56,670 --> 00:28:59,100
因此 现在 这应该会奏效 

544
00:29:01,630 --> 00:29:05,224
Printf 所以我们有这个 

545
00:29:05,224 --> 00:29:08,040
哦 对了 然后只需要打印出来就行了 

546
00:29:08,040 --> 00:29:10,830
它不需要是打印的 

547
00:29:10,830 --> 00:29:12,750
又要存钱了 

548
00:29:12,750 --> 00:29:14,450
抱歉的 

549
00:29:14,450 --> 00:29:18,220
我希望这将是值得的 

550
00:29:18,220 --> 00:29:20,326
好了 5160 

551
00:29:20,326 --> 00:29:21,700
好的 这需要几秒钟 

552
00:29:21,700 --> 00:29:24,540
它必须在最后几次之间进行内插

553
00:29:24,540 --> 00:29:26,964
它是为画框拉的 当你启动时 

554
00:29:26,964 --> 00:29:28,380
它没有所需的数据 

555
00:29:28,380 --> 00:29:31,620
所以 一万 很容易 

556
00:29:31,620 --> 00:29:34,360
让我们做一百万吧 

557
00:29:34,360 --> 00:29:39,480
所以我们有10,000,100,000,100万 

558
00:29:39,480 --> 00:29:41,660
我真的要更改这些权限 

559
00:29:41,660 --> 00:29:44,440
不过 我越来越擅长练习我的密码了 

560
00:29:44,440 --> 00:29:46,868
去吧 去做那件事 

561
00:29:46,868 --> 00:29:48,150
哦 哦 

562
00:29:48,150 --> 00:29:50,640
哦 我的笔记本电脑坏了 

563
00:29:50,640 --> 00:29:53,700
天哪 但它们都是独立于帧速率移动的 

564
00:29:53,700 --> 00:29:56,910
这只是三角洲时间有多强大的证明 

565
00:29:56,910 --> 00:29:59,070
他们都在10秒后移动到那里 

566
00:29:59,070 --> 00:30:01,670
我们还有10.6秒 这不是很好 

567
00:30:01,670 --> 00:30:04,470
这意味着这是最后一帧之间经过的时间 

568
00:30:04,470 --> 00:30:08,850
但我的笔记本电脑显然不能处理屏幕上的一百万只鸟 

569
00:30:08,850 --> 00:30:12,450
但它可以处理10,000 甚至100,000 

570
00:30:12,450 --> 00:30:13,740
这只是一种有趣的方式--

571
00:30:13,740 --> 00:30:15,420
这是一件有趣的事情 

572
00:30:15,420 --> 00:30:18,210
通常 当您想要对您的游戏进行压力测试时 

573
00:30:18,210 --> 00:30:21,210
只需设置每秒帧数 然后就可以疯狂了 

574
00:30:21,210 --> 00:30:22,740
只是添加了很多东西 

575
00:30:22,740 --> 00:30:25,710
只要看看你的电脑有什么能力 因为你

576
00:30:25,710 --> 00:30:29,630
我想 这样可以发现新的、有趣的东西 也许只是

577
00:30:29,630 --> 00:30:32,840
看看你的代码也有多好 

578
00:30:32,840 --> 00:30:35,100
所以Tween0 简单的方法 

579
00:30:35,100 --> 00:30:38,490
我们只有变量和一个计数器 

580
00:30:38,490 --> 00:30:40,110
没有桌子之类的 

581
00:30:40,110 --> 00:30:43,969
如果我们有很多东西 Tween2是一个很好的方法

582
00:30:43,969 --> 00:30:45,510
我们想要随着时间的推移来操纵 

583
00:30:45,510 --> 00:30:49,650
但如果现在我们想要其中的一些改变呢

584
00:30:49,650 --> 00:30:52,950
他们随着时间的推移而变得不透明还是什么？

585
00:30:52,950 --> 00:30:55,241
事情开始变得有点复杂了 

586
00:30:55,241 --> 00:30:57,990
顺便说一句 我应该早点把这个放在代码里 

587
00:30:57,990 --> 00:31:03,360
但这是刀库负责计时器 

588
00:31:03,360 --> 00:31:05,806
以及我们将会看到的许多其他东西 

589
00:31:05,806 --> 00:31:07,680
它在这里列出了一系列模块--

590
00:31:07,680 --> 00:31:09,986
状态机的行为 这就像什么

591
00:31:09,986 --> 00:31:13,110
我们一直在为状态机做准备 但它们有自己的版本 

592
00:31:13,110 --> 00:31:16,290
Knife.ind 因此您可以将参数预绑定到函数 

593
00:31:16,290 --> 00:31:18,230
并创建子函数 

594
00:31:18,230 --> 00:31:20,940
它被称为Currying 但创建了其他函数的子函数

595
00:31:20,940 --> 00:31:23,750
它们有预先确定的变量 

596
00:31:23,750 --> 00:31:28,740
Knife.Chain 实际上 我们稍后会看到如何使用它 

597
00:31:28,740 --> 00:31:30,570
召集会是用于协作性的 

598
00:31:30,570 --> 00:31:32,520
我们将在统一的背景下看到协程 

599
00:31:32,520 --> 00:31:36,570
但从根本上说 它们是可以暂停其状态以便稍后使用的函数 

600
00:31:36,570 --> 00:31:41,580
Knife.我们将在两周内为塞尔达使用这一事件 

601
00:31:41,580 --> 00:31:44,510
也许甚至是下周 如果我能为马里奥安排的话 

602
00:31:44,510 --> 00:31:46,980
Memoize是用于记忆的 

603
00:31:46,980 --> 00:31:49,810
这就像是与动态编程相关的事情 

604
00:31:49,810 --> 00:31:51,720
序列化系统 

605
00:31:51,720 --> 00:31:55,620
在团结的背景下 了解系统也将是有用的 

606
00:31:55,620 --> 00:31:59,230
Unity的大部分结构使用实体组件系统 

607
00:31:59,230 --> 00:32:01,830
Knife.test 最后是Knife.Timer 

608
00:32:01,830 --> 00:32:05,970
这就是我们最终将使用的库 这可能是我最喜欢的库

609
00:32:05,970 --> 00:32:09,290
存在于Love2D生态系统中 

610
00:32:09,290 --> 00:32:12,540
说到这里 我们现在来看看tween2 

611
00:32:12,540 --> 00:32:22,620
我将进入第二节 所以现在我们不仅有运动 还有

612
00:32:22,620 --> 00:32:23,790
他们的不透明 

613
00:32:23,790 --> 00:32:26,460
它们都从不同的不透明度级别开始 

614
00:32:26,460 --> 00:32:30,870
我们不仅想改变他们的运动

615
00:32:30,870 --> 00:32:34,110
随着时间的推移 也是不透明的 

616
00:32:34,110 --> 00:32:39,247
所以如果我们决定 事情会变得更棘手

617
00:32:39,247 --> 00:32:40,830
在我们目前的情况下做到这一点 

618
00:32:40,830 --> 00:32:47,090
完全可行 但我们现在该如何着手改变 

619
00:32:47,090 --> 00:32:50,370
他们的不透明就像现在一样？

620
00:32:50,370 --> 00:32:54,555
你如何改变怨恨的不透明性？

621
00:32:54,555 --> 00:33:01,897
受众：变量和图形[INAUDIBLE]

622
00:33:01,897 --> 00:33:04,438
演讲者1：这是一个变量吗--你能再说一遍吗？

623
00:33:04,438 --> 00:33:06,229
听众：我忘记了确切的函数名称 

624
00:33:06,229 --> 00:33:13,365
但这就像是把图像放在屏幕上的爱 

625
00:33:13,365 --> 00:33:15,390
演讲者1：The love.graph ics.Drag 

626
00:33:15,390 --> 00:33:18,900
观众：这里面不是有争论吗？

627
00:33:18,900 --> 00:33:22,830
演讲者1：所以它实际上不是那个函数的参数 

628
00:33:22,830 --> 00:33:24,120
所以我现在就给你们展示一下 

629
00:33:24,120 --> 00:33:27,930
因此 为了在不同的不透明度下绘制一些东西 

630
00:33:27,930 --> 00:33:33,250
它实际上是love.graph ics.setcolor 我们在这里这样做 

631
00:33:33,250 --> 00:33:38,760
所以回想一下 Love2D是一个状态机 以及它是如何绘制事物的 

632
00:33:38,760 --> 00:33:41,040
你基本上可以给任何东西设置颜色

633
00:33:41,040 --> 00:33:47,520
无论是字体、图像还是形状 你都可以画出来 

634
00:33:47,520 --> 00:33:53,432
如果你只传255,255,255 那就是白色 

635
00:33:53,432 --> 00:33:55,140
然后如果你给它一个不透明的 这

636
00:33:55,140 --> 00:33:58,590
是第四个参数 这是它的阿尔法分量 

637
00:33:58,590 --> 00:34:00,890
那么这就是它的透明度 

638
00:34:00,890 --> 00:34:03,570
所以我们也可以用其他颜色来做这件事 

639
00:34:03,570 --> 00:34:06,153
我们可以这样做 如果我们想把它染成红色 

640
00:34:06,153 --> 00:34:07,890
同时也要让它变得透明 

641
00:34:07,890 --> 00:34:12,010
如果我们只做25500只鸟 我们就能做到 不透明 

642
00:34:12,010 --> 00:34:14,580
但如果你只是想操纵不透明度 而不是--

643
00:34:14,580 --> 00:34:18,389
或者它的透明度或者它的阿尔法与它的颜色无关 

644
00:34:18,389 --> 00:34:21,469
并保持相同的颜色 你只要把它弄白就行了 

645
00:34:21,469 --> 00:34:25,139
如果你做的是黑色的 什么都不会出现 

646
00:34:25,139 --> 00:34:26,219
实际上 这是真的吗？

647
00:34:26,219 --> 00:34:27,010
让我来验证一下 

648
00:34:29,940 --> 00:34:34,350
我很确定这是对的 但我可能错了 

649
00:34:38,860 --> 00:34:40,340
谢天谢地 我是对的 

650
00:34:40,340 --> 00:34:41,830
好的 

651
00:34:41,830 --> 00:34:44,931
或者它们只是黑色 而且也有黑色的背景 

652
00:34:44,931 --> 00:34:46,389
你有什么问题吗？托尼？？]

653
00:34:46,389 --> 00:34:46,930
观众：没有 

654
00:34:46,930 --> 00:34:49,300
演讲者1：哦 好的 

655
00:34:49,300 --> 00:34:58,780
因此 我们将相信这是正确的 

656
00:34:58,780 --> 00:35:06,391
回到这个例子的主旨 

657
00:35:06,391 --> 00:35:07,390
我们又有了Timer_Max 

658
00:35:07,390 --> 00:35:10,250
事实上 我们真的没有太大变化 

659
00:35:10,250 --> 00:35:14,560
我们改变的是 我们仍然有我们的鸟 

660
00:35:14,560 --> 00:35:18,450
我们需要跟踪他们的x、y和他们的比率 

661
00:35:18,450 --> 00:35:19,887
嗯 不一定是他们的速度 

662
00:35:19,887 --> 00:35:21,970
哦 好吧 他们的价格 是啊 因为我们实际上

663
00:35:21,970 --> 00:35:24,011
循环遍历其中的每一个 然后创建

664
00:35:24,011 --> 00:35:26,020
两次操作之间的计时器 

665
00:35:26,020 --> 00:35:28,160
以及它们的不透明性 

666
00:35:28,160 --> 00:35:29,980
哦 对了 它们以不透明度0开始 

667
00:35:29,980 --> 00:35:35,500
淡出到55岁 不管他们--

668
00:35:38,820 --> 00:35:43,150
它们的不透明度的变化速度与它们的x的变化速度相同 

669
00:35:43,150 --> 00:35:44,950
因此 距离越远 他们需要的时间就越长 

670
00:35:44,950 --> 00:35:49,510
它们褪色到完全不透明的速度就越慢 我们在这里看到了这一点 

671
00:35:49,510 --> 00:35:51,855
所以对于k鸟和成对的鸟来说 

672
00:35:51,855 --> 00:35:55,490
所以 对于每一只鸟 我们只需设置一个吐温 然后这个就是吐温 

673
00:35:55,490 --> 00:36:00,550
所以计时器 我想我在这上面有一张幻灯片 对吗？

674
00:36:00,550 --> 00:36:05,710
一个超酷有用的功能 也超好用 它

675
00:36:05,710 --> 00:36:10,940
使用迭代 就像timer.each、timer.After一样 它需要一个定义 

676
00:36:10,940 --> 00:36:13,450
因此 在本例中 它不接受匿名函数

677
00:36:13,450 --> 00:36:15,450
像其他人一样 因为我们并不是真的

678
00:36:15,450 --> 00:36:19,354
说我想做一些不确定的行为

679
00:36:19,354 --> 00:36:20,770
在这次行动的过程中 

680
00:36:20,770 --> 00:36:23,140
我想做的只是改变一些价值观 

681
00:36:23,140 --> 00:36:25,070
我想对它们进行插补 

682
00:36:25,070 --> 00:36:31,090
所以我们要做的就是传入一个--这是它的语法 

683
00:36:31,090 --> 00:36:35,820
我们传入方括号 这是我们想要更改的实际内容 

684
00:36:35,820 --> 00:36:37,900
在这种情况下 我想换一只鸟 

685
00:36:37,900 --> 00:36:41,620
我想让小鸟以某种方式改变 然后

686
00:36:41,620 --> 00:36:44,590
我希望它的价值观朝着以下方向改变 

687
00:36:44,590 --> 00:36:50,230
我希望x变为结束x 并且我希望它的不透明度变为255 

688
00:36:50,230 --> 00:36:54,019
我想在小鸟身上做 Rate 所以这只小鸟 Rate 

689
00:36:54,019 --> 00:36:55,060
每只鸟都在储存它 

690
00:36:55,060 --> 00:36:57,850
所以 对于得到2分的鸟类来说 那么它就是

691
00:36:57,850 --> 00:37:01,630
X将在2秒的过程中结束 

692
00:37:01,630 --> 00:37:06,730
它的不透明度将在2秒内达到255 

693
00:37:06,730 --> 00:37:10,620
你想放多少就放多少 放多少就放多少--

694
00:37:10,620 --> 00:37:15,334
您可以在此处放置尽可能多的变量和实体 

695
00:37:15,334 --> 00:37:17,500
实体是您想要更改的任何内容

696
00:37:17,500 --> 00:37:21,220
具有字段、任何基于表或基于类的结构 

697
00:37:21,220 --> 00:37:25,810
你可以把它们中的任何一个放在这里 然后把它们放在一起--

698
00:37:25,810 --> 00:37:29,830
如果他们都有相同的比率 那么就用这种方式进行手术 

699
00:37:29,830 --> 00:37:33,040
所以我们需要做的就是在这里添加--

700
00:37:33,040 --> 00:37:36,370
它就像两行代码 但现在我们很容易地将其更改为

701
00:37:36,370 --> 00:37:40,067
我们一次只能在两样东西之间做补丁 

702
00:37:40,067 --> 00:37:42,400
这就是定时器的力量 我们会看到的 

703
00:37:42,400 --> 00:37:47,140
所以回到第三场比赛 如果我们想再看一遍的话 

704
00:37:49,660 --> 00:37:54,190
这是补丁 那是补丁 

705
00:37:54,190 --> 00:37:59,980
所以白色 前景 只是一个矩形

706
00:37:59,980 --> 00:38:01,320
它充满了整个屏幕 

707
00:38:01,320 --> 00:38:03,550
它只是一个白色的长方形 

708
00:38:03,550 --> 00:38:08,770
我将其设置为定时器 补间不透明度从0到255 

709
00:38:08,770 --> 00:38:13,570
在调用之前 如果我们从开始到开始游戏状态 

710
00:38:13,570 --> 00:38:18,550
然后如果我们从游戏状态的开始 

711
00:38:18,550 --> 00:38:23,160
在级别文本下降之前 它将从255降到0 

712
00:38:23,160 --> 00:38:26,810
所以它的反面是青少年 然后它所做的

713
00:38:26,810 --> 00:38:28,560
只是在屏幕上画一个矩形 

714
00:38:28,560 --> 00:38:32,502
但这就是你如何得到一个非常简单的过渡 

715
00:38:32,502 --> 00:38:33,710
褪色为黑色也是如此 

716
00:38:33,710 --> 00:38:35,080
如果您想要将整个屏幕淡出为黑色 

717
00:38:35,080 --> 00:38:37,310
只需画一个屏幕大小的矩形 

718
00:38:37,310 --> 00:38:42,995
然后将其不透明度从0补间到255 反之亦然 

719
00:38:42,995 --> 00:38:44,620
这就是你如何得到一个简单的过渡 

720
00:38:44,620 --> 00:38:45,828
它可以是你想要的任何颜色 

721
00:38:45,828 --> 00:38:48,280
这可能是一个红色过渡 

722
00:38:48,280 --> 00:38:54,970
然后是水平文本 这只是y轴上的一个补间 对吗？

723
00:38:54,970 --> 00:38:59,740
然后我只有一些矩形 love.graph 带文本的矩形 

724
00:38:59,740 --> 00:39:04,600
它只是写着计时器 像是虚拟高度除以2减去8 

725
00:39:04,600 --> 00:39:08,260
然后是定时器 1之后 

726
00:39:08,260 --> 00:39:10,650
所以如果我们想的话我们可以把它拉上来 

727
00:39:10,650 --> 00:39:14,070
我们可以看到这是如何运作的 

728
00:39:14,070 --> 00:39:17,980
今天主要发行版的代码会更宽泛一些

729
00:39:17,980 --> 00:39:20,950
只是因为这其中很多都是概念性的 

730
00:39:20,950 --> 00:39:27,430
但在开始游戏状态下--实际上 在开始状态下

731
00:39:27,430 --> 00:39:29,120
就是我们走的时候 

732
00:39:29,120 --> 00:39:33,130
所以这些颜色 字母表 以及所有的东西都是匹配3文本的内容 

733
00:39:33,130 --> 00:39:34,060
如果你好奇的话 

734
00:39:34,060 --> 00:39:37,960
所有这些都回到了我之前所说的开始屏幕

735
00:39:37,960 --> 00:39:41,310
在计时器上用不同的颜色进行匹配3 

736
00:39:41,310 --> 00:39:43,250
这些只是一些颜色的表格 

737
00:39:43,250 --> 00:39:47,140
请注意 这是RGBA 然后我只是在表演

738
00:39:47,140 --> 00:39:49,550
每隔0.075秒对他们进行一次洗牌 

739
00:39:49,550 --> 00:39:52,630
所以2会得到1 反之亦然 

740
00:39:52,630 --> 00:39:58,390
它会全部下降 然后6每0.75秒就会上升到1 

741
00:39:58,390 --> 00:40:01,140
然后M映射到这个 A映射到这个 

742
00:40:01,140 --> 00:40:05,080
T到这个 C H 3 就是这样 

743
00:40:05,080 --> 00:40:09,190
这是在开始状态的第44行完成的 

744
00:40:09,190 --> 00:40:16,120
但我要向你们展示的是过渡的青少年时期 

745
00:40:16,120 --> 00:40:21,730
因此 在这里的开始状态中 在更新函数中 

746
00:40:21,730 --> 00:40:24,690
它说如果我们按Enter 我们当前的菜单项

747
00:40:24,690 --> 00:40:29,960
是1 意味着我们在开始游戏 而不是退出游戏 计时器 

748
00:40:29,960 --> 00:40:33,760
注意 我们有一个Finish函数 它将显示--

749
00:40:33,760 --> 00:40:37,210
实际上 我将在接下来的几个示例中向您展示 链条

750
00:40:37,210 --> 00:40:38,350
举个例子 

751
00:40:38,350 --> 00:40:40,360
但Finish只是一个函数 您可以

752
00:40:40,360 --> 00:40:43,930
追着任何计时器跑 只要它说 嘿 当这个结束时 

753
00:40:43,930 --> 00:40:47,330
运行这段代码 注意这里使用匿名函数 

754
00:40:47,330 --> 00:40:48,070
简单得不得了 

755
00:40:48,070 --> 00:40:52,337
所以我们可以说 好的 青少年 在一秒钟的过程中 

756
00:40:52,337 --> 00:40:55,420
请注意 我们将self传递到这里是因为我们想要控制自己 

757
00:40:55,420 --> 00:40:57,211
我们有一个我们想要操纵的价值 

758
00:40:57,211 --> 00:40:59,350
所以就是自己 过渡阿尔法 

759
00:40:59,350 --> 00:41:02,290
所以我们说我想要我的过渡期阿尔法 

760
00:41:02,290 --> 00:41:07,240
我希望它设置为255 默认情况下我们将其设置为0 所以在最高层 

761
00:41:07,240 --> 00:41:13,100
在这里 在第60行 过渡Alpha就是我们的白色矩形

762
00:41:13,100 --> 00:41:14,160
填充整个屏幕 

763
00:41:14,160 --> 00:41:17,256
我只是说将它设置为0 这样我们就根本看不到它了 

764
00:41:17,256 --> 00:41:18,380
它将是看不见的 

765
00:41:18,380 --> 00:41:20,150
不管发生什么 它都还在那里 

766
00:41:20,150 --> 00:41:23,450
它是隐藏的 但在我们按回车键后 

767
00:41:23,450 --> 00:41:27,770
在1秒内增加到255 然后在完成后 

768
00:41:27,770 --> 00:41:29,580
注意这是很熟悉的 对吗？

769
00:41:29,580 --> 00:41:31,640
GStateMachine更改开始游戏 

770
00:41:31,640 --> 00:41:33,990
在那之后 我们将采用开始游戏状态 

771
00:41:33,990 --> 00:41:35,150
我们的及格等级是1分 

772
00:41:35,150 --> 00:41:38,810
我们要开始游戏了 然后我们要移除这个颜色 

773
00:41:38,810 --> 00:41:41,780
把计时器从--这实际上是

774
00:41:41,780 --> 00:41:47,330
在这种情况下不需要 但您可以从计时器中删除计时器 

775
00:41:47,330 --> 00:41:49,970
如果你有一些事情一直在进行--

776
00:41:49,970 --> 00:41:53,180
在这种情况下 颜色计时器 假设我们从这个状态

777
00:41:53,180 --> 00:41:55,940
到下一个状态 下一个状态没有所有这些颜色 

778
00:41:55,940 --> 00:41:58,320
对 匹配3种颜色 

779
00:41:58,320 --> 00:42:01,100
所以我们不需要保持--因为计时器是一个全局对象 

780
00:42:01,100 --> 00:42:05,120
它将不断更新 一次又一次 

781
00:42:05,120 --> 00:42:07,940
我们不需要特定的计时器来无限期地存在 

782
00:42:07,940 --> 00:42:11,300
我们可以删除这个 因为它已经不再相关了 

783
00:42:11,300 --> 00:42:14,990
但这就是我们从一个屏幕进行简单转换所需的全部内容

784
00:42:14,990 --> 00:42:15,800
给另一个人 

785
00:42:15,800 --> 00:42:23,320
只需在实际渲染函数中向下提供此过渡Alpha 255即可 

786
00:42:23,320 --> 00:42:24,510
它在哪里?

787
00:42:24,510 --> 00:42:31,290
就在这里 

788
00:42:31,290 --> 00:42:34,779
所以就在这里 

789
00:42:34,779 --> 00:42:35,820
画出我们的过渡矩形 

790
00:42:35,820 --> 00:42:39,000
它将被画在最后 这样当我们最终

791
00:42:39,000 --> 00:42:42,540
确实得到了一个过渡 但它自己 过渡Alpha 

792
00:42:42,540 --> 00:42:44,040
这就是我们真正需要的 

793
00:42:44,040 --> 00:42:45,999
我们需要保留变量 然后无论何时

794
00:42:45,999 --> 00:42:48,373
我们想随着时间的推移进行某种手术 

795
00:42:48,373 --> 00:42:49,480
只要用定时器就行了 

796
00:42:49,480 --> 00:42:51,510
就这么简单 

797
00:42:51,510 --> 00:42:52,920
但那是有点--

798
00:42:52,920 --> 00:42:54,003
这是一个相关的切线 

799
00:42:54,003 --> 00:42:59,580
无论如何 我们都会讨论它 但这是第一个用例

800
00:42:59,580 --> 00:43:03,390
我在这个项目中想到的 然后还有标签 

801
00:43:03,390 --> 00:43:05,310
一会儿我会给你看标签的 

802
00:43:05,310 --> 00:43:08,760
但我想在此之前 让我们先讨论一下链接 

803
00:43:08,760 --> 00:43:12,510
所以你们可能玩了很多游戏

804
00:43:12,510 --> 00:43:15,302
其中可能有一个剪辑场景 而你正在看的是一个角色 

805
00:43:15,302 --> 00:43:18,468
他们走着 也许他们转过身 朝另一个方向走去 

806
00:43:18,468 --> 00:43:20,440
他们走上前去 然后跟你说话 

807
00:43:20,440 --> 00:43:23,940
有一个对话框 然后他们可能会做一个动画或其他什么 

808
00:43:23,940 --> 00:43:26,610
然后可能会发生一些其他的事情 

809
00:43:26,610 --> 00:43:28,860
在某种预定的道路上 

810
00:43:28,860 --> 00:43:30,660
这是一条非常离散的道路 

811
00:43:30,660 --> 00:43:32,259
这不是随机的 

812
00:43:32,259 --> 00:43:33,300
这是事先安排好的 

813
00:43:33,300 --> 00:43:37,320
这是一系列的步骤 一个连续的 

814
00:43:37,320 --> 00:43:42,120
这就是将事物链接在一起的概念是相关的

815
00:43:42,120 --> 00:43:46,067
当我们开始计时时 因为当我们完成计时时

816
00:43:46,067 --> 00:43:48,150
一些--因为通常情况下 很多这样的事情

817
00:43:48,150 --> 00:43:50,220
随着时间的推移而发生 

818
00:43:50,220 --> 00:43:54,210
在五秒钟的过程中 NPC1将向北行走 

819
00:43:54,210 --> 00:43:58,934
然后他们会向左转 然后他们会说些什么 

820
00:43:58,934 --> 00:43:59,850
我们想以此为榜样 

821
00:43:59,850 --> 00:44:02,190
我们不想基本上有这样的变量

822
00:44:02,190 --> 00:44:07,480
如果NPC1在此磁贴上 则执行此操作 

823
00:44:07,480 --> 00:44:12,270
如果NPC.DialogueOpen 则执行此操作 

824
00:44:12,270 --> 00:44:15,970
我们基本上是想说走到这里 做这个 做这个 

825
00:44:15,970 --> 00:44:24,780
以平坦、轻松--或者至少是半平坦、简单的顺序--来做这件事 

826
00:44:24,780 --> 00:44:27,930
我举了几个例子来说明如何使用计时器来实现这一点

827
00:44:27,930 --> 00:44:30,810
用于一些半基本的用例 

828
00:44:30,810 --> 00:44:33,060
所以chain0是第一个 

829
00:44:33,060 --> 00:44:34,410
所以这只是Flappy Bird 

830
00:44:34,410 --> 00:44:38,700
他从左到右 然后向下 然后再向左转 

831
00:44:38,700 --> 00:44:41,790
然后他就上去了 

832
00:44:41,790 --> 00:44:46,570
我们建模的基本方式是什么--

833
00:44:46,570 --> 00:44:49,680
我们要实施这个计划吗？

834
00:44:49,680 --> 00:44:50,430
只是即兴表演 

835
00:44:55,210 --> 00:44:58,080
观众：我们可以用这个结束的东西来做--

836
00:44:58,080 --> 00:45:00,330
演讲者1：我们会 

837
00:45:00,330 --> 00:45:05,610
如果我们不知道Finish 我们会怎么做呢？

838
00:45:05,610 --> 00:45:08,570
在我讲到那个例子之前 我不应该放弃完成 

839
00:45:08,570 --> 00:45:09,820
我有点超前了 

840
00:45:12,640 --> 00:45:15,120
我们可以想象有人可能会说好 我

841
00:45:15,120 --> 00:45:19,110
希望Flappy从左到右 从右到下 从下到左 

842
00:45:19,110 --> 00:45:21,510
从下到上 

843
00:45:21,510 --> 00:45:24,870
也许他们会说如果Flappy不到--

844
00:45:24,870 --> 00:45:31,680
或者已经到达第一个点 向左移动 否则如果他已经到达底部或第二个点 

845
00:45:31,680 --> 00:45:34,500
向下移动 然后向左移动 向上移动 

846
00:45:34,500 --> 00:45:41,970
在这两种情况下 它们都改变了Flappy的x和y值 

847
00:45:41,970 --> 00:45:45,870
这基本上只是一大堆假设和状态变量 

848
00:45:48,410 --> 00:45:50,460
我在大量的代码中看到了这一点 

849
00:45:50,460 --> 00:45:54,090
只是声明到处都是 

850
00:45:54,090 --> 00:45:58,750
我们将看到的第一个实现使用的是类似的东西 

851
00:45:58,750 --> 00:46:05,250
所以在chain0中 这里只有两个例子 实际上 关于chain 

852
00:46:05,250 --> 00:46:13,500
但是链0 有一个移动时间 然后是一个计时器 

853
00:46:13,500 --> 00:46:15,420
我们会对此半清白的 

854
00:46:15,420 --> 00:46:16,830
我们有一些目的地 

855
00:46:16,830 --> 00:46:18,600
好的 我们有目的地了 

856
00:46:18,600 --> 00:46:25,020
我知道我不一定想跟踪一堆if语句 

857
00:46:25,020 --> 00:46:26,940
但我要去...

858
00:46:26,940 --> 00:46:30,930
假设我不知道定时器能为我们做什么 

859
00:46:30,930 --> 00:46:34,380
在这里 我只是说好的 我想要这个第一个目的地

860
00:46:34,380 --> 00:46:38,310
等于虚拟宽度减去他的宽度 然后

861
00:46:38,310 --> 00:46:43,140
假设他从0 0开始 让他保持在屏幕的右边 

862
00:46:43,140 --> 00:46:46,650
然后我希望他的第二个目的地是x轴上的同一侧 

863
00:46:46,650 --> 00:46:49,660
但我希望y等于他的身高减去他的身高 

864
00:46:49,660 --> 00:46:51,390
因此 请转到屏幕底部 

865
00:46:51,390 --> 00:46:54,740
然后我希望从屏幕底部算起他的身高是0 

866
00:46:54,740 --> 00:46:56,550
然后回到0 0 

867
00:46:56,550 --> 00:47:01,740
我们制作了这些模型 然后我想在每个模型中都保留一面旗帜 

868
00:47:01,740 --> 00:47:04,060
我想知道他是不是已经到那个地步了 

869
00:47:04,060 --> 00:47:07,080
所以我将遍历我刚刚创建的表 

870
00:47:07,080 --> 00:47:10,149
只需为每个名为REACHED的密钥添加一个新的密钥 

871
00:47:10,149 --> 00:47:11,190
并将其设置为False 

872
00:47:11,190 --> 00:47:14,670
只是默认的情况下 他还没有联系到所有的人 

873
00:47:14,670 --> 00:47:17,520
然后在更新中 基本上 我会

874
00:47:17,520 --> 00:47:20,730
将计时器设置为移动时间的最小值 

875
00:47:20,730 --> 00:47:26,760
所以它永远不会超过移动时间 然后是计时器加上增量时间 

876
00:47:26,760 --> 00:47:32,260
然后对于目的地中的每个目的地 如果没有到达 

877
00:47:32,260 --> 00:47:36,280
然后设置它的x和y、FlappyX和FlappyY 在本例中是

878
00:47:36,280 --> 00:47:40,170
我们不干净地使用全局变量来跟踪这一点 

879
00:47:40,170 --> 00:47:43,140
FlappyX和FlappyY得到Basex 

880
00:47:43,140 --> 00:47:44,340
因此 请注意另一个问题 

881
00:47:44,340 --> 00:47:49,890
我们必须保持我们相对于下一个位置的位置

882
00:47:49,890 --> 00:47:57,420
因为之前我们只用Flappy Birds--

883
00:47:57,420 --> 00:47:59,670
基本上 计时器除以移动时间

884
00:47:59,670 --> 00:48:02,610
是我们衡量最终目的地的比率 

885
00:48:02,610 --> 00:48:06,240
并将其分配给Flappy 它的效果是

886
00:48:06,240 --> 00:48:07,470
Flappy从左到右 

887
00:48:07,470 --> 00:48:10,540
但如果我们用相反的方式 从右到左 

888
00:48:10,540 --> 00:48:14,250
算术不一样 因为他在走回头路 

889
00:48:14,250 --> 00:48:19,650
他的x值被加上了负值 

890
00:48:19,650 --> 00:48:22,560
所以我们需要追踪他从哪个基地开始

891
00:48:22,560 --> 00:48:25,620
在这些行动中 Basex Basey 

892
00:48:25,620 --> 00:48:28,629
所以一开始 Basex Basey是0 0 

893
00:48:28,629 --> 00:48:30,420
所以它实际上会大同小异 

894
00:48:30,420 --> 00:48:32,836
但Flappy一到屏幕的右边 

895
00:48:32,836 --> 00:48:36,300
我们希望Basex是屏幕的右边缘 Basey仍然是0 

896
00:48:36,300 --> 00:48:40,230
如果他倒下了 我们希望贝西成为屏幕的底部边缘 

897
00:48:40,230 --> 00:48:42,820
Basex为右边缘 依此类推 

898
00:48:42,820 --> 00:48:45,390
所以我们要做的就是扩大规模 

899
00:48:45,390 --> 00:48:50,070
我们仍然使用超过移动时间的定时器作为我们的比例因子 

900
00:48:50,070 --> 00:48:54,930
但我们加上了目的地和基地的差异 

901
00:48:54,930 --> 00:48:58,990
我们要乘以那个比例因子 

902
00:48:58,990 --> 00:49:01,740
所以这个差异 如果我们加上它 无论我们是

903
00:49:01,740 --> 00:49:05,190
向左或向右 或向下 或向上 它是

904
00:49:05,190 --> 00:49:09,060
将起到填补桥梁缺口的作用 无论

905
00:49:09,060 --> 00:49:11,840
我们在哪里 无论我们想去哪个方向 

906
00:49:11,840 --> 00:49:18,600
所以这基本上是一个相当完整的线性插值法

907
00:49:18,600 --> 00:49:21,630
算法 这是补间的基础 

908
00:49:21,630 --> 00:49:26,010
只需在另一个值之间插入一些值 

909
00:49:26,010 --> 00:49:29,085
在几何图形中 它通常被建模为两个线段之间的线 

910
00:49:32,070 --> 00:49:35,510
如果计时器获得移动时间 我们就

911
00:49:35,510 --> 00:49:40,500
到达目的地 重置计时器 重置或Basex和Y 

912
00:49:40,500 --> 00:49:43,980
这样做的效果就像我们之前看到的那样 那就是

913
00:49:43,980 --> 00:49:47,290
把他一点一点地放进去 

914
00:49:47,290 --> 00:49:50,910
所以 有没有关于这种插补的问题--如何

915
00:49:50,910 --> 00:49:53,100
这种建模问题的方法有效吗？

916
00:49:57,230 --> 00:50:06,360
好的 多亏了计时器 还有一种更好的方法 结束 

917
00:50:06,360 --> 00:50:11,250
您可以将其应用于任何计时器操作 包括timer.tweet 

918
00:50:11,250 --> 00:50:17,730
所以我们基本上可以说OK 一旦操作完成 就做点什么 

919
00:50:17,730 --> 00:50:21,014
这就是我们要做的 我们只需要说定时器 

920
00:50:21,014 --> 00:50:22,680
我们不再需要插补 

921
00:50:22,680 --> 00:50:24,780
这是由定时器为我们处理的 

922
00:50:24,780 --> 00:50:29,970
所以我们在做定时器 在移动的时间里 

923
00:50:29,970 --> 00:50:34,680
Flappy 将其设置为--这是在我们将所有这些添加到目的地表之前

924
00:50:34,680 --> 00:50:36,490
还带着伸展的旗帜 

925
00:50:36,490 --> 00:50:40,710
现在 我们这里只有x和y 

926
00:50:40,710 --> 00:50:45,030
所以在第一个动作中 我们希望他的x在屏幕的右边 

927
00:50:45,030 --> 00:50:46,890
就像以前一样--你得零分 

928
00:50:46,890 --> 00:50:52,710
完成后 使用另一个定时器的匿名函数 tweet 

929
00:50:52,710 --> 00:50:54,520
所以我们说好的 一旦你做完了 

930
00:50:54,520 --> 00:50:59,100
然后将他从右上边缘补间到右下边缘 

931
00:50:59,100 --> 00:51:03,000
因此y得到的是VALUAL_HEIGH减去FlappySprite的getHeight 

932
00:51:03,000 --> 00:51:06,470
一旦完成 另一个匿名函数 

933
00:51:06,470 --> 00:51:09,750
另一个计时器 另一个结束 另一个匿名函数 

934
00:51:09,750 --> 00:51:10,920
另一个定时器 

935
00:51:10,920 --> 00:51:14,010
而且 这以其自身的方式是不可扩展的 

936
00:51:14,010 --> 00:51:15,480
它是嵌套的 

937
00:51:15,480 --> 00:51:17,400
有一个术语叫做召回地狱

938
00:51:17,400 --> 00:51:22,440
因为你只会得到无限向下倾斜的匿名函数

939
00:51:22,440 --> 00:51:23,820
这种行为 

940
00:51:23,820 --> 00:51:27,740
有一些方法可以让它变得平坦 我们可能会讨论它 

941
00:51:27,740 --> 00:51:29,500
这是刀的一部分链条 

942
00:51:29,500 --> 00:51:32,355
Knife.Chain有一种方法来改变所有这些--

943
00:51:32,355 --> 00:51:34,230
基本上 它会看起来像这样 

944
00:51:34,230 --> 00:51:38,940
它将是链状的 然后它将像moveFlappy x y 

945
00:51:38,940 --> 00:51:43,230
MoveFlappy x2--不会是x2 y2 

946
00:51:43,230 --> 00:51:49,340
我们实际上会把这些写在这里 但它会产生完全相同的效果 

947
00:51:49,340 --> 00:51:55,800
这是如果您想要实现一个场景切换系统 或者只是

948
00:51:55,800 --> 00:51:57,960
为你的游戏设计某种脚本系统

949
00:51:57,960 --> 00:52:03,840
这是非常陈述性的 在风格上也是强制性的 

950
00:52:03,840 --> 00:52:10,710
这是改变行为并使其发挥作用的圣杯 

951
00:52:10,710 --> 00:52:12,790
只是让它看起来很漂亮 而且是可读性的 

952
00:52:12,790 --> 00:52:13,290
嗯?

953
00:52:13,290 --> 00:52:16,713
观众：好的 你也可以进来--

954
00:52:16,713 --> 00:52:21,603
您可以将一个表传递给x和y的函数[INAUDIBLE]

955
00:52:21,603 --> 00:52:25,040
对[INAUDIBLE]来说 链接很多东西更简单 

956
00:52:25,040 --> 00:52:27,190
演讲者1：是的 你也可以这么做 

957
00:52:27,190 --> 00:52:30,980
回答是 你可以把一个表传递给--

958
00:52:30,980 --> 00:52:33,350
您可以遍历一个表 在该表中 

959
00:52:33,350 --> 00:52:36,110
生成定时器 补间 

960
00:52:36,110 --> 00:52:45,380
唯一的问题是Finish 有一种方法--

961
00:52:45,380 --> 00:52:49,130
我想你可以拿回计时器的参考资料 

962
00:52:49,130 --> 00:52:55,770
然后给它加一个完工块 但这样你就会失去--

963
00:52:55,770 --> 00:53:03,200
如果您所做的所有操作都适用于相同的功能

964
00:53:03,200 --> 00:53:07,200
把东西搬到很多地方 这绝对是真的 

965
00:53:07,200 --> 00:53:19,130
但如果我们想让Flappy说点什么 英雄就会消失 然后

966
00:53:19,130 --> 00:53:23,102
英雄闪电侠 做这样的事情会变得有点棘手 

967
00:53:23,102 --> 00:53:23,810
但是 是的 我同意 

968
00:53:23,810 --> 00:53:28,190
建模有多种方法--这个特定的例子有点

969
00:53:28,190 --> 00:53:31,160
重复 而且我认为可以更好地模仿

970
00:53:31,160 --> 00:53:34,550
具有一个功能 该功能利用

971
00:53:34,550 --> 00:53:39,847
可以返回计时器 然后给出新的Finish变量 

972
00:53:39,847 --> 00:53:42,430
我得试一试才能明白 因为我实际上不是

973
00:53:42,430 --> 00:53:46,620
100%确定您可以添加饰面 

974
00:53:46,620 --> 00:53:47,870
不 我想你可以的 事实上 

975
00:53:47,870 --> 00:53:50,591
我认为您可以向引用添加Finish函数

976
00:53:50,591 --> 00:53:52,340
因为它只是一个对象上的函数 

977
00:53:52,340 --> 00:53:58,670
所以 是的 但除此之外 我认为目标可能是

978
00:53:58,670 --> 00:54:04,640
一个是 知道我们现在可以如何链接行为 然后是第二个 

979
00:54:04,640 --> 00:54:06,680
努力将其夷为平地 

980
00:54:06,680 --> 00:54:10,880
但为了这个习题集的目的 我们会看几次 

981
00:54:10,880 --> 00:54:14,780
这只是比以前更好的世界 

982
00:54:14,780 --> 00:54:16,310
这是什么 76行吗？

983
00:54:16,310 --> 00:54:22,490
然后tween1或chain0等于96 

984
00:54:22,490 --> 00:54:25,490
好的 所以有20行代码 

985
00:54:25,490 --> 00:54:29,032
还有一个事实是 现在我们有了一个用于建模的声明性接口

986
00:54:29,032 --> 00:54:31,490
异步行为 这确实是最基本的事情 

987
00:54:31,490 --> 00:54:37,460
不是有某种价值来模拟你的持续时间或你的计数器 

988
00:54:37,460 --> 00:54:40,984
或任何价值 但只是说 嘿 在这段时间里 

989
00:54:40,984 --> 00:54:41,900
我要你做这件事 

990
00:54:41,900 --> 00:54:42,660
我要你做这件事 

991
00:54:42,660 --> 00:54:43,350
我想做这个 

992
00:54:43,350 --> 00:54:43,880
我要你做这件事 

993
00:54:43,880 --> 00:54:45,921
过了这么长时间 我要你做这件事 

994
00:54:49,910 --> 00:54:53,309
我总是喜欢尝试并努力使代码尽可能具有声明性 

995
00:54:53,309 --> 00:54:55,100
只是为了让你将来能读到它 

996
00:54:55,100 --> 00:54:58,130
然后为您的代码库工作的人员

997
00:54:58,130 --> 00:55:01,040
我以后也能读得很好 我

998
00:55:01,040 --> 00:55:03,114
我认为Timer在这方面做得相当出色 

999
00:55:03,114 --> 00:55:05,030
这只是定时器结束的参考 

1000
00:55:05,030 --> 00:55:08,510
所以它只需要一个回调 然后一旦计时器函数

1001
00:55:08,510 --> 00:55:13,760
补间间隔或在完成之后 它会触发该回调 

1002
00:55:13,760 --> 00:55:17,340
所以我们现在休息五分钟 然后等我们回来 

1003
00:55:17,340 --> 00:55:21,740
我们将讨论交换 以及我们在比赛3中使用的一些算法 

1004
00:55:21,740 --> 00:55:25,490
从渲染一块木板开始 让瓷砖交换 对它们进行补间 

1005
00:55:25,490 --> 00:55:29,150
然后我们将看看我们是如何处理掉下来的瓷砖的

1006
00:55:29,150 --> 00:55:31,210
并对它们进行解释 然后重新填充它们 

1007
00:55:36,080 --> 00:55:37,430
好了 我们回来了 

1008
00:55:37,430 --> 00:55:41,930
回想一下 在休息之前 我们看着计时器 

1009
00:55:41,930 --> 00:55:47,090
以及如何获取以前由计时器管理的、异步的代码 

1010
00:55:47,090 --> 00:55:50,720
但也非常有状态 有点凌乱 到处都是 

1011
00:55:50,720 --> 00:55:53,160
把它变成一种更具说明性的、干净的、

1012
00:55:53,160 --> 00:55:59,290
易于通过timer.tweet、timer.each、timer.After、timer.Finish、

1013
00:55:59,290 --> 00:56:02,360
Timer；任何Timer对象都结束 

1014
00:56:02,360 --> 00:56:04,370
所有这些都解决了 现在我们要

1015
00:56:04,370 --> 00:56:07,010
开始谈论第三场比赛的实际机制吧 

1016
00:56:07,010 --> 00:56:11,000
我们首先要看的是swap0 

1017
00:56:11,000 --> 00:56:15,110
这是包括在发行版中的《第三场比赛》的精灵版 

1018
00:56:15,110 --> 00:56:20,930
正如我们所看到的 这是我们可以很容易地用生成四元组来切割的东西 

1019
00:56:20,930 --> 00:56:21,710
正如我们之前看到的 

1020
00:56:21,710 --> 00:56:24,080
只是util.lua中提供的一个函数 

1021
00:56:24,080 --> 00:56:25,647
这些都是32x32像素 

1022
00:56:25,647 --> 00:56:27,980
因此 只需浏览所有这些内容就很容易了 

1023
00:56:27,980 --> 00:56:32,450
基本上只用精灵薄板32、32生成四边形 

1024
00:56:32,450 --> 00:56:36,310
然后找一张桌子 里面有所有这些单独的东西 

1025
00:56:36,310 --> 00:56:41,960
但请注意 它们被遮挡成各种颜色的图案 

1026
00:56:41,960 --> 00:56:44,870
这对我们的游戏有实际的意义和价值

1027
00:56:44,870 --> 00:56:47,990
因为当一些东西是相同的颜色时 

1028
00:56:47,990 --> 00:56:51,800
只有当东西是相同的颜色时 瓷砖才是相同的颜色 

1029
00:56:51,800 --> 00:56:54,110
我们可以用它来触发匹配吗 

1030
00:56:54,110 --> 00:56:56,120
如果我们有三四个--

1031
00:56:56,120 --> 00:56:59,450
在垂直方向上 在一条线上超过三个的任何东西

1032
00:56:59,450 --> 00:57:04,070
或者横向来看 这是一场比赛 我们需要把它从桌子上移走 

1033
00:57:04,070 --> 00:57:07,580
所以我们需要某种方式来识别这些瓷砖是

1034
00:57:07,580 --> 00:57:11,990
一些颜色 然后它们也碰巧有不同的图案 

1035
00:57:11,990 --> 00:57:15,470
这个什么都没有 然后是一个x 然后是一个圆 还有一个正方形 

1036
00:57:15,470 --> 00:57:18,316
所以那些模式--它没有在发行版中实现 

1037
00:57:18,316 --> 00:57:19,440
但这是任务的一部分 

1038
00:57:19,440 --> 00:57:22,070
这实际上会让它们变得相关 

1039
00:57:22,070 --> 00:57:27,650
但实现的部分是颜色的实际匹配 

1040
00:57:27,650 --> 00:57:31,220
所以我们需要做的第一件事 可能是 当我们真正

1041
00:57:31,220 --> 00:57:34,730
深入了解发行版的核心代码

1042
00:57:34,730 --> 00:57:40,010
不是简单地把它们放在一个表格里 把它们分类 

1043
00:57:40,010 --> 00:57:44,105
把它分成一 二 三 四 五 六 七 八 

1044
00:57:44,105 --> 00:57:45,590
九乘以二--

1045
00:57:45,590 --> 00:57:50,810
18张桌子 这样我们就可以在颜色上说框架了 

1046
00:57:50,810 --> 00:57:54,440
所以颜色是1到18 然后把指数放进去 

1047
00:57:54,440 --> 00:57:56,310
所以每一个里面都有六个 

1048
00:57:56,310 --> 00:57:57,620
所以会是一比六 

1049
00:57:57,620 --> 00:58:01,577
1至6个为品种 1个为基础品种 

1050
00:58:01,577 --> 00:58:03,410
任务的一部分就是确保

1051
00:58:03,410 --> 00:58:08,600
基础品种是我们从第一级开始的唯一品种 

1052
00:58:08,600 --> 00:58:11,450
但随后逐渐引入这些其他品种 

1053
00:58:11,450 --> 00:58:14,330
你可以把它们放在任何层次结构中

1054
00:58:14,330 --> 00:58:17,450
你想要 但要让它们有某种价值

1055
00:58:17,450 --> 00:58:20,812
稍后 作业还将涵盖其他几个方面 

1056
00:58:20,812 --> 00:58:22,520
但简而言之 这就是电子表格 

1057
00:58:22,520 --> 00:58:23,978
我们会以这种方式平分它 

1058
00:58:23,978 --> 00:58:29,180
所以18张桌子是四份 而不是一张

1059
00:58:29,180 --> 00:58:31,280
这个数字是--8乘16 

1060
00:58:31,280 --> 00:58:33,970
不知道有多少是我脑海中浮现的 

1061
00:58:33,970 --> 00:58:38,790
但让我们来看看发行版中的swap0

1062
00:58:38,790 --> 00:58:41,840
这样我们就能知道我们需要做什么

1063
00:58:41,840 --> 00:58:46,800
开始实施我们的第三场比赛 

1064
00:58:46,800 --> 00:58:49,460
请注意 我们已经为GenerateQuad要求了util 

1065
00:58:49,460 --> 00:58:51,650
我们只需要为这个基本的例子生成 

1066
00:58:51,650 --> 00:58:54,816
我们不会区分颜色、品种或任何东西 

1067
00:58:54,816 --> 00:58:58,127
我们只是要把它们都放进一个四元组 或者一张四元组的桌子 

1068
00:58:58,127 --> 00:59:00,710
因此 我们将只使用常规的GenerateQuads函数 

1069
00:59:00,710 --> 00:59:03,070
我们不会区分它们 

1070
00:59:03,070 --> 00:59:05,400
我们将在这里使用我们的精灵 我们的match3.png

1071
00:59:05,400 --> 00:59:08,150
在发行版中提供 这与我们刚才的图像完全相同

1072
00:59:08,150 --> 00:59:09,470
在屏幕上看到的 

1073
00:59:09,470 --> 00:59:11,290
我将只生成它们 

1074
00:59:11,290 --> 00:59:12,384
他们是32乘32英寸--

1075
00:59:12,384 --> 00:59:13,550
为它们生成四元组 

1076
00:59:13,550 --> 00:59:15,320
它们是32x32像素的 

1077
00:59:15,320 --> 00:59:19,310
我将它分配给这里一个名为TileQuads的表 

1078
00:59:19,310 --> 00:59:21,830
然后在这里 我们调用GenerateBoard 

1079
00:59:21,830 --> 00:59:25,700
因此 GenerateBoard与我们之前看到的并没有太大的不同

1080
00:59:25,700 --> 00:59:30,830
可能是《越狱》中的关卡制造者 我们只是在那里生产了一堆砖 

1081
00:59:30,830 --> 00:59:33,440
或者一堆瓷砖 在这种情况下 

1082
00:59:33,440 --> 00:59:37,220
但在这种情况下 它们被保存在一个很好的2D数组中

1083
00:59:37,220 --> 00:59:39,860
总是会是8乘8 这永远不会

1084
00:59:39,860 --> 00:59:43,437
仅仅因为这个游戏的其中一个限制而改变 

1085
00:59:43,437 --> 00:59:45,770
传统上 第三场比赛是一个8乘8的网格

1086
00:59:45,770 --> 00:59:48,540
总是满是各种各样的瓷砖 

1087
00:59:48,540 --> 00:59:51,680
所以当地的瓷砖 它将是一张空桌子 

1088
00:59:51,680 --> 00:59:53,980
然后我们将在这里做一个嵌套的for循环--

1089
00:59:53,980 --> 00:59:54,980
从y到x 

1090
00:59:54,980 --> 00:59:58,520
标准通常是先是y 然后是x 

1091
00:59:58,520 --> 01:00:05,480
然后我们在x之前对y进行索引 因为2D中的各个行

1092
01:00:05,480 --> 01:00:13,370
数组、子画面或表将是这样的 例如 如果我们的表

1093
01:00:13,370 --> 01:00:15,020
等于这个--哦 对不起 

1094
01:00:15,020 --> 01:00:18,560
语法错误 

1095
01:00:18,560 --> 01:00:25,040
如果我们这样做 然后我们有一张桌子 一张桌子

1096
01:00:25,040 --> 01:00:35,070
这里 我们有0 1 1 1 1 1 1 1 1 然后是1 1 1 1 

1097
01:00:35,070 --> 01:00:37,210
如果我们索引这张表--

1098
01:00:37,210 --> 01:00:43,410
所以桌子在0 这会给我们带来另一张桌子 

1099
01:00:43,410 --> 01:00:45,060
这不会给我们带来--

1100
01:00:45,060 --> 01:00:56,040
假设我们想要得到表2 3中的值 

1101
01:00:56,040 --> 01:01:00,990
我的直觉可能是认为我将在x y处建立索引

1102
01:01:00,990 --> 01:01:04,350
只是因为x y往往更常见 

1103
01:01:04,350 --> 01:01:08,100
但如果我们这样做 并假设x是水平的 

1104
01:01:08,100 --> 01:01:13,080
而y在这个排列中是垂直的 这就是我们的方式 

1105
01:01:13,080 --> 01:01:20,350
那么表2就不是这个值了 表2就是这个表了 

1106
01:01:20,350 --> 01:01:26,700
当某个表是嵌套表时 您传递到索引该表的第一个值

1107
01:01:26,700 --> 01:01:29,100
实际上 就是表本身 它

1108
01:01:29,100 --> 01:01:33,300
这就是为什么我们实际上需要做的--当我们想要获得一些价值时 

1109
01:01:33,300 --> 01:01:35,850
我们必须在表y x处建立索引 

1110
01:01:35,850 --> 01:01:40,395
因此它被翻转了 因为x实际上将是--

1111
01:01:40,395 --> 01:01:46,680
第一个索引将是这些子表 

1112
01:01:46,680 --> 01:01:51,309
或者子数组 如果你用的是C 或者Java 或者类似的语言 

1113
01:01:51,309 --> 01:01:54,225
所以当你看到表y x时 你会奇怪为什么它不是表x 

1114
01:01:54,225 --> 01:01:56,790
Y 这就是原因 

1115
01:01:56,790 --> 01:02:01,700
那么 对于为什么会这样 或者这是如何运作的 有什么问题吗？

1116
01:02:01,700 --> 01:02:05,810
观众：[听不见]

1117
01:02:05,810 --> 01:02:10,400
演讲者1：在这种情况下 我使用了从零开始的索引 

1118
01:02:10,400 --> 01:02:11,802
但Lua是一个指数 

1119
01:02:11,802 --> 01:02:12,635
那只是习惯而已 

1120
01:02:15,434 --> 01:02:18,350
有人指出 我在我的示例中使用了从零开始的索引 

1121
01:02:18,350 --> 01:02:22,940
当您实际编程时 您希望使用一个基于索引的索引 

1122
01:02:22,940 --> 01:02:25,550
而不是从零开始 

1123
01:02:25,550 --> 01:02:27,350
但同样的原则也适用于此 

1124
01:02:27,350 --> 01:02:31,310
在这种情况下 零将是一 

1125
01:02:31,310 --> 01:02:34,490
用一种通用语言--

1126
01:02:34,490 --> 01:02:42,500
大多数语言 如果我们将问题抽象为C2D数组 

1127
01:02:42,500 --> 01:02:45,250
或者C++ 或者Java 零在那里是合适的 

1128
01:02:45,250 --> 01:02:49,370
但无论如何 我们有一个嵌套的for循环 

1129
01:02:49,370 --> 01:02:51,870
我们从y开始 然后我们再到x 

1130
01:02:51,870 --> 01:02:55,270
然后基本上 这就是y的效果 

1131
01:02:55,270 --> 01:02:59,150
然后是x y x x 

1132
01:02:59,150 --> 01:03:00,380
只需插入一个空白表格 

1133
01:03:00,380 --> 01:03:05,300
把它填满--我们只是在用桌子 

1134
01:03:05,300 --> 01:03:07,850
所以我们没有使用任何类型的瓷砖类 

1135
01:03:07,850 --> 01:03:10,190
或者上冲浪板课 或者任何花哨的东西 

1136
01:03:10,190 --> 01:03:11,990
我们在这里只使用原始数据类型 

1137
01:03:11,990 --> 01:03:16,760
所以我们只是说插入到瓷砖y中 这

1138
01:03:16,760 --> 01:03:22,670
顺便说一句 如果我们在这里x等于1 8 

1139
01:03:22,670 --> 01:03:27,170
我们处于外部y循环的任意给定迭代中 

1140
01:03:27,170 --> 01:03:30,640
瓷砖y将是我们刚刚插入的最后一张表--

1141
01:03:30,640 --> 01:03:35,630
此x循环的第一次迭代上的最后一个空白表 

1142
01:03:35,630 --> 01:03:39,710
所以基本上 它是说 在内表中 我只是

1143
01:03:39,710 --> 01:03:47,810
放进代表我们的棋盘的桌子里 瓷砖桌子 

1144
01:03:47,810 --> 01:03:51,650
插入新表格 

1145
01:03:51,650 --> 01:03:55,820
所以我们有一张桌子 一张桌子 一张桌子 

1146
01:03:55,820 --> 01:03:59,150
第三个表中是实际的瓷砖本身 

1147
01:03:59,150 --> 01:04:02,480
您可以认为这个表或多或少是一种平铺数据类型 

1148
01:04:02,480 --> 01:04:04,430
只是使用表实现的 

1149
01:04:04,430 --> 01:04:07,610
它有一个x坐标 一个y坐标 然后是一个瓷砖 

1150
01:04:07,610 --> 01:04:11,000
瓷砖将是一个随机数字 

1151
01:04:11,000 --> 01:04:13,280
将成为我们四人组的索引 

1152
01:04:13,280 --> 01:04:17,030
所以每个瓷砖都有x和y 然后请注意

1153
01:04:17,030 --> 01:04:18,950
我们乘以32是因为我们

1154
01:04:18,950 --> 01:04:23,780
我要用这个来画瓷砖 瓷砖是32像素高的--

1155
01:04:23,780 --> 01:04:26,340
抱歉 太高了 

1156
01:04:26,340 --> 01:04:29,300
我们要乘以x减1 回想一下 

1157
01:04:29,300 --> 01:04:35,510
因为即使表是一个索引的 坐标也是零索引的 

1158
01:04:35,510 --> 01:04:39,320
所以x乘以32 y乘以32 

1159
01:04:39,320 --> 01:04:44,600
然后得到一个介于1和四元组数量之间的随机数

1160
01:04:44,600 --> 01:04:46,040
在我们的四边形瓷砖桌子上 

1161
01:04:46,040 --> 01:04:51,264
回想一下 这里的数字符号只是桌子长度的速记 

1162
01:04:51,264 --> 01:04:52,680
然后我们会把它还回去 

1163
01:04:52,680 --> 01:04:54,290
因此 我们产生了我们的董事会 

1164
01:04:54,290 --> 01:05:01,660
它是一个y x x网格 由小桌子组成的表格行

1165
01:05:01,660 --> 01:05:05,450
都具有x、y和切片ID 并且切片ID映射到四元组

1166
01:05:05,450 --> 01:05:09,350
我们刚刚生成的 

1167
01:05:09,350 --> 01:05:11,630
好了 init函数就是这样了 

1168
01:05:11,630 --> 01:05:14,450
在本例中 对不起是love.Load 

1169
01:05:14,450 --> 01:05:20,620
Drave使用一个名为DrawBoard的函数 我们传入128乘以16 

1170
01:05:20,620 --> 01:05:23,330
128乘以16只是xy偏移量 

1171
01:05:23,330 --> 01:05:25,640
我们要在128 16点抽签 

1172
01:05:25,640 --> 01:05:28,460
它会成为我们董事会的中心吗 

1173
01:05:28,460 --> 01:05:31,190
如果我们往下走到第89行的DrawBoard 

1174
01:05:31,190 --> 01:05:34,130
获取再次嵌套的for循环的offsetX、offsetY 

1175
01:05:34,130 --> 01:05:37,520
我们只是在重复我们得到的瓷砖 

1176
01:05:37,520 --> 01:05:40,820
回想一下 实际上 GenerateBoard返回的是瓷砖 

1177
01:05:40,820 --> 01:05:45,350
然后我们将Board设置为等于GenerateBoard的结果 

1178
01:05:45,350 --> 01:05:50,210
所以在这里的第89行 也是在DrawBoard中--实际上在第95行 

1179
01:05:50,210 --> 01:05:56,255
在这个嵌套的for循环中 我们将在板y x 

1180
01:05:56,255 --> 01:05:58,130
只是为了让我们有一个速记参考 

1181
01:05:58,130 --> 01:06:01,760
我们不需要多次说黑板y x 这是你必须听到的 

1182
01:06:01,760 --> 01:06:04,040
我们要画出精灵--

1183
01:06:04,040 --> 01:06:07,319
瓦片 回想一下 

1184
01:06:07,319 --> 01:06:09,110
是一个介于1和任何值之间的随机数

1185
01:06:09,110 --> 01:06:13,170
我们的瓷砖四元组表格中有四元组的数量 

1186
01:06:13,170 --> 01:06:16,940
然后x加上偏移量X y加上偏移量Y 这

1187
01:06:16,940 --> 01:06:22,040
可以在给定的偏移量上绘制网格中的每一块瓷砖 

1188
01:06:22,040 --> 01:06:23,180
这就产生了结果--

1189
01:06:23,180 --> 01:06:26,600
实际上 我可能应该提前运行这段视频 

1190
01:06:26,600 --> 01:06:28,950
这样我就可以举例说明了 

1191
01:06:31,800 --> 01:06:34,340
但我们有一块简单的冲浪板 

1192
01:06:34,340 --> 01:06:35,080
看起来不错 

1193
01:06:35,080 --> 01:06:37,580
它是五颜六色的 但它非常 非常基本 

1194
01:06:37,580 --> 01:06:39,697
只是我们游戏的2D渲染 

1195
01:06:39,697 --> 01:06:41,030
没有任何行为或任何东西 

1196
01:06:41,030 --> 01:06:43,070
这只是我们画棋盘的方式 

1197
01:06:43,070 --> 01:06:46,510
所以 有没有什么问题 比如图纸和黑板的制作

1198
01:06:46,510 --> 01:06:47,010
工作?

1199
01:06:50,340 --> 01:06:51,890
好的 

1200
01:06:51,890 --> 01:06:56,010
因此 swap1稍微复杂一些 

1201
01:06:56,010 --> 01:06:58,820
它建立在我们以前所做的基础上 我们只是

1202
01:06:58,820 --> 01:07:02,569
建立 这是实现董事会 并绘制到屏幕上 

1203
01:07:02,569 --> 01:07:03,860
但它们根本没有任何行为 

1204
01:07:03,860 --> 01:07:05,870
这只是一个静电--基本上是一样的东西

1205
01:07:05,870 --> 01:07:07,640
将图像绘制到屏幕上 

1206
01:07:07,640 --> 01:07:13,070
因此 我们想要做的是实现交换 

1207
01:07:13,070 --> 01:07:17,810
那么 我们认为如何才能做到这一点呢？

1208
01:07:17,810 --> 01:07:20,660
有没有人有办法让我们互换？

1209
01:07:23,618 --> 01:07:27,570
观众：(听不见)用补丁让它朝相反的方向移动 

1210
01:07:27,570 --> 01:07:30,060
演讲者1：嗯 我们可以 

1211
01:07:30,060 --> 01:07:32,970
这将会产生--

1212
01:07:32,970 --> 01:07:34,890
得到的回应是我们可以使用推特 

1213
01:07:34,890 --> 01:07:38,790
我们可以 实际上我们也会这样做 

1214
01:07:38,790 --> 01:07:41,400
但事情会比这更复杂一点

1215
01:07:41,400 --> 01:07:44,447
因为它们是在2D阵列中 

1216
01:07:44,447 --> 01:07:45,780
所以如果我们只是在他们的x之间 你--

1217
01:07:45,780 --> 01:07:50,140
观众：[听不见]

1218
01:07:50,140 --> 01:07:53,670
演讲者1：它们将在阵列中的相同位置 

1219
01:07:53,670 --> 01:07:54,462
但是 是的 终极--

1220
01:07:54,462 --> 01:07:56,670
观众：你可以在阵列中交换位置 

1221
01:07:56,670 --> 01:07:57,870
然后重新加载阵列 

1222
01:07:57,870 --> 01:08:00,330
扬声器1：交换它们在阵列中的位置 然后重新加载阵列 

1223
01:08:00,330 --> 01:08:01,496
我们将调换位置 

1224
01:08:01,496 --> 01:08:04,679
我们不需要重新加载阵列 但我们会改变它们的位置 

1225
01:08:04,679 --> 01:08:05,970
这是有效的 它是什么 

1226
01:08:05,970 --> 01:08:09,990
从字面上看 只需取两块瓷砖 并交换到CS50 

1227
01:08:09,990 --> 01:08:13,560
我们只需要取两个变量 然后得到一个临时变量

1228
01:08:13,560 --> 01:08:16,080
指向一个变量 获取它的值

1229
01:08:16,080 --> 01:08:22,689
而第二个变量获取该变量的值 反之亦然 

1230
01:08:22,689 --> 01:08:23,189
我认为 

1231
01:08:23,189 --> 01:08:27,479
这个得到这个的值 这个得到这个的值 

1232
01:08:27,479 --> 01:08:29,700
然后这个基本上归结到这个 

1233
01:08:29,700 --> 01:08:32,910
有一个中间人一直在--因为如果这个人得到这个人

1234
01:08:32,910 --> 01:08:35,966
值 它将被这个值覆盖 

1235
01:08:35,966 --> 01:08:38,340
所以不会有关于它的x y 或任何东西的引用 

1236
01:08:38,340 --> 01:08:42,180
这就是为什么你需要把这个放在这里 这样这个就可以放在这里 

1237
01:08:42,180 --> 01:08:43,750
然后再回到这里来 

1238
01:08:43,750 --> 01:08:45,630
因此 我们已经进行了有效的互换 

1239
01:08:45,630 --> 01:08:47,910
正如我们之前看到的 在Lua有办法进行掉期交易 

1240
01:08:47,910 --> 01:08:49,659
甚至不需要临时变量 

1241
01:08:49,659 --> 01:08:54,130
你可以做一些其他的XY 这样可以绕过这一点 

1242
01:08:54,130 --> 01:08:57,510
但当你开始一次做四件事被交换时 

1243
01:08:57,510 --> 01:09:01,830
而且你有四个逗号 它可能会变得有点棘手 有点笨拙 

1244
01:09:01,830 --> 01:09:04,779
事实上 我不能百分百确定你可以在Lua打开两个以上的东西 

1245
01:09:04,779 --> 01:09:09,060
我得再查一遍 但马上就要到了 

1246
01:09:09,060 --> 01:09:11,850
我们在第32行看到了双重任务 

1247
01:09:11,850 --> 01:09:15,069
高亮显示x 高亮显示y得到1 1 

1248
01:09:15,069 --> 01:09:17,069
让我实际运行 这样我们就可以看到了 

1249
01:09:17,069 --> 01:09:20,460
实际上 除了这些 这里还有几件 

1250
01:09:24,569 --> 01:09:25,930
交换1 

1251
01:09:25,930 --> 01:09:29,279
所以我们和以前一样有董事会 我们也有

1252
01:09:29,279 --> 01:09:32,069
一些东西可以告诉我们在哪里刷 因为我们有

1253
01:09:32,069 --> 01:09:34,380
知道我们在哪里交换瓷砖 

1254
01:09:34,380 --> 01:09:39,057
在作为分配的可选部分的理想实现中 

1255
01:09:39,057 --> 01:09:40,890
你的游戏会有鼠标行为 

1256
01:09:40,890 --> 01:09:43,899
因此 您只需单击两个磁贴 或者单击、拖动并交换它们 

1257
01:09:43,899 --> 01:09:45,357
在这种情况下 我们不会这么做 

1258
01:09:45,357 --> 01:09:47,430
我们只是实现了基于键的行为 

1259
01:09:47,430 --> 01:09:50,760
所以当我按向左、向右、向上或向下时 我可以移动 

1260
01:09:50,760 --> 01:09:55,950
如果我在磁贴上按Enter键 然后四处移动 这对我来说是一个指示器

1261
01:09:55,950 --> 01:09:58,290
我已经选择了那块瓷砖与其他东西互换

1262
01:09:58,290 --> 01:10:01,300
因为它需要跟踪OK 所以您想要交换此磁贴 

1263
01:10:01,300 --> 01:10:02,675
您想用什么来交换呢？

1264
01:10:02,675 --> 01:10:04,850
我想把它换成这块瓷砖 

1265
01:10:04,850 --> 01:10:06,210
所以他们被交换了 

1266
01:10:06,210 --> 01:10:08,910
我想把它换成这块瓷砖 

1267
01:10:08,910 --> 01:10:10,230
所以他们被交换了 

1268
01:10:10,230 --> 01:10:11,387
或者这块瓷砖 

1269
01:10:11,387 --> 01:10:13,470
所以你可以把它换成你想要的任何瓷砖 

1270
01:10:13,470 --> 01:10:16,020
没有任何限制 

1271
01:10:16,020 --> 01:10:21,150
实际的发行版代码实现了一个约束 因此 

1272
01:10:21,150 --> 01:10:24,342
你认为什么样的约束才能确保我们不能--

1273
01:10:24,342 --> 01:10:25,800
观众：它们必须是相邻的 

1274
01:10:25,800 --> 01:10:27,550
演讲者1：是的 它们必须是相邻的 

1275
01:10:27,550 --> 01:10:31,020
那么 这将需要什么呢？

1276
01:10:31,020 --> 01:10:34,450
观众：他们的x[INAUDIBLE]

1277
01:10:34,450 --> 01:10:35,950
演讲者1：完全正确 

1278
01:10:35,950 --> 01:10:41,880
简而言之 如果他们的x的绝对值

1279
01:10:41,880 --> 01:10:48,910
减去他们的y等于1 

1280
01:10:48,910 --> 01:10:52,320
因为如果你用一个人的x减去另一个人的x 

1281
01:10:52,320 --> 01:10:54,510
然后一个是y 另一个是y 然后

1282
01:10:54,510 --> 01:10:56,400
你把这些差异加在一起 那就是

1283
01:10:56,400 --> 01:10:58,860
告诉你它们是否直接相邻 

1284
01:10:58,860 --> 01:10:59,950
它必须等于1 

1285
01:10:59,950 --> 01:11:02,750
如果等于零 那么它们的x和y是相同的 

1286
01:11:02,750 --> 01:11:07,350
如果等于2 那么它在x轴上是两块瓷砖 

1287
01:11:07,350 --> 01:11:13,660
或者它在x和y上 在这种情况下 它与它是对角的 

1288
01:11:13,660 --> 01:11:16,780
所以唯一的方法是x减去x的 

1289
01:11:16,780 --> 01:11:21,210
Tile1.x减去tile2.x tile1.y减去tile2.y 

1290
01:11:21,210 --> 01:11:24,840
如果它们的绝对值之差为1 

1291
01:11:24,840 --> 01:11:26,100
那么它们是相邻的 

1292
01:11:26,100 --> 01:11:27,846
这是在实现中 

1293
01:11:33,120 --> 01:11:36,305
这就是为什么我们在这里有这些变量 突出显示的瓷砖 

1294
01:11:36,305 --> 01:11:39,180
基本上 我们是在设置一面旗帜 上面写着 我们有突出显示的磁贴吗？

1295
01:11:39,180 --> 01:11:45,090
如果我们这样做了 我们将在稍后的绘图中执行一些绘图逻辑

1296
01:11:45,090 --> 01:11:46,620
功能 

1297
01:11:46,620 --> 01:11:52,554
基本上 我们将如何绘制突出显示的瓷砖 你认为呢？

1298
01:11:52,554 --> 01:11:55,239
观众：添加一个透明的矩形 

1299
01:11:55,239 --> 01:11:56,030
演讲者1：完全正确 

1300
01:11:56,030 --> 01:11:58,260
所以答案是添加一个透明的矩形 

1301
01:11:58,260 --> 01:11:59,910
这正是我们要做的 

1302
01:11:59,910 --> 01:12:07,050
我将在这里深入到这部分 

1303
01:12:07,050 --> 01:12:10,900
所以在第173行 如果我们有一个突出显示的磁贴 

1304
01:12:10,900 --> 01:12:12,930
基本上 这是在一个循环的中间--

1305
01:12:12,930 --> 01:12:14,610
我们之前的y x 

1306
01:12:14,610 --> 01:12:16,160
我们已经把它放到了绘图板上 

1307
01:12:16,160 --> 01:12:19,980
我们有DrawBoard函数 但是x y 或者y x 

1308
01:12:19,980 --> 01:12:22,540
瓷砖将是我们目前所在的瓷砖 

1309
01:12:22,540 --> 01:12:27,200
如果我们有一个突出显示的瓷砖 而且那个瓷砖是GRIDX--

1310
01:12:27,200 --> 01:12:31,019
请注意 我们现在有一个名为gridX的新变量 而不是常规的x

1311
01:12:31,019 --> 01:12:34,310
这样我们就可以检查这些东西 看看它在数组中的什么位置 

1312
01:12:34,310 --> 01:12:39,500
如果GRIDX等于我们设置的高亮X 

1313
01:12:39,500 --> 01:12:45,400
GRIDY等于高亮Y 然后是love.graph ics.setColor

1314
01:12:45,400 --> 01:12:50,000
半透明 然后用这个4画一个矩形

1315
01:12:50,000 --> 01:12:53,920
在它的末尾 它实际上绘制了一个圆角矩形 

1316
01:12:53,920 --> 01:12:56,550
如果你传4号 它只画直的矩形 

1317
01:12:56,550 --> 01:12:58,970
但是如果在最后传入一个int 那么就是这个数字

1318
01:12:58,970 --> 01:13:01,597
圆角的线段基本上就是那个矩形 

1319
01:13:01,597 --> 01:13:03,680
所以你可以在你的矩形上得到圆角 

1320
01:13:03,680 --> 01:13:07,040
而且它对用户界面绘制和诸如此类的东西都很好 

1321
01:13:07,040 --> 01:13:10,910
我们在发行版中稍微用到了它 

1322
01:13:10,910 --> 01:13:13,010
这就是你如何得到一个突出显示的瓷砖 

1323
01:13:13,010 --> 01:13:15,740
还有一个选定的切片和一个选定的切片

1324
01:13:15,740 --> 01:13:19,847
就是画一个矩形 一样的东西 但这次是一条线 

1325
01:13:19,847 --> 01:13:22,430
无论如何 总会有一个选定的磁贴 

1326
01:13:22,430 --> 01:13:25,430
所以我们总是在渲染函数的末尾绘制它 

1327
01:13:25,430 --> 01:13:26,410
只有255--

1328
01:13:26,410 --> 01:13:30,080
234对于不透明 所以它只是一种透明 但不是超级的

1329
01:13:30,080 --> 01:13:31,670
透明的 

1330
01:13:31,670 --> 01:13:37,800
将线宽设置为4 这样它就不会只是一个非常细的矩形 

1331
01:13:37,800 --> 01:13:44,990
如果你设置了线宽 然后用线条格式画了一个矩形--

1332
01:13:44,990 --> 01:13:48,530
绘制的线条模式 它将使用任何当前线条

1333
01:13:48,530 --> 01:13:50,370
宽度是绘制矩形时的宽度 

1334
01:13:50,370 --> 01:13:54,740
因此 我们将其设置为4 然后在seltedTile.x处绘制一条RECT线

1335
01:13:54,740 --> 01:13:59,039
加上OffsetX选定的Tile.Y OffsetY 我们将其绘制为32乘以32

1336
01:13:59,039 --> 01:14:00,830
因为那是瓷砖的大小 然后

1337
01:14:00,830 --> 01:14:05,360
我们设置了颜色--记住始终将颜色设置回255、255、255 

1338
01:14:05,360 --> 01:14:09,770
255因为如果你不这样做 事实上 我在调试的时候做了这个 

1339
01:14:09,770 --> 01:14:16,200
你会得到一些有趣的东西 

1340
01:14:16,200 --> 01:14:18,172
等等 是不是就是这个？

1341
01:14:23,650 --> 01:14:27,240
哦 我可能已经把它修好了--

1342
01:14:27,240 --> 01:14:28,600
这是一个问题 

1343
01:14:28,600 --> 01:14:34,260
如果你不设置 基本上是你的颜色 你把它设置成红色 

1344
01:14:34,260 --> 01:14:36,840
在你做了一些事情之后 一切都会变红的 

1345
01:14:36,840 --> 01:14:42,640
因此 如果发生这种情况 请记住将颜色设置回255、255、255、255 

1346
01:14:42,640 --> 01:14:46,503
任何时候你以某种方式改变颜色 就像我在这里做的那样 

1347
01:14:46,503 --> 01:14:48,336
观众：或者 你也可以

1348
01:14:48,336 --> 01:14:50,820
在你画东西之前 一定要先设定好颜色 是那么回事吗？

1349
01:14:50,820 --> 01:14:51,962
演讲者1：是的 

1350
01:14:51,962 --> 01:14:53,670
回答是确保您始终设置

1351
01:14:53,670 --> 01:14:55,170
在你画东西之前的颜色 

1352
01:14:55,170 --> 01:14:57,540
我想这就是我最终在这个发行版中做的事情 它

1353
01:14:57,540 --> 01:14:58,873
这就是为什么它不再起作用了 

1354
01:14:58,873 --> 01:14:59,880
我想那是...

1355
01:14:59,880 --> 01:15:01,870
它在哪里？

1356
01:15:01,870 --> 01:15:05,130
它在这里 但我一定是修好了 因为我不小心

1357
01:15:05,130 --> 01:15:08,130
我在调试的时候把它漏掉了 结果画出了--所有的东西

1358
01:15:08,130 --> 01:15:08,629
是红色的 

1359
01:15:08,629 --> 01:15:12,660
因此 顺便说一句 Love2D是一个状态机 

1360
01:15:12,660 --> 01:15:16,440
事先把它画出来肯定也是更安全的方式 

1361
01:15:19,522 --> 01:15:22,230
所以这件事的核心 因为我们的时间不多了--

1362
01:15:22,230 --> 01:15:28,300
整个代码块的核心就是这里的交换 

1363
01:15:28,300 --> 01:15:30,480
因此 如果没有突出显示的磁贴--所以基本上 

1364
01:15:30,480 --> 01:15:32,250
如果我们按Enter或Return--

1365
01:15:32,250 --> 01:15:36,510
现在 我们在love.key按键中完成了所有的输入处理 

1366
01:15:36,510 --> 01:15:38,910
顺便说一句 这是要更改的输入处理

1367
01:15:38,910 --> 01:15:40,500
所选瓷砖的x和y 

1368
01:15:43,680 --> 01:15:46,170
如果我们按Enter键 并且没有突出显示的磁贴 

1369
01:15:46,170 --> 01:15:49,470
然后我们需要有一个突出显示的瓷砖 否则我们应该交换它们 

1370
01:15:49,470 --> 01:15:53,724
所以我们得到了第一块和第二块的引用 我们交换 我们创建临时变量 

1371
01:15:53,724 --> 01:15:55,890
回想一下 我们需要让中间人站在这里

1372
01:15:55,890 --> 01:15:57,910
跟踪此磁贴的信息 

1373
01:15:57,910 --> 01:16:00,285
所以它将跟踪所有标题2的S信息

1374
01:16:00,285 --> 01:16:03,480
使用tempX、tempy、tempgridX和tempgridY 因为我们

1375
01:16:03,480 --> 01:16:05,880
不仅需要改变它们的x坐标 

1376
01:16:05,880 --> 01:16:08,190
还有他们的网格位置 

1377
01:16:08,190 --> 01:16:16,110
然后我们需要在这里创建一个临时瓷砖 

1378
01:16:16,110 --> 01:16:19,470
基本上 这就是我们实际上交换他们在董事会中的位置的地方 

1379
01:16:19,470 --> 01:16:24,600
所以标题为1.gridY 标题为1.gridX 标题为2 然后我们得到一个引用

1380
01:16:24,600 --> 01:16:27,090
让瓷砖临时工 这样我们就可以--

1381
01:16:27,090 --> 01:16:35,940
因为如果我们把木板放在瓷砖1到瓷砖2的任何地方 

1382
01:16:35,940 --> 01:16:37,890
我们不会有任何东西在Tle2的地方 

1383
01:16:37,890 --> 01:16:40,250
我们需要一个临时瓷砖来跟踪--

1384
01:16:40,250 --> 01:16:46,170
对不起 如果我们用磁贴2覆盖它 我们将不会有磁贴1的任何东西 

1385
01:16:46,170 --> 01:16:49,410
所以我们需要在这里引用tile1 这样我们就可以把它

1386
01:16:49,410 --> 01:16:52,780
进入2‘S点在哪里 就在这里 

1387
01:16:52,780 --> 01:16:58,486
然后我们需要在我们最终交换他们的坐标之前完成所有这些

1388
01:16:58,486 --> 01:17:01,110
和平铺网格位置 否则会出现奇怪的错误行为

1389
01:17:01,110 --> 01:17:03,880
当您移动选定的瓷砖时 

1390
01:17:03,880 --> 01:17:06,960
然后我们可以突出显示 然后重置选择

1391
01:17:06,960 --> 01:17:10,330
因为他们的选择也会在我们交换之后发生变化 

1392
01:17:10,330 --> 01:17:15,090
所以我们需要把它放到第二个瓷砖上 因为它可以与任何东西交换

1393
01:17:15,090 --> 01:17:18,110
我们突出显示的磁贴 

1394
01:17:18,110 --> 01:17:19,940
这就是总体要旨 

1395
01:17:19,940 --> 01:17:22,830
它基本上是拿两块瓷砖 翻转信息 

1396
01:17:22,830 --> 01:17:23,970
储存一个中间人 

1397
01:17:23,970 --> 01:17:26,260
CS50中的掉期也是如此 稍微复杂一些 

1398
01:17:26,260 --> 01:17:30,210
不过 因为这些都有需要处理的子字段 

1399
01:17:30,210 --> 01:17:32,530
实际上 其中很多都可以通过数学运算来实现 

1400
01:17:32,530 --> 01:17:37,407
你实际上可以用数学方法推导出它的x和y

1401
01:17:37,407 --> 01:17:38,490
来自GridX和Gridy 

1402
01:17:38,490 --> 01:17:40,620
只需乘以32即可 

1403
01:17:40,620 --> 01:17:43,920
在这种情况下 我只是将它们作为变量 并将其分开 

1404
01:17:43,920 --> 01:17:47,430
但是 是的 你也可以这样做 而且

1405
01:17:47,430 --> 01:17:51,930
只要我们移动变量 就会产生交换变量的效果 

1406
01:17:51,930 --> 01:17:56,490
这是第三场比赛最基本的第一步 

1407
01:17:56,490 --> 01:17:58,900
只是在给定位置交换任意两个瓷砖 

1408
01:17:58,900 --> 01:18:01,770
那么 这完全说得通吗？

1409
01:18:01,770 --> 01:18:03,630
好的 

1410
01:18:03,630 --> 01:18:11,070
因此 这个示例实际上与Swap2没有太大不同 

1411
01:18:11,070 --> 01:18:13,200
现在 我将向你们展示交换2 

1412
01:18:13,200 --> 01:18:19,530
因此 如果我们转到Swap2 我们真正做的唯一更改

1413
01:18:19,530 --> 01:18:26,090
现在瓷砖翻转 而不是立即改变 他们之间 

1414
01:18:26,090 --> 01:18:27,840
在这一点上 这是小菜一碟 

1415
01:18:27,840 --> 01:18:31,030
我们已经知道--我们需要做什么功能？

1416
01:18:31,030 --> 01:18:32,742
只是计时器而已 

1417
01:18:32,742 --> 01:18:34,950
我们所要做的就是带走这两个人 然后

1418
01:18:34,950 --> 01:18:40,030
从tile1.x和tile1.y到tile2.x和tile2.y 

1419
01:18:40,030 --> 01:18:41,700
然后反向做同样的事情 

1420
01:18:41,700 --> 01:18:46,210
从tile2.x和tile2.y到tile1.x和tile1.y 

1421
01:18:46,210 --> 01:18:52,740
所以如果我们打开Swap2 转到Main 在这个程序中什么都没有

1422
01:18:52,740 --> 01:18:58,050
真正的变化 除了在更新中 我们转到第99行 

1423
01:18:58,050 --> 01:18:59,294
而我们只是在这里做这件事 

1424
01:18:59,294 --> 01:19:00,210
请注意其定义 

1425
01:19:00,210 --> 01:19:03,479
在0.2秒内 它在定义表中 这里 

1426
01:19:03,479 --> 01:19:06,270
它接受了两个实体 因为我们正在修改两个东西 

1427
01:19:06,270 --> 01:19:08,640
我们正在修改标题2和标题1 

1428
01:19:08,640 --> 01:19:13,230
我们只是将x设置为tile1.x y设置为tile1.y 

1429
01:19:13,230 --> 01:19:15,967
然后Tle1得到了tempX和Tempy

1430
01:19:15,967 --> 01:19:18,550
因为以前 它只是直接从临时工那里拿到的 

1431
01:19:18,550 --> 01:19:22,270
现在 它只是随着时间的推移而调整 

1432
01:19:22,270 --> 01:19:26,830
但那是在一堆tile2.x等于tile1.x之前 

1433
01:19:26,830 --> 01:19:33,310
Tile2.y等于tile2.y tile1.y等于tile2.y 

1434
01:19:33,310 --> 01:19:34,070
仅此而已 

1435
01:19:34,070 --> 01:19:35,528
这就是它真正好的地方 

1436
01:19:35,528 --> 01:19:38,050
现在我们根本不需要真正努力工作

1437
01:19:38,050 --> 01:19:41,890
为了在我们所做的任何事情中获得良好、平稳的过渡 

1438
01:19:41,890 --> 01:19:43,870
无论是用户界面 还是游戏 

1439
01:19:43,870 --> 01:19:47,249
它太棒了 而且很方便 

1440
01:19:47,249 --> 01:19:49,540
因此 我们需要做的就是完成基本的掉期交易 

1441
01:19:49,540 --> 01:19:51,840
那是Swap2 青少年互换 

1442
01:19:51,840 --> 01:19:54,070
所以我在这里放了一组幻灯片

1443
01:19:54,070 --> 01:19:58,180
来说明我们用来计算匹配的算法 

1444
01:19:58,180 --> 01:20:02,080
所以现在我们可以换货 但我们

1445
01:20:02,080 --> 01:20:03,880
不知道我们什么时候找到匹配的了 

1446
01:20:03,880 --> 01:20:06,850
所以 顺便说一句 有没有人知道

1447
01:20:06,850 --> 01:20:09,732
我们怎样才能开始计算我们是否有匹配的呢？

1448
01:20:15,188 --> 01:20:18,660
观众：嗯 我们已经知道了如何追踪一个物体是否相邻 

1449
01:20:18,660 --> 01:20:21,636
所以 我想 你有一张相邻的桌子--

1450
01:20:21,636 --> 01:20:24,612
你穿过[INAUDIBLE]区块 如果你有一个相邻的--

1451
01:20:24,612 --> 01:20:29,076
或者 对于每个相邻的块 检查该颜色是否与您的颜色相同 

1452
01:20:29,076 --> 01:20:31,824
如果是这样的话 你会检查是否--

1453
01:20:31,824 --> 01:20:34,532
好吧 那我想你需要弄清楚它在哪个方向 

1454
01:20:34,532 --> 01:20:37,508
然后你检查 继续往那个方向走 

1455
01:20:37,508 --> 01:20:40,050
如果有另一个同样颜色的 

1456
01:20:40,050 --> 01:20:42,840
演讲者1：所以他们的反应是当你

1457
01:20:42,840 --> 01:20:46,920
看看瓷砖 看看所有相邻的瓷砖 

1458
01:20:46,920 --> 01:20:52,470
如果有一种颜色是相同的 那么就找出它的方向 

1459
01:20:52,470 --> 01:20:55,130
然后从那里搬出去 

1460
01:20:55,130 --> 01:20:56,950
就像一种递归风格 

1461
01:20:56,950 --> 01:20:59,934
我想您可以递归地实现它 

1462
01:20:59,934 --> 01:21:02,850
它可能会更难理解 而且可能

1463
01:21:02,850 --> 01:21:05,130
效率不是很高 

1464
01:21:05,130 --> 01:21:07,950
我们实际上要实施它的方式

1465
01:21:07,950 --> 01:21:13,320
将会有更多的迭代 

1466
01:21:13,320 --> 01:21:19,290
所以我们真正需要做的就是检查每一行 每一列 

1467
01:21:19,290 --> 01:21:21,450
然后基本上 从左到右 

1468
01:21:21,450 --> 01:21:25,412
所以在这种情况下 我们必须检查每一行和每一列

1469
01:21:25,412 --> 01:21:27,870
朝这个方向走一次 然后朝这个方向走一次

1470
01:21:27,870 --> 01:21:33,420
因为我们可以得到垂直和水平匹配 

1471
01:21:33,420 --> 01:21:35,350
所以我们开始吧 

1472
01:21:35,350 --> 01:21:40,450
让我们随意决定我们要开始从左到右查看数据

1473
01:21:40,450 --> 01:21:41,250
结构 

1474
01:21:41,250 --> 01:21:43,950
那我们就去 这是什么颜色的？

1475
01:21:43,950 --> 01:21:44,600
那是棕色的 

1476
01:21:44,600 --> 01:21:46,200
好的 检查下一个 

1477
01:21:46,200 --> 01:21:47,820
是同样的颜色吗？

1478
01:21:47,820 --> 01:21:52,680
如果是 则说确定 即我们到目前为止找到的匹配切片的数量

1479
01:21:52,680 --> 01:21:54,090
是两个 

1480
01:21:54,090 --> 01:21:57,060
如果它大于3 那么稍后我们将

1481
01:21:57,060 --> 01:22:03,130
基本上 需要将该组作为匹配添加到我们的匹配列表中 

1482
01:22:03,130 --> 01:22:07,340
但如果不是 那么匹配的数字又是1 

1483
01:22:07,340 --> 01:22:09,510
因此 将其设置为1 然后执行相同的操作 

1484
01:22:09,510 --> 01:22:10,211
一样的颜色？

1485
01:22:10,211 --> 01:22:10,710
不是的 

1486
01:22:10,710 --> 01:22:12,780
好的 匹配的次数是1 

1487
01:22:12,780 --> 01:22:16,680
在这种情况下 匹配的数量将是两个

1488
01:22:16,680 --> 01:22:19,770
因为这是蓝色的 然后我们要继续 

1489
01:22:19,770 --> 01:22:20,865
然后又是同样的颜色 

1490
01:22:20,865 --> 01:22:25,450
匹配的数字是三个 然后我们就到了这一排的最后 

1491
01:22:25,450 --> 01:22:28,680
所以我们可以说 我们最后一次比赛的次数是多少？

1492
01:22:28,680 --> 01:22:31,050
它是大于还是等于三？

1493
01:22:31,050 --> 01:22:34,080
如果是 请将该组瓷砖添加到我们的

1494
01:22:34,080 --> 01:22:37,650
如果我们找到匹配的话 然后继续前进 

1495
01:22:37,650 --> 01:22:40,950
我们一遍又一遍地做这件事 如果它是在一个小组的中间 

1496
01:22:40,950 --> 01:22:43,200
就像它在这里一样--所以这不是排在最后的 

1497
01:22:43,200 --> 01:22:44,783
这就在这一排的中间 

1498
01:22:44,783 --> 01:22:49,170
我们要做的是一、二、三场比赛 然后我们来到这里 

1499
01:22:49,170 --> 01:22:50,434
而且它被设置为1 

1500
01:22:50,434 --> 01:22:52,350
好的 首先 我们检查匹配的数量

1501
01:22:52,350 --> 01:22:53,724
当我们看到不同的颜色时 

1502
01:22:53,724 --> 01:22:56,180
我们说 好的 这和这块瓷砖的颜色不一样 

1503
01:22:56,180 --> 01:23:00,960
这个是紫色的 这个是灰色的 但匹配的数量是三个 

1504
01:23:00,960 --> 01:23:06,880
所以我们要做的就是把这三块瓷砖加到我们的--

1505
01:23:06,880 --> 01:23:09,960
我们准备了一桌火柴 因为我们要通过 

1506
01:23:09,960 --> 01:23:11,550
我们要把它们全部删除 

1507
01:23:11,550 --> 01:23:15,090
然后 最终 我们还会做一些补丁 

1508
01:23:15,090 --> 01:23:17,100
但我们将删除所有这些内容 

1509
01:23:17,100 --> 01:23:20,220
然后为了做到这一点 我们需要向后走 

1510
01:23:20,220 --> 01:23:24,240
我们需要说 基本上 因为x得到了位置

1511
01:23:24,240 --> 01:23:28,742
减去匹配中的瓷砖数量 只需将其添加到匹配中 

1512
01:23:28,742 --> 01:23:30,450
把它加到火柴上 再加到火柴上 

1513
01:23:30,450 --> 01:23:32,850
然后将火柴添加到我们的火柴列表中 

1514
01:23:32,850 --> 01:23:34,685
这就是x方向的情况 

1515
01:23:34,685 --> 01:23:36,810
对于y方向 这是完全相同的 

1516
01:23:36,810 --> 01:23:39,643
在这里--不同的颜色 

1517
01:23:39,643 --> 01:23:42,490
不同的颜色 然后是相同的颜色 相同的颜色 不同的颜色 

1518
01:23:42,490 --> 01:23:46,470
但匹配的数量是三个 因为一 二 三 然后

1519
01:23:46,470 --> 01:23:50,290
它会向后走 向上走到顶端 添加那个火柴 

1520
01:23:50,290 --> 01:23:51,750
然后继续往下走 

1521
01:23:51,750 --> 01:23:54,180
一样的东西 一样的东西 然后一样的东西 

1522
01:23:54,180 --> 01:23:56,350
这是在本专栏的末尾 

1523
01:23:56,350 --> 01:23:57,690
所以它会一直持续到最后 

1524
01:23:57,690 --> 01:24:00,900
它实际上不会去寻找下一个瓷砖

1525
01:24:00,900 --> 01:24:03,270
因为已经没有瓷砖了 但每次

1526
01:24:03,270 --> 01:24:07,122
我们完成一行或一列 我们在最后检查 

1527
01:24:07,122 --> 01:24:09,580
我们有等于或超过三场比赛的比赛次数吗？

1528
01:24:09,580 --> 01:24:11,520
如果我们这样做了 那么我们需要做同样的逻辑

1529
01:24:11,520 --> 01:24:14,880
正如我们之前所做的那样 将该匹配添加到我们的匹配列表中 

1530
01:24:14,880 --> 01:24:19,440
这实际上是一个非常简单的算法 这是一组步骤

1531
01:24:19,440 --> 01:24:21,630
我刚才举例说明了这一点 

1532
01:24:21,630 --> 01:24:23,295
我们在那里找到了一根火柴 

1533
01:24:23,295 --> 01:24:24,420
啊!对不起 [?托尼 ？]是?

1534
01:24:24,420 --> 01:24:30,030
观众：如果你同时完成两场比赛 它会同时看到两场比赛吗？

1535
01:24:30,030 --> 01:24:31,680
演讲者1：会的 

1536
01:24:31,680 --> 01:24:34,680
问题是 如果你同时完成两场比赛 它会同时看到两场比赛吗？

1537
01:24:34,680 --> 01:24:35,280
是 

1538
01:24:35,280 --> 01:24:39,570
如果你完成了--如果你删除了它就不会了

1539
01:24:39,570 --> 01:24:43,790
因为我们假设你这里有一个 两个 三个 

1540
01:24:43,790 --> 01:24:46,890
我猜你是这个意思 一 二 三 一 二 三 

1541
01:24:46,890 --> 01:24:52,080
如果你只是随手删除它们 那么不 它不会看到它们 

1542
01:24:52,080 --> 01:24:55,450
它会放在这里 它会得到这三个 删除它们 

1543
01:24:55,450 --> 01:24:57,180
然后它只会看到这两个人 

1544
01:24:57,180 --> 01:24:59,730
但因为我们走过了整件事 

1545
01:24:59,730 --> 01:25:03,030
然后 我们只在处理完所有匹配后才删除匹配 

1546
01:25:03,030 --> 01:25:06,314
我们将首先添加这个 然后当我们做垂直的时候 

1547
01:25:06,314 --> 01:25:09,480
我们还会看到这场比赛 所以它将被算作两场比赛 

1548
01:25:09,480 --> 01:25:12,330
如果你愿意 你可以让你的代码变得更复杂 

1549
01:25:12,330 --> 01:25:14,820
假设两个匹配之间有交集 

1550
01:25:14,820 --> 01:25:16,900
我想给球员更多的分数 

1551
01:25:16,900 --> 01:25:20,364
或者我想给他一些效果 就像《糖果粉碎传奇》里的那样 

1552
01:25:20,364 --> 01:25:22,280
我觉得你会像爆炸一样 或者珠光宝气 

1553
01:25:22,280 --> 01:25:25,450
如果你得到一个像T形的图案 你就会发生爆炸 

1554
01:25:25,450 --> 01:25:29,530
如果你连续四次 屏幕上就会出现激光之类的东西 

1555
01:25:29,530 --> 01:25:32,380
实际上 作业的一部分就是清楚地排成一行 

1556
01:25:32,380 --> 01:25:37,990
如果你连续拿到四个 你应该清空那一排 或者打电话给他们 

1557
01:25:37,990 --> 01:25:40,360
如果你这么做了 那么 你就有了逻辑 

1558
01:25:40,360 --> 01:25:44,290
但目前 发行版所做的只是一个简单的迭代--

1559
01:25:44,290 --> 01:25:46,990
先水平 然后垂直 边走边添加火柴 

1560
01:25:46,990 --> 01:25:49,690
实际上 有一个优化是可以实现的 

1561
01:25:49,690 --> 01:25:54,700
如果你去这里 比如说 我们要去这里 这里 

1562
01:25:54,700 --> 01:25:59,860
然后我们来到了这里 我们的颜色与上一次不同 

1563
01:25:59,860 --> 01:26:01,870
我们可以直接去下一家 

1564
01:26:01,870 --> 01:26:05,440
我们可以直接跳过 因为我们知道我们只剩下两个了 

1565
01:26:05,440 --> 01:26:10,090
如果你是在n减2 那么寻找匹配就没有意义了

1566
01:26:10,090 --> 01:26:12,170
因为找不到匹配的方法 

1567
01:26:12,170 --> 01:26:13,060
所以这只是一条捷径 

1568
01:26:13,060 --> 01:26:15,893
您可以进行一些优化 这实际上包含在代码中 

1569
01:26:15,893 --> 01:26:17,690
如果你在--就停下来吧

1570
01:26:17,690 --> 01:26:21,910
在代码中 x或y等于7 

1571
01:26:21,910 --> 01:26:23,830
从根本上说 就是摆脱FOR循环 

1572
01:26:23,830 --> 01:26:28,780
然后转到下一行或下一列 

1573
01:26:32,500 --> 01:26:34,810
关于它是如何工作的 还有什么问题吗？

1574
01:26:38,170 --> 01:26:41,770
如果你真的在看代码 我们不会再看了

1575
01:26:41,770 --> 01:26:44,152
在课堂上讲得太详细了 

1576
01:26:44,152 --> 01:26:46,360
这很简单 我想 一旦我陪你走

1577
01:26:46,360 --> 01:26:52,060
通过算法 但我会为您指出相关的行 

1578
01:26:52,060 --> 01:26:53,150
它处于播放状态 

1579
01:26:53,150 --> 01:26:53,650
不 对不起 

1580
01:26:53,650 --> 01:26:59,020
它在黑板上的计算匹配功能中 

1581
01:26:59,020 --> 01:27:04,840
在这里 第50行 计算匹配项 

1582
01:27:04,840 --> 01:27:08,180
所以水平匹配 y得到1到8 

1583
01:27:08,180 --> 01:27:10,337
你保持颜色相匹配 基本上 你只是

1584
01:27:10,337 --> 01:27:11,920
记录一下你匹配了多少个 

1585
01:27:11,920 --> 01:27:16,090
当你在做一种全新的颜色时 总是匹配第一个数字 

1586
01:27:16,090 --> 01:27:18,310
然后从x2到8开始 因为我们已经

1587
01:27:18,310 --> 01:27:24,490
得到了第一个瓷砖 基本上 如果颜色相同 则递增matchNum 

1588
01:27:24,490 --> 01:27:29,800
否则 将当前颜色设置为下一个磁贴的颜色 

1589
01:27:29,800 --> 01:27:36,010
如果我们这样做了 并且我们的匹配大于或等于3 

1590
01:27:36,010 --> 01:27:37,019
然后我们找到了匹配的 

1591
01:27:37,019 --> 01:27:37,810
我们可以添加匹配项 

1592
01:27:37,810 --> 01:27:39,090
我们创建一个新表 

1593
01:27:39,090 --> 01:27:43,030
我们从x2的位置倒退得到x减去1 

1594
01:27:43,030 --> 01:27:44,380
然后x减去matchNum 

1595
01:27:44,380 --> 01:27:46,780
所以无论比赛时间有多长 它都是有效的 

1596
01:27:46,780 --> 01:27:49,420
不管是三个、四个还是五个 

1597
01:27:49,420 --> 01:27:51,490
然后我们减去1 然后你就

1598
01:27:51,490 --> 01:27:56,560
插入到火柴中 该x2位置处瓷砖

1599
01:27:56,560 --> 01:27:58,570
因为火柴是用瓷砖做的 

1600
01:27:58,570 --> 01:28:01,400
所以火柴只是一组瓷砖放在一起 

1601
01:28:01,400 --> 01:28:04,660
所以你可以通过比较瓷砖与任何给定的匹配物相交 

1602
01:28:04,660 --> 01:28:06,951
只是看看它们是否有基本上相同的瓷砖 

1603
01:28:06,951 --> 01:28:09,940
这就是你得到交叉匹配的方法 

1604
01:28:09,940 --> 01:28:14,440
然后在所有操作完成后 只需插入到匹配的火柴中 

1605
01:28:14,440 --> 01:28:15,940
这是一个小小的优化 

1606
01:28:15,940 --> 01:28:19,120
如果x大于或等于7 这是循环的一部分

1607
01:28:19,120 --> 01:28:23,210
我们已经知道我们用的是上一种颜色的新颜色 

1608
01:28:23,210 --> 01:28:27,880
我们将中断 然后将matchNum设置为1(如果我们还没有达到该点

1609
01:28:27,880 --> 01:28:28,600
现在还不行 

1610
01:28:28,600 --> 01:28:33,700
然后这是代码的最后一行--

1611
01:28:33,700 --> 01:28:37,330
行以匹配结束 因为我们不会在下一个循环中

1612
01:28:37,330 --> 01:28:39,880
看看我们是不是要换一种颜色 

1613
01:28:39,880 --> 01:28:45,414
我们只需要检查以确保在任何行迭代结束时 

1614
01:28:45,414 --> 01:28:47,830
或列迭代 当我们转到下一行或列时 

1615
01:28:47,830 --> 01:28:51,310
在我们进入下一行或下一列之前 该matchNum

1616
01:28:51,310 --> 01:28:53,860
大于或等于3 如果是这样 

1617
01:28:53,860 --> 01:28:57,430
然后在这里做同样的逻辑 但是从8开始 

1618
01:28:57,430 --> 01:28:58,950
垂直比赛也是如此 

1619
01:28:58,950 --> 01:29:02,260
完全相同的逻辑 只有x和y是颠倒的 

1620
01:29:02,260 --> 01:29:03,970
然后就是这样 

1621
01:29:03,970 --> 01:29:08,080
然后是self.matches 我们在黑板上保留对self.matches的引用

1622
01:29:08,080 --> 01:29:12,670
这样以后我们就可以把它们移到这里 而我

1623
01:29:12,670 --> 01:29:15,750
相信我们把它用来做别的事了 

1624
01:29:15,750 --> 01:29:21,070
然后我们返回 基本上 如果匹配的数量大于0 

1625
01:29:21,070 --> 01:29:24,937
我们将返回匹配项 否则将返回False 

1626
01:29:24,937 --> 01:29:26,020
我们以后可以用这个 

1627
01:29:26,020 --> 01:29:29,470
我们可以说 如果从我们的比赛状态来看 

1628
01:29:29,470 --> 01:29:32,320
然后我们可以调用其他几个函数 并将

1629
01:29:32,320 --> 01:29:34,330
新瓷砖之类的东西 

1630
01:29:34,330 --> 01:29:39,950
但为了说明问题的全面性 

1631
01:29:39,950 --> 01:29:41,650
这就是算法的工作原理 

1632
01:29:41,650 --> 01:29:44,750
在这种情况下 实际上 这是在我进行优化之前 

1633
01:29:44,750 --> 01:29:47,575
在这种情况下 我们实际上不会这样做 

1634
01:29:47,575 --> 01:29:52,330
它甚至在检查这个之前就会缩短到下一列 

1635
01:29:52,330 --> 01:29:55,560
但如果你的算法没有进行优化 那么是的 

1636
01:29:55,560 --> 01:29:56,950
我只能看到那里有两块瓷砖 

1637
01:29:56,950 --> 01:30:00,070
去下一家 那里什么都没有 没有匹配的 

1638
01:30:00,070 --> 01:30:02,200
这里也是一样 

1639
01:30:02,200 --> 01:30:04,600
那里有一场比赛 比赛将会是

1640
01:30:04,600 --> 01:30:09,470
在这张图的末尾没有发现 

1641
01:30:09,470 --> 01:30:11,950
当它指向这里时 它会被计算出来 

1642
01:30:11,950 --> 01:30:17,400
但它知道在该点上matchNum大于或等于3 

1643
01:30:17,400 --> 01:30:19,780
它在这里做的也是一样的事情 

1644
01:30:19,780 --> 01:30:22,540
我们只是按列排列 然后什么都没有 

1645
01:30:22,540 --> 01:30:25,790
那里什么都没有 然后我们就有一个在那里 

1646
01:30:25,790 --> 01:30:27,530
所以下一部分--

1647
01:30:27,530 --> 01:30:29,845
哦 对这是怎么回事有什么问题吗？

1648
01:30:34,310 --> 01:30:36,652
下一部分--我们现在有了火柴 

1649
01:30:36,652 --> 01:30:37,610
我们把它们放在桌子上 

1650
01:30:37,610 --> 01:30:38,360
我们有瓷砖 

1651
01:30:38,360 --> 01:30:39,890
我们有关于瓷砖的资料 

1652
01:30:39,890 --> 01:30:42,470
一旦我们有了--我们怎么把瓷砖移走？

1653
01:30:42,470 --> 01:30:45,686
一旦我们有了火柴 我们如何尽快摆脱他们？

1654
01:30:52,200 --> 01:30:59,640
假设我们的电路板是一张表 一张2D表 其中的每个数组

1655
01:30:59,640 --> 01:31:04,691
有一个瓷砖对象 我们如何清除我们的瓷砖板？

1656
01:31:04,691 --> 01:31:08,130
观众：你包括你要转移的东西了吗？

1657
01:31:08,130 --> 01:31:11,640
演讲者1：不 只是把它去掉--就像这样 

1658
01:31:11,640 --> 01:31:12,770
把它从游戏中移除就行了 

1659
01:31:12,770 --> 01:31:15,590
观众：哦 

1660
01:31:15,590 --> 01:31:21,326
我想你可以[INAUDIBLE]

1661
01:31:21,326 --> 01:31:22,450
演讲者1：是的 你可以 

1662
01:31:22,450 --> 01:31:24,699
是啊 稍微弄虚作假 你就能拿到

1663
01:31:24,699 --> 01:31:27,790
你可以将瓷砖设置为隐形 

1664
01:31:27,790 --> 01:31:31,790
然后你可以给它一个新的磁贴ID 我想 

1665
01:31:31,790 --> 01:31:36,550
然后把它移到上面 然后让它来 

1666
01:31:36,550 --> 01:31:40,600
我不知道这种方法是否有必要

1667
01:31:40,600 --> 01:31:42,730
由于地心引力的缘故 这方面的效果非常好

1668
01:31:42,730 --> 01:31:44,290
因为瓷砖必须要拆下来 

1669
01:31:44,290 --> 01:31:48,970
因此 如果它们在这里的底部 那么你必须带上较低的那些 

1670
01:31:48,970 --> 01:31:50,560
这些将不得不降下来 

1671
01:31:52,672 --> 01:31:54,630
这种方法可能会有点棘手 

1672
01:31:54,630 --> 01:31:58,090
我想 你可以让它发挥作用 

1673
01:31:58,090 --> 01:32:01,450
我们在这个发行版中使用的简单方法 

1674
01:32:01,450 --> 01:32:05,050
实际上就是将它们设置为零 因为如果您将某个值设置为零 

1675
01:32:05,050 --> 01:32:07,206
在这种情况下 它只是不会呈现 

1676
01:32:07,206 --> 01:32:10,330
因此 我们只是将所有以前在那里的瓷砖设置为零 

1677
01:32:10,330 --> 01:32:12,310
在这一点上 他们什么都不是 

1678
01:32:12,310 --> 01:32:16,300
如果您尝试渲染它们 它们实际上会像这样渲染 

1679
01:32:16,300 --> 01:32:20,930
假设您的代码说明了这一点 或者它没有崩溃 

1680
01:32:20,930 --> 01:32:27,670
然后下一步就是实际修好电路板

1681
01:32:27,670 --> 01:32:30,310
因为我们已经把瓷砖移走了 

1682
01:32:30,310 --> 01:32:34,250
所以现在 我们这里有这个东西 但在那里

1683
01:32:34,250 --> 01:32:37,810
这是在我们得到新瓷砖之前必须完成的一个步骤 这就是重力 

1684
01:32:37,810 --> 01:32:40,000
我们真的要把所有东西都往下移 

1685
01:32:40,000 --> 01:32:44,072
那么 我们如何着手将瓷砖向下移动呢？

1686
01:32:44,072 --> 01:32:46,780
所以在第一篇专栏中 我们不需要做任何事情 对吗？

1687
01:32:46,780 --> 01:32:49,049
这一栏都准备好了 但这一栏呢？

1688
01:32:49,049 --> 01:32:49,840
我们将如何转移？

1689
01:32:49,840 --> 01:32:52,968
我们怎么才能把瓷砖铺下去呢？

1690
01:32:52,968 --> 01:32:54,292
观众：[听不见]

1691
01:32:54,292 --> 01:32:55,000
演讲者1：什么？

1692
01:32:55,000 --> 01:32:56,170
观众：又是青少年？

1693
01:32:56,170 --> 01:32:57,220
演讲者1：青少年 

1694
01:32:57,220 --> 01:33:00,790
是的 我们可以使用Tweens 但从数据结构

1695
01:33:00,790 --> 01:33:02,050
立场 我们怎么.

1696
01:33:02,050 --> 01:33:05,262
因为这只会在XY之间 但不一定

1697
01:33:05,262 --> 01:33:06,970
修复--底层数据结构仍然

1698
01:33:06,970 --> 01:33:09,820
必须代表--因为我们将对其进行迭代 

1699
01:33:09,820 --> 01:33:12,520
我们必须在正确的位置引用瓷砖 

1700
01:33:12,520 --> 01:33:15,130
观众：所以就是把桌子移开

1701
01:33:15,130 --> 01:33:17,260
从第四排到第五排 

1702
01:33:17,260 --> 01:33:20,890
演讲者1：那么你怎么开始取下这块瓷砖

1703
01:33:20,890 --> 01:33:23,704
到了这个位置？

1704
01:33:23,704 --> 01:33:26,470
观众：把它从第四排换到第五排 

1705
01:33:26,470 --> 01:33:27,655
演讲者1：你会的 

1706
01:33:27,655 --> 01:33:31,939
你的算法将如何一步一步地工作 以确保实现这一点？

1707
01:33:36,669 --> 01:33:41,019
观众：它是从底部开始的吗 如果是零 它会上升更多

1708
01:33:41,019 --> 01:33:41,810
演讲者1：完全正确 

1709
01:33:41,810 --> 01:33:43,660
这就是你要做的 

1710
01:33:43,660 --> 01:33:49,790
你从底层开始 然后当我们有任何东西是零的时候 

1711
01:33:49,790 --> 01:33:53,910
我们需要寻找它上面的第一个不是零的瓷砖 然后将它向下移动 

1712
01:33:53,910 --> 01:33:57,350
所以在这种情况下 我们从底部开始 我们沿着这条路向上 

1713
01:33:57,350 --> 01:34:00,380
不是零 不是零 

1714
01:34:00,380 --> 01:34:02,630
所以这些都不是代码中的空格 

1715
01:34:02,630 --> 01:34:07,626
这叫Spacey 或称Space and Spacey 

1716
01:34:07,626 --> 01:34:09,500
所以我们转到下一个专栏 我们只

1717
01:34:09,500 --> 01:34:11,610
在这种情况下 必须垂直检查 

1718
01:34:11,610 --> 01:34:13,735
我们不需要对任何东西进行横向检查

1719
01:34:13,735 --> 01:34:15,870
因为重力只能沿着一个方向 

1720
01:34:15,870 --> 01:34:17,120
所以我们就从这里走过去 

1721
01:34:17,120 --> 01:34:21,770
所以我们只循环了这段代码 在这种情况下 有效地 五次 

1722
01:34:21,770 --> 01:34:24,770
但在我们的代码中 是八次 

1723
01:34:24,770 --> 01:34:28,400
但它需要是WHILE循环而不是FOR循环 

1724
01:34:28,400 --> 01:34:29,820
我们一会儿就会知道原因 

1725
01:34:29,820 --> 01:34:31,460
但从这里开始吧 

1726
01:34:31,460 --> 01:34:33,650
我们看到了 哦 我们在那里有一个空间 

1727
01:34:33,650 --> 01:34:39,080
所以我们需要做的是 好的 最低的空间在这里 

1728
01:34:39,080 --> 01:34:42,764
所以我们需要寻找它上面的下一个瓷砖 然后将它向下移动 

1729
01:34:42,764 --> 01:34:44,930
所以我们把这个作为参考 我们在这里寻找 

1730
01:34:44,930 --> 01:34:46,520
我们会说 哦 这是一块瓷砖 

1731
01:34:46,520 --> 01:34:47,300
完美无缺 

1732
01:34:47,300 --> 01:34:49,510
所以我要拿着这块瓷砖 我

1733
01:34:49,510 --> 01:34:52,460
将空间索引设置为该磁贴 

1734
01:34:52,460 --> 01:34:55,010
然后我会把这个指数设置为零 

1735
01:34:55,010 --> 01:34:58,460
然后我们只需要重新开始 从这里开始

1736
01:34:58,460 --> 01:35:01,670
因为这块瓷砖现在是太空了 

1737
01:35:01,670 --> 01:35:06,770
所以我们必须抬头看这里 然后说好的 所以基本上 我们的y计数器

1738
01:35:06,770 --> 01:35:10,670
保持在那个位置 然后返回 因为我们的y计数器可以 

1739
01:35:10,670 --> 01:35:13,310
从理论上讲 在它找到瓷砖之前大老远跑到这里来 

1740
01:35:13,310 --> 01:35:17,450
然后把它一直往下移 但我们不能--或者在这里 让我们

1741
01:35:17,450 --> 01:35:19,220
假设这里有两块瓷砖 

1742
01:35:19,220 --> 01:35:22,400
我们的y计数器可能会在这里结束 因为这些都是空格 

1743
01:35:22,400 --> 01:35:25,220
瓷砖被移到这里 但我们不能

1744
01:35:25,220 --> 01:35:28,670
在这里重新开始我们的y计数器 然后转到下一个瓷砖 

1745
01:35:28,670 --> 01:35:31,580
并寻找空间 因为我们这里有所有的空间 

1746
01:35:31,580 --> 01:35:32,520
所以这是一个While循环 

1747
01:35:32,520 --> 01:35:36,690
所以 虽然这些点基本上都没有空格 

1748
01:35:36,690 --> 01:35:39,080
我们需要确保我们继续降低瓦片 

1749
01:35:39,080 --> 01:35:43,010
所以在这里保留一个参考 在这里瓷砖 把它放下来 在这里留出空间 

1750
01:35:43,010 --> 01:35:44,690
所以我们保留了一个空间的参照 

1751
01:35:44,690 --> 01:35:46,460
我们说 哦 这里现在有一个空间 

1752
01:35:46,460 --> 01:35:48,935
我们可以往上看 但到处都没有瓷砖 

1753
01:35:48,935 --> 01:35:51,810
所以我们知道我们可以继续循环的下一次迭代 

1754
01:35:51,810 --> 01:35:52,935
我们没有找到任何瓷砖 

1755
01:35:52,935 --> 01:35:54,300
我们不需要为它操心 

1756
01:35:54,300 --> 01:35:55,370
这里也是一样 

1757
01:35:55,370 --> 01:35:59,450
我们有一个太空参考 瓷砖 找到了一块瓷砖 

1758
01:35:59,450 --> 01:36:04,970
向下移动 这里的空间 这里的瓷砖 向下移动 这里的空间 这里的瓷砖 

1759
01:36:04,970 --> 01:36:09,240
向下移动 空格 空格 完成 然后我们冲洗 重复这个过程 

1760
01:36:09,240 --> 01:36:13,010
这几乎是一种泡泡排序型算法 

1761
01:36:13,010 --> 01:36:18,180
不是一种 但它或多或少有相同的外观和行为 

1762
01:36:18,180 --> 01:36:20,780
这只是它的一个视觉插图 

1763
01:36:20,780 --> 01:36:24,050
所以从底部开始 向上 我们在这里寻找空间 

1764
01:36:24,050 --> 01:36:26,510
没有空格；柱子非常稳定 

1765
01:36:26,510 --> 01:36:30,440
我们在这里找到了一个空间 瓷砖在那里 把它往下移 

1766
01:36:30,440 --> 01:36:35,650
重新启动循环从瓷砖 空格 没有更多的空格；

1767
01:36:35,650 --> 01:36:36,710
柱子稳定 

1768
01:36:36,710 --> 01:36:42,350
找到的空间、找到的磁贴、移位、找到的空间、找到的磁贴、移位、找到的空间

1769
01:36:42,350 --> 01:36:46,100
平铺已找到、移位等 

1770
01:36:46,100 --> 01:36:47,960
这就是要点所在 

1771
01:36:47,960 --> 01:36:50,160
超级 超级基础 

1772
01:36:50,160 --> 01:36:54,705
但现在我们实际上必须更换瓷砖 

1773
01:36:54,705 --> 01:36:56,330
观众：你甚至不需要检查 

1774
01:36:56,330 --> 01:36:58,330
一旦你向下移动一个街区 你甚至不会

1775
01:36:58,330 --> 01:37:00,162
需要检查其上方的空间 是否为空间

1776
01:37:00,162 --> 01:37:02,911
或者不是因为你知道当你只是

1777
01:37:02,911 --> 01:37:05,294
移了一个街区 对吧？

1778
01:37:05,294 --> 01:37:05,960
演讲者1：是的 

1779
01:37:05,960 --> 01:37:06,980
事实上 这是真的 

1780
01:37:06,980 --> 01:37:10,460
是啊 我想如果是那样的话 你就不需要了 

1781
01:37:10,460 --> 01:37:16,530
但我们确实需要一个关于那个空间的参考 并继续检查它上面的 

1782
01:37:16,530 --> 01:37:19,430
但是 是的 我想你可能不一定需要 

1783
01:37:19,430 --> 01:37:21,200
检查它是否是空格 

1784
01:37:21,200 --> 01:37:25,460
您可以假设它是一个空格 而我实际上认为我的代码可以做到这一点 

1785
01:37:25,460 --> 01:37:28,790
我不是百分之百确定我的头顶 

1786
01:37:28,790 --> 01:37:29,840
我们可以查一查 看看 

1787
01:37:35,882 --> 01:37:37,840
我想它就在下面 

1788
01:37:37,840 --> 01:37:38,920
不是吗？

1789
01:37:38,920 --> 01:37:39,420
是吗?

1790
01:37:42,260 --> 01:37:48,920
哦 不 我想是在落地砖店 是177线 

1791
01:37:48,920 --> 01:37:54,890
因此 对于1到8英寸x 我们保留一个空格 

1792
01:37:54,890 --> 01:37:57,617
所以Spacey 我们把它设为零 因为这只是一个变量 

1793
01:37:57,617 --> 01:37:58,700
我们还没有空位 

1794
01:37:58,700 --> 01:38:01,100
所以 不能为瓷砖编制索引--

1795
01:38:01,100 --> 01:38:04,910
您可以通过零来索引Lua表 但是因为它们不是缺省的 

1796
01:38:04,910 --> 01:38:09,740
我们只是把零设置成像我们的假太空旗帜一样 

1797
01:38:09,740 --> 01:38:12,170
Y得到8 从底部开始 

1798
01:38:12,170 --> 01:38:17,090
所以当y大于或等于1时 瓦片得到x的自瓦片y 

1799
01:38:17,090 --> 01:38:21,230
那样的话 它将排在第八位 

1800
01:38:21,230 --> 01:38:23,930
因此 space设置为False 但space是我们的空间

1801
01:38:23,930 --> 01:38:27,830
找到旗帜 以及我们刚才看到的瓷砖是否

1802
01:38:27,830 --> 01:38:29,360
是一个空间 

1803
01:38:29,360 --> 01:38:32,552
抱歉 不 这只是我们的太空旗帜 

1804
01:38:32,552 --> 01:38:35,010
我们检查一下 看看我们现在的位置是否有瓷砖 

1805
01:38:35,010 --> 01:38:37,370
所以请记住 一切都被设置为零 

1806
01:38:37,370 --> 01:38:41,050
所以我们可以说局部瓦片是自的 瓦片y x 

1807
01:38:41,050 --> 01:38:42,910
如果那里没有瓷砖 这将是零 

1808
01:38:42,910 --> 01:38:49,450
所以如果平铺 这意味着如果它不是零 如果它等于某个东西 x的空格

1809
01:38:49,450 --> 01:38:52,240
将与那块瓷砖持平 

1810
01:38:52,240 --> 01:38:56,230
我们保留了对Spacey的引用 这是我们最后的空间 

1811
01:38:56,230 --> 01:39:03,340
我们将tile.gridY设置为Spacey 因为我们必须将其重置为Gridy 

1812
01:39:03,340 --> 01:39:04,620
我们将在这里讨论这个问题 

1813
01:39:04,620 --> 01:39:07,720
这就是我们实际上如何得到跌倒、补丁的行为 

1814
01:39:07,720 --> 01:39:12,070
我们将在y到tile.GridY减去1乘以32之间 

1815
01:39:12,070 --> 01:39:19,970
回想一下 因为坐标是从零开始的 但是Lua表是1索引的 

1816
01:39:19,970 --> 01:39:25,745
空格是假的 y是Spacey 然后Spacey得零 

1817
01:39:28,390 --> 01:39:32,050
基本上 我们将从--开始

1818
01:39:32,050 --> 01:39:37,360
我们要把Spacey放在瓷砖上 然后我们

1819
01:39:37,360 --> 01:39:41,980
将Spacey设置为0 

1820
01:39:41,980 --> 01:39:46,780
我认为它实际上是这样做的 在这种情况下 它实际上是在检查瓷砖

1821
01:39:46,780 --> 01:39:49,160
以确保它是--

1822
01:39:49,160 --> 01:39:52,086
是的 因为它刚刚被设置到瓷砖上--

1823
01:39:52,086 --> 01:39:54,460
Spacey是我们刚刚更换的瓷砖 只是放在

1824
01:39:54,460 --> 01:39:55,660
变成了一个真实的地点 

1825
01:39:55,660 --> 01:39:58,701
所以它确实在上面做了检查 看看这是不是一个空格

1826
01:39:58,701 --> 01:40:00,220
或者不去 

1827
01:40:00,220 --> 01:40:04,050
但实际上只有一个需要注意的地方--

1828
01:40:04,050 --> 01:40:05,550
实际上 不 那不是真的 

1829
01:40:05,550 --> 01:40:07,841
我想说的是 如果你在屏幕的顶端 

1830
01:40:07,841 --> 01:40:12,850
但不是因为我们不可能站在屏幕的顶端 

1831
01:40:12,850 --> 01:40:17,590
而且--是的 我觉得这行不通 

1832
01:40:17,590 --> 01:40:20,710
您可以做的一个小优化就是假设总是有一个空格 

1833
01:40:20,710 --> 01:40:21,209
嗯 

1834
01:40:24,580 --> 01:40:26,980
这就是坚果壳里掉落的瓷砖 

1835
01:40:26,980 --> 01:40:30,460
或者至少是那些从重力中坠落的物体 

1836
01:40:30,460 --> 01:40:35,020
然后我们也有我们想要添加的瓷砖来取代它们 

1837
01:40:35,020 --> 01:40:38,240
我们会在这里看到这一点 

1838
01:40:38,240 --> 01:40:39,790
所以这个代码 

1839
01:40:39,790 --> 01:40:44,310
所以我们需要做的是取代--

1840
01:40:44,310 --> 01:40:47,868
你们认为我们需要做些什么来更换瓷砖？

1841
01:40:52,708 --> 01:40:56,580
观众：检查回应 检查是否为空 [INAUDIBLE]

1842
01:40:56,580 --> 01:40:58,709
但如果不是 那你就完了 

1843
01:40:58,709 --> 01:40:59,750
演讲者1：是的 没错 

1844
01:40:59,750 --> 01:41:03,050
因此 从顶层查看了响应

1845
01:41:03,050 --> 01:41:06,830
如果有空的瓷砖 如果有 

1846
01:41:06,830 --> 01:41:11,360
然后产生一些瓷砖 然后理想情况下 将它们补间到它们的新位置 

1847
01:41:11,360 --> 01:41:15,419
您基本上可以在这里将它们赋给它们的值 

1848
01:41:15,419 --> 01:41:17,210
所以我们需要做的是 实际上 

1849
01:41:17,210 --> 01:41:21,920
如果我们在这里生产一块瓷砖放在这些位置中的任何一个 他们的Gridy

1850
01:41:21,920 --> 01:41:23,690
需要提前设置 因为它们是

1851
01:41:23,690 --> 01:41:25,740
无论如何都要占据那个空间 

1852
01:41:25,740 --> 01:41:31,490
他们的实际y位置需要调整 

1853
01:41:31,490 --> 01:41:35,150
所以因为x和y与Gridy和GridX是分开的 

1854
01:41:35,150 --> 01:41:38,692
这些只是表索引 而不是它们的坐标 

1855
01:41:38,692 --> 01:41:40,400
我们可以在它们之间加补丁 但实际上不会

1856
01:41:40,400 --> 01:41:41,983
对数据结构有任何影响 

1857
01:41:41,983 --> 01:41:46,070
数据结构本身可以维护--我们仍然可以使用数据结构--

1858
01:41:46,070 --> 01:41:48,350
把一块瓷砖放在我们桌子上的正确位置 

1859
01:41:48,350 --> 01:41:53,667
然后给它正确的GridX和Gridy 但要介于x和y之间 

1860
01:41:53,667 --> 01:41:55,250
我们可以用这些钱做任何我们想做的事 

1861
01:41:55,250 --> 01:41:58,220
我们可以让他们旋转 和东西一样长

1862
01:41:58,220 --> 01:42:01,430
因为数据结构是完好无损的 理想情况下 

1863
01:42:01,430 --> 01:42:04,100
只要我们不能在它移动的时候输入 

1864
01:42:04,100 --> 01:42:06,770
诸如此类的东西 因为这可能会产生一些视觉上的错误 

1865
01:42:06,770 --> 01:42:10,670
因此 我们所做的实际上是在交换发生时禁用输入 

1866
01:42:10,670 --> 01:42:14,240
您将在分发代码中看到这一点 

1867
01:42:14,240 --> 01:42:16,880
但是的 数一数有多少空位 

1868
01:42:16,880 --> 01:42:19,670
产生四个瓦片 产生两个瓦片 产生两个瓦片

1869
01:42:19,670 --> 01:42:24,110
产生四个已经被赋予了正确的GRIDX的瓷砖 格里迪 

1870
01:42:24,110 --> 01:42:27,170
然后就在他们的y到它需要去的地方之间 

1871
01:42:27,170 --> 01:42:30,580
这是格里迪的32倍

1872
01:42:30,580 --> 01:42:33,110
格里迪减去1乘32 

1873
01:42:33,110 --> 01:42:34,610
这就是我们在这里做的事情 

1874
01:42:34,610 --> 01:42:39,980
我们只是在数 然后砰的一声 

1875
01:42:39,980 --> 01:42:43,624
这是我把这部剧组合在一起最喜欢的部分 

1876
01:42:43,624 --> 01:42:46,790
因此 我们将用几分钟的时间来谈论精灵 

1877
01:42:46,790 --> 01:42:50,164
和调色板 但我认为有一件事--

1878
01:42:50,164 --> 01:42:51,080
一秒钟的空白 

1879
01:42:51,080 --> 01:42:53,600
我还想说最后一件事 

1880
01:42:53,600 --> 01:42:57,590
让我看看我能不能搞清楚那是什么 

1881
01:42:57,590 --> 01:43:02,960
哦 对了 所以在黑板上--

1882
01:43:02,960 --> 01:43:08,360
对不起 在播放状态下 我相信这就是它的位置 有一个功能 

1883
01:43:12,460 --> 01:43:15,980
所以Play State基本上有它自己的计算匹配 

1884
01:43:15,980 --> 01:43:17,360
它在那里等着你--

1885
01:43:17,360 --> 01:43:20,690
一旦你基本上交换了任何两块瓷砖 

1886
01:43:20,690 --> 01:43:23,390
它将计算这些瓷砖是否匹配 

1887
01:43:26,150 --> 01:43:29,480
我们将通过自己的黑板计算匹配来获得匹配 

1888
01:43:29,480 --> 01:43:31,520
我们之前看到的函数 

1889
01:43:31,520 --> 01:43:32,810
如果有匹配的--

1890
01:43:32,810 --> 01:43:35,609
嗯 我们这里每场比赛都有音效 

1891
01:43:35,609 --> 01:43:37,400
这也是计算分数的地方 

1892
01:43:37,400 --> 01:43:41,312
你只需将一场比赛中的瓷砖数量乘以50 

1893
01:43:41,312 --> 01:43:43,880
任务的一部分将是增加一些价值

1894
01:43:43,880 --> 01:43:45,890
不同种类的瓷砖 

1895
01:43:48,890 --> 01:43:52,190
在这里 我们在一起 

1896
01:43:52,190 --> 01:43:58,220
所以我们也从董事会班回来了一张桌子

1897
01:43:58,220 --> 01:44:02,810
对于我们刚刚催生的所有新瓷砖 

1898
01:44:02,810 --> 01:44:07,740
所以我们最终要做的就是把它们都补齐 

1899
01:44:07,740 --> 01:44:10,100
所以请注意 我们传入了一个计时器 tweet 

1900
01:44:10,100 --> 01:44:11,870
该变量为tilesToFall 

1901
01:44:11,870 --> 01:44:15,650
这是一个定义文件 我们刚刚从我们的董事会班上返回 

1902
01:44:15,650 --> 01:44:21,950
一旦所有这些都完成了 我们就会得到新的瓷砖 

1903
01:44:21,950 --> 01:44:25,620
然后我们在这里相聚 

1904
01:44:25,620 --> 01:44:28,074
事实上 我认为这条线路是多余的 

1905
01:44:28,074 --> 01:44:29,990
我认为这可能是一条调试线 

1906
01:44:29,990 --> 01:44:31,220
我不认为我们需要这个 

1907
01:44:33,750 --> 01:44:35,000
不 我们根本不需要这个 

1908
01:44:35,000 --> 01:44:36,650
真的很抱歉 

1909
01:44:36,650 --> 01:44:39,260
这是最重要的部分 

1910
01:44:39,260 --> 01:44:41,720
我们要去青春节--

1911
01:44:41,720 --> 01:44:42,560
等等 我们确实需要它 

1912
01:44:42,560 --> 01:44:45,480
Self.board获取NewTiles 

1913
01:44:45,480 --> 01:44:47,338
我在想什么呢？

1914
01:44:53,570 --> 01:44:55,320
抱歉 我有点困惑 

1915
01:44:55,320 --> 01:44:58,012
我以为这是我定义的一个空函数 

1916
01:44:58,012 --> 01:44:59,970
买新的瓷砖 

1917
01:44:59,970 --> 01:45:02,770
是的 这会返回一个空桌子 

1918
01:45:02,770 --> 01:45:06,940
但从根本上说 它的主旨是剧本

1919
01:45:06,940 --> 01:45:13,485
状态 当它调用此函数时 它每次都会调用自身 

1920
01:45:15,884 --> 01:45:18,300
我认为这实际上是在产生这样做的结果

1921
01:45:18,300 --> 01:45:20,591
马上就到了 因为新Tiles只是一张空桌子 

1922
01:45:20,591 --> 01:45:28,620
我认为这一切都应该是这样的 这一切都是这样的 

1923
01:45:28,620 --> 01:45:31,980
但这样做的结果是 它再次自称

1924
01:45:31,980 --> 01:45:35,520
因为当我们从屏幕顶部获得新的磁贴时 

1925
01:45:35,520 --> 01:45:40,170
我们可能会有一个案子 我们找到一些匹配的 

1926
01:45:40,170 --> 01:45:45,090
这里没有显示 但新落下的瓷砖可能会给我们带来新的火柴 

1927
01:45:45,090 --> 01:45:48,840
所以在我们计算了匹配后 假设这块瓷砖掉在了这里 

1928
01:45:48,840 --> 01:45:51,135
但它是紫色的 而这两个人已经在那里了 

1929
01:45:51,135 --> 01:45:53,010
我们已经计算了匹配 但后来我们

1930
01:45:53,010 --> 01:45:56,690
需要再做一次 如果它继续发生 就再做一次 

1931
01:45:56,690 --> 01:45:59,790
因此您应该递归地调用Self CalculateMatches

1932
01:45:59,790 --> 01:46:06,510
在这种情况下 这将具有实现这一点的效果 因为这

1933
01:46:06,510 --> 01:46:07,980
会一直寻找匹配的对象 

1934
01:46:07,980 --> 01:46:11,580
因此 当我们在这里调用Self CalculateMatches时 一遍又一遍

1935
01:46:11,580 --> 01:46:14,096
再说一次 直到没有匹配--

1936
01:46:14,096 --> 01:46:16,470
只要有比赛 这种情况就应该继续发生 

1937
01:46:16,470 --> 01:46:19,980
你应该不断地得分 瓷砖应该不断地被清除 

1938
01:46:19,980 --> 01:46:22,470
但一旦情况不再是这样 

1939
01:46:22,470 --> 01:46:27,005
则self.canInput等于真 我们不再计算匹配项 

1940
01:46:27,005 --> 01:46:29,630
我们不再递归地调用该函数 我们就完成了 

1941
01:46:29,630 --> 01:46:31,230
这就是我想要说明的观点 

1942
01:46:31,230 --> 01:46:34,500
我想 我对我的旧代码的遗迹感到有点困惑 

1943
01:46:34,500 --> 01:46:37,109
也许我是在尝试什么 但我认为 最终 

1944
01:46:37,109 --> 01:46:39,900
应该是这样的 我会测试它 并确保 然后按

1945
01:46:39,900 --> 01:46:40,410
这一变化 

1946
01:46:42,960 --> 01:46:44,972
它不需要超过0.25秒 

1947
01:46:44,972 --> 01:46:45,930
它可以是瞬间的 

1948
01:46:48,102 --> 01:46:50,560
调色板 非常快 有一些我想要涵盖的东西 

1949
01:46:50,560 --> 01:46:53,606
这只是一个想法 把艺术 然后--和我

1950
01:46:53,606 --> 01:46:55,230
有几个很酷的例子可以展示 

1951
01:46:55,230 --> 01:46:58,080
只是拍了一些照片 然后给它--

1952
01:46:58,080 --> 01:47:03,060
仅使用或某种类型的图像 并且仅使用32 在本例中 

1953
01:47:03,060 --> 01:47:05,160
或者一些任意数量的颜色 

1954
01:47:05,160 --> 01:47:09,390
这是一个叫DawnBringer Online的人做的一些奇特的东西 

1955
01:47:09,390 --> 01:47:13,170
他生成了一个非常著名的32色调色板 名为DawnBringer的32色

1956
01:47:13,170 --> 01:47:14,760
调色板 

1957
01:47:14,760 --> 01:47:16,380
但基本上 它允许--

1958
01:47:16,380 --> 01:47:18,990
这是用我们在屏幕上看到的32种颜色完成的 

1959
01:47:18,990 --> 01:47:21,750
这些都是摇摆不定的 

1960
01:47:21,750 --> 01:47:27,120
抖动是一个术语 意思是逐个像素地绘制两种颜色 

1961
01:47:27,120 --> 01:47:31,590
交错 所以从远处看它就像是一种全新的颜色 

1962
01:47:31,590 --> 01:47:32,880
这是一张抖动图 

1963
01:47:32,880 --> 01:47:35,550
这只是向你展示了最上面的每种颜色 

1964
01:47:35,550 --> 01:47:37,570
这些都是32种颜色 

1965
01:47:37,570 --> 01:47:42,420
这些是32个 而那些是彼此相交的32个

1966
01:47:42,420 --> 01:47:45,030
他们就像圆点 圆点 

1967
01:47:45,030 --> 01:47:47,027
每一个点都是另一个颜色 

1968
01:47:47,027 --> 01:47:49,860
所以你可以用几种颜色做一些令人惊叹的事情 

1969
01:47:49,860 --> 01:47:52,140
这实际上是用16种颜色来完成的 

1970
01:47:52,140 --> 01:47:56,940
这四种颜色都只有16种 

1971
01:47:56,940 --> 01:48:00,500
这只是为了向您展示当您对实际图像执行此操作时它看起来是什么样子 

1972
01:48:00,500 --> 01:48:04,159
这是一个在图像上使用调色板的示例

1973
01:48:04,159 --> 01:48:05,700
看起来效果不是很好 

1974
01:48:05,700 --> 01:48:07,533
所以这是一张规则的图像 我不知道

1975
01:48:07,533 --> 01:48:10,080
有多少种颜色 几百万种颜色 还有这个

1976
01:48:10,080 --> 01:48:12,760
正在使用DawnBringer的32色调色板 

1977
01:48:12,760 --> 01:48:15,390
因此 它看起来仍然与应有的非常相似 

1978
01:48:15,390 --> 01:48:19,800
这是一只猫 但背景里有很多奇怪的事情

1979
01:48:19,800 --> 01:48:24,240
因为拍摄一张有很多模糊和大量扭曲色彩的图像 

1980
01:48:24,240 --> 01:48:28,230
有这样的效果 当你倒下的时候 你会看到斑点图案

1981
01:48:28,230 --> 01:48:30,640
几种颜色 

1982
01:48:30,640 --> 01:48:34,807
但这是一个图像的例子 它有很多更平坦的颜色 

1983
01:48:34,807 --> 01:48:36,640
这张图片中仍然有很多颜色 

1984
01:48:36,640 --> 01:48:40,800
有一些色调 诸如此类的东西 但这是成千上万种颜色 

1985
01:48:40,800 --> 01:48:42,490
这是32种颜色 

1986
01:48:42,490 --> 01:48:45,509
所以很明显 如果你做了正确的事情 

1987
01:48:45,509 --> 01:48:47,550
实际上 你可以用它获得非常好的效果 

1988
01:48:47,550 --> 01:48:52,004
所以再一次 没有太大的区别 但这一次

1989
01:48:52,004 --> 01:48:54,420
我不知道有多少几十万种颜色 

1990
01:48:54,420 --> 01:48:57,450
而这一张只有32张 

1991
01:48:57,450 --> 01:49:00,150
所以它是如何与我们正在做的事情联系起来的

1992
01:49:00,150 --> 01:49:06,910
这是故意使用32位颜色还是32色调色板 

1993
01:49:06,910 --> 01:49:09,060
这实际上是DawnBringer的32色调色板 

1994
01:49:09,060 --> 01:49:12,510
Breakout使用相同的调色板 32种颜色 

1995
01:49:12,510 --> 01:49:17,770
我们未来的许多2D课程将使用有限的调色板 

1996
01:49:17,770 --> 01:49:22,890
如果你正在尝试画精灵艺术 并且你想要一些快速 简单的方法

1997
01:49:22,890 --> 01:49:26,100
为了给你的工作带来一点一致性 

1998
01:49:26,100 --> 01:49:30,180
我建议试着挑选8、16或32种颜色 

1999
01:49:30,180 --> 01:49:32,570
而只是坚持只使用这些 

2000
01:49:32,570 --> 01:49:35,580
你会惊讶于你从中得到了多少

2001
01:49:35,580 --> 01:49:39,240
以及你的工作看起来会有多有凝聚力

2002
01:49:39,240 --> 01:49:41,200
通过把这个限制强加给你 

2003
01:49:41,200 --> 01:49:46,170
它是前硬件现实世界约束下的产物 

2004
01:49:46,170 --> 01:49:48,720
NES只有那么多颜色可以给每个精灵上色 

2005
01:49:48,720 --> 01:49:51,570
比如四种颜色 或者类似的东西 

2006
01:49:51,570 --> 01:49:55,530
所以你也会得到一个--如果你想要一个真正的复古造型 

2007
01:49:55,530 --> 01:49:56,920
从这个意义上说 它会对你有所帮助 

2008
01:49:56,920 --> 01:49:59,580
然后不同于调色板 但相关

2009
01:49:59,580 --> 01:50:02,550
调色板互换 这是你可能听说过的另一个术语 

2010
01:50:02,550 --> 01:50:05,295
基本上就是所有这些马里奥精灵--

2011
01:50:07,950 --> 01:50:12,600
他们可能会从灰度级的马里奥开始 有些像灰色版本

2012
01:50:12,600 --> 01:50:15,990
其中每一种不同的颜色都被绘制出来

2013
01:50:15,990 --> 01:50:20,430
一张等于红色 两张等于蓝色 或者其他什么的桌子 

2014
01:50:20,430 --> 01:50:23,340
然后你可以把它们全部移开 然后你

2015
01:50:23,340 --> 01:50:25,470
得到所有这些不同的美好效果 假设

2016
01:50:25,470 --> 01:50:30,690
你创造了一个很好的调色板 

2017
01:50:30,690 --> 01:50:33,480
你可以得到大量的重复使用 这实际上是

2018
01:50:33,480 --> 01:50:38,310
超级马里奥兄弟过去是如何制作一些节目的 

2019
01:50:38,310 --> 01:50:41,310
云朵和灌木丛是同一个精灵 

2020
01:50:41,310 --> 01:50:42,960
其中一个只是涂成了绿色 

2021
01:50:42,960 --> 01:50:48,780
它的调色板从白色变成了绿色 那就是云是彩色的 

2022
01:50:48,780 --> 01:50:51,830
这就是第三场比赛的要点 

2023
01:50:51,830 --> 01:50:54,150
作业3会有几个部分 

2024
01:50:54,150 --> 01:50:55,740
所以在比赛中增加时间 

2025
01:50:55,740 --> 01:50:58,800
因此 当你得到一个匹配 你应该得到时间增加到时钟 

2026
01:50:58,800 --> 01:51:01,290
目前 你只有60秒的时间 

2027
01:51:01,290 --> 01:51:05,130
在这一点上 要真正通过第二级是有点困难的 

2028
01:51:05,130 --> 01:51:08,880
所以比赛中的每一块瓷砖都能得到积分 

2029
01:51:08,880 --> 01:51:11,490
让它成为第一级从简单的扁平积木开始 

2030
01:51:11,490 --> 01:51:14,580
早些时候 我们看到了瓷砖阵列 它

2031
01:51:14,580 --> 01:51:18,625
在每个颜色行的第一个索引上都是扁平的瓷砖 

2032
01:51:18,625 --> 01:51:21,750
但还有其他几种图案 比如x 圆圈和三角形 

2033
01:51:21,750 --> 01:51:22,410
诸如此类的 

2034
01:51:22,410 --> 01:51:27,780
让那些价值更高的东西 每一件都有价值 

2035
01:51:27,780 --> 01:51:31,324
创建随机的闪闪发光的块变体 在以下情况下将销毁整行

2036
01:51:31,324 --> 01:51:31,990
你会得到一个匹配的 

2037
01:51:31,990 --> 01:51:32,930
所以 来个街区吧 

2038
01:51:32,930 --> 01:51:35,160
它应该有一些领域 闪闪发光或什么的 

2039
01:51:35,160 --> 01:51:38,310
如果它很有光泽 就用一些东西来渲染它 让它看起来很有光泽 

2040
01:51:38,310 --> 01:51:41,370
如果需要 可以使用粒子效果 

2041
01:51:41,370 --> 01:51:48,000
你可以把一个很不透明的 或者一个很透明的 可能发黄或发白

2042
01:51:48,000 --> 01:51:50,430
长方形在上面 让它看起来更明亮 

2043
01:51:50,430 --> 01:51:53,820
如果它在匹配中 那么整排

2044
01:51:53,820 --> 01:51:58,312
应该清白而不只是那场比赛 

2045
01:51:58,312 --> 01:52:00,270
仅当结果匹配时才允许交换 

2046
01:52:00,270 --> 01:52:03,150
这是一件重要的事情 因为现在 从数学上讲 

2047
01:52:03,150 --> 01:52:05,850
实际上 你不太可能得到一块

2048
01:52:05,850 --> 01:52:10,660
一开始就有火柴 

2049
01:52:10,660 --> 01:52:16,350
因此 您将不得不在您的实现中选择瓷砖的子集 

2050
01:52:16,350 --> 01:52:20,250
并实际使用它们 而不是全部使用它们 

2051
01:52:20,250 --> 01:52:25,470
挑选六块瓷砖 你可以在上面贴上各种不同的瓷砖 或者随便什么

2052
01:52:25,470 --> 01:52:28,920
颜色 然后只使用这些来产卵您的板 

2053
01:52:28,920 --> 01:52:32,600
不要用掉所有的18个 或者不管有多少个 

2054
01:52:32,600 --> 01:52:35,520
然后是可选的 如果你好奇 如果你想 很可能 

2055
01:52:35,520 --> 01:52:38,250
这款游戏可以说是更好的游戏体验 

2056
01:52:38,250 --> 01:52:41,490
只要实现真正玩鼠标就行了 

2057
01:52:41,490 --> 01:52:44,880
能够点击并拖动 或者只需点击单个磁贴 

2058
01:52:44,880 --> 01:52:47,220
要做到这一点 你需要转换--

2059
01:52:47,220 --> 01:52:49,620
因为我们使用推送库进行虚拟解析 

2060
01:52:49,620 --> 01:52:53,340
您需要转换窗口鼠标坐标

2061
01:52:53,340 --> 01:52:56,584
来推动坐标 这样它们就会适当地映射到游戏空间中 

2062
01:52:56,584 --> 01:52:58,875
因此 您将使用一个名为Push to Game的函数 其中

2063
01:52:58,875 --> 01:53:03,780
它需要x和y 其中x和y将是您的鼠标坐标 

2064
01:53:03,780 --> 01:53:06,450
下一次 我们实际上会进入一个

2065
01:53:06,450 --> 01:53:11,880
更健壮的游戏 可以说 就像马里奥的克隆体 

2066
01:53:11,880 --> 01:53:14,910
本课程实际上就是从这里开始的

2067
01:53:14,910 --> 01:53:16,920
我是不是教过一个关于超级马里奥兄弟的研讨会 

2068
01:53:16,920 --> 01:53:20,186
我们不会因为版权的原因而使用超级马里奥兄弟的资产 

2069
01:53:20,186 --> 01:53:22,810
但我们将在这里使用这块瓷砖 它非常相似 

2070
01:53:22,810 --> 01:53:23,950
它有一种很好的美感 

2071
01:53:23,950 --> 01:53:25,230
我们将介绍瓷砖地图 

2072
01:53:25,230 --> 01:53:27,990
那么如何使用单独的瓷砖来生成关卡 

2073
01:53:27,990 --> 01:53:30,187
2D动画 所以不只是喜欢静态的东西

2074
01:53:30,187 --> 01:53:33,270
到目前为止我们一直在做的是 你会有真正会走路的角色 

2075
01:53:33,270 --> 01:53:35,241
跳起来 做不同的事情 

2076
01:53:35,241 --> 01:53:36,990
我们将讨论如何实际操作

2077
01:53:36,990 --> 01:53:40,710
生成平台级别 这并不是特别困难 

2078
01:53:40,710 --> 01:53:43,630
这听起来有点难 但实际上很漂亮--

2079
01:53:43,630 --> 01:53:46,650
对于非常简单的事情来说 这并不是太糟糕 

2080
01:53:46,650 --> 01:53:49,097
基本的平台物理学 所以击球 跳跃 

2081
01:53:49,097 --> 01:53:49,930
诸如此类的事情 

2082
01:53:49,930 --> 01:53:54,780
事实上 我们已经在Flappy Bird中讲述了很多这一点 实际上 

2083
01:53:54,780 --> 01:53:57,890
《越狱》中的砖块有点搭在一起 

2084
01:53:57,890 --> 01:54:01,890
伤害盒子 这样我们就可以有伤害你的敌人 反之亦然 

2085
01:54:01,890 --> 01:54:05,100
并通电 这样你就可以以某种方式改变你的状态 让你

2086
01:54:05,100 --> 01:54:07,620
更大 或所向披靡 或诸如此类 

2087
01:54:07,620 --> 01:54:08,520
那是第三场比赛 

2088
01:54:08,520 --> 01:54:11,270
非常感谢 下次再见 

