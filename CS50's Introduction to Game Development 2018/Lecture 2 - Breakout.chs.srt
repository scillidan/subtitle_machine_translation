1
00:00:00,000 --> 00:00:03,479
[音乐播放]
[MUSIC PLAYING]

2
00:00:16,999 --> 00:00:18,290
科尔顿·奥格登：大家好 
COLTON OGDEN: Hello, everybody.

3
00:00:18,290 --> 00:00:20,530
欢迎来到GD50第二讲 
Welcome to GD50 Lecture 2.

4
00:00:20,530 --> 00:00:22,300
这里是越狱频道 
This is Breakout.

5
00:00:22,300 --> 00:00:25,225
有趣的是 CS50与Breakout有渊源 
And interestingly, CS50 has a history with Breakout,

6
00:00:25,225 --> 00:00:26,680
所以我今天调出了这个 
so I pulled this up today.

7
00:00:26,680 --> 00:00:30,700
这是2015、2014年的Pset3 
This is Pset3 in 2015, 2014.

8
00:00:30,700 --> 00:00:34,960
它是使用斯坦福便携的Breakout的实现
It was an implementation of Breakout using the Stanford Portable

9
00:00:34,960 --> 00:00:37,150
库 这是一种Java库
Library, which was a sort of Java library

10
00:00:37,150 --> 00:00:40,450
我们能够为其获得C绑定 
that we were able to get C bindings for.

11
00:00:40,450 --> 00:00:42,430
因此 学生们能够实际实施
And so students were able to actually implement

12
00:00:42,430 --> 00:00:48,040
这是一款当时还是CS50设备的游戏 是一个Linux发行版 
a game what was at the time the CS50 appliance, which is a Linux distro.

13
00:00:48,040 --> 00:00:49,870
但我只想说 那是--
But suffice to say that was--

14
00:00:49,870 --> 00:00:51,280
哦 这也是个有趣的故事 
oh, a funny story also.

15
00:00:51,280 --> 00:00:56,570
我碰巧也为这个实现编写了激光程序 
I happened to also write the lasers for this implementation back in the day.

16
00:00:56,570 --> 00:00:59,260
我认为这是最早的代码之一
And I think that was one of the first bits of code

17
00:00:59,260 --> 00:01:02,380
我在使用CS50的时候弄脏了自己的手 
I got my hands dirty with when working with CS50.

18
00:01:02,380 --> 00:01:04,919
所以今天在突破的背景下 我们将
So today in the context of Breakout, we'll

19
00:01:04,919 --> 00:01:07,960
谈论一些我们还没有谈论过的不同的事情 
be talking about a few different things that we haven't talked about yet.

20
00:01:07,960 --> 00:01:10,600
其中最有可能的是雪碧薄片 
Sprite sheets being chief among them most likely.

21
00:01:10,600 --> 00:01:12,130
至少最明显的是这样 
At least the most visibly so.

22
00:01:12,130 --> 00:01:15,370
因此 精灵纸只是一种拍摄图像的方式 一张大图像 
So sprite sheets are simply a way of taking an image, a large image,

23
00:01:15,370 --> 00:01:19,210
而不是拆分 而不是加载单独的图像
and rather than splitting it, rather than loading individual images

24
00:01:19,210 --> 00:01:21,260
对于你在游戏中的所有不同的东西 
for all of your different things in the game,

25
00:01:21,260 --> 00:01:25,990
不管是你的外星人还是你的球拍什么的 你可以把所有东西
whether it's your aliens or your paddles or whatnot, you can put everything

26
00:01:25,990 --> 00:01:30,080
放入一张表中 然后使用矩形对该表进行索引 
into one sheet and then just sort of index into that sheet using rectangles,

27
00:01:30,080 --> 00:01:30,580
四人组 
quads.

28
00:01:30,580 --> 00:01:31,535
我们很快就会谈到 
We'll talk about soon.

29
00:01:31,535 --> 00:01:33,910
这将允许您只绘制该图像的子集 
Which will allow you to just draw a subset of that image,

30
00:01:33,910 --> 00:01:37,930
并因此将您的所有图稿压缩到一个文件中 
and therefore condense all of your artwork just into one piece, one file.

31
00:01:37,930 --> 00:01:41,020
我们将更多地讨论程序生成
We'll be talking a little bit more about procedural generation

32
00:01:41,020 --> 00:01:42,580
在越狱的背景下 
in the context of Breakout.

33
00:01:42,580 --> 00:01:45,680
在这种情况下 我们将在游戏世界中铺设所有的砖
And in this case, we'll be laying out all the bricks in the game world

34
00:01:45,680 --> 00:01:46,240
从程序上讲 
procedurally.

35
00:01:46,240 --> 00:01:50,480
因此 在这种情况下 不是使用相同的颜色集 
So having instead of the same set of colors, in this case,

36
00:01:50,480 --> 00:01:55,510
标准的布局是一排一排地放一堆相同颜色的砖 
the standard layout is to have a bunch of the same colored bricks row by row.

37
00:01:55,510 --> 00:01:58,702
我们实际上将实现一种动态生成方法
We'll actually implement a dynamic generation approach

38
00:01:58,702 --> 00:02:00,910
并有一堆不同的酷布局 我们将看到 
and have a bunch of different cool layouts we'll see.

39
00:02:00,910 --> 00:02:04,810
实际上很容易就能得到可信的结果 
And it's actually quite simple to achieve pretty believable results.

40
00:02:04,810 --> 00:02:07,100
我们会在这场比赛中更好地管理状态 
We'll manage state a little bit better in this game.

41
00:02:07,100 --> 00:02:10,479
在我们有一些全局变量之前
So before we sort of had a couple of global variables

42
00:02:10,479 --> 00:02:14,320
我们并没有每个州或全球州的概念
and we didn't really have the concept of a per state or a global state

43
00:02:14,320 --> 00:02:18,310
在我们所有的州之间 
that we were cleanly sort of sharing between all of our states

44
00:02:18,310 --> 00:02:19,510
我们的国家机器 
for our state machine.

45
00:02:19,510 --> 00:02:22,552
但为了避免有一种污染的全球名称空间 
But to avoid having sort of like a polluted global name space

46
00:02:22,552 --> 00:02:24,760
为了让事情变得更干净
and to just sort of keep things a little bit cleaner,

47
00:02:24,760 --> 00:02:28,051
我们最终会把所有重要的变量都作为我们的代码 你知道 
we'll end up taking all of the important variables for our code like, you know,

48
00:02:28,051 --> 00:02:29,770
玩家和任何其他实体 
the player and any other entities.

49
00:02:29,770 --> 00:02:30,940
砖块球
The bricks, the ball.

50
00:02:30,940 --> 00:02:33,064
而不是让他们在我们的主要[听不见] 
And rather than keep them in our main [INAUDIBLE],,

51
00:02:33,064 --> 00:02:34,410
我们最终会转移他们
we'll end up shifting them.

52
00:02:34,410 --> 00:02:37,990
我们会把他们从不同的州转移到不同的州
We'll sort of transfer them to and from the different states

53
00:02:37,990 --> 00:02:41,366
通过状态机的enter方法 
via the state machine's enter method.

54
00:02:41,366 --> 00:02:42,490
实际上我们会有水平 
We'll actually have levels.

55
00:02:42,490 --> 00:02:43,780
这是一个渐进系统 
So a progression system.

56
00:02:43,780 --> 00:02:45,650
从第一层开始 往上走 
So start at level one, go up.

57
00:02:45,650 --> 00:02:48,730
然后在每一个级别上 我们将实现一个规模
And then with each level, we'll implement a scale

58
00:02:48,730 --> 00:02:51,730
在砖块的生成方面 
in terms of the generation of the bricks.

59
00:02:51,730 --> 00:02:54,545
因此 我们将得到更高层次的砖和更多的点作为一个结果 
So we'll get higher tiered bricks and more points as a result.

60
00:02:54,545 --> 00:02:55,670
我们会有一个健康系统 
We'll have a health system.

61
00:02:55,670 --> 00:02:58,780
《心》与《塞尔达传说》相似 
So hearts, in a similar fashion to Legend of Zelda.

62
00:02:58,780 --> 00:03:02,380
粒子系统 这是一个非常重要的美学组成部分
Particle systems, which are a very important aesthetic component

63
00:03:02,380 --> 00:03:04,720
2D游戏和3D游戏 
to 2D games and 3D games.

64
00:03:04,720 --> 00:03:07,720
粒子系统基本上是一堆产生的图像
Particle systems basically being a bunch of spawned images

65
00:03:07,720 --> 00:03:10,720
你可以把它们聚在一起 放进一个小产卵器里 
that you sort of cluster, you put into a little spawner,

66
00:03:10,720 --> 00:03:15,190
以某种方式发射它们 给它们上色 对它们进行数学运算 
emit them in a certain way, and color them, perform math on them,

67
00:03:15,190 --> 00:03:17,462
并得到一些可信的效果 比如火和烟
and get sort of believable effects like fire and smoke

68
00:03:17,462 --> 00:03:19,420
以及所有其他的事情 
and all these other things that would otherwise

69
00:03:19,420 --> 00:03:24,040
使用简单的动画并不容易 
be not easy to do using simple animation,

70
00:03:24,040 --> 00:03:26,980
但对粒子系统来说微不足道
but trivial with a particle system.

71
00:03:26,980 --> 00:03:31,060
我们会用球拍做一个更复杂的碰撞检测
We'll do a little bit more complicated collision detection with our paddle

72
00:03:31,060 --> 00:03:33,132
比我们和乒乓的关系要好得多
and with our bricks than we did with Pong.

73
00:03:33,132 --> 00:03:34,840
最后我们还会讨论
And then we'll also talk lastly about how

74
00:03:34,840 --> 00:03:38,950
我们可以将数据本地保存到我们的计算机上 这样当我们关闭应用程序时 
we can save data locally to our computer so that when we close the application

75
00:03:38,950 --> 00:03:42,460
再运行一次 我们最终得到了一个持续的高分
and run it again, we end up having a persistent high score rather

76
00:03:42,460 --> 00:03:44,980
而不仅仅是一些不稳定的东西 
than just something that's volatile.

77
00:03:44,980 --> 00:03:49,300
所以首先 我想演示一下今天完成的游戏 
So first though, I would like to demo today's finished game.

78
00:03:49,300 --> 00:03:55,260
因此 如果有人想从观众那里演示一下 那就太好了 
So if anybody would like to demo from the audience, that would be nice.

79
00:03:55,260 --> 00:03:57,311
来吧 上来吧 
Go ahead and come up.

80
00:03:57,311 --> 00:03:58,810
我先走一步 为你做好准备 
I'll go ahead and cue it up for you.

81
00:04:02,652 --> 00:04:03,360
你叫什么名字？
What's your name?

82
00:04:03,360 --> 00:04:03,980
杰里米：杰里米 
JEREMY: Jeremy.

83
00:04:03,980 --> 00:04:04,330
科尔顿·奥格登：杰里米 
COLTON OGDEN: Jeremy.

84
00:04:04,330 --> 00:04:04,660
科尔顿 
Colton.

85
00:04:04,660 --> 00:04:05,290
杰里米：很高兴认识你 科尔顿 
JEREMY: Nice to meet you, Colton.

86
00:04:05,290 --> 00:04:06,280
科尔顿·奥格登：很高兴见到你 
COLTON OGDEN: Nice to meet you.

87
00:04:06,280 --> 00:04:08,410
因此 我们将继续在这里运行Breakout 
So we're going to go ahead and run Breakout here.

88
00:04:13,220 --> 00:04:15,462
所以它使用了箭头键 
And so it uses the arrow keys.

89
00:04:15,462 --> 00:04:17,170
所以如果你继续往上按 然后往下按 
So if you go ahead and press up and down,

90
00:04:17,170 --> 00:04:19,430
你会看到你可以在开始屏幕和高分屏幕之间移动 
you'll see you can move between the start and the high score screen.

91
00:04:19,430 --> 00:04:21,040
所以它们是两个独立的屏幕 
So they're two separate screens.

92
00:04:21,040 --> 00:04:22,392
所以去吧 然后--
So go ahead and--

93
00:04:22,392 --> 00:04:24,600
在我们这里 当你开始的时候 你可以选择一个球拍 
here we have when you start, you can choose a paddle.

94
00:04:24,600 --> 00:04:27,740
因此 你可以选择 而不是每次都是同样的老牌球拍 
So rather than just the same old paddle every time, you get to select.

95
00:04:27,740 --> 00:04:29,650
正如你在这里看到的 他选择了绿色 
And as you can see here, he chose green.

96
00:04:29,650 --> 00:04:31,000
所以他拿到了绿色球拍 
So he gets the green paddle.

97
00:04:31,000 --> 00:04:32,650
这些砖都是程序生成的 
These bricks all procedure generated.

98
00:04:32,650 --> 00:04:36,520
因此 如果他运行应用程序 它们将完全不同 
So if he runs the application, they'll be completely different.

99
00:04:36,520 --> 00:04:39,610
就像经典的公式一样 球移动
And as is the classic formula, the ball moves

100
00:04:39,610 --> 00:04:41,230
在砖头和球拍之间 
between the bricks and the paddle.

101
00:04:41,230 --> 00:04:44,060
当它击中砖块时 如果它是某种颜色的 
When it hits a brick, if it's of a certain color,

102
00:04:44,060 --> 00:04:46,840
它要么被摧毁--在这种情况下 如果它是蓝色的 
it'll either get destroyed-- in this case, if it's blue,

103
00:04:46,840 --> 00:04:48,280
这是基色砖 
it's the base color brick.

104
00:04:48,280 --> 00:04:50,590
所以这是最低的值 
So it's the lowest value.

105
00:04:50,590 --> 00:04:52,480
如果它比蓝色高 它最终会变成
And if it's higher than blue, it'll end up

106
00:04:52,480 --> 00:04:55,840
根据颜色的不同向下调整颜色 
going down a color depending on which color it is.

107
00:04:55,840 --> 00:04:58,210
我相信它会变成蓝色、绿色、红色、紫色、黄色 
I believe it goes blue, green, red, purple, yellow.

108
00:04:58,210 --> 00:05:01,600
因此 任何更高的东西都会被下移 
So anything higher will get shifted down.

109
00:05:01,600 --> 00:05:04,240
然后玩家积累分数 如你在右上角所看到的 
And then the player amasses points, as you can see top right.

110
00:05:04,240 --> 00:05:04,930
得分 
Score.

111
00:05:04,930 --> 00:05:06,370
还要注意这三颗心 
And notice also the three hearts.

112
00:05:06,370 --> 00:05:07,820
这将是球员的健康 
That will be the player's health.

113
00:05:07,820 --> 00:05:13,830
所以如果他可能故意输掉比赛 
So if he were to lose on purpose possibly,

114
00:05:13,830 --> 00:05:18,870
我们可以看到他收到了另一条消息 说按Enter键服务 
we can see he gets another message that's saying press Enter to serve.

115
00:05:18,870 --> 00:05:20,730
他的心跳下降了一分 
His hearts have gone down by one.

116
00:05:20,730 --> 00:05:23,370
所以现在他有三分之二的健康状况 
So now he's got two out of three health.

117
00:05:23,370 --> 00:05:28,020
所以最终 如果他碰巧完全输了--
And so eventually if he were to by chance lose completely--

118
00:05:32,900 --> 00:05:35,290
噢 
oh.

119
00:05:35,290 --> 00:05:37,290
老实说 这是越狱最有趣的部分
That's honestly the most fun part about Breakout

120
00:05:37,290 --> 00:05:39,630
只是让它卡在一堆东西里 
is just getting it caught in a bunch of stuff.

121
00:05:39,630 --> 00:05:41,620
但你可以看到我们在屏幕上观看了一场比赛 
But you can see we go to a Game Over screen.

122
00:05:41,620 --> 00:05:42,850
它会显示你的最终分数 
It shows your final score.

123
00:05:42,850 --> 00:05:46,130
然后你可以按Enter 它就会--
And then you can press Enter and it will--

124
00:05:46,130 --> 00:05:46,840
噢 
oh.

125
00:05:46,840 --> 00:05:48,040
我一定是染上了虫子 
I must have had a bug.

126
00:05:48,040 --> 00:05:51,500
但这应该会把你带回--
But that should take you back to the--

127
00:05:51,500 --> 00:05:53,440
如果你的分数很高 
if in the event that you have a high score,

128
00:05:53,440 --> 00:05:55,360
你要打出一个高分才行 
it'll take you to enter a high score.

129
00:05:55,360 --> 00:06:00,270
如果你的分数不高 它会把你带回开始菜单 
And if you don't have a high score, it'll take you back to the Start menu.

130
00:06:00,270 --> 00:06:02,020
所以我在最后一刻做了几处改动 
So I made a couple of last minute changes.

131
00:06:02,020 --> 00:06:04,390
不幸的是 我一定是把什么东西落在里面了 
Unfortunately I must have left something in there.

132
00:06:04,390 --> 00:06:07,606
但简而言之 这就是突破 
But that's Breakout in a nutshell.

133
00:06:07,606 --> 00:06:10,730
我们今天的目标是基本实现我们看到的所有功能 
Our goal today will be to implement basically all the functionality we saw.

134
00:06:10,730 --> 00:06:12,550
哦 我们没有看高分屏幕 
Oh, we didn't take a look at the high score screen.

135
00:06:12,550 --> 00:06:14,633
所以让我们也快速地来看看这一点 
So let's take a look at that really quick as well.

136
00:06:14,633 --> 00:06:17,820
所以在这里的冠军 你可以看到我们有起跑和高分 
So here at the title, you can see we have Start and High Scores.

137
00:06:17,820 --> 00:06:18,970
哦 伙计 
Oh, man.

138
00:06:18,970 --> 00:06:19,510
好的 
OK.

139
00:06:19,510 --> 00:06:20,884
我一定是搞砸了什么 
I must have screwed something up.

140
00:06:20,884 --> 00:06:24,050
所以我要去参加[INAUDIBLE]突破12 
So I'm going want to go [INAUDIBLE] Breakout 12.

141
00:06:24,050 --> 00:06:24,550
好的 
OK.

142
00:06:24,550 --> 00:06:25,049
抱歉的 
Sorry.

143
00:06:25,049 --> 00:06:25,660
我向你道歉 
I apologize.

144
00:06:25,660 --> 00:06:26,900
我会解决这个问题的 
I'm going to fix that.

145
00:06:26,900 --> 00:06:31,420
但它应该在这里显示这个菜单 在这里您将有一个包含您所有姓名的列表
But it should show this menu here where you will have a list of all your names

146
00:06:31,420 --> 00:06:35,830
从文件中加载 并相应地输出您的分数 
that get loaded from a file and will output your score accordingly.

147
00:06:35,830 --> 00:06:41,920
如果你得到了新的最高分 
And in the event that you get a new high score,

148
00:06:41,920 --> 00:06:44,230
在那之后你可以输入你的名字 
you'll get to enter your name after that,

149
00:06:44,230 --> 00:06:46,360
然后 它将最终将其保存到另一个文件 
and then it will end up saving it to another file.

150
00:06:46,360 --> 00:06:48,401
当我们达到这一点时 我会试着修复它
And when we get to that point I'll try and fix it

151
00:06:48,401 --> 00:06:51,140
这样我们才能真正看到它的样子 
so that we can actually see what it looks like.

152
00:06:51,140 --> 00:06:53,240
所以让我们回到这些幻灯片上来 
So let's go back to these slides here.

153
00:06:53,240 --> 00:06:55,790
这就是我们游戏的整体状态和流程 
So this is the overall state, flow of our game.

154
00:06:55,790 --> 00:06:59,080
所以你可以看到 我用高亮的颜色把它标出来 
So as you can see by me marking it out in a highlighted color,

155
00:06:59,080 --> 00:07:00,550
我们从StartState开始 
we start off in the StartState.

156
00:07:00,550 --> 00:07:01,990
这些都是我们以前讲过的内容 
And this is all stuff we've covered before.

157
00:07:01,990 --> 00:07:03,100
只有状态机 
Just the state machine.

158
00:07:03,100 --> 00:07:05,266
它比Flappy Bird要复杂一点 
It's a little bit more complicated than Flappy Bird.

159
00:07:05,266 --> 00:07:07,930
我们有八个州 而不是我认为的
We have eight states as opposed to I think it

160
00:07:07,930 --> 00:07:10,420
上一节课有四五个人 
was four or five in the last lecture.

161
00:07:10,420 --> 00:07:13,640
箭头显示了哪些状态可以在其他状态之间移动 
And the arrows illustrate which states can move in between other states.

162
00:07:13,640 --> 00:07:17,110
如我们所见 StartState可以通过向上和向下箭头移动
So as we saw, the StartState can move via the up and down arrows

163
00:07:17,110 --> 00:07:18,700
在High ScoreState 
in the HighScoreState.

164
00:07:18,700 --> 00:07:20,710
它可以在HighScoreState和Back之间移动 
It can move between the HighScoreState and back.

165
00:07:20,710 --> 00:07:23,020
所以当你进入HighScoreState时 按Escape键 
So when you go into the HighScoreState, press Escape,

166
00:07:23,020 --> 00:07:25,180
回到StartState 
go back to the StartState.

167
00:07:25,180 --> 00:07:27,280
StartState也有一个分支箭头
The StartState also has an arrow branching off

168
00:07:27,280 --> 00:07:29,710
向左一直到PaddleSelectState
to the left going down to the PaddleSelectState

169
00:07:29,710 --> 00:07:32,952
我们看到用户能够选择要使用的划桨 
where we saw the user is able to select a paddle to use.

170
00:07:32,952 --> 00:07:35,410
一旦他们选择了划桨 我们就去ServeState 
Once they've selected a paddle, we'll go to the ServeState.

171
00:07:35,410 --> 00:07:37,780
他们将能够悠闲地发球 
They'll be able to serve the ball at their leisure.

172
00:07:37,780 --> 00:07:40,380
然后它将在PlayState之间来回移动 
And then it will go back and forth between the PlayState.

173
00:07:40,380 --> 00:07:43,900
因此 如果他们最终受到损害 球
So if they end up taking damage, the ball

174
00:07:43,900 --> 00:07:47,230
在屏幕表面以下 它们将返回到ServeState
goes below the surface of the screen, they'll go back to the ServeState

175
00:07:47,230 --> 00:07:49,930
这样他们才能重新定位自己 
again so they can reorient themselves.

176
00:07:49,930 --> 00:07:53,170
如果他们在PlayState 他们最终得分 
If they're in the PlayState and they end up scoring,

177
00:07:53,170 --> 00:07:55,476
清理整套砖 他们会
clearing the whole entire set of bricks, they'll

178
00:07:55,476 --> 00:07:57,100
实际上被带到了维克托州 
actually get taken to the VictoryState.

179
00:07:57,100 --> 00:07:59,266
而VictoryState是我们增加级别的地方
And the VictoryState is where we increment the level

180
00:07:59,266 --> 00:08:00,760
我们还重新生成了级别 
and we also regenerate the level.

181
00:08:00,760 --> 00:08:02,801
而VictoryState回到ServeState 
And the VictoryState goes back to the ServeState,

182
00:08:02,801 --> 00:08:04,990
然后我们再重复一遍整个循环 
and then we repeat that whole loop again.

183
00:08:04,990 --> 00:08:08,200
在PlayState 如果他们想要结束一场比赛 
In the PlayState if they are to get a Game Over,

184
00:08:08,200 --> 00:08:10,960
他们会去GameOverState 它会告诉他们他们的分数 
they'll go to the GameOverState, it'll tell them their score,

185
00:08:10,960 --> 00:08:13,090
然后他们会进入EnterHighScoreState
and then they'll go to the EnterHighScoreState

186
00:08:13,090 --> 00:08:14,950
取决于他们的分数是否很高 
depending on whether they have a high score.

187
00:08:14,950 --> 00:08:18,010
如果不是 如向上和向左的箭头所示 
And if not, as seen by the arrow that goes up and to the left,

188
00:08:18,010 --> 00:08:19,990
他们实际上会回到星际之州 
they'll actually go back to the StartState.

189
00:08:19,990 --> 00:08:22,730
然后EnterHighScoreState也将返回到HighScoreState
And then the EnterHighScoreState will also go back to the HighScoreState

190
00:08:22,730 --> 00:08:24,438
这样他们一进门就能看到
so that they can see once they've entered

191
00:08:24,438 --> 00:08:27,687
他们的高分 他们的分数相对于列表中的其他分数 
their high score, their score relative to the other scores in the list.

192
00:08:27,687 --> 00:08:29,770
所以在我们现在要看的《突破0》中 
So in Breakout0, which we're going to look at now,

193
00:08:29,770 --> 00:08:31,436
我们要做一些非常基本的事情 
we're going to do some very basic stuff.

194
00:08:31,436 --> 00:08:34,059
因此 这是一如既往的第0天更新 
So this is the Day 0 update as always.

195
00:08:34,059 --> 00:08:37,900
我现在在《越狱0》里 
I'm in Breakout0 right now.

196
00:08:37,900 --> 00:08:39,049
是的 我是 
Yes, I am.

197
00:08:39,049 --> 00:08:42,940
所以我们要做的是 我们首先来看这里的第27行 
So what we're going to do is we're going to look at first thing here, line 27.

198
00:08:42,940 --> 00:08:47,110
所以在我们在应用程序中所做的事情之前
So before what we were doing in our application

199
00:08:47,110 --> 00:08:51,850
基本上在顶层有很多文件 有点迷失了方向
is having basically a lot of files at the top level and sort of losing track

200
00:08:51,850 --> 00:08:53,697
我们可能在做什么 
of what we were doing potentially.

201
00:08:53,697 --> 00:08:55,780
特别是当你开始添加越来越多的文件
Especially as you start adding more and more files

202
00:08:55,780 --> 00:08:58,330
还有50到100个文件
and you've got like 50, 100 more files, that's

203
00:08:58,330 --> 00:09:00,190
一些明显不重要的东西
something that's obviously not maintainable.

204
00:09:00,190 --> 00:09:02,884
所以解决的办法是 把它们放在文件夹里
So the solution there, just put them in folders

205
00:09:02,884 --> 00:09:04,300
然后记录所有的事情
and then keep track of everything.

206
00:09:04,300 --> 00:09:05,370
让他们有组织 
Keep them organized.

207
00:09:05,370 --> 00:09:07,745
这是我们要开始做的一件大事 
And that's a major thing that we're going to start doing.

208
00:09:07,745 --> 00:09:10,120
最重要的是 在代码中 
And on top of that, we're also going to, in our code,

209
00:09:10,120 --> 00:09:11,800
让事情变得更加模块化 
keep things a little bit more modular.

210
00:09:11,800 --> 00:09:15,790
这就是为什么我们有这个文件源斜杠依赖项 
And that's why we have this file source slash dependencies,

211
00:09:15,790 --> 00:09:18,520
我们马上就会看到 
which we'll take a look at in a second.

212
00:09:18,520 --> 00:09:20,530
我们在这里分配了一堆全局表 
We've allocated a bunch of global tables here.

213
00:09:20,530 --> 00:09:23,410
所以我们的设计决定
So we're taking the design decision of even

214
00:09:23,410 --> 00:09:26,740
虽然我提到过我们会把很多全局变量
though I mentioned that we will be sort of taking a lot of the global variables

215
00:09:26,740 --> 00:09:29,740
从我们的应用程序资产中 
out of our application assets, we're going to keep

216
00:09:29,740 --> 00:09:31,450
所有这些都是全局变量 
all of those in some global variables.

217
00:09:31,450 --> 00:09:34,491
将来我们会看到如何实现资源管理器
And we'll see in the future how we can maybe implement a resource manager

218
00:09:34,491 --> 00:09:36,430
为我们解决这个问题 
class that takes care of this for us.

219
00:09:36,430 --> 00:09:38,890
但现在 为了简单起见 在爱 负荷 
But for now, for simplicity's sake, in love.load,

220
00:09:38,890 --> 00:09:41,320
我们只需要几个全局表 
we're just going to have a few global tables that contain,

221
00:09:41,320 --> 00:09:43,300
在本例中是全局字体 
in this case, global fonts.

222
00:09:43,300 --> 00:09:46,237
通过键 我们可以索引小 中 大字体 
So by key, we can index small, medium, and large fonts,

223
00:09:46,237 --> 00:09:48,070
就是不同大小的新字体
which are just new fonts at different sizes.

224
00:09:48,070 --> 00:09:49,379
八十六三十二
8, 16, 32.

225
00:09:49,379 --> 00:09:50,170
我们正在利用它 
And we're using it.

226
00:09:50,170 --> 00:09:53,649
我们现在有一个字体文件夹 而不仅仅是保持在父级 
We have a fonts folder now instead of just keeping it at the parent level.

227
00:09:53,649 --> 00:09:54,940
我们将把它设置为小 
We're going to set it to small.

228
00:09:54,940 --> 00:09:55,960
我们有全局纹理 
We have global textures.

229
00:09:55,960 --> 00:09:59,641
背景 主 箭头 红心 粒子 
So background, main, arrows, hearts, particle.

230
00:09:59,641 --> 00:10:02,390
所以我们有背景 这是我们屏幕的背景 
So we have the background, which was the background of our screen.

231
00:10:02,390 --> 00:10:05,230
我们所有的砖块球拍球等等都在总部
Main has all of our bricks, paddles, the balls, et cetera.

232
00:10:05,230 --> 00:10:07,770
箭头将用于桨选择屏幕 
Arrows are going to be for the paddle select screen.

233
00:10:07,770 --> 00:10:09,220
两个左右箭头 
The two left and right arrows.

234
00:10:09,220 --> 00:10:10,990
心脏是为了我们的健康 
Hearts are going to be for our health.

235
00:10:10,990 --> 00:10:13,570
粒子是一个很小很小的纹理
And then particle is a single, small, tiny little texture

236
00:10:13,570 --> 00:10:16,330
我们将用它来产生粒子系统中的所有粒子
that we'll use to spawn all the particles in our particle systems

237
00:10:16,330 --> 00:10:20,584
稍后当我们接近演示的尾声时 
later on as we get towards the end of the demonstration.

238
00:10:20,584 --> 00:10:21,250
所以这是推 
So this is push.

239
00:10:21,250 --> 00:10:22,450
我们就像平常一样布置 
We're setting it up just like normal.

240
00:10:22,450 --> 00:10:23,440
没什么新鲜的
Nothing new there.

241
00:10:23,440 --> 00:10:26,200
除了虚拟宽度 虚拟高度 以及所有这些东西 
Except the virtual width, virtual height, and all that stuff,

242
00:10:26,200 --> 00:10:29,930
如果我们在一个常量文件中查看源代码 这些都被移走了 
those have been moved out, if we look into source in a constants file.

243
00:10:29,930 --> 00:10:32,770
所以这个文件 没有包含main中的所有常量 
So this file here, instead of having all the constants in main,

244
00:10:32,770 --> 00:10:35,020
把它们拿出来 
it kind of makes sense just to take them out, put them

245
00:10:35,020 --> 00:10:39,520
在一个名为constants.lua的文件中 我们可以排序管理所有这些 
in a file called constants.lua, and we can sort manage all that.

246
00:10:39,520 --> 00:10:42,340
当我们看到资本窗口时 
We can know immediately when we're looking at capital window

247
00:10:42,340 --> 00:10:43,240
宽度 窗户高度 等等
width, window height, et cetera.

248
00:10:43,240 --> 00:10:44,410
这些都是常量 
And these are all constants.

249
00:10:44,410 --> 00:10:46,150
如果你有一个常量文件 我们可以更容易地
If you have a constants file, we just can more easily

250
00:10:46,150 --> 00:10:48,460
追踪它而不是抓取我们所有的文件
track it rather than having to grab through all of our files

251
00:10:48,460 --> 00:10:50,410
试图弄清楚我们在看什么
to try and figure out what we were looking at.

252
00:10:53,830 --> 00:10:59,410
和前面一样 常量在设置屏幕中使用 
And the constants are used here in our set up screen as before.

253
00:10:59,410 --> 00:11:03,289
然后另一个声音全局表 就像以前一样 
And then another sounds global table, just as before.

254
00:11:03,289 --> 00:11:05,080
我们有很多不同的音效 
We have a bunch of different sound effects.

255
00:11:05,080 --> 00:11:07,038
我把音乐和音效分开了
I've separated the music from the sound effects

256
00:11:07,038 --> 00:11:10,020
就为了让我们一眼就能看出来 哦 这是音乐 
just so that we can see at a glance, oh, this is the music,

257
00:11:10,020 --> 00:11:11,560
这些是音效 
these are the sound effects.

258
00:11:11,560 --> 00:11:12,970
很直接 
Pretty straight forward.

259
00:11:12,970 --> 00:11:14,500
我们有一个国家机器 一如既往 
We have a state machine, as always.

260
00:11:14,500 --> 00:11:18,250
我们将使用StartState来进行演示 
And we're just going to use a StartState for this demonstration.

261
00:11:18,250 --> 00:11:20,770
将其设置为开始 
Setting it to Start.

262
00:11:20,770 --> 00:11:22,180
爱 调整大小 爱 更新 
Love.resize, love.update.

263
00:11:22,180 --> 00:11:23,929
这些都是我们以前见过的函数 
These are all functions we've seen before.

264
00:11:23,929 --> 00:11:25,000
没什么新鲜的
Nothing too new.

265
00:11:25,000 --> 00:11:25,772
Love.keypress.
Love.keypress.

266
00:11:25,772 --> 00:11:26,980
我们有一个全局输入表 
We have a global input table.

267
00:11:26,980 --> 00:11:30,880
就像Flappy Bird一样 我们可以在任何地方索引输入表
So as in the case of Flappy Bird, we can index into that input table anywhere

268
00:11:30,880 --> 00:11:34,930
在我们的应用程序中调用love.keyboard.wasPressed[key] 
in our application and call love.keyboard.wasPressed[key],

269
00:11:34,930 --> 00:11:38,020
它允许我们专门从main获取输入并使用它
which allows us to take input exclusively from main and use it

270
00:11:38,020 --> 00:11:40,680
在其他模块中 
in other modules.

271
00:11:40,680 --> 00:11:42,850
这里我们画的是
Here we're drawing the--

272
00:11:42,850 --> 00:11:45,160
这是实际的渲染代码 
so this is the actual rendering code.

273
00:11:45,160 --> 00:11:49,690
我们在我们的爱中这样做 draw与特定的状态相对
And we're doing this in our love.draw as opposed to a specific state

274
00:11:49,690 --> 00:11:51,940
因为这实际上适用于所有州 
because this is actually going to apply to all states.

275
00:11:51,940 --> 00:11:53,731
我们总是会有这样的背景 
We're always going to have this background.

276
00:11:53,731 --> 00:11:55,900
所以与其一遍又一遍地重复 
So rather than duplicate it over and over again,

277
00:11:55,900 --> 00:11:58,240
在本例中 这一小段代码 
in this instance, this minor bit of code,

278
00:11:58,240 --> 00:12:02,214
我们将显示所有状态后面的背景 
we're going to display the background behind all the states.

279
00:12:02,214 --> 00:12:04,630
所以所有的州都将在这个背景下渲染
So all the states are going to render over this background

280
00:12:04,630 --> 00:12:07,000
让它看起来更有凝聚力 
and make it seem a little more cohesive.

281
00:12:07,000 --> 00:12:09,039
我们将在没有旋转的情况下画0 0 
We're going to draw at 0, 0 without rotation.

282
00:12:09,039 --> 00:12:11,080
然后这里有一些数学运算 即虚拟宽度
And then this bit of math here, the virtual width

283
00:12:11,080 --> 00:12:15,929
除以 然后背景宽度减去1 最终得到一个比例因子
divided by, and then background width minus one, end up being a scale factor

284
00:12:15,929 --> 00:12:18,220
这样我们就可以始终将其调整到我们的虚拟宽度 
so that we can always scale it to be our virtual width.

285
00:12:18,220 --> 00:12:22,930
因为默认情况下纹理比实际窗口小一些
Because the texture by default is some amount smaller than our actual window

286
00:12:22,930 --> 00:12:26,140
或者我们的实际虚拟宽度和高度 但通过除以虚拟宽度
or our actual virtual width and height, but by dividing virtual width

287
00:12:26,140 --> 00:12:29,560
无论该图像的背景宽度是多少 
by whatever the background width of that image is by one,

288
00:12:29,560 --> 00:12:32,950
我们将获得比例因子 因为虚拟宽度大于图像 
we'll get a scale factor because virtual width is larger than the image.

289
00:12:32,950 --> 00:12:37,270
我们将得到X和Y的比例因子 它等同于它完全拉伸
We'll get a scale factor on X and Y that equates to it completely stretching

290
00:12:37,270 --> 00:12:41,050
来填满我们的虚拟宽度和高度 
to fill our virtual width and height.

291
00:12:41,050 --> 00:12:44,136
回想一下 这两个参数是X和Y上的比例 
And recall that these two parameters are the scale on the X and the Y.

292
00:12:44,136 --> 00:12:47,260
所以这将是一些 就像 一点什么或两点什么 
So it's going to be some, like, one point something or two point something.

293
00:12:47,260 --> 00:12:50,230
不惜一切代价来填满屏幕 
Whatever it takes to end up filling the screen.

294
00:12:50,230 --> 00:12:52,567
最后 在这里 我实现的新Bit
And then lastly here, the new bit I implemented

295
00:12:52,567 --> 00:12:55,150
只是一个每秒显示帧的函数 我认为
is just a display of frames per second function, which I think

296
00:12:55,150 --> 00:12:58,357
通常是很重要的 而且很容易做到 
is kind of important generally, and it's very easy to do.

297
00:12:58,357 --> 00:13:00,940
我不记得了 我想我们还没谈过 但只是
I don't recall, I don't think we talked about it yet, but just

298
00:13:00,940 --> 00:13:02,710
Love.timer.getFPS 
love.timer.getFPS.

299
00:13:02,710 --> 00:13:04,811
然后我就在左上角画上绿色
And then I just draw in the top left in green

300
00:13:04,811 --> 00:13:07,810
这样我们就可以在游戏的所有迭代中看到它 什么
so that we can see it throughout all of our iterations of the game, what

301
00:13:07,810 --> 00:13:08,770
每秒的帧数是 
are frames per second are.

302
00:13:08,770 --> 00:13:12,070
如果您想要在无需查看终端或任何东西的情况下进行监控
If you want to monitor without having to look through your terminal or anything

303
00:13:12,070 --> 00:13:13,861
就像这样 就在上面显示 它是
like that, just displaying at the top, it's

304
00:13:13,861 --> 00:13:16,090
这是很多比赛中的标准练习 
standard practice in a lot of games.

305
00:13:16,090 --> 00:13:18,140
如果您已进入调试控制台或诸如此类的
If you've gone to the debug console or whatnot

306
00:13:18,140 --> 00:13:20,920
或者是调查了一些黑客行为 
or sort of looked into some of the hacks,

307
00:13:20,920 --> 00:13:23,030
你会在很多地方看到这一点 
you'll see that in a lot of places.

308
00:13:23,030 --> 00:13:25,750
所以我早些时候谈到了依赖 
So I talked earlier about dependencies.lua.

309
00:13:25,750 --> 00:13:30,190
因此 这也与我们将一切模块化的努力联系在一起 
So this ties in as well to our effort to sort of modularize everything,

310
00:13:30,190 --> 00:13:31,750
保持一切井然有序 
keep everything organized.

311
00:13:31,750 --> 00:13:34,010
而不是要求所有东西都放在Main的顶部 
Instead of requiring everything at the top of main,

312
00:13:34,010 --> 00:13:36,550
让我们把它们都放在一个文件里 然后我们
let's just put it all in a file and then we'll

313
00:13:36,550 --> 00:13:40,630
一目了然地知道我们需要什么 我们不必查看Main
know at a glance what we're requiring and we don't have to look through main

314
00:13:40,630 --> 00:13:44,620
并建造100条主线 这可能比需要的要多得多 
and make main 100 lines, potentially a lot more than it needs to be.

315
00:13:44,620 --> 00:13:47,500
所以需要推动 需要上进 
So requiring push, requiring class.

316
00:13:47,500 --> 00:13:49,690
和我们以前做的一样 
Same as we've done before.

317
00:13:49,690 --> 00:13:50,791
需要Soure.Constants 
Require source.constants.

318
00:13:50,791 --> 00:13:51,790
我们有权访问这些文件 
We have access to those.

319
00:13:51,790 --> 00:13:55,550
需要StateMachine 然后是BaseState和StartState 
Require StateMachine, and then BaseState and StartState.

320
00:13:55,550 --> 00:13:58,750
那么 让我们继续来看看我们的StartState 
So let's go ahead and take a look at our StartState.

321
00:13:58,750 --> 00:14:01,330
所以我把州放在了SOURCE的子文件夹中 
So I put states in a subfolder of source.

322
00:14:01,330 --> 00:14:03,580
这是另一种让事情保持模块化的努力 
This is another effort to sort of keep things modular.

323
00:14:03,580 --> 00:14:08,410
在这个特定的项目中 我们不会有很多嵌套的代码文件夹 
In this particular project, we won't have a lot of nested folders of code,

324
00:14:08,410 --> 00:14:10,720
但我决定把各州放在他们自己的文件夹里
but I decided to put the states in their own folder

325
00:14:10,720 --> 00:14:14,130
你可以很容易地访问你所有的州 
just so easily you can get access to all your states.

326
00:14:14,130 --> 00:14:18,610
因此 我们将在这里的第21行查看StartState 
So we'll look at StartState here on line 21.

327
00:14:18,610 --> 00:14:21,940
回想一下 在StartState中 我们刚刚在屏幕中央显示了Breakout
So recall in the StartState, we just had Breakout in the center of the screen

328
00:14:21,940 --> 00:14:24,950
然后我们有了首发比赛和高分 
and then we had Start Game and High Scores.

329
00:14:24,950 --> 00:14:27,772
因此 用户能够突出显示他想要查看的州 
So the user was able to highlight which state he wanted to look at.

330
00:14:27,772 --> 00:14:29,980
因此 我们需要跟踪突出显示的是哪一个 
So we need to keep track of which one is highlighted.

331
00:14:29,980 --> 00:14:32,220
所以所有这个变量的目的只是为了跟踪 
So all this variable's purpose is just to keep track.

332
00:14:32,220 --> 00:14:33,250
那就一两个吧 
So one or two.

333
00:14:33,250 --> 00:14:36,115
一个是玩游戏 两个是高分 
One being Play Game, and two being High Scores.

334
00:14:39,580 --> 00:14:43,930
然后在这里 如果我们上下按压 那么我们--
And then here if we press up and down, then we--

335
00:14:43,930 --> 00:14:45,850
因为实际上只有两种选择 
because there's only two options effectively,

336
00:14:45,850 --> 00:14:48,400
你可以只用一两个来翻转任何高亮的部分 
you can just flip whatever highlight is with one or two.

337
00:14:48,400 --> 00:14:50,590
如果你有一个多于两个的选项列表 
If you have a list of options that's more than two,

338
00:14:50,590 --> 00:14:52,840
你需要递增一个 直到它到达任何
you'll need to increment one until it gets to whatever

339
00:14:52,840 --> 00:14:55,332
X是您的列表选项的数量 
X is, your number of list options.

340
00:14:55,332 --> 00:14:57,040
然后如果你在那个点按下 
And then if you press down at that point,

341
00:14:57,040 --> 00:14:58,840
你应该翻到最上面去 
you should flip back up to the top.

342
00:14:58,840 --> 00:15:02,110
同样的道理也适用于你是否选择了第一种选择 
And the same holds true for whether you're at option one.

343
00:15:02,110 --> 00:15:05,290
你应该去翻转 旋转到你的清单的底部
You should go flip, rotate to the bottom of your list

344
00:15:05,290 --> 00:15:08,712
这样看起来你就像是绕了一圈 
so that it looks as if you've gone all the way around.

345
00:15:08,712 --> 00:15:11,170
然后--当我们这样做的时候 我们只是在这里播放声音 
And-- then we're just playing a sound here when we do that.

346
00:15:11,170 --> 00:15:14,390
我们有一个love.keyboard.wa按下[退出]调用
We have a love.keyboard.wasPressed[escape] call

347
00:15:14,390 --> 00:15:14,890
这里 
here.

348
00:15:14,890 --> 00:15:18,109
它不再是全局的 因为我们的应用程序中有一些状态
It's not global anymore because there are some states in our application

349
00:15:18,109 --> 00:15:20,650
我们可能想按下Escape来后退
where we might want to press Escape to actually go backwards,

350
00:15:20,650 --> 00:15:22,464
我们会看到的
and we'll see that.

351
00:15:22,464 --> 00:15:23,380
在这里渲染 
And so rendering here.

352
00:15:23,380 --> 00:15:25,450
我们用大字体渲染Breakout 
We render Breakout with a large font.

353
00:15:25,450 --> 00:15:29,500
现在我们可以在屏幕中央的大键处访问G字体 
Now that we can access G fonts at large key in the center of the screen,

354
00:15:29,500 --> 00:15:30,370
设置中等字体 
set medium font.

355
00:15:30,370 --> 00:15:36,060
然后我们将一个接一个地呈现两个文本字段 
And then we're going to render our two text fields one after the other.

356
00:15:36,060 --> 00:15:38,132
但如果高亮部分等于1 
But if highlighted is equal to one, then we're

357
00:15:38,132 --> 00:15:40,590
将它设置为蓝色 这是三种颜色之一 
going to set it to some blue color, which is one of three--

358
00:15:40,590 --> 00:15:43,590
255 255 255
255, 255, 255.

359
00:15:43,590 --> 00:15:44,996
然后将其渲染 
And then render it.

360
00:15:44,996 --> 00:15:47,620
然后确保在那之后重置颜色 因为回想一下 
And then make sure to reset the color after that because recall

361
00:15:47,620 --> 00:15:50,270
爱情2D本身就像一个状态机 
love 2D is sort of like a state machine in its own right,

362
00:15:50,270 --> 00:15:53,340
如果你给某个东西设置颜色 不管你画什么 
where if you set the color to something, whatever you draw and render

363
00:15:53,340 --> 00:15:56,430
然后呢 不管是图片还是文字 都会采用这个颜色 
after that, be it images or text, will adopt that color.

364
00:15:56,430 --> 00:16:00,480
所有的都是255 255 255 255 
So having everything be 255, 255, 255, 255,

365
00:16:00,480 --> 00:16:02,670
它是纯白色的 完全不透明 
which is pure white, completely opaque, has

366
00:16:02,670 --> 00:16:04,920
把所有东西都画成完全不透明的效果 
the effect of drawing everything completely opaque.

367
00:16:04,920 --> 00:16:07,980
但如果你不这样做 你的图像或你后来画的东西 
But if you don't do that, your images or whatnot that you draw afterwards

368
00:16:07,980 --> 00:16:10,962
会是有色的或透明的 这是你大多数时候不想要的 
will be tinted or transparent, which you most of the time don't want.

369
00:16:10,962 --> 00:16:13,170
但有时候你可能会想要 
But you might sometimes want that, and we'll actually

370
00:16:13,170 --> 00:16:14,589
在PaddleSelectState中可以看到 
see that in the PaddleSelectState.

371
00:16:14,589 --> 00:16:15,880
同样的道理也适用于这里 
And same thing holds true here.

372
00:16:15,880 --> 00:16:19,090
如果突出显示的是两个 则执行完全相同的操作 
If highlighted is two, do the exact same thing.

373
00:16:19,090 --> 00:16:22,830
如果我们运行这个应用程序 
And so if we run this application, which is mainly

374
00:16:22,830 --> 00:16:26,771
只是我们之前看到的一个子集 我们可以上下移动
just a subset of what we saw before, we can move up and down

375
00:16:26,771 --> 00:16:28,020
在开始和最高分之间 
between Start and High Scores.

376
00:16:28,020 --> 00:16:30,270
但如果我们按下任何一个回车键 
But if we press Enter on any of them, nothing

377
00:16:30,270 --> 00:16:33,450
因为我们没有事件处理程序来处理它 
happens because we have no event handlers actually taking care of that.

378
00:16:33,450 --> 00:16:37,300
但是我们有缩放到屏幕上的图像 我们有中间的突破 
But we have the image scaled to the screen, we have Breakout in the middle,

379
00:16:37,300 --> 00:16:40,750
我们有两个菜单选项
and we have our two menu options there.

380
00:16:40,750 --> 00:16:41,680
所以Breakout 1.
So Breakout1.

381
00:16:41,680 --> 00:16:46,710
这就是我们开始深入精灵表的地方 
So this is where we start to dive a little bit into sprite sheets, which

382
00:16:46,710 --> 00:16:49,530
是游戏开发的主要组成部分 2D游戏
is a major component of game development, 2D game

383
00:16:49,530 --> 00:16:53,340
我们将在未来和这个应用程序中看到的发展 
development that we'll be looking at in the future and in this application.

384
00:16:53,340 --> 00:16:57,300
但最终 精灵表单只是 而不是有--
But a sprite sheet is just, ultimately, rather than have--

385
00:16:57,300 --> 00:17:00,150
我不知道这张精灵纸上有多少张图片 
I don't know how many images there are on this sprite sheet here.

386
00:17:00,150 --> 00:17:03,030
但无论这些文件有多少 只要有
But however many of these files, just have

387
00:17:03,030 --> 00:17:07,200
一个文件将它们放在一起 然后使用矩形定义
one file put them all together, and then using rectangles, define

388
00:17:07,200 --> 00:17:08,849
所有不同的精灵都在那里 
where all the different sprites are.

389
00:17:08,849 --> 00:17:11,400
然后当我们想要画的时候 使用这些矩形
And then when we want to draw, use those rectangles

390
00:17:11,400 --> 00:17:14,230
告诉我爱 图解 画 我要你
and just tell love.graphics.draw, I want you

391
00:17:14,230 --> 00:17:16,589
来绘制这个纹理 这个精灵图案 但是我想
to draw this texture, this sprite sheet, but I want

392
00:17:16,589 --> 00:17:19,500
你只需要画它的这一部分.
you to draw just this section of it.

393
00:17:19,500 --> 00:17:23,490
你会在一个四边形中传递它 这个四边形只是一个简单的矩形 上面有高度 X和Y 
You'd pass it in a quad, which is just simply rectangle with height, X and Y.

394
00:17:23,490 --> 00:17:27,900
喜欢2D的人会知道 好的 我要画这个图像 但只有这一点 
And love 2D will know, OK, I'm going to draw the image, but only this bit.

395
00:17:27,900 --> 00:17:31,290
它的效果就像你只画了很小的图像
And it has the effect of looking as if you're only drawing tiny little images

396
00:17:31,290 --> 00:17:34,092
而不是一个可怕的形象 
as opposed to one monstrous image.

397
00:17:34,092 --> 00:17:36,300
以及与我们要查看的相关函数
And the functions that are relevant for us to look at

398
00:17:36,300 --> 00:17:41,250
是love.graph ics.newquad 它接受X、Y、宽度和高度 
are love.graphics.newquad, which takes an X, Y, width, and a height.

399
00:17:41,250 --> 00:17:45,570
还有一个维度对象 这是从图像中获得的 
And also a dimensions object, which you get from an image.

400
00:17:45,570 --> 00:17:46,380
我们会看到的 
We'll see that.

401
00:17:46,380 --> 00:17:50,870
我相信 所有这些基本上只是一个X Y 宽度和高度 
And all that basically is, I believe, is just an X, Y, width and height as well.

402
00:17:50,870 --> 00:17:54,540
或者只是宽度和高度 更确切地说 来自任何图像
Or just a width and a height, rather, from whatever image

403
00:17:54,540 --> 00:17:57,180
您想要为创建四边形 
you want to create quads for.

404
00:17:57,180 --> 00:18:00,174
然后是爱 画 画 我们已经看过了 
And then love.graphics.draw, we've already seen it,

405
00:18:00,174 --> 00:18:01,590
但这是一个不同的签名 
but this is a different signature.

406
00:18:01,590 --> 00:18:06,480
这有纹理 四边形 X Y 四边形是第二个参数 
This has texture, quad, X, Y. Quad being the second argument.

407
00:18:06,480 --> 00:18:09,030
当它进入这个四边形时 它知道只有抽签
And when it takes in this quad, it knows to only draw

408
00:18:09,030 --> 00:18:13,290
定义的矩形图像显示在屏幕上 
that defined rectangle of image to the screen.

409
00:18:13,290 --> 00:18:17,436
接下来 我们将继续关注《突破1》 
And so we'll go ahead and take a look now at Breakout1.

410
00:18:17,436 --> 00:18:22,746
观众：[听不见]
AUDIENCE: [INAUDIBLE]

411
00:18:22,746 --> 00:18:24,870
科尔顿·奥格登：问题是 有没有什么工具
COLTON OGDEN: The question was, are there any tools

412
00:18:24,870 --> 00:18:28,980
这样我们在做床单的时候就不用去猜四合院在哪里了？
so that we don't have to guess where the quad is when we're doing the sheet?

413
00:18:28,980 --> 00:18:31,320
是的 有很多时间 
Yes, there are a lot of the time.

414
00:18:31,320 --> 00:18:35,637
我看了看 看到了几个 但我自己还没有彻底测试过它们 
I looked and saw a couple, but I haven't tested them thoroughly myself.

415
00:18:35,637 --> 00:18:37,470
对于像这样的简单示例 通常是
For simpler examples like this, it's usually

416
00:18:37,470 --> 00:18:39,053
非常简单 可以通过编程来完成 
easy enough to programmatically do it.

417
00:18:39,053 --> 00:18:42,840
但是的 当你开始阅读巨型精灵地图集时 
But yeah, when you get into having giant sprite atlases where

418
00:18:42,840 --> 00:18:46,890
你有特别的东西不一定是对称的
you have especially things that are not necessarily symmetrical

419
00:18:46,890 --> 00:18:50,970
或者看起来是矩形的 尽管它们仍然需要被限定为矩形 
or rectangular looking even though they still need to be defined rectangularly,

420
00:18:50,970 --> 00:18:54,600
通常最好使用这样的工具 
it's often best to use a tool like that.

421
00:18:54,600 --> 00:18:57,600
有 我相信 我只是没有使用它们 
There are, I do believe, I just haven't used them.

422
00:18:57,600 --> 00:19:00,450
我可以在以后的讲座中提出来 这样我们就可以讨论了 
I can bring it up in a future lecture so we can discuss.

423
00:19:03,450 --> 00:19:08,430
在我们进入Breakout 1之前还有其他问题吗？
Any other questions before we carry into Breakout1?

424
00:19:08,430 --> 00:19:09,840
好吧
All right.

425
00:19:09,840 --> 00:19:12,450
所以我将打开第一个
So I'm going to go ahead and open up the very first thing

426
00:19:12,450 --> 00:19:14,430
我们应该在Breakout 1上看看 
we should look at on Breakout1.

427
00:19:14,430 --> 00:19:18,000
在源目录中 我们有一个新文件 
In the source directory, we have a new file.

428
00:19:18,000 --> 00:19:20,970
从现在开始 我假设 
And from here on out, I'm going to assume,

429
00:19:20,970 --> 00:19:24,990
我们总是假设当我们引入一个新文件时 
we're going to always assume that when we introduce a new file,

430
00:19:24,990 --> 00:19:28,620
我们将把它包含在dependencies. lua中 
we're going to include it in dependencies.lua.

431
00:19:28,620 --> 00:19:32,160
所以在这种情况下 我们只需要说require source/util 
And so in this case, all we need to do is just say require source/util.

432
00:19:32,160 --> 00:19:38,700
正如你所看到的 我们还在这个演示中添加了一个PlayState 
And as you can see, we're also adding a PlayState to this demonstration.

433
00:19:38,700 --> 00:19:41,520
但从现在开始 我不会再提我们了
But from here on out, I won't make mention of us actually

434
00:19:41,520 --> 00:19:42,840
将其添加到我们的项目中 
adding it to our project.

435
00:19:42,840 --> 00:19:47,210
所以util.lua是包含代码的模块
So util.lua is the module that contains the code

436
00:19:47,210 --> 00:19:51,150
我们将使用它来为给定的精灵表生成四边形 
we're going to use to actually generate quads for a given sprite sheet.

437
00:19:51,150 --> 00:19:54,850
这个函数 它所做的就是 它需要一个地图集或精灵表--
And this function, all it does, is it takes an atlas or sprite sheet--

438
00:19:54,850 --> 00:19:56,110
这两个名字是同义的 
the names are synonymous.

439
00:19:56,110 --> 00:19:57,370
你会听到他们两个 
You'll hear them both.

440
00:19:57,370 --> 00:20:02,040
或者我们给它一个地图集 我们给它我们想要的瓷砖的宽度
Or we pass it an Atlas, we pass it the width of the tile that we want

441
00:20:02,040 --> 00:20:04,800
和瓷砖的高度 
and the height of the tile that we want.

442
00:20:04,800 --> 00:20:07,440
它会得到纸张的宽度和高度 
It's going to get the width and the height of the sheet here.

443
00:20:07,440 --> 00:20:11,050
所以每幅图像都有一个函数叫做获取宽度和高度 
So every image has a function called get width and get height,

444
00:20:11,050 --> 00:20:13,150
所以我们就这么做
so we're just going to do that.

445
00:20:13,150 --> 00:20:16,290
特别是纸张的宽度和高度
And specifically the sheet width and sheet height

446
00:20:16,290 --> 00:20:19,920
是图像的宽度除以图块宽度和图块高度 
are the width of the image divided by tile width and tile height.

447
00:20:19,920 --> 00:20:23,480
这样我们就知道我们需要在精灵表上重复多少次
So we know how many times we need to iterate over the sprite sheet

448
00:20:23,480 --> 00:20:24,480
来生成矩形 
to generate a rectangle.

449
00:20:24,480 --> 00:20:29,700
我们根据瓷砖的大小来划分 
We're dividing it up based on the size of our tiles.

450
00:20:29,700 --> 00:20:32,350
然后我们在这里做一个简单的嵌套四个循环 
And then we just basically do a simple nested four loop here.

451
00:20:32,350 --> 00:20:34,250
我们开始一个计数器和一个精灵表 
We start a counter and a sprite sheet.

452
00:20:34,250 --> 00:20:37,470
这个精灵表将是一个表 容纳我们所有的四边形 
This sprite sheet is going to be a table that holds all of our quads.

453
00:20:37,470 --> 00:20:39,220
我们只说Y 得到零 
We just say for Y, get zero.

454
00:20:39,220 --> 00:20:40,400
图纸高度减一 
Sheet height minus one.

455
00:20:40,400 --> 00:20:44,200
所以从左上角开始往下走 
So starting at the top left, going down.

456
00:20:44,200 --> 00:20:46,720
从顶部开始向下 然后x等于零 
And starting at the top going down, and then x equals zero,

457
00:20:46,720 --> 00:20:50,320
从左边开始向右转 
starting at the left going right.

458
00:20:50,320 --> 00:20:55,540
在Sprite Sheet Sheet Counter 这是一个因为在Lua 
At sprite sheet, sheet counter, which is one here because in lua,

459
00:20:55,540 --> 00:20:57,280
表是一个索引表 
tables are one indexed.

460
00:20:57,280 --> 00:21:02,650
我们将创建一个新的四边形 X乘以瓷砖宽度 Y乘以瓷砖宽度 
We're going to create a new quad at X times tile width, Y times tile width.

461
00:21:02,650 --> 00:21:05,110
给它和我们的瓷砖一样的宽度和高度 
Give it the width and the height of our tile.

462
00:21:05,110 --> 00:21:07,930
所以 无论我们传递给函数签名的是什么 
So just whatever we passed into our function signature.

463
00:21:07,930 --> 00:21:10,420
在这种情况下 通常是16x32
Here it will often be in this case be 16 by 32

464
00:21:10,420 --> 00:21:14,590
因为这就是砖块的大小 
because that's the size of the bricks.

465
00:21:14,590 --> 00:21:17,380
然后我们传入幻灯片中看到的最后一个参数 
And then we pass in the last parameter that we saw in the slide,

466
00:21:17,380 --> 00:21:19,640
这就是地图集：获取维度 
which is atlas:getdimensions.

467
00:21:19,640 --> 00:21:21,760
然后我们只需在这里增加我们的床单计数器 
And then we just increment our sheet counter here.

468
00:21:21,760 --> 00:21:23,990
然后在这个结束的时候 当我们都做完了 我们会把这个还回去 
And then at the end of this, when we're all done, we'll return this.

469
00:21:23,990 --> 00:21:25,930
我们会有一张四合院的桌子 然后我们就可以
We'll have a table of quads that we can then

470
00:21:25,930 --> 00:21:31,410
以一、二、三、四、五、六、七、八的形式使用 
use that are in a sort of one, two, three, four, five, six, seven, eight.

471
00:21:31,410 --> 00:21:34,390
嗯 我应该说 一 二 三 四 五 六 七 八
Well, I should say, one, two, three, four, five, six, seven, eight top

472
00:21:34,390 --> 00:21:38,230
从左到右是我们床单上所有的精灵
left to bottom right of all the sprites in our sheet to make it

473
00:21:38,230 --> 00:21:40,990
看起来超级简单 
super easy to look at.

474
00:21:40,990 --> 00:21:42,480
我们这里还有一个功能 
We have another function here.

475
00:21:42,480 --> 00:21:45,940
默认情况下 Lua没有切片功能 但我们只是在添加它 
Lua doesn't by default, have a slice function, but we are just adding to it.

476
00:21:45,940 --> 00:21:47,200
桌子 切片 
Table.slice.

477
00:21:47,200 --> 00:21:52,390
它首先获取表 表中我们想要的第一个条目 
It takes the table a first, the first entry in the table that we want,

478
00:21:52,390 --> 00:21:54,940
最后一个条目 然后是它们之间的步骤 
the last entry, and then the step between them.

479
00:21:54,940 --> 00:22:00,160
就像Pythons切片函数一样 它只是迭代
Just like Pythons slice function, it just iterates over the

480
00:22:00,160 --> 00:22:02,500
For循环 这是倒数第一个循环 
for loop, which is first till one.

481
00:22:02,500 --> 00:22:10,270
因此 默认情况下只有一个 直到最后或者直到任何这样的数字符号
So one by default. Until the last or until whatever this sort of number sign

482
00:22:10,270 --> 00:22:13,450
是一张桌子的大小 我想我们还没有介绍过 
is the size of a table, which I don't think we've introduced yet.

483
00:22:13,450 --> 00:22:18,430
但基本上 如果我们最后通过 它就会止步于此 否则
But basically, if we pass in last, it'll stop there, otherwise just

484
00:22:18,430 --> 00:22:20,920
假设我们想要整个表 
assume we want the whole entire table.

485
00:22:20,920 --> 00:22:25,030
然后这个逗号在末尾 它有一步或一步 
And then this comma here at the end, which has step or one,

486
00:22:25,030 --> 00:22:28,600
您可以在for循环的末尾传入一个步骤作为第三个参数 
you can pass in a step at the end of a for loop as a third argument,

487
00:22:28,600 --> 00:22:33,710
这将会增加或减少你所处的循环 
and that will be however much increments or decrements the loop that you're in.

488
00:22:33,710 --> 00:22:35,000
因此 默认情况下 只有一个 
So by default, just one.

489
00:22:35,000 --> 00:22:37,540
我们先走一步 然后走到第二步 再走到第三步 
We go one, then we go to two, then we go to three.

490
00:22:37,540 --> 00:22:39,260
但您可以将其设置为负1 
But you can set it to negative one.

491
00:22:39,260 --> 00:22:42,370
所以如果你说四 我得到三减一 
And so if you say four i gets three to one minus one,

492
00:22:42,370 --> 00:22:44,260
你来三 二 一 
you'll go three, two, one.

493
00:22:44,260 --> 00:22:50,170
而且你不能正常地走一步 而我们这里就是这样做的 
And you can't do normally a step, which is what we do here.

494
00:22:50,170 --> 00:22:52,100
不 你可以走一步 但你不能切开 
No, you can do a step, but you can't slice,

495
00:22:52,100 --> 00:22:58,250
这就是为什么我们在这里以切片的数量加一得到表i 
which is why we have here sliced at number of slice plus one gets table i,

496
00:22:58,250 --> 00:22:59,750
然后最终我们返回Slice 
and then eventually we return slice.

497
00:22:59,750 --> 00:23:04,690
所以它只返回我们所在表的一部分 
So it just returns just a segment of whatever table we're in.

498
00:23:04,690 --> 00:23:07,270
然后这里的重要功能是 我们实际上
And then the important function here that we're actually

499
00:23:07,270 --> 00:23:11,440
要在我们的应用程序中使用 我们将生成四足桨 
going to use in our application, we're going to generate quads paddles.

500
00:23:11,440 --> 00:23:15,070
所以这需要X和Y 0和64 
And so this takes X and Y, 0 and 64.

501
00:23:15,070 --> 00:23:19,630
如果我们回过头来看我们的桨 我们
And if we look back at our paddles here, we

502
00:23:19,630 --> 00:23:22,100
可以看到我们有各种不同的尺码 
can see that we have various different sizes.

503
00:23:22,100 --> 00:23:25,690
所以我们有一个小的 一个中号的 一个大的 然后是一个非常大的 
So we have a small one, a medium one, a large one, and then a really large one.

504
00:23:25,690 --> 00:23:30,130
所以如果我们想把每一只桨都放在雪碧表上 
So if we want to get every single paddle in our sprite sheet,

505
00:23:30,130 --> 00:23:33,809
小、中、大、大 请注意 我们有四个街区
small, medium, large, giant, notice that we have four blocks

506
00:23:33,809 --> 00:23:36,350
在每一块中 我们有四种不同的大小 
and within each of those blocks we have four different sizes.

507
00:23:36,350 --> 00:23:38,200
所以我们可以重复这四次
So we can just iterate over this four times

508
00:23:38,200 --> 00:23:41,005
然后定义这个矩形的大小
and then just define whatever the size of this rect

509
00:23:41,005 --> 00:23:43,270
就是那个教区 那个教区 那个教区 
is, that rect, that rect, and that rect.

510
00:23:43,270 --> 00:23:45,850
我们将在这里看到它的数学计算 
And we'll see the math for it here.

511
00:23:45,850 --> 00:23:50,920
如果我从零到三 对我来说 从零到三 
If I go zero to three, for i, get zero till three.

512
00:23:50,920 --> 00:23:53,890
我们要继续 因为这会给我们四个 
We're going to go ahead because that will give us four.

513
00:23:53,890 --> 00:23:57,400
这就是我们要在精灵工作表上迭代的次数
So that's how many times we want to iterate over the sprite sheet

514
00:23:57,400 --> 00:24:00,010
才能得到单独的四元组 
to get the separate quads.

515
00:24:00,010 --> 00:24:01,990
我们会买最小的 
We'll get the smallest one.

516
00:24:01,990 --> 00:24:03,160
因此 四元组起了反作用 
So quads counter.

517
00:24:03,160 --> 00:24:05,080
我们将计数器初始化为1 
We initialize counter to one.

518
00:24:05,080 --> 00:24:11,980
得到了爱 图形 这个新的四边形在X Y 32和16 
Gets love.graphics, that new quad at X, Y, with the 32 and 16.

519
00:24:11,980 --> 00:24:16,960
哦 X和Y在这里默认为0和64 因为音符--
Oh, and X and Y default at 0 and 64 here because the note--

520
00:24:16,960 --> 00:24:21,880
回想一下 这里的这些都是16个高的 
recall that these are all 16 tall here.

521
00:24:21,880 --> 00:24:24,520
所以我们从64开始 所以我们从这里开始 
So we're starting Y at 64 so that we start right here.

522
00:24:24,520 --> 00:24:28,792
我们从零开始 因为它在左边 
And we're starting X at zero because it's on the left side.

523
00:24:28,792 --> 00:24:29,500
所以我们就这么做 
So we'll do that.

524
00:24:29,500 --> 00:24:31,780
我们会递增计数器 
We'll increment counter.

525
00:24:31,780 --> 00:24:34,150
把它调到32宽16高 
Get it at 32 wide by 16 tall.

526
00:24:34,150 --> 00:24:36,430
这些是最小的一个的实际尺寸 
Those are the actual dimensions of the smallest one.

527
00:24:36,430 --> 00:24:40,240
同样的逻辑也适用于中型和大型企业 
The same exact logic applies for medium and for large.

528
00:24:40,240 --> 00:24:44,560
只是我们加了32 然后我们把它改成64号 
Only that we're adding 32 and then we're making it size 64,

529
00:24:44,560 --> 00:24:49,420
然后我们在96号的X上加96 因为它们变宽了 
and then we're adding 96 to X at size 96 because they're getting wider,

530
00:24:49,420 --> 00:24:52,510
但他们也在更多地向右倾斜 
but they're also offsetting more to the right.

531
00:24:52,510 --> 00:24:56,830
最后一点和以前几乎一样 除了现在我们
And then the last bit is pretty much the same thing as before, except now we're

532
00:24:56,830 --> 00:25:01,960
将Y加16返回到X 因为我们在精灵工作表中排到了下一行
going Y plus 16 back to X because we've gone down a row in our sprite sheet

533
00:25:01,960 --> 00:25:06,580
此时的桨宽为128 但仍为16像素 
The paddle width at that point is 128, but still 16 pixels.

534
00:25:06,580 --> 00:25:13,280
然后在底部 因为我们想要做四次 
And then here at the bottom because we want to do this four times,

535
00:25:13,280 --> 00:25:16,030
我们想要检查的块实际上是32个像素
we want to go through the chunks are effectively 32 pixels

536
00:25:16,030 --> 00:25:19,350
因为我们要开到16 16 16 16 
because we're going 16, 16, 16, 16.

537
00:25:19,350 --> 00:25:23,080
我们要把32加到Y上 然后转到下一组四个球拍 
We're going to add 32 to Y and then go to the next set of four paddles.

538
00:25:23,080 --> 00:25:26,350
这就是我们如何有效地获得所有的划桨精灵 
So this is how we're effectively getting all of the paddle sprites,

539
00:25:26,350 --> 00:25:30,900
它们将从一个存储到X 我相信X是16 
and they;re going to be stored one through X where I believe X is 16.

540
00:25:30,900 --> 00:25:34,180
因此 我们将在精灵工作表中定义16个四边形
So we'll have 16 quads defined in our sprite sheet

541
00:25:34,180 --> 00:25:36,560
之后 我们就可以回来了 
thereafter that we can then return.

542
00:25:36,560 --> 00:25:43,640
所以我要回到主要的 Lua 现在在64行 
So I'm going to go back to main.lua now on line 64.

543
00:25:43,640 --> 00:25:47,321
这里我们有一个新的全局表 名为GFRAMES 
Here we have a new global table called gframes.

544
00:25:47,321 --> 00:25:49,820
我们将能够在任何想要画东西的地方访问它 
We'll be able to access this anywhere we want to draw stuff.

545
00:25:49,820 --> 00:25:52,010
这和我们刚刚看到的是一样的 
And it's just the same thing that we just saw.

546
00:25:52,010 --> 00:25:55,430
生成四足桨 我们只是在我们的主纹理中传递它 
Generate quads paddles, and we just pass it in our main texture.

547
00:25:55,430 --> 00:25:57,350
我们的主要质地是这个 
And our main texture is this.

548
00:25:57,350 --> 00:25:59,695
这是我们的主要纹理看起来是什么样子 
This is what our main texture looks like.

549
00:25:59,695 --> 00:26:01,070
然后我们要将其编入索引 
And then we're going to index it.

550
00:26:01,070 --> 00:26:04,610
我们会说它得到了关键的控制板 
We're going to say it gets the key paddles,

551
00:26:04,610 --> 00:26:10,400
因为在那个特定的桌子上只有我们的球拍的四个方格 
because in that particular table was just the quads for our paddles.

552
00:26:10,400 --> 00:26:14,330
因此 在将来 我们只需要调用love.graph ics.Drawing纹理 然后
So in the future, we just need to call love.graphics.drawtexture and then

553
00:26:14,330 --> 00:26:19,640
索引到框架划桨在任何我们想要的划桨 
index into gframes paddles at whatever paddle we want.

554
00:26:19,640 --> 00:26:24,440
这就是我们可以跟踪我们想要画的划桨明智的方式 
And that's how we can keep track of what we want to draw paddle wise.

555
00:26:24,440 --> 00:26:28,010
在这个特定的演示中 我们有一个新的Padle类
And in this particular demo we have a new paddle class

556
00:26:28,010 --> 00:26:30,380
因为划桨是我们比赛中的一件事 
because paddle is a thing in our game.

557
00:26:30,380 --> 00:26:33,390
我们可以将其表示为某种类或对象 
We can represent it as sort of a class or an object.

558
00:26:33,390 --> 00:26:36,599
所以我们将为它定义一个类 
So we'll define a class for it.

559
00:26:36,599 --> 00:26:38,140
到目前为止 一切都很简单 
Everything is pretty simple thus far.

560
00:26:38,140 --> 00:26:41,680
得到X和Y Dx随高度为零 
Gets an X and a Y. Dx is zero with height.

561
00:26:41,680 --> 00:26:42,470
皮肤 
Skin.

562
00:26:42,470 --> 00:26:45,800
皮肤将是什么颜色的 
The skin is going to be what color it is.

563
00:26:45,800 --> 00:26:47,300
我们需要跟踪这一点 
We need to keep track of that.

564
00:26:47,300 --> 00:26:51,440
然后是大小 因为大小将是我们排序的偏移量
And then the size, because size will be how we sort of offset

565
00:26:51,440 --> 00:26:56,540
进入我们的桨 我们的四肢 因为大小有小的 中等的 大的 巨大的 
into our paddles, our quads, because the sizes are small, medium, large, giant.

566
00:26:56,540 --> 00:26:58,306
一 二 三 四乘四 
One, two, three, four times four.

567
00:26:58,306 --> 00:27:00,680
所以第一盘一 二 三 四 然后五 
So one, two, three, four for the first set and then five,

568
00:27:00,680 --> 00:27:03,079
第二盘是六、七、八 
six, seven, eight for the second set.

569
00:27:03,079 --> 00:27:04,370
这些都是按颜色排列的 
Those are all sort of by color.

570
00:27:04,370 --> 00:27:07,140
所以我们可以乘以皮肤时间--
So we can just multiply skin times--

571
00:27:07,140 --> 00:27:12,050
或者我们可以通过皮肤来繁殖我们的体型
or we can multiply whatever our size is by skin

572
00:27:12,050 --> 00:27:15,710
这将为我们提供当前帧 即我们想要的当前四边形
and that will give us the current frame, the current quad that we want in order

573
00:27:15,710 --> 00:27:18,770
画到屏幕上 
to draw to the screen.

574
00:27:18,770 --> 00:27:21,040
然后在7号线上--
And then on line seven--

575
00:27:21,040 --> 00:27:23,000
这就是键盘输入 
so this is keyboard input here.

576
00:27:23,000 --> 00:27:24,340
我们以前见过的东西 
Stuff that we've seen before.

577
00:27:24,340 --> 00:27:28,570
如果我们按向左或向右 那么球拍应该会移动 
If we're pressing left or right, then the paddles should move.

578
00:27:28,570 --> 00:27:31,167
DX应设置为左侧或右侧 
Dx should be set left or right.

579
00:27:31,167 --> 00:27:32,000
我们想把它夹住 
We want to clamp it.

580
00:27:32,000 --> 00:27:33,770
我们看到了这个 我们也看到了这个 
We saw this, we've seen this as well.

581
00:27:33,770 --> 00:27:37,820
将输入夹在屏幕的左侧和右侧 
Clamp the input to the left and the right side of the screen.

582
00:27:37,820 --> 00:27:42,050
如果dx小于零 则执行math.max和math.min 否则
If the dx is less than zero, do math.max and math.min otherwise

583
00:27:42,050 --> 00:27:43,841
如果我们要向右移动 
if we're moving to the right.

584
00:27:43,841 --> 00:27:46,340
然后在这里 这实际上是我们将所有东西联系在一起的地方
And then here, this is actually where we tie it all together

585
00:27:46,340 --> 00:27:49,680
我们实际上使用四元组来在屏幕上绘制一些东西 
and we actually use the quads to draw something onto the screen.

586
00:27:49,680 --> 00:27:54,860
因此 我们将其命名为love.graph 只绘制我们的纹理 我们的主要纹理 
So we're calling love.graphics.draw just our texture, our main texture.

587
00:27:54,860 --> 00:28:01,280
然后在我们现在的大小 也就是两个人的球拍上画出格框 
And then gframes at paddles at our current size, which is two.

588
00:28:01,280 --> 00:28:07,760
默认情况下 我们想要中号外加四倍的
We want to by default have the medium size plus four times whatever

589
00:28:07,760 --> 00:28:10,080
我们的皮肤是负一 
our skin is, minus one.

590
00:28:10,080 --> 00:28:18,720
因此 如果我们的皮肤是蓝色皮肤 我们不会向它添加任何东西 
So if our skin is one, which is the blue skin, we won't add anything to it.

591
00:28:18,720 --> 00:28:20,370
只会是零的四倍 
It'll just be four times zero.

592
00:28:20,370 --> 00:28:22,790
但如果我们有下一个 就会是二减一 
But if we have the next one, it'll be two minus one,

593
00:28:22,790 --> 00:28:24,710
所以我们最终会在上面加4 
so we'll end up adding four to that.

594
00:28:24,710 --> 00:28:28,920
因为无论皮肤是什么 我们都要加四倍 
And because we're adding four to it times whatever that skin is,

595
00:28:28,920 --> 00:28:32,120
它基本上会把我们四个四边形放进去 
it will just basically put us four quads in,

596
00:28:32,120 --> 00:28:36,860
哪一个是下一个 完全一样的球拍 但下一个颜色 
which is the next, the exact same paddle, but the next color.

597
00:28:36,860 --> 00:28:41,360
最后 我们要看的是PlayState 
And then lastly what we'll look at here is the PlayState.

598
00:28:41,360 --> 00:28:44,777
所以我们之前只有StartState 但是现在我们
So we had just the StartState before, but now we

599
00:28:44,777 --> 00:28:47,110
我想测试一下 确保我们能画出一个桨 
want to actually test to make sure we can draw a paddle,

600
00:28:47,110 --> 00:28:48,450
在屏幕上移动
move it around the screen.

601
00:28:48,450 --> 00:28:50,630
所以我们要在这里实现一个简单的PlayState 
So we're going to implement a simple PlayState here.

602
00:28:50,630 --> 00:28:53,840
所以在第20行 我们只是打电话给self 桨得到桨 
So on line 20, we're just calling self.paddle gets paddle.

603
00:28:53,840 --> 00:28:56,220
我们正在初始化一个新的paddle对象 
We're initializing a new paddle object.

604
00:28:56,220 --> 00:28:58,970
然后我们也在跟踪这个
And then we're keeping track of also this

605
00:28:58,970 --> 00:29:01,610
就是一个简单的暂停演示
is a simple, like, pause demonstration.

606
00:29:01,610 --> 00:29:06,010
如果赛尔夫停顿了一下 那么--事实上是的 
If self.paused, then-- actually yeah.

607
00:29:06,010 --> 00:29:06,950
我说了自我停顿吗？
Did I say self.paused?

608
00:29:06,950 --> 00:29:07,240
是的
I did.

609
00:29:07,240 --> 00:29:07,490
好的.
OK.

610
00:29:07,490 --> 00:29:09,200
我只是没有初始化它 
I just don't initialize it to anything.

611
00:29:09,200 --> 00:29:15,440
我应该在这里把自己设为假的 
I should have set self.paused to false here.

612
00:29:15,440 --> 00:29:19,790
如果self.暂停了 我们将测试是否按下了空格 
If self.paused, we're going to test to see whether we're pressing space,

613
00:29:19,790 --> 00:29:22,910
如果是的话就取消暂停
and if we are, unpause it.

614
00:29:22,910 --> 00:29:26,360
否则 基本上只是做同样的事情反过来 
Otherwise, basically just do the same exact thing in reverse.

615
00:29:26,360 --> 00:29:31,580
如果我们按空格键 暂停游戏 播放声音 等等 
If we press space, pause the game, play a sound, et cetera.

616
00:29:31,580 --> 00:29:34,250
在第39行 我们将调用桨的更新 
Here on line 39, we're just going to call update on the paddle.

617
00:29:34,250 --> 00:29:37,049
记住 测试左输入还是右输入 
Which, just remember, test for left or right input.

618
00:29:37,049 --> 00:29:38,840
在这里我们希望能够逃离游戏 
Here we want to be able to escape the game,

619
00:29:38,840 --> 00:29:41,060
所以我们会有一个负责逃跑的人
so we're going to have a handler for escape.

620
00:29:41,060 --> 00:29:45,350
渲染第47行的桨 这将做爱 图形 绘制
Render the paddle on lines 47, which will do the love.graphics.draw

621
00:29:45,350 --> 00:29:47,480
和我们之前看到的一样 但它会使用
with a quad as we saw before, but it'll use

622
00:29:47,480 --> 00:29:52,160
皮肤和桨大小以索引到四边形瓦片片中
the skin and the size of that paddle to index into the quads tile sheet

623
00:29:52,160 --> 00:29:54,170
适当地 
appropriately.

624
00:29:54,170 --> 00:29:57,170
然后这里如果我们暂停了 我们就画
And then here if we're paused, let's just draw

625
00:29:57,170 --> 00:30:00,110
屏幕中间的一些文字写着“你好”
some text in the middle of the screen that just says Pause.

626
00:30:00,110 --> 00:30:01,400
我们用大号字体 
And we use the large font.

627
00:30:01,400 --> 00:30:04,316
所以我们现在可以继续演示 看看所有的东西都在一起 
So we can go ahead and demo this now and see everything come together.

628
00:30:08,190 --> 00:30:11,260
我们像以前一样有我们的StartState 
We have as before our StartState.

629
00:30:11,260 --> 00:30:13,711
但是如果我们按下Enter键 
But if we press Enter, now we go to our PlayState

630
00:30:13,711 --> 00:30:15,960
我们在屏幕底部有一个桨 
and we just have a paddle at the bottom of the screen.

631
00:30:15,960 --> 00:30:18,720
是2号 1号皮 
It's size two, skin one.

632
00:30:18,720 --> 00:30:19,740
只有蓝色的皮肤 
Just the blue skin.

633
00:30:19,740 --> 00:30:21,895
我们可以像这样左右移动 
And we can move it left or right like that.

634
00:30:21,895 --> 00:30:24,270
如果它击中屏幕的左侧 它会停止 
And if it hits the left side of the screen, it will stop.

635
00:30:24,270 --> 00:30:27,130
如果它击中屏幕的右侧 它也会停止 
And if it hits the right side of the screen, it will stop as well.

636
00:30:27,130 --> 00:30:30,180
所以我们已经取得了进展 但这是最基本的事情之一 
So we've made progress, but this is one of the fundamental things

637
00:30:30,180 --> 00:30:35,220
我今天要展示的是 就像 使用四元组和分类
I'd like to showcase today is just, like, using quads and categorizing

638
00:30:35,220 --> 00:30:38,160
他们 组织他们 并能够画出
them, organizing them, and being able to draw

639
00:30:38,160 --> 00:30:43,860
您的资产来自一个大的汇编图像 而不是跟踪
your assets from a large compiled image rather than keep track

640
00:30:43,860 --> 00:30:45,742
不管它拍下多少张照片 
of however many images it would take.

641
00:30:45,742 --> 00:30:47,700
你必须将它们全部命名并进行分类 
And you have to name all of them and sort them.

642
00:30:47,700 --> 00:30:49,270
这只会是一种巨大的痛苦 
It would just be a big pain.

643
00:30:49,270 --> 00:30:49,770
所以是的 
So yeah.

644
00:30:49,770 --> 00:30:52,500
当你有不止一个精灵的时候 肯定会继续前进 
Definitely going forward when you have more than one sprite,

645
00:30:52,500 --> 00:30:55,200
你想把它放在一张纸上 
you want to sort of put it together in one sheet,

646
00:30:55,200 --> 00:30:57,900
这就是我们实现这一目标的方法 
and that's how we can accomplish that.

647
00:30:57,900 --> 00:31:00,030
但我们没有砖头 这很可能是
But we don't have bricks, and this is probably

648
00:31:00,030 --> 00:31:05,380
除了球拍和球之外 突破的另一个主要组成部分 
the other big main component of Breakout besides the paddle and the ball.

649
00:31:05,380 --> 00:31:08,710
我们想要的是我们可以在屏幕上真正击中和瞄准的砖块 
We want to have bricks that we can actually hit and aim for on the screen.

650
00:31:08,710 --> 00:31:10,450
因此 此次更新将解决这一问题 
So this update will address that.

651
00:31:10,450 --> 00:31:16,430
那么让我们继续来看看Breakout2 in Main.Lua 
So let's go ahead and take a look at Breakout2 in main.lua.

652
00:31:16,430 --> 00:31:17,670
我要在这里把它打开 
I'm going to open it up here.

653
00:31:21,740 --> 00:31:29,600
在第66行 您可以看到在我们的GFrame中有一个新的表 
On line 66, you can see we have a new table in our gframes.

654
00:31:29,600 --> 00:31:32,266
因为我们有一个专门用来划桨的 所以我们就拿出来了
Because we had one just for paddles, we took out

655
00:31:32,266 --> 00:31:33,890
只有我们精灵床单上的球拍 
just the paddles from our sprite sheet.

656
00:31:33,890 --> 00:31:36,056
我们将对蛋蛋做同样的事情 
We're going to do the same thing for just the balls.

657
00:31:36,056 --> 00:31:38,070
所以我们要看--如果我们看这里 
So we're going to look at-- if we look here,

658
00:31:38,070 --> 00:31:43,100
我们可以看到 球是在这里的所有砖块之后出现的
we can see that the balls sort of come after all of the bricks here

659
00:31:43,100 --> 00:31:46,070
它们只是以八个像素宽乘八个像素来布置
and they're just laid out in eight pixels wide by eight

660
00:31:46,070 --> 00:31:48,500
像素高的增量在这里 
pixels tall increments here.

661
00:31:48,500 --> 00:31:52,070
所以四个像素对应一块砖 四个球对应一块砖 
So four pixels to one brick, four balls to one brick,

662
00:31:52,070 --> 00:31:56,610
两个球水平对一 然后垂直两个球 
two balls to one horizontally, and then two balls vertically.

663
00:31:56,610 --> 00:32:02,360
因此 我们最终要做的只是我们的实用程序中的一个简单函数
And so what we'll end up doing is just a simple function in our util

664
00:32:02,360 --> 00:32:04,530
我们来看看这一点 
that takes a look at that.

665
00:32:04,530 --> 00:32:08,570
因此 让我们继续查看我们的util.lua 我们已经对其进行了更改 
So let's go ahead and take a look at our util.lua, which we've made changes to.

666
00:32:14,120 --> 00:32:17,810
所以它要做的是做同样的事情
And so what this is going to do is sort of do the same thing

667
00:32:17,810 --> 00:32:20,540
就像我们以前做的那样 
that we did before.

668
00:32:20,540 --> 00:32:21,290
它必须迭代 
It has to iterate.

669
00:32:21,290 --> 00:32:23,850
所以请注意 我们有两排球 
So notice we have two rows of balls.

670
00:32:23,850 --> 00:32:26,030
我们有这四个 我们有这三个 
We have these four and we have these three.

671
00:32:26,030 --> 00:32:27,606
所以我们想要迭代四次 
So we want to iterate four times.

672
00:32:27,606 --> 00:32:29,480
你想知道这里的偏移量是多少 
You want to find whatever the offset is here,

673
00:32:29,480 --> 00:32:35,270
X和Y 所以看起来是3乘以32 然后是3乘以16 
the X and Y. So it looks like three times 32 and then three times 16.

674
00:32:35,270 --> 00:32:36,860
所以96乘以--
So 96 by--

675
00:32:36,860 --> 00:32:37,550
我不会做数学 
I can't do math.

676
00:32:37,550 --> 00:32:39,110
不管16乘以3是什么 
Whatever 16 times three is.

677
00:32:39,110 --> 00:32:40,700
然后我们就会变成48岁 
And then we'll end up 48.

678
00:32:40,700 --> 00:32:42,839
然后我们会有--
And then we'll have--

679
00:32:42,839 --> 00:32:43,880
这就是我们在这里所做的 
which is what we do here.

680
00:32:43,880 --> 00:32:46,187
所以我们有两次迭代 
So we have two iterations.

681
00:32:46,187 --> 00:32:48,020
所以从零到三的四个循环 
So a four loop that goes from zero to three.

682
00:32:48,020 --> 00:32:51,030
所以最上面的一排 四个 
So the top row, the four.

683
00:32:51,030 --> 00:32:52,990
我们在这里设一个柜台 
We'll set a counter to one here.

684
00:32:52,990 --> 00:32:54,641
还请注意96和48 
And notice also 96 and 48.

685
00:32:54,641 --> 00:32:56,390
这是我们设定的X和Y 
That's the X and the Y that we're setting.

686
00:32:56,390 --> 00:33:01,510
这就是各个球精灵的偏移量 
That's where the offset is for the individual ball sprites.

687
00:33:01,510 --> 00:33:03,710
柜台的四人组--
Quads at counter gets--

688
00:33:03,710 --> 00:33:05,330
请注意 四边形还有一张桌子 
and notice also quads is a table.

689
00:33:05,330 --> 00:33:06,650
我们要把这个退掉 
We're going to return this.

690
00:33:06,650 --> 00:33:10,630
在柜台的四人组得到了爱 
Quads at counter gets love.graphics.newquad at X, Y.

691
00:33:10,630 --> 00:33:12,230
八个像素宽 八个像素高 
Eight pixels wide, eight pixels tall.

692
00:33:12,230 --> 00:33:13,580
这就是球的大小 
That's how large the balls are.

693
00:33:13,580 --> 00:33:17,390
然后我们再加8 因为我们要向右转 
And then we're going to add eight to it because we're going to the right.

694
00:33:17,390 --> 00:33:20,960
所以这个迭代是从左到右的 
So this iteration just goes left to right.

695
00:33:20,960 --> 00:33:25,460
然后在这里 我们将基本上将X设置为96
And then here we're going to do basically X being set to 96

696
00:33:25,460 --> 00:33:27,900
然后Y变为56 
and then Y to 56.

697
00:33:27,900 --> 00:33:30,350
然后因为我们直接在这里编辑X 
And then because we were editing X directly in here,

698
00:33:30,350 --> 00:33:33,380
我们希望将X重置为96 但也要添加
we want to reset X back to 96, but then also add

699
00:33:33,380 --> 00:33:36,320
8个像素 这样我们就有了下一行的起点
the eight pixels so that we have the start for the next row

700
00:33:36,320 --> 00:33:38,840
纵向上 56日元也是如此 
vertically, so at Y 56.

701
00:33:38,840 --> 00:33:40,730
在这里做完全相同的事情 但只做
Do the exact same thing here, but only do it

702
00:33:40,730 --> 00:33:43,010
三次 因为回想一下 上面有四个球
three times because recall there is four balls on top

703
00:33:43,010 --> 00:33:44,720
然后是底部的三个球 
and then three balls on bottom.

704
00:33:44,720 --> 00:33:46,280
然后在最后还回来 
And then return it at the very end.

705
00:33:46,280 --> 00:33:49,250
所以现在我们只有一张单独的桌子 
And so now we have just an individual table.

706
00:33:49,250 --> 00:33:51,620
我们不需要像一张巨大的四边形餐桌一样 
We don't need to keep like one monstrous table of quads,

707
00:33:51,620 --> 00:33:53,360
我觉得这有点杂乱无章 
which I find sort of disorganized.

708
00:33:53,360 --> 00:33:57,950
我们可以只有一张划桨架的桌子 
We can just have a table of frames for the paddles,

709
00:33:57,950 --> 00:34:00,110
还有球 还有我们将会看到的砖头 
and the balls, and the bricks as we'll see.

710
00:34:02,930 --> 00:34:05,311
实际上 我想我把它放在这里了 
Actually, I have it up here I think.

711
00:34:05,311 --> 00:34:05,810
也许不会 
Maybe not.

712
00:34:08,900 --> 00:34:12,480
所以在舞会上--哦 实际上 等等 
So in ball-- oh, actually, hold on.

713
00:34:12,480 --> 00:34:12,980
抱歉的 
Sorry.

714
00:34:12,980 --> 00:34:14,030
所以我们在看--
So we were looking at--

715
00:34:17,540 --> 00:34:19,080
我不小心跳过了这一条 
I skipped over this one on accident.

716
00:34:19,080 --> 00:34:19,955
所以弹跳更新 
So the bounce update.

717
00:34:19,955 --> 00:34:22,370
所以我刚才说的每件事都是相关的 但我不小心
So everything I just said is relevant, but I accidentally

718
00:34:22,370 --> 00:34:23,840
向右打了两下 
hit that right two times.

719
00:34:23,840 --> 00:34:27,620
我们想要转到退回更新 因为这稍微简单一些 
We want to go to the bounce update because this is slightly simpler.

720
00:34:27,620 --> 00:34:30,699
所以我们只是在谈论球 这太完美了 
So we were just talking about the ball, which is perfect.

721
00:34:30,699 --> 00:34:33,949
所以我们要拿着球 然后我们要把它添加到场景中 
So we're going to take the ball and then we're going to add that to the scene,

722
00:34:33,949 --> 00:34:36,980
我们要做的就是从墙上跳起来 
and we're just going to implement bouncing off the walls.

723
00:34:36,980 --> 00:34:39,380
所以实际上 与代码几乎完全相同
So actually, pretty identical to the code

724
00:34:39,380 --> 00:34:43,040
我们看到了Pong 你只需要检测球是否有
we saw for Pong where you just detect whether the ball has

725
00:34:43,040 --> 00:34:45,985
超出屏幕的左、右或上边缘 
gone past the left, right, or top edge of the screen.

726
00:34:45,985 --> 00:34:48,860
在这种情况下 它还将允许我们转到屏幕底部
In this case, it will also allow us to go to the bottom of the screen

727
00:34:48,860 --> 00:34:51,290
我们还将实现与球拍的碰撞
and we'll also implement colliding with the paddle

728
00:34:51,290 --> 00:34:54,690
那么 你就可以感受到真正的游戏效果 以及那种感觉 
so then get a sense of the actual game play and what that feels like.

729
00:34:54,690 --> 00:34:57,920
所以目前一切都是最新的 
So everything is currently current.

730
00:34:57,920 --> 00:34:59,300
所以我们要去--
So we're going to go--

731
00:34:59,300 --> 00:35:03,712
在谈到实际拿到个人球的功能后
after talking about the function to actually get the individual ball

732
00:35:03,712 --> 00:35:05,420
从电子表格中拿出四元组 我们要
quads out of the spreadsheet, we're going

733
00:35:05,420 --> 00:35:10,140
来看看球类 它将允许我们在场景中产生它们 
to look at the ball class which is going to allow us to spawn them in our scene.

734
00:35:10,140 --> 00:35:12,310
所以球的宽度和高度都是8 
So a ball takes a width and height of eight.

735
00:35:12,310 --> 00:35:13,490
没有速度 
No velocity.

736
00:35:13,490 --> 00:35:17,600
但我们将允许我们自己使用皮肤来初始化球 
But we're going to allow ourselves to initialize the ball with the skin,

737
00:35:17,600 --> 00:35:21,010
我们稍后会看到这是一个可爱的小东西给你
and we'll see this later just as a cutesy little thing to you

738
00:35:21,010 --> 00:35:24,550
使用实际的单个精灵 而不只是一个恒定的精灵 
use the actual individual sprites rather than just one constant sprite.

739
00:35:24,550 --> 00:35:27,740
我们只会给它一个介于1和7之间的随机数
We're just going to give it a random number between one and seven

740
00:35:27,740 --> 00:35:30,110
因为有七个四边形 
because there are seven quads.

741
00:35:30,110 --> 00:35:35,300
然后我们将只使用格框、球和数学点随机数
And then we'll just use gframes balls and math dot random number

742
00:35:35,300 --> 00:35:38,657
才能得到我们想要的真正的球面 
to get the actual ball spread that we want.

743
00:35:38,657 --> 00:35:40,865
所以我们在球内有一个简单的碰撞函数
And so we have a simple collides function within ball

744
00:35:40,865 --> 00:35:45,290
这将允许我们检查是否与某个物体相撞
that would allow us to check to see whether we've collided with something

745
00:35:45,290 --> 00:35:47,180
它具有X、Y宽度和高度 
that has a X, Y width and a height.

746
00:35:47,180 --> 00:35:54,620
所以这是一个简单的A B碰撞检测 
So it's a simple A, B collision detection.

747
00:35:54,620 --> 00:35:56,609
然后在这里我们有重置 
And then here we have reset.

748
00:35:56,609 --> 00:35:58,400
只需将其重置到屏幕中央即可 
Just resets it to the middle of the screen.

749
00:35:58,400 --> 00:35:59,840
更新应用速度 
Update applies velocity.

750
00:35:59,840 --> 00:36:02,420
我们已经看过的东西 
Stuff we've already seen.

751
00:36:02,420 --> 00:36:05,010
这就是我们真正实现弹离墙壁的地方 
This is where we actually implement bouncing off the walls.

752
00:36:05,010 --> 00:36:07,370
因此 如果X小于或等于零 则大于
So if X is less than or equal to zero, greater than

753
00:36:07,370 --> 00:36:11,180
或等于虚拟宽度减8 或小于或等于零 
or equal to virtual width minus eight, or less than or equal to zero,

754
00:36:11,180 --> 00:36:14,660
这应该是我们反转速度的地方 
this should be where we reverse the velocity.

755
00:36:14,660 --> 00:36:18,380
在它从左侧反弹的情况下 我们想要反转X速度
In the case of it bouncing off the left side, we want to reverse the X velocity

756
00:36:18,380 --> 00:36:19,370
但要继续往上走 
but keep it going up.

757
00:36:19,370 --> 00:36:21,200
如果它击中顶部 那么我们想要反转
If it hits the top, then we want to reverse

758
00:36:21,200 --> 00:36:24,200
Y速度 以保持它朝任何方向移动 
the Y velocity to keep it moving in whatever direction it was moving.

759
00:36:24,200 --> 00:36:27,620
右手边的墙也是这样 
And same thing with the right hand wall.

760
00:36:27,620 --> 00:36:29,150
然后播放一段墙壁上的热门音乐 
And then play a wall hit sound.

761
00:36:29,150 --> 00:36:31,790
我们在今天的节目中融入了这些声音
And we're incorporating the sounds sort of as we go today

762
00:36:31,790 --> 00:36:33,420
就因为它们太简单了 
just because they're so simple.

763
00:36:33,420 --> 00:36:35,360
仅仅得到一点反馈也是很好的
And it's also kind of nice just to have a little bit of feedback

764
00:36:35,360 --> 00:36:37,130
当你实际上是游戏的终点时 
when you're actually endpoint of the game.

765
00:36:37,130 --> 00:36:39,290
这里的绘图代码与此完全相同 
And the exact same code is here for drawing.

766
00:36:39,290 --> 00:36:43,040
所以我们有主纹理 但现在我们使用的是GFrame球 
So we have main texture, but now we're using gframes balls,

767
00:36:43,040 --> 00:36:46,100
然后我们在self.kin上对其进行索引 
and then we're indexing that at self.skin.

768
00:36:46,100 --> 00:36:48,179
回想一下 我们刚刚在这里设置了self.kin 
And recall that we just set self.skin in here.

769
00:36:48,179 --> 00:36:49,970
所以我们要做的就是把它随机
So all we need to do to just make it random

770
00:36:49,970 --> 00:36:53,660
就是在我们创造一个新球的任何地方 给它一个数学运算 
is just wherever we create a new ball, just give it a math.random7,

771
00:36:53,660 --> 00:36:57,170
然后 它将索引到那个四元表中
and then that will index into that quads table

772
00:36:57,170 --> 00:37:01,380
这样我们每次都可以画出不同的球纹理 
so we can draw a different ball texture each time.

773
00:37:01,380 --> 00:37:03,170
所以让我们继续下去 看看--
And so let's go ahead and see--

774
00:37:03,170 --> 00:37:03,890
哦 事实上 不是的 
oh, actually, no.

775
00:37:03,890 --> 00:37:06,320
我们需要关注的最后一件事是PlayState
And one last thing we need to look at is the PlayState

776
00:37:06,320 --> 00:37:09,471
也有一些新的代码 
has a little bit of new code as well.

777
00:37:09,471 --> 00:37:11,970
我们要生一个球 所以这就是我们要做的 
We're going to spawn a ball, so this is where we do it here.

778
00:37:11,970 --> 00:37:14,886
我不是随机做的 但如果我想的话 我可以在这里随机做 
I'm not doing it random, but I could do it random here if I wanted to.

779
00:37:14,886 --> 00:37:17,297
我可以算术 随机7 而且每次我们启动的时候
I could math.random7, and every time we boot up

780
00:37:17,297 --> 00:37:19,630
这个游戏将会是不同的颜色 因为它
the game it's going to be a different color because it's

781
00:37:19,630 --> 00:37:22,646
将会是一张不同的皮肤 
going to be a different skin.

782
00:37:22,646 --> 00:37:23,770
我们需要更新一下球 
We need to update the ball.

783
00:37:23,770 --> 00:37:26,500
因此 在第50行 我们只需更新它 就像我们处理划桨一样 
So on line 50 we just update it like we do the paddle.

784
00:37:26,500 --> 00:37:29,560
然后在第52行 我们只是测试一下
And then on line 52, we're just testing to see

785
00:37:29,560 --> 00:37:32,661
它是否与球拍相撞 因为我们只用了简单的A 
whether it collides with the paddle because we're using just simple A,

786
00:37:32,661 --> 00:37:36,790
如果它与球拍相撞 我们就可以假定它正在坠落 
A, B, B. If it collides with the paddle, we can assume it was coming down.

787
00:37:36,790 --> 00:37:38,540
我们可以反转为增量Y 
We can just reverse as delta Y.

788
00:37:38,540 --> 00:37:43,030
现在 有谁知道什么可能是当前的问题
Now, does anybody know what might be a current issue

789
00:37:43,030 --> 00:37:46,760
该函数的当前实现情况如何？
with the current implementation of this function?

790
00:37:46,760 --> 00:37:48,880
尤其是这条线 
Particularly with this line.

791
00:37:51,766 --> 00:38:01,284
观众：[听不见]
AUDIENCE: [INAUDIBLE]

792
00:38:01,284 --> 00:38:02,200
科尔顿·奥格登：会的 
COLTON OGDEN: It will.

793
00:38:02,200 --> 00:38:03,283
你走上了正确的道路 
You're on the right track.

794
00:38:03,283 --> 00:38:06,880
答案是 如果球是从侧面传来的 
The answer was, if the ball is coming from the side,

795
00:38:06,880 --> 00:38:11,082
它不一定会在正确的Y方向反弹回来 
it won't necessarily be bounced back up in the right Y direction.

796
00:38:11,082 --> 00:38:13,540
如果它是从侧面来的 在这种情况下 它总是 
If it's coming from the side, it will always, in this case,

797
00:38:13,540 --> 00:38:15,170
是从上面来的 
be coming from up above.

798
00:38:15,170 --> 00:38:17,890
因此 在右增量Y中 它总是在倒转 
So it always still be reversing in the right delta Y.

799
00:38:17,890 --> 00:38:22,090
但如果它以一个角度进入会发生什么
But what's going to happen if it comes in at an angle

800
00:38:22,090 --> 00:38:28,840
然后基本上不是重置了吗？
and then isn't basically reset?

801
00:38:28,840 --> 00:38:31,990
就像现在 如果它从一个角度来 它
Like right now if it comes at an angle and it

802
00:38:31,990 --> 00:38:36,640
被抓到了--比方说它就像是在桨的顶端下方 
gets caught-- let's say it's like below the top edge of the paddle.

803
00:38:36,640 --> 00:38:37,840
观众：[听不见]
AUDIENCE: [INAUDIBLE]

804
00:38:37,840 --> 00:38:40,352
科尔顿·奥格登：你会有一个无限的碰撞
COLTON OGDEN: You're going to get an infinite collision

805
00:38:40,352 --> 00:38:42,310
循环 因为我们没有重置它的位置 
loop because we're not resetting it's position,

806
00:38:42,310 --> 00:38:44,230
我们只是在更新它的速度 
we're only updating its velocity.

807
00:38:44,230 --> 00:38:46,630
如果它从侧面以正确的角度进入 
If it comes in at the right angle from the side,

808
00:38:46,630 --> 00:38:50,101
它会卡在球拍里
it's going to get stuck inside the paddle

809
00:38:50,101 --> 00:38:52,600
然后 它会导致一些时髦的行为 
and then it's going to cause a little bit of funky behavior.

810
00:38:52,600 --> 00:38:55,690
我会试着在我的演示中实现这一点 
I'll try and see if I can make that happen in my demonstration here.

811
00:38:55,690 --> 00:38:58,300
但这就是所有这些更新的要点 
But that's the gist of all of these updates.

812
00:38:58,300 --> 00:39:02,620
因此 如果我们开始 我们可以立即看到我们有一个球 
So if we go to Start, we can see immediately we have a ball.

813
00:39:02,620 --> 00:39:05,999
当它撞到侧面或顶部时 它会相应地反弹 
And when it hits the sides or the top, it bounces accordingly.

814
00:39:05,999 --> 00:39:06,790
它击中了球拍 
It hits the paddle.

815
00:39:06,790 --> 00:39:11,420
因此 当它从顶部进入时 它会翻转Y速度 
So when it comes in from the top flush on the top, it flips the Y velocity.

816
00:39:11,420 --> 00:39:14,620
让我们看看我能不能从这个角度拍到它 
Let's see if I can get it at an angle here.

817
00:39:14,620 --> 00:39:15,520
这就是了 
There it is.

818
00:39:15,520 --> 00:39:17,150
它会卡住的 
It'll get stuck.

819
00:39:17,150 --> 00:39:22,120
所以每当你进行A、A、B、B碰撞检测时 
And so whenever you sort of do A, A, B, B collision detection,

820
00:39:22,120 --> 00:39:25,810
只要记住总是重置它的位置就行了
just remember to always reset the position of whatever it

821
00:39:25,810 --> 00:39:29,020
它是被碰撞的 正在移动的 所以它不会卡住
is that collided that's moving so that it doesn't clip

822
00:39:29,020 --> 00:39:31,611
一次又一次地被困在别的东西里 
and get stuck inside of something else over and over again.

823
00:39:31,611 --> 00:39:32,110
是 
Yes.

824
00:39:32,110 --> 00:39:42,190
观众：[听不见]
AUDIENCE: [INAUDIBLE]

825
00:39:42,190 --> 00:39:45,610
科尔顿·奥格登：问题是我一直在做爱情空间点 
COLTON OGDEN: The question is I'm always doing love space dot,

826
00:39:45,610 --> 00:39:50,050
而不是仅仅使用
and as opposed to just running things from using

827
00:39:50,050 --> 00:39:55,030
任何文件的完整路径 为了做到这一点--您也是
the complete path of whatever the file is, in order to do that-- so are you

828
00:39:55,030 --> 00:39:56,320
在Mac还是Windows机器上？
on a Mac or a Windows machine?

829
00:39:56,320 --> 00:39:57,450
观众：[听不见]
AUDIENCE: [INAUDIBLE]

830
00:39:57,450 --> 00:40:01,780
科尔顿·奥格登：所以在Windows系统上 这就有点棘手了 
COLTON OGDEN: So on a Windows machine it is a little trickier,

831
00:40:01,780 --> 00:40:07,390
但我已经找到了一种非常好的VS代码插件 
but I've found a really nice sort of plug-in for VS Code.

832
00:40:07,390 --> 00:40:11,650
因此 如果您使用的是VS Code 这是我使用的编辑器 它有插件
So if you're VS Code, which is the editor that I use, it has plug-ins

833
00:40:11,650 --> 00:40:14,830
你可以下载的其中一个插件是Love2D
and one of the plug-ins that you can download is for Love2D

834
00:40:14,830 --> 00:40:19,210
它有一个配置 如果你只需按下Alt L 
and it has a config where if you just press Alt L,

835
00:40:19,210 --> 00:40:22,240
它将运行您当前所在目录 
it will run whatever directory you're currently in,

836
00:40:22,240 --> 00:40:24,260
无论你目前参与的是什么项目 
whatever project you're currently in.

837
00:40:24,260 --> 00:40:25,780
它将呼唤爱 
It will call Love.

838
00:40:25,780 --> 00:40:27,470
它会为你把它添加到你的道路上 
It adds it to your path for you.

839
00:40:27,470 --> 00:40:31,810
因此 如果您想让它工作 请下载VS代码上的Love2D插件 
So download the Love2D plug-in on VS code if you want that to work.

840
00:40:31,810 --> 00:40:34,990
我在Mac上 所以我可以编辑我的批次配置文件 
I'm on a Mac, so I can edit what's called my batch profile,

841
00:40:34,990 --> 00:40:40,970
并将其别名Love添加到我文件系统中的完整路径 
and alias Love to its complete path in my file system.

842
00:40:40,970 --> 00:40:43,880
你也可以做同样的事情--
And you can do the same thing with--

843
00:40:43,880 --> 00:40:48,280
我不知道Windows在别名方面是如何工作的 
I don't know how it would work with Windows in terms of aliasing,

844
00:40:48,280 --> 00:40:52,540
但从本质上讲 这与输入通向爱的整个道路是一样的 
but it's essentially the same thing as typing out the entire path to Love,

845
00:40:52,540 --> 00:40:55,120
不过 我要换个词 
but only I'm changing it to another word.

846
00:40:55,120 --> 00:40:56,790
我要把它改成爱 
I'm changing it to Love.

847
00:40:56,790 --> 00:40:59,680
所以我将Love设置为应用程序斜杠
So I'm setting Love equals to application slash

848
00:40:59,680 --> 00:41:02,870
Love.app/内容/资源等 
love.app/content/resources et cetera.

849
00:41:02,870 --> 00:41:04,150
问得好 
So good question.

850
00:41:04,150 --> 00:41:05,560
我会在Windows上下载 
I would download on Windows.

851
00:41:05,560 --> 00:41:07,720
我是VS Code和Love2D插件的铁杆粉丝 
I'm a big fan of VS Code and the Love2D plug-in.

852
00:41:07,720 --> 00:41:09,427
我建议你调查一下这个问题 
I would recommend looking into that.

853
00:41:09,427 --> 00:41:12,010
我相信还有其他插件 还有一个页面
And I'm sure there are other plug-ins, and there's a page also

854
00:41:12,010 --> 00:41:13,611
在网站上--
on the website--

855
00:41:13,611 --> 00:41:15,360
我目前没有打开浏览器 
I don't have a browser open at the moment.

856
00:41:15,360 --> 00:41:19,330
但在维基上 你可以看到入门页面 
But on the wiki, you can look at the Getting Started page.

857
00:41:19,330 --> 00:41:21,606
我相信这就像是love2d.com/wiki/gettingstarted 
I believe it's like love2d.com/wiki/gettingstarted.

858
00:41:21,606 --> 00:41:23,980
他们有一堆不同操作的说明
They have a bunch of instructions for different operating

859
00:41:23,980 --> 00:41:26,521
允许您进行排序的系统和不同的文本编辑器
systems and different text editors that allow you to get sort

860
00:41:26,521 --> 00:41:29,750
更高效的工作流程 
of a more efficient workflow going.

861
00:41:29,750 --> 00:41:34,590
还有其他问题吗？
So any other questions?

862
00:41:34,590 --> 00:41:35,580
好的 
All right.

863
00:41:35,580 --> 00:41:38,130
所以我们做了弹跳更新 
So we did the bounce update.

864
00:41:38,130 --> 00:41:40,780
现在我们终于可以编辑砖块了 
Now we can finally edit the bricks.

865
00:41:40,780 --> 00:41:42,420
我要说的是 再加上砖头 
Add in the bricks, I should say.

866
00:41:42,420 --> 00:41:44,880
所以这些都很简单 
So these are pretty simple.

867
00:41:44,880 --> 00:41:47,264
所以我们要来看看它 
So we're going to take a look at it.

868
00:41:47,264 --> 00:41:50,430
现在我们不会做任何花哨的程序世代 
And right now we're not going to do any sort of fancy procedural generation,

869
00:41:50,430 --> 00:41:52,980
我们只是要在屏幕上放几块砖 
we're just going to get some bricks on the screen.

870
00:41:52,980 --> 00:41:55,509
只是一些简单的砖块 
Just some easy bricks.

871
00:41:55,509 --> 00:41:58,050
或者更确切地说 我们将得到一些非常基本的程序性生成 
Or rather, we will get some very basic procedural generation,

872
00:41:58,050 --> 00:41:59,758
但不会达到我们很快就会看到的水平 
but not to the level that we'll see soon.

873
00:41:59,758 --> 00:42:01,660
我们很快就会看到这一点 
We'll see that very soon.

874
00:42:01,660 --> 00:42:02,160
好的 
OK.

875
00:42:02,160 --> 00:42:05,940
所以我要进入我的主 Lua在这里 
So I'm going to go into my main.lua here.

876
00:42:05,940 --> 00:42:08,400
我要进入《越狱3》 
I'm going to go into the Breakout3.

877
00:42:12,250 --> 00:42:15,310
和我们之前在第67行做的相同的事情 
And same thing that we did before on line 67,

878
00:42:15,310 --> 00:42:19,920
我们的框架里只有一张新的砖桌 
we just have a new bricks table in our gframes.

879
00:42:19,920 --> 00:42:21,640
它只会产生四边形的砖块 
And it just generate quads bricks.

880
00:42:21,640 --> 00:42:25,840
我们从util.lua调用 所以我们也可以快速查看它 
We call from util.lua, so we can look at that really quick as well.

881
00:42:25,840 --> 00:42:28,270
这个其实很简单 
This one's actually really easy.

882
00:42:28,270 --> 00:42:30,310
Sourceutil.Lua
Sourceutil.lua.

883
00:42:30,310 --> 00:42:33,790
因为它们从屏幕的最顶端开始 
Because they start at the very top of the screen,

884
00:42:33,790 --> 00:42:37,720
我们可以假设--我们可以有效地
we can assume that-- we could effectively

885
00:42:37,720 --> 00:42:40,270
把这整件事当做是这些
treat this whole thing as if it were just these

886
00:42:40,270 --> 00:42:43,720
并且只生成宽度和高度恒定的四边形
and just generate quads at a constant width and height

887
00:42:43,720 --> 00:42:47,530
因为 实际上 我们只需要正在生成的帧的一个子集 
because, effectively, we only need a subset of the frames that's generating.

888
00:42:47,530 --> 00:42:52,130
因为它是这样产生它们的 从上到下 从左到右 
Because it's generating them this way, top to bottom, left to right,

889
00:42:52,130 --> 00:42:55,500
我们可以一直抓取到这里 用
we can just grab all the way up to here using

890
00:42:55,500 --> 00:42:59,020
表 切片 我们之前看到的 而不是
table.slice, which we saw before, and not

891
00:42:59,020 --> 00:43:01,720
担心索引到任何奇怪的 比如 
worry about indexing into any weird, like,

892
00:43:01,720 --> 00:43:04,450
具有需要按顺序编制索引的任何常量X和Y
having any constants X and Y that we need to index with in order

893
00:43:04,450 --> 00:43:05,620
以获得补偿 
to get an offset.

894
00:43:05,620 --> 00:43:07,730
我们可以做一个非常简单的--
We can just do a very simple--

895
00:43:07,730 --> 00:43:15,460
如果我们往下到第57行 生成四块砖 它只做一张表 切片 
if we go down to line 57, generate quads bricks, it just does a table.slice.

896
00:43:15,460 --> 00:43:19,400
在此基础上 我们将生成四元地图集32 16 
And so within that, we're going to generate quads atlas 32,16.

897
00:43:19,400 --> 00:43:23,440
这将产生将我们的精灵工作表除以32的效果
So this is going to have the effect of dividing up our sprite sheet by 32

898
00:43:23,440 --> 00:43:24,730
以16块为单位 
by 16 pieces.

899
00:43:24,730 --> 00:43:27,010
它会很好地产生所有这些 
It's going to generate all of these just fine,

900
00:43:27,010 --> 00:43:30,076
但它会在这里 这里有四个四边形
but then it's going to have quads here, here, here, here, here

901
00:43:30,076 --> 00:43:32,200
与你在这里看到的四边形不对齐
that don't line up with the quads that you see here

902
00:43:32,200 --> 00:43:36,889
因为它只是盲目地假设那张纸上的所有精灵
because it's just blindly assuming that all of the sprites in that sheet

903
00:43:36,889 --> 00:43:38,930
都是一样的大小 因为这就是我们要做的 
are the same size because that's all we're doing.

904
00:43:38,930 --> 00:43:41,410
我们只是调用生成四元组 如果您还记得的话 
We're just calling generate quads, which if you recall,

905
00:43:41,410 --> 00:43:46,300
只是在我们的整个地图集中生成固定大小的宽度和高度 
just generates a fixed size width and height throughout our entire atlas,

906
00:43:46,300 --> 00:43:49,290
这对于许多对称的床单来说是很棒的 
which is great for a lot of sheets that are symmetrical,

907
00:43:49,290 --> 00:43:52,270
但在某些情况下 比如在这里 
but there are cases where we have, like, for example here, where

908
00:43:52,270 --> 00:43:53,929
我们的电子表格是不对称的 
our spreadsheet is asymmetrical.

909
00:43:53,929 --> 00:43:55,720
我们有不同大小的球拍 我们有
We have paddles of differing sizes, we have

910
00:43:55,720 --> 00:43:58,011
八乘八的球 我们有砖头 
the balls which are eight by eight, we have the bricks,

911
00:43:58,011 --> 00:44:01,840
我们在底部有其他加电装置 
we have the other power ups at the bottom.

912
00:44:01,840 --> 00:44:05,920
但生成的四边形砖块占据了那张桌子
But the generate quads bricks takes in that table

913
00:44:05,920 --> 00:44:08,769
我们正在生成的 这将是一堆帧
that we're generating, which is going to be a bunch of frames

914
00:44:08,769 --> 00:44:09,560
这是我们不想要的 
that we don't want.

915
00:44:09,560 --> 00:44:11,650
他们中的许多人剪掉了 一半剪掉了 
Many of them clipped, half clipped.

916
00:44:11,650 --> 00:44:14,120
然后我们就把它从1变为21 
And then we're just going to take it from one to 21.

917
00:44:14,120 --> 00:44:18,500
当我们这样做的时候 1到21实际上是--这就是这些
And when we do that, one to 21 is effectively-- that's how many of these

918
00:44:18,500 --> 00:44:19,000
确实有 
there are.

919
00:44:19,000 --> 00:44:22,270
所以是18 然后是1 2 3 
So 18 and then one, two, three.

920
00:44:22,270 --> 00:44:24,434
所以从1到21 所有这些都是 
So from one to 21, all of those.

921
00:44:24,434 --> 00:44:25,600
这将是所有的砖 
That will be all the bricks.

922
00:44:25,600 --> 00:44:28,270
我们可以扔掉所有剩下的四边形
We can throw away all the rest of the quads

923
00:44:28,270 --> 00:44:33,310
然后盲目地假设它们都是一样大小的 
and just blindly assume that they're all the same size.

924
00:44:36,450 --> 00:44:41,090
那么 对于四元组如何工作或这些桌子是如何工作的 有什么问题吗？
So any questions on how quads or how any of these tables are working?

925
00:44:41,090 --> 00:44:41,590
好的 
OK.

926
00:44:44,075 --> 00:44:45,200
所以我们要继续下去 
So we're going to go ahead.

927
00:44:45,200 --> 00:44:47,200
我们现在有一个新的班级 布里克·卢亚 
We have a new class now, brick.lua.

928
00:44:49,750 --> 00:44:52,600
如此简单的积木 
So simple building blocks.

929
00:44:52,600 --> 00:44:57,160
在第30行的brick.lua中 我们有一面名为in play的旗帜 
In brick.lua on line 30, we have a flag called in play.

930
00:44:57,160 --> 00:44:58,574
自我陶醉成真 
self.inplay gets true.

931
00:44:58,574 --> 00:45:00,490
所以我们只需要用这个来渲染 
And so we're just going to use this to render.

932
00:45:00,490 --> 00:45:02,800
我们只想说 如果它在起作用 就渲染它 
We're just going to say, if it's in play, render it.

933
00:45:02,800 --> 00:45:04,160
如果不是 则不要呈现它 
If it's not, don't render it.

934
00:45:04,160 --> 00:45:04,869
就这么简单 
It's that simple.

935
00:45:04,869 --> 00:45:08,035
这样我们就不必担心对象重新分配或任何花哨的事情了 
That way we don't have to worry about object deallocation or anything fancy.

936
00:45:08,035 --> 00:45:10,270
我们已经准备好了所有的砖块 以及它是否正在发挥作用
We have all of our bricks and whether it's in play

937
00:45:10,270 --> 00:45:12,310
或者不是 呈现它或执行更新逻辑 
or not, render it or perform update logic.

938
00:45:12,310 --> 00:45:14,980
如果它不存在 就假装它不存在 
And if it's not in play, just pretend it doesn't exist.

939
00:45:14,980 --> 00:45:17,560
忽略它就好 
Just ignore it.

940
00:45:17,560 --> 00:45:21,220
我们只会有30人 或者我不知道有多少人 
We're only going to have like 30 or I don't know how many,

941
00:45:21,220 --> 00:45:26,860
在我们的场景中 一次最多13 x 4块砖 所以担心内存释放
13 max by four bricks in our scene at once, so worrying about freeing memory

942
00:45:26,860 --> 00:45:28,070
其实并不是什么问题 
isn't really an issue.

943
00:45:28,070 --> 00:45:34,150
但是如果你有一百万种不同的东西一直在产生 
But if you have a million different things getting generated all the time,

944
00:45:34,150 --> 00:45:37,480
在游戏中拥有简单可能并不总是错误的
having simple in play is false might not always

945
00:45:37,480 --> 00:45:40,730
这是可行的 因为您需要存储所有这些对象的所有内存 
be viable because you need to store all that memory for all those objects.

946
00:45:40,730 --> 00:45:44,920
所以这里只是一条捷径 但不一定是最好的
So just a shortcut here, but not necessarily best

947
00:45:44,920 --> 00:45:47,080
为大型比赛做练习 
practice for very large games.

948
00:45:47,080 --> 00:45:49,870
但对于小游戏来说 这无疑是既好又简单的 
But certainly great and simple for small games.

949
00:45:53,340 --> 00:45:56,350
在第37行 我们定义了一个名为Brick Hit的函数 
On line 37, we define a function called brick hit.

950
00:45:56,350 --> 00:46:00,520
所有这些都只是播放音效 并将其设置为假 
And all this does is just play a sound effect and set in play to false.

951
00:46:00,520 --> 00:46:03,430
所以我们要做的就是检查
And so all we're going to do is just check

952
00:46:03,430 --> 00:46:06,940
来查看是否存在冲突 然后调用此Hit函数 
to see whether there's a collision and then just call this hit function,

953
00:46:06,940 --> 00:46:10,990
播放一个声音 然后假装它不再存在 
play a sound, and then just pretend it doesn't exist anymore.

954
00:46:10,990 --> 00:46:15,010
然后渲染 渲染所做的就是如果它正在播放 检查正在播放的标志 
And then render, all render does is if it's in play, check the in play flag,

955
00:46:15,010 --> 00:46:23,425
在砖块处绘制Main 或使用我们创建的砖桌 
draw main at bricks or using our bricks table here that we created.

956
00:46:23,425 --> 00:46:25,300
然后我们从一点开始 然后
And then we're going to start at one and then

957
00:46:25,300 --> 00:46:30,020
我们将根据我们的颜色减去1乘以4来索引它 
we're going to index it based on our color minus one times four,

958
00:46:30,020 --> 00:46:31,630
然后我们要添加它的层 
and then we're going to add it's tier.

959
00:46:31,630 --> 00:46:36,490
所以 如果你还记得的话 有一 二 三 四 
So there are, if you recall, one, two, three, four,

960
00:46:36,490 --> 00:46:41,380
五种颜色 四个层次 
five colors and four tiers.

961
00:46:41,380 --> 00:46:44,380
所以我们要做的是在不同的颜色之间跳跃 
And so what we're going to do is we're going to jump between the colors.

962
00:46:44,380 --> 00:46:49,840
所以我们会得到值1 值2 值3 值4 值5 
So we'll go value one, value two, value three, value four, value five.

963
00:46:49,840 --> 00:46:52,450
这将是我们的前五个 或者我想是六个 
That will be our first five or I guess six.

964
00:46:52,450 --> 00:46:55,690
这将是我们的头六块砖 
That will be our first six bricks.

965
00:46:55,690 --> 00:46:59,099
然后我们将开始一 二 三--或者我们将添加 
And then we're going to go one, two, three-- or we're going to add,

966
00:46:59,099 --> 00:47:00,640
我们基本上会有一个层次 
we're going to have a tier basically.

967
00:47:00,640 --> 00:47:04,030
可能是一、二、三或四 
It'll be one, two, three, or four.

968
00:47:04,030 --> 00:47:07,780
如果是在第一级 那么我们可以添加--
And if it's at tier one, then we can just add--

969
00:47:07,780 --> 00:47:10,000
基本上是索引到我们所在的任何一层 
basically to index into whatever tier we're on,

970
00:47:10,000 --> 00:47:13,870
无论我们的索引是什么 我们只需添加减一级即可 
we just need to add tier minus one to whatever our index is.

971
00:47:13,870 --> 00:47:17,050
所以在这里 如果我们的层是一层 那么我们只想渲染这个块 
So here if our tier is one, then we just want to render this block.

972
00:47:17,050 --> 00:47:18,550
我们不想去下一家 
We don't want to go to the next one.

973
00:47:18,550 --> 00:47:20,299
所以我们就说一级减去一级 
So we're just going to say tier minus one.

974
00:47:20,299 --> 00:47:22,250
我们将添加--
We're going to add--

975
00:47:22,250 --> 00:47:23,922
所以一减一等于零 
so one minus one is zero.

976
00:47:23,922 --> 00:47:25,630
所以我们从零开始 明白这一点 
So we're going at zero to this, get this.

977
00:47:25,630 --> 00:47:29,860
但如果是第二级 我们会增加一级、二级和三级 
But if tiers two, we'll add one, and two, and three.

978
00:47:29,860 --> 00:47:34,750
然后我们只需将我们想要的任何砖乘以我们的颜色 
And then we just multiply whatever brick we want by our color.

979
00:47:34,750 --> 00:47:40,540
将它乘以4 就可以得到我们实际颜色的偏移量 
Multiply it by four to get an offset for whatever our actual color is.

980
00:47:40,540 --> 00:47:43,210
所以我们选择我们的颜色 找出它在床单上的位置 
So we take our color, figure out where on the sheet it is,

981
00:47:43,210 --> 00:47:46,180
然后只需将我们的层添加到其中 以便为其编制索引
and then just add our tier to it in order to index

982
00:47:46,180 --> 00:47:49,580
添加到我们的电子表格中 
into our spreadsheet accordingly.

983
00:47:49,580 --> 00:47:52,900
这就是数学所要做的 
And so that's what the math here is doing.

984
00:47:52,900 --> 00:47:56,285
如果我们回到PlayState--
And if we go back to our PlayState--

985
00:48:02,050 --> 00:48:04,880
我要开始走得更快一点
and I'm going to start moving a little bit faster

986
00:48:04,880 --> 00:48:06,590
这样我们就能跟上进度了 
just so we can keep caught up.

987
00:48:06,590 --> 00:48:10,700
但在我们的PlayState中 我们在这里注意到一件事 
But in our PlayState, one thing that we notice here,

988
00:48:10,700 --> 00:48:13,820
我们看到了一个名为Level Maker的新班级 
we have a new class called level maker that we're seeing,

989
00:48:13,820 --> 00:48:15,530
这是一个名为createmap的函数 
which was a function called createmap.

990
00:48:15,530 --> 00:48:17,930
我们将去掉所有产生我们的关卡的逻辑
We're going to take out all the logic for generating our levels

991
00:48:17,930 --> 00:48:19,370
我们只需要把它放在一个地方 
and we're just going to put it in one place.

992
00:48:19,370 --> 00:48:20,911
我们要给那个关卡制造者打电话 
We're going to call that level maker.

993
00:48:20,911 --> 00:48:24,170
而不是在我们不同的州 也许
Rather than in our different states that maybe

994
00:48:24,170 --> 00:48:26,630
生成像PlayState或I一样的积木
generate the bricks like the PlayState or I

995
00:48:26,630 --> 00:48:30,680
我猜应该是ServeState VictoryState 
guess it would be the ServeState, VictoryState,

996
00:48:30,680 --> 00:48:33,470
我猜 而不是产生所有的砖
I guess, rather than generating all the bricks

997
00:48:33,470 --> 00:48:37,610
在其固有代码状态下 让我们创建一个关卡标记器
in that state within it's innate code, let's just make a level maker

998
00:48:37,610 --> 00:48:41,750
我们可以说 好的 把砖放到平地上 创建地图 
and we can just say, OK, set bricks to levelmaker.createmap,

999
00:48:41,750 --> 00:48:46,840
这将返回一张桌子的砖块 
which will return a table of bricks.

1000
00:48:46,840 --> 00:48:51,110
抱歉 逻辑和我们之前看到的一样 
Same-- excuse me-- logic as we saw before.

1001
00:48:51,110 --> 00:48:53,510
在本例中 我们将迭代k Brick
In this case, we're just going to iterate for k brick

1002
00:48:53,510 --> 00:48:57,050
成对的自家的砖块 
in pairs of self.bricks.

1003
00:48:57,050 --> 00:49:00,710
如果砖块在比赛中发生碰撞 如果球与之相撞 
If the brick's in play and it collides, if the ball collides with it,

1004
00:49:00,710 --> 00:49:02,730
然后击打它 这将使它不再发挥作用 
then hit it, which will set it not into play.

1005
00:49:02,730 --> 00:49:08,030
很简单的A A B B 
So simple A, A, B, B.

1006
00:49:08,030 --> 00:49:10,550
最后 我们这里有我们的呈现逻辑 
And then lastly, we have our render logic here,

1007
00:49:10,550 --> 00:49:13,805
它会把那张砖头桌子拿来 然后迭代 
which is going to take that bricks table and just iterate over it.

1008
00:49:13,805 --> 00:49:15,680
我们最不应该看到的就是
And the last thing we should probably look at

1009
00:49:15,680 --> 00:49:18,921
是真正的关卡制造者本身 在这种情况下很简单 
is the actual level maker itself, which in this case is very simple,

1010
00:49:18,921 --> 00:49:21,920
但我们稍后会看到 它会变得更复杂 
but we'll see it gets a little bit more complicated later when we do it.

1011
00:49:21,920 --> 00:49:26,516
当我们有一个更详细的程序性生成方法来处理我们的级别时 
When we have a more elaborate procedural generation approach to our levels.

1012
00:49:26,516 --> 00:49:29,390
但现在 我们只需要在这里设置两个随机变量 
But right now, we're just going to say set two random variables here.

1013
00:49:29,390 --> 00:49:31,040
行数和列数 
Number of rows and columns.

1014
00:49:31,040 --> 00:49:37,670
然后对于每行或基本上每行和每列 
And then for every row or for basically every row and every column,

1015
00:49:37,670 --> 00:49:40,280
创建一块新砖 
create a new brick.

1016
00:49:40,280 --> 00:49:41,810
然后这里有一些数学问题 
And then there's some math here.

1017
00:49:41,810 --> 00:49:43,934
我会略读一下 但基本上
I'm going to kind of skim over it, but basically it

1018
00:49:43,934 --> 00:49:46,970
计算砖块的位置 然后给我们
calculates where the brick is and then gives us

1019
00:49:46,970 --> 00:49:50,510
两边各有八个像素的填充 
eight pixels of padding on either side.

1020
00:49:50,510 --> 00:49:53,145
然后根据它的数量 它需要将所有
And then based on how many it is, it needs to center all

1021
00:49:53,145 --> 00:49:55,520
然后把砖向左移动一定的量
the bricks and shift them by a certain amount to the left

1022
00:49:55,520 --> 00:49:57,080
然后开始把它们都画出来 
and then start drawing all of them.

1023
00:49:57,080 --> 00:49:59,270
这就是这段代码在这里的基本功能 
And that's essentially what this code does here.

1024
00:49:59,270 --> 00:50:01,580
所以计算中心 
So calculate the center.

1025
00:50:01,580 --> 00:50:03,680
我在这里的评论中写下了 但我要去
I wrote it out in comments here, but I'm going

1026
00:50:03,680 --> 00:50:05,600
只是暂时不去想它
just kind of glaze over it for now.

1027
00:50:05,600 --> 00:50:08,330
但实际上 把所有的砖块放在中间 
But effectively, center all the bricks.

1028
00:50:08,330 --> 00:50:12,380
基本上计算什么样的偏移量在X轴上你需要把所有的人
Basically calculate what offset on the X-axis you need to put all of them

1029
00:50:12,380 --> 00:50:16,850
让它们看起来居中 然后把它们都画出来 
so that they appear centered, and then you're going to draw them all out.

1030
00:50:16,850 --> 00:50:20,630
这就是水平仪制造者课程的内容 
And then that's it for the level maker class.

1031
00:50:20,630 --> 00:50:24,800
所以简单的行数和列数 然后用砖块填满一个表
So simply number of rows and columns, and then fill a table with bricks

1032
00:50:24,800 --> 00:50:28,392
但是把它们的X设为我们需要的
but set their X equal to however much we need to center all

1033
00:50:28,392 --> 00:50:29,850
当他们都被拉出来的时候 
of them when they're all drawn out.

1034
00:50:29,850 --> 00:50:32,850
所以我们需要计算 我们需要基本上把我们的列数
So we need to figure, we need to basically take in our number of columns

1035
00:50:32,850 --> 00:50:34,430
在我们这样做的时候 
into account when we do that.

1036
00:50:34,430 --> 00:50:43,560
然后如果我们进入Breakout3并运行它 我们就有了砖块 
And then if we go into Breakout3 and run that, we have bricks.

1037
00:50:43,560 --> 00:50:47,130
它们会被撞上 一旦它们被撞上 
They're getting collided with, and as soon as they get hit,

1038
00:50:47,130 --> 00:50:51,390
碰撞在这些砖块中的每一个都被设置为假
collided are in play on each of those bricks gets set to false

1039
00:50:51,390 --> 00:50:52,770
它们不再被渲染 
and they no longer get rendered.

1040
00:50:52,770 --> 00:50:55,830
它们不再更新碰撞方面 
And they no longer get updated in terms of collision.

1041
00:50:55,830 --> 00:50:58,470
现在 我们仍然有问题的球没有得到重置 
Now, we still have the issue with the ball not getting reset.

1042
00:50:58,470 --> 00:50:59,140
我们会解决的 
We'll fix that.

1043
00:50:59,140 --> 00:51:01,034
很容易搞定 
That's an easy fix.

1044
00:51:01,034 --> 00:51:02,200
但我们已经走了很远了 
But we're coming a long way.

1045
00:51:02,200 --> 00:51:04,880
我们的进展相当快 
We have things moving at quite a pace.

1046
00:51:04,880 --> 00:51:08,039
我将继续前进 并移动到下一个代码位 
I'm going to go ahead and move to the next bit of code here.

1047
00:51:08,039 --> 00:51:09,330
这是另一段代码 
So this is another bit of code.

1048
00:51:09,330 --> 00:51:12,450
我会在这里稍微忽略一些细节 
I'm going to sort of glaze over a little bit of the details here.

1049
00:51:12,450 --> 00:51:16,380
但在高层次上 我们需要做的是 
But at a high level what we need to do is it's one thing

1050
00:51:16,380 --> 00:51:18,840
来检测我们是否撞上了一块砖头
to detect that we've collided with a brick,

1051
00:51:18,840 --> 00:51:21,990
但在《越狱》里 球会从砖块上弹开
but in Breakout, the ball bounces off of the brick

1052
00:51:21,990 --> 00:51:23,580
这取决于它击中的是哪一边 
depending on which side it hits.

1053
00:51:23,580 --> 00:51:27,780
我们不能仅仅根据碰撞就知道这一点 
And we don't know this necessarily just based off of the collision.

1054
00:51:27,780 --> 00:51:29,920
我们只知道碰撞是真是假 
We just know whether the collision is true or not.

1055
00:51:29,920 --> 00:51:34,260
我们不知道它从哪里来 也不知道它与多少物体相撞 
We don't know where it came from and how much it collided with.

1056
00:51:34,260 --> 00:51:37,860
然后我们还要固定我们的桨 
And then we're also going to fix our paddles so that rather than-- because

1057
00:51:37,860 --> 00:51:40,790
目前它所做的只是否定Y速度 
currently all it does is just negate whatever the Y velocity is,

1058
00:51:40,790 --> 00:51:43,230
但我们想增加一点变化
but we want to add a little bit more variety

1059
00:51:43,230 --> 00:51:47,895
当我们打球的时候 
to how we end up sort of ricocheting the ball off the paddle when we play

1060
00:51:47,895 --> 00:51:50,190
这样我们就能制定一点策略
so that we can sort of strategize a little bit,

1061
00:51:50,190 --> 00:51:51,550
给我们自己一点游戏的机会 
give ourselves a little bit of game play.

1062
00:51:51,550 --> 00:51:54,300
所以 如果我们向右移动 我们碰到了水坑的右边
So if we are moving to the right and we hit the right edge of the puddle

1063
00:51:54,300 --> 00:51:56,800
有了球 它可能会朝着更锋利的方向前进 
with the ball, it should probably go in a sharper direction.

1064
00:51:56,800 --> 00:51:58,330
左边也是一样 
Same thing with the left side.

1065
00:51:58,330 --> 00:52:01,320
而我们可以通过选择中间部分来有效地做到这一点 
And we can effectively do that by taking the middle,

1066
00:52:01,320 --> 00:52:03,630
计算出它离中心有多远 
figuring out how far away from the center it is,

1067
00:52:03,630 --> 00:52:08,430
然后在负或正的方向上放大我们的增量X
and then just amplifying our delta X in the negative or positive direction

1068
00:52:08,430 --> 00:52:09,510
在此基础上 
based off of that.

1069
00:52:09,510 --> 00:52:13,390
而这会导致这种情况的发生 
And that has the effect of causing that to happen.

1070
00:52:13,390 --> 00:52:18,090
所以在这里我们可以看到我们的球有点像是在划桨 
So here we can see we have the ball sort of coming at the paddle,

1071
00:52:18,090 --> 00:52:21,270
让我们假设球拍正在向左移动 
and let's pretend that the paddle is moving to the left.

1072
00:52:21,270 --> 00:52:24,930
在这种情况下 无论球离中心有多远 
In this case, however far away the ball is from the center,

1073
00:52:24,930 --> 00:52:27,390
我们希望按一定的比例进行调整 然后
we want to scale that by some amount and then

1074
00:52:27,390 --> 00:52:32,970
最终使它成为负的增量X 因为这实际上是
end up making that our negative delta X, because that's effectively

1075
00:52:32,970 --> 00:52:34,650
这个游戏通常是怎么运作的 
how the game normally works.

1076
00:52:34,650 --> 00:52:36,692
如果你把球拍向左或向右移动 
If you move the paddle to the left or the right,

1077
00:52:36,692 --> 00:52:39,150
在拐角或其他什么地方击球 给它一个尖锐的角度 
hit it on a corner or something, gives it that sharp angle.

1078
00:52:39,150 --> 00:52:41,108
而这实际上就是尖锐的角度 
And that's effectively what the sharp angle is.

1079
00:52:41,108 --> 00:52:44,350
它只是一个很强的增量X 并且它被放大得越大 
It's just a strong delta X, and it gets amplified the larger this is.

1080
00:52:44,350 --> 00:52:47,040
所以基本上就是把这个 乘以某个数值 
So just basically take this, multiply it by some amount,

1081
00:52:47,040 --> 00:52:50,220
然后在你的DX上设置为负值或正值 
and then make it negative or positive on your dx.

1082
00:52:50,220 --> 00:52:56,730
这就是你的划桨碰撞V2 
That's your sort of paddle collision V2.

1083
00:52:56,730 --> 00:53:00,630
砖块碰撞有点--
Brick collision is a little bit--

1084
00:53:00,630 --> 00:53:03,340
这很简单 但有点复杂 
it's pretty simple, but it's a little bit more complicated.

1085
00:53:03,340 --> 00:53:06,900
基本上 我们需要做的就是检查一下 看看球的哪边
Basically what we need to do is just check and see which edge of the ball

1086
00:53:06,900 --> 00:53:09,630
不在砖头里面 
isn't inside the brick.

1087
00:53:09,630 --> 00:53:12,000
所以如果左边的边缘--我们也可以
And so if the left edge of the-- and we can also sort of

1088
00:53:12,000 --> 00:53:13,290
稍微简化一下 
simplify this a little bit.

1089
00:53:13,290 --> 00:53:15,500
如果左边--就像你在这里看到的伪代码--
If the left-- as you see here by the pseudocode--

1090
00:53:15,500 --> 00:53:20,140
如果球的左边缘在砖外并且DX为正 
if the left edge of the ball is outside the brick and the dx is positive,

1091
00:53:20,140 --> 00:53:22,440
然后我们可以说 哦 我们基本上可以假设
then we can say, oh, we can basically assume

1092
00:53:22,440 --> 00:53:25,590
我们是从左边进来的 所以我们应该
we've come in from the left side, so we should probably

1093
00:53:25,590 --> 00:53:30,120
在左侧朝相反的Y方向行驶 
go in the opposite Y direction on the left side.

1094
00:53:30,120 --> 00:53:35,310
或者很抱歉 我们应该朝同一个Y方向前进 但要取消我们的增量
Or sorry, we should go in the same Y direction, but negate our delta

1095
00:53:35,310 --> 00:53:38,730
因为我们是从左边进来的 
X. Because we're coming in from the left,

1096
00:53:38,730 --> 00:53:42,907
左边在砖块外面 所以把它弹回来 
the left side is outside the brick, so bounce it back.

1097
00:53:42,907 --> 00:53:44,490
同样的道理也适用于右边 
And the same thing for the right edge.

1098
00:53:44,490 --> 00:53:48,300
我们只做这个测试 球的左边 如果dx是正数 
And we only do this test, the left edge of the ball, if dx is positive.

1099
00:53:48,300 --> 00:53:50,130
因为如果DX是负值 就不可能
Because if dx is negative, there's no way

1100
00:53:50,130 --> 00:53:52,590
球撞到了我们的砖的左侧 
the ball's colliding with the left side of our brick.

1101
00:53:52,590 --> 00:53:54,379
所以我们可以有效地走捷径 
So we can shortcut that effectively.

1102
00:53:54,379 --> 00:53:56,670
我们在这里做同样的逻辑 只是在正确的边缘
We do the same exact logic here, just on the right edge

1103
00:53:56,670 --> 00:53:59,460
而不是左边的边缘 
of the brick instead of the left edge.

1104
00:53:59,460 --> 00:54:01,230
如果这些都不成立 我们就会
And then if none of those hold true, we're

1105
00:54:01,230 --> 00:54:06,570
去看看球的顶边是否在砖头的顶边之上 
going to see if the top edge of the ball is above the top edge of the brick.

1106
00:54:06,570 --> 00:54:09,290
如果是这样的话 我们知道我们是从顶端开始的 
And if that's the case, we know that we've hit from the top.

1107
00:54:09,290 --> 00:54:10,740
我们可以触发顶部碰撞 
We can trigger a top collision.

1108
00:54:10,740 --> 00:54:12,600
如果这些都不成立 我们知道
And if none of those have held true, we know

1109
00:54:12,600 --> 00:54:14,970
我们发生了某种碰撞 
that we have had a collision of some kind,

1110
00:54:14,970 --> 00:54:18,440
我们可以只登记一次底部碰撞 
we can just register a bottom collision.

1111
00:54:18,440 --> 00:54:23,130
所以这是这个排序的一个简单版本
And so this is a simple version of this sort

1112
00:54:23,130 --> 00:54:25,290
做突破碰撞的方式 
of way of doing Breakout collision.

1113
00:54:25,290 --> 00:54:27,604
它在弯道方面有一些缺陷 
It has a few faults when it comes to corners,

1114
00:54:27,604 --> 00:54:29,520
有时弯道可能有点挑剔 
sometimes corners can be a little bit finicky,

1115
00:54:29,520 --> 00:54:31,680
但我要说的是 它99%的情况下都是有效的 
but I would say it works 99% of the time.

1116
00:54:31,680 --> 00:54:37,170
要获得一个更健壮、更好的示例 我将查看以下URL
For a much more robust and a better example, I would look at this URL

1117
00:54:37,170 --> 00:54:40,050
这是因为他也陷入了全面的崩溃
here because he also goes into a full sort of breakdown

1118
00:54:40,050 --> 00:54:43,230
他将如何实施阿卡诺德 这是同样的事情有效地
of how he would implement arkanoid, which is the same thing effectively

1119
00:54:43,230 --> 00:54:46,050
如果你只是想从另一个角度看它 那就作为突破口 
as Breakout if you just want an alternative look at it.

1120
00:54:46,050 --> 00:54:50,220
但基本上 他的解决方案包括取X和Y的多少
But basically, his solution involved taking how much the X and the Y

1121
00:54:50,220 --> 00:54:54,570
在砖块相对于球的不同点上有所不同 
differed on different points of the bricks relative to the ball.

1122
00:54:54,570 --> 00:54:58,680
我相信他也把球当做一个有中心点的真正的球 
And I believe he also kept the ball as an actual ball with a center point,

1123
00:54:58,680 --> 00:55:04,420
尽管他把它渲染成了一个长方形 
even though he rendered it as a rectangle.

1124
00:55:04,420 --> 00:55:05,820
所以它更坚固了一点 
So it's a little bit more robust.

1125
00:55:05,820 --> 00:55:09,090
我决定以一种更简单的方式实现它 我将展示这一点 
I decided to implement it a simpler way, which I'll showcase,

1126
00:55:09,090 --> 00:55:12,240
这就是我演示的方式 因为它工作得很好
which is the way that I demonstrated because it worked well

1127
00:55:12,240 --> 00:55:15,600
这并不是太多的代码 几乎看不出来 
and it wasn't too much code to sort of look over.

1128
00:55:15,600 --> 00:55:17,580
但我鼓励你去看看这一点 
But I do encourage you to take a look at that.

1129
00:55:17,580 --> 00:55:19,860
我们将在《突破4》中看看我们的PlayState 
We're going to look at our PlayState now in Breakout4.

1130
00:55:26,880 --> 00:55:28,965
在我们的PlayState中 我们将看到--
And in our PlayState, we're going to see--

1131
00:55:32,560 --> 00:55:33,460
抱歉的 
sorry.

1132
00:55:33,460 --> 00:55:35,470
65行 
Line 65.

1133
00:55:35,470 --> 00:55:43,830
这就是影响球的增量X的实际球拍代码 
So this is the actual paddle code for influencing the ball's delta X.

1134
00:55:43,830 --> 00:55:53,700
所以基本上 如果球x小于球桨x加上它的宽度
So basically, if the ball.x is less than the paddle.x plus it's width divided

1135
00:55:53,700 --> 00:55:58,500
两个人 所以基本上在划桨的左边 
by two, so basically on the left side of the paddle,

1136
00:55:58,500 --> 00:56:02,040
划桨的增量X小于零 这意味着它在向左移动--
and the paddle's delta X is less than zero, which means it's moving left--

1137
00:56:02,040 --> 00:56:04,956
因为我们真的不想影响它 如果我们只是
because we don't really want to necessarily influence it if we're just

1138
00:56:04,956 --> 00:56:05,889
原地踏步--
standing still--

1139
00:56:05,889 --> 00:56:07,680
我们要做我之前描述过的事情 
we're going to do what I described earlier.

1140
00:56:07,680 --> 00:56:11,490
我们要给它一些定标器 比如一些起始值 
We're going to give it some scaler, like some start off value.

1141
00:56:11,490 --> 00:56:15,210
在这种情况下 负50只是在某种程度上播种 给它
In this case, negative 50 is just sort of seeding this, giving it

1142
00:56:15,210 --> 00:56:18,090
某种初值 
some sort of initial value.

1143
00:56:18,090 --> 00:56:24,470
然后我们只需从中点减去球的X 
And then we're just going to subtract the ball's X from the middle point.

1144
00:56:24,470 --> 00:56:26,892
这是划桨的中点
This being the middle point of the paddle

1145
00:56:26,892 --> 00:56:28,350
然后再乘以8 
And then just multiply it by eight.

1146
00:56:28,350 --> 00:56:31,980
所以不管球的X和中间有什么不同
So whatever the difference is between the ball's X and the middle

1147
00:56:31,980 --> 00:56:34,080
划桨的数乘以八 
of the paddle, multiply it by eight.

1148
00:56:34,080 --> 00:56:36,720
把它加到负50 然后再求反 
Add it to negative 50 and then negate that.

1149
00:56:36,720 --> 00:56:40,560
同时否定该整数值 从而使整个整数值变为负值 
Also negate that whole value so that the whole entire value becomes negative.

1150
00:56:40,560 --> 00:56:44,880
因此 我们得到了更清晰的增量X 这取决于哪个角度
And we, therefore, get a sharper delta X depending on which angle

1151
00:56:44,880 --> 00:56:46,980
它正在到来 也是以多快的速度--
it's coming at, and also how fast--

1152
00:56:46,980 --> 00:56:50,250
或者不是速度有多快 而是我们是否在向左移动 
or not how fast, but whether or not we are moving left.

1153
00:56:50,250 --> 00:56:53,970
右边也是一样的东西 
And it's the exact same thing on the right side.

1154
00:56:53,970 --> 00:56:58,050
只是因为我们要学这个数学 这个self.paddle.x
Only because we're taking this math, this self.paddle.x

1155
00:56:58,050 --> 00:57:02,655
加上自拍宽度除以2减去球宽x 
plus self.paddle.width divided by two minus the ball.x,

1156
00:57:02,655 --> 00:57:05,320
Ball.x不会大于那个点 
the ball.x isn't going to be greater than that point.

1157
00:57:05,320 --> 00:57:07,360
所以这个值实际上是负值 
So this value is actually going to be negative.

1158
00:57:07,360 --> 00:57:09,660
所以我们只需要用Math.abs来证明这一点 
So we're going to just make it positive with math.abs.

1159
00:57:09,660 --> 00:57:10,730
所以绝对值 
So absolute value.

1160
00:57:10,730 --> 00:57:12,330
只是一个Lua函数 
Just a lua function.

1161
00:57:12,330 --> 00:57:14,820
所以球与球之间的差值的绝对值
So the absolute value of the difference between the ball's

1162
00:57:14,820 --> 00:57:19,530
X和中间点乘以8 加到50 
X and the middle point times eight, add it to 50,

1163
00:57:19,530 --> 00:57:23,580
这将给我们一个正值 它的大小取决于
and that'll give us a positive value that scales depending on whether or not

1164
00:57:23,580 --> 00:57:27,030
我们打到了中间 我们打到了桨的右边
we've hit the middle of the, we've hit the right edge of the paddle

1165
00:57:27,030 --> 00:57:28,700
正在向右移动 
and are moving to the right.

1166
00:57:28,700 --> 00:57:33,450
所以 简而言之 这就是我们如何让碰撞与划桨一起工作
And so that's, in a nutshell, how we get that collision to work with the paddle

1167
00:57:33,450 --> 00:57:36,630
以及我们如何将增量X调整得更大一些
and how we can tweak delta X to be scaled a little bit more

1168
00:57:36,630 --> 00:57:40,920
而不只是一个常量 你知道的 负数或其他什么
than just a constant, you know, negative or whatever

1169
00:57:40,920 --> 00:57:43,020
它是当前的x 但是是负的dy 
it's current X was, but negative dy.

1170
00:57:43,020 --> 00:57:45,900
稍微复杂一点 
A little bit more complicated.

1171
00:57:45,900 --> 00:57:50,610
然后是砖块的实际碰撞代码
And then the actual collision code for the bricks

1172
00:57:50,610 --> 00:57:53,110
它们将在这里的for循环中发生 
themselves is going to take place in a for loop here.

1173
00:57:53,110 --> 00:57:58,270
因此 如果它在比赛中 如果球与它相撞 就击打它 
So if it's in play, if the ball collides with it, hit it.

1174
00:57:58,270 --> 00:57:59,640
所以我加了加二 
So I added plus two.

1175
00:57:59,640 --> 00:58:05,520
所以数学的要点是 如果bal.x小于brick.x
So the gist of the math is if ball.x is less than brick.x

1176
00:58:05,520 --> 00:58:09,300
球向右移动 self.ball.dx大于零 
and the ball is moving to the right, self.ball.dx is greater than zero,

1177
00:58:09,300 --> 00:58:10,590
然后将其翻转为X速度 
then flip it's X velocity.

1178
00:58:10,590 --> 00:58:11,850
所以把它弹到左边 
So bounce it to the left.

1179
00:58:11,850 --> 00:58:13,560
这张支票就是这么回事 
That's what this check is.

1180
00:58:13,560 --> 00:58:15,785
但它在角球上打得有点粗糙
But it plays a little bit rough with corners

1181
00:58:15,785 --> 00:58:17,910
因为从理论上讲 你可以进入一个
because you could theoretically get into a position

1182
00:58:17,910 --> 00:58:21,900
你以一个角度进入 它是相交的
where you come in at an angle and it's intersecting

1183
00:58:21,900 --> 00:58:29,190
将球拍放在两个位置 都在顶部和左侧
with the paddle in two positions, both on top and the left

1184
00:58:29,190 --> 00:58:30,930
或者在底部和左边 
or on bottom and the left.

1185
00:58:30,930 --> 00:58:36,780
因此 在这种情况下 添加两个将确定命中的Y的优先顺序 
So in that case, adding two sort of prioritizes the Y being hit.

1186
00:58:36,780 --> 00:58:42,690
所以它基本上是从球的展开式到X加2的检查 
So it basically takes the check from the exposition of the ball to the X plus 2.

1187
00:58:42,690 --> 00:58:48,210
因此 它最终修复了一些角落 但它的要点是
And so it ends up fixing the corners a little bit, but the gist of it

1188
00:58:48,210 --> 00:58:50,810
只需检查Ball.x是否小于brick.x 
is just check to see if the ball.x is less than the brick.x.

1189
00:58:50,810 --> 00:58:55,680
如果是这样 并且我们检测到了碰撞 我们可以将其弹回 
And if it is and we've detected a collision, we can bounce it.

1190
00:58:55,680 --> 00:58:59,670
在没有加上这个加二的情况下 有一些微妙的角落问题 
There are some subtle corner case bugs without adding this plus two,

1191
00:58:59,670 --> 00:59:01,500
所以我们加上了这一点 
so we add that.

1192
00:59:01,500 --> 00:59:04,190
然后在这里反转速度 
And then flip the velocity here.

1193
00:59:04,190 --> 00:59:05,156
哦 这个班次 
Oh, this shift here.

1194
00:59:05,156 --> 00:59:07,530
这就是我们之前谈到的确保
This is what we were talking about earlier with make sure

1195
00:59:07,530 --> 00:59:09,570
当你做碰撞时 移动任何
when you do a collision, shift whatever is

1196
00:59:09,570 --> 00:59:12,870
走出你正在碰撞的任何东西的界限 
moving outside the boundaries of whatever you're colliding with.

1197
00:59:12,870 --> 00:59:19,010
因此 self.ball.x得到的是brick.x减去8 因为球有8个像素宽 
So self.ball.x gets brick.x minus eight because the ball is eight pixels wide.

1198
00:59:19,010 --> 00:59:23,070
为了获得更好的风格 它实际上应该是self.ball 
It should actually be self.ball.width for a better style,

1199
00:59:23,070 --> 00:59:26,651
但这就是它本质上要转化为的 
but that's essentially what it translates out to.

1200
00:59:26,651 --> 00:59:27,900
右边的边缘也是这样 
Same thing for the right edge.

1201
00:59:27,900 --> 00:59:29,850
正六是因为它在右边 
The plus six because it's on the right side.

1202
00:59:29,850 --> 00:59:34,080
所以如果我们在左边 它实际上和负2是一样的 
So it's effectively the same thing as minus two if we're on the left side.

1203
00:59:34,080 --> 00:59:39,540
只是一种修复转角的方法 转角的奇怪问题 
Just a sort of fixes corners, weird issues with corners.

1204
00:59:39,540 --> 00:59:44,970
但检查一下 基本上球是不是加上它的高度减2
But check in to see if basically the ball plus its height minus two

1205
00:59:44,970 --> 00:59:51,630
大于砖块加X加砖块宽度 这意味着 
is greater than the brick plus X plus brick.width, which it means,

1206
00:59:51,630 --> 00:59:55,560
哦 我们撞到了屏幕的右边 砖头的右边 
oh, we've collided with the right edge of the screen, of the brick.

1207
00:59:55,560 --> 00:59:58,530
然后如果Y小于砖块Y 
And then if the Y is less than the brick.y,

1208
00:59:58,530 --> 01:00:00,980
然后我们撞上了砖头的顶部 
then we've collided with the top of the brick,

1209
01:00:00,980 --> 01:00:03,420
否则 我们就撞到了底部 
and otherwise, we've collided with the bottom.

1210
01:00:03,420 --> 01:00:06,780
对于顶部和底部 只要做我们对增量X所做的相同的事情 
And with the top and the bottom, just do the same thing we did with delta X,

1211
01:00:06,780 --> 01:00:09,030
但对Delta Y进行此操作 但您仍在重新设置它 
but do it with delta Y, but you're still resetting it.

1212
01:00:09,030 --> 01:00:11,580
因此 Ball.y得到brick.y减去8 
So ball.y gets brick.y minus eight.

1213
01:00:11,580 --> 01:00:17,130
Ball.y得到brick.y加16 因为球拍或单独的砖
Ball.y gets brick.y plus 16 because the paddle or the individual bricks

1214
01:00:17,130 --> 01:00:21,120
有16个像素高 
are 16 pixels tall.

1215
01:00:21,120 --> 01:00:24,810
这就是碰撞检测的要点 
That's the gist of the collision detection.

1216
01:00:24,810 --> 01:00:27,840
然后如果我们真的--哦 还有一件事 我最终
And then if we actually-- oh, and one other thing that I ended up

1217
01:00:27,840 --> 01:00:30,600
把它放在这里只是为了让它更有趣一些 
putting here just to make it a little bit more interesting,

1218
01:00:30,600 --> 01:00:33,960
这也与更复杂的碰撞检测有关 
and this also ties into more complicated collision detection.

1219
01:00:33,960 --> 01:00:38,015
如果你的速度太快 很多时候它会跳过物体 
If your velocity is too fast, a lot of the time it'll skip through objects,

1220
01:00:38,015 --> 01:00:40,890
这就给这些碰撞检测带来了很多问题
and then that causes a lot of problems with these collision detection

1221
01:00:40,890 --> 01:00:44,520
这些函数通常在数学上是非常正确的
functions that normally are very sort of mathematically correct

1222
01:00:44,520 --> 01:00:45,480
它们工作得很好 
and they work well.

1223
01:00:45,480 --> 01:00:47,370
当它跳过什么时 它们就不能很好地工作
They don't work well when it skips over what

1224
01:00:47,370 --> 01:00:49,260
你实际上正试图与之相撞 
you're trying to actually collide with.

1225
01:00:49,260 --> 01:00:53,970
这个问题的解决方案超出了本例的范围 但是
So a solution to that, which was beyond the scope of this example but something

1226
01:00:53,970 --> 01:00:57,600
我们在想 可能是在倒退到一定程度
we're thinking about, is perhaps stepping backwards a certain amount

1227
01:00:57,600 --> 01:00:59,790
时间 一定的像素量 
of time, a certain amount of pixels.

1228
01:00:59,790 --> 01:01:04,380
也许可以从你的球所在的地方开始 
Perhaps maybe start at where you where your ball was on one particular,

1229
01:01:04,380 --> 01:01:08,100
在最后一帧上 然后只需将其宽度和高度添加到其自身
on the last frame, and then just add its width and height to itself

1230
01:01:08,100 --> 01:01:12,480
直到它与某物相撞 直到它到达当前的增量X
until it collides with something, until it reaches whatever its current delta X

1231
01:01:12,480 --> 01:01:15,380
或者Y增量加上它的位置 
or delta Y plus its position is.

1232
01:01:15,380 --> 01:01:16,380
这是一种方法 
That's one way to do it.

1233
01:01:16,380 --> 01:01:18,817
就像是添加了一堆看不见的--
Sort of just adding a bunch of invisible--

1234
01:01:18,817 --> 01:01:21,650
无论你撞上的是什么 或者你用来碰撞的是什么--
whatever you're colliding with or whatever you're using to collide--

1235
01:01:21,650 --> 01:01:26,250
添加一堆看不见的那些来弥合差距 并检查其中任何一个
add a bunch of invisible those to bridge the gap and check into if any of those

1236
01:01:26,250 --> 01:01:27,900
对于碰撞 保持为True 
hold true for a collision.

1237
01:01:27,900 --> 01:01:32,010
计算成本稍微高一点 但精确度要高得多
A little bit more computationally expensive, but a lot more accurate

1238
01:01:32,010 --> 01:01:35,107
从物理学的角度来说 
in terms of the physics.

1239
01:01:35,107 --> 01:01:36,940
除此之外 一切都是一样的 
And aside from that, everything is the same.

1240
01:01:36,940 --> 01:01:40,326
所以如果你看一下Breakout 4中的代码--
So if you look at the code in Breakout4--

1241
01:01:40,326 --> 01:01:42,450
从今以后 我要开得更快一点 
and I'm going to go a little bit faster henceforth.

1242
01:01:42,450 --> 01:01:44,491
这可能是该计划中最丰盛的部分 
That's probably the meatiest part of the program.

1243
01:01:47,050 --> 01:01:49,080
我们会遇到碰撞 
We get collisions.

1244
01:01:49,080 --> 01:01:54,102
然后我会试着得到一个强有力的角度 这样我就可以演示--
And then I'll try and get a strong angle so I can demo the--

1245
01:01:54,102 --> 01:01:54,810
但这并不管用 
that didn't work.

1246
01:01:54,810 --> 01:01:55,890
这实际上给出了一个较弱的角度 
That actually gave a weaker angle.

1247
01:01:55,890 --> 01:01:59,250
所以如果你这样做 你靠近中心做 它会产生相反的效果 
So if you do this and you do it close to the center, it has the opposite effect.

1248
01:01:59,250 --> 01:01:59,958
但这就是你要做的 
But there you go.

1249
01:01:59,958 --> 01:02:01,200
这是一个更锐利的角度 
That's a sharper angle.

1250
01:02:01,200 --> 01:02:05,550
所以现在你实际上可以更多地影响球
So now you can actually influence the ball in a little bit more

1251
01:02:05,550 --> 01:02:07,770
风度翩翩的方式 
of a personable way.

1252
01:02:07,770 --> 01:02:11,070
你知道 它不仅仅是一个平坦的增量 Y变负--
You know, not just have it be a flat delta Y gets negative--

1253
01:02:11,070 --> 01:02:14,220
或者有效地得到负的增量Y 
or get negative delta Y effectively.

1254
01:02:14,220 --> 01:02:19,920
那么对于这一切的主旨是如何运作的 有什么问题吗？
So any questions on sort of how the gist of all of that works?

1255
01:02:23,730 --> 01:02:24,230
好的 
OK.

1256
01:02:24,230 --> 01:02:25,040
完美无缺 
Perfect.

1257
01:02:25,040 --> 01:02:28,395
所以现在我们要进入更多一些有趣的东西 
So now we're going to get into a little bit more of some fun stuff.

1258
01:02:28,395 --> 01:02:30,770
我们再做几个例子 然后休息一下 
We'll do a couple more examples, then we'll take a break.

1259
01:02:30,770 --> 01:02:32,360
这就是心脏的最新情况 
So this is the hearts update.

1260
01:02:32,360 --> 01:02:35,690
请注意屏幕的最上方 正如我在下面这些演示中所演示的
So notice that the very top of the screen, as I've demonstrated in these

1261
01:02:35,690 --> 01:02:38,480
幻灯片 我们只有几颗心 
slides, we have just a few hearts.

1262
01:02:38,480 --> 01:02:39,382
其中一个是空的 
One of them is empty.

1263
01:02:39,382 --> 01:02:40,340
我们早些时候展示了这个 
We showed this earlier.

1264
01:02:40,340 --> 01:02:43,660
然后我们有一场屏幕上的比赛 这是我们的最终比分 
And then we have a game over screen, which is our final score.

1265
01:02:43,660 --> 01:02:46,909
所以我要继续 我们只需要稍微看一下代码
So I'm going to go ahead and we're just going to look at the code a little bit

1266
01:02:46,909 --> 01:02:50,656
现在更快了 因为很多东西都相当简单 
faster now since a lot of the stuff is fairly straightforward.

1267
01:02:50,656 --> 01:02:52,280
我要继续下去 打开--
I'm going to go ahead and open up the--

1268
01:02:52,280 --> 01:02:54,780
我首先要确保我在正确的文件夹中 
I'm going to make sure I'm in the right folder first of all.

1269
01:02:54,780 --> 01:02:55,760
突破5.
Breakout5.

1270
01:02:55,760 --> 01:02:57,320
然后在--
And then in the--

1271
01:03:00,860 --> 01:03:07,690
所以我们要开始做的另一件事是--
so one other thing we're going to start doing is--

1272
01:03:07,690 --> 01:03:08,917
我刚才提到过这一点 
I mentioned this earlier.

1273
01:03:08,917 --> 01:03:10,750
它将会是真实的
And it's going to be it's going to hold true

1274
01:03:10,750 --> 01:03:13,570
对于任何一种状态转换
for any of the sort of state transformations

1275
01:03:13,570 --> 01:03:15,460
这一切都发生在未来 
that take place going forward.

1276
01:03:15,460 --> 01:03:17,440
我们没有保留全局变量 而是
Rather than keep global variables, we're going

1277
01:03:17,440 --> 01:03:20,500
在某种程度上消除资产表外的这种想法
to sort of do away with that idea outside of the asset tables

1278
01:03:20,500 --> 01:03:23,210
我们所拥有的只是因为这些是一种例外
that we have just because those are kind of an exception

1279
01:03:23,210 --> 01:03:26,560
并且可以合理地将它们放在一个称为资源的单独类中
and they could reasonably be put into a separate class called the resource

1280
01:03:26,560 --> 01:03:27,550
经理 
manager.

1281
01:03:27,550 --> 01:03:35,570
我们将开始传入基本上就是我们当前的应用程序状态 
We're going to start passing in what is basically our current app state,

1282
01:03:35,570 --> 01:03:37,750
或者至少是有意义的变量 
or at least the variables that make sense.

1283
01:03:37,750 --> 01:03:40,900
这也是使用Reaction进行Web开发的常见范例 
And this is a common paradigm in web development with React as well.

1284
01:03:40,900 --> 01:03:44,560
但基本上 我们需要的一切都是州与州之间的保存 
But basically, everything that we need to be preserve state to state,

1285
01:03:44,560 --> 01:03:46,310
与其只保留全局变量 
rather than just keeping global variables,

1286
01:03:46,310 --> 01:03:49,210
让我们在状态之间传递它们 因为状态机允许
let's pass them between the states because the state machine allows

1287
01:03:49,210 --> 01:03:52,120
我们需要在Change函数中执行此操作 
us to do that in the change function.

1288
01:03:52,120 --> 01:03:55,240
然后不管它的Enter函数处于什么状态 
And then whatever that state is in it's enter function,

1289
01:03:55,240 --> 01:03:56,950
它将可以访问它 并且它可以
it'll have access to that and it can just

1290
01:03:56,950 --> 01:04:01,090
将这些值设置为Self Dot Anywhere并使用它们 
set those values to self dot whatever and use them.

1291
01:04:01,090 --> 01:04:02,770
但我们不再有全球变量 
But we no longer have global variables.

1292
01:04:02,770 --> 01:04:03,770
我们只是想说 给你 
We're just saying, here.

1293
01:04:03,770 --> 01:04:06,962
以下是对你继续下去很重要的价值观 
Here's the values that are important for you to continue on.

1294
01:04:06,962 --> 01:04:09,670
然后 该状态将采用其值并进入下一状态
And then that state will take its values and go to the next state

1295
01:04:09,670 --> 01:04:14,170
然后说 哦 好的 这是你运作所需要的价值观 
and say, oh, OK, here are the values that you need to function.

1296
01:04:14,170 --> 01:04:16,240
比如发球 打球 以及所有这些状态
Like the serve, play, and all those states

1297
01:04:16,240 --> 01:04:17,890
有核心游戏参与的人可能会
that have the core game play involved will probably

1298
01:04:17,890 --> 01:04:19,540
需要保持一个像桨一样的引用 
need to maintain a reference to like the paddle,

1299
01:04:19,540 --> 01:04:21,676
更重要的是 我们所拥有的健康程度 
and to the score, the amount of health we have.

1300
01:04:21,676 --> 01:04:24,550
但当我们走到最后 例如 然后我们不再真的
But when we get to the end, for example, and then we no longer really

1301
01:04:24,550 --> 01:04:27,849
需要一把桨 我们不再真的需要砖头或类似的东西 
need a paddle, we no longer really need bricks or anything like that,

1302
01:04:27,849 --> 01:04:30,640
我们只需要知道我们的最高分是多少 这样我们就可以进入它
we just need to know what our high score is so that we can enter it

1303
01:04:30,640 --> 01:04:33,430
进入我们的高分名单 我们真正需要的
into our high score list, all we really need

1304
01:04:33,430 --> 01:04:37,030
要做的就是通过高分州进入或只通过我们的高分 
to do is just pass in the high score state entry or just our high score,

1305
01:04:37,030 --> 01:04:39,340
就是这样 
and that's it.

1306
01:04:39,340 --> 01:04:41,170
所以它封装了我们所有的数据 
So it encapsulates all of our data.

1307
01:04:41,170 --> 01:04:45,730
一眼就能看出我们需要在两个州之间传递什么
And at a glance, we can sort of see what we need to pass between the states

1308
01:04:45,730 --> 01:04:48,730
以及哪些内容也将一目了然 
and what's going to be relevant at a glance as well.

1309
01:04:48,730 --> 01:04:52,340
它只是清理了相当多的东西 
It just clean things up quite a bit.

1310
01:04:52,340 --> 01:04:55,120
这就是我们现在在第35行所做的 
So that's what we're doing now on line 35.

1311
01:04:55,120 --> 01:04:58,600
从今以后 我们将在我们所看到的每个州都这样做 
And henceforth, we will do this in every state as we see,

1312
01:04:58,600 --> 01:05:02,500
但我打算在未来对它进行某种程度的掩盖 
but I'm going to sort of glaze over it in the future.

1313
01:05:02,500 --> 01:05:03,610
我们现在有了一个ServeState 
We have a ServeState now.

1314
01:05:03,610 --> 01:05:08,257
因此 作为一个ServeState 这与我们在Pong所做的非常相同 
So a ServeState, this is very identical to what we did in Pong.

1315
01:05:08,257 --> 01:05:10,090
因此 我们只需等待用户按空格键 
So we just wait for the user to press Space.

1316
01:05:10,090 --> 01:05:16,810
他们可以四处走动 然后当他们按下Enter键时 
They can move around and then when they do press Enter,

1317
01:05:16,810 --> 01:05:20,380
基本上 球开始移动了 
basically the ball starts moving.

1318
01:05:20,380 --> 01:05:23,110
然后我们使用以下命令更改此处的PlayState
And then we change the PlayState here using

1319
01:05:23,110 --> 01:05:25,644
所需的当前值 
the current values that are necessary.

1320
01:05:25,644 --> 01:05:27,310
划桨、砖块、健康、得分和球 
Paddle, bricks, health, score, and ball.

1321
01:05:27,310 --> 01:05:30,220
这些基本上是基本的变量
Those are basically the fundamental variables

1322
01:05:30,220 --> 01:05:35,980
我们需要它来跟踪我们的游戏状态 
that we need in order to keep track of our GameState.

1323
01:05:35,980 --> 01:05:38,890
所以我们有一个ServeState 它将等待我们按Enter键 
So we have a ServeState, it will wait for us to press Enter.

1324
01:05:38,890 --> 01:05:50,820
然后是我们的主路 我们有了一个新的心心桌 
And then our main.lua, we have a new hearts table.

1325
01:05:50,820 --> 01:05:55,350
然后在208线上 因为我们要去
And then on line 208, because we're going

1326
01:05:55,350 --> 01:05:59,280
需要在几个州呈现健康和分数的能力 
to need the ability to render health and render our score across several states,

1327
01:05:59,280 --> 01:06:02,100
比赛、发球、胜利、游戏结束--
Play, Serve, Victory, Game Over--

1328
01:06:02,100 --> 01:06:04,290
其实不是游戏结束 而是之前的三场比赛 
actually not Game Over, but the three before that.

1329
01:06:04,290 --> 01:06:06,081
我们不想重复这些行为 
We don't want to duplicate those behaviors,

1330
01:06:06,081 --> 01:06:08,730
所以我只调用了一个名为Render Health的函数 它
so I'm just calling a function called Render Health, which

1331
01:06:08,730 --> 01:06:10,830
只是吸收任何健康的东西 然后
just takes in whatever health is and then

1332
01:06:10,830 --> 01:06:13,800
我们只需将X设置为虚拟宽度减去100 
we just set an X to virtual width minus 100.

1333
01:06:13,800 --> 01:06:17,070
然后 为了我们的健康 画一颗心
And then for however many health we have, draw a heart

1334
01:06:17,070 --> 01:06:20,430
从红心精灵纸上 我把心分开
from the hearts sprite sheet, which I separated the hearts out

1335
01:06:20,430 --> 01:06:23,670
分成更小的图像 这样你就可以把它们分成8乘8的
into a smaller image so you can just split them on like eight by eight

1336
01:06:23,670 --> 01:06:25,590
或者什么都行 
or whatever it is.

1337
01:06:25,590 --> 01:06:27,774
但只要把它们画出来 然后把11加到X上 
But just draw those and then add 11 to X,

1338
01:06:27,774 --> 01:06:30,690
继续前进 直到我们拔出我们有多少颗心 
and just keep going until we've drawn out however many hearts we have.

1339
01:06:30,690 --> 01:06:32,220
这将吸引满满的心 
That will draw full hearts.

1340
01:06:32,220 --> 01:06:35,350
然后 三减健康将会给我们带来多少我们错过的健康 
And then three minus health will give us however many health we're missing.

1341
01:06:35,350 --> 01:06:38,099
所以如果我们取一个损伤点 这将等于1 
So if we took a point of damage, this is going to be equal to one.

1342
01:06:38,099 --> 01:06:41,736
然后它会画出一颗空的心 否则它会画出两颗空的心 
So then it'll draw one empty heart after that or it'll draw two empty hearts.

1343
01:06:41,736 --> 01:06:44,610
所以 画出我们有多少颗饱满的心 然后画出空虚的心 
So draw however many full hearts we have, then draw the empty hearts.

1344
01:06:44,610 --> 01:06:48,540
这是我们从图像中得到的两个独立的精灵 
And those are two separate sprites that we get from the image.

1345
01:06:48,540 --> 01:06:51,150
这将对我们的健康产生影响 
And that will have the effect of drawing our health.

1346
01:06:51,150 --> 01:06:56,530
然后我们的分数很简单 它接受一个分数变量 我们在这里传递 
And then our score is simply, it takes a score variable that we pass into here.

1347
01:06:56,530 --> 01:06:58,530
还请注意 渲染运行状况[INAUDIBLE]
And also note that the render health [INAUDIBLE]

1348
01:06:58,530 --> 01:07:00,450
和健康变量 并在这里传递给它 
and health variable and pass into it here.

1349
01:07:00,450 --> 01:07:17,670
因此 在我们的PlayState中 我们在第135行调用这两个函数 
And so in our PlayState, we are calling both of these functions on line 135.

1350
01:07:17,670 --> 01:07:20,702
好的 在第135行 我们正在计算我们是否
Well, on line 135, we are calculating whether we

1351
01:07:20,702 --> 01:07:23,910
走到屏幕边缘下方 这是游戏的另一个重要部分 
go below the edge of the screen, which is another important part of the game.

1352
01:07:23,910 --> 01:07:26,520
显然 我们需要发现我们何时失去了健康 
Obviously, we need to detect when we've lost health.

1353
01:07:26,520 --> 01:07:28,080
所以事情就是这么简单 
So it's as simple as this.

1354
01:07:28,080 --> 01:07:31,140
如果它大于实际身高 健康就会减少1 
If it's greater than the virtual height, decrement health by one.

1355
01:07:31,140 --> 01:07:34,200
如果它等于零 则更改为游戏结束 
If it's equal to zero, change to Game Over.

1356
01:07:34,200 --> 01:07:35,467
否则 更改为ServeState 
Else change to the ServeState.

1357
01:07:35,467 --> 01:07:38,550
请注意 我们将所有这些变量传入和传出我们的州 
And note that we're passing in all these variables to and from our states.

1358
01:07:38,550 --> 01:07:39,716
那些重要的东西 
The ones that are important.

1359
01:07:39,716 --> 01:07:41,970
比赛结束只需要得分 但发球需要任何东西
Game Over just needs score, but Serve needs whatever

1360
01:07:41,970 --> 01:07:43,740
我们已经在使用的变量 
variables we were already using.

1361
01:07:46,620 --> 01:07:50,100
然后我们在这里调用Render Score和Render Health 
And then down here we're calling render score and render health,

1362
01:07:50,100 --> 01:07:54,900
然后 GameOverState就是简单的--
and then the GameOverState is simply--

1363
01:07:54,900 --> 01:07:58,890
因为它接受参数列表中的分数 
because it takes in score from the parameters list,

1364
01:07:58,890 --> 01:08:03,330
只需等待键盘输入返回到开始 然后渲染游戏结束 
just wait for keyboard input to go back to the start and then render game over,

1365
01:08:03,330 --> 01:08:04,530
这是你的分数 
here's your score.

1366
01:08:04,530 --> 01:08:06,930
这是自己的得分 然后就是这样 
It's self.score, and then that's it.

1367
01:08:06,930 --> 01:08:07,620
非常简单 
Very simple.

1368
01:08:07,620 --> 01:08:08,636
非常简单的状态 
Very simple state.

1369
01:08:08,636 --> 01:08:09,510
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1370
01:08:09,510 --> 01:08:10,301
科尔顿·奥格登：当然可以 
COLTON OGDEN: Sure.

1371
01:08:10,301 --> 01:08:15,899
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1372
01:08:15,899 --> 01:08:18,149
科尔顿·奥格登：问题是 这些州中有哪一个
COLTON OGDEN: The question was, do any of these states

1373
01:08:18,149 --> 01:08:19,740
有权访问他们的父文件吗？
have access to their parent file?

1374
01:08:19,740 --> 01:08:27,180
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1375
01:08:27,180 --> 01:08:30,120
科尔顿·奥格登：一切正常吗？Lua全球运行吗？
COLTON OGDEN: Is everything in main.lua global functions?

1376
01:08:30,120 --> 01:08:30,810
是 
Yes.

1377
01:08:30,810 --> 01:08:31,935
您声明的函数 
Functions that you declare.

1378
01:08:31,935 --> 01:08:35,220
在main.lua中定义的基本上未指定为本地的任何内容
Anything that's basically not specified as local that you define in main.lua

1379
01:08:35,220 --> 01:08:39,163
将可在应用程序中的任何位置访问 包括函数 
will be accessible anywhere in your application, including functions.

1380
01:08:39,163 --> 01:08:40,715
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1381
01:08:40,715 --> 01:08:42,840
科尔顿·奥格登：你不必--问题是 
COLTON OGDEN: You don't have to-- the question was,

1382
01:08:42,840 --> 01:08:44,215
你必须申报为公共物品吗？
do you have to declare as public?

1383
01:08:44,215 --> 01:08:45,725
不 没有公开的概念 
No, there is no notion of public.

1384
01:08:45,725 --> 01:08:48,720
在LUA中 任何没有局部说明符的东西
In lua, anything that does not have a local specifier

1385
01:08:48,720 --> 01:08:51,330
被假定为全局的 即使它在嵌套作用域中 
is assumed global, even if it's in a nested scope.

1386
01:08:51,330 --> 01:08:54,930
所以你可以有一个for循环 你可以有几个嵌套的for循环
So you could have a for loop, you could have several nested for loops

1387
01:08:54,930 --> 01:08:59,310
并声明一些不带局部变量的变量 该变量可以在任何地方访问
and declare some variable without local, that variable can be accessed anywhere

1388
01:08:59,310 --> 01:09:01,050
在它上面或外面 
above it or outside of it.

1389
01:09:01,050 --> 01:09:03,060
所以使用局部变量非常重要
So it's pretty important to use local variables

1390
01:09:03,060 --> 01:09:05,970
当你没有显式地分配全局变量时 
when you're not explicitly allocating something as global

1391
01:09:05,970 --> 01:09:09,600
只是为了避免for嵌套循环的错误
just to avoid the bug of for nested loops

1392
01:09:09,600 --> 01:09:14,729
你有一个变量名 比如hello 你可以在其他地方使用它 
and you have some variable name like hello and you use it somewhere else.

1393
01:09:14,729 --> 01:09:16,960
好问题 
Good questions though.

1394
01:09:16,960 --> 01:09:17,460
所以是的 
So yeah.

1395
01:09:17,460 --> 01:09:18,569
我们现在有很多州 
We have a bunch of states now.

1396
01:09:18,569 --> 01:09:20,360
我们有一个GameOverState 一个PlayState 我们
We have a GameOverState, a PlayState, we're

1397
01:09:20,360 --> 01:09:22,359
渲染我们的分数渲染我们的健康
rendering our score, rendering our health.

1398
01:09:22,359 --> 01:09:24,239
如果我们去看看Breakout 5--
If we go and take a look at Breakout5--

1399
01:09:29,805 --> 01:09:33,630
是另一扇窗吗？
is it a different window?

1400
01:09:33,630 --> 01:09:35,660
好了
There we go.

1401
01:09:35,660 --> 01:09:37,500
我们可以在顶部看到心脏 
We can see hearts at the top.

1402
01:09:37,500 --> 01:09:38,279
零分 
Score zero.

1403
01:09:41,600 --> 01:09:44,960
哦 我忘了说我们现在要加分了 
Oh, and I forgot to mention the part where we actually add score now.

1404
01:09:44,960 --> 01:09:54,440
所以砖块本身在击中时 或者我应该说在PlayState中 
So the bricks themselves in their on hit, or I should say in the PlayState,

1405
01:09:54,440 --> 01:10:00,221
在第81行 当我们检测到一个命中时 我们现在只是在分数上加10 
on line 81 when we detect a hit, we're just adding 10 to the score for now.

1406
01:10:00,221 --> 01:10:01,970
但稍后我们会做一个计算
But later on, we'll do a calculation where

1407
01:10:01,970 --> 01:10:04,200
我们会考虑层次和颜色
we take tier and color into consideration

1408
01:10:04,200 --> 01:10:09,500
然后进行算术运算 得出每次击球的总得分 
and then perform arithmetic on that to get our total score for each ball hit.

1409
01:10:09,500 --> 01:10:14,810
但是 是的 我们有我们的健康 我们有我们的分数 
But yeah, we have our health, we have our score.

1410
01:10:14,810 --> 01:10:16,569
一旦我们受到足够的伤害 
And then once we take enough damage, we'll

1411
01:10:16,569 --> 01:10:18,110
最终进入游戏结束屏幕 
end up going to the Game Over screen.

1412
01:10:18,110 --> 01:10:20,420
游戏结束屏幕将返回到开始屏幕 
The Game Over screen will go back to our Start screen.

1413
01:10:20,420 --> 01:10:21,780
所以有进步 
So making progress.

1414
01:10:21,780 --> 01:10:24,440
然后可能是我最喜欢的更新
And then probably my favorite of the updates

1415
01:10:24,440 --> 01:10:27,650
在我们短暂休息之前是美丽的颜色更新 
before we take a short break is the pretty colors update.

1416
01:10:27,650 --> 01:10:31,200
所以很明显我们可以
So what this does is clearly we can have--

1417
01:10:31,200 --> 01:10:32,480
我们已经更新了水平仪
we've updated our level maker.

1418
01:10:32,480 --> 01:10:37,160
所以我们不需要一堆静止的砖块 
So rather than just having a bunch of very static bricks,

1419
01:10:37,160 --> 01:10:41,270
我们最终做了一个更复杂的过程生成 
we end up doing a little bit more complicated procedural generation.

1420
01:10:41,270 --> 01:10:42,740
但这并不复杂 
It's not complicated though.

1421
01:10:42,740 --> 01:10:48,290
在Breakout 6的levelmaker.lua中 我们有几个不同的常量 
Just in levelmaker.lua in Breakout6, we have a few different constants here.

1422
01:10:48,290 --> 01:10:51,499
所以固体 交替 跳过 或没有 
So solid, alternate, skip, or none.

1423
01:10:51,499 --> 01:10:53,290
实际上 我不认为我用了跳过或没有 
Actually, I don't think I use skip or none.

1424
01:10:53,290 --> 01:10:54,860
基本上是固定的或者交替的 
Just solid or alternate basically.

1425
01:10:54,860 --> 01:10:56,180
我们现在有旗子了 
We have flags now.

1426
01:10:56,180 --> 01:10:58,100
列的数量 
So number of columns.

1427
01:10:58,100 --> 01:11:02,480
我们确保它是奇数的 因为偶数列具有生成模式
And we ensure that it's odd because even columns with generating patterns

1428
01:11:02,480 --> 01:11:04,340
会导致不对称 
leads to asymmetry.

1429
01:11:04,340 --> 01:11:07,679
因此 请确保列数为奇数 
So make sure the number of columns is odd.

1430
01:11:07,679 --> 01:11:10,470
根据我们的级别生成最高级别和最高颜色 
Generate the highest tier and the highest color based on our level.

1431
01:11:10,470 --> 01:11:12,850
所以在这种情况下 我们不会再往上走一层
So in this case, we'll go no higher of a tier

1432
01:11:12,850 --> 01:11:16,025
因为我们没有比三级更高的级别 
than three because we have no higher tiers than three.

1433
01:11:16,025 --> 01:11:18,080
0 1 2 3 
It goes zero, one, two, three.

1434
01:11:18,080 --> 01:11:20,564
然后 无论我们的水平除以5是多少 
And then whatever our level divided by five is,

1435
01:11:20,564 --> 01:11:21,980
而且它只需要数学 地板 
and it would just take math.floor.

1436
01:11:21,980 --> 01:11:26,540
Math.Floor基本上执行除法 然后截断
Math.floor takes in basically performing division and then truncating

1437
01:11:26,540 --> 01:11:28,269
小数点 
the decimal point.

1438
01:11:28,269 --> 01:11:29,060
嗯 不是组织 
Well, not division.

1439
01:11:29,060 --> 01:11:31,760
它只是从字面上截断了一个数字的小数点 
It just literally truncates the decimal point off of a number.

1440
01:11:31,760 --> 01:11:33,260
所以这个水平除以5 
So a level divided by five.

1441
01:11:33,260 --> 01:11:36,560
不管小数点前的数字是多少 
Whatever that is before the decimal point.

1442
01:11:36,560 --> 01:11:39,420
级别模块五加三为最高颜色 
Level modular five plus three for the highest color.

1443
01:11:39,420 --> 01:11:40,430
所以我们要骑车了 
So we'll cycle.

1444
01:11:40,430 --> 01:11:42,140
我们会一遍又一遍地复习 
We'll go over and over again.

1445
01:11:42,140 --> 01:11:46,400
走最高的颜色一 二 三 四 五 然后我们将进入一个新的层次
Go highest color one, two, three, four, five, and then we'll go to a new tier

1446
01:11:46,400 --> 01:11:47,810
级别除以5 
with level divided by 5.

1447
01:11:47,810 --> 01:11:50,520
所以基本上 每五个级别就会在层中递增 
So basically, every five levels will increment in tier,

1448
01:11:50,520 --> 01:11:52,410
然后我们再从蓝色开始 
and then we'll start back at blue.

1449
01:11:52,410 --> 01:11:56,406
然后我们继续 继续 就像这样 每隔几行 
And then we go on, and on, and on like that for every number of rows.

1450
01:11:56,406 --> 01:11:57,530
所以基本上我有几个--
So basically I have a few--

1451
01:11:57,530 --> 01:11:59,889
我将在这一点上稍加强调
I'm going to sort of glaze over this a little bit

1452
01:11:59,889 --> 01:12:02,180
就因为我们可能会赶不上时间 
just because we're probably going to run short on time.

1453
01:12:02,180 --> 01:12:05,360
但我们基本上有两面旗帜 
But we have basically two flags.

1454
01:12:05,360 --> 01:12:10,620
无论我们是跳过这一排的砖块 还是按颜色交替使用砖块 
Whether we're skipping bricks in this row or alternating bricks color wise.

1455
01:12:10,620 --> 01:12:14,810
如果我们这样做 我们需要为它设置一个颜色和一个层 
And if we do, we need to set a color for it and a tier.

1456
01:12:14,810 --> 01:12:16,681
然后我们基本上只是说 你知道的 
And then we basically just say, you know,

1457
01:12:16,681 --> 01:12:19,430
与我们在生成随机行之前使用的逻辑相同
the same sort of logic that we had before we generated random rows

1458
01:12:19,430 --> 01:12:24,350
和列 但是如果我们打开了Alternate标志 
and columns, but if we have the alternate flag on,

1459
01:12:24,350 --> 01:12:31,400
然后 正如我们在这里的一些照片中看到的 我们在这里有一个跳跃是真的 
then as we can see in some of these photos here, here we have skip is true.

1460
01:12:31,400 --> 01:12:36,260
因此 该行的颜色设置为蓝色 但跳过为真 
So the color for that row is set to the blue, but skip is true,

1461
01:12:36,260 --> 01:12:40,700
因此 每隔一块砖就会跳过循环的迭代 
so every other brick is just going to skip that iteration of the loop.

1462
01:12:40,700 --> 01:12:42,980
这里也是一样 只是被1抵消了 
Same thing here, only it's offset by one.

1463
01:12:42,980 --> 01:12:43,770
这里也是一样 
Same thing here.

1464
01:12:43,770 --> 01:12:44,490
这里也是一样 
Same thing here.

1465
01:12:44,490 --> 01:12:46,550
所以这是一种不错的小图案 
So this is kind of a nice little pattern.

1466
01:12:46,550 --> 01:12:47,966
在每一种情况下--
And in each of these cases--

1467
01:12:47,966 --> 01:12:49,340
实际上 并不是每一个案例都是如此 
actually not each of these cases.

1468
01:12:49,340 --> 01:12:52,070
请注意第三个参数 它还将Alternate设置为True 
Notice this third one, it also set alternate to true.

1469
01:12:52,070 --> 01:12:55,250
所以它变成了绿色 紫色 绿色 紫色 绿色 紫色 
So it goes green, purple, green, purple, green, purple.

1470
01:12:55,250 --> 01:12:57,920
所以逻辑是 如果Alternate为真 那么
And so the logic there is if alternate is true, then

1471
01:12:57,920 --> 01:13:00,560
只需在每次迭代中翻转颜色即可 
just flip the color every iteration.

1472
01:13:00,560 --> 01:13:04,430
如果跳过为真 则不要每隔一次迭代生成一块积木 依此类推
If skip is true, don't generate a brick every other iteration, and so on

1473
01:13:04,430 --> 01:13:05,010
以此类推 
and so forth.

1474
01:13:05,010 --> 01:13:09,570
如果有Solid 或者没有Alternate Equals True 
And then if you have solid or if you don't have alternate equals true,

1475
01:13:09,570 --> 01:13:11,750
然后你就会有一块坚固的砖 就像这些蓝色的 
then you have a solid brick like these blue ones.

1476
01:13:11,750 --> 01:13:16,730
如果你有替代但没有跳过 你就会得到这种模式
And if you have alternate but no skip, you get this sort of pattern

1477
01:13:16,730 --> 01:13:18,830
有绿色、紫色、绿色、紫色 
where you have green, purple, green, purple.

1478
01:13:18,830 --> 01:13:20,480
你知道 任何随机的颜色 
You know, any random color.

1479
01:13:20,480 --> 01:13:23,450
而且列数也是随机的 
And then also the number of columns is random.

1480
01:13:23,450 --> 01:13:24,740
所以它可以--
So it can go--

1481
01:13:24,740 --> 01:13:30,590
这里有1 2 3 4 5 6 7 8 9 10 11 但在最下面的这个上 
here we have 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 but on this very bottom one,

1482
01:13:30,590 --> 01:13:35,810
看起来是负二 因为它只能这么宽 
we have that minus two it looks like because it can only go that wide.

1483
01:13:35,810 --> 01:13:37,490
这里的那些也是如此 
And in those here too.

1484
01:13:37,490 --> 01:13:38,660
尺寸要小一些 
Smaller size.

1485
01:13:38,660 --> 01:13:40,100
那个没有空格 
That one there's no spacing.

1486
01:13:40,100 --> 01:13:42,470
所以这些都是非常简单的概念 
So these are very simple concepts.

1487
01:13:42,470 --> 01:13:44,960
比如 我们应该在这次迭代中跳过一个块吗？
Like should we skip a block this iteration?

1488
01:13:44,960 --> 01:13:47,300
我们应该换一下颜色吗？
Should we alternate the colors?

1489
01:13:47,300 --> 01:13:49,970
当你把它们放在一起时 就会产生
And when you put them all together, it produces

1490
01:13:49,970 --> 01:13:52,160
看起来像是几乎是手工制作的东西 
things that look as if they were almost handcrafted.

1491
01:13:52,160 --> 01:13:53,900
就像这可能是某人做的一样 
Like this could be made by somebody.

1492
01:13:53,900 --> 01:13:55,850
就像 这看起来像是有人做的 
Like, that looks like it was made by somebody.

1493
01:13:55,850 --> 01:13:57,170
几乎每一次迭代 
Pretty much every iteration of this.

1494
01:13:57,170 --> 01:13:59,330
我的意思是 即使是这样 那看起来也几乎是一个形状 
I mean, even that, that looks like a shape almost.

1495
01:13:59,330 --> 01:14:03,534
这很简单 但在我看来 结果非常棒 
Its just very simple but the results are pretty awesome in my opinion.

1496
01:14:03,534 --> 01:14:05,700
这就是我们正在做的事情背后的主旨 
And so that's just the gist behind what we're doing.

1497
01:14:05,700 --> 01:14:08,510
我们只是在设置旗帜 然后说 你知道的 
We're just setting flags and just saying, you know,

1498
01:14:08,510 --> 01:14:10,789
如果我们跳过这一轮 跳过每一次迭代 
if we're skipping this turn and just every iteration,

1499
01:14:10,789 --> 01:14:13,580
每次我们铺开一块砖 在这一排上生出一块新砖 
every time we lay out a brick and we spawn a new brick on this row,

1500
01:14:13,580 --> 01:14:14,810
要么做要么不做 
just do or don't.

1501
01:14:14,810 --> 01:14:16,660
只要把它弄成彩色的就行了
Just make it's color--

1502
01:14:16,660 --> 01:14:19,940
如果我们是交替的 选择两种颜色 然后设置
pick two colors if we're alternating and then set

1503
01:14:19,940 --> 01:14:23,660
它的颜色是我们交替的任何关闭的颜色 
its color to whatever the off color is that we're alternating.

1504
01:14:23,660 --> 01:14:26,150
如果我们跳过和交替 那么
And if we're skipping and alternating, then

1505
01:14:26,150 --> 01:14:29,090
我们只是在我们实际铺设的砖头上做
we're just doing whenever we're on a brick that we're actually laying

1506
01:14:29,090 --> 01:14:32,540
就是当我们改变颜色时 交替的颜色 
is when we change the color, the alternate color.

1507
01:14:32,540 --> 01:14:35,004
就像我说的 我不会讲太多细节 
And so like I said, I won't go into too much detail.

1508
01:14:35,004 --> 01:14:36,920
我很乐意在课后讨论发电机 
Happy to talk about the generator after class.

1509
01:14:36,920 --> 01:14:39,240
但我们时间不多了 
But just because we're running short on time,

1510
01:14:39,240 --> 01:14:40,880
我会在上面挥舞双手
sort of going to wave my hands over it.

1511
01:14:40,880 --> 01:14:42,350
但简单来说就是这样 
But that's it in a nutshell.

1512
01:14:42,350 --> 01:14:47,430
在我们休息五分钟之前还有问题吗？
So any questions before we take a break for five minutes?

1513
01:14:47,430 --> 01:14:47,930
- 是吗-是的
Yes?

1514
01:14:47,930 --> 01:15:02,800
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1515
01:15:02,800 --> 01:15:06,340
科尔顿·奥格登：问题是 在这种编程的情况下 
COLTON OGDEN: The question is, in an instance with this programming

1516
01:15:06,340 --> 01:15:10,360
如果球的速度快到我们实际上在砖块里面 
if the ball were so fast that it we're actually inside the brick,

1517
01:15:10,360 --> 01:15:12,633
会怎样？
would it what?

1518
01:15:12,633 --> 01:15:14,174
记者：还会反弹吗？
AUDIENCE: Would it still bounce back?

1519
01:15:14,174 --> 01:15:15,882
科尔顿·奥格登：它还会反弹吗？
COLTON OGDEN: Would it still bounce back?

1520
01:15:15,882 --> 01:15:18,250
答案是不 不会 
The answer is no, it wouldn't.

1521
01:15:18,250 --> 01:15:21,460
此实现不考虑速度
This implementation doesn't take into consideration velocity

1522
01:15:21,460 --> 01:15:24,130
太快了 
that goes too fast.

1523
01:15:24,130 --> 01:15:26,150
主要有两个原因 
Mainly to-- for two reasons.

1524
01:15:26,150 --> 01:15:28,707
第一 它的实现是不平凡的 第二 
One, it's non-trivial to implement, and two,

1525
01:15:28,707 --> 01:15:30,790
这是一件有趣的事情 
it's an interesting thing to look at, and observe,

1526
01:15:30,790 --> 01:15:34,750
并且在你实现自己的游戏时要有意识 
and be conscious of as you go forward in implementing your own games.

1527
01:15:34,750 --> 01:15:38,862
当前的代码 如果它被夹在砖块里 
The current code, if it gets clipped inside of the brick,

1528
01:15:38,862 --> 01:15:41,320
它的边缘不会突出到砖的外面
it will have no edges that are peaking outside of the brick

1529
01:15:41,320 --> 01:15:43,819
因此 它将默认为最终条件 
and therefore, it will default to the final condition, which

1530
01:15:43,819 --> 01:15:47,080
是最后一个else子句 它把它放在砖块下面 
is the last else clause, which puts it below the brick.

1531
01:15:47,080 --> 01:15:48,850
所以它只会在砖下面 
So it'll just go below the brick.

1532
01:15:48,850 --> 01:15:54,212
就像是从下面弹出来的 
It'll almost be as if it came in from the underside and bounced out.

1533
01:15:54,212 --> 01:15:56,920
但是就像我之前提到的 如果你想实现一些东西 
But like I alluded to earlier, if you want to implement something

1534
01:15:56,920 --> 01:16:01,960
像这样 你需要把X帧和X +1帧分割开来
like this yourself, you would have to slice up frame X and frame X plus one

1535
01:16:01,960 --> 01:16:08,440
如果三角洲很宽
into the size of the ball if the delta is so wide

1536
01:16:08,440 --> 01:16:11,800
它要么在砖里面要么在砖外面
that it either goes inside of a brick or it goes outside of a brick,

1537
01:16:11,800 --> 01:16:13,559
还是漏了一块砖
or if it skips a brick.

1538
01:16:13,559 --> 01:16:15,100
这个解决了这个问题 
And this sort of solves that problem.

1539
01:16:15,100 --> 01:16:18,220
它解决了这两个问题 但它有点多
It solves both of those problems, but it's a little more

1540
01:16:18,220 --> 01:16:20,600
比我们在这个例子中所能涵盖的要多 
than we can cover in this example.

1541
01:16:20,600 --> 01:16:24,260
还有其他问题吗？
Any other questions?

1542
01:16:24,260 --> 01:16:24,760
好吧
All right.

1543
01:16:24,760 --> 01:16:28,671
休息五分钟继续工作 
Let's take five and get back to it.

1544
01:16:28,671 --> 01:16:29,170
好吧
All right.

1545
01:16:29,170 --> 01:16:29,960
我们回来了 
And we're back.

1546
01:16:29,960 --> 01:16:35,980
下一步就是我们有一个动态的布局
So the next step is we have basically a layout dynamically

1547
01:16:35,980 --> 01:16:39,310
现在产生了许多有趣的砖 但我们还没有真正
generated of interesting bricks now, but we haven't really

1548
01:16:39,310 --> 01:16:41,680
实施了对其中任何一项的评分 
implemented scoring any of these.

1549
01:16:41,680 --> 01:16:43,570
我们只有分数加10 这就是
We just have score gets score plus 10, which

1550
01:16:43,570 --> 01:16:46,330
其实并不是特别有趣 
isn't really particularly interesting.

1551
01:16:46,330 --> 01:16:50,080
因此 Breakout 7就是我所说的层更新 即
So Breakout7 is what I call the tier update, which

1552
01:16:50,080 --> 01:16:55,160
应该允许我们命中比基本蓝色更高级别的块 
should allow us to hit blocks that are a higher tier than just base blue.

1553
01:16:55,160 --> 01:16:59,800
如果它们的颜色高于基蓝 它们应该降到更低的颜色 
And if they are of a higher color than base blue, they should go down a color.

1554
01:16:59,800 --> 01:17:04,150
因此 如果我们回头看 这个等级是蓝色的
So the hierarchy was, if we look back, blue

1555
01:17:04,150 --> 01:17:08,890
变成绿色 变成红色 变成紫色 变成金色 
goes to green goes to red goes to purple goes to gold.

1556
01:17:08,890 --> 01:17:11,920
如果某个东西是更高的层次 它就会
And if something is a higher tier, it goes

1557
01:17:11,920 --> 01:17:15,640
到它下面的下一个颜色 但在同一层 
to the next color below it but at that same tier,

1558
01:17:15,640 --> 01:17:19,750
除非它恰好是蓝色和灰色的 在这种情况下
unless it happens to be like blue and gray, in which case

1559
01:17:19,750 --> 01:17:22,010
它会变回蓝色 
it'll go back to blue.

1560
01:17:22,010 --> 01:17:30,184
那么 我们如何在这个系统的基础上实施评分呢？
So how might we implement scoring based on this system?

1561
01:17:30,184 --> 01:17:30,850
我们需要什么？
What do we need?

1562
01:17:30,850 --> 01:17:33,770
我们需要些什么呢？
What pieces do we need?

1563
01:17:33,770 --> 01:17:38,202
我们已经拥有了哪些我们可以用来实现这一点的东西？
What pieces do we already have that we can use to make this happen?

1564
01:17:38,202 --> 01:17:40,460
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1565
01:17:40,460 --> 01:17:41,460
科尔顿·奥格登：什么？
COLTON OGDEN: I'm sorry?

1566
01:17:41,460 --> 01:17:52,351
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1567
01:17:52,351 --> 01:17:54,350
科尔顿·奥格登：所以答案是砖块指数 
COLTON OGDEN: So the answer was the brick index.

1568
01:17:54,350 --> 01:18:00,721
所以 是的 砖皮和颜色就是碎片 
So yes, the brick skin and color are the pieces.

1569
01:18:00,721 --> 01:18:01,220
是 
Yes.

1570
01:18:01,220 --> 01:18:03,280
所以这些都是砖块砌成的田地 
So those are fields of brick.

1571
01:18:03,280 --> 01:18:04,420
所以如果我们敞开心扉
So if we open up--

1572
01:18:04,420 --> 01:18:06,950
我要去看《越狱7》 
I'm going to go up to Breakout7.

1573
01:18:06,950 --> 01:18:10,070
我可能会开始推迟很多代码
And I'm going to start probably deferring a lot of this code

1574
01:18:10,070 --> 01:18:12,020
敬未来的阅读 
to future reading.

1575
01:18:12,020 --> 01:18:16,580
但这里的砖块 层数和颜色--
But in brick here, the tier and the color--

1576
01:18:16,580 --> 01:18:19,670
对不起 不是皮 但皮是用来划桨的 
sorry, not skin, but skin is for the paddle.

1577
01:18:19,670 --> 01:18:22,200
但这块砖有一层 它有一种颜色 
But the brick has a tier and it has a color.

1578
01:18:22,200 --> 01:18:25,530
所以我们需要在这里进行一些算术运算 
And so we need to perform some arithmetic on that here.

1579
01:18:25,530 --> 01:18:28,100
这基本上就是第44行到第58行的意思 
And that's essentially what lines 44 through 58 is.

1580
01:18:28,100 --> 01:18:32,420
所以基本上--哦 我道歉 
So basically-- oh, I apologize.

1581
01:18:32,420 --> 01:18:36,330
这实际上并不是算术上的问题 
That's not actually where the arithmetic is.

1582
01:18:36,330 --> 01:18:40,430
44 这是可以计算的 但这是一小段代码
44, that does compute, but this is the bit of code

1583
01:18:40,430 --> 01:18:45,810
这就计算了如果我们发生碰撞 我们实际上可以如何倒退 
that computes how we can actually go backwards if we make a collision.

1584
01:18:45,810 --> 01:18:52,880
所以如果我们撞上了一块砖 它的层级比一层高
So if we collide with a brick and it's of a higher tier than one

1585
01:18:52,880 --> 01:18:57,870
而且它是一种比蓝色更高的颜色 它应该被带回一个台阶 
and it's a higher color than blue, it should be brought back one step.

1586
01:18:57,870 --> 01:19:02,420
但如果它恰好是蓝色的 在这种情况下 self.COLOR会得到一个
But if it happens to be blue, in which case self.color gets one

1587
01:19:02,420 --> 01:19:05,420
因为蓝色是其中之一 那么就应该把它从比赛中剔除
because blue is one, then it should just be removed from play

1588
01:19:05,420 --> 01:19:06,840
就像我们以前做的那样 
just like we've done before.

1589
01:19:06,840 --> 01:19:10,490
只是现在 我们也在考虑层次感和色彩 
Only now, we're also taking in tier and color.

1590
01:19:10,490 --> 01:19:13,460
因此 我们根据我们所处的索引递减层
So we're decrementing tier based on what index we're at

1591
01:19:13,460 --> 01:19:15,890
而且我们的颜色也在减少 
and we're decrementing color.

1592
01:19:15,890 --> 01:19:20,053
然后这实际上会在我们的PlayState中使用 
And then this actually gets used in our PlayState.

1593
01:19:24,000 --> 01:19:29,750
如果我们转到第81行 它之前刚刚
If we go to line 81, which previously just

1594
01:19:29,750 --> 01:19:32,960
让自己得分 得分加一 这里有一点数学知识 
had self.score gets self.score plus one, there's a little bit of math here.

1595
01:19:32,960 --> 01:19:34,220
不过 这很简单 
It's very simple though.

1596
01:19:34,220 --> 01:19:36,290
就是砖头 200倍 
Just brick.tier times 200.

1597
01:19:36,290 --> 01:19:38,270
因此 让这些层的价值达到100 
So make the tiers worth 100.

1598
01:19:38,270 --> 01:19:41,470
再加上砖块 颜色乘以25 
Plus brick.color times 25.

1599
01:19:41,470 --> 01:19:43,520
因此 如果层为零 如果它是基数 那么我们将
And so if tier is zero, if it's a base then we're

1600
01:19:43,520 --> 01:19:44,990
只是拿不到那200英镑的奖金 
just not going to get that 200 bonus.

1601
01:19:44,990 --> 01:19:47,115
但在第一层 一切都将是值得的
But the first tier, everything is going to be worth

1602
01:19:47,115 --> 01:19:49,490
25倍 不管它是什么颜色 
25 times whatever its color is.

1603
01:19:49,490 --> 01:19:52,400
一、二、三、四、五 
So one, two, three, four, five.

1604
01:19:52,400 --> 01:19:55,790
然后再加上200加上砖块的颜色
And then add 200 plus the brick.color for when

1605
01:19:55,790 --> 01:19:58,760
我们到了下一组砖 
we get to the next set of bricks.

1606
01:19:58,760 --> 01:20:01,140
这样做的结果是--
And so the result of this is--

1607
01:20:05,680 --> 01:20:10,120
我相信这是《图形用户界面突破7》 
I believe this is GUI Breakout7.

1608
01:20:14,100 --> 01:20:15,680
如果我们撞到了一块砖--
And then if we hit a brick--

1609
01:20:15,680 --> 01:20:17,520
既然这个是蓝色的 它应该会消失 
since this one is blue, it should disappear.

1610
01:20:17,520 --> 01:20:19,103
我们也在播放一种新的声音 
And we're playing a new sound as well.

1611
01:20:19,103 --> 01:20:21,285
新的 就像 死亡的声音只是为了清楚 
New, like, death sound just to make it clear.

1612
01:20:24,710 --> 01:20:26,337
但请注意 它们会改变颜色 
But notice they change colors.

1613
01:20:26,337 --> 01:20:27,420
这就是我们要做的一切 
So that's all we're doing.

1614
01:20:27,420 --> 01:20:29,960
我们只是想要他们的等级或颜色
We're just taking their tier or their color

1615
01:20:29,960 --> 01:20:32,330
只需对其执行一个简单的减量 
and just performing a simple decrement on it.

1616
01:20:32,330 --> 01:20:33,650
往回循环 
Looping back.

1617
01:20:33,650 --> 01:20:36,620
在我们下一层的情况下 我们应该循环返回
In the event that we go down a tier, we should loop back up

1618
01:20:36,620 --> 01:20:39,440
到较低层的最高颜色 
to the highest color of the lower tier.

1619
01:20:39,440 --> 01:20:41,390
所以我会让你们看看这方面的代码
So I'll let you look at the code for that

1620
01:20:41,390 --> 01:20:44,060
如果你想对它有一个更低层次的理解 
if you want to sort of get a more low level understanding of it,

1621
01:20:44,060 --> 01:20:46,192
但这是一种高层次的理解 
but that's the sort of high level understanding.

1622
01:20:46,192 --> 01:20:48,650
我想向你们介绍的下一个重要概念是
The next big concept that I'd like to introduce you guys to

1623
01:20:48,650 --> 01:20:51,080
是一个粒子系统 
is a particle system.

1624
01:20:51,080 --> 01:20:57,420
因此 粒子系统在视频游戏中相当普遍 
And so particle systems are fairly omnipresent in video games,

1625
01:20:57,420 --> 01:20:59,510
我会说 因为它们产生的效果
I would say, because they make effects that

1626
01:20:59,510 --> 01:21:02,090
或者很难用简单的精灵来做
or otherwise difficult to do with simple sprite

1627
01:21:02,090 --> 01:21:05,720
编辑可以非常容易和现实地实现 
editing achievable very easily and realistically.

1628
01:21:05,720 --> 01:21:07,200
例如 就像火一样 
Just like fire, for example.

1629
01:21:07,200 --> 01:21:10,417
非常有机的 流畅的 有很多东西在进行
Things that are very organic, and flowy, and have a lot going on

1630
01:21:10,417 --> 01:21:12,500
通常用粒子系统表示得更好
are often better represented with particle systems

1631
01:21:12,500 --> 01:21:15,260
而不是使用简单的精灵动画 
than they are with simple sprite animation.

1632
01:21:15,260 --> 01:21:18,230
有谁知道我们如何才能--
So does anybody know how we might be able to--

1633
01:21:18,230 --> 01:21:22,010
粒子系统如何在引擎盖下工作？
how a particle system might work underneath the hood?

1634
01:21:22,010 --> 01:21:26,304
我想我以前提到过这一点 
I think I alluded to it previously.

1635
01:21:26,304 --> 01:21:26,803
是 
Yes.

1636
01:21:26,803 --> 01:21:33,879
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1637
01:21:33,879 --> 01:21:34,670
科尔顿·奥格登：是的 
COLTON OGDEN: Yeah.

1638
01:21:34,670 --> 01:21:38,740
所以他说的是为了生火 
So what he said was in order to make fire,

1639
01:21:38,740 --> 01:21:41,650
例如 只需产生一束粒子
for example, just spawn a bunch of particles

1640
01:21:41,650 --> 01:21:45,320
靠近你的火种产生的中心 然后在它的外面
close to the center of wherever your fire is spawning and then outside of it

1641
01:21:45,320 --> 01:21:46,450
产卵较少 
spawn fewer.

1642
01:21:46,450 --> 01:21:49,900
这绝对是一种让火发挥作用的方法 
That is absolutely a way to get fire to work,

1643
01:21:49,900 --> 01:21:54,190
同时也要考虑到粒子的移动 
and also taking into consideration the travel of your particles.

1644
01:21:54,190 --> 01:21:57,580
例如 你可能会非常密集地产生一吨的火粒子 
For example, you might spawn a ton of fire particles really densely,

1645
01:21:57,580 --> 01:22:00,580
但或许他们有某种逻辑让他们往上走 
but then maybe they have some logic that makes them go upwards.

1646
01:22:00,580 --> 01:22:04,400
也许它们有一个负的增量Y 然后是某种加速度
Maybe they have a negative delta Y and then some sort of acceleration

1647
01:22:04,400 --> 01:22:06,040
因此 他们已经有了一些踪迹 
so they've sort of trail off.

1648
01:22:06,040 --> 01:22:10,270
然后也许是如何获得更逼真的火
And then maybe sort of how to get a more realistic fire

1649
01:22:10,270 --> 01:22:13,720
看 它们向上移动 然后逐渐消失 
look, they travel sort of upwards and then fade away.

1650
01:22:13,720 --> 01:22:16,690
所以火的运作方式 某种程度上是在思考事物
So the way fire works, sort of thinking of things

1651
01:22:16,690 --> 01:22:20,830
就这样的粒子而言 你可以达到很多效果 
in terms of particles like that, you can achieve a lot of effects.

1652
01:22:20,830 --> 01:22:23,360
例如 我们如何实现吸烟？
How might we implement, like, smoke, for example?

1653
01:22:23,360 --> 01:22:24,340
同样的系统 
Same system.

1654
01:22:29,250 --> 01:22:33,980
所以我们可以在粒子效果中使用计时器 
So we could have maybe a timer in our particle effect,

1655
01:22:33,980 --> 01:22:36,170
甚至是一种转变 因为在粒子系统中 
or even a transition because in particle systems,

1656
01:22:36,170 --> 01:22:39,300
通常 您可以在粒子之间过渡颜色 
often you have the ability to transition colors between particles.

1657
01:22:39,300 --> 01:22:41,900
比方说 你从红色开始 到黄色 
Let's say you start off red, go to yellow,

1658
01:22:41,900 --> 01:22:44,996
然后 您的粒子系统可能会过渡到灰色或棕色 
and then maybe your particle system transitions to gray or brown.

1659
01:22:44,996 --> 01:22:47,870
然后随着时间的推移 你的颗粒物会上升 它们会消散 
And then over time, your particles are going up, they're dissipating.

1660
01:22:47,870 --> 01:22:50,210
它们也变暗了 它们变成了棕色 
And they're also turning dark, they're turning brown,

1661
01:22:50,210 --> 01:22:52,820
它给你一种火的错觉 
it sort of gives you the illusion of fire.

1662
01:22:52,820 --> 01:22:54,890
我们不会做任何事情 因为
And we won't be doing anything necessarily as

1663
01:22:54,890 --> 01:22:59,030
在我们的代码中如此复杂 但在Breakout 8中 我们
complex as this in our code here, but in Breakout8, we

1664
01:22:59,030 --> 01:23:04,160
将使用Love的一种集成粒子系统 它只是
will be using Love's sort of integrated particle system which is just

1665
01:23:04,160 --> 01:23:06,770
Love.graph ics.newarticlessystem 
love.graphics.newparticlesystem.

1666
01:23:06,770 --> 01:23:09,830
它接受纹理 因为所有粒子系统都需要某种
And it takes in a texture because all particle systems need some sort

1667
01:23:09,830 --> 01:23:11,630
质地作为它们的基础 
of texture as their foundation.

1668
01:23:11,630 --> 01:23:15,920
然后它需要它最大限度地释放出的粒子的数量 
And then it needs the number of particles that it could maximally emit.

1669
01:23:15,920 --> 01:23:18,740
因此每个单独的粒子系统都可以向上发射
And so each individual particle system can emit up

1670
01:23:18,740 --> 01:23:20,780
到粒子的某个实例 
to a certain instance of particles.

1671
01:23:20,780 --> 01:23:23,234
在数量、速度和诸如此类的东西上
And in the number, and speed, and whatnot of all

1672
01:23:23,234 --> 01:23:25,400
这些颗粒最终是决定因素
those particles is ultimately the determining factor

1673
01:23:25,400 --> 01:23:28,850
你如何才能得到一个幻觉 
for how you can get an illusion.

1674
01:23:28,850 --> 01:23:32,722
回到上周的演讲 幻觉 就像 这不是火 不是烟 
Back to last week's lecture, illusions, like, it's not fire, it's not smoke,

1675
01:23:32,722 --> 01:23:34,430
它只是一群粒子在响应
it's just a bunch of particles responding

1676
01:23:34,430 --> 01:23:36,740
用颜色和加速度之类的东西 
with colors and acceleration and stuff.

1677
01:23:36,740 --> 01:23:40,940
但在Love2D中 粒子系统为您提供了很多功能 
But there's a lot of functions that particle system gives you in Love2D,

1678
01:23:40,940 --> 01:23:44,240
所以我鼓励你们看看这个链接 只是为了探索其中的一些 
so I encourage you to look at that link just to explore some of them.

1679
01:23:44,240 --> 01:23:48,530
Love2d.org/wiki/articlessystem 
Love2d.org/wiki/particlesystem.

1680
01:23:48,530 --> 01:23:49,930
我们将使用其中的几个 
We'll be using a few of them.

1681
01:23:49,930 --> 01:23:53,330
在这里 我将简要地向你们展示 
Here I'm going to just briefly show you.

1682
01:23:53,330 --> 01:23:57,890
所以当每一块砖被击中时
So each individual brick when it gets hit

1683
01:23:57,890 --> 01:23:59,895
需要一个自己的粒子系统 
is going to need a particle system of its own.

1684
01:23:59,895 --> 01:24:00,770
因为我们的目标是--
Because our goal is--

1685
01:24:00,770 --> 01:24:03,870
我将为您运行代码 这样您就可以看到它 
I'll run the code for you so you can see it.

1686
01:24:03,870 --> 01:24:09,290
因此 如果你转到Breakout 8 然后你运行它 
So if you go to Breakout8 and then you run it,

1687
01:24:09,290 --> 01:24:18,390
我们有一点粒子 你们在最后看到的 
we have a little bit of particles you saw there at the very end.

1688
01:24:18,390 --> 01:24:22,250
你可能看得更清楚一点的蓝色 
The blue you were probably able to see a little bit better.

1689
01:24:22,250 --> 01:24:25,150
然后是最后一次 
And then one last time.

1690
01:24:25,150 --> 01:24:27,340
所以它会产生一堆微小的粒子 
So it spawns a bunch of little particles.

1691
01:24:27,340 --> 01:24:30,970
所以有没有人能告诉我他们认为这些粒子
So can anyone tell me how they think the particles are

1692
01:24:30,970 --> 01:24:33,670
一言以蔽之？
behaving sort of in a nutshell?

1693
01:24:33,670 --> 01:24:38,354
粒子的逻辑是什么？
What the logic is for the particles?

1694
01:24:38,354 --> 01:24:40,819
观众：[听不见]稍微有点随意 
AUDIENCE: [INAUDIBLE] slightly random.

1695
01:24:40,819 --> 01:24:41,610
科尔顿·奥格登：是的 
COLTON OGDEN: Yeah.

1696
01:24:41,610 --> 01:24:42,400
有点随机 
Slightly random.

1697
01:24:42,400 --> 01:24:45,940
如果你看它 你也会注意到它们往往是向下的 
And if you look at it, you'll also notice that they tend to go downwards.

1698
01:24:49,030 --> 01:24:52,210
所以知道了这一点 我们大概可以假设
So knowing that, we can probably just assume

1699
01:24:52,210 --> 01:24:57,080
它们有一个趋向于正Y的加速度 
that they have an acceleration that tends towards positive Y.

1700
01:24:57,080 --> 01:24:59,080
这基本上就是我们真正需要做的事情 
And that's essentially all we really need to do.

1701
01:24:59,080 --> 01:25:02,560
我们向外产生一束粒子 然后把它们放在一起--
We spawn a bunch of particles outwards and then just set them--

1702
01:25:02,560 --> 01:25:04,000
他们都有一辈子的时间 
they have all a lifetime.

1703
01:25:04,000 --> 01:25:06,250
它们会持续一段时间 
They last for a certain amount of time.

1704
01:25:06,250 --> 01:25:09,490
然后它们会在两种颜色之间褪色 
And then they fade between two colors.

1705
01:25:09,490 --> 01:25:16,150
在这种情况下 我们从红色褪色为透明或其他任何颜色 
In this case, we fade from red to transparent or whatever color it is.

1706
01:25:16,150 --> 01:25:23,260
然后在生命周期过去之后 它会产生整体的影响
And then after the lifetimes elapsed, it has the overall effect

1707
01:25:23,260 --> 01:25:25,810
这种闪烁的、基于重力的效果 
of sort of this glimmering, gravity based effect,

1708
01:25:25,810 --> 01:25:27,280
但它实际上只是一堆粒子
but it's really just a bunch of particles that are

1709
01:25:27,280 --> 01:25:28,821
设置为在不同方向产卵 
set to spawn in different directions.

1710
01:25:28,821 --> 01:25:30,260
为此道歉 
Apologize for that.

1711
01:25:30,260 --> 01:25:32,110
所以我们来看看 
So we'll take a look.

1712
01:25:32,110 --> 01:25:38,130
它将出现在我们的《突破8》的砖块课上 
It's going to be in our brick class here in Breakout8.

1713
01:25:38,130 --> 01:25:39,380
所以我们要去布里克 
So we're going to go to brick.

1714
01:25:42,290 --> 01:25:45,260
我们在这里储存了一堆颜色 
We have a bunch of colors that we're storing here.

1715
01:25:45,260 --> 01:25:49,820
所以如果你注意到了 粒子系统采用的是任何砖块的颜色
So if you notice, the particle systems adopt the color of whatever brick

1716
01:25:49,820 --> 01:25:52,430
他们的打击只是为了让它保持一致
they're hitting just so that it stays sort of congruent

1717
01:25:52,430 --> 01:25:54,185
与我们正在看的东西相吻合 
with what we're looking at.

1718
01:25:54,185 --> 01:25:56,060
所以我们只是在这里存储了一堆颜色 
So we're just storing a bunch of colors here.

1719
01:25:56,060 --> 01:25:57,950
我也不会太担心这一点 
And I wouldn't worry too much about this.

1720
01:25:57,950 --> 01:25:59,824
这些只是精灵调色板中的颜色
These are just colors from the sprite palette

1721
01:25:59,824 --> 01:26:01,760
我们用在我们的精灵艺术上 
that we used with our sprite art.

1722
01:26:01,760 --> 01:26:04,490
有一些特定的颜色只在那个精灵中使用 
There's specific colors that are only used in that sprite.

1723
01:26:04,490 --> 01:26:06,487
一般来说 有一个调色板 
And having a palette, generally speaking,

1724
01:26:06,487 --> 01:26:08,570
让你的作品看起来更有凝聚力
allows your art to look a little bit more cohesive

1725
01:26:08,570 --> 01:26:11,694
当你在做精灵艺术 而不是任性地挑选颜色 
when you're doing sprite art as opposed to just picking colors willy nilly.

1726
01:26:11,694 --> 01:26:15,320
如果你说 哦 这个调色板我只会用16或32种颜色 
If you say, oh, I'm going to only use 16 or 32 colors for this palette,

1727
01:26:15,320 --> 01:26:17,840
你会看起来更有凝聚力 而且
you'll sort of have a more cohesive look and also

1728
01:26:17,840 --> 01:26:20,780
非常复古的外观 因为硬件通常是
a very retro look because often hardware was

1729
01:26:20,780 --> 01:26:25,190
对于较旧的系统 仅限于一定数量的颜色 
limited to a certain amount of colors back in the day for older systems.

1730
01:26:25,190 --> 01:26:26,960
所以我很高兴--
So it's nice to--

1731
01:26:26,960 --> 01:26:30,050
顺便说一句 我们下周也会讨论这个问题 
as an aside-- and we'll look at it next week as well.

1732
01:26:30,050 --> 01:26:34,137
当你在做自己的精灵艺术时 试着使用更少的颜色
Looking at when you're doing your own sprite art, try to use fewer colors

1733
01:26:34,137 --> 01:26:36,720
然后这会给你--它也会让你更容易 
and then that will give you-- it also makes it easier for you.

1734
01:26:36,720 --> 01:26:40,970
你不必花时间来挑选 我想要这种绿色 
You don't have to spend time choosing I want to have this shade of green.

1735
01:26:40,970 --> 01:26:42,240
我想知道它看起来好不好 
I wonder if it looks good.

1736
01:26:42,240 --> 01:26:45,634
如果你只有两种深浅绿色或半深浅绿色可供选择 
If you only have two shades of green or semi shades of green to choose from,

1737
01:26:45,634 --> 01:26:46,550
这就是你能做的一切 
that's all you've got.

1738
01:26:46,550 --> 01:26:48,302
你必须尽你所能凑合着使用它 
You have to make do with it what you can.

1739
01:26:48,302 --> 01:26:51,260
所以我们在这里做的是从调色板中存储五种颜色 
So what we're doing here is we're storing five colors from our palette.

1740
01:26:51,260 --> 01:26:52,430
我们将利用这一点 
We're going to use this.

1741
01:26:52,430 --> 01:26:54,920
然后当我们启动我们的.
And then when we trigger our--

1742
01:26:54,920 --> 01:26:57,980
就在这里 我们正在初始化一个粒子系统 
so right here we're initializing a particle system.

1743
01:26:57,980 --> 01:27:02,150
因此 psystem得到了love.graph ics.newarticlessystem 
So psystem gets love.graphics.newparticlesystem.

1744
01:27:02,150 --> 01:27:04,130
然后是几个函数 
And then these are a few functions.

1745
01:27:04,130 --> 01:27:07,370
因此 您可以在维基中查看这些功能的实际运行方式 
So feel free to look in the wiki for how these functions actually behave.

1746
01:27:07,370 --> 01:27:10,550
但终生加速和面积扩散
But lifetime acceleration and area spread

1747
01:27:10,550 --> 01:27:13,190
只是在某种程度上影响了
just are sort of the properties that influence

1748
01:27:13,190 --> 01:27:15,330
我们的粒子系统的行为方式 
the way our particle systems behave.

1749
01:27:15,330 --> 01:27:17,600
所以使用我们当前的颜色 
And so using whatever our current color is,

1750
01:27:17,600 --> 01:27:21,230
我们将使用setColors函数设置psystem的颜色 
we're going to set our psystem's colors using setcolors function.

1751
01:27:21,230 --> 01:27:23,200
我们要把它设置在两种颜色之间 
We're going to set it between two colors.

1752
01:27:23,200 --> 01:27:28,796
层Alpha的颜色为55倍 Alpha为零的颜色 
Color with 55 times tier alpha and color with zero alpha.

1753
01:27:28,796 --> 01:27:30,920
因此 层数越高 粒子越亮 
So the higher the tier, the brighter the particles,

1754
01:27:30,920 --> 01:27:34,130
但如果这有道理的话 它们总是会逐渐消失到零阿尔法 
but they'll always fade to zero alpha, if that makes sense.

1755
01:27:34,130 --> 01:27:35,760
然后我们就会排放64 
And then we'll just emit 64.

1756
01:27:35,760 --> 01:27:37,650
这些都在HIT功能中 
And this is all in the hit function.

1757
01:27:37,650 --> 01:27:42,020
所以我们基本上所做的就是在我们的命中中添加这个粒子系统触发器
So all we've basically done is just add this particle system trigger in our hit

1758
01:27:42,020 --> 01:27:46,170
函数 它具有我们前面看到的行为的结果 
function, and it has the result of the behavior that we saw earlier.

1759
01:27:46,170 --> 01:27:49,700
那么 关于粒子系统或我们如何使用它们有什么问题吗？
So any questions on particle systems or how we use them?

1760
01:27:53,220 --> 01:27:55,830
因此 级别9是进度更新 
So level 9 is the progression update.

1761
01:27:55,830 --> 01:27:59,880
因此 此更新的目的是让我们从第一个级别开始
So the purpose of this update is to allow us to go from level one

1762
01:27:59,880 --> 01:28:04,170
从两个到三个到四个 开始变得更有趣
to two to three to four and start get more interesting level

1763
01:28:04,170 --> 01:28:06,510
一代人都是这样的 
generation that way.

1764
01:28:06,510 --> 01:28:09,480
这件事的主旨在于我们--
The gist of this is in our--

1765
01:28:09,480 --> 01:28:11,932
所以如果你看看我们的StartState--
so if you look at our StartState--

1766
01:28:16,180 --> 01:28:22,090
所以我们真正需要做的就是存储一个级别 只需存储一个数字 
so all we need to really do to store a level is just to store a number.

1767
01:28:22,090 --> 01:28:24,850
然后我们在哪里递增这个数字？
And then where do we increment the number?

1768
01:28:24,850 --> 01:28:28,069
或者我们什么时候增加我应该说的数字？
Or when do we increment the number I should say?

1769
01:28:28,069 --> 01:28:33,914
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1770
01:28:33,914 --> 01:28:34,830
科尔顿·奥格登：没错 
COLTON OGDEN: Exactly.

1771
01:28:34,830 --> 01:28:40,590
因此 我们增加了级别 
So we increment the level.

1772
01:28:40,590 --> 01:28:43,560
我们进入下一阶段 当所有的砖块
We go to the next level when all of the bricks

1773
01:28:43,560 --> 01:28:47,310
正在进行中已到达那里 正在进行中标志设置为假 
are in play have gotten there in play flag set to false.

1774
01:28:47,310 --> 01:28:52,720
所以我们没有有效发挥作用的刺头 
So we have no pricks that are in play effectively.

1775
01:28:52,720 --> 01:28:54,840
所以在我们的StartState中--
So in our StartState--

1776
01:28:54,840 --> 01:28:57,086
让我们继续看《突破9》 
so let's go ahead and look at Breakout9.

1777
01:29:00,990 --> 01:29:02,147
所以 StartState 
So StartState.

1778
01:29:05,803 --> 01:29:07,711
我们正在通过这里的一层 
We're passing in level gets one here.

1779
01:29:07,711 --> 01:29:08,960
我们只是要开始了 
We're just going to start off.

1780
01:29:08,960 --> 01:29:12,043
当我们要去StartState的时候 我们只需要通过等于1的级别 
When we're going to StartState, we're just going to pass level equals one.

1781
01:29:12,043 --> 01:29:17,450
从今以后 任何时候我们从打球到发球的任何状态变化
And then henceforth, anytime we do any state changes from play to serve

1782
01:29:17,450 --> 01:29:19,940
而胜利 正如我们将看到的 胜利是我们的新的 
and to victory, as we'll see, victory being our new,

1783
01:29:19,940 --> 01:29:21,750
哦 你清除了这个级别 
oh, you cleared this level.

1784
01:29:21,750 --> 01:29:22,690
这是下一个关口 
Here's the next level.

1785
01:29:22,690 --> 01:29:27,050
我们只是要超过他们之间的水平 
We're just going to pass the level between them.

1786
01:29:27,050 --> 01:29:37,962
然后在PlayState中 这里的重要代码在204行 
And then in PlayState, the important bit of code here is on line 204.

1787
01:29:37,962 --> 01:29:39,920
所以这只是一个名为check Vicary的函数 
So this is just a function called checkVictory,

1788
01:29:39,920 --> 01:29:41,480
正如詹姆斯所说的那样 
which is exactly as James said.

1789
01:29:44,090 --> 01:29:48,590
我们将遍历整个表 并只说它是否在运行 
We're going to iterate over the entire table and just say if it's in play,

1790
01:29:48,590 --> 01:29:50,360
返回错误 因为我们没有取得胜利
return false because we're not in victory

1791
01:29:50,360 --> 01:29:52,070
如果我们有任何砖块在发挥作用 
if we have any bricks that are in play.

1792
01:29:52,070 --> 01:29:55,850
但如果我们不满足该条件 则返回TRUE 
But return true if we didn't meet that condition.

1793
01:29:55,850 --> 01:29:59,390
所以这只是一种简单的方式 让我们检查
And so this is just a simple way for us to check whether or not

1794
01:29:59,390 --> 01:30:02,730
我们取得了胜利 
we are in a victory.

1795
01:30:02,730 --> 01:30:05,800
因此 在我们的PlayState中同一文件的第88行 
And so on line 88 of the same file in our PlayState,

1796
01:30:05,800 --> 01:30:09,560
我们只是想说 嘿 如果我们做了任何砖头之后 自己检查胜利
we're just checking to say, hey, if self.checkVictory after we do any brick

1797
01:30:09,560 --> 01:30:10,160
命中--
hit--

1798
01:30:10,160 --> 01:30:13,370
因为在那个时候 我们刚刚设置的一块砖是错误的--
because that's when we've just set a brick to in play is false--

1799
01:30:13,370 --> 01:30:14,880
只要检查胜利就好 
just check victory.

1800
01:30:14,880 --> 01:30:17,900
如果是这样的话 播放一个新的声音 就像一个快乐的声音
And if so, play a new sound like a happy sound

1801
01:30:17,900 --> 01:30:20,390
我们已经取得了胜利 然后就把一切都抛诸脑后了
that we've done a victory, and then just pass everything

1802
01:30:20,390 --> 01:30:22,400
进入我们这里拥有的新的维克托州 
into the new VictoryState that we have here.

1803
01:30:22,400 --> 01:30:27,410
而VictoryState仅仅是一种消息状态 
And the VictoryState is simply a sort of just a message state.

1804
01:30:27,410 --> 01:30:30,630
所以它所做的只是像以前一样渲染一切 
So all it does is just renders everything as before,

1805
01:30:30,630 --> 01:30:34,150
但它只是说你目前的水平已经完成了 
but it just says your current level complete.

1806
01:30:34,150 --> 01:30:36,342
自我.级别完成 
Self.level complete.

1807
01:30:36,342 --> 01:30:39,050
然后按Enter键服务 它将返回到ServeState
And then press Enter to serve and it'll go back to the ServeState

1808
01:30:39,050 --> 01:30:41,100
一旦发生这种情况 
as soon as that happens.

1809
01:30:41,100 --> 01:30:47,270
然后 这就是实际进展发生的地方 
And then here is where the actual progression happens.

1810
01:30:47,270 --> 01:30:51,450
当我们转到ServeState时 我们有自己的级别 但我们想要添加一个 
When we go to the ServeState, we have our level but we want to add one to it.

1811
01:30:51,450 --> 01:30:57,320
因此 当我们触发到下一个状态的转换时 我们需要做的就是
So all we need to do when we trigger a transition into our next state, just

1812
01:30:57,320 --> 01:31:01,550
在这里将级别递增1 并创建
increment level by one here, and also create

1813
01:31:01,550 --> 01:31:05,470
一个新的地图 因为砖块需要重新开始 因为我们有一个新的关卡 
a new map because bricks needs to get restarted because we have a new level.

1814
01:31:05,470 --> 01:31:07,680
自我 级别加一 
Self.level plus one.

1815
01:31:07,680 --> 01:31:12,820
这将会产生 哦 我们已经从第一级到第二级的效果
And that'll have the effect of, oh, we've gone from level one to two

1816
01:31:12,820 --> 01:31:17,480
当我们在PlayState和VictoryState之间穿梭时 会有三到四个人等等
to three to four et cetera when we go between PlayState to the VictoryState

1817
01:31:17,480 --> 01:31:19,110
回到ServeState 
back to the ServeState.

1818
01:31:19,110 --> 01:31:21,420
那么 对这一切是如何运作的有什么问题吗？
So any questions on how any of this works?

1819
01:31:21,420 --> 01:31:21,920
是 
Yes.

1820
01:31:21,920 --> 01:31:24,545
观众：你需要担心垃圾回收吗？
AUDIENCE: Do you have to worry about garbage collection for any

1821
01:31:24,545 --> 01:31:26,294
所有的砖块吗？
of the bricks at all?

1822
01:31:26,294 --> 01:31:28,211
或者这是由爱情引擎以某种方式处理的？
Or is that handled by the Love engine somehow?

1823
01:31:28,211 --> 01:31:30,377
科尔顿·奥格登：垃圾收集是由Love处理的 
COLTON OGDEN: Garbage collection is handled by Love.

1824
01:31:30,377 --> 01:31:31,060
是 
Yes.

1825
01:31:31,060 --> 01:31:31,560
嗯 
Yeah.

1826
01:31:31,560 --> 01:31:32,760
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1827
01:31:32,760 --> 01:31:33,510
科尔顿·奥格登：是的 
COLTON OGDEN: Yes.

1828
01:31:33,510 --> 01:31:37,550
因为问题是 你需要担心垃圾收集吗？
Because the question was, do you have to worry about garbage collection

1829
01:31:37,550 --> 01:31:40,880
当我们清理砖块并添加新砖的时候？
when we are sort of clearing away the bricks and adding new bricks?

1830
01:31:40,880 --> 01:31:45,950
砖桌 这张桌子 它是
The self.bricks table, this table here, it's

1831
01:31:45,950 --> 01:31:48,950
被分配到一张全新的桌子上 这张桌子来自velmap.createmap 
getting assigned to a brand new table from levelmap.createmap.

1832
01:31:48,950 --> 01:31:51,950
当不存在对现有表的引用时 
When there are no references to an existing table,

1833
01:31:51,950 --> 01:31:54,290
Lua的垃圾收集器将在任何地方触发
lua's garbage collector will trigger at whatever

1834
01:31:54,290 --> 01:31:57,410
它被设置为动态触发和清除所有这些 
interval it's set to trigger and clear up all that for you dynamically.

1835
01:31:57,410 --> 01:32:00,050
就像Java的工作方式一样 
Just like the same way that Java works.

1836
01:32:00,050 --> 01:32:02,810
几乎一模一样 
Almost identical.

1837
01:32:02,810 --> 01:32:06,170
还有其他问题吗？
Any other questions?

1838
01:32:06,170 --> 01:32:07,690
好的 
All right.

1839
01:32:07,690 --> 01:32:10,020
所以我们有进步 
So we have progression.

1840
01:32:10,020 --> 01:32:11,500
为了速度 我不做演示 
In the sake of speed, I won't demo.

1841
01:32:11,500 --> 01:32:14,499
这也需要一段时间 因为我们必须清除整个关卡
It also takes a while just because we have to clear an entire level then

1842
01:32:14,499 --> 01:32:16,030
更上一层楼 
get to the next level.

1843
01:32:16,030 --> 01:32:17,680
但这就是这种行为的运作方式 
But that's how the behavior works.

1844
01:32:17,680 --> 01:32:22,780
这种情况的下一种迭代是高分 
The next sort of iteration of this is high scores.

1845
01:32:22,780 --> 01:32:30,040
我将进行测试 以确保这是否真的有效 
And I will test to make sure whether or not this is actually working.

1846
01:32:30,040 --> 01:32:31,730
我知道我改变了一些东西 
I know I changed some stuff.

1847
01:32:31,730 --> 01:32:32,230
嗯 
Yeah.

1848
01:32:32,230 --> 01:32:33,169
这么高的分数 
So high score.

1849
01:32:33,169 --> 01:32:34,210
让我们调试一下 
Let's debug for a second.

1850
01:32:34,210 --> 01:32:41,863
因此 在Breakout 10中 HighScoreState第38行 
So HighScoreState line 38 in Breakout10.

1851
01:32:44,750 --> 01:32:46,730
所以 HighScoreState 
So HighScoreState.

1852
01:32:49,780 --> 01:32:54,030
然后问题是[INAUDIBLE]索引领域的高分 
And then the issue was [INAUDIBLE] to index field high scores.

1853
01:32:54,030 --> 01:32:56,270
零值 
A nil value.

1854
01:32:56,270 --> 01:32:57,000
好的 
OK.

1855
01:32:57,000 --> 01:32:59,620
所以这意味着--
So that means that--

1856
01:32:59,620 --> 01:33:00,120
好的 
OK.

1857
01:33:00,120 --> 01:33:03,420
我想我可能知道问题所在 但这是因为我
I think I might know the issue, but it's because I

1858
01:33:03,420 --> 01:33:06,570
已转换为新用户 该新用户在此上没有活动的已保存文件 
transitioned to a new user that doesn't have a saved file active on this.

1859
01:33:06,570 --> 01:33:12,780
因此 将过渡到love.file系统的方式 它
The way that will transition, therefore, into love.file system, which

1860
01:33:12,780 --> 01:33:17,910
它引入的主要新事物是《突破10》的S--所以写文件
is Breakout10's main new thing that it introduces-- so writing files

1861
01:33:17,910 --> 01:33:22,429
到您的文件系统的操作使用love.filessystem完成[INAUDIBLE] 
to your file system is done [INAUDIBLE] with love.filesystem.

1862
01:33:22,429 --> 01:33:23,470
有几件事 
And there's a few things.

1863
01:33:23,470 --> 01:33:28,870
所以Love会自动给你一个目录 一个保存的目录
So Love automatically gives you a directory, a save directory

1864
01:33:28,870 --> 01:33:30,120
这几乎是硬编码 
that's pretty much hard coded.

1865
01:33:30,120 --> 01:33:33,960
关于如何不使用该目录 有几个例外 
There are a few exceptions as to how to not use that directory,

1866
01:33:33,960 --> 01:33:36,480
但它假定您一直在使用该目录 
but it assumes that you're always using that directory.

1867
01:33:36,480 --> 01:33:42,750
除了极少数例外 您将始终使用该文件夹 
And with very few exceptions will you always use that folder.

1868
01:33:42,750 --> 01:33:47,460
它就像Windows上的本地应用程序数据 以及应用程序支持 
It's like app data local on Windows, and application support,

1869
01:33:47,460 --> 01:33:50,850
以及您在Mac上的应用程序的名称 
and the name of your application on Mac.

1870
01:33:50,850 --> 01:33:53,490
但它是Love拥有读写权限的子文件夹
But it's a subfolder that Love has read and write access to

1871
01:33:53,490 --> 01:33:55,650
用于您的文件系统上的文件 
for files on your file system.

1872
01:33:55,650 --> 01:33:59,940
您可以检查它是否与love.filesystem.存在于某个路径中 
You can check whether it exists with love.filesystem.exists at some path.

1873
01:33:59,940 --> 01:34:03,870
您可以使用一些数据写入该路径 这些数据是字符串值 
You can write to that path with some data, that data being a string value.

1874
01:34:03,870 --> 01:34:08,140
然后love.filesystem.line是一个迭代器 
And then love.filesystem.lines is an iterator,

1875
01:34:08,140 --> 01:34:11,040
这将允许您查看任何数据 
which will allow you to look over any of the data that's

1876
01:34:11,040 --> 01:34:12,720
在给定位置的文件中 
in a file at a given location.

1877
01:34:12,720 --> 01:34:13,395
是 
Yes.

1878
01:34:13,395 --> 01:34:16,010
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1879
01:34:16,010 --> 01:34:17,010
科尔顿·奥格登：是的 
COLTON OGDEN: Yeah.

1880
01:34:17,010 --> 01:34:20,930
观众：如果你[INAUDIBLE]
AUDIENCE: Does this work if you [INAUDIBLE]

1881
01:34:20,930 --> 01:34:21,930
科尔顿·奥格登：应该是这样 
COLTON OGDEN: It should.

1882
01:34:21,930 --> 01:34:24,150
实际上 我们现在可以把它拉出来看看 
We can pull that up now actually and see.

1883
01:34:24,150 --> 01:34:28,500
因为我知道他们的2D爱情--
Because I know on their Love2D--

1884
01:34:28,500 --> 01:34:30,180
因此 文件系统 
so file system.

1885
01:34:30,180 --> 01:34:35,910
所以问题是他把他的.
So the question was he ported his--

1886
01:34:35,910 --> 01:34:39,390
当你将Love应用程序移植到iPhone上时 
when you port your Love app to the iPhone,

1887
01:34:39,390 --> 01:34:43,440
它会有同样的行为吗 如果你是--
will it have the same sort of behavior if you're--

1888
01:34:47,867 --> 01:34:50,700
在iPhone上 它会有同样的保存目录行为吗？
on an iPhone, will it have the same sort of save directory behavior?

1889
01:34:50,700 --> 01:34:53,010
而且看起来它还没有正式出现在这里 
And it looks like it's not officially on here.

1890
01:34:53,010 --> 01:34:57,840
我知道有一个用于Love2D的iOS端口 
I know that there is an iOS port for Love2D,

1891
01:34:57,840 --> 01:35:02,458
或者将其发送到Love2D的能力 
or the ability to send it to Love2D.

1892
01:35:02,458 --> 01:35:05,610
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1893
01:35:05,610 --> 01:35:07,110
科尔顿·奥格登：我想是的 
COLTON OGDEN: I have to imagine yes.

1894
01:35:07,110 --> 01:35:08,359
它可能有某种--
It probably has some sort of--

1895
01:35:08,359 --> 01:35:14,040
我并不完全熟悉iOS是如何处理本地存储的 
I'm not entirely familiar with how iOS handles sort of local storage,

1896
01:35:14,040 --> 01:35:18,210
但我假设只是从桌面抽象出来的方式
but I'm assuming that just in the way that it's been abstracted for desktops

1897
01:35:18,210 --> 01:35:20,460
而对于Android 它也是为iOS抽象的 
and for Android, it's also abstracted for iOS.

1898
01:35:20,460 --> 01:35:22,320
我自己还没有测试过 
Haven't tested it myself.

1899
01:35:22,320 --> 01:35:25,260
我会用这段代码做实验 看看有没有可能 
I would experiment and see actually maybe with this code.

1900
01:35:25,260 --> 01:35:29,200
看看你能不能让它在持续的高分下发挥作用 
See if you can maybe get it working with persistent high scores.

1901
01:35:29,200 --> 01:35:33,292
我知道iOS通常允许您在每个应用程序中存储少量数据
I know that iOS does typically let you store a small amount of data per app

1902
01:35:33,292 --> 01:35:35,250
在某个地方 一个固定的地方 但我不是
in some location, a fixed location, but I'm not

1903
01:35:35,250 --> 01:35:37,920
完全确定这是即兴的事情 
entirely sure what that is offhand.

1904
01:35:37,920 --> 01:35:40,400
我可以更深入地研究一下 然后想出一个--
I can look into it more and come up with a--

1905
01:35:40,400 --> 01:35:41,609
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1906
01:35:41,609 --> 01:35:42,400
科尔顿·奥格登：是的 
COLTON OGDEN: Yeah.

1907
01:35:42,400 --> 01:35:45,180
我的意思是 不是来自第一手 因为我没有机器人 
I mean, not from firsthand because I don't have an Android,

1908
01:35:45,180 --> 01:35:47,280
但它有官方的Android支持 
but it has official Android support.

1909
01:35:47,280 --> 01:35:50,840
所以我猜是的 但我还没测试过 
So I'm guessing it does, but I haven't tested it.

1910
01:35:50,840 --> 01:35:53,710
我还没有在Android上手动测试它来验证这一点 
I have not tested it manually on Android to verify that.

1911
01:35:59,030 --> 01:36:00,190
不过 是的 
But yes.

1912
01:36:00,190 --> 01:36:03,420
我相信--因为在之前的目录中 当它
I believe-- because in the prior directory we were looking at when it

1913
01:36:03,420 --> 01:36:05,690
展示了--
showed--

1914
01:36:05,690 --> 01:36:08,690
哦 实际上就在这上面 
oh, it's actually up here.

1915
01:36:08,690 --> 01:36:09,750
这条路在这里 
This path here.

1916
01:36:09,750 --> 01:36:14,640
这个数据/user/0/love2d.android 
This data/user/0/love2d.android.

1917
01:36:14,640 --> 01:36:15,300
文件保存 
file save.

1918
01:36:15,300 --> 01:36:18,990
在我看来 这是一条官方的道路
That looks to me like it's the official sort of path

1919
01:36:18,990 --> 01:36:22,050
这些数据存储在Android设备上 供应用程序使用 
that data is stored on an Android device for application.

1920
01:36:22,050 --> 01:36:24,150
所以我还没有亲自测试过 
So I haven't tested it myself.

1921
01:36:24,150 --> 01:36:27,360
但如果你有一个机器人 你很好奇 或者可能是一个仿真器 
But if you have an Android and you're curious or maybe an emulator,

1922
01:36:27,360 --> 01:36:30,470
试一试 看看它是否奏效 
give it a shot and see if it works.

1923
01:36:30,470 --> 01:36:32,970
哦 这里甚至写着 有各种各样的保存地点 
Oh, and it even says here, there are various save locations.

1924
01:36:32,970 --> 01:36:35,760
如果它们不起作用 你可以看到实际位置
And if they don't work, you can see what the actual location

1925
01:36:35,760 --> 01:36:37,200
就是这里的这个功能 
is with this function here.

1926
01:36:37,200 --> 01:36:39,540
Love.filesystem.get保存目录 
The love.filesystem.get save directory.

1927
01:36:39,540 --> 01:36:43,440
这可能也适用于iOS 所以我很想知道
That may work on iOS as well, so I'd be curious to hear about

1928
01:36:43,440 --> 01:36:45,360
这是否真的能解决这个问题 
whether that actually works on that.

1929
01:36:50,790 --> 01:36:51,300
嗯 
Yeah.

1930
01:36:51,300 --> 01:36:52,260
这就是要点所在 
So that's the gist.

1931
01:36:52,260 --> 01:36:55,530
通过使用love.filessystem抽象 我们可以读写文件 
Using the love.filesystem abstraction lets us read and write files.

1932
01:36:55,530 --> 01:36:58,470
然后我们可以直接粘贴 也可以直接保存任何数据
We can then just paste or we can just save whatever data

1933
01:36:58,470 --> 01:37:02,520
我们想要那个目录中的任何地方 
we want anywhere within that directory.

1934
01:37:02,520 --> 01:37:06,090
我们可以在那里创建文件 然后使用这些文件来存储我们的
We can just create files in there and then use those to store our,

1935
01:37:06,090 --> 01:37:10,440
你知道 游戏世界 或者角色简介 或者诸如此类的东西 
you know, sort of game worlds, or character profiles, or whatnot.

1936
01:37:10,440 --> 01:37:14,445
我们将如何实施一份类似高分名单的计划？
How would we maybe go about implementing sort of like a high score list?

1937
01:37:21,290 --> 01:37:21,860
所以我会找的 
So I'll look.

1938
01:37:21,860 --> 01:37:24,360
这里有一张照片 
There's a picture here.

1939
01:37:24,360 --> 01:37:27,320
所以我们有10分 
So we have 10 scores.

1940
01:37:27,320 --> 01:37:29,390
我们就假设这个问题已经解决了 
We'll assume that's fixed.

1941
01:37:29,390 --> 01:37:34,650
每个分数都有一个名称 然后每个分数都有一个实际分数 
Each of the scores has a name, and then each of the scores has an actual score.

1942
01:37:34,650 --> 01:37:39,230
所以我们真正需要做的就是最终存储这些名字
So all we really need to do is just store ultimately the names

1943
01:37:39,230 --> 01:37:42,190
然后是比分 
and then the scores.

1944
01:37:42,190 --> 01:37:47,680
观众：[听不见]
AUDIENCE: [INAUDIBLE]

1945
01:37:47,680 --> 01:37:49,180
科尔顿·奥格登：所以我们将使用一个数组 
COLTON OGDEN: So we'll use an array.

1946
01:37:49,180 --> 01:37:53,371
他们的回答是 我们将使用按该分数排序的数组 
Their response was we'll use an array as sorted by that score.

1947
01:37:53,371 --> 01:37:53,870
嗯 
Yeah.

1948
01:37:53,870 --> 01:37:55,120
从本质上说 就是这样 
Essentially that's exactly it.

1949
01:37:55,120 --> 01:37:57,560
我们只需要保留一个计分表 每个表
We're just going to keep a score table and each table

1950
01:37:57,560 --> 01:37:59,069
将会有一张小桌子 
is going to have a sub table.

1951
01:37:59,069 --> 01:38:00,860
这些条目中的每一个 从一到十
And each of those entries, one through ten,

1952
01:38:00,860 --> 01:38:02,870
将会有一个名字和一个分数 
is going to have a name and a score.

1953
01:38:02,870 --> 01:38:05,300
然后 一旦我们完成了应用程序 
And then once we're done with our application,

1954
01:38:05,300 --> 01:38:07,790
我们将只使用love.filesystem.write 
we'll just use love.filesystem.write.

1955
01:38:07,790 --> 01:38:10,460
我们必须将所有这些内容转换为一个字符串
We'll have to convert all of those into a string

1956
01:38:10,460 --> 01:38:15,200
因为我们不能只拿一张桌子 然后把它吐到一个文件里 
because we can't just take a table and then spit that out into a file.

1957
01:38:15,200 --> 01:38:18,230
我们必须把它变成某种我们可以拯救的形式
We have to actually make it into some form that we can save

1958
01:38:18,230 --> 01:38:20,880
然后以某种方式重新装填 
and then reload back in somehow.

1959
01:38:20,880 --> 01:38:24,295
你认为什么是最有效的方式 或者我们可以做到这一点的一种方式？
What would be the most efficient way, do you think, or a way we can do this?

1960
01:38:28,950 --> 01:38:31,995
可能只是一个新的以行分隔的列表 
Probably just a new line separated list.

1961
01:38:31,995 --> 01:38:33,870
我在这个应用程序中这样做的方式
The way that I've done it in this application

1962
01:38:33,870 --> 01:38:39,570
就是名字 然后是新行、分数、新行、名字、新行、分数 
is just names, and then new line, score, new line, name, new line, score.

1963
01:38:39,570 --> 01:38:41,280
10 也就是20排 
10, so 20 rows.

1964
01:38:41,280 --> 01:38:43,130
这就完成了工作 
And that gets the job done.

1965
01:38:43,130 --> 01:38:46,772
假设您没有篡改文件 那么一切都应该正常工作 
Assuming that you don't tamper with the file, then everything should work.

1966
01:38:46,772 --> 01:38:48,480
您还可以编写其他代码
And you can write additional code as well

1967
01:38:48,480 --> 01:38:51,845
说 哦 如果有分数 那就是全部
to say, oh, if there is a score that's all

1968
01:38:51,845 --> 01:38:53,970
乱码 我们没有足够的分数 那么很可能
garbled, we don't have enough scores, then probably

1969
01:38:53,970 --> 01:38:55,500
应该相应地呈现它 
should render it accordingly.

1970
01:38:55,500 --> 01:38:59,272
我的代码执行类似的操作 但不完全是这样 
My code does something similar to this, but not entirely.

1971
01:39:02,370 --> 01:39:06,240
相关代码--我将对其进行简单介绍 
The relevant code-- and I'm going to sort of just glaze over it.

1972
01:39:06,240 --> 01:39:08,640
如果我们在看--这是突破口11 对吗？
If we're looking at-- this is Breakout11, right?

1973
01:39:08,640 --> 01:39:09,140
嗯 
Yeah.

1974
01:39:09,140 --> 01:39:11,550
哦 不 这是《突破10》 
Oh, no, this is Breakout10.

1975
01:39:11,550 --> 01:39:14,850
所以在《突破10》中 我们必须加载所有的高分
So in Breakout10, we have to load all the high scores

1976
01:39:14,850 --> 01:39:16,810
在Main.Lua中 它就在这里 
in main.lua, which is here.

1977
01:39:16,810 --> 01:39:19,680
因此将身份设置为Breakout或创建一个名为Breakout文件夹
So set identity to Breakout or create a folder called Breakout

1978
01:39:19,680 --> 01:39:22,170
我们可以在其中保存和读取文件 
that we can save and read files to and from.

1979
01:39:22,170 --> 01:39:24,450
如果它不存在 那么就创建它们 
If it doesn't exist, then just create them.

1980
01:39:24,450 --> 01:39:26,910
在这种情况下 我只是输入CTO作为我的首字母 
In this case, I'm just seeding CTO my initials.

1981
01:39:26,910 --> 01:39:28,870
然后我乘以1000 
And then I times 1,000.

1982
01:39:28,870 --> 01:39:30,990
所以从一万降到一千 
So 10,000 down to 1,000.

1983
01:39:30,990 --> 01:39:33,314
只是非常简单的数据 
Just very simple data.

1984
01:39:33,314 --> 01:39:34,980
正在写入名为Breakout.lst的文件 
Writing into a file called breakout.lst.

1985
01:39:34,980 --> 01:39:36,300
它可以是你想要的任何东西 
It can be whatever you want.

1986
01:39:36,300 --> 01:39:40,620
我们所做的只是从数据或文件中读取行 
All we're doing is reading lines from the data, or from the file.

1987
01:39:40,620 --> 01:39:42,540
然后这是如果它不存在的话 
And then this is if it doesn't exist.

1988
01:39:42,540 --> 01:39:50,100
如果它确实存在 那么我们将对其进行迭代
And then if it does exist, then we're going to iterate over it

1989
01:39:50,100 --> 01:39:53,730
使用love.filesystem.line 它将接受一个文件
with love.filesystem.line, which will take a file

1990
01:39:53,730 --> 01:39:56,460
然后基本上把它分成新的行 然后给你
and then just split it on new lines basically and give you

1991
01:39:56,460 --> 01:39:58,200
所有这些行的迭代器 
an iterator over all those lines.

1992
01:39:58,200 --> 01:40:00,540
所以它可以说 好的 如果它是一个名字 哪一个
So it can just say, OK, if it's a name, which

1993
01:40:00,540 --> 01:40:06,120
也就是说 如果名单上有一个、三个、五个或七个 
means that if it's one or three or five or seven in the list,

1994
01:40:06,120 --> 01:40:08,990
然后将名称设置为--
then set the name to--

1995
01:40:08,990 --> 01:40:11,460
我们使用的是字符串.sub.以防他们
and we're using string.sub just in case they

1996
01:40:11,460 --> 01:40:14,270
写一些长名字 或者写一些长名字--他们做不到
write some long name or some long name gets-- they can't do it

1997
01:40:14,270 --> 01:40:17,640
通过我们的游戏 但如果它以某个长名称写入文件 
through our game, but if it gets written to the file as some long name,

1998
01:40:17,640 --> 01:40:19,770
它应该被截断为三个字符
it should get truncated to three characters

1999
01:40:19,770 --> 01:40:22,360
这样我们就可以适当地展示它 
so we can display it appropriately.

2000
01:40:22,360 --> 01:40:24,850
否则 如果我们不是在名字线上 
And then otherwise if we're not on a name line,

2001
01:40:24,850 --> 01:40:28,140
如果我们在一条奇数或偶数行上 
if we're on, like, an odd line or even line,

2002
01:40:28,140 --> 01:40:32,140
我们应该认为这是一个分数 只使用数字 
we should consider that a score and just use to number.

2003
01:40:32,140 --> 01:40:37,154
因为我们使用字符串数据 如果我们尝试赋值 
Because we're using string data and if we try to assign,

2004
01:40:37,154 --> 01:40:39,570
对字符串数据进行任何类型的数字比较 
do any sort of comparisons numerically on the string data,

2005
01:40:39,570 --> 01:40:41,790
我们将不得不这样做 以比较高分 
which we will have to do to compare high scores,

2006
01:40:41,790 --> 01:40:44,160
它不会起作用 因为它会看到有弦 
it's not going to work because it's going to see that there's strings.

2007
01:40:44,160 --> 01:40:45,330
所以我们在这里用数字 
So we use to number here.

2008
01:40:45,330 --> 01:40:46,819
只是一个简单的Lua函数 
Just a simple Lua function.

2009
01:40:46,819 --> 01:40:47,610
然后就是这样 
And then that's it.

2010
01:40:47,610 --> 01:40:50,430
然后我们只需返回分数 
And then we just return scores.

2011
01:40:50,430 --> 01:40:53,490
然后我会找出问题的起因 
And then I'll sort out what's causing the issue,

2012
01:40:53,490 --> 01:40:56,880
然后尽快把它推到回购上 
and then push that to the repo ASAP.

2013
01:40:56,880 --> 01:41:00,690
但这样做的效果是 我们实际上能够加载我们所有的高分
But that has the effect of us being able to actually load all of our high scores

2014
01:41:00,690 --> 01:41:03,790
并在游戏开始时展示它们 
and display them at the start of the game.

2015
01:41:03,790 --> 01:41:08,680
它不需要考虑能够实际输入我们的分数 
It doesn't take care of being able to actually input our score.

2016
01:41:08,680 --> 01:41:12,870
因此 我们可以使用Breakout 11来实现这一点 如果运行回购 您可以看到这一点 
And so we can do this with Breakout11, which you can see if you run the repo.

2017
01:41:12,870 --> 01:41:17,580
您可以通过测试将初始分数分配给某个值 例如10,000
And you can test just to assign your initial score to some value like 10,000

2018
01:41:17,580 --> 01:41:19,890
或者20,000 然后故意输掉 而你
or 20,000, and then just lose on purpose and you

2019
01:41:19,890 --> 01:41:21,990
了解它的实际工作原理 
get a sense of how it actually works.

2020
01:41:21,990 --> 01:41:24,010
但从本质上说 这只是一种街机风格 
But essentially, it's just arcade style.

2021
01:41:24,010 --> 01:41:26,760
你知道吗 你只有三个字可以输入你的名字 
You know, you had only three characters you could input your name.

2022
01:41:26,760 --> 01:41:31,530
那么 有谁知道我们是如何存储这些东西的 
So does anybody have any idea as to how we are sort of storing this,

2023
01:41:31,530 --> 01:41:32,670
或者可以提出一个想法？
or can pitch an idea?

2024
01:41:36,720 --> 01:41:41,100
所以我们有三个角色 我们想--
So we have three characters and we want to--

2025
01:41:41,100 --> 01:41:45,330
理想情况下 如果我们是 假设我想在第一个数上转到C 
ideally if we're, let's say I want to go to C on the first one.

2026
01:41:45,330 --> 01:41:52,526
比方说 我按了两次 这样我就到了C 从A到C怎么样？
Let's say I pressed up twice so I get to C. How is it going from A to C?

2027
01:41:52,526 --> 01:41:54,610
你可以只说 你可以只渲染
You could just say, you could just render

2028
01:41:54,610 --> 01:41:58,900
我想要渲染角色A 角色A 角色A 
I want to render the character A, the character A, the character A,

2029
01:41:58,900 --> 01:42:01,700
但它怎么知道你什么时候想去B、C或D呢？
but how is it going to know when you want to go to B, or C, or D.

2030
01:42:01,700 --> 01:42:15,116
观众：[听不见]
AUDIENCE: [INAUDIBLE]

2031
01:42:15,116 --> 01:42:16,990
科尔顿·奥格登：投球是 你可以创造
COLTON OGDEN: The pitch was, you could create

2032
01:42:16,990 --> 01:42:19,406
一个包含所有字符的表 并对其进行迭代 
a table with all of the characters and iterate through it.

2033
01:42:19,406 --> 01:42:22,450
你绝对可以做到的 
You absolutely could do that.

2034
01:42:22,450 --> 01:42:23,740
它有一点笨重 
It's a little bit bulky.

2035
01:42:23,740 --> 01:42:24,880
这可能就是...
That might be what--

2036
01:42:24,880 --> 01:42:28,720
事实上 这可能不是街机系统当年的做法 
actually, that's probably not how arcade systems did it back in the day.

2037
01:42:28,720 --> 01:42:38,680
因为在《越狱11》中我们要做的是
Because the way that we're going to do it here in Breakout11 is I

2038
01:42:38,680 --> 01:42:43,780
添加了一个名为EnterHighScoreState的新状态 
added a new state called EnterHighScoreState.

2039
01:42:43,780 --> 01:42:46,390
如果你还记得的话 CS50教授了这一点 
And if you recall, CS50 teaches this.

2040
01:42:46,390 --> 01:42:51,260
但归根结底 所有类型的字符都只是数字 
But all sort of characters at the end of the day are just numbers.

2041
01:42:51,260 --> 01:42:53,740
ASCI 
ASCI.

2042
01:42:53,740 --> 01:42:58,030
在这个例子中 如果你还记得的话 65是大写的A 
In this case, 65, if you recall, is capital A.

2043
01:42:58,030 --> 01:43:03,640
所以我们要做的就是画出那个角色
So all we need to do is just draw out whatever that character

2044
01:43:03,640 --> 01:43:06,590
转换为字符串是或字符 
cast to a string is, or character.

2045
01:43:06,590 --> 01:43:11,740
我们在下面的DRAW函数中简单地完成这项工作 
And we do that simply down here in the draw function.

2046
01:43:11,740 --> 01:43:19,962
如果我们做string.char at char就是3 
If we do string.char, at char is three.

2047
01:43:19,962 --> 01:43:22,420
所做的一切只会产生这样的效果
All that has the effect of doing is just taking that number

2048
01:43:22,420 --> 01:43:25,660
然后将其转换为字符 
and then converting it to a character.

2049
01:43:25,660 --> 01:43:27,520
那么我们所需要做的就是什么？
So all we need to do then is what?

2050
01:43:27,520 --> 01:43:33,006
当我们想要从A到B B到C C到D 
When we want to go from A to B, B to C, C to D.

2051
01:43:33,006 --> 01:43:35,654
观众：[听不见]
AUDIENCE: [INAUDIBLE]

2052
01:43:35,654 --> 01:43:36,570
科尔顿·奥格登：没错 
COLTON OGDEN: Exactly.

2053
01:43:36,570 --> 01:43:39,165
但如果我们在A 我们想往下走 会发生什么？
But then what happens if we're at A and we want to go down?

2054
01:43:39,165 --> 01:43:41,102
观众：[听不见]
AUDIENCE: [INAUDIBLE]

2055
01:43:41,102 --> 01:43:42,060
科尔顿·奥格登：我们会的 
COLTON OGDEN: We would.

2056
01:43:42,060 --> 01:43:49,650
所以 如果我们在A 那么如果我们向下按 我们想要到Z 
So if we're at A, then if we press downward and we want to go to Z,

2057
01:43:49,650 --> 01:43:50,670
其中的逻辑就在这里 
the logic is in here.

2058
01:43:53,580 --> 01:43:59,280
但是我们增加了代码 如果它大于90 也就是Z 
But one we've incremented our code, if it's greater than 90, which is Z,

2059
01:43:59,280 --> 01:44:00,670
那我们应该把它调回65 
then we should set it back to 65.

2060
01:44:00,670 --> 01:44:01,560
我们将循环回A 
We'll loop back to A.

2061
01:44:01,560 --> 01:44:02,820
这里也是一样的 
And same thing here.

2062
01:44:02,820 --> 01:44:06,630
如果我们按下 我们在A 我们必须回到Z 
If we press down and we're at A, we've got to go back up to Z,

2063
01:44:06,630 --> 01:44:08,130
所以我们把它设为90 
so we just set it to 90.

2064
01:44:08,130 --> 01:44:09,690
如此简单的环回逻辑 
So simple loop back logic.

2065
01:44:09,690 --> 01:44:11,940
我们只是把它画出来 我们突出显示 
And we just draw it, we highlight.

2066
01:44:11,940 --> 01:44:14,940
一旦我们这样做了 用户就按Enter键 
And then once we've done that, the user presses Enter.

2067
01:44:14,940 --> 01:44:19,380
实际上 我们过渡到High ScoreState
We transition to the HighScoreState, actually,

2068
01:44:19,380 --> 01:44:22,410
因为只有当他们进入新的最高分时 这种状态才会触发 
because this state should only trigger if they entered a new high score.

2069
01:44:22,410 --> 01:44:26,740
这意味着我们需要登记到VictoryState 或者不是VictoryState 
Which means that we need to check in the VictoryState, or not the VictoryState,

2070
01:44:26,740 --> 01:44:29,070
而是在GameOverState中 无论是否
but rather in the GameOverState whether or not

2071
01:44:29,070 --> 01:44:33,540
他们的分数比任何一家商店都要高 
their score is higher than any of the stores in some sort of,

2072
01:44:33,540 --> 01:44:36,000
引用不引用 全球分数表 
quote unquote, global scores table.

2073
01:44:36,000 --> 01:44:39,558
然后我们认为我们现在是如何来回传递分数的呢？
And then how do we think we're passing the scores back and forth now?

2074
01:44:42,510 --> 01:44:45,388
有人记得我们是如何跟踪应用程序状态的吗？
Does anybody recall how we're keeping track of app state?

2075
01:44:48,280 --> 01:44:55,190
观众：[听不见]
AUDIENCE: [INAUDIBLE]

2076
01:44:55,190 --> 01:44:55,940
科尔顿·奥格登：是的 
COLTON OGDEN: Yep.

2077
01:44:55,940 --> 01:44:57,270
在更改功能中 
In the change function.

2078
01:44:57,270 --> 01:44:59,540
所以我们要做的就是跟踪--加载
So all we need to do is keep track of-- load

2079
01:44:59,540 --> 01:45:01,490
我们在比赛开始时的高分 
our high scores at the beginning of the game,

2080
01:45:01,490 --> 01:45:03,360
把它们一直传到最后 
pass them all the way down the line.

2081
01:45:03,360 --> 01:45:07,560
最后--我们还可以将它们加载到EnterHighScoreState中 
And then finally-- and we can also load them in our EnterHighScoreState,

2082
01:45:07,560 --> 01:45:11,390
但我们需要跟踪我们在GameOverState中的高分是多少
but we need to keep track of what our high scores are in the GameOverState

2083
01:45:11,390 --> 01:45:13,562
这样我们就知道 哦 我得了高分 
so that we know, oh, I've got a high score.

2084
01:45:13,562 --> 01:45:16,520
与其转换回StartState 不如让我们转换
Let's instead of transitioning back to the StartState, let's transition

2085
01:45:16,520 --> 01:45:22,130
添加到EnterHighScoreState 以便用户可以将他们的高分添加到列表中 
to the EnterHighScoreState so the user can add their high score to the list.

2086
01:45:22,130 --> 01:45:30,770
然后一旦他们进入了他们的高分 也就是这里 
And then once they've entered their high score, which is here,

2087
01:45:30,770 --> 01:45:35,940
我们只需将其再次写入此文件 
we'll just write it to this file again.

2088
01:45:35,940 --> 01:45:39,760
编译一个分数字符串 它接受我们的分数的名称和分数 
Compile a score string, which takes name and score of our scores.

2089
01:45:39,760 --> 01:45:43,000
我们拿我们当时的分数 那是--
We take whatever score that we were at that's--

2090
01:45:43,000 --> 01:45:45,220
我们倒着看我们的分数表
we look through our scores table backwards

2091
01:45:45,220 --> 01:45:47,982
当我们找到比我们的分数低的分数时 
and when we find a score that's lower than ours,

2092
01:45:47,982 --> 01:45:51,190
我们只是跟踪这个指数 直到我们得到一个比我们的指数更高的指数 
we just keep track of that index until we get to one that's higher than ours.

2093
01:45:51,190 --> 01:45:54,160
在这种情况下 一加一 该指数加一
In which case the one plus one, that index plus one

2094
01:45:54,160 --> 01:45:55,600
是我们应该改写的内容 
is what we should then overwrite.

2095
01:45:55,600 --> 01:45:59,050
因此 我们相应地将下面的所有其他部分移位 
And so we shift all the other ones below accordingly.

2096
01:45:59,050 --> 01:46:01,907
如果好奇的话 我们在这节课上也会这么做 
And we do that in this class if curious.

2097
01:46:01,907 --> 01:46:04,240
所以我要轻松地看完最后一对选手 
And so I'm just going to breeze through the last couple.

2098
01:46:04,240 --> 01:46:07,000
Ppale SELECT更新只是一种模糊状态
The paddle select update is just kind of a fluffy state

2099
01:46:07,000 --> 01:46:13,330
这让我们可以在我们的游戏中添加一些元素 比如用户选择 
that lets us add a element of sort of, like, user selection to our game.

2100
01:46:13,330 --> 01:46:18,850
在我们的PaddleSelectState中 我们立即进行转换 
In our PaddleSelectState here, we transition immediately.

2101
01:46:18,850 --> 01:46:21,370
而不是现在去[INAUDIBLE]PlayState 
Instead of going to the [INAUDIBLE] PlayState now,

2102
01:46:21,370 --> 01:46:26,140
当我们点击开始游戏时 我们将从开始到划桨选择 
we're going to go from Start to Paddle Select when we hit Start Game.

2103
01:46:26,140 --> 01:46:27,310
所以我们要去...
So we're going to go to--

2104
01:46:27,310 --> 01:46:29,200
然后是Paddle Select类本身 
and then the Paddle Select class itself.

2105
01:46:32,170 --> 01:46:35,080
CurrentPaddle得到一个 然后它基本上
CurrentPaddle gets one, and then all it essentially

2106
01:46:35,080 --> 01:46:42,210
我们在这里画两个箭头
is is us drawing two arrows here.

2107
01:46:42,210 --> 01:46:47,260
所以如果我们是第一名--在这个例子中 我想我们是第三名--
And so if we're at number one-- in this case, I think we're at number three--

2108
01:46:47,260 --> 01:46:49,990
那么这两个箭头都将是完全不透明的 
then both of these arrows will be completely opaque.

2109
01:46:49,990 --> 01:46:53,320
但如果我们在左边或右边 他们应该变暗对我们说 
But if we're on the left or the right edge, they should darken to say to us,

2110
01:46:53,320 --> 01:46:55,528
我们不能再左右移动了因为我们
oh, we can't move left or right anymore because we're

2111
01:46:55,528 --> 01:47:00,100
在索引1或4或5处 只有那么多颜色 
at either index one or four or five, and there's only that many colors.

2112
01:47:00,100 --> 01:47:02,170
然后渲染这个颜色变量
And then render whatever that color variable

2113
01:47:02,170 --> 01:47:07,976
就是用我们之前用过的四元表 
is using the quads table that we had before of the different tables.

2114
01:47:07,976 --> 01:47:09,100
然后只是指令 
And then just instructions.

2115
01:47:09,100 --> 01:47:13,360
然后从那里我们将最终过渡到ServeState
And then from there is where we'll end up transitioning to the ServeState

2116
01:47:13,360 --> 01:47:18,100
而不是从StartState转到ServeState 
rather than going to the ServeState from the StartState.

2117
01:47:18,100 --> 01:47:20,590
所有的代码都在这里 
And all the code in that is here.

2118
01:47:20,590 --> 01:47:22,540
我们在放音效 
We have sound effects playing.

2119
01:47:22,540 --> 01:47:26,654
然后确保我们也播放不同的声音
And then making sure that we also play a different sound

2120
01:47:26,654 --> 01:47:29,320
效果取决于它们是在左边还是右边 
effect based upon whether they're at the left or the right edge.

2121
01:47:29,320 --> 01:47:30,880
如果他们在左边想往左走 
If they're on the left edge and they try to go left,

2122
01:47:30,880 --> 01:47:33,940
它应该像一个声音 听起来有点粗糙 
it should play like a sound that sort of sounds a little rougher

2123
01:47:33,940 --> 01:47:35,680
让他们知道不能向左走
to let them know that they can't go left,

2124
01:47:35,680 --> 01:47:38,350
而右边缘则相反 
and the opposite for the right edge.

2125
01:47:38,350 --> 01:47:42,770
一旦他们按下回车键
And then once that's all done, once they press Enter on whatever paddle

2126
01:47:42,770 --> 01:47:46,940
他们想要 他们会得到球拍 
they want, they're going to get the paddle,

2127
01:47:46,940 --> 01:47:50,770
我们将实例化一个paddle 将其传递到ServeState 
we're going to instantiate a paddle, pass that into the ServeState,

2128
01:47:50,770 --> 01:47:53,710
and we're going to take current当前Paddle桨from the state状态 which哪一个
and we're going to take currentPaddle from the state, which

2129
01:47:53,710 --> 01:47:59,920
就是他们在不同的拨片之间滚动得到的值 
is whatever value they got by scrolling between all the different paddles.

2130
01:47:59,920 --> 01:48:06,280
然后是最后一个更新 这是几乎每堂课我最喜欢的部分
And then the last update, which is my favorite part of most every lecture

2131
01:48:06,280 --> 01:48:09,850
我想是音乐的更新 
I think is the music update.

2132
01:48:09,850 --> 01:48:15,130
而所有这一切实际上只是音乐集发挥在主要.lua 
And all that really is is just music set play in main.lua,

2133
01:48:15,130 --> 01:48:19,410
然后将循环设置为真 这样就有了一个博弈
and then set looping to true, and then we have a game.

2134
01:48:19,410 --> 01:48:20,660
这是我们的Paddle Select 
And this is our Paddle Select.

2135
01:48:20,660 --> 01:48:25,960
请注意 左右两边的箭头是半透明的 
So notice the arrows are semi-opaque on the left and the right.

2136
01:48:25,960 --> 01:48:30,310
听起来有点难 但当我现在按下
It's kind of hard to hear, but when I press right now

2137
01:48:30,310 --> 01:48:33,890
有点像是有一点粗糙的声音 
it's kind of like there's a bit of a rougher sound.

2138
01:48:33,890 --> 01:48:35,080
我们选择红色 
We choose red.

2139
01:48:35,080 --> 01:48:37,900
我们转到第一级 然后转换到ServeState
We go to level one and we transition to the ServeState

2140
01:48:37,900 --> 01:48:43,240
PaddleSelectState 然后我们就像往常一样玩游戏 
from the PaddleSelectState, and then we just play the game as normal.

2141
01:48:43,240 --> 01:48:45,060
这基本上就是它的全部 
And that's basically all there is to it.

2142
01:48:45,060 --> 01:48:48,018
有几个功能我们没有时间去真正了解
And there is a couple of features we didn't have time to really go over

2143
01:48:48,018 --> 01:48:51,374
比如确保我们在一定数量的点数
like making sure we recover HP if a certain amount of points

2144
01:48:51,374 --> 01:48:53,290
已经过去了 但我鼓励你去看看
have been elapsed, but I encourage you to look

2145
01:48:53,290 --> 01:48:56,290
当你触发一次命中的时候 
into that when you trigger a hit.

2146
01:48:56,290 --> 01:48:58,930
在PlayState中有一些逻辑可以说 哦 
There's some logic in the PlayState to say, oh,

2147
01:48:58,930 --> 01:49:01,467
如果他们已经超过了当前的复苏门槛 
if they've gone over a current recovery threshold,

2148
01:49:01,467 --> 01:49:04,300
让我们为球员增加一颗心 你知道的 让他们继续比赛 
let's add one heart to the player, you know, just keep them playing.

2149
01:49:04,300 --> 01:49:06,008
只是为了奖励他们的高分 
Just to reward them for their high score.

2150
01:49:08,470 --> 01:49:10,410
下一次我们将介绍一些概念 
Next time we'll cover a few concepts.

2151
01:49:10,410 --> 01:49:11,300
所以基本的着色器 
So basic shaders.

2152
01:49:11,300 --> 01:49:13,550
着色器就像可以在显卡上运行的小程序
Shaders are like little programs you can run in your graphics card

2153
01:49:13,550 --> 01:49:16,210
并制作奇特的效果 但我们不会深入到太多细节 
and do fancy effects, but we won't go into too much detail.

2154
01:49:16,210 --> 01:49:17,140
匿名函数 
Anonymous functions.

2155
01:49:17,140 --> 01:49:21,119
我们在Lua中看到了很多关于Love的匿名函数 
We've seen a lot of anonymous functions in Lua in the context of Love.

2156
01:49:21,119 --> 01:49:23,410
它们只是没有名称的函数 您可以
They're just functions without a name, and you can just

2157
01:49:23,410 --> 01:49:26,410
将它们用作函数参数 并用它们做各种很酷的事情 
use them as function arguments and do all sorts of cool stuff with them.

2158
01:49:26,410 --> 01:49:29,140
下周我们做事的时候 我们会用它们做回调
We'll use them for callbacks next week when we do things

2159
01:49:29,140 --> 01:49:31,480
比如Twening 它正在获得一些价值
like tweening, which is taking some value

2160
01:49:31,480 --> 01:49:35,190
并让它随着时间的推移插入到其他东西中 
and making it interpolate over time to some other thing.

2161
01:49:35,190 --> 01:49:38,440
因为现在我们基本上只是根据速度进行更新 
Because right now we've basically just been updating things based on velocity,

2162
01:49:38,440 --> 01:49:40,609
但我们并没有真正按照时间来做任何事情 
but we haven't really done anything based on time.

2163
01:49:40,609 --> 01:49:42,400
所以我们将更详细地了解这一点
So we'll take a look at that in more detail

2164
01:49:42,400 --> 01:49:46,600
下周将有一个名为Timer的图书馆 这真的很棒 
next week with a library called timer, which is really fantastic.

2165
01:49:46,600 --> 01:49:50,050
允许您对事物进行计时 然后将事物链接在一起 
Lets you time things and then chain things together.

2166
01:49:50,050 --> 01:49:52,670
如果熟悉的话 我们会报道第三场比赛 
We'll be covering the game Match Three if familiar.

2167
01:49:52,670 --> 01:49:54,130
这基本上就是糖果粉碎传奇 
It's basically Candy Crush.

2168
01:49:54,130 --> 01:49:57,130
我们将使用不同的瓷砖设置 但这是相同的想法 
We'll be using a different tile set, but it's the same idea.

2169
01:49:57,130 --> 01:49:59,500
我们将不得不计算如何真正找出
And we'll have to calculate how to actually find out

2170
01:49:59,500 --> 01:50:02,500
无论我们是否在网格中找到了匹配 我们的瓷砖网格 
whether we've gotten a match in the grid, our tile grid,

2171
01:50:02,500 --> 01:50:06,820
然后相应地移动这些块 然后做所有其他逻辑 加分数 
and then shift the blocks accordingly and do all the other logic, add score.

2172
01:50:06,820 --> 01:50:10,810
然后基本上 因为它是糖果粉碎传奇和游戏的基础
And then basically since it's so fundamental to Candy Crush and games

2173
01:50:10,810 --> 01:50:13,720
对于它的本质 我们将不得不讨论如何在某种程度上生成
of its nature, we will have to cover how to sort of generate

2174
01:50:13,720 --> 01:50:17,076
这些地图在程序上具有动态布局的瓦片 
these maps procedurally to have tiles that are laid out in a dynamic way,

2175
01:50:17,076 --> 01:50:19,450
在某种程度上 也不是从任何火柴开始
and also in a way that doesn't start off with any matches

2176
01:50:19,450 --> 01:50:22,199
因为那就没有任何意义了 因为比赛已经
because then that wouldn't make any sense because the matches have

2177
01:50:22,199 --> 01:50:23,230
来解决问题 
to resolve.

2178
01:50:23,230 --> 01:50:26,740
如果下周有时间的话我们会抽出一点时间
And then we'll take a little time if we have the time next week

2179
01:50:26,740 --> 01:50:28,810
再次谈论精灵艺术和调色板 
to talk about sprite art again and palettes.

2180
01:50:28,810 --> 01:50:32,490
也许我会向你们展示如何将图像从一个
And maybe I'll show you guys how to sort of convert images from one

2181
01:50:32,490 --> 01:50:35,200
调色板到另一个 比如 我使用的一个程序 Aseprite 
palette to another in, like, a program that I use, Aseprite,

2182
01:50:35,200 --> 01:50:40,200
但你可以在任何类型的大型照片编辑软件中做到这一点 
but you can do this in any sort of large photo editing software.

2183
01:50:40,200 --> 01:50:44,990
第二项任务是《越狱》的几个扩展 
And then assignment two is a couple of extensions to Breakout.

2184
01:50:44,990 --> 01:50:50,100
所以如果你注意到床单上有几个小精灵
So if you noticed in the sheet there were a few little sprites here

2185
01:50:50,100 --> 01:50:51,240
在底部--
at the bottom--

2186
01:50:51,240 --> 01:50:53,580
所以 去掉四边形轮廓吧 
so get rid of the quad outlines.

2187
01:50:53,580 --> 01:50:56,580
所以下面这些小东西 我猜 
So these little things down here are, I'm assuming,

2188
01:50:56,580 --> 01:50:57,909
它们应该是能量充沛的 
they're meant to be power ups.

2189
01:50:57,909 --> 01:50:58,950
它们看起来像是通电了 
They look like power ups.

2190
01:50:58,950 --> 01:51:01,790
但pset的目标是实现通电 
But the goal of the pset is to implement a power up.

2191
01:51:01,790 --> 01:51:05,939
一旦启动 当你抓住它的时候 
And a power up is going to be such that when you grab it,

2192
01:51:05,939 --> 01:51:08,730
你会得到两个额外的球 或者实际上你想要多少球 
you'll get two additional balls, or however many you want actually,

2193
01:51:08,730 --> 01:51:12,270
它将在你的那个之外产生 并自己检测碰撞 
that will spawn in addition to your one and detect collisions on their own.

2194
01:51:12,270 --> 01:51:14,760
所以你会有几个 他们会为你得分 
So you'll have several and they'll score points for you.

2195
01:51:14,760 --> 01:51:18,450
当然 只有当最后一个球落在屏幕表面以下时
And, of course, only when the last ball comes below the surface of the screen

2196
01:51:18,450 --> 01:51:20,700
你是否应该触发一场游戏结束 
should you trigger a Game Over.

2197
01:51:20,700 --> 01:51:22,930
然后我想让你们加上--这也会
And then I want you to add-- and this will also

2198
01:51:22,930 --> 01:51:24,763
比说明书更详细--但我会
be more detailed than the spec-- but I would

2199
01:51:24,763 --> 01:51:26,970
喜欢你把成长和萎缩加到桨上 
like you to add growing and shrinking to the paddle.

2200
01:51:26,970 --> 01:51:29,925
所以目前 我们有四种不同大小的球拍 
So currently, we have like four different sizes of paddle,

2201
01:51:29,925 --> 01:51:31,230
但我们没有使用它们 
but we're not using them.

2202
01:51:31,230 --> 01:51:34,380
所以如果我们得到了足够的分数或我们失去了分数 那就好了
So it would be nice if when we gain enough points or we lose points, or not

2203
01:51:34,380 --> 01:51:37,890
分数 而不是生活 我们增加或减少桨的大小
points, but lives rather, we increase or decrease the size of the paddle

2204
01:51:37,890 --> 01:51:40,260
因此 我们要引入另一个层面的挑战
accordingly just to introduce another level of challenge

2205
01:51:40,260 --> 01:51:42,630
或者缺乏挑战 
and or lack of challenge.

2206
01:51:42,630 --> 01:51:46,620
最后 最后一部分也在精灵表中 
And then finally, one last part which is in the sprite sheet as well,

2207
01:51:46,620 --> 01:51:54,040
这里有一个钥匙块 这里有一个钥匙电源
there's a key block here and a key power up here.

2208
01:51:54,040 --> 01:52:00,504
所以让力量来 用你的桨把力量捡起来 
So sort of let the power up come, pick the power up with your paddle.

2209
01:52:00,504 --> 01:52:02,670
只有当你有了这种力量 
And then only when you have that power up should you

2210
01:52:02,670 --> 01:52:06,069
能用钥匙打破障碍 
be able to break the block with a key.

2211
01:52:06,069 --> 01:52:07,860
你应该考虑到这点
And you should take this into consideration

2212
01:52:07,860 --> 01:52:09,360
你也可以在生成水平时使用 
when generating your levels as well.

2213
01:52:09,360 --> 01:52:12,420
所以你也必须用水平仪弄脏你的手 
So you'll have to also get your hands dirty with the level maker.

2214
01:52:12,420 --> 01:52:14,670
但总的来说 这就是突破 
But all in all, that was Breakout.

2215
01:52:14,670 --> 01:52:16,170
我们下次见 
So I'll see you guys next time.

2216
01:52:16,170 --> 01:52:18,020
谢谢
Thank you.
