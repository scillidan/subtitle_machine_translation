1
00:00:00,000 --> 00:00:03,479
[音乐播放]

2
00:00:16,999 --> 00:00:18,290
科尔顿·奥格登：大家好 

3
00:00:18,290 --> 00:00:20,530
欢迎来到GD50第二讲 

4
00:00:20,530 --> 00:00:22,300
这里是越狱频道 

5
00:00:22,300 --> 00:00:25,225
有趣的是 CS50与Breakout有渊源 

6
00:00:25,225 --> 00:00:26,680
所以我今天调出了这个 

7
00:00:26,680 --> 00:00:30,700
这是2015、2014年的Pset3 

8
00:00:30,700 --> 00:00:34,960
它是使用斯坦福便携的Breakout的实现

9
00:00:34,960 --> 00:00:37,150
库 这是一种Java库

10
00:00:37,150 --> 00:00:40,450
我们能够为其获得C绑定 

11
00:00:40,450 --> 00:00:42,430
因此 学生们能够实际实施

12
00:00:42,430 --> 00:00:48,040
这是一款当时还是CS50设备的游戏 是一个Linux发行版 

13
00:00:48,040 --> 00:00:49,870
但我只想说 那是--

14
00:00:49,870 --> 00:00:51,280
哦 这也是个有趣的故事 

15
00:00:51,280 --> 00:00:56,570
我碰巧也为这个实现编写了激光程序 

16
00:00:56,570 --> 00:00:59,260
我认为这是最早的代码之一

17
00:00:59,260 --> 00:01:02,380
我在使用CS50的时候弄脏了自己的手 

18
00:01:02,380 --> 00:01:04,919
所以今天在突破的背景下 我们将

19
00:01:04,919 --> 00:01:07,960
谈论一些我们还没有谈论过的不同的事情 

20
00:01:07,960 --> 00:01:10,600
其中最有可能的是雪碧薄片 

21
00:01:10,600 --> 00:01:12,130
至少最明显的是这样 

22
00:01:12,130 --> 00:01:15,370
因此 精灵纸只是一种拍摄图像的方式 一张大图像 

23
00:01:15,370 --> 00:01:19,210
而不是拆分 而不是加载单独的图像

24
00:01:19,210 --> 00:01:21,260
对于你在游戏中的所有不同的东西 

25
00:01:21,260 --> 00:01:25,990
不管是你的外星人还是你的球拍什么的 你可以把所有东西

26
00:01:25,990 --> 00:01:30,080
放入一张表中 然后使用矩形对该表进行索引 

27
00:01:30,080 --> 00:01:30,580
四人组 

28
00:01:30,580 --> 00:01:31,535
我们很快就会谈到 

29
00:01:31,535 --> 00:01:33,910
这将允许您只绘制该图像的子集 

30
00:01:33,910 --> 00:01:37,930
并因此将您的所有图稿压缩到一个文件中 

31
00:01:37,930 --> 00:01:41,020
我们将更多地讨论程序生成

32
00:01:41,020 --> 00:01:42,580
在越狱的背景下 

33
00:01:42,580 --> 00:01:45,680
在这种情况下 我们将在游戏世界中铺设所有的砖

34
00:01:45,680 --> 00:01:46,240
从程序上讲 

35
00:01:46,240 --> 00:01:50,480
因此 在这种情况下 不是使用相同的颜色集 

36
00:01:50,480 --> 00:01:55,510
标准的布局是一排一排地放一堆相同颜色的砖 

37
00:01:55,510 --> 00:01:58,702
我们实际上将实现一种动态生成方法

38
00:01:58,702 --> 00:02:00,910
并有一堆不同的酷布局 我们将看到 

39
00:02:00,910 --> 00:02:04,810
实际上很容易就能得到可信的结果 

40
00:02:04,810 --> 00:02:07,100
我们会在这场比赛中更好地管理状态 

41
00:02:07,100 --> 00:02:10,479
在我们有一些全局变量之前

42
00:02:10,479 --> 00:02:14,320
我们并没有每个州或全球州的概念

43
00:02:14,320 --> 00:02:18,310
在我们所有的州之间 

44
00:02:18,310 --> 00:02:19,510
我们的国家机器 

45
00:02:19,510 --> 00:02:22,552
但为了避免有一种污染的全球名称空间 

46
00:02:22,552 --> 00:02:24,760
为了让事情变得更干净

47
00:02:24,760 --> 00:02:28,051
我们最终会把所有重要的变量都作为我们的代码 你知道 

48
00:02:28,051 --> 00:02:29,770
玩家和任何其他实体 

49
00:02:29,770 --> 00:02:30,940
砖块球

50
00:02:30,940 --> 00:02:33,064
而不是让他们在我们的主要[听不见] 

51
00:02:33,064 --> 00:02:34,410
我们最终会转移他们

52
00:02:34,410 --> 00:02:37,990
我们会把他们从不同的州转移到不同的州

53
00:02:37,990 --> 00:02:41,366
通过状态机的enter方法 

54
00:02:41,366 --> 00:02:42,490
实际上我们会有水平 

55
00:02:42,490 --> 00:02:43,780
这是一个渐进系统 

56
00:02:43,780 --> 00:02:45,650
从第一层开始 往上走 

57
00:02:45,650 --> 00:02:48,730
然后在每一个级别上 我们将实现一个规模

58
00:02:48,730 --> 00:02:51,730
在砖块的生成方面 

59
00:02:51,730 --> 00:02:54,545
因此 我们将得到更高层次的砖和更多的点作为一个结果 

60
00:02:54,545 --> 00:02:55,670
我们会有一个健康系统 

61
00:02:55,670 --> 00:02:58,780
《心》与《塞尔达传说》相似 

62
00:02:58,780 --> 00:03:02,380
粒子系统 这是一个非常重要的美学组成部分

63
00:03:02,380 --> 00:03:04,720
2D游戏和3D游戏 

64
00:03:04,720 --> 00:03:07,720
粒子系统基本上是一堆产生的图像

65
00:03:07,720 --> 00:03:10,720
你可以把它们聚在一起 放进一个小产卵器里 

66
00:03:10,720 --> 00:03:15,190
以某种方式发射它们 给它们上色 对它们进行数学运算 

67
00:03:15,190 --> 00:03:17,462
并得到一些可信的效果 比如火和烟

68
00:03:17,462 --> 00:03:19,420
以及所有其他的事情 

69
00:03:19,420 --> 00:03:24,040
使用简单的动画并不容易 

70
00:03:24,040 --> 00:03:26,980
但对粒子系统来说微不足道

71
00:03:26,980 --> 00:03:31,060
我们会用球拍做一个更复杂的碰撞检测

72
00:03:31,060 --> 00:03:33,132
比我们和乒乓的关系要好得多

73
00:03:33,132 --> 00:03:34,840
最后我们还会讨论

74
00:03:34,840 --> 00:03:38,950
我们可以将数据本地保存到我们的计算机上 这样当我们关闭应用程序时 

75
00:03:38,950 --> 00:03:42,460
再运行一次 我们最终得到了一个持续的高分

76
00:03:42,460 --> 00:03:44,980
而不仅仅是一些不稳定的东西 

77
00:03:44,980 --> 00:03:49,300
所以首先 我想演示一下今天完成的游戏 

78
00:03:49,300 --> 00:03:55,260
因此 如果有人想从观众那里演示一下 那就太好了 

79
00:03:55,260 --> 00:03:57,311
来吧 上来吧 

80
00:03:57,311 --> 00:03:58,810
我先走一步 为你做好准备 

81
00:04:02,652 --> 00:04:03,360
你叫什么名字？

82
00:04:03,360 --> 00:04:03,980
杰里米：杰里米 

83
00:04:03,980 --> 00:04:04,330
科尔顿·奥格登：杰里米 

84
00:04:04,330 --> 00:04:04,660
科尔顿 

85
00:04:04,660 --> 00:04:05,290
杰里米：很高兴认识你 科尔顿 

86
00:04:05,290 --> 00:04:06,280
科尔顿·奥格登：很高兴见到你 

87
00:04:06,280 --> 00:04:08,410
因此 我们将继续在这里运行Breakout 

88
00:04:13,220 --> 00:04:15,462
所以它使用了箭头键 

89
00:04:15,462 --> 00:04:17,170
所以如果你继续往上按 然后往下按 

90
00:04:17,170 --> 00:04:19,430
你会看到你可以在开始屏幕和高分屏幕之间移动 

91
00:04:19,430 --> 00:04:21,040
所以它们是两个独立的屏幕 

92
00:04:21,040 --> 00:04:22,392
所以去吧 然后--

93
00:04:22,392 --> 00:04:24,600
在我们这里 当你开始的时候 你可以选择一个球拍 

94
00:04:24,600 --> 00:04:27,740
因此 你可以选择 而不是每次都是同样的老牌球拍 

95
00:04:27,740 --> 00:04:29,650
正如你在这里看到的 他选择了绿色 

96
00:04:29,650 --> 00:04:31,000
所以他拿到了绿色球拍 

97
00:04:31,000 --> 00:04:32,650
这些砖都是程序生成的 

98
00:04:32,650 --> 00:04:36,520
因此 如果他运行应用程序 它们将完全不同 

99
00:04:36,520 --> 00:04:39,610
就像经典的公式一样 球移动

100
00:04:39,610 --> 00:04:41,230
在砖头和球拍之间 

101
00:04:41,230 --> 00:04:44,060
当它击中砖块时 如果它是某种颜色的 

102
00:04:44,060 --> 00:04:46,840
它要么被摧毁--在这种情况下 如果它是蓝色的 

103
00:04:46,840 --> 00:04:48,280
这是基色砖 

104
00:04:48,280 --> 00:04:50,590
所以这是最低的值 

105
00:04:50,590 --> 00:04:52,480
如果它比蓝色高 它最终会变成

106
00:04:52,480 --> 00:04:55,840
根据颜色的不同向下调整颜色 

107
00:04:55,840 --> 00:04:58,210
我相信它会变成蓝色、绿色、红色、紫色、黄色 

108
00:04:58,210 --> 00:05:01,600
因此 任何更高的东西都会被下移 

109
00:05:01,600 --> 00:05:04,240
然后玩家积累分数 如你在右上角所看到的 

110
00:05:04,240 --> 00:05:04,930
得分 

111
00:05:04,930 --> 00:05:06,370
还要注意这三颗心 

112
00:05:06,370 --> 00:05:07,820
这将是球员的健康 

113
00:05:07,820 --> 00:05:13,830
所以如果他可能故意输掉比赛 

114
00:05:13,830 --> 00:05:18,870
我们可以看到他收到了另一条消息 说按Enter键服务 

115
00:05:18,870 --> 00:05:20,730
他的心跳下降了一分 

116
00:05:20,730 --> 00:05:23,370
所以现在他有三分之二的健康状况 

117
00:05:23,370 --> 00:05:28,020
所以最终 如果他碰巧完全输了--

118
00:05:32,900 --> 00:05:35,290
噢 

119
00:05:35,290 --> 00:05:37,290
老实说 这是越狱最有趣的部分

120
00:05:37,290 --> 00:05:39,630
只是让它卡在一堆东西里 

121
00:05:39,630 --> 00:05:41,620
但你可以看到我们在屏幕上观看了一场比赛 

122
00:05:41,620 --> 00:05:42,850
它会显示你的最终分数 

123
00:05:42,850 --> 00:05:46,130
然后你可以按Enter 它就会--

124
00:05:46,130 --> 00:05:46,840
噢 

125
00:05:46,840 --> 00:05:48,040
我一定是染上了虫子 

126
00:05:48,040 --> 00:05:51,500
但这应该会把你带回--

127
00:05:51,500 --> 00:05:53,440
如果你的分数很高 

128
00:05:53,440 --> 00:05:55,360
你要打出一个高分才行 

129
00:05:55,360 --> 00:06:00,270
如果你的分数不高 它会把你带回开始菜单 

130
00:06:00,270 --> 00:06:02,020
所以我在最后一刻做了几处改动 

131
00:06:02,020 --> 00:06:04,390
不幸的是 我一定是把什么东西落在里面了 

132
00:06:04,390 --> 00:06:07,606
但简而言之 这就是突破 

133
00:06:07,606 --> 00:06:10,730
我们今天的目标是基本实现我们看到的所有功能 

134
00:06:10,730 --> 00:06:12,550
哦 我们没有看高分屏幕 

135
00:06:12,550 --> 00:06:14,633
所以让我们也快速地来看看这一点 

136
00:06:14,633 --> 00:06:17,820
所以在这里的冠军 你可以看到我们有起跑和高分 

137
00:06:17,820 --> 00:06:18,970
哦 伙计 

138
00:06:18,970 --> 00:06:19,510
好的 

139
00:06:19,510 --> 00:06:20,884
我一定是搞砸了什么 

140
00:06:20,884 --> 00:06:24,050
所以我要去参加[INAUDIBLE]突破12 

141
00:06:24,050 --> 00:06:24,550
好的 

142
00:06:24,550 --> 00:06:25,049
抱歉的 

143
00:06:25,049 --> 00:06:25,660
我向你道歉 

144
00:06:25,660 --> 00:06:26,900
我会解决这个问题的 

145
00:06:26,900 --> 00:06:31,420
但它应该在这里显示这个菜单 在这里您将有一个包含您所有姓名的列表

146
00:06:31,420 --> 00:06:35,830
从文件中加载 并相应地输出您的分数 

147
00:06:35,830 --> 00:06:41,920
如果你得到了新的最高分 

148
00:06:41,920 --> 00:06:44,230
在那之后你可以输入你的名字 

149
00:06:44,230 --> 00:06:46,360
然后 它将最终将其保存到另一个文件 

150
00:06:46,360 --> 00:06:48,401
当我们达到这一点时 我会试着修复它

151
00:06:48,401 --> 00:06:51,140
这样我们才能真正看到它的样子 

152
00:06:51,140 --> 00:06:53,240
所以让我们回到这些幻灯片上来 

153
00:06:53,240 --> 00:06:55,790
这就是我们游戏的整体状态和流程 

154
00:06:55,790 --> 00:06:59,080
所以你可以看到 我用高亮的颜色把它标出来 

155
00:06:59,080 --> 00:07:00,550
我们从StartState开始 

156
00:07:00,550 --> 00:07:01,990
这些都是我们以前讲过的内容 

157
00:07:01,990 --> 00:07:03,100
只有状态机 

158
00:07:03,100 --> 00:07:05,266
它比Flappy Bird要复杂一点 

159
00:07:05,266 --> 00:07:07,930
我们有八个州 而不是我认为的

160
00:07:07,930 --> 00:07:10,420
上一节课有四五个人 

161
00:07:10,420 --> 00:07:13,640
箭头显示了哪些状态可以在其他状态之间移动 

162
00:07:13,640 --> 00:07:17,110
如我们所见 StartState可以通过向上和向下箭头移动

163
00:07:17,110 --> 00:07:18,700
在High ScoreState 

164
00:07:18,700 --> 00:07:20,710
它可以在HighScoreState和Back之间移动 

165
00:07:20,710 --> 00:07:23,020
所以当你进入HighScoreState时 按Escape键 

166
00:07:23,020 --> 00:07:25,180
回到StartState 

167
00:07:25,180 --> 00:07:27,280
StartState也有一个分支箭头

168
00:07:27,280 --> 00:07:29,710
向左一直到PaddleSelectState

169
00:07:29,710 --> 00:07:32,952
我们看到用户能够选择要使用的划桨 

170
00:07:32,952 --> 00:07:35,410
一旦他们选择了划桨 我们就去ServeState 

171
00:07:35,410 --> 00:07:37,780
他们将能够悠闲地发球 

172
00:07:37,780 --> 00:07:40,380
然后它将在PlayState之间来回移动 

173
00:07:40,380 --> 00:07:43,900
因此 如果他们最终受到损害 球

174
00:07:43,900 --> 00:07:47,230
在屏幕表面以下 它们将返回到ServeState

175
00:07:47,230 --> 00:07:49,930
这样他们才能重新定位自己 

176
00:07:49,930 --> 00:07:53,170
如果他们在PlayState 他们最终得分 

177
00:07:53,170 --> 00:07:55,476
清理整套砖 他们会

178
00:07:55,476 --> 00:07:57,100
实际上被带到了维克托州 

179
00:07:57,100 --> 00:07:59,266
而VictoryState是我们增加级别的地方

180
00:07:59,266 --> 00:08:00,760
我们还重新生成了级别 

181
00:08:00,760 --> 00:08:02,801
而VictoryState回到ServeState 

182
00:08:02,801 --> 00:08:04,990
然后我们再重复一遍整个循环 

183
00:08:04,990 --> 00:08:08,200
在PlayState 如果他们想要结束一场比赛 

184
00:08:08,200 --> 00:08:10,960
他们会去GameOverState 它会告诉他们他们的分数 

185
00:08:10,960 --> 00:08:13,090
然后他们会进入EnterHighScoreState

186
00:08:13,090 --> 00:08:14,950
取决于他们的分数是否很高 

187
00:08:14,950 --> 00:08:18,010
如果不是 如向上和向左的箭头所示 

188
00:08:18,010 --> 00:08:19,990
他们实际上会回到星际之州 

189
00:08:19,990 --> 00:08:22,730
然后EnterHighScoreState也将返回到HighScoreState

190
00:08:22,730 --> 00:08:24,438
这样他们一进门就能看到

191
00:08:24,438 --> 00:08:27,687
他们的高分 他们的分数相对于列表中的其他分数 

192
00:08:27,687 --> 00:08:29,770
所以在我们现在要看的《突破0》中 

193
00:08:29,770 --> 00:08:31,436
我们要做一些非常基本的事情 

194
00:08:31,436 --> 00:08:34,059
因此 这是一如既往的第0天更新 

195
00:08:34,059 --> 00:08:37,900
我现在在《越狱0》里 

196
00:08:37,900 --> 00:08:39,049
是的 我是 

197
00:08:39,049 --> 00:08:42,940
所以我们要做的是 我们首先来看这里的第27行 

198
00:08:42,940 --> 00:08:47,110
所以在我们在应用程序中所做的事情之前

199
00:08:47,110 --> 00:08:51,850
基本上在顶层有很多文件 有点迷失了方向

200
00:08:51,850 --> 00:08:53,697
我们可能在做什么 

201
00:08:53,697 --> 00:08:55,780
特别是当你开始添加越来越多的文件

202
00:08:55,780 --> 00:08:58,330
还有50到100个文件

203
00:08:58,330 --> 00:09:00,190
一些明显不重要的东西

204
00:09:00,190 --> 00:09:02,884
所以解决的办法是 把它们放在文件夹里

205
00:09:02,884 --> 00:09:04,300
然后记录所有的事情

206
00:09:04,300 --> 00:09:05,370
让他们有组织 

207
00:09:05,370 --> 00:09:07,745
这是我们要开始做的一件大事 

208
00:09:07,745 --> 00:09:10,120
最重要的是 在代码中 

209
00:09:10,120 --> 00:09:11,800
让事情变得更加模块化 

210
00:09:11,800 --> 00:09:15,790
这就是为什么我们有这个文件源斜杠依赖项 

211
00:09:15,790 --> 00:09:18,520
我们马上就会看到 

212
00:09:18,520 --> 00:09:20,530
我们在这里分配了一堆全局表 

213
00:09:20,530 --> 00:09:23,410
所以我们的设计决定

214
00:09:23,410 --> 00:09:26,740
虽然我提到过我们会把很多全局变量

215
00:09:26,740 --> 00:09:29,740
从我们的应用程序资产中 

216
00:09:29,740 --> 00:09:31,450
所有这些都是全局变量 

217
00:09:31,450 --> 00:09:34,491
将来我们会看到如何实现资源管理器

218
00:09:34,491 --> 00:09:36,430
为我们解决这个问题 

219
00:09:36,430 --> 00:09:38,890
但现在 为了简单起见 在爱 负荷 

220
00:09:38,890 --> 00:09:41,320
我们只需要几个全局表 

221
00:09:41,320 --> 00:09:43,300
在本例中是全局字体 

222
00:09:43,300 --> 00:09:46,237
通过键 我们可以索引小 中 大字体 

223
00:09:46,237 --> 00:09:48,070
就是不同大小的新字体

224
00:09:48,070 --> 00:09:49,379
八十六三十二

225
00:09:49,379 --> 00:09:50,170
我们正在利用它 

226
00:09:50,170 --> 00:09:53,649
我们现在有一个字体文件夹 而不仅仅是保持在父级 

227
00:09:53,649 --> 00:09:54,940
我们将把它设置为小 

228
00:09:54,940 --> 00:09:55,960
我们有全局纹理 

229
00:09:55,960 --> 00:09:59,641
背景 主 箭头 红心 粒子 

230
00:09:59,641 --> 00:10:02,390
所以我们有背景 这是我们屏幕的背景 

231
00:10:02,390 --> 00:10:05,230
我们所有的砖块球拍球等等都在总部

232
00:10:05,230 --> 00:10:07,770
箭头将用于桨选择屏幕 

233
00:10:07,770 --> 00:10:09,220
两个左右箭头 

234
00:10:09,220 --> 00:10:10,990
心脏是为了我们的健康 

235
00:10:10,990 --> 00:10:13,570
粒子是一个很小很小的纹理

236
00:10:13,570 --> 00:10:16,330
我们将用它来产生粒子系统中的所有粒子

237
00:10:16,330 --> 00:10:20,584
稍后当我们接近演示的尾声时 

238
00:10:20,584 --> 00:10:21,250
所以这是推 

239
00:10:21,250 --> 00:10:22,450
我们就像平常一样布置 

240
00:10:22,450 --> 00:10:23,440
没什么新鲜的

241
00:10:23,440 --> 00:10:26,200
除了虚拟宽度 虚拟高度 以及所有这些东西 

242
00:10:26,200 --> 00:10:29,930
如果我们在一个常量文件中查看源代码 这些都被移走了 

243
00:10:29,930 --> 00:10:32,770
所以这个文件 没有包含main中的所有常量 

244
00:10:32,770 --> 00:10:35,020
把它们拿出来 

245
00:10:35,020 --> 00:10:39,520
在一个名为constants.lua的文件中 我们可以排序管理所有这些 

246
00:10:39,520 --> 00:10:42,340
当我们看到资本窗口时 

247
00:10:42,340 --> 00:10:43,240
宽度 窗户高度 等等

248
00:10:43,240 --> 00:10:44,410
这些都是常量 

249
00:10:44,410 --> 00:10:46,150
如果你有一个常量文件 我们可以更容易地

250
00:10:46,150 --> 00:10:48,460
追踪它而不是抓取我们所有的文件

251
00:10:48,460 --> 00:10:50,410
试图弄清楚我们在看什么

252
00:10:53,830 --> 00:10:59,410
和前面一样 常量在设置屏幕中使用 

253
00:10:59,410 --> 00:11:03,289
然后另一个声音全局表 就像以前一样 

254
00:11:03,289 --> 00:11:05,080
我们有很多不同的音效 

255
00:11:05,080 --> 00:11:07,038
我把音乐和音效分开了

256
00:11:07,038 --> 00:11:10,020
就为了让我们一眼就能看出来 哦 这是音乐 

257
00:11:10,020 --> 00:11:11,560
这些是音效 

258
00:11:11,560 --> 00:11:12,970
很直接 

259
00:11:12,970 --> 00:11:14,500
我们有一个国家机器 一如既往 

260
00:11:14,500 --> 00:11:18,250
我们将使用StartState来进行演示 

261
00:11:18,250 --> 00:11:20,770
将其设置为开始 

262
00:11:20,770 --> 00:11:22,180
爱 调整大小 爱 更新 

263
00:11:22,180 --> 00:11:23,929
这些都是我们以前见过的函数 

264
00:11:23,929 --> 00:11:25,000
没什么新鲜的

265
00:11:25,000 --> 00:11:25,772
Love.keypress.

266
00:11:25,772 --> 00:11:26,980
我们有一个全局输入表 

267
00:11:26,980 --> 00:11:30,880
就像Flappy Bird一样 我们可以在任何地方索引输入表

268
00:11:30,880 --> 00:11:34,930
在我们的应用程序中调用love.keyboard.wasPressed[key] 

269
00:11:34,930 --> 00:11:38,020
它允许我们专门从main获取输入并使用它

270
00:11:38,020 --> 00:11:40,680
在其他模块中 

271
00:11:40,680 --> 00:11:42,850
这里我们画的是

272
00:11:42,850 --> 00:11:45,160
这是实际的渲染代码 

273
00:11:45,160 --> 00:11:49,690
我们在我们的爱中这样做 draw与特定的状态相对

274
00:11:49,690 --> 00:11:51,940
因为这实际上适用于所有州 

275
00:11:51,940 --> 00:11:53,731
我们总是会有这样的背景 

276
00:11:53,731 --> 00:11:55,900
所以与其一遍又一遍地重复 

277
00:11:55,900 --> 00:11:58,240
在本例中 这一小段代码 

278
00:11:58,240 --> 00:12:02,214
我们将显示所有状态后面的背景 

279
00:12:02,214 --> 00:12:04,630
所以所有的州都将在这个背景下渲染

280
00:12:04,630 --> 00:12:07,000
让它看起来更有凝聚力 

281
00:12:07,000 --> 00:12:09,039
我们将在没有旋转的情况下画0 0 

282
00:12:09,039 --> 00:12:11,080
然后这里有一些数学运算 即虚拟宽度

283
00:12:11,080 --> 00:12:15,929
除以 然后背景宽度减去1 最终得到一个比例因子

284
00:12:15,929 --> 00:12:18,220
这样我们就可以始终将其调整到我们的虚拟宽度 

285
00:12:18,220 --> 00:12:22,930
因为默认情况下纹理比实际窗口小一些

286
00:12:22,930 --> 00:12:26,140
或者我们的实际虚拟宽度和高度 但通过除以虚拟宽度

287
00:12:26,140 --> 00:12:29,560
无论该图像的背景宽度是多少 

288
00:12:29,560 --> 00:12:32,950
我们将获得比例因子 因为虚拟宽度大于图像 

289
00:12:32,950 --> 00:12:37,270
我们将得到X和Y的比例因子 它等同于它完全拉伸

290
00:12:37,270 --> 00:12:41,050
来填满我们的虚拟宽度和高度 

291
00:12:41,050 --> 00:12:44,136
回想一下 这两个参数是X和Y上的比例 

292
00:12:44,136 --> 00:12:47,260
所以这将是一些 就像 一点什么或两点什么 

293
00:12:47,260 --> 00:12:50,230
不惜一切代价来填满屏幕 

294
00:12:50,230 --> 00:12:52,567
最后 在这里 我实现的新Bit

295
00:12:52,567 --> 00:12:55,150
只是一个每秒显示帧的函数 我认为

296
00:12:55,150 --> 00:12:58,357
通常是很重要的 而且很容易做到 

297
00:12:58,357 --> 00:13:00,940
我不记得了 我想我们还没谈过 但只是

298
00:13:00,940 --> 00:13:02,710
Love.timer.getFPS 

299
00:13:02,710 --> 00:13:04,811
然后我就在左上角画上绿色

300
00:13:04,811 --> 00:13:07,810
这样我们就可以在游戏的所有迭代中看到它 什么

301
00:13:07,810 --> 00:13:08,770
每秒的帧数是 

302
00:13:08,770 --> 00:13:12,070
如果您想要在无需查看终端或任何东西的情况下进行监控

303
00:13:12,070 --> 00:13:13,861
就像这样 就在上面显示 它是

304
00:13:13,861 --> 00:13:16,090
这是很多比赛中的标准练习 

305
00:13:16,090 --> 00:13:18,140
如果您已进入调试控制台或诸如此类的

306
00:13:18,140 --> 00:13:20,920
或者是调查了一些黑客行为 

307
00:13:20,920 --> 00:13:23,030
你会在很多地方看到这一点 

308
00:13:23,030 --> 00:13:25,750
所以我早些时候谈到了依赖 

309
00:13:25,750 --> 00:13:30,190
因此 这也与我们将一切模块化的努力联系在一起 

310
00:13:30,190 --> 00:13:31,750
保持一切井然有序 

311
00:13:31,750 --> 00:13:34,010
而不是要求所有东西都放在Main的顶部 

312
00:13:34,010 --> 00:13:36,550
让我们把它们都放在一个文件里 然后我们

313
00:13:36,550 --> 00:13:40,630
一目了然地知道我们需要什么 我们不必查看Main

314
00:13:40,630 --> 00:13:44,620
并建造100条主线 这可能比需要的要多得多 

315
00:13:44,620 --> 00:13:47,500
所以需要推动 需要上进 

316
00:13:47,500 --> 00:13:49,690
和我们以前做的一样 

317
00:13:49,690 --> 00:13:50,791
需要Soure.Constants 

318
00:13:50,791 --> 00:13:51,790
我们有权访问这些文件 

319
00:13:51,790 --> 00:13:55,550
需要StateMachine 然后是BaseState和StartState 

320
00:13:55,550 --> 00:13:58,750
那么 让我们继续来看看我们的StartState 

321
00:13:58,750 --> 00:14:01,330
所以我把州放在了SOURCE的子文件夹中 

322
00:14:01,330 --> 00:14:03,580
这是另一种让事情保持模块化的努力 

323
00:14:03,580 --> 00:14:08,410
在这个特定的项目中 我们不会有很多嵌套的代码文件夹 

324
00:14:08,410 --> 00:14:10,720
但我决定把各州放在他们自己的文件夹里

325
00:14:10,720 --> 00:14:14,130
你可以很容易地访问你所有的州 

326
00:14:14,130 --> 00:14:18,610
因此 我们将在这里的第21行查看StartState 

327
00:14:18,610 --> 00:14:21,940
回想一下 在StartState中 我们刚刚在屏幕中央显示了Breakout

328
00:14:21,940 --> 00:14:24,950
然后我们有了首发比赛和高分 

329
00:14:24,950 --> 00:14:27,772
因此 用户能够突出显示他想要查看的州 

330
00:14:27,772 --> 00:14:29,980
因此 我们需要跟踪突出显示的是哪一个 

331
00:14:29,980 --> 00:14:32,220
所以所有这个变量的目的只是为了跟踪 

332
00:14:32,220 --> 00:14:33,250
那就一两个吧 

333
00:14:33,250 --> 00:14:36,115
一个是玩游戏 两个是高分 

334
00:14:39,580 --> 00:14:43,930
然后在这里 如果我们上下按压 那么我们--

335
00:14:43,930 --> 00:14:45,850
因为实际上只有两种选择 

336
00:14:45,850 --> 00:14:48,400
你可以只用一两个来翻转任何高亮的部分 

337
00:14:48,400 --> 00:14:50,590
如果你有一个多于两个的选项列表 

338
00:14:50,590 --> 00:14:52,840
你需要递增一个 直到它到达任何

339
00:14:52,840 --> 00:14:55,332
X是您的列表选项的数量 

340
00:14:55,332 --> 00:14:57,040
然后如果你在那个点按下 

341
00:14:57,040 --> 00:14:58,840
你应该翻到最上面去 

342
00:14:58,840 --> 00:15:02,110
同样的道理也适用于你是否选择了第一种选择 

343
00:15:02,110 --> 00:15:05,290
你应该去翻转 旋转到你的清单的底部

344
00:15:05,290 --> 00:15:08,712
这样看起来你就像是绕了一圈 

345
00:15:08,712 --> 00:15:11,170
然后--当我们这样做的时候 我们只是在这里播放声音 

346
00:15:11,170 --> 00:15:14,390
我们有一个love.keyboard.wa按下[退出]调用

347
00:15:14,390 --> 00:15:14,890
这里 

348
00:15:14,890 --> 00:15:18,109
它不再是全局的 因为我们的应用程序中有一些状态

349
00:15:18,109 --> 00:15:20,650
我们可能想按下Escape来后退

350
00:15:20,650 --> 00:15:22,464
我们会看到的

351
00:15:22,464 --> 00:15:23,380
在这里渲染 

352
00:15:23,380 --> 00:15:25,450
我们用大字体渲染Breakout 

353
00:15:25,450 --> 00:15:29,500
现在我们可以在屏幕中央的大键处访问G字体 

354
00:15:29,500 --> 00:15:30,370
设置中等字体 

355
00:15:30,370 --> 00:15:36,060
然后我们将一个接一个地呈现两个文本字段 

356
00:15:36,060 --> 00:15:38,132
但如果高亮部分等于1 

357
00:15:38,132 --> 00:15:40,590
将它设置为蓝色 这是三种颜色之一 

358
00:15:40,590 --> 00:15:43,590
255 255 255

359
00:15:43,590 --> 00:15:44,996
然后将其渲染 

360
00:15:44,996 --> 00:15:47,620
然后确保在那之后重置颜色 因为回想一下 

361
00:15:47,620 --> 00:15:50,270
爱情2D本身就像一个状态机 

362
00:15:50,270 --> 00:15:53,340
如果你给某个东西设置颜色 不管你画什么 

363
00:15:53,340 --> 00:15:56,430
然后呢 不管是图片还是文字 都会采用这个颜色 

364
00:15:56,430 --> 00:16:00,480
所有的都是255 255 255 255 

365
00:16:00,480 --> 00:16:02,670
它是纯白色的 完全不透明 

366
00:16:02,670 --> 00:16:04,920
把所有东西都画成完全不透明的效果 

367
00:16:04,920 --> 00:16:07,980
但如果你不这样做 你的图像或你后来画的东西 

368
00:16:07,980 --> 00:16:10,962
会是有色的或透明的 这是你大多数时候不想要的 

369
00:16:10,962 --> 00:16:13,170
但有时候你可能会想要 

370
00:16:13,170 --> 00:16:14,589
在PaddleSelectState中可以看到 

371
00:16:14,589 --> 00:16:15,880
同样的道理也适用于这里 

372
00:16:15,880 --> 00:16:19,090
如果突出显示的是两个 则执行完全相同的操作 

373
00:16:19,090 --> 00:16:22,830
如果我们运行这个应用程序 

374
00:16:22,830 --> 00:16:26,771
只是我们之前看到的一个子集 我们可以上下移动

375
00:16:26,771 --> 00:16:28,020
在开始和最高分之间 

376
00:16:28,020 --> 00:16:30,270
但如果我们按下任何一个回车键 

377
00:16:30,270 --> 00:16:33,450
因为我们没有事件处理程序来处理它 

378
00:16:33,450 --> 00:16:37,300
但是我们有缩放到屏幕上的图像 我们有中间的突破 

379
00:16:37,300 --> 00:16:40,750
我们有两个菜单选项

380
00:16:40,750 --> 00:16:41,680
所以Breakout 1.

381
00:16:41,680 --> 00:16:46,710
这就是我们开始深入精灵表的地方 

382
00:16:46,710 --> 00:16:49,530
是游戏开发的主要组成部分 2D游戏

383
00:16:49,530 --> 00:16:53,340
我们将在未来和这个应用程序中看到的发展 

384
00:16:53,340 --> 00:16:57,300
但最终 精灵表单只是 而不是有--

385
00:16:57,300 --> 00:17:00,150
我不知道这张精灵纸上有多少张图片 

386
00:17:00,150 --> 00:17:03,030
但无论这些文件有多少 只要有

387
00:17:03,030 --> 00:17:07,200
一个文件将它们放在一起 然后使用矩形定义

388
00:17:07,200 --> 00:17:08,849
所有不同的精灵都在那里 

389
00:17:08,849 --> 00:17:11,400
然后当我们想要画的时候 使用这些矩形

390
00:17:11,400 --> 00:17:14,230
告诉我爱 图解 画 我要你

391
00:17:14,230 --> 00:17:16,589
来绘制这个纹理 这个精灵图案 但是我想

392
00:17:16,589 --> 00:17:19,500
你只需要画它的这一部分.

393
00:17:19,500 --> 00:17:23,490
你会在一个四边形中传递它 这个四边形只是一个简单的矩形 上面有高度 X和Y 

394
00:17:23,490 --> 00:17:27,900
喜欢2D的人会知道 好的 我要画这个图像 但只有这一点 

395
00:17:27,900 --> 00:17:31,290
它的效果就像你只画了很小的图像

396
00:17:31,290 --> 00:17:34,092
而不是一个可怕的形象 

397
00:17:34,092 --> 00:17:36,300
以及与我们要查看的相关函数

398
00:17:36,300 --> 00:17:41,250
是love.graph ics.newquad 它接受X、Y、宽度和高度 

399
00:17:41,250 --> 00:17:45,570
还有一个维度对象 这是从图像中获得的 

400
00:17:45,570 --> 00:17:46,380
我们会看到的 

401
00:17:46,380 --> 00:17:50,870
我相信 所有这些基本上只是一个X Y 宽度和高度 

402
00:17:50,870 --> 00:17:54,540
或者只是宽度和高度 更确切地说 来自任何图像

403
00:17:54,540 --> 00:17:57,180
您想要为创建四边形 

404
00:17:57,180 --> 00:18:00,174
然后是爱 画 画 我们已经看过了 

405
00:18:00,174 --> 00:18:01,590
但这是一个不同的签名 

406
00:18:01,590 --> 00:18:06,480
这有纹理 四边形 X Y 四边形是第二个参数 

407
00:18:06,480 --> 00:18:09,030
当它进入这个四边形时 它知道只有抽签

408
00:18:09,030 --> 00:18:13,290
定义的矩形图像显示在屏幕上 

409
00:18:13,290 --> 00:18:17,436
接下来 我们将继续关注《突破1》 

410
00:18:17,436 --> 00:18:22,746
观众：[听不见]

411
00:18:22,746 --> 00:18:24,870
科尔顿·奥格登：问题是 有没有什么工具

412
00:18:24,870 --> 00:18:28,980
这样我们在做床单的时候就不用去猜四合院在哪里了？

413
00:18:28,980 --> 00:18:31,320
是的 有很多时间 

414
00:18:31,320 --> 00:18:35,637
我看了看 看到了几个 但我自己还没有彻底测试过它们 

415
00:18:35,637 --> 00:18:37,470
对于像这样的简单示例 通常是

416
00:18:37,470 --> 00:18:39,053
非常简单 可以通过编程来完成 

417
00:18:39,053 --> 00:18:42,840
但是的 当你开始阅读巨型精灵地图集时 

418
00:18:42,840 --> 00:18:46,890
你有特别的东西不一定是对称的

419
00:18:46,890 --> 00:18:50,970
或者看起来是矩形的 尽管它们仍然需要被限定为矩形 

420
00:18:50,970 --> 00:18:54,600
通常最好使用这样的工具 

421
00:18:54,600 --> 00:18:57,600
有 我相信 我只是没有使用它们 

422
00:18:57,600 --> 00:19:00,450
我可以在以后的讲座中提出来 这样我们就可以讨论了 

423
00:19:03,450 --> 00:19:08,430
在我们进入Breakout 1之前还有其他问题吗？

424
00:19:08,430 --> 00:19:09,840
好吧

425
00:19:09,840 --> 00:19:12,450
所以我将打开第一个

426
00:19:12,450 --> 00:19:14,430
我们应该在Breakout 1上看看 

427
00:19:14,430 --> 00:19:18,000
在源目录中 我们有一个新文件 

428
00:19:18,000 --> 00:19:20,970
从现在开始 我假设 

429
00:19:20,970 --> 00:19:24,990
我们总是假设当我们引入一个新文件时 

430
00:19:24,990 --> 00:19:28,620
我们将把它包含在dependencies. lua中 

431
00:19:28,620 --> 00:19:32,160
所以在这种情况下 我们只需要说require source/util 

432
00:19:32,160 --> 00:19:38,700
正如你所看到的 我们还在这个演示中添加了一个PlayState 

433
00:19:38,700 --> 00:19:41,520
但从现在开始 我不会再提我们了

434
00:19:41,520 --> 00:19:42,840
将其添加到我们的项目中 

435
00:19:42,840 --> 00:19:47,210
所以util.lua是包含代码的模块

436
00:19:47,210 --> 00:19:51,150
我们将使用它来为给定的精灵表生成四边形 

437
00:19:51,150 --> 00:19:54,850
这个函数 它所做的就是 它需要一个地图集或精灵表--

438
00:19:54,850 --> 00:19:56,110
这两个名字是同义的 

439
00:19:56,110 --> 00:19:57,370
你会听到他们两个 

440
00:19:57,370 --> 00:20:02,040
或者我们给它一个地图集 我们给它我们想要的瓷砖的宽度

441
00:20:02,040 --> 00:20:04,800
和瓷砖的高度 

442
00:20:04,800 --> 00:20:07,440
它会得到纸张的宽度和高度 

443
00:20:07,440 --> 00:20:11,050
所以每幅图像都有一个函数叫做获取宽度和高度 

444
00:20:11,050 --> 00:20:13,150
所以我们就这么做

445
00:20:13,150 --> 00:20:16,290
特别是纸张的宽度和高度

446
00:20:16,290 --> 00:20:19,920
是图像的宽度除以图块宽度和图块高度 

447
00:20:19,920 --> 00:20:23,480
这样我们就知道我们需要在精灵表上重复多少次

448
00:20:23,480 --> 00:20:24,480
来生成矩形 

449
00:20:24,480 --> 00:20:29,700
我们根据瓷砖的大小来划分 

450
00:20:29,700 --> 00:20:32,350
然后我们在这里做一个简单的嵌套四个循环 

451
00:20:32,350 --> 00:20:34,250
我们开始一个计数器和一个精灵表 

452
00:20:34,250 --> 00:20:37,470
这个精灵表将是一个表 容纳我们所有的四边形 

453
00:20:37,470 --> 00:20:39,220
我们只说Y 得到零 

454
00:20:39,220 --> 00:20:40,400
图纸高度减一 

455
00:20:40,400 --> 00:20:44,200
所以从左上角开始往下走 

456
00:20:44,200 --> 00:20:46,720
从顶部开始向下 然后x等于零 

457
00:20:46,720 --> 00:20:50,320
从左边开始向右转 

458
00:20:50,320 --> 00:20:55,540
在Sprite Sheet Sheet Counter 这是一个因为在Lua 

459
00:20:55,540 --> 00:20:57,280
表是一个索引表 

460
00:20:57,280 --> 00:21:02,650
我们将创建一个新的四边形 X乘以瓷砖宽度 Y乘以瓷砖宽度 

461
00:21:02,650 --> 00:21:05,110
给它和我们的瓷砖一样的宽度和高度 

462
00:21:05,110 --> 00:21:07,930
所以 无论我们传递给函数签名的是什么 

463
00:21:07,930 --> 00:21:10,420
在这种情况下 通常是16x32

464
00:21:10,420 --> 00:21:14,590
因为这就是砖块的大小 

465
00:21:14,590 --> 00:21:17,380
然后我们传入幻灯片中看到的最后一个参数 

466
00:21:17,380 --> 00:21:19,640
这就是地图集：获取维度 

467
00:21:19,640 --> 00:21:21,760
然后我们只需在这里增加我们的床单计数器 

468
00:21:21,760 --> 00:21:23,990
然后在这个结束的时候 当我们都做完了 我们会把这个还回去 

469
00:21:23,990 --> 00:21:25,930
我们会有一张四合院的桌子 然后我们就可以

470
00:21:25,930 --> 00:21:31,410
以一、二、三、四、五、六、七、八的形式使用 

471
00:21:31,410 --> 00:21:34,390
嗯 我应该说 一 二 三 四 五 六 七 八

472
00:21:34,390 --> 00:21:38,230
从左到右是我们床单上所有的精灵

473
00:21:38,230 --> 00:21:40,990
看起来超级简单 

474
00:21:40,990 --> 00:21:42,480
我们这里还有一个功能 

475
00:21:42,480 --> 00:21:45,940
默认情况下 Lua没有切片功能 但我们只是在添加它 

476
00:21:45,940 --> 00:21:47,200
桌子 切片 

477
00:21:47,200 --> 00:21:52,390
它首先获取表 表中我们想要的第一个条目 

478
00:21:52,390 --> 00:21:54,940
最后一个条目 然后是它们之间的步骤 

479
00:21:54,940 --> 00:22:00,160
就像Pythons切片函数一样 它只是迭代

480
00:22:00,160 --> 00:22:02,500
For循环 这是倒数第一个循环 

481
00:22:02,500 --> 00:22:10,270
因此 默认情况下只有一个 直到最后或者直到任何这样的数字符号

482
00:22:10,270 --> 00:22:13,450
是一张桌子的大小 我想我们还没有介绍过 

483
00:22:13,450 --> 00:22:18,430
但基本上 如果我们最后通过 它就会止步于此 否则

484
00:22:18,430 --> 00:22:20,920
假设我们想要整个表 

485
00:22:20,920 --> 00:22:25,030
然后这个逗号在末尾 它有一步或一步 

486
00:22:25,030 --> 00:22:28,600
您可以在for循环的末尾传入一个步骤作为第三个参数 

487
00:22:28,600 --> 00:22:33,710
这将会增加或减少你所处的循环 

488
00:22:33,710 --> 00:22:35,000
因此 默认情况下 只有一个 

489
00:22:35,000 --> 00:22:37,540
我们先走一步 然后走到第二步 再走到第三步 

490
00:22:37,540 --> 00:22:39,260
但您可以将其设置为负1 

491
00:22:39,260 --> 00:22:42,370
所以如果你说四 我得到三减一 

492
00:22:42,370 --> 00:22:44,260
你来三 二 一 

493
00:22:44,260 --> 00:22:50,170
而且你不能正常地走一步 而我们这里就是这样做的 

494
00:22:50,170 --> 00:22:52,100
不 你可以走一步 但你不能切开 

495
00:22:52,100 --> 00:22:58,250
这就是为什么我们在这里以切片的数量加一得到表i 

496
00:22:58,250 --> 00:22:59,750
然后最终我们返回Slice 

497
00:22:59,750 --> 00:23:04,690
所以它只返回我们所在表的一部分 

498
00:23:04,690 --> 00:23:07,270
然后这里的重要功能是 我们实际上

499
00:23:07,270 --> 00:23:11,440
要在我们的应用程序中使用 我们将生成四足桨 

500
00:23:11,440 --> 00:23:15,070
所以这需要X和Y 0和64 

501
00:23:15,070 --> 00:23:19,630
如果我们回过头来看我们的桨 我们

502
00:23:19,630 --> 00:23:22,100
可以看到我们有各种不同的尺码 

503
00:23:22,100 --> 00:23:25,690
所以我们有一个小的 一个中号的 一个大的 然后是一个非常大的 

504
00:23:25,690 --> 00:23:30,130
所以如果我们想把每一只桨都放在雪碧表上 

505
00:23:30,130 --> 00:23:33,809
小、中、大、大 请注意 我们有四个街区

506
00:23:33,809 --> 00:23:36,350
在每一块中 我们有四种不同的大小 

507
00:23:36,350 --> 00:23:38,200
所以我们可以重复这四次

508
00:23:38,200 --> 00:23:41,005
然后定义这个矩形的大小

509
00:23:41,005 --> 00:23:43,270
就是那个教区 那个教区 那个教区 

510
00:23:43,270 --> 00:23:45,850
我们将在这里看到它的数学计算 

511
00:23:45,850 --> 00:23:50,920
如果我从零到三 对我来说 从零到三 

512
00:23:50,920 --> 00:23:53,890
我们要继续 因为这会给我们四个 

513
00:23:53,890 --> 00:23:57,400
这就是我们要在精灵工作表上迭代的次数

514
00:23:57,400 --> 00:24:00,010
才能得到单独的四元组 

515
00:24:00,010 --> 00:24:01,990
我们会买最小的 

516
00:24:01,990 --> 00:24:03,160
因此 四元组起了反作用 

517
00:24:03,160 --> 00:24:05,080
我们将计数器初始化为1 

518
00:24:05,080 --> 00:24:11,980
得到了爱 图形 这个新的四边形在X Y 32和16 

519
00:24:11,980 --> 00:24:16,960
哦 X和Y在这里默认为0和64 因为音符--

520
00:24:16,960 --> 00:24:21,880
回想一下 这里的这些都是16个高的 

521
00:24:21,880 --> 00:24:24,520
所以我们从64开始 所以我们从这里开始 

522
00:24:24,520 --> 00:24:28,792
我们从零开始 因为它在左边 

523
00:24:28,792 --> 00:24:29,500
所以我们就这么做 

524
00:24:29,500 --> 00:24:31,780
我们会递增计数器 

525
00:24:31,780 --> 00:24:34,150
把它调到32宽16高 

526
00:24:34,150 --> 00:24:36,430
这些是最小的一个的实际尺寸 

527
00:24:36,430 --> 00:24:40,240
同样的逻辑也适用于中型和大型企业 

528
00:24:40,240 --> 00:24:44,560
只是我们加了32 然后我们把它改成64号 

529
00:24:44,560 --> 00:24:49,420
然后我们在96号的X上加96 因为它们变宽了 

530
00:24:49,420 --> 00:24:52,510
但他们也在更多地向右倾斜 

531
00:24:52,510 --> 00:24:56,830
最后一点和以前几乎一样 除了现在我们

532
00:24:56,830 --> 00:25:01,960
将Y加16返回到X 因为我们在精灵工作表中排到了下一行

533
00:25:01,960 --> 00:25:06,580
此时的桨宽为128 但仍为16像素 

534
00:25:06,580 --> 00:25:13,280
然后在底部 因为我们想要做四次 

535
00:25:13,280 --> 00:25:16,030
我们想要检查的块实际上是32个像素

536
00:25:16,030 --> 00:25:19,350
因为我们要开到16 16 16 16 

537
00:25:19,350 --> 00:25:23,080
我们要把32加到Y上 然后转到下一组四个球拍 

538
00:25:23,080 --> 00:25:26,350
这就是我们如何有效地获得所有的划桨精灵 

539
00:25:26,350 --> 00:25:30,900
它们将从一个存储到X 我相信X是16 

540
00:25:30,900 --> 00:25:34,180
因此 我们将在精灵工作表中定义16个四边形

541
00:25:34,180 --> 00:25:36,560
之后 我们就可以回来了 

542
00:25:36,560 --> 00:25:43,640
所以我要回到主要的 Lua 现在在64行 

543
00:25:43,640 --> 00:25:47,321
这里我们有一个新的全局表 名为GFRAMES 

544
00:25:47,321 --> 00:25:49,820
我们将能够在任何想要画东西的地方访问它 

545
00:25:49,820 --> 00:25:52,010
这和我们刚刚看到的是一样的 

546
00:25:52,010 --> 00:25:55,430
生成四足桨 我们只是在我们的主纹理中传递它 

547
00:25:55,430 --> 00:25:57,350
我们的主要质地是这个 

548
00:25:57,350 --> 00:25:59,695
这是我们的主要纹理看起来是什么样子 

549
00:25:59,695 --> 00:26:01,070
然后我们要将其编入索引 

550
00:26:01,070 --> 00:26:04,610
我们会说它得到了关键的控制板 

551
00:26:04,610 --> 00:26:10,400
因为在那个特定的桌子上只有我们的球拍的四个方格 

552
00:26:10,400 --> 00:26:14,330
因此 在将来 我们只需要调用love.graph ics.Drawing纹理 然后

553
00:26:14,330 --> 00:26:19,640
索引到框架划桨在任何我们想要的划桨 

554
00:26:19,640 --> 00:26:24,440
这就是我们可以跟踪我们想要画的划桨明智的方式 

555
00:26:24,440 --> 00:26:28,010
在这个特定的演示中 我们有一个新的Padle类

556
00:26:28,010 --> 00:26:30,380
因为划桨是我们比赛中的一件事 

557
00:26:30,380 --> 00:26:33,390
我们可以将其表示为某种类或对象 

558
00:26:33,390 --> 00:26:36,599
所以我们将为它定义一个类 

559
00:26:36,599 --> 00:26:38,140
到目前为止 一切都很简单 

560
00:26:38,140 --> 00:26:41,680
得到X和Y Dx随高度为零 

561
00:26:41,680 --> 00:26:42,470
皮肤 

562
00:26:42,470 --> 00:26:45,800
皮肤将是什么颜色的 

563
00:26:45,800 --> 00:26:47,300
我们需要跟踪这一点 

564
00:26:47,300 --> 00:26:51,440
然后是大小 因为大小将是我们排序的偏移量

565
00:26:51,440 --> 00:26:56,540
进入我们的桨 我们的四肢 因为大小有小的 中等的 大的 巨大的 

566
00:26:56,540 --> 00:26:58,306
一 二 三 四乘四 

567
00:26:58,306 --> 00:27:00,680
所以第一盘一 二 三 四 然后五 

568
00:27:00,680 --> 00:27:03,079
第二盘是六、七、八 

569
00:27:03,079 --> 00:27:04,370
这些都是按颜色排列的 

570
00:27:04,370 --> 00:27:07,140
所以我们可以乘以皮肤时间--

571
00:27:07,140 --> 00:27:12,050
或者我们可以通过皮肤来繁殖我们的体型

572
00:27:12,050 --> 00:27:15,710
这将为我们提供当前帧 即我们想要的当前四边形

573
00:27:15,710 --> 00:27:18,770
画到屏幕上 

574
00:27:18,770 --> 00:27:21,040
然后在7号线上--

575
00:27:21,040 --> 00:27:23,000
这就是键盘输入 

576
00:27:23,000 --> 00:27:24,340
我们以前见过的东西 

577
00:27:24,340 --> 00:27:28,570
如果我们按向左或向右 那么球拍应该会移动 

578
00:27:28,570 --> 00:27:31,167
DX应设置为左侧或右侧 

579
00:27:31,167 --> 00:27:32,000
我们想把它夹住 

580
00:27:32,000 --> 00:27:33,770
我们看到了这个 我们也看到了这个 

581
00:27:33,770 --> 00:27:37,820
将输入夹在屏幕的左侧和右侧 

582
00:27:37,820 --> 00:27:42,050
如果dx小于零 则执行math.max和math.min 否则

583
00:27:42,050 --> 00:27:43,841
如果我们要向右移动 

584
00:27:43,841 --> 00:27:46,340
然后在这里 这实际上是我们将所有东西联系在一起的地方

585
00:27:46,340 --> 00:27:49,680
我们实际上使用四元组来在屏幕上绘制一些东西 

586
00:27:49,680 --> 00:27:54,860
因此 我们将其命名为love.graph 只绘制我们的纹理 我们的主要纹理 

587
00:27:54,860 --> 00:28:01,280
然后在我们现在的大小 也就是两个人的球拍上画出格框 

588
00:28:01,280 --> 00:28:07,760
默认情况下 我们想要中号外加四倍的

589
00:28:07,760 --> 00:28:10,080
我们的皮肤是负一 

590
00:28:10,080 --> 00:28:18,720
因此 如果我们的皮肤是蓝色皮肤 我们不会向它添加任何东西 

591
00:28:18,720 --> 00:28:20,370
只会是零的四倍 

592
00:28:20,370 --> 00:28:22,790
但如果我们有下一个 就会是二减一 

593
00:28:22,790 --> 00:28:24,710
所以我们最终会在上面加4 

594
00:28:24,710 --> 00:28:28,920
因为无论皮肤是什么 我们都要加四倍 

595
00:28:28,920 --> 00:28:32,120
它基本上会把我们四个四边形放进去 

596
00:28:32,120 --> 00:28:36,860
哪一个是下一个 完全一样的球拍 但下一个颜色 

597
00:28:36,860 --> 00:28:41,360
最后 我们要看的是PlayState 

598
00:28:41,360 --> 00:28:44,777
所以我们之前只有StartState 但是现在我们

599
00:28:44,777 --> 00:28:47,110
我想测试一下 确保我们能画出一个桨 

600
00:28:47,110 --> 00:28:48,450
在屏幕上移动

601
00:28:48,450 --> 00:28:50,630
所以我们要在这里实现一个简单的PlayState 

602
00:28:50,630 --> 00:28:53,840
所以在第20行 我们只是打电话给self 桨得到桨 

603
00:28:53,840 --> 00:28:56,220
我们正在初始化一个新的paddle对象 

604
00:28:56,220 --> 00:28:58,970
然后我们也在跟踪这个

605
00:28:58,970 --> 00:29:01,610
就是一个简单的暂停演示

606
00:29:01,610 --> 00:29:06,010
如果赛尔夫停顿了一下 那么--事实上是的 

607
00:29:06,010 --> 00:29:06,950
我说了自我停顿吗？

608
00:29:06,950 --> 00:29:07,240
是的

609
00:29:07,240 --> 00:29:07,490
好的.

610
00:29:07,490 --> 00:29:09,200
我只是没有初始化它 

611
00:29:09,200 --> 00:29:15,440
我应该在这里把自己设为假的 

612
00:29:15,440 --> 00:29:19,790
如果self.暂停了 我们将测试是否按下了空格 

613
00:29:19,790 --> 00:29:22,910
如果是的话就取消暂停

614
00:29:22,910 --> 00:29:26,360
否则 基本上只是做同样的事情反过来 

615
00:29:26,360 --> 00:29:31,580
如果我们按空格键 暂停游戏 播放声音 等等 

616
00:29:31,580 --> 00:29:34,250
在第39行 我们将调用桨的更新 

617
00:29:34,250 --> 00:29:37,049
记住 测试左输入还是右输入 

618
00:29:37,049 --> 00:29:38,840
在这里我们希望能够逃离游戏 

619
00:29:38,840 --> 00:29:41,060
所以我们会有一个负责逃跑的人

620
00:29:41,060 --> 00:29:45,350
渲染第47行的桨 这将做爱 图形 绘制

621
00:29:45,350 --> 00:29:47,480
和我们之前看到的一样 但它会使用

622
00:29:47,480 --> 00:29:52,160
皮肤和桨大小以索引到四边形瓦片片中

623
00:29:52,160 --> 00:29:54,170
适当地 

624
00:29:54,170 --> 00:29:57,170
然后这里如果我们暂停了 我们就画

625
00:29:57,170 --> 00:30:00,110
屏幕中间的一些文字写着“你好”

626
00:30:00,110 --> 00:30:01,400
我们用大号字体 

627
00:30:01,400 --> 00:30:04,316
所以我们现在可以继续演示 看看所有的东西都在一起 

628
00:30:08,190 --> 00:30:11,260
我们像以前一样有我们的StartState 

629
00:30:11,260 --> 00:30:13,711
但是如果我们按下Enter键 

630
00:30:13,711 --> 00:30:15,960
我们在屏幕底部有一个桨 

631
00:30:15,960 --> 00:30:18,720
是2号 1号皮 

632
00:30:18,720 --> 00:30:19,740
只有蓝色的皮肤 

633
00:30:19,740 --> 00:30:21,895
我们可以像这样左右移动 

634
00:30:21,895 --> 00:30:24,270
如果它击中屏幕的左侧 它会停止 

635
00:30:24,270 --> 00:30:27,130
如果它击中屏幕的右侧 它也会停止 

636
00:30:27,130 --> 00:30:30,180
所以我们已经取得了进展 但这是最基本的事情之一 

637
00:30:30,180 --> 00:30:35,220
我今天要展示的是 就像 使用四元组和分类

638
00:30:35,220 --> 00:30:38,160
他们 组织他们 并能够画出

639
00:30:38,160 --> 00:30:43,860
您的资产来自一个大的汇编图像 而不是跟踪

640
00:30:43,860 --> 00:30:45,742
不管它拍下多少张照片 

641
00:30:45,742 --> 00:30:47,700
你必须将它们全部命名并进行分类 

642
00:30:47,700 --> 00:30:49,270
这只会是一种巨大的痛苦 

643
00:30:49,270 --> 00:30:49,770
所以是的 

644
00:30:49,770 --> 00:30:52,500
当你有不止一个精灵的时候 肯定会继续前进 

645
00:30:52,500 --> 00:30:55,200
你想把它放在一张纸上 

646
00:30:55,200 --> 00:30:57,900
这就是我们实现这一目标的方法 

647
00:30:57,900 --> 00:31:00,030
但我们没有砖头 这很可能是

648
00:31:00,030 --> 00:31:05,380
除了球拍和球之外 突破的另一个主要组成部分 

649
00:31:05,380 --> 00:31:08,710
我们想要的是我们可以在屏幕上真正击中和瞄准的砖块 

650
00:31:08,710 --> 00:31:10,450
因此 此次更新将解决这一问题 

651
00:31:10,450 --> 00:31:16,430
那么让我们继续来看看Breakout2 in Main.Lua 

652
00:31:16,430 --> 00:31:17,670
我要在这里把它打开 

653
00:31:21,740 --> 00:31:29,600
在第66行 您可以看到在我们的GFrame中有一个新的表 

654
00:31:29,600 --> 00:31:32,266
因为我们有一个专门用来划桨的 所以我们就拿出来了

655
00:31:32,266 --> 00:31:33,890
只有我们精灵床单上的球拍 

656
00:31:33,890 --> 00:31:36,056
我们将对蛋蛋做同样的事情 

657
00:31:36,056 --> 00:31:38,070
所以我们要看--如果我们看这里 

658
00:31:38,070 --> 00:31:43,100
我们可以看到 球是在这里的所有砖块之后出现的

659
00:31:43,100 --> 00:31:46,070
它们只是以八个像素宽乘八个像素来布置

660
00:31:46,070 --> 00:31:48,500
像素高的增量在这里 

661
00:31:48,500 --> 00:31:52,070
所以四个像素对应一块砖 四个球对应一块砖 

662
00:31:52,070 --> 00:31:56,610
两个球水平对一 然后垂直两个球 

663
00:31:56,610 --> 00:32:02,360
因此 我们最终要做的只是我们的实用程序中的一个简单函数

664
00:32:02,360 --> 00:32:04,530
我们来看看这一点 

665
00:32:04,530 --> 00:32:08,570
因此 让我们继续查看我们的util.lua 我们已经对其进行了更改 

666
00:32:14,120 --> 00:32:17,810
所以它要做的是做同样的事情

667
00:32:17,810 --> 00:32:20,540
就像我们以前做的那样 

668
00:32:20,540 --> 00:32:21,290
它必须迭代 

669
00:32:21,290 --> 00:32:23,850
所以请注意 我们有两排球 

670
00:32:23,850 --> 00:32:26,030
我们有这四个 我们有这三个 

671
00:32:26,030 --> 00:32:27,606
所以我们想要迭代四次 

672
00:32:27,606 --> 00:32:29,480
你想知道这里的偏移量是多少 

673
00:32:29,480 --> 00:32:35,270
X和Y 所以看起来是3乘以32 然后是3乘以16 

674
00:32:35,270 --> 00:32:36,860
所以96乘以--

675
00:32:36,860 --> 00:32:37,550
我不会做数学 

676
00:32:37,550 --> 00:32:39,110
不管16乘以3是什么 

677
00:32:39,110 --> 00:32:40,700
然后我们就会变成48岁 

678
00:32:40,700 --> 00:32:42,839
然后我们会有--

679
00:32:42,839 --> 00:32:43,880
这就是我们在这里所做的 

680
00:32:43,880 --> 00:32:46,187
所以我们有两次迭代 

681
00:32:46,187 --> 00:32:48,020
所以从零到三的四个循环 

682
00:32:48,020 --> 00:32:51,030
所以最上面的一排 四个 

683
00:32:51,030 --> 00:32:52,990
我们在这里设一个柜台 

684
00:32:52,990 --> 00:32:54,641
还请注意96和48 

685
00:32:54,641 --> 00:32:56,390
这是我们设定的X和Y 

686
00:32:56,390 --> 00:33:01,510
这就是各个球精灵的偏移量 

687
00:33:01,510 --> 00:33:03,710
柜台的四人组--

688
00:33:03,710 --> 00:33:05,330
请注意 四边形还有一张桌子 

689
00:33:05,330 --> 00:33:06,650
我们要把这个退掉 

690
00:33:06,650 --> 00:33:10,630
在柜台的四人组得到了爱 

691
00:33:10,630 --> 00:33:12,230
八个像素宽 八个像素高 

692
00:33:12,230 --> 00:33:13,580
这就是球的大小 

693
00:33:13,580 --> 00:33:17,390
然后我们再加8 因为我们要向右转 

694
00:33:17,390 --> 00:33:20,960
所以这个迭代是从左到右的 

695
00:33:20,960 --> 00:33:25,460
然后在这里 我们将基本上将X设置为96

696
00:33:25,460 --> 00:33:27,900
然后Y变为56 

697
00:33:27,900 --> 00:33:30,350
然后因为我们直接在这里编辑X 

698
00:33:30,350 --> 00:33:33,380
我们希望将X重置为96 但也要添加

699
00:33:33,380 --> 00:33:36,320
8个像素 这样我们就有了下一行的起点

700
00:33:36,320 --> 00:33:38,840
纵向上 56日元也是如此 

701
00:33:38,840 --> 00:33:40,730
在这里做完全相同的事情 但只做

702
00:33:40,730 --> 00:33:43,010
三次 因为回想一下 上面有四个球

703
00:33:43,010 --> 00:33:44,720
然后是底部的三个球 

704
00:33:44,720 --> 00:33:46,280
然后在最后还回来 

705
00:33:46,280 --> 00:33:49,250
所以现在我们只有一张单独的桌子 

706
00:33:49,250 --> 00:33:51,620
我们不需要像一张巨大的四边形餐桌一样 

707
00:33:51,620 --> 00:33:53,360
我觉得这有点杂乱无章 

708
00:33:53,360 --> 00:33:57,950
我们可以只有一张划桨架的桌子 

709
00:33:57,950 --> 00:34:00,110
还有球 还有我们将会看到的砖头 

710
00:34:02,930 --> 00:34:05,311
实际上 我想我把它放在这里了 

711
00:34:05,311 --> 00:34:05,810
也许不会 

712
00:34:08,900 --> 00:34:12,480
所以在舞会上--哦 实际上 等等 

713
00:34:12,480 --> 00:34:12,980
抱歉的 

714
00:34:12,980 --> 00:34:14,030
所以我们在看--

715
00:34:17,540 --> 00:34:19,080
我不小心跳过了这一条 

716
00:34:19,080 --> 00:34:19,955
所以弹跳更新 

717
00:34:19,955 --> 00:34:22,370
所以我刚才说的每件事都是相关的 但我不小心

718
00:34:22,370 --> 00:34:23,840
向右打了两下 

719
00:34:23,840 --> 00:34:27,620
我们想要转到退回更新 因为这稍微简单一些 

720
00:34:27,620 --> 00:34:30,699
所以我们只是在谈论球 这太完美了 

721
00:34:30,699 --> 00:34:33,949
所以我们要拿着球 然后我们要把它添加到场景中 

722
00:34:33,949 --> 00:34:36,980
我们要做的就是从墙上跳起来 

723
00:34:36,980 --> 00:34:39,380
所以实际上 与代码几乎完全相同

724
00:34:39,380 --> 00:34:43,040
我们看到了Pong 你只需要检测球是否有

725
00:34:43,040 --> 00:34:45,985
超出屏幕的左、右或上边缘 

726
00:34:45,985 --> 00:34:48,860
在这种情况下 它还将允许我们转到屏幕底部

727
00:34:48,860 --> 00:34:51,290
我们还将实现与球拍的碰撞

728
00:34:51,290 --> 00:34:54,690
那么 你就可以感受到真正的游戏效果 以及那种感觉 

729
00:34:54,690 --> 00:34:57,920
所以目前一切都是最新的 

730
00:34:57,920 --> 00:34:59,300
所以我们要去--

731
00:34:59,300 --> 00:35:03,712
在谈到实际拿到个人球的功能后

732
00:35:03,712 --> 00:35:05,420
从电子表格中拿出四元组 我们要

733
00:35:05,420 --> 00:35:10,140
来看看球类 它将允许我们在场景中产生它们 

734
00:35:10,140 --> 00:35:12,310
所以球的宽度和高度都是8 

735
00:35:12,310 --> 00:35:13,490
没有速度 

736
00:35:13,490 --> 00:35:17,600
但我们将允许我们自己使用皮肤来初始化球 

737
00:35:17,600 --> 00:35:21,010
我们稍后会看到这是一个可爱的小东西给你

738
00:35:21,010 --> 00:35:24,550
使用实际的单个精灵 而不只是一个恒定的精灵 

739
00:35:24,550 --> 00:35:27,740
我们只会给它一个介于1和7之间的随机数

740
00:35:27,740 --> 00:35:30,110
因为有七个四边形 

741
00:35:30,110 --> 00:35:35,300
然后我们将只使用格框、球和数学点随机数

742
00:35:35,300 --> 00:35:38,657
才能得到我们想要的真正的球面 

743
00:35:38,657 --> 00:35:40,865
所以我们在球内有一个简单的碰撞函数

744
00:35:40,865 --> 00:35:45,290
这将允许我们检查是否与某个物体相撞

745
00:35:45,290 --> 00:35:47,180
它具有X、Y宽度和高度 

746
00:35:47,180 --> 00:35:54,620
所以这是一个简单的A B碰撞检测 

747
00:35:54,620 --> 00:35:56,609
然后在这里我们有重置 

748
00:35:56,609 --> 00:35:58,400
只需将其重置到屏幕中央即可 

749
00:35:58,400 --> 00:35:59,840
更新应用速度 

750
00:35:59,840 --> 00:36:02,420
我们已经看过的东西 

751
00:36:02,420 --> 00:36:05,010
这就是我们真正实现弹离墙壁的地方 

752
00:36:05,010 --> 00:36:07,370
因此 如果X小于或等于零 则大于

753
00:36:07,370 --> 00:36:11,180
或等于虚拟宽度减8 或小于或等于零 

754
00:36:11,180 --> 00:36:14,660
这应该是我们反转速度的地方 

755
00:36:14,660 --> 00:36:18,380
在它从左侧反弹的情况下 我们想要反转X速度

756
00:36:18,380 --> 00:36:19,370
但要继续往上走 

757
00:36:19,370 --> 00:36:21,200
如果它击中顶部 那么我们想要反转

758
00:36:21,200 --> 00:36:24,200
Y速度 以保持它朝任何方向移动 

759
00:36:24,200 --> 00:36:27,620
右手边的墙也是这样 

760
00:36:27,620 --> 00:36:29,150
然后播放一段墙壁上的热门音乐 

761
00:36:29,150 --> 00:36:31,790
我们在今天的节目中融入了这些声音

762
00:36:31,790 --> 00:36:33,420
就因为它们太简单了 

763
00:36:33,420 --> 00:36:35,360
仅仅得到一点反馈也是很好的

764
00:36:35,360 --> 00:36:37,130
当你实际上是游戏的终点时 

765
00:36:37,130 --> 00:36:39,290
这里的绘图代码与此完全相同 

766
00:36:39,290 --> 00:36:43,040
所以我们有主纹理 但现在我们使用的是GFrame球 

767
00:36:43,040 --> 00:36:46,100
然后我们在self.kin上对其进行索引 

768
00:36:46,100 --> 00:36:48,179
回想一下 我们刚刚在这里设置了self.kin 

769
00:36:48,179 --> 00:36:49,970
所以我们要做的就是把它随机

770
00:36:49,970 --> 00:36:53,660
就是在我们创造一个新球的任何地方 给它一个数学运算 

771
00:36:53,660 --> 00:36:57,170
然后 它将索引到那个四元表中

772
00:36:57,170 --> 00:37:01,380
这样我们每次都可以画出不同的球纹理 

773
00:37:01,380 --> 00:37:03,170
所以让我们继续下去 看看--

774
00:37:03,170 --> 00:37:03,890
哦 事实上 不是的 

775
00:37:03,890 --> 00:37:06,320
我们需要关注的最后一件事是PlayState

776
00:37:06,320 --> 00:37:09,471
也有一些新的代码 

777
00:37:09,471 --> 00:37:11,970
我们要生一个球 所以这就是我们要做的 

778
00:37:11,970 --> 00:37:14,886
我不是随机做的 但如果我想的话 我可以在这里随机做 

779
00:37:14,886 --> 00:37:17,297
我可以算术 随机7 而且每次我们启动的时候

780
00:37:17,297 --> 00:37:19,630
这个游戏将会是不同的颜色 因为它

781
00:37:19,630 --> 00:37:22,646
将会是一张不同的皮肤 

782
00:37:22,646 --> 00:37:23,770
我们需要更新一下球 

783
00:37:23,770 --> 00:37:26,500
因此 在第50行 我们只需更新它 就像我们处理划桨一样 

784
00:37:26,500 --> 00:37:29,560
然后在第52行 我们只是测试一下

785
00:37:29,560 --> 00:37:32,661
它是否与球拍相撞 因为我们只用了简单的A 

786
00:37:32,661 --> 00:37:36,790
如果它与球拍相撞 我们就可以假定它正在坠落 

787
00:37:36,790 --> 00:37:38,540
我们可以反转为增量Y 

788
00:37:38,540 --> 00:37:43,030
现在 有谁知道什么可能是当前的问题

789
00:37:43,030 --> 00:37:46,760
该函数的当前实现情况如何？

790
00:37:46,760 --> 00:37:48,880
尤其是这条线 

791
00:37:51,766 --> 00:38:01,284
观众：[听不见]

792
00:38:01,284 --> 00:38:02,200
科尔顿·奥格登：会的 

793
00:38:02,200 --> 00:38:03,283
你走上了正确的道路 

794
00:38:03,283 --> 00:38:06,880
答案是 如果球是从侧面传来的 

795
00:38:06,880 --> 00:38:11,082
它不一定会在正确的Y方向反弹回来 

796
00:38:11,082 --> 00:38:13,540
如果它是从侧面来的 在这种情况下 它总是 

797
00:38:13,540 --> 00:38:15,170
是从上面来的 

798
00:38:15,170 --> 00:38:17,890
因此 在右增量Y中 它总是在倒转 

799
00:38:17,890 --> 00:38:22,090
但如果它以一个角度进入会发生什么

800
00:38:22,090 --> 00:38:28,840
然后基本上不是重置了吗？

801
00:38:28,840 --> 00:38:31,990
就像现在 如果它从一个角度来 它

802
00:38:31,990 --> 00:38:36,640
被抓到了--比方说它就像是在桨的顶端下方 

803
00:38:36,640 --> 00:38:37,840
观众：[听不见]

804
00:38:37,840 --> 00:38:40,352
科尔顿·奥格登：你会有一个无限的碰撞

805
00:38:40,352 --> 00:38:42,310
循环 因为我们没有重置它的位置 

806
00:38:42,310 --> 00:38:44,230
我们只是在更新它的速度 

807
00:38:44,230 --> 00:38:46,630
如果它从侧面以正确的角度进入 

808
00:38:46,630 --> 00:38:50,101
它会卡在球拍里

809
00:38:50,101 --> 00:38:52,600
然后 它会导致一些时髦的行为 

810
00:38:52,600 --> 00:38:55,690
我会试着在我的演示中实现这一点 

811
00:38:55,690 --> 00:38:58,300
但这就是所有这些更新的要点 

812
00:38:58,300 --> 00:39:02,620
因此 如果我们开始 我们可以立即看到我们有一个球 

813
00:39:02,620 --> 00:39:05,999
当它撞到侧面或顶部时 它会相应地反弹 

814
00:39:05,999 --> 00:39:06,790
它击中了球拍 

815
00:39:06,790 --> 00:39:11,420
因此 当它从顶部进入时 它会翻转Y速度 

816
00:39:11,420 --> 00:39:14,620
让我们看看我能不能从这个角度拍到它 

817
00:39:14,620 --> 00:39:15,520
这就是了 

818
00:39:15,520 --> 00:39:17,150
它会卡住的 

819
00:39:17,150 --> 00:39:22,120
所以每当你进行A、A、B、B碰撞检测时 

820
00:39:22,120 --> 00:39:25,810
只要记住总是重置它的位置就行了

821
00:39:25,810 --> 00:39:29,020
它是被碰撞的 正在移动的 所以它不会卡住

822
00:39:29,020 --> 00:39:31,611
一次又一次地被困在别的东西里 

823
00:39:31,611 --> 00:39:32,110
是 

824
00:39:32,110 --> 00:39:42,190
观众：[听不见]

825
00:39:42,190 --> 00:39:45,610
科尔顿·奥格登：问题是我一直在做爱情空间点 

826
00:39:45,610 --> 00:39:50,050
而不是仅仅使用

827
00:39:50,050 --> 00:39:55,030
任何文件的完整路径 为了做到这一点--您也是

828
00:39:55,030 --> 00:39:56,320
在Mac还是Windows机器上？

829
00:39:56,320 --> 00:39:57,450
观众：[听不见]

830
00:39:57,450 --> 00:40:01,780
科尔顿·奥格登：所以在Windows系统上 这就有点棘手了 

831
00:40:01,780 --> 00:40:07,390
但我已经找到了一种非常好的VS代码插件 

832
00:40:07,390 --> 00:40:11,650
因此 如果您使用的是VS Code 这是我使用的编辑器 它有插件

833
00:40:11,650 --> 00:40:14,830
你可以下载的其中一个插件是Love2D

834
00:40:14,830 --> 00:40:19,210
它有一个配置 如果你只需按下Alt L 

835
00:40:19,210 --> 00:40:22,240
它将运行您当前所在目录 

836
00:40:22,240 --> 00:40:24,260
无论你目前参与的是什么项目 

837
00:40:24,260 --> 00:40:25,780
它将呼唤爱 

838
00:40:25,780 --> 00:40:27,470
它会为你把它添加到你的道路上 

839
00:40:27,470 --> 00:40:31,810
因此 如果您想让它工作 请下载VS代码上的Love2D插件 

840
00:40:31,810 --> 00:40:34,990
我在Mac上 所以我可以编辑我的批次配置文件 

841
00:40:34,990 --> 00:40:40,970
并将其别名Love添加到我文件系统中的完整路径 

842
00:40:40,970 --> 00:40:43,880
你也可以做同样的事情--

843
00:40:43,880 --> 00:40:48,280
我不知道Windows在别名方面是如何工作的 

844
00:40:48,280 --> 00:40:52,540
但从本质上讲 这与输入通向爱的整个道路是一样的 

845
00:40:52,540 --> 00:40:55,120
不过 我要换个词 

846
00:40:55,120 --> 00:40:56,790
我要把它改成爱 

847
00:40:56,790 --> 00:40:59,680
所以我将Love设置为应用程序斜杠

848
00:40:59,680 --> 00:41:02,870
Love.app/内容/资源等 

849
00:41:02,870 --> 00:41:04,150
问得好 

850
00:41:04,150 --> 00:41:05,560
我会在Windows上下载 

851
00:41:05,560 --> 00:41:07,720
我是VS Code和Love2D插件的铁杆粉丝 

852
00:41:07,720 --> 00:41:09,427
我建议你调查一下这个问题 

853
00:41:09,427 --> 00:41:12,010
我相信还有其他插件 还有一个页面

854
00:41:12,010 --> 00:41:13,611
在网站上--

855
00:41:13,611 --> 00:41:15,360
我目前没有打开浏览器 

856
00:41:15,360 --> 00:41:19,330
但在维基上 你可以看到入门页面 

857
00:41:19,330 --> 00:41:21,606
我相信这就像是love2d.com/wiki/gettingstarted 

858
00:41:21,606 --> 00:41:23,980
他们有一堆不同操作的说明

859
00:41:23,980 --> 00:41:26,521
允许您进行排序的系统和不同的文本编辑器

860
00:41:26,521 --> 00:41:29,750
更高效的工作流程 

861
00:41:29,750 --> 00:41:34,590
还有其他问题吗？

862
00:41:34,590 --> 00:41:35,580
好的 

863
00:41:35,580 --> 00:41:38,130
所以我们做了弹跳更新 

864
00:41:38,130 --> 00:41:40,780
现在我们终于可以编辑砖块了 

865
00:41:40,780 --> 00:41:42,420
我要说的是 再加上砖头 

866
00:41:42,420 --> 00:41:44,880
所以这些都很简单 

867
00:41:44,880 --> 00:41:47,264
所以我们要来看看它 

868
00:41:47,264 --> 00:41:50,430
现在我们不会做任何花哨的程序世代 

869
00:41:50,430 --> 00:41:52,980
我们只是要在屏幕上放几块砖 

870
00:41:52,980 --> 00:41:55,509
只是一些简单的砖块 

871
00:41:55,509 --> 00:41:58,050
或者更确切地说 我们将得到一些非常基本的程序性生成 

872
00:41:58,050 --> 00:41:59,758
但不会达到我们很快就会看到的水平 

873
00:41:59,758 --> 00:42:01,660
我们很快就会看到这一点 

874
00:42:01,660 --> 00:42:02,160
好的 

875
00:42:02,160 --> 00:42:05,940
所以我要进入我的主 Lua在这里 

876
00:42:05,940 --> 00:42:08,400
我要进入《越狱3》 

877
00:42:12,250 --> 00:42:15,310
和我们之前在第67行做的相同的事情 

878
00:42:15,310 --> 00:42:19,920
我们的框架里只有一张新的砖桌 

879
00:42:19,920 --> 00:42:21,640
它只会产生四边形的砖块 

880
00:42:21,640 --> 00:42:25,840
我们从util.lua调用 所以我们也可以快速查看它 

881
00:42:25,840 --> 00:42:28,270
这个其实很简单 

882
00:42:28,270 --> 00:42:30,310
Sourceutil.Lua

883
00:42:30,310 --> 00:42:33,790
因为它们从屏幕的最顶端开始 

884
00:42:33,790 --> 00:42:37,720
我们可以假设--我们可以有效地

885
00:42:37,720 --> 00:42:40,270
把这整件事当做是这些

886
00:42:40,270 --> 00:42:43,720
并且只生成宽度和高度恒定的四边形

887
00:42:43,720 --> 00:42:47,530
因为 实际上 我们只需要正在生成的帧的一个子集 

888
00:42:47,530 --> 00:42:52,130
因为它是这样产生它们的 从上到下 从左到右 

889
00:42:52,130 --> 00:42:55,500
我们可以一直抓取到这里 用

890
00:42:55,500 --> 00:42:59,020
表 切片 我们之前看到的 而不是

891
00:42:59,020 --> 00:43:01,720
担心索引到任何奇怪的 比如 

892
00:43:01,720 --> 00:43:04,450
具有需要按顺序编制索引的任何常量X和Y

893
00:43:04,450 --> 00:43:05,620
以获得补偿 

894
00:43:05,620 --> 00:43:07,730
我们可以做一个非常简单的--

895
00:43:07,730 --> 00:43:15,460
如果我们往下到第57行 生成四块砖 它只做一张表 切片 

896
00:43:15,460 --> 00:43:19,400
在此基础上 我们将生成四元地图集32 16 

897
00:43:19,400 --> 00:43:23,440
这将产生将我们的精灵工作表除以32的效果

898
00:43:23,440 --> 00:43:24,730
以16块为单位 

899
00:43:24,730 --> 00:43:27,010
它会很好地产生所有这些 

900
00:43:27,010 --> 00:43:30,076
但它会在这里 这里有四个四边形

901
00:43:30,076 --> 00:43:32,200
与你在这里看到的四边形不对齐

902
00:43:32,200 --> 00:43:36,889
因为它只是盲目地假设那张纸上的所有精灵

903
00:43:36,889 --> 00:43:38,930
都是一样的大小 因为这就是我们要做的 

904
00:43:38,930 --> 00:43:41,410
我们只是调用生成四元组 如果您还记得的话 

905
00:43:41,410 --> 00:43:46,300
只是在我们的整个地图集中生成固定大小的宽度和高度 

906
00:43:46,300 --> 00:43:49,290
这对于许多对称的床单来说是很棒的 

907
00:43:49,290 --> 00:43:52,270
但在某些情况下 比如在这里 

908
00:43:52,270 --> 00:43:53,929
我们的电子表格是不对称的 

909
00:43:53,929 --> 00:43:55,720
我们有不同大小的球拍 我们有

910
00:43:55,720 --> 00:43:58,011
八乘八的球 我们有砖头 

911
00:43:58,011 --> 00:44:01,840
我们在底部有其他加电装置 

912
00:44:01,840 --> 00:44:05,920
但生成的四边形砖块占据了那张桌子

913
00:44:05,920 --> 00:44:08,769
我们正在生成的 这将是一堆帧

914
00:44:08,769 --> 00:44:09,560
这是我们不想要的 

915
00:44:09,560 --> 00:44:11,650
他们中的许多人剪掉了 一半剪掉了 

916
00:44:11,650 --> 00:44:14,120
然后我们就把它从1变为21 

917
00:44:14,120 --> 00:44:18,500
当我们这样做的时候 1到21实际上是--这就是这些

918
00:44:18,500 --> 00:44:19,000
确实有 

919
00:44:19,000 --> 00:44:22,270
所以是18 然后是1 2 3 

920
00:44:22,270 --> 00:44:24,434
所以从1到21 所有这些都是 

921
00:44:24,434 --> 00:44:25,600
这将是所有的砖 

922
00:44:25,600 --> 00:44:28,270
我们可以扔掉所有剩下的四边形

923
00:44:28,270 --> 00:44:33,310
然后盲目地假设它们都是一样大小的 

924
00:44:36,450 --> 00:44:41,090
那么 对于四元组如何工作或这些桌子是如何工作的 有什么问题吗？

925
00:44:41,090 --> 00:44:41,590
好的 

926
00:44:44,075 --> 00:44:45,200
所以我们要继续下去 

927
00:44:45,200 --> 00:44:47,200
我们现在有一个新的班级 布里克·卢亚 

928
00:44:49,750 --> 00:44:52,600
如此简单的积木 

929
00:44:52,600 --> 00:44:57,160
在第30行的brick.lua中 我们有一面名为in play的旗帜 

930
00:44:57,160 --> 00:44:58,574
自我陶醉成真 

931
00:44:58,574 --> 00:45:00,490
所以我们只需要用这个来渲染 

932
00:45:00,490 --> 00:45:02,800
我们只想说 如果它在起作用 就渲染它 

933
00:45:02,800 --> 00:45:04,160
如果不是 则不要呈现它 

934
00:45:04,160 --> 00:45:04,869
就这么简单 

935
00:45:04,869 --> 00:45:08,035
这样我们就不必担心对象重新分配或任何花哨的事情了 

936
00:45:08,035 --> 00:45:10,270
我们已经准备好了所有的砖块 以及它是否正在发挥作用

937
00:45:10,270 --> 00:45:12,310
或者不是 呈现它或执行更新逻辑 

938
00:45:12,310 --> 00:45:14,980
如果它不存在 就假装它不存在 

939
00:45:14,980 --> 00:45:17,560
忽略它就好 

940
00:45:17,560 --> 00:45:21,220
我们只会有30人 或者我不知道有多少人 

941
00:45:21,220 --> 00:45:26,860
在我们的场景中 一次最多13 x 4块砖 所以担心内存释放

942
00:45:26,860 --> 00:45:28,070
其实并不是什么问题 

943
00:45:28,070 --> 00:45:34,150
但是如果你有一百万种不同的东西一直在产生 

944
00:45:34,150 --> 00:45:37,480
在游戏中拥有简单可能并不总是错误的

945
00:45:37,480 --> 00:45:40,730
这是可行的 因为您需要存储所有这些对象的所有内存 

946
00:45:40,730 --> 00:45:44,920
所以这里只是一条捷径 但不一定是最好的

947
00:45:44,920 --> 00:45:47,080
为大型比赛做练习 

948
00:45:47,080 --> 00:45:49,870
但对于小游戏来说 这无疑是既好又简单的 

949
00:45:53,340 --> 00:45:56,350
在第37行 我们定义了一个名为Brick Hit的函数 

950
00:45:56,350 --> 00:46:00,520
所有这些都只是播放音效 并将其设置为假 

951
00:46:00,520 --> 00:46:03,430
所以我们要做的就是检查

952
00:46:03,430 --> 00:46:06,940
来查看是否存在冲突 然后调用此Hit函数 

953
00:46:06,940 --> 00:46:10,990
播放一个声音 然后假装它不再存在 

954
00:46:10,990 --> 00:46:15,010
然后渲染 渲染所做的就是如果它正在播放 检查正在播放的标志 

955
00:46:15,010 --> 00:46:23,425
在砖块处绘制Main 或使用我们创建的砖桌 

956
00:46:23,425 --> 00:46:25,300
然后我们从一点开始 然后

957
00:46:25,300 --> 00:46:30,020
我们将根据我们的颜色减去1乘以4来索引它 

958
00:46:30,020 --> 00:46:31,630
然后我们要添加它的层 

959
00:46:31,630 --> 00:46:36,490
所以 如果你还记得的话 有一 二 三 四 

960
00:46:36,490 --> 00:46:41,380
五种颜色 四个层次 

961
00:46:41,380 --> 00:46:44,380
所以我们要做的是在不同的颜色之间跳跃 

962
00:46:44,380 --> 00:46:49,840
所以我们会得到值1 值2 值3 值4 值5 

963
00:46:49,840 --> 00:46:52,450
这将是我们的前五个 或者我想是六个 

964
00:46:52,450 --> 00:46:55,690
这将是我们的头六块砖 

965
00:46:55,690 --> 00:46:59,099
然后我们将开始一 二 三--或者我们将添加 

966
00:46:59,099 --> 00:47:00,640
我们基本上会有一个层次 

967
00:47:00,640 --> 00:47:04,030
可能是一、二、三或四 

968
00:47:04,030 --> 00:47:07,780
如果是在第一级 那么我们可以添加--

969
00:47:07,780 --> 00:47:10,000
基本上是索引到我们所在的任何一层 

970
00:47:10,000 --> 00:47:13,870
无论我们的索引是什么 我们只需添加减一级即可 

971
00:47:13,870 --> 00:47:17,050
所以在这里 如果我们的层是一层 那么我们只想渲染这个块 

972
00:47:17,050 --> 00:47:18,550
我们不想去下一家 

973
00:47:18,550 --> 00:47:20,299
所以我们就说一级减去一级 

974
00:47:20,299 --> 00:47:22,250
我们将添加--

975
00:47:22,250 --> 00:47:23,922
所以一减一等于零 

976
00:47:23,922 --> 00:47:25,630
所以我们从零开始 明白这一点 

977
00:47:25,630 --> 00:47:29,860
但如果是第二级 我们会增加一级、二级和三级 

978
00:47:29,860 --> 00:47:34,750
然后我们只需将我们想要的任何砖乘以我们的颜色 

979
00:47:34,750 --> 00:47:40,540
将它乘以4 就可以得到我们实际颜色的偏移量 

980
00:47:40,540 --> 00:47:43,210
所以我们选择我们的颜色 找出它在床单上的位置 

981
00:47:43,210 --> 00:47:46,180
然后只需将我们的层添加到其中 以便为其编制索引

982
00:47:46,180 --> 00:47:49,580
添加到我们的电子表格中 

983
00:47:49,580 --> 00:47:52,900
这就是数学所要做的 

984
00:47:52,900 --> 00:47:56,285
如果我们回到PlayState--

985
00:48:02,050 --> 00:48:04,880
我要开始走得更快一点

986
00:48:04,880 --> 00:48:06,590
这样我们就能跟上进度了 

987
00:48:06,590 --> 00:48:10,700
但在我们的PlayState中 我们在这里注意到一件事 

988
00:48:10,700 --> 00:48:13,820
我们看到了一个名为Level Maker的新班级 

989
00:48:13,820 --> 00:48:15,530
这是一个名为createmap的函数 

990
00:48:15,530 --> 00:48:17,930
我们将去掉所有产生我们的关卡的逻辑

991
00:48:17,930 --> 00:48:19,370
我们只需要把它放在一个地方 

992
00:48:19,370 --> 00:48:20,911
我们要给那个关卡制造者打电话 

993
00:48:20,911 --> 00:48:24,170
而不是在我们不同的州 也许

994
00:48:24,170 --> 00:48:26,630
生成像PlayState或I一样的积木

995
00:48:26,630 --> 00:48:30,680
我猜应该是ServeState VictoryState 

996
00:48:30,680 --> 00:48:33,470
我猜 而不是产生所有的砖

997
00:48:33,470 --> 00:48:37,610
在其固有代码状态下 让我们创建一个关卡标记器

998
00:48:37,610 --> 00:48:41,750
我们可以说 好的 把砖放到平地上 创建地图 

999
00:48:41,750 --> 00:48:46,840
这将返回一张桌子的砖块 

1000
00:48:46,840 --> 00:48:51,110
抱歉 逻辑和我们之前看到的一样 

1001
00:48:51,110 --> 00:48:53,510
在本例中 我们将迭代k Brick

1002
00:48:53,510 --> 00:48:57,050
成对的自家的砖块 

1003
00:48:57,050 --> 00:49:00,710
如果砖块在比赛中发生碰撞 如果球与之相撞 

1004
00:49:00,710 --> 00:49:02,730
然后击打它 这将使它不再发挥作用 

1005
00:49:02,730 --> 00:49:08,030
很简单的A A B B 

1006
00:49:08,030 --> 00:49:10,550
最后 我们这里有我们的呈现逻辑 

1007
00:49:10,550 --> 00:49:13,805
它会把那张砖头桌子拿来 然后迭代 

1008
00:49:13,805 --> 00:49:15,680
我们最不应该看到的就是

1009
00:49:15,680 --> 00:49:18,921
是真正的关卡制造者本身 在这种情况下很简单 

1010
00:49:18,921 --> 00:49:21,920
但我们稍后会看到 它会变得更复杂 

1011
00:49:21,920 --> 00:49:26,516
当我们有一个更详细的程序性生成方法来处理我们的级别时 

1012
00:49:26,516 --> 00:49:29,390
但现在 我们只需要在这里设置两个随机变量 

1013
00:49:29,390 --> 00:49:31,040
行数和列数 

1014
00:49:31,040 --> 00:49:37,670
然后对于每行或基本上每行和每列 

1015
00:49:37,670 --> 00:49:40,280
创建一块新砖 

1016
00:49:40,280 --> 00:49:41,810
然后这里有一些数学问题 

1017
00:49:41,810 --> 00:49:43,934
我会略读一下 但基本上

1018
00:49:43,934 --> 00:49:46,970
计算砖块的位置 然后给我们

1019
00:49:46,970 --> 00:49:50,510
两边各有八个像素的填充 

1020
00:49:50,510 --> 00:49:53,145
然后根据它的数量 它需要将所有

1021
00:49:53,145 --> 00:49:55,520
然后把砖向左移动一定的量

1022
00:49:55,520 --> 00:49:57,080
然后开始把它们都画出来 

1023
00:49:57,080 --> 00:49:59,270
这就是这段代码在这里的基本功能 

1024
00:49:59,270 --> 00:50:01,580
所以计算中心 

1025
00:50:01,580 --> 00:50:03,680
我在这里的评论中写下了 但我要去

1026
00:50:03,680 --> 00:50:05,600
只是暂时不去想它

1027
00:50:05,600 --> 00:50:08,330
但实际上 把所有的砖块放在中间 

1028
00:50:08,330 --> 00:50:12,380
基本上计算什么样的偏移量在X轴上你需要把所有的人

1029
00:50:12,380 --> 00:50:16,850
让它们看起来居中 然后把它们都画出来 

1030
00:50:16,850 --> 00:50:20,630
这就是水平仪制造者课程的内容 

1031
00:50:20,630 --> 00:50:24,800
所以简单的行数和列数 然后用砖块填满一个表

1032
00:50:24,800 --> 00:50:28,392
但是把它们的X设为我们需要的

1033
00:50:28,392 --> 00:50:29,850
当他们都被拉出来的时候 

1034
00:50:29,850 --> 00:50:32,850
所以我们需要计算 我们需要基本上把我们的列数

1035
00:50:32,850 --> 00:50:34,430
在我们这样做的时候 

1036
00:50:34,430 --> 00:50:43,560
然后如果我们进入Breakout3并运行它 我们就有了砖块 

1037
00:50:43,560 --> 00:50:47,130
它们会被撞上 一旦它们被撞上 

1038
00:50:47,130 --> 00:50:51,390
碰撞在这些砖块中的每一个都被设置为假

1039
00:50:51,390 --> 00:50:52,770
它们不再被渲染 

1040
00:50:52,770 --> 00:50:55,830
它们不再更新碰撞方面 

1041
00:50:55,830 --> 00:50:58,470
现在 我们仍然有问题的球没有得到重置 

1042
00:50:58,470 --> 00:50:59,140
我们会解决的 

1043
00:50:59,140 --> 00:51:01,034
很容易搞定 

1044
00:51:01,034 --> 00:51:02,200
但我们已经走了很远了 

1045
00:51:02,200 --> 00:51:04,880
我们的进展相当快 

1046
00:51:04,880 --> 00:51:08,039
我将继续前进 并移动到下一个代码位 

1047
00:51:08,039 --> 00:51:09,330
这是另一段代码 

1048
00:51:09,330 --> 00:51:12,450
我会在这里稍微忽略一些细节 

1049
00:51:12,450 --> 00:51:16,380
但在高层次上 我们需要做的是 

1050
00:51:16,380 --> 00:51:18,840
来检测我们是否撞上了一块砖头

1051
00:51:18,840 --> 00:51:21,990
但在《越狱》里 球会从砖块上弹开

1052
00:51:21,990 --> 00:51:23,580
这取决于它击中的是哪一边 

1053
00:51:23,580 --> 00:51:27,780
我们不能仅仅根据碰撞就知道这一点 

1054
00:51:27,780 --> 00:51:29,920
我们只知道碰撞是真是假 

1055
00:51:29,920 --> 00:51:34,260
我们不知道它从哪里来 也不知道它与多少物体相撞 

1056
00:51:34,260 --> 00:51:37,860
然后我们还要固定我们的桨 

1057
00:51:37,860 --> 00:51:40,790
目前它所做的只是否定Y速度 

1058
00:51:40,790 --> 00:51:43,230
但我们想增加一点变化

1059
00:51:43,230 --> 00:51:47,895
当我们打球的时候 

1060
00:51:47,895 --> 00:51:50,190
这样我们就能制定一点策略

1061
00:51:50,190 --> 00:51:51,550
给我们自己一点游戏的机会 

1062
00:51:51,550 --> 00:51:54,300
所以 如果我们向右移动 我们碰到了水坑的右边

1063
00:51:54,300 --> 00:51:56,800
有了球 它可能会朝着更锋利的方向前进 

1064
00:51:56,800 --> 00:51:58,330
左边也是一样 

1065
00:51:58,330 --> 00:52:01,320
而我们可以通过选择中间部分来有效地做到这一点 

1066
00:52:01,320 --> 00:52:03,630
计算出它离中心有多远 

1067
00:52:03,630 --> 00:52:08,430
然后在负或正的方向上放大我们的增量X

1068
00:52:08,430 --> 00:52:09,510
在此基础上 

1069
00:52:09,510 --> 00:52:13,390
而这会导致这种情况的发生 

1070
00:52:13,390 --> 00:52:18,090
所以在这里我们可以看到我们的球有点像是在划桨 

1071
00:52:18,090 --> 00:52:21,270
让我们假设球拍正在向左移动 

1072
00:52:21,270 --> 00:52:24,930
在这种情况下 无论球离中心有多远 

1073
00:52:24,930 --> 00:52:27,390
我们希望按一定的比例进行调整 然后

1074
00:52:27,390 --> 00:52:32,970
最终使它成为负的增量X 因为这实际上是

1075
00:52:32,970 --> 00:52:34,650
这个游戏通常是怎么运作的 

1076
00:52:34,650 --> 00:52:36,692
如果你把球拍向左或向右移动 

1077
00:52:36,692 --> 00:52:39,150
在拐角或其他什么地方击球 给它一个尖锐的角度 

1078
00:52:39,150 --> 00:52:41,108
而这实际上就是尖锐的角度 

1079
00:52:41,108 --> 00:52:44,350
它只是一个很强的增量X 并且它被放大得越大 

1080
00:52:44,350 --> 00:52:47,040
所以基本上就是把这个 乘以某个数值 

1081
00:52:47,040 --> 00:52:50,220
然后在你的DX上设置为负值或正值 

1082
00:52:50,220 --> 00:52:56,730
这就是你的划桨碰撞V2 

1083
00:52:56,730 --> 00:53:00,630
砖块碰撞有点--

1084
00:53:00,630 --> 00:53:03,340
这很简单 但有点复杂 

1085
00:53:03,340 --> 00:53:06,900
基本上 我们需要做的就是检查一下 看看球的哪边

1086
00:53:06,900 --> 00:53:09,630
不在砖头里面 

1087
00:53:09,630 --> 00:53:12,000
所以如果左边的边缘--我们也可以

1088
00:53:12,000 --> 00:53:13,290
稍微简化一下 

1089
00:53:13,290 --> 00:53:15,500
如果左边--就像你在这里看到的伪代码--

1090
00:53:15,500 --> 00:53:20,140
如果球的左边缘在砖外并且DX为正 

1091
00:53:20,140 --> 00:53:22,440
然后我们可以说 哦 我们基本上可以假设

1092
00:53:22,440 --> 00:53:25,590
我们是从左边进来的 所以我们应该

1093
00:53:25,590 --> 00:53:30,120
在左侧朝相反的Y方向行驶 

1094
00:53:30,120 --> 00:53:35,310
或者很抱歉 我们应该朝同一个Y方向前进 但要取消我们的增量

1095
00:53:35,310 --> 00:53:38,730
因为我们是从左边进来的 

1096
00:53:38,730 --> 00:53:42,907
左边在砖块外面 所以把它弹回来 

1097
00:53:42,907 --> 00:53:44,490
同样的道理也适用于右边 

1098
00:53:44,490 --> 00:53:48,300
我们只做这个测试 球的左边 如果dx是正数 

1099
00:53:48,300 --> 00:53:50,130
因为如果DX是负值 就不可能

1100
00:53:50,130 --> 00:53:52,590
球撞到了我们的砖的左侧 

1101
00:53:52,590 --> 00:53:54,379
所以我们可以有效地走捷径 

1102
00:53:54,379 --> 00:53:56,670
我们在这里做同样的逻辑 只是在正确的边缘

1103
00:53:56,670 --> 00:53:59,460
而不是左边的边缘 

1104
00:53:59,460 --> 00:54:01,230
如果这些都不成立 我们就会

1105
00:54:01,230 --> 00:54:06,570
去看看球的顶边是否在砖头的顶边之上 

1106
00:54:06,570 --> 00:54:09,290
如果是这样的话 我们知道我们是从顶端开始的 

1107
00:54:09,290 --> 00:54:10,740
我们可以触发顶部碰撞 

1108
00:54:10,740 --> 00:54:12,600
如果这些都不成立 我们知道

1109
00:54:12,600 --> 00:54:14,970
我们发生了某种碰撞 

1110
00:54:14,970 --> 00:54:18,440
我们可以只登记一次底部碰撞 

1111
00:54:18,440 --> 00:54:23,130
所以这是这个排序的一个简单版本

1112
00:54:23,130 --> 00:54:25,290
做突破碰撞的方式 

1113
00:54:25,290 --> 00:54:27,604
它在弯道方面有一些缺陷 

1114
00:54:27,604 --> 00:54:29,520
有时弯道可能有点挑剔 

1115
00:54:29,520 --> 00:54:31,680
但我要说的是 它99%的情况下都是有效的 

1116
00:54:31,680 --> 00:54:37,170
要获得一个更健壮、更好的示例 我将查看以下URL

1117
00:54:37,170 --> 00:54:40,050
这是因为他也陷入了全面的崩溃

1118
00:54:40,050 --> 00:54:43,230
他将如何实施阿卡诺德 这是同样的事情有效地

1119
00:54:43,230 --> 00:54:46,050
如果你只是想从另一个角度看它 那就作为突破口 

1120
00:54:46,050 --> 00:54:50,220
但基本上 他的解决方案包括取X和Y的多少

1121
00:54:50,220 --> 00:54:54,570
在砖块相对于球的不同点上有所不同 

1122
00:54:54,570 --> 00:54:58,680
我相信他也把球当做一个有中心点的真正的球 

1123
00:54:58,680 --> 00:55:04,420
尽管他把它渲染成了一个长方形 

1124
00:55:04,420 --> 00:55:05,820
所以它更坚固了一点 

1125
00:55:05,820 --> 00:55:09,090
我决定以一种更简单的方式实现它 我将展示这一点 

1126
00:55:09,090 --> 00:55:12,240
这就是我演示的方式 因为它工作得很好

1127
00:55:12,240 --> 00:55:15,600
这并不是太多的代码 几乎看不出来 

1128
00:55:15,600 --> 00:55:17,580
但我鼓励你去看看这一点 

1129
00:55:17,580 --> 00:55:19,860
我们将在《突破4》中看看我们的PlayState 

1130
00:55:26,880 --> 00:55:28,965
在我们的PlayState中 我们将看到--

1131
00:55:32,560 --> 00:55:33,460
抱歉的 

1132
00:55:33,460 --> 00:55:35,470
65行 

1133
00:55:35,470 --> 00:55:43,830
这就是影响球的增量X的实际球拍代码 

1134
00:55:43,830 --> 00:55:53,700
所以基本上 如果球x小于球桨x加上它的宽度

1135
00:55:53,700 --> 00:55:58,500
两个人 所以基本上在划桨的左边 

1136
00:55:58,500 --> 00:56:02,040
划桨的增量X小于零 这意味着它在向左移动--

1137
00:56:02,040 --> 00:56:04,956
因为我们真的不想影响它 如果我们只是

1138
00:56:04,956 --> 00:56:05,889
原地踏步--

1139
00:56:05,889 --> 00:56:07,680
我们要做我之前描述过的事情 

1140
00:56:07,680 --> 00:56:11,490
我们要给它一些定标器 比如一些起始值 

1141
00:56:11,490 --> 00:56:15,210
在这种情况下 负50只是在某种程度上播种 给它

1142
00:56:15,210 --> 00:56:18,090
某种初值 

1143
00:56:18,090 --> 00:56:24,470
然后我们只需从中点减去球的X 

1144
00:56:24,470 --> 00:56:26,892
这是划桨的中点

1145
00:56:26,892 --> 00:56:28,350
然后再乘以8 

1146
00:56:28,350 --> 00:56:31,980
所以不管球的X和中间有什么不同

1147
00:56:31,980 --> 00:56:34,080
划桨的数乘以八 

1148
00:56:34,080 --> 00:56:36,720
把它加到负50 然后再求反 

1149
00:56:36,720 --> 00:56:40,560
同时否定该整数值 从而使整个整数值变为负值 

1150
00:56:40,560 --> 00:56:44,880
因此 我们得到了更清晰的增量X 这取决于哪个角度

1151
00:56:44,880 --> 00:56:46,980
它正在到来 也是以多快的速度--

1152
00:56:46,980 --> 00:56:50,250
或者不是速度有多快 而是我们是否在向左移动 

1153
00:56:50,250 --> 00:56:53,970
右边也是一样的东西 

1154
00:56:53,970 --> 00:56:58,050
只是因为我们要学这个数学 这个self.paddle.x

1155
00:56:58,050 --> 00:57:02,655
加上自拍宽度除以2减去球宽x 

1156
00:57:02,655 --> 00:57:05,320
Ball.x不会大于那个点 

1157
00:57:05,320 --> 00:57:07,360
所以这个值实际上是负值 

1158
00:57:07,360 --> 00:57:09,660
所以我们只需要用Math.abs来证明这一点 

1159
00:57:09,660 --> 00:57:10,730
所以绝对值 

1160
00:57:10,730 --> 00:57:12,330
只是一个Lua函数 

1161
00:57:12,330 --> 00:57:14,820
所以球与球之间的差值的绝对值

1162
00:57:14,820 --> 00:57:19,530
X和中间点乘以8 加到50 

1163
00:57:19,530 --> 00:57:23,580
这将给我们一个正值 它的大小取决于

1164
00:57:23,580 --> 00:57:27,030
我们打到了中间 我们打到了桨的右边

1165
00:57:27,030 --> 00:57:28,700
正在向右移动 

1166
00:57:28,700 --> 00:57:33,450
所以 简而言之 这就是我们如何让碰撞与划桨一起工作

1167
00:57:33,450 --> 00:57:36,630
以及我们如何将增量X调整得更大一些

1168
00:57:36,630 --> 00:57:40,920
而不只是一个常量 你知道的 负数或其他什么

1169
00:57:40,920 --> 00:57:43,020
它是当前的x 但是是负的dy 

1170
00:57:43,020 --> 00:57:45,900
稍微复杂一点 

1171
00:57:45,900 --> 00:57:50,610
然后是砖块的实际碰撞代码

1172
00:57:50,610 --> 00:57:53,110
它们将在这里的for循环中发生 

1173
00:57:53,110 --> 00:57:58,270
因此 如果它在比赛中 如果球与它相撞 就击打它 

1174
00:57:58,270 --> 00:57:59,640
所以我加了加二 

1175
00:57:59,640 --> 00:58:05,520
所以数学的要点是 如果bal.x小于brick.x

1176
00:58:05,520 --> 00:58:09,300
球向右移动 self.ball.dx大于零 

1177
00:58:09,300 --> 00:58:10,590
然后将其翻转为X速度 

1178
00:58:10,590 --> 00:58:11,850
所以把它弹到左边 

1179
00:58:11,850 --> 00:58:13,560
这张支票就是这么回事 

1180
00:58:13,560 --> 00:58:15,785
但它在角球上打得有点粗糙

1181
00:58:15,785 --> 00:58:17,910
因为从理论上讲 你可以进入一个

1182
00:58:17,910 --> 00:58:21,900
你以一个角度进入 它是相交的

1183
00:58:21,900 --> 00:58:29,190
将球拍放在两个位置 都在顶部和左侧

1184
00:58:29,190 --> 00:58:30,930
或者在底部和左边 

1185
00:58:30,930 --> 00:58:36,780
因此 在这种情况下 添加两个将确定命中的Y的优先顺序 

1186
00:58:36,780 --> 00:58:42,690
所以它基本上是从球的展开式到X加2的检查 

1187
00:58:42,690 --> 00:58:48,210
因此 它最终修复了一些角落 但它的要点是

1188
00:58:48,210 --> 00:58:50,810
只需检查Ball.x是否小于brick.x 

1189
00:58:50,810 --> 00:58:55,680
如果是这样 并且我们检测到了碰撞 我们可以将其弹回 

1190
00:58:55,680 --> 00:58:59,670
在没有加上这个加二的情况下 有一些微妙的角落问题 

1191
00:58:59,670 --> 00:59:01,500
所以我们加上了这一点 

1192
00:59:01,500 --> 00:59:04,190
然后在这里反转速度 

1193
00:59:04,190 --> 00:59:05,156
哦 这个班次 

1194
00:59:05,156 --> 00:59:07,530
这就是我们之前谈到的确保

1195
00:59:07,530 --> 00:59:09,570
当你做碰撞时 移动任何

1196
00:59:09,570 --> 00:59:12,870
走出你正在碰撞的任何东西的界限 

1197
00:59:12,870 --> 00:59:19,010
因此 self.ball.x得到的是brick.x减去8 因为球有8个像素宽 

1198
00:59:19,010 --> 00:59:23,070
为了获得更好的风格 它实际上应该是self.ball 

1199
00:59:23,070 --> 00:59:26,651
但这就是它本质上要转化为的 

1200
00:59:26,651 --> 00:59:27,900
右边的边缘也是这样 

1201
00:59:27,900 --> 00:59:29,850
正六是因为它在右边 

1202
00:59:29,850 --> 00:59:34,080
所以如果我们在左边 它实际上和负2是一样的 

1203
00:59:34,080 --> 00:59:39,540
只是一种修复转角的方法 转角的奇怪问题 

1204
00:59:39,540 --> 00:59:44,970
但检查一下 基本上球是不是加上它的高度减2

1205
00:59:44,970 --> 00:59:51,630
大于砖块加X加砖块宽度 这意味着 

1206
00:59:51,630 --> 00:59:55,560
哦 我们撞到了屏幕的右边 砖头的右边 

1207
00:59:55,560 --> 00:59:58,530
然后如果Y小于砖块Y 

1208
00:59:58,530 --> 01:00:00,980
然后我们撞上了砖头的顶部 

1209
01:00:00,980 --> 01:00:03,420
否则 我们就撞到了底部 

1210
01:00:03,420 --> 01:00:06,780
对于顶部和底部 只要做我们对增量X所做的相同的事情 

1211
01:00:06,780 --> 01:00:09,030
但对Delta Y进行此操作 但您仍在重新设置它 

1212
01:00:09,030 --> 01:00:11,580
因此 Ball.y得到brick.y减去8 

1213
01:00:11,580 --> 01:00:17,130
Ball.y得到brick.y加16 因为球拍或单独的砖

1214
01:00:17,130 --> 01:00:21,120
有16个像素高 

1215
01:00:21,120 --> 01:00:24,810
这就是碰撞检测的要点 

1216
01:00:24,810 --> 01:00:27,840
然后如果我们真的--哦 还有一件事 我最终

1217
01:00:27,840 --> 01:00:30,600
把它放在这里只是为了让它更有趣一些 

1218
01:00:30,600 --> 01:00:33,960
这也与更复杂的碰撞检测有关 

1219
01:00:33,960 --> 01:00:38,015
如果你的速度太快 很多时候它会跳过物体 

1220
01:00:38,015 --> 01:00:40,890
这就给这些碰撞检测带来了很多问题

1221
01:00:40,890 --> 01:00:44,520
这些函数通常在数学上是非常正确的

1222
01:00:44,520 --> 01:00:45,480
它们工作得很好 

1223
01:00:45,480 --> 01:00:47,370
当它跳过什么时 它们就不能很好地工作

1224
01:00:47,370 --> 01:00:49,260
你实际上正试图与之相撞 

1225
01:00:49,260 --> 01:00:53,970
这个问题的解决方案超出了本例的范围 但是

1226
01:00:53,970 --> 01:00:57,600
我们在想 可能是在倒退到一定程度

1227
01:00:57,600 --> 01:00:59,790
时间 一定的像素量 

1228
01:00:59,790 --> 01:01:04,380
也许可以从你的球所在的地方开始 

1229
01:01:04,380 --> 01:01:08,100
在最后一帧上 然后只需将其宽度和高度添加到其自身

1230
01:01:08,100 --> 01:01:12,480
直到它与某物相撞 直到它到达当前的增量X

1231
01:01:12,480 --> 01:01:15,380
或者Y增量加上它的位置 

1232
01:01:15,380 --> 01:01:16,380
这是一种方法 

1233
01:01:16,380 --> 01:01:18,817
就像是添加了一堆看不见的--

1234
01:01:18,817 --> 01:01:21,650
无论你撞上的是什么 或者你用来碰撞的是什么--

1235
01:01:21,650 --> 01:01:26,250
添加一堆看不见的那些来弥合差距 并检查其中任何一个

1236
01:01:26,250 --> 01:01:27,900
对于碰撞 保持为True 

1237
01:01:27,900 --> 01:01:32,010
计算成本稍微高一点 但精确度要高得多

1238
01:01:32,010 --> 01:01:35,107
从物理学的角度来说 

1239
01:01:35,107 --> 01:01:36,940
除此之外 一切都是一样的 

1240
01:01:36,940 --> 01:01:40,326
所以如果你看一下Breakout 4中的代码--

1241
01:01:40,326 --> 01:01:42,450
从今以后 我要开得更快一点 

1242
01:01:42,450 --> 01:01:44,491
这可能是该计划中最丰盛的部分 

1243
01:01:47,050 --> 01:01:49,080
我们会遇到碰撞 

1244
01:01:49,080 --> 01:01:54,102
然后我会试着得到一个强有力的角度 这样我就可以演示--

1245
01:01:54,102 --> 01:01:54,810
但这并不管用 

1246
01:01:54,810 --> 01:01:55,890
这实际上给出了一个较弱的角度 

1247
01:01:55,890 --> 01:01:59,250
所以如果你这样做 你靠近中心做 它会产生相反的效果 

1248
01:01:59,250 --> 01:01:59,958
但这就是你要做的 

1249
01:01:59,958 --> 01:02:01,200
这是一个更锐利的角度 

1250
01:02:01,200 --> 01:02:05,550
所以现在你实际上可以更多地影响球

1251
01:02:05,550 --> 01:02:07,770
风度翩翩的方式 

1252
01:02:07,770 --> 01:02:11,070
你知道 它不仅仅是一个平坦的增量 Y变负--

1253
01:02:11,070 --> 01:02:14,220
或者有效地得到负的增量Y 

1254
01:02:14,220 --> 01:02:19,920
那么对于这一切的主旨是如何运作的 有什么问题吗？

1255
01:02:23,730 --> 01:02:24,230
好的 

1256
01:02:24,230 --> 01:02:25,040
完美无缺 

1257
01:02:25,040 --> 01:02:28,395
所以现在我们要进入更多一些有趣的东西 

1258
01:02:28,395 --> 01:02:30,770
我们再做几个例子 然后休息一下 

1259
01:02:30,770 --> 01:02:32,360
这就是心脏的最新情况 

1260
01:02:32,360 --> 01:02:35,690
请注意屏幕的最上方 正如我在下面这些演示中所演示的

1261
01:02:35,690 --> 01:02:38,480
幻灯片 我们只有几颗心 

1262
01:02:38,480 --> 01:02:39,382
其中一个是空的 

1263
01:02:39,382 --> 01:02:40,340
我们早些时候展示了这个 

1264
01:02:40,340 --> 01:02:43,660
然后我们有一场屏幕上的比赛 这是我们的最终比分 

1265
01:02:43,660 --> 01:02:46,909
所以我要继续 我们只需要稍微看一下代码

1266
01:02:46,909 --> 01:02:50,656
现在更快了 因为很多东西都相当简单 

1267
01:02:50,656 --> 01:02:52,280
我要继续下去 打开--

1268
01:02:52,280 --> 01:02:54,780
我首先要确保我在正确的文件夹中 

1269
01:02:54,780 --> 01:02:55,760
突破5.

1270
01:02:55,760 --> 01:02:57,320
然后在--

1271
01:03:00,860 --> 01:03:07,690
所以我们要开始做的另一件事是--

1272
01:03:07,690 --> 01:03:08,917
我刚才提到过这一点 

1273
01:03:08,917 --> 01:03:10,750
它将会是真实的

1274
01:03:10,750 --> 01:03:13,570
对于任何一种状态转换

1275
01:03:13,570 --> 01:03:15,460
这一切都发生在未来 

1276
01:03:15,460 --> 01:03:17,440
我们没有保留全局变量 而是

1277
01:03:17,440 --> 01:03:20,500
在某种程度上消除资产表外的这种想法

1278
01:03:20,500 --> 01:03:23,210
我们所拥有的只是因为这些是一种例外

1279
01:03:23,210 --> 01:03:26,560
并且可以合理地将它们放在一个称为资源的单独类中

1280
01:03:26,560 --> 01:03:27,550
经理 

1281
01:03:27,550 --> 01:03:35,570
我们将开始传入基本上就是我们当前的应用程序状态 

1282
01:03:35,570 --> 01:03:37,750
或者至少是有意义的变量 

1283
01:03:37,750 --> 01:03:40,900
这也是使用Reaction进行Web开发的常见范例 

1284
01:03:40,900 --> 01:03:44,560
但基本上 我们需要的一切都是州与州之间的保存 

1285
01:03:44,560 --> 01:03:46,310
与其只保留全局变量 

1286
01:03:46,310 --> 01:03:49,210
让我们在状态之间传递它们 因为状态机允许

1287
01:03:49,210 --> 01:03:52,120
我们需要在Change函数中执行此操作 

1288
01:03:52,120 --> 01:03:55,240
然后不管它的Enter函数处于什么状态 

1289
01:03:55,240 --> 01:03:56,950
它将可以访问它 并且它可以

1290
01:03:56,950 --> 01:04:01,090
将这些值设置为Self Dot Anywhere并使用它们 

1291
01:04:01,090 --> 01:04:02,770
但我们不再有全球变量 

1292
01:04:02,770 --> 01:04:03,770
我们只是想说 给你 

1293
01:04:03,770 --> 01:04:06,962
以下是对你继续下去很重要的价值观 

1294
01:04:06,962 --> 01:04:09,670
然后 该状态将采用其值并进入下一状态

1295
01:04:09,670 --> 01:04:14,170
然后说 哦 好的 这是你运作所需要的价值观 

1296
01:04:14,170 --> 01:04:16,240
比如发球 打球 以及所有这些状态

1297
01:04:16,240 --> 01:04:17,890
有核心游戏参与的人可能会

1298
01:04:17,890 --> 01:04:19,540
需要保持一个像桨一样的引用 

1299
01:04:19,540 --> 01:04:21,676
更重要的是 我们所拥有的健康程度 

1300
01:04:21,676 --> 01:04:24,550
但当我们走到最后 例如 然后我们不再真的

1301
01:04:24,550 --> 01:04:27,849
需要一把桨 我们不再真的需要砖头或类似的东西 

1302
01:04:27,849 --> 01:04:30,640
我们只需要知道我们的最高分是多少 这样我们就可以进入它

1303
01:04:30,640 --> 01:04:33,430
进入我们的高分名单 我们真正需要的

1304
01:04:33,430 --> 01:04:37,030
要做的就是通过高分州进入或只通过我们的高分 

1305
01:04:37,030 --> 01:04:39,340
就是这样 

1306
01:04:39,340 --> 01:04:41,170
所以它封装了我们所有的数据 

1307
01:04:41,170 --> 01:04:45,730
一眼就能看出我们需要在两个州之间传递什么

1308
01:04:45,730 --> 01:04:48,730
以及哪些内容也将一目了然 

1309
01:04:48,730 --> 01:04:52,340
它只是清理了相当多的东西 

1310
01:04:52,340 --> 01:04:55,120
这就是我们现在在第35行所做的 

1311
01:04:55,120 --> 01:04:58,600
从今以后 我们将在我们所看到的每个州都这样做 

1312
01:04:58,600 --> 01:05:02,500
但我打算在未来对它进行某种程度的掩盖 

1313
01:05:02,500 --> 01:05:03,610
我们现在有了一个ServeState 

1314
01:05:03,610 --> 01:05:08,257
因此 作为一个ServeState 这与我们在Pong所做的非常相同 

1315
01:05:08,257 --> 01:05:10,090
因此 我们只需等待用户按空格键 

1316
01:05:10,090 --> 01:05:16,810
他们可以四处走动 然后当他们按下Enter键时 

1317
01:05:16,810 --> 01:05:20,380
基本上 球开始移动了 

1318
01:05:20,380 --> 01:05:23,110
然后我们使用以下命令更改此处的PlayState

1319
01:05:23,110 --> 01:05:25,644
所需的当前值 

1320
01:05:25,644 --> 01:05:27,310
划桨、砖块、健康、得分和球 

1321
01:05:27,310 --> 01:05:30,220
这些基本上是基本的变量

1322
01:05:30,220 --> 01:05:35,980
我们需要它来跟踪我们的游戏状态 

1323
01:05:35,980 --> 01:05:38,890
所以我们有一个ServeState 它将等待我们按Enter键 

1324
01:05:38,890 --> 01:05:50,820
然后是我们的主路 我们有了一个新的心心桌 

1325
01:05:50,820 --> 01:05:55,350
然后在208线上 因为我们要去

1326
01:05:55,350 --> 01:05:59,280
需要在几个州呈现健康和分数的能力 

1327
01:05:59,280 --> 01:06:02,100
比赛、发球、胜利、游戏结束--

1328
01:06:02,100 --> 01:06:04,290
其实不是游戏结束 而是之前的三场比赛 

1329
01:06:04,290 --> 01:06:06,081
我们不想重复这些行为 

1330
01:06:06,081 --> 01:06:08,730
所以我只调用了一个名为Render Health的函数 它

1331
01:06:08,730 --> 01:06:10,830
只是吸收任何健康的东西 然后

1332
01:06:10,830 --> 01:06:13,800
我们只需将X设置为虚拟宽度减去100 

1333
01:06:13,800 --> 01:06:17,070
然后 为了我们的健康 画一颗心

1334
01:06:17,070 --> 01:06:20,430
从红心精灵纸上 我把心分开

1335
01:06:20,430 --> 01:06:23,670
分成更小的图像 这样你就可以把它们分成8乘8的

1336
01:06:23,670 --> 01:06:25,590
或者什么都行 

1337
01:06:25,590 --> 01:06:27,774
但只要把它们画出来 然后把11加到X上 

1338
01:06:27,774 --> 01:06:30,690
继续前进 直到我们拔出我们有多少颗心 

1339
01:06:30,690 --> 01:06:32,220
这将吸引满满的心 

1340
01:06:32,220 --> 01:06:35,350
然后 三减健康将会给我们带来多少我们错过的健康 

1341
01:06:35,350 --> 01:06:38,099
所以如果我们取一个损伤点 这将等于1 

1342
01:06:38,099 --> 01:06:41,736
然后它会画出一颗空的心 否则它会画出两颗空的心 

1343
01:06:41,736 --> 01:06:44,610
所以 画出我们有多少颗饱满的心 然后画出空虚的心 

1344
01:06:44,610 --> 01:06:48,540
这是我们从图像中得到的两个独立的精灵 

1345
01:06:48,540 --> 01:06:51,150
这将对我们的健康产生影响 

1346
01:06:51,150 --> 01:06:56,530
然后我们的分数很简单 它接受一个分数变量 我们在这里传递 

1347
01:06:56,530 --> 01:06:58,530
还请注意 渲染运行状况[INAUDIBLE]

1348
01:06:58,530 --> 01:07:00,450
和健康变量 并在这里传递给它 

1349
01:07:00,450 --> 01:07:17,670
因此 在我们的PlayState中 我们在第135行调用这两个函数 

1350
01:07:17,670 --> 01:07:20,702
好的 在第135行 我们正在计算我们是否

1351
01:07:20,702 --> 01:07:23,910
走到屏幕边缘下方 这是游戏的另一个重要部分 

1352
01:07:23,910 --> 01:07:26,520
显然 我们需要发现我们何时失去了健康 

1353
01:07:26,520 --> 01:07:28,080
所以事情就是这么简单 

1354
01:07:28,080 --> 01:07:31,140
如果它大于实际身高 健康就会减少1 

1355
01:07:31,140 --> 01:07:34,200
如果它等于零 则更改为游戏结束 

1356
01:07:34,200 --> 01:07:35,467
否则 更改为ServeState 

1357
01:07:35,467 --> 01:07:38,550
请注意 我们将所有这些变量传入和传出我们的州 

1358
01:07:38,550 --> 01:07:39,716
那些重要的东西 

1359
01:07:39,716 --> 01:07:41,970
比赛结束只需要得分 但发球需要任何东西

1360
01:07:41,970 --> 01:07:43,740
我们已经在使用的变量 

1361
01:07:46,620 --> 01:07:50,100
然后我们在这里调用Render Score和Render Health 

1362
01:07:50,100 --> 01:07:54,900
然后 GameOverState就是简单的--

1363
01:07:54,900 --> 01:07:58,890
因为它接受参数列表中的分数 

1364
01:07:58,890 --> 01:08:03,330
只需等待键盘输入返回到开始 然后渲染游戏结束 

1365
01:08:03,330 --> 01:08:04,530
这是你的分数 

1366
01:08:04,530 --> 01:08:06,930
这是自己的得分 然后就是这样 

1367
01:08:06,930 --> 01:08:07,620
非常简单 

1368
01:08:07,620 --> 01:08:08,636
非常简单的状态 

1369
01:08:08,636 --> 01:08:09,510
观众：[听不见]

1370
01:08:09,510 --> 01:08:10,301
科尔顿·奥格登：当然可以 

1371
01:08:10,301 --> 01:08:15,899
观众：[听不见]

1372
01:08:15,899 --> 01:08:18,149
科尔顿·奥格登：问题是 这些州中有哪一个

1373
01:08:18,149 --> 01:08:19,740
有权访问他们的父文件吗？

1374
01:08:19,740 --> 01:08:27,180
观众：[听不见]

1375
01:08:27,180 --> 01:08:30,120
科尔顿·奥格登：一切正常吗？Lua全球运行吗？

1376
01:08:30,120 --> 01:08:30,810
是 

1377
01:08:30,810 --> 01:08:31,935
您声明的函数 

1378
01:08:31,935 --> 01:08:35,220
在main.lua中定义的基本上未指定为本地的任何内容

1379
01:08:35,220 --> 01:08:39,163
将可在应用程序中的任何位置访问 包括函数 

1380
01:08:39,163 --> 01:08:40,715
观众：[听不见]

1381
01:08:40,715 --> 01:08:42,840
科尔顿·奥格登：你不必--问题是 

1382
01:08:42,840 --> 01:08:44,215
你必须申报为公共物品吗？

1383
01:08:44,215 --> 01:08:45,725
不 没有公开的概念 

1384
01:08:45,725 --> 01:08:48,720
在LUA中 任何没有局部说明符的东西

1385
01:08:48,720 --> 01:08:51,330
被假定为全局的 即使它在嵌套作用域中 

1386
01:08:51,330 --> 01:08:54,930
所以你可以有一个for循环 你可以有几个嵌套的for循环

1387
01:08:54,930 --> 01:08:59,310
并声明一些不带局部变量的变量 该变量可以在任何地方访问

1388
01:08:59,310 --> 01:09:01,050
在它上面或外面 

1389
01:09:01,050 --> 01:09:03,060
所以使用局部变量非常重要

1390
01:09:03,060 --> 01:09:05,970
当你没有显式地分配全局变量时 

1391
01:09:05,970 --> 01:09:09,600
只是为了避免for嵌套循环的错误

1392
01:09:09,600 --> 01:09:14,729
你有一个变量名 比如hello 你可以在其他地方使用它 

1393
01:09:14,729 --> 01:09:16,960
好问题 

1394
01:09:16,960 --> 01:09:17,460
所以是的 

1395
01:09:17,460 --> 01:09:18,569
我们现在有很多州 

1396
01:09:18,569 --> 01:09:20,360
我们有一个GameOverState 一个PlayState 我们

1397
01:09:20,360 --> 01:09:22,359
渲染我们的分数渲染我们的健康

1398
01:09:22,359 --> 01:09:24,239
如果我们去看看Breakout 5--

1399
01:09:29,805 --> 01:09:33,630
是另一扇窗吗？

1400
01:09:33,630 --> 01:09:35,660
好了

1401
01:09:35,660 --> 01:09:37,500
我们可以在顶部看到心脏 

1402
01:09:37,500 --> 01:09:38,279
零分 

1403
01:09:41,600 --> 01:09:44,960
哦 我忘了说我们现在要加分了 

1404
01:09:44,960 --> 01:09:54,440
所以砖块本身在击中时 或者我应该说在PlayState中 

1405
01:09:54,440 --> 01:10:00,221
在第81行 当我们检测到一个命中时 我们现在只是在分数上加10 

1406
01:10:00,221 --> 01:10:01,970
但稍后我们会做一个计算

1407
01:10:01,970 --> 01:10:04,200
我们会考虑层次和颜色

1408
01:10:04,200 --> 01:10:09,500
然后进行算术运算 得出每次击球的总得分 

1409
01:10:09,500 --> 01:10:14,810
但是 是的 我们有我们的健康 我们有我们的分数 

1410
01:10:14,810 --> 01:10:16,569
一旦我们受到足够的伤害 

1411
01:10:16,569 --> 01:10:18,110
最终进入游戏结束屏幕 

1412
01:10:18,110 --> 01:10:20,420
游戏结束屏幕将返回到开始屏幕 

1413
01:10:20,420 --> 01:10:21,780
所以有进步 

1414
01:10:21,780 --> 01:10:24,440
然后可能是我最喜欢的更新

1415
01:10:24,440 --> 01:10:27,650
在我们短暂休息之前是美丽的颜色更新 

1416
01:10:27,650 --> 01:10:31,200
所以很明显我们可以

1417
01:10:31,200 --> 01:10:32,480
我们已经更新了水平仪

1418
01:10:32,480 --> 01:10:37,160
所以我们不需要一堆静止的砖块 

1419
01:10:37,160 --> 01:10:41,270
我们最终做了一个更复杂的过程生成 

1420
01:10:41,270 --> 01:10:42,740
但这并不复杂 

1421
01:10:42,740 --> 01:10:48,290
在Breakout 6的levelmaker.lua中 我们有几个不同的常量 

1422
01:10:48,290 --> 01:10:51,499
所以固体 交替 跳过 或没有 

1423
01:10:51,499 --> 01:10:53,290
实际上 我不认为我用了跳过或没有 

1424
01:10:53,290 --> 01:10:54,860
基本上是固定的或者交替的 

1425
01:10:54,860 --> 01:10:56,180
我们现在有旗子了 

1426
01:10:56,180 --> 01:10:58,100
列的数量 

1427
01:10:58,100 --> 01:11:02,480
我们确保它是奇数的 因为偶数列具有生成模式

1428
01:11:02,480 --> 01:11:04,340
会导致不对称 

1429
01:11:04,340 --> 01:11:07,679
因此 请确保列数为奇数 

1430
01:11:07,679 --> 01:11:10,470
根据我们的级别生成最高级别和最高颜色 

1431
01:11:10,470 --> 01:11:12,850
所以在这种情况下 我们不会再往上走一层

1432
01:11:12,850 --> 01:11:16,025
因为我们没有比三级更高的级别 

1433
01:11:16,025 --> 01:11:18,080
0 1 2 3 

1434
01:11:18,080 --> 01:11:20,564
然后 无论我们的水平除以5是多少 

1435
01:11:20,564 --> 01:11:21,980
而且它只需要数学 地板 

1436
01:11:21,980 --> 01:11:26,540
Math.Floor基本上执行除法 然后截断

1437
01:11:26,540 --> 01:11:28,269
小数点 

1438
01:11:28,269 --> 01:11:29,060
嗯 不是组织 

1439
01:11:29,060 --> 01:11:31,760
它只是从字面上截断了一个数字的小数点 

1440
01:11:31,760 --> 01:11:33,260
所以这个水平除以5 

1441
01:11:33,260 --> 01:11:36,560
不管小数点前的数字是多少 

1442
01:11:36,560 --> 01:11:39,420
级别模块五加三为最高颜色 

1443
01:11:39,420 --> 01:11:40,430
所以我们要骑车了 

1444
01:11:40,430 --> 01:11:42,140
我们会一遍又一遍地复习 

1445
01:11:42,140 --> 01:11:46,400
走最高的颜色一 二 三 四 五 然后我们将进入一个新的层次

1446
01:11:46,400 --> 01:11:47,810
级别除以5 

1447
01:11:47,810 --> 01:11:50,520
所以基本上 每五个级别就会在层中递增 

1448
01:11:50,520 --> 01:11:52,410
然后我们再从蓝色开始 

1449
01:11:52,410 --> 01:11:56,406
然后我们继续 继续 就像这样 每隔几行 

1450
01:11:56,406 --> 01:11:57,530
所以基本上我有几个--

1451
01:11:57,530 --> 01:11:59,889
我将在这一点上稍加强调

1452
01:11:59,889 --> 01:12:02,180
就因为我们可能会赶不上时间 

1453
01:12:02,180 --> 01:12:05,360
但我们基本上有两面旗帜 

1454
01:12:05,360 --> 01:12:10,620
无论我们是跳过这一排的砖块 还是按颜色交替使用砖块 

1455
01:12:10,620 --> 01:12:14,810
如果我们这样做 我们需要为它设置一个颜色和一个层 

1456
01:12:14,810 --> 01:12:16,681
然后我们基本上只是说 你知道的 

1457
01:12:16,681 --> 01:12:19,430
与我们在生成随机行之前使用的逻辑相同

1458
01:12:19,430 --> 01:12:24,350
和列 但是如果我们打开了Alternate标志 

1459
01:12:24,350 --> 01:12:31,400
然后 正如我们在这里的一些照片中看到的 我们在这里有一个跳跃是真的 

1460
01:12:31,400 --> 01:12:36,260
因此 该行的颜色设置为蓝色 但跳过为真 

1461
01:12:36,260 --> 01:12:40,700
因此 每隔一块砖就会跳过循环的迭代 

1462
01:12:40,700 --> 01:12:42,980
这里也是一样 只是被1抵消了 

1463
01:12:42,980 --> 01:12:43,770
这里也是一样 

1464
01:12:43,770 --> 01:12:44,490
这里也是一样 

1465
01:12:44,490 --> 01:12:46,550
所以这是一种不错的小图案 

1466
01:12:46,550 --> 01:12:47,966
在每一种情况下--

1467
01:12:47,966 --> 01:12:49,340
实际上 并不是每一个案例都是如此 

1468
01:12:49,340 --> 01:12:52,070
请注意第三个参数 它还将Alternate设置为True 

1469
01:12:52,070 --> 01:12:55,250
所以它变成了绿色 紫色 绿色 紫色 绿色 紫色 

1470
01:12:55,250 --> 01:12:57,920
所以逻辑是 如果Alternate为真 那么

1471
01:12:57,920 --> 01:13:00,560
只需在每次迭代中翻转颜色即可 

1472
01:13:00,560 --> 01:13:04,430
如果跳过为真 则不要每隔一次迭代生成一块积木 依此类推

1473
01:13:04,430 --> 01:13:05,010
以此类推 

1474
01:13:05,010 --> 01:13:09,570
如果有Solid 或者没有Alternate Equals True 

1475
01:13:09,570 --> 01:13:11,750
然后你就会有一块坚固的砖 就像这些蓝色的 

1476
01:13:11,750 --> 01:13:16,730
如果你有替代但没有跳过 你就会得到这种模式

1477
01:13:16,730 --> 01:13:18,830
有绿色、紫色、绿色、紫色 

1478
01:13:18,830 --> 01:13:20,480
你知道 任何随机的颜色 

1479
01:13:20,480 --> 01:13:23,450
而且列数也是随机的 

1480
01:13:23,450 --> 01:13:24,740
所以它可以--

1481
01:13:24,740 --> 01:13:30,590
这里有1 2 3 4 5 6 7 8 9 10 11 但在最下面的这个上 

1482
01:13:30,590 --> 01:13:35,810
看起来是负二 因为它只能这么宽 

1483
01:13:35,810 --> 01:13:37,490
这里的那些也是如此 

1484
01:13:37,490 --> 01:13:38,660
尺寸要小一些 

1485
01:13:38,660 --> 01:13:40,100
那个没有空格 

1486
01:13:40,100 --> 01:13:42,470
所以这些都是非常简单的概念 

1487
01:13:42,470 --> 01:13:44,960
比如 我们应该在这次迭代中跳过一个块吗？

1488
01:13:44,960 --> 01:13:47,300
我们应该换一下颜色吗？

1489
01:13:47,300 --> 01:13:49,970
当你把它们放在一起时 就会产生

1490
01:13:49,970 --> 01:13:52,160
看起来像是几乎是手工制作的东西 

1491
01:13:52,160 --> 01:13:53,900
就像这可能是某人做的一样 

1492
01:13:53,900 --> 01:13:55,850
就像 这看起来像是有人做的 

1493
01:13:55,850 --> 01:13:57,170
几乎每一次迭代 

1494
01:13:57,170 --> 01:13:59,330
我的意思是 即使是这样 那看起来也几乎是一个形状 

1495
01:13:59,330 --> 01:14:03,534
这很简单 但在我看来 结果非常棒 

1496
01:14:03,534 --> 01:14:05,700
这就是我们正在做的事情背后的主旨 

1497
01:14:05,700 --> 01:14:08,510
我们只是在设置旗帜 然后说 你知道的 

1498
01:14:08,510 --> 01:14:10,789
如果我们跳过这一轮 跳过每一次迭代 

1499
01:14:10,789 --> 01:14:13,580
每次我们铺开一块砖 在这一排上生出一块新砖 

1500
01:14:13,580 --> 01:14:14,810
要么做要么不做 

1501
01:14:14,810 --> 01:14:16,660
只要把它弄成彩色的就行了

1502
01:14:16,660 --> 01:14:19,940
如果我们是交替的 选择两种颜色 然后设置

1503
01:14:19,940 --> 01:14:23,660
它的颜色是我们交替的任何关闭的颜色 

1504
01:14:23,660 --> 01:14:26,150
如果我们跳过和交替 那么

1505
01:14:26,150 --> 01:14:29,090
我们只是在我们实际铺设的砖头上做

1506
01:14:29,090 --> 01:14:32,540
就是当我们改变颜色时 交替的颜色 

1507
01:14:32,540 --> 01:14:35,004
就像我说的 我不会讲太多细节 

1508
01:14:35,004 --> 01:14:36,920
我很乐意在课后讨论发电机 

1509
01:14:36,920 --> 01:14:39,240
但我们时间不多了 

1510
01:14:39,240 --> 01:14:40,880
我会在上面挥舞双手

1511
01:14:40,880 --> 01:14:42,350
但简单来说就是这样 

1512
01:14:42,350 --> 01:14:47,430
在我们休息五分钟之前还有问题吗？

1513
01:14:47,430 --> 01:14:47,930
- 是吗-是的

1514
01:14:47,930 --> 01:15:02,800
观众：[听不见]

1515
01:15:02,800 --> 01:15:06,340
科尔顿·奥格登：问题是 在这种编程的情况下 

1516
01:15:06,340 --> 01:15:10,360
如果球的速度快到我们实际上在砖块里面 

1517
01:15:10,360 --> 01:15:12,633
会怎样？

1518
01:15:12,633 --> 01:15:14,174
记者：还会反弹吗？

1519
01:15:14,174 --> 01:15:15,882
科尔顿·奥格登：它还会反弹吗？

1520
01:15:15,882 --> 01:15:18,250
答案是不 不会 

1521
01:15:18,250 --> 01:15:21,460
此实现不考虑速度

1522
01:15:21,460 --> 01:15:24,130
太快了 

1523
01:15:24,130 --> 01:15:26,150
主要有两个原因 

1524
01:15:26,150 --> 01:15:28,707
第一 它的实现是不平凡的 第二 

1525
01:15:28,707 --> 01:15:30,790
这是一件有趣的事情 

1526
01:15:30,790 --> 01:15:34,750
并且在你实现自己的游戏时要有意识 

1527
01:15:34,750 --> 01:15:38,862
当前的代码 如果它被夹在砖块里 

1528
01:15:38,862 --> 01:15:41,320
它的边缘不会突出到砖的外面

1529
01:15:41,320 --> 01:15:43,819
因此 它将默认为最终条件 

1530
01:15:43,819 --> 01:15:47,080
是最后一个else子句 它把它放在砖块下面 

1531
01:15:47,080 --> 01:15:48,850
所以它只会在砖下面 

1532
01:15:48,850 --> 01:15:54,212
就像是从下面弹出来的 

1533
01:15:54,212 --> 01:15:56,920
但是就像我之前提到的 如果你想实现一些东西 

1534
01:15:56,920 --> 01:16:01,960
像这样 你需要把X帧和X +1帧分割开来

1535
01:16:01,960 --> 01:16:08,440
如果三角洲很宽

1536
01:16:08,440 --> 01:16:11,800
它要么在砖里面要么在砖外面

1537
01:16:11,800 --> 01:16:13,559
还是漏了一块砖

1538
01:16:13,559 --> 01:16:15,100
这个解决了这个问题 

1539
01:16:15,100 --> 01:16:18,220
它解决了这两个问题 但它有点多

1540
01:16:18,220 --> 01:16:20,600
比我们在这个例子中所能涵盖的要多 

1541
01:16:20,600 --> 01:16:24,260
还有其他问题吗？

1542
01:16:24,260 --> 01:16:24,760
好吧

1543
01:16:24,760 --> 01:16:28,671
休息五分钟继续工作 

1544
01:16:28,671 --> 01:16:29,170
好吧

1545
01:16:29,170 --> 01:16:29,960
我们回来了 

1546
01:16:29,960 --> 01:16:35,980
下一步就是我们有一个动态的布局

1547
01:16:35,980 --> 01:16:39,310
现在产生了许多有趣的砖 但我们还没有真正

1548
01:16:39,310 --> 01:16:41,680
实施了对其中任何一项的评分 

1549
01:16:41,680 --> 01:16:43,570
我们只有分数加10 这就是

1550
01:16:43,570 --> 01:16:46,330
其实并不是特别有趣 

1551
01:16:46,330 --> 01:16:50,080
因此 Breakout 7就是我所说的层更新 即

1552
01:16:50,080 --> 01:16:55,160
应该允许我们命中比基本蓝色更高级别的块 

1553
01:16:55,160 --> 01:16:59,800
如果它们的颜色高于基蓝 它们应该降到更低的颜色 

1554
01:16:59,800 --> 01:17:04,150
因此 如果我们回头看 这个等级是蓝色的

1555
01:17:04,150 --> 01:17:08,890
变成绿色 变成红色 变成紫色 变成金色 

1556
01:17:08,890 --> 01:17:11,920
如果某个东西是更高的层次 它就会

1557
01:17:11,920 --> 01:17:15,640
到它下面的下一个颜色 但在同一层 

1558
01:17:15,640 --> 01:17:19,750
除非它恰好是蓝色和灰色的 在这种情况下

1559
01:17:19,750 --> 01:17:22,010
它会变回蓝色 

1560
01:17:22,010 --> 01:17:30,184
那么 我们如何在这个系统的基础上实施评分呢？

1561
01:17:30,184 --> 01:17:30,850
我们需要什么？

1562
01:17:30,850 --> 01:17:33,770
我们需要些什么呢？

1563
01:17:33,770 --> 01:17:38,202
我们已经拥有了哪些我们可以用来实现这一点的东西？

1564
01:17:38,202 --> 01:17:40,460
观众：[听不见]

1565
01:17:40,460 --> 01:17:41,460
科尔顿·奥格登：什么？

1566
01:17:41,460 --> 01:17:52,351
观众：[听不见]

1567
01:17:52,351 --> 01:17:54,350
科尔顿·奥格登：所以答案是砖块指数 

1568
01:17:54,350 --> 01:18:00,721
所以 是的 砖皮和颜色就是碎片 

1569
01:18:00,721 --> 01:18:01,220
是 

1570
01:18:01,220 --> 01:18:03,280
所以这些都是砖块砌成的田地 

1571
01:18:03,280 --> 01:18:04,420
所以如果我们敞开心扉

1572
01:18:04,420 --> 01:18:06,950
我要去看《越狱7》 

1573
01:18:06,950 --> 01:18:10,070
我可能会开始推迟很多代码

1574
01:18:10,070 --> 01:18:12,020
敬未来的阅读 

1575
01:18:12,020 --> 01:18:16,580
但这里的砖块 层数和颜色--

1576
01:18:16,580 --> 01:18:19,670
对不起 不是皮 但皮是用来划桨的 

1577
01:18:19,670 --> 01:18:22,200
但这块砖有一层 它有一种颜色 

1578
01:18:22,200 --> 01:18:25,530
所以我们需要在这里进行一些算术运算 

1579
01:18:25,530 --> 01:18:28,100
这基本上就是第44行到第58行的意思 

1580
01:18:28,100 --> 01:18:32,420
所以基本上--哦 我道歉 

1581
01:18:32,420 --> 01:18:36,330
这实际上并不是算术上的问题 

1582
01:18:36,330 --> 01:18:40,430
44 这是可以计算的 但这是一小段代码

1583
01:18:40,430 --> 01:18:45,810
这就计算了如果我们发生碰撞 我们实际上可以如何倒退 

1584
01:18:45,810 --> 01:18:52,880
所以如果我们撞上了一块砖 它的层级比一层高

1585
01:18:52,880 --> 01:18:57,870
而且它是一种比蓝色更高的颜色 它应该被带回一个台阶 

1586
01:18:57,870 --> 01:19:02,420
但如果它恰好是蓝色的 在这种情况下 self.COLOR会得到一个

1587
01:19:02,420 --> 01:19:05,420
因为蓝色是其中之一 那么就应该把它从比赛中剔除

1588
01:19:05,420 --> 01:19:06,840
就像我们以前做的那样 

1589
01:19:06,840 --> 01:19:10,490
只是现在 我们也在考虑层次感和色彩 

1590
01:19:10,490 --> 01:19:13,460
因此 我们根据我们所处的索引递减层

1591
01:19:13,460 --> 01:19:15,890
而且我们的颜色也在减少 

1592
01:19:15,890 --> 01:19:20,053
然后这实际上会在我们的PlayState中使用 

1593
01:19:24,000 --> 01:19:29,750
如果我们转到第81行 它之前刚刚

1594
01:19:29,750 --> 01:19:32,960
让自己得分 得分加一 这里有一点数学知识 

1595
01:19:32,960 --> 01:19:34,220
不过 这很简单 

1596
01:19:34,220 --> 01:19:36,290
就是砖头 200倍 

1597
01:19:36,290 --> 01:19:38,270
因此 让这些层的价值达到100 

1598
01:19:38,270 --> 01:19:41,470
再加上砖块 颜色乘以25 

1599
01:19:41,470 --> 01:19:43,520
因此 如果层为零 如果它是基数 那么我们将

1600
01:19:43,520 --> 01:19:44,990
只是拿不到那200英镑的奖金 

1601
01:19:44,990 --> 01:19:47,115
但在第一层 一切都将是值得的

1602
01:19:47,115 --> 01:19:49,490
25倍 不管它是什么颜色 

1603
01:19:49,490 --> 01:19:52,400
一、二、三、四、五 

1604
01:19:52,400 --> 01:19:55,790
然后再加上200加上砖块的颜色

1605
01:19:55,790 --> 01:19:58,760
我们到了下一组砖 

1606
01:19:58,760 --> 01:20:01,140
这样做的结果是--

1607
01:20:05,680 --> 01:20:10,120
我相信这是《图形用户界面突破7》 

1608
01:20:14,100 --> 01:20:15,680
如果我们撞到了一块砖--

1609
01:20:15,680 --> 01:20:17,520
既然这个是蓝色的 它应该会消失 

1610
01:20:17,520 --> 01:20:19,103
我们也在播放一种新的声音 

1611
01:20:19,103 --> 01:20:21,285
新的 就像 死亡的声音只是为了清楚 

1612
01:20:24,710 --> 01:20:26,337
但请注意 它们会改变颜色 

1613
01:20:26,337 --> 01:20:27,420
这就是我们要做的一切 

1614
01:20:27,420 --> 01:20:29,960
我们只是想要他们的等级或颜色

1615
01:20:29,960 --> 01:20:32,330
只需对其执行一个简单的减量 

1616
01:20:32,330 --> 01:20:33,650
往回循环 

1617
01:20:33,650 --> 01:20:36,620
在我们下一层的情况下 我们应该循环返回

1618
01:20:36,620 --> 01:20:39,440
到较低层的最高颜色 

1619
01:20:39,440 --> 01:20:41,390
所以我会让你们看看这方面的代码

1620
01:20:41,390 --> 01:20:44,060
如果你想对它有一个更低层次的理解 

1621
01:20:44,060 --> 01:20:46,192
但这是一种高层次的理解 

1622
01:20:46,192 --> 01:20:48,650
我想向你们介绍的下一个重要概念是

1623
01:20:48,650 --> 01:20:51,080
是一个粒子系统 

1624
01:20:51,080 --> 01:20:57,420
因此 粒子系统在视频游戏中相当普遍 

1625
01:20:57,420 --> 01:20:59,510
我会说 因为它们产生的效果

1626
01:20:59,510 --> 01:21:02,090
或者很难用简单的精灵来做

1627
01:21:02,090 --> 01:21:05,720
编辑可以非常容易和现实地实现 

1628
01:21:05,720 --> 01:21:07,200
例如 就像火一样 

1629
01:21:07,200 --> 01:21:10,417
非常有机的 流畅的 有很多东西在进行

1630
01:21:10,417 --> 01:21:12,500
通常用粒子系统表示得更好

1631
01:21:12,500 --> 01:21:15,260
而不是使用简单的精灵动画 

1632
01:21:15,260 --> 01:21:18,230
有谁知道我们如何才能--

1633
01:21:18,230 --> 01:21:22,010
粒子系统如何在引擎盖下工作？

1634
01:21:22,010 --> 01:21:26,304
我想我以前提到过这一点 

1635
01:21:26,304 --> 01:21:26,803
是 

1636
01:21:26,803 --> 01:21:33,879
观众：[听不见]

1637
01:21:33,879 --> 01:21:34,670
科尔顿·奥格登：是的 

1638
01:21:34,670 --> 01:21:38,740
所以他说的是为了生火 

1639
01:21:38,740 --> 01:21:41,650
例如 只需产生一束粒子

1640
01:21:41,650 --> 01:21:45,320
靠近你的火种产生的中心 然后在它的外面

1641
01:21:45,320 --> 01:21:46,450
产卵较少 

1642
01:21:46,450 --> 01:21:49,900
这绝对是一种让火发挥作用的方法 

1643
01:21:49,900 --> 01:21:54,190
同时也要考虑到粒子的移动 

1644
01:21:54,190 --> 01:21:57,580
例如 你可能会非常密集地产生一吨的火粒子 

1645
01:21:57,580 --> 01:22:00,580
但或许他们有某种逻辑让他们往上走 

1646
01:22:00,580 --> 01:22:04,400
也许它们有一个负的增量Y 然后是某种加速度

1647
01:22:04,400 --> 01:22:06,040
因此 他们已经有了一些踪迹 

1648
01:22:06,040 --> 01:22:10,270
然后也许是如何获得更逼真的火

1649
01:22:10,270 --> 01:22:13,720
看 它们向上移动 然后逐渐消失 

1650
01:22:13,720 --> 01:22:16,690
所以火的运作方式 某种程度上是在思考事物

1651
01:22:16,690 --> 01:22:20,830
就这样的粒子而言 你可以达到很多效果 

1652
01:22:20,830 --> 01:22:23,360
例如 我们如何实现吸烟？

1653
01:22:23,360 --> 01:22:24,340
同样的系统 

1654
01:22:29,250 --> 01:22:33,980
所以我们可以在粒子效果中使用计时器 

1655
01:22:33,980 --> 01:22:36,170
甚至是一种转变 因为在粒子系统中 

1656
01:22:36,170 --> 01:22:39,300
通常 您可以在粒子之间过渡颜色 

1657
01:22:39,300 --> 01:22:41,900
比方说 你从红色开始 到黄色 

1658
01:22:41,900 --> 01:22:44,996
然后 您的粒子系统可能会过渡到灰色或棕色 

1659
01:22:44,996 --> 01:22:47,870
然后随着时间的推移 你的颗粒物会上升 它们会消散 

1660
01:22:47,870 --> 01:22:50,210
它们也变暗了 它们变成了棕色 

1661
01:22:50,210 --> 01:22:52,820
它给你一种火的错觉 

1662
01:22:52,820 --> 01:22:54,890
我们不会做任何事情 因为

1663
01:22:54,890 --> 01:22:59,030
在我们的代码中如此复杂 但在Breakout 8中 我们

1664
01:22:59,030 --> 01:23:04,160
将使用Love的一种集成粒子系统 它只是

1665
01:23:04,160 --> 01:23:06,770
Love.graph ics.newarticlessystem 

1666
01:23:06,770 --> 01:23:09,830
它接受纹理 因为所有粒子系统都需要某种

1667
01:23:09,830 --> 01:23:11,630
质地作为它们的基础 

1668
01:23:11,630 --> 01:23:15,920
然后它需要它最大限度地释放出的粒子的数量 

1669
01:23:15,920 --> 01:23:18,740
因此每个单独的粒子系统都可以向上发射

1670
01:23:18,740 --> 01:23:20,780
到粒子的某个实例 

1671
01:23:20,780 --> 01:23:23,234
在数量、速度和诸如此类的东西上

1672
01:23:23,234 --> 01:23:25,400
这些颗粒最终是决定因素

1673
01:23:25,400 --> 01:23:28,850
你如何才能得到一个幻觉 

1674
01:23:28,850 --> 01:23:32,722
回到上周的演讲 幻觉 就像 这不是火 不是烟 

1675
01:23:32,722 --> 01:23:34,430
它只是一群粒子在响应

1676
01:23:34,430 --> 01:23:36,740
用颜色和加速度之类的东西 

1677
01:23:36,740 --> 01:23:40,940
但在Love2D中 粒子系统为您提供了很多功能 

1678
01:23:40,940 --> 01:23:44,240
所以我鼓励你们看看这个链接 只是为了探索其中的一些 

1679
01:23:44,240 --> 01:23:48,530
Love2d.org/wiki/articlessystem 

1680
01:23:48,530 --> 01:23:49,930
我们将使用其中的几个 

1681
01:23:49,930 --> 01:23:53,330
在这里 我将简要地向你们展示 

1682
01:23:53,330 --> 01:23:57,890
所以当每一块砖被击中时

1683
01:23:57,890 --> 01:23:59,895
需要一个自己的粒子系统 

1684
01:23:59,895 --> 01:24:00,770
因为我们的目标是--

1685
01:24:00,770 --> 01:24:03,870
我将为您运行代码 这样您就可以看到它 

1686
01:24:03,870 --> 01:24:09,290
因此 如果你转到Breakout 8 然后你运行它 

1687
01:24:09,290 --> 01:24:18,390
我们有一点粒子 你们在最后看到的 

1688
01:24:18,390 --> 01:24:22,250
你可能看得更清楚一点的蓝色 

1689
01:24:22,250 --> 01:24:25,150
然后是最后一次 

1690
01:24:25,150 --> 01:24:27,340
所以它会产生一堆微小的粒子 

1691
01:24:27,340 --> 01:24:30,970
所以有没有人能告诉我他们认为这些粒子

1692
01:24:30,970 --> 01:24:33,670
一言以蔽之？

1693
01:24:33,670 --> 01:24:38,354
粒子的逻辑是什么？

1694
01:24:38,354 --> 01:24:40,819
观众：[听不见]稍微有点随意 

1695
01:24:40,819 --> 01:24:41,610
科尔顿·奥格登：是的 

1696
01:24:41,610 --> 01:24:42,400
有点随机 

1697
01:24:42,400 --> 01:24:45,940
如果你看它 你也会注意到它们往往是向下的 

1698
01:24:49,030 --> 01:24:52,210
所以知道了这一点 我们大概可以假设

1699
01:24:52,210 --> 01:24:57,080
它们有一个趋向于正Y的加速度 

1700
01:24:57,080 --> 01:24:59,080
这基本上就是我们真正需要做的事情 

1701
01:24:59,080 --> 01:25:02,560
我们向外产生一束粒子 然后把它们放在一起--

1702
01:25:02,560 --> 01:25:04,000
他们都有一辈子的时间 

1703
01:25:04,000 --> 01:25:06,250
它们会持续一段时间 

1704
01:25:06,250 --> 01:25:09,490
然后它们会在两种颜色之间褪色 

1705
01:25:09,490 --> 01:25:16,150
在这种情况下 我们从红色褪色为透明或其他任何颜色 

1706
01:25:16,150 --> 01:25:23,260
然后在生命周期过去之后 它会产生整体的影响

1707
01:25:23,260 --> 01:25:25,810
这种闪烁的、基于重力的效果 

1708
01:25:25,810 --> 01:25:27,280
但它实际上只是一堆粒子

1709
01:25:27,280 --> 01:25:28,821
设置为在不同方向产卵 

1710
01:25:28,821 --> 01:25:30,260
为此道歉 

1711
01:25:30,260 --> 01:25:32,110
所以我们来看看 

1712
01:25:32,110 --> 01:25:38,130
它将出现在我们的《突破8》的砖块课上 

1713
01:25:38,130 --> 01:25:39,380
所以我们要去布里克 

1714
01:25:42,290 --> 01:25:45,260
我们在这里储存了一堆颜色 

1715
01:25:45,260 --> 01:25:49,820
所以如果你注意到了 粒子系统采用的是任何砖块的颜色

1716
01:25:49,820 --> 01:25:52,430
他们的打击只是为了让它保持一致

1717
01:25:52,430 --> 01:25:54,185
与我们正在看的东西相吻合 

1718
01:25:54,185 --> 01:25:56,060
所以我们只是在这里存储了一堆颜色 

1719
01:25:56,060 --> 01:25:57,950
我也不会太担心这一点 

1720
01:25:57,950 --> 01:25:59,824
这些只是精灵调色板中的颜色

1721
01:25:59,824 --> 01:26:01,760
我们用在我们的精灵艺术上 

1722
01:26:01,760 --> 01:26:04,490
有一些特定的颜色只在那个精灵中使用 

1723
01:26:04,490 --> 01:26:06,487
一般来说 有一个调色板 

1724
01:26:06,487 --> 01:26:08,570
让你的作品看起来更有凝聚力

1725
01:26:08,570 --> 01:26:11,694
当你在做精灵艺术 而不是任性地挑选颜色 

1726
01:26:11,694 --> 01:26:15,320
如果你说 哦 这个调色板我只会用16或32种颜色 

1727
01:26:15,320 --> 01:26:17,840
你会看起来更有凝聚力 而且

1728
01:26:17,840 --> 01:26:20,780
非常复古的外观 因为硬件通常是

1729
01:26:20,780 --> 01:26:25,190
对于较旧的系统 仅限于一定数量的颜色 

1730
01:26:25,190 --> 01:26:26,960
所以我很高兴--

1731
01:26:26,960 --> 01:26:30,050
顺便说一句 我们下周也会讨论这个问题 

1732
01:26:30,050 --> 01:26:34,137
当你在做自己的精灵艺术时 试着使用更少的颜色

1733
01:26:34,137 --> 01:26:36,720
然后这会给你--它也会让你更容易 

1734
01:26:36,720 --> 01:26:40,970
你不必花时间来挑选 我想要这种绿色 

1735
01:26:40,970 --> 01:26:42,240
我想知道它看起来好不好 

1736
01:26:42,240 --> 01:26:45,634
如果你只有两种深浅绿色或半深浅绿色可供选择 

1737
01:26:45,634 --> 01:26:46,550
这就是你能做的一切 

1738
01:26:46,550 --> 01:26:48,302
你必须尽你所能凑合着使用它 

1739
01:26:48,302 --> 01:26:51,260
所以我们在这里做的是从调色板中存储五种颜色 

1740
01:26:51,260 --> 01:26:52,430
我们将利用这一点 

1741
01:26:52,430 --> 01:26:54,920
然后当我们启动我们的.

1742
01:26:54,920 --> 01:26:57,980
就在这里 我们正在初始化一个粒子系统 

1743
01:26:57,980 --> 01:27:02,150
因此 psystem得到了love.graph ics.newarticlessystem 

1744
01:27:02,150 --> 01:27:04,130
然后是几个函数 

1745
01:27:04,130 --> 01:27:07,370
因此 您可以在维基中查看这些功能的实际运行方式 

1746
01:27:07,370 --> 01:27:10,550
但终生加速和面积扩散

1747
01:27:10,550 --> 01:27:13,190
只是在某种程度上影响了

1748
01:27:13,190 --> 01:27:15,330
我们的粒子系统的行为方式 

1749
01:27:15,330 --> 01:27:17,600
所以使用我们当前的颜色 

1750
01:27:17,600 --> 01:27:21,230
我们将使用setColors函数设置psystem的颜色 

1751
01:27:21,230 --> 01:27:23,200
我们要把它设置在两种颜色之间 

1752
01:27:23,200 --> 01:27:28,796
层Alpha的颜色为55倍 Alpha为零的颜色 

1753
01:27:28,796 --> 01:27:30,920
因此 层数越高 粒子越亮 

1754
01:27:30,920 --> 01:27:34,130
但如果这有道理的话 它们总是会逐渐消失到零阿尔法 

1755
01:27:34,130 --> 01:27:35,760
然后我们就会排放64 

1756
01:27:35,760 --> 01:27:37,650
这些都在HIT功能中 

1757
01:27:37,650 --> 01:27:42,020
所以我们基本上所做的就是在我们的命中中添加这个粒子系统触发器

1758
01:27:42,020 --> 01:27:46,170
函数 它具有我们前面看到的行为的结果 

1759
01:27:46,170 --> 01:27:49,700
那么 关于粒子系统或我们如何使用它们有什么问题吗？

1760
01:27:53,220 --> 01:27:55,830
因此 级别9是进度更新 

1761
01:27:55,830 --> 01:27:59,880
因此 此更新的目的是让我们从第一个级别开始

1762
01:27:59,880 --> 01:28:04,170
从两个到三个到四个 开始变得更有趣

1763
01:28:04,170 --> 01:28:06,510
一代人都是这样的 

1764
01:28:06,510 --> 01:28:09,480
这件事的主旨在于我们--

1765
01:28:09,480 --> 01:28:11,932
所以如果你看看我们的StartState--

1766
01:28:16,180 --> 01:28:22,090
所以我们真正需要做的就是存储一个级别 只需存储一个数字 

1767
01:28:22,090 --> 01:28:24,850
然后我们在哪里递增这个数字？

1768
01:28:24,850 --> 01:28:28,069
或者我们什么时候增加我应该说的数字？

1769
01:28:28,069 --> 01:28:33,914
观众：[听不见]

1770
01:28:33,914 --> 01:28:34,830
科尔顿·奥格登：没错 

1771
01:28:34,830 --> 01:28:40,590
因此 我们增加了级别 

1772
01:28:40,590 --> 01:28:43,560
我们进入下一阶段 当所有的砖块

1773
01:28:43,560 --> 01:28:47,310
正在进行中已到达那里 正在进行中标志设置为假 

1774
01:28:47,310 --> 01:28:52,720
所以我们没有有效发挥作用的刺头 

1775
01:28:52,720 --> 01:28:54,840
所以在我们的StartState中--

1776
01:28:54,840 --> 01:28:57,086
让我们继续看《突破9》 

1777
01:29:00,990 --> 01:29:02,147
所以 StartState 

1778
01:29:05,803 --> 01:29:07,711
我们正在通过这里的一层 

1779
01:29:07,711 --> 01:29:08,960
我们只是要开始了 

1780
01:29:08,960 --> 01:29:12,043
当我们要去StartState的时候 我们只需要通过等于1的级别 

1781
01:29:12,043 --> 01:29:17,450
从今以后 任何时候我们从打球到发球的任何状态变化

1782
01:29:17,450 --> 01:29:19,940
而胜利 正如我们将看到的 胜利是我们的新的 

1783
01:29:19,940 --> 01:29:21,750
哦 你清除了这个级别 

1784
01:29:21,750 --> 01:29:22,690
这是下一个关口 

1785
01:29:22,690 --> 01:29:27,050
我们只是要超过他们之间的水平 

1786
01:29:27,050 --> 01:29:37,962
然后在PlayState中 这里的重要代码在204行 

1787
01:29:37,962 --> 01:29:39,920
所以这只是一个名为check Vicary的函数 

1788
01:29:39,920 --> 01:29:41,480
正如詹姆斯所说的那样 

1789
01:29:44,090 --> 01:29:48,590
我们将遍历整个表 并只说它是否在运行 

1790
01:29:48,590 --> 01:29:50,360
返回错误 因为我们没有取得胜利

1791
01:29:50,360 --> 01:29:52,070
如果我们有任何砖块在发挥作用 

1792
01:29:52,070 --> 01:29:55,850
但如果我们不满足该条件 则返回TRUE 

1793
01:29:55,850 --> 01:29:59,390
所以这只是一种简单的方式 让我们检查

1794
01:29:59,390 --> 01:30:02,730
我们取得了胜利 

1795
01:30:02,730 --> 01:30:05,800
因此 在我们的PlayState中同一文件的第88行 

1796
01:30:05,800 --> 01:30:09,560
我们只是想说 嘿 如果我们做了任何砖头之后 自己检查胜利

1797
01:30:09,560 --> 01:30:10,160
命中--

1798
01:30:10,160 --> 01:30:13,370
因为在那个时候 我们刚刚设置的一块砖是错误的--

1799
01:30:13,370 --> 01:30:14,880
只要检查胜利就好 

1800
01:30:14,880 --> 01:30:17,900
如果是这样的话 播放一个新的声音 就像一个快乐的声音

1801
01:30:17,900 --> 01:30:20,390
我们已经取得了胜利 然后就把一切都抛诸脑后了

1802
01:30:20,390 --> 01:30:22,400
进入我们这里拥有的新的维克托州 

1803
01:30:22,400 --> 01:30:27,410
而VictoryState仅仅是一种消息状态 

1804
01:30:27,410 --> 01:30:30,630
所以它所做的只是像以前一样渲染一切 

1805
01:30:30,630 --> 01:30:34,150
但它只是说你目前的水平已经完成了 

1806
01:30:34,150 --> 01:30:36,342
自我.级别完成 

1807
01:30:36,342 --> 01:30:39,050
然后按Enter键服务 它将返回到ServeState

1808
01:30:39,050 --> 01:30:41,100
一旦发生这种情况 

1809
01:30:41,100 --> 01:30:47,270
然后 这就是实际进展发生的地方 

1810
01:30:47,270 --> 01:30:51,450
当我们转到ServeState时 我们有自己的级别 但我们想要添加一个 

1811
01:30:51,450 --> 01:30:57,320
因此 当我们触发到下一个状态的转换时 我们需要做的就是

1812
01:30:57,320 --> 01:31:01,550
在这里将级别递增1 并创建

1813
01:31:01,550 --> 01:31:05,470
一个新的地图 因为砖块需要重新开始 因为我们有一个新的关卡 

1814
01:31:05,470 --> 01:31:07,680
自我 级别加一 

1815
01:31:07,680 --> 01:31:12,820
这将会产生 哦 我们已经从第一级到第二级的效果

1816
01:31:12,820 --> 01:31:17,480
当我们在PlayState和VictoryState之间穿梭时 会有三到四个人等等

1817
01:31:17,480 --> 01:31:19,110
回到ServeState 

1818
01:31:19,110 --> 01:31:21,420
那么 对这一切是如何运作的有什么问题吗？

1819
01:31:21,420 --> 01:31:21,920
是 

1820
01:31:21,920 --> 01:31:24,545
观众：你需要担心垃圾回收吗？

1821
01:31:24,545 --> 01:31:26,294
所有的砖块吗？

1822
01:31:26,294 --> 01:31:28,211
或者这是由爱情引擎以某种方式处理的？

1823
01:31:28,211 --> 01:31:30,377
科尔顿·奥格登：垃圾收集是由Love处理的 

1824
01:31:30,377 --> 01:31:31,060
是 

1825
01:31:31,060 --> 01:31:31,560
嗯 

1826
01:31:31,560 --> 01:31:32,760
观众：[听不见]

1827
01:31:32,760 --> 01:31:33,510
科尔顿·奥格登：是的 

1828
01:31:33,510 --> 01:31:37,550
因为问题是 你需要担心垃圾收集吗？

1829
01:31:37,550 --> 01:31:40,880
当我们清理砖块并添加新砖的时候？

1830
01:31:40,880 --> 01:31:45,950
砖桌 这张桌子 它是

1831
01:31:45,950 --> 01:31:48,950
被分配到一张全新的桌子上 这张桌子来自velmap.createmap 

1832
01:31:48,950 --> 01:31:51,950
当不存在对现有表的引用时 

1833
01:31:51,950 --> 01:31:54,290
Lua的垃圾收集器将在任何地方触发

1834
01:31:54,290 --> 01:31:57,410
它被设置为动态触发和清除所有这些 

1835
01:31:57,410 --> 01:32:00,050
就像Java的工作方式一样 

1836
01:32:00,050 --> 01:32:02,810
几乎一模一样 

1837
01:32:02,810 --> 01:32:06,170
还有其他问题吗？

1838
01:32:06,170 --> 01:32:07,690
好的 

1839
01:32:07,690 --> 01:32:10,020
所以我们有进步 

1840
01:32:10,020 --> 01:32:11,500
为了速度 我不做演示 

1841
01:32:11,500 --> 01:32:14,499
这也需要一段时间 因为我们必须清除整个关卡

1842
01:32:14,499 --> 01:32:16,030
更上一层楼 

1843
01:32:16,030 --> 01:32:17,680
但这就是这种行为的运作方式 

1844
01:32:17,680 --> 01:32:22,780
这种情况的下一种迭代是高分 

1845
01:32:22,780 --> 01:32:30,040
我将进行测试 以确保这是否真的有效 

1846
01:32:30,040 --> 01:32:31,730
我知道我改变了一些东西 

1847
01:32:31,730 --> 01:32:32,230
嗯 

1848
01:32:32,230 --> 01:32:33,169
这么高的分数 

1849
01:32:33,169 --> 01:32:34,210
让我们调试一下 

1850
01:32:34,210 --> 01:32:41,863
因此 在Breakout 10中 HighScoreState第38行 

1851
01:32:44,750 --> 01:32:46,730
所以 HighScoreState 

1852
01:32:49,780 --> 01:32:54,030
然后问题是[INAUDIBLE]索引领域的高分 

1853
01:32:54,030 --> 01:32:56,270
零值 

1854
01:32:56,270 --> 01:32:57,000
好的 

1855
01:32:57,000 --> 01:32:59,620
所以这意味着--

1856
01:32:59,620 --> 01:33:00,120
好的 

1857
01:33:00,120 --> 01:33:03,420
我想我可能知道问题所在 但这是因为我

1858
01:33:03,420 --> 01:33:06,570
已转换为新用户 该新用户在此上没有活动的已保存文件 

1859
01:33:06,570 --> 01:33:12,780
因此 将过渡到love.file系统的方式 它

1860
01:33:12,780 --> 01:33:17,910
它引入的主要新事物是《突破10》的S--所以写文件

1861
01:33:17,910 --> 01:33:22,429
到您的文件系统的操作使用love.filessystem完成[INAUDIBLE] 

1862
01:33:22,429 --> 01:33:23,470
有几件事 

1863
01:33:23,470 --> 01:33:28,870
所以Love会自动给你一个目录 一个保存的目录

1864
01:33:28,870 --> 01:33:30,120
这几乎是硬编码 

1865
01:33:30,120 --> 01:33:33,960
关于如何不使用该目录 有几个例外 

1866
01:33:33,960 --> 01:33:36,480
但它假定您一直在使用该目录 

1867
01:33:36,480 --> 01:33:42,750
除了极少数例外 您将始终使用该文件夹 

1868
01:33:42,750 --> 01:33:47,460
它就像Windows上的本地应用程序数据 以及应用程序支持 

1869
01:33:47,460 --> 01:33:50,850
以及您在Mac上的应用程序的名称 

1870
01:33:50,850 --> 01:33:53,490
但它是Love拥有读写权限的子文件夹

1871
01:33:53,490 --> 01:33:55,650
用于您的文件系统上的文件 

1872
01:33:55,650 --> 01:33:59,940
您可以检查它是否与love.filesystem.存在于某个路径中 

1873
01:33:59,940 --> 01:34:03,870
您可以使用一些数据写入该路径 这些数据是字符串值 

1874
01:34:03,870 --> 01:34:08,140
然后love.filesystem.line是一个迭代器 

1875
01:34:08,140 --> 01:34:11,040
这将允许您查看任何数据 

1876
01:34:11,040 --> 01:34:12,720
在给定位置的文件中 

1877
01:34:12,720 --> 01:34:13,395
是 

1878
01:34:13,395 --> 01:34:16,010
观众：[听不见]

1879
01:34:16,010 --> 01:34:17,010
科尔顿·奥格登：是的 

1880
01:34:17,010 --> 01:34:20,930
观众：如果你[INAUDIBLE]

1881
01:34:20,930 --> 01:34:21,930
科尔顿·奥格登：应该是这样 

1882
01:34:21,930 --> 01:34:24,150
实际上 我们现在可以把它拉出来看看 

1883
01:34:24,150 --> 01:34:28,500
因为我知道他们的2D爱情--

1884
01:34:28,500 --> 01:34:30,180
因此 文件系统 

1885
01:34:30,180 --> 01:34:35,910
所以问题是他把他的.

1886
01:34:35,910 --> 01:34:39,390
当你将Love应用程序移植到iPhone上时 

1887
01:34:39,390 --> 01:34:43,440
它会有同样的行为吗 如果你是--

1888
01:34:47,867 --> 01:34:50,700
在iPhone上 它会有同样的保存目录行为吗？

1889
01:34:50,700 --> 01:34:53,010
而且看起来它还没有正式出现在这里 

1890
01:34:53,010 --> 01:34:57,840
我知道有一个用于Love2D的iOS端口 

1891
01:34:57,840 --> 01:35:02,458
或者将其发送到Love2D的能力 

1892
01:35:02,458 --> 01:35:05,610
观众：[听不见]

1893
01:35:05,610 --> 01:35:07,110
科尔顿·奥格登：我想是的 

1894
01:35:07,110 --> 01:35:08,359
它可能有某种--

1895
01:35:08,359 --> 01:35:14,040
我并不完全熟悉iOS是如何处理本地存储的 

1896
01:35:14,040 --> 01:35:18,210
但我假设只是从桌面抽象出来的方式

1897
01:35:18,210 --> 01:35:20,460
而对于Android 它也是为iOS抽象的 

1898
01:35:20,460 --> 01:35:22,320
我自己还没有测试过 

1899
01:35:22,320 --> 01:35:25,260
我会用这段代码做实验 看看有没有可能 

1900
01:35:25,260 --> 01:35:29,200
看看你能不能让它在持续的高分下发挥作用 

1901
01:35:29,200 --> 01:35:33,292
我知道iOS通常允许您在每个应用程序中存储少量数据

1902
01:35:33,292 --> 01:35:35,250
在某个地方 一个固定的地方 但我不是

1903
01:35:35,250 --> 01:35:37,920
完全确定这是即兴的事情 

1904
01:35:37,920 --> 01:35:40,400
我可以更深入地研究一下 然后想出一个--

1905
01:35:40,400 --> 01:35:41,609
观众：[听不见]

1906
01:35:41,609 --> 01:35:42,400
科尔顿·奥格登：是的 

1907
01:35:42,400 --> 01:35:45,180
我的意思是 不是来自第一手 因为我没有机器人 

1908
01:35:45,180 --> 01:35:47,280
但它有官方的Android支持 

1909
01:35:47,280 --> 01:35:50,840
所以我猜是的 但我还没测试过 

1910
01:35:50,840 --> 01:35:53,710
我还没有在Android上手动测试它来验证这一点 

1911
01:35:59,030 --> 01:36:00,190
不过 是的 

1912
01:36:00,190 --> 01:36:03,420
我相信--因为在之前的目录中 当它

1913
01:36:03,420 --> 01:36:05,690
展示了--

1914
01:36:05,690 --> 01:36:08,690
哦 实际上就在这上面 

1915
01:36:08,690 --> 01:36:09,750
这条路在这里 

1916
01:36:09,750 --> 01:36:14,640
这个数据/user/0/love2d.android 

1917
01:36:14,640 --> 01:36:15,300
文件保存 

1918
01:36:15,300 --> 01:36:18,990
在我看来 这是一条官方的道路

1919
01:36:18,990 --> 01:36:22,050
这些数据存储在Android设备上 供应用程序使用 

1920
01:36:22,050 --> 01:36:24,150
所以我还没有亲自测试过 

1921
01:36:24,150 --> 01:36:27,360
但如果你有一个机器人 你很好奇 或者可能是一个仿真器 

1922
01:36:27,360 --> 01:36:30,470
试一试 看看它是否奏效 

1923
01:36:30,470 --> 01:36:32,970
哦 这里甚至写着 有各种各样的保存地点 

1924
01:36:32,970 --> 01:36:35,760
如果它们不起作用 你可以看到实际位置

1925
01:36:35,760 --> 01:36:37,200
就是这里的这个功能 

1926
01:36:37,200 --> 01:36:39,540
Love.filesystem.get保存目录 

1927
01:36:39,540 --> 01:36:43,440
这可能也适用于iOS 所以我很想知道

1928
01:36:43,440 --> 01:36:45,360
这是否真的能解决这个问题 

1929
01:36:50,790 --> 01:36:51,300
嗯 

1930
01:36:51,300 --> 01:36:52,260
这就是要点所在 

1931
01:36:52,260 --> 01:36:55,530
通过使用love.filessystem抽象 我们可以读写文件 

1932
01:36:55,530 --> 01:36:58,470
然后我们可以直接粘贴 也可以直接保存任何数据

1933
01:36:58,470 --> 01:37:02,520
我们想要那个目录中的任何地方 

1934
01:37:02,520 --> 01:37:06,090
我们可以在那里创建文件 然后使用这些文件来存储我们的

1935
01:37:06,090 --> 01:37:10,440
你知道 游戏世界 或者角色简介 或者诸如此类的东西 

1936
01:37:10,440 --> 01:37:14,445
我们将如何实施一份类似高分名单的计划？

1937
01:37:21,290 --> 01:37:21,860
所以我会找的 

1938
01:37:21,860 --> 01:37:24,360
这里有一张照片 

1939
01:37:24,360 --> 01:37:27,320
所以我们有10分 

1940
01:37:27,320 --> 01:37:29,390
我们就假设这个问题已经解决了 

1941
01:37:29,390 --> 01:37:34,650
每个分数都有一个名称 然后每个分数都有一个实际分数 

1942
01:37:34,650 --> 01:37:39,230
所以我们真正需要做的就是最终存储这些名字

1943
01:37:39,230 --> 01:37:42,190
然后是比分 

1944
01:37:42,190 --> 01:37:47,680
观众：[听不见]

1945
01:37:47,680 --> 01:37:49,180
科尔顿·奥格登：所以我们将使用一个数组 

1946
01:37:49,180 --> 01:37:53,371
他们的回答是 我们将使用按该分数排序的数组 

1947
01:37:53,371 --> 01:37:53,870
嗯 

1948
01:37:53,870 --> 01:37:55,120
从本质上说 就是这样 

1949
01:37:55,120 --> 01:37:57,560
我们只需要保留一个计分表 每个表

1950
01:37:57,560 --> 01:37:59,069
将会有一张小桌子 

1951
01:37:59,069 --> 01:38:00,860
这些条目中的每一个 从一到十

1952
01:38:00,860 --> 01:38:02,870
将会有一个名字和一个分数 

1953
01:38:02,870 --> 01:38:05,300
然后 一旦我们完成了应用程序 

1954
01:38:05,300 --> 01:38:07,790
我们将只使用love.filesystem.write 

1955
01:38:07,790 --> 01:38:10,460
我们必须将所有这些内容转换为一个字符串

1956
01:38:10,460 --> 01:38:15,200
因为我们不能只拿一张桌子 然后把它吐到一个文件里 

1957
01:38:15,200 --> 01:38:18,230
我们必须把它变成某种我们可以拯救的形式

1958
01:38:18,230 --> 01:38:20,880
然后以某种方式重新装填 

1959
01:38:20,880 --> 01:38:24,295
你认为什么是最有效的方式 或者我们可以做到这一点的一种方式？

1960
01:38:28,950 --> 01:38:31,995
可能只是一个新的以行分隔的列表 

1961
01:38:31,995 --> 01:38:33,870
我在这个应用程序中这样做的方式

1962
01:38:33,870 --> 01:38:39,570
就是名字 然后是新行、分数、新行、名字、新行、分数 

1963
01:38:39,570 --> 01:38:41,280
10 也就是20排 

1964
01:38:41,280 --> 01:38:43,130
这就完成了工作 

1965
01:38:43,130 --> 01:38:46,772
假设您没有篡改文件 那么一切都应该正常工作 

1966
01:38:46,772 --> 01:38:48,480
您还可以编写其他代码

1967
01:38:48,480 --> 01:38:51,845
说 哦 如果有分数 那就是全部

1968
01:38:51,845 --> 01:38:53,970
乱码 我们没有足够的分数 那么很可能

1969
01:38:53,970 --> 01:38:55,500
应该相应地呈现它 

1970
01:38:55,500 --> 01:38:59,272
我的代码执行类似的操作 但不完全是这样 

1971
01:39:02,370 --> 01:39:06,240
相关代码--我将对其进行简单介绍 

1972
01:39:06,240 --> 01:39:08,640
如果我们在看--这是突破口11 对吗？

1973
01:39:08,640 --> 01:39:09,140
嗯 

1974
01:39:09,140 --> 01:39:11,550
哦 不 这是《突破10》 

1975
01:39:11,550 --> 01:39:14,850
所以在《突破10》中 我们必须加载所有的高分

1976
01:39:14,850 --> 01:39:16,810
在Main.Lua中 它就在这里 

1977
01:39:16,810 --> 01:39:19,680
因此将身份设置为Breakout或创建一个名为Breakout文件夹

1978
01:39:19,680 --> 01:39:22,170
我们可以在其中保存和读取文件 

1979
01:39:22,170 --> 01:39:24,450
如果它不存在 那么就创建它们 

1980
01:39:24,450 --> 01:39:26,910
在这种情况下 我只是输入CTO作为我的首字母 

1981
01:39:26,910 --> 01:39:28,870
然后我乘以1000 

1982
01:39:28,870 --> 01:39:30,990
所以从一万降到一千 

1983
01:39:30,990 --> 01:39:33,314
只是非常简单的数据 

1984
01:39:33,314 --> 01:39:34,980
正在写入名为Breakout.lst的文件 

1985
01:39:34,980 --> 01:39:36,300
它可以是你想要的任何东西 

1986
01:39:36,300 --> 01:39:40,620
我们所做的只是从数据或文件中读取行 

1987
01:39:40,620 --> 01:39:42,540
然后这是如果它不存在的话 

1988
01:39:42,540 --> 01:39:50,100
如果它确实存在 那么我们将对其进行迭代

1989
01:39:50,100 --> 01:39:53,730
使用love.filesystem.line 它将接受一个文件

1990
01:39:53,730 --> 01:39:56,460
然后基本上把它分成新的行 然后给你

1991
01:39:56,460 --> 01:39:58,200
所有这些行的迭代器 

1992
01:39:58,200 --> 01:40:00,540
所以它可以说 好的 如果它是一个名字 哪一个

1993
01:40:00,540 --> 01:40:06,120
也就是说 如果名单上有一个、三个、五个或七个 

1994
01:40:06,120 --> 01:40:08,990
然后将名称设置为--

1995
01:40:08,990 --> 01:40:11,460
我们使用的是字符串.sub.以防他们

1996
01:40:11,460 --> 01:40:14,270
写一些长名字 或者写一些长名字--他们做不到

1997
01:40:14,270 --> 01:40:17,640
通过我们的游戏 但如果它以某个长名称写入文件 

1998
01:40:17,640 --> 01:40:19,770
它应该被截断为三个字符

1999
01:40:19,770 --> 01:40:22,360
这样我们就可以适当地展示它 

2000
01:40:22,360 --> 01:40:24,850
否则 如果我们不是在名字线上 

2001
01:40:24,850 --> 01:40:28,140
如果我们在一条奇数或偶数行上 

2002
01:40:28,140 --> 01:40:32,140
我们应该认为这是一个分数 只使用数字 

2003
01:40:32,140 --> 01:40:37,154
因为我们使用字符串数据 如果我们尝试赋值 

2004
01:40:37,154 --> 01:40:39,570
对字符串数据进行任何类型的数字比较 

2005
01:40:39,570 --> 01:40:41,790
我们将不得不这样做 以比较高分 

2006
01:40:41,790 --> 01:40:44,160
它不会起作用 因为它会看到有弦 

2007
01:40:44,160 --> 01:40:45,330
所以我们在这里用数字 

2008
01:40:45,330 --> 01:40:46,819
只是一个简单的Lua函数 

2009
01:40:46,819 --> 01:40:47,610
然后就是这样 

2010
01:40:47,610 --> 01:40:50,430
然后我们只需返回分数 

2011
01:40:50,430 --> 01:40:53,490
然后我会找出问题的起因 

2012
01:40:53,490 --> 01:40:56,880
然后尽快把它推到回购上 

2013
01:40:56,880 --> 01:41:00,690
但这样做的效果是 我们实际上能够加载我们所有的高分

2014
01:41:00,690 --> 01:41:03,790
并在游戏开始时展示它们 

2015
01:41:03,790 --> 01:41:08,680
它不需要考虑能够实际输入我们的分数 

2016
01:41:08,680 --> 01:41:12,870
因此 我们可以使用Breakout 11来实现这一点 如果运行回购 您可以看到这一点 

2017
01:41:12,870 --> 01:41:17,580
您可以通过测试将初始分数分配给某个值 例如10,000

2018
01:41:17,580 --> 01:41:19,890
或者20,000 然后故意输掉 而你

2019
01:41:19,890 --> 01:41:21,990
了解它的实际工作原理 

2020
01:41:21,990 --> 01:41:24,010
但从本质上说 这只是一种街机风格 

2021
01:41:24,010 --> 01:41:26,760
你知道吗 你只有三个字可以输入你的名字 

2022
01:41:26,760 --> 01:41:31,530
那么 有谁知道我们是如何存储这些东西的 

2023
01:41:31,530 --> 01:41:32,670
或者可以提出一个想法？

2024
01:41:36,720 --> 01:41:41,100
所以我们有三个角色 我们想--

2025
01:41:41,100 --> 01:41:45,330
理想情况下 如果我们是 假设我想在第一个数上转到C 

2026
01:41:45,330 --> 01:41:52,526
比方说 我按了两次 这样我就到了C 从A到C怎么样？

2027
01:41:52,526 --> 01:41:54,610
你可以只说 你可以只渲染

2028
01:41:54,610 --> 01:41:58,900
我想要渲染角色A 角色A 角色A 

2029
01:41:58,900 --> 01:42:01,700
但它怎么知道你什么时候想去B、C或D呢？

2030
01:42:01,700 --> 01:42:15,116
观众：[听不见]

2031
01:42:15,116 --> 01:42:16,990
科尔顿·奥格登：投球是 你可以创造

2032
01:42:16,990 --> 01:42:19,406
一个包含所有字符的表 并对其进行迭代 

2033
01:42:19,406 --> 01:42:22,450
你绝对可以做到的 

2034
01:42:22,450 --> 01:42:23,740
它有一点笨重 

2035
01:42:23,740 --> 01:42:24,880
这可能就是...

2036
01:42:24,880 --> 01:42:28,720
事实上 这可能不是街机系统当年的做法 

2037
01:42:28,720 --> 01:42:38,680
因为在《越狱11》中我们要做的是

2038
01:42:38,680 --> 01:42:43,780
添加了一个名为EnterHighScoreState的新状态 

2039
01:42:43,780 --> 01:42:46,390
如果你还记得的话 CS50教授了这一点 

2040
01:42:46,390 --> 01:42:51,260
但归根结底 所有类型的字符都只是数字 

2041
01:42:51,260 --> 01:42:53,740
ASCI 

2042
01:42:53,740 --> 01:42:58,030
在这个例子中 如果你还记得的话 65是大写的A 

2043
01:42:58,030 --> 01:43:03,640
所以我们要做的就是画出那个角色

2044
01:43:03,640 --> 01:43:06,590
转换为字符串是或字符 

2045
01:43:06,590 --> 01:43:11,740
我们在下面的DRAW函数中简单地完成这项工作 

2046
01:43:11,740 --> 01:43:19,962
如果我们做string.char at char就是3 

2047
01:43:19,962 --> 01:43:22,420
所做的一切只会产生这样的效果

2048
01:43:22,420 --> 01:43:25,660
然后将其转换为字符 

2049
01:43:25,660 --> 01:43:27,520
那么我们所需要做的就是什么？

2050
01:43:27,520 --> 01:43:33,006
当我们想要从A到B B到C C到D 

2051
01:43:33,006 --> 01:43:35,654
观众：[听不见]

2052
01:43:35,654 --> 01:43:36,570
科尔顿·奥格登：没错 

2053
01:43:36,570 --> 01:43:39,165
但如果我们在A 我们想往下走 会发生什么？

2054
01:43:39,165 --> 01:43:41,102
观众：[听不见]

2055
01:43:41,102 --> 01:43:42,060
科尔顿·奥格登：我们会的 

2056
01:43:42,060 --> 01:43:49,650
所以 如果我们在A 那么如果我们向下按 我们想要到Z 

2057
01:43:49,650 --> 01:43:50,670
其中的逻辑就在这里 

2058
01:43:53,580 --> 01:43:59,280
但是我们增加了代码 如果它大于90 也就是Z 

2059
01:43:59,280 --> 01:44:00,670
那我们应该把它调回65 

2060
01:44:00,670 --> 01:44:01,560
我们将循环回A 

2061
01:44:01,560 --> 01:44:02,820
这里也是一样的 

2062
01:44:02,820 --> 01:44:06,630
如果我们按下 我们在A 我们必须回到Z 

2063
01:44:06,630 --> 01:44:08,130
所以我们把它设为90 

2064
01:44:08,130 --> 01:44:09,690
如此简单的环回逻辑 

2065
01:44:09,690 --> 01:44:11,940
我们只是把它画出来 我们突出显示 

2066
01:44:11,940 --> 01:44:14,940
一旦我们这样做了 用户就按Enter键 

2067
01:44:14,940 --> 01:44:19,380
实际上 我们过渡到High ScoreState

2068
01:44:19,380 --> 01:44:22,410
因为只有当他们进入新的最高分时 这种状态才会触发 

2069
01:44:22,410 --> 01:44:26,740
这意味着我们需要登记到VictoryState 或者不是VictoryState 

2070
01:44:26,740 --> 01:44:29,070
而是在GameOverState中 无论是否

2071
01:44:29,070 --> 01:44:33,540
他们的分数比任何一家商店都要高 

2072
01:44:33,540 --> 01:44:36,000
引用不引用 全球分数表 

2073
01:44:36,000 --> 01:44:39,558
然后我们认为我们现在是如何来回传递分数的呢？

2074
01:44:42,510 --> 01:44:45,388
有人记得我们是如何跟踪应用程序状态的吗？

2075
01:44:48,280 --> 01:44:55,190
观众：[听不见]

2076
01:44:55,190 --> 01:44:55,940
科尔顿·奥格登：是的 

2077
01:44:55,940 --> 01:44:57,270
在更改功能中 

2078
01:44:57,270 --> 01:44:59,540
所以我们要做的就是跟踪--加载

2079
01:44:59,540 --> 01:45:01,490
我们在比赛开始时的高分 

2080
01:45:01,490 --> 01:45:03,360
把它们一直传到最后 

2081
01:45:03,360 --> 01:45:07,560
最后--我们还可以将它们加载到EnterHighScoreState中 

2082
01:45:07,560 --> 01:45:11,390
但我们需要跟踪我们在GameOverState中的高分是多少

2083
01:45:11,390 --> 01:45:13,562
这样我们就知道 哦 我得了高分 

2084
01:45:13,562 --> 01:45:16,520
与其转换回StartState 不如让我们转换

2085
01:45:16,520 --> 01:45:22,130
添加到EnterHighScoreState 以便用户可以将他们的高分添加到列表中 

2086
01:45:22,130 --> 01:45:30,770
然后一旦他们进入了他们的高分 也就是这里 

2087
01:45:30,770 --> 01:45:35,940
我们只需将其再次写入此文件 

2088
01:45:35,940 --> 01:45:39,760
编译一个分数字符串 它接受我们的分数的名称和分数 

2089
01:45:39,760 --> 01:45:43,000
我们拿我们当时的分数 那是--

2090
01:45:43,000 --> 01:45:45,220
我们倒着看我们的分数表

2091
01:45:45,220 --> 01:45:47,982
当我们找到比我们的分数低的分数时 

2092
01:45:47,982 --> 01:45:51,190
我们只是跟踪这个指数 直到我们得到一个比我们的指数更高的指数 

2093
01:45:51,190 --> 01:45:54,160
在这种情况下 一加一 该指数加一

2094
01:45:54,160 --> 01:45:55,600
是我们应该改写的内容 

2095
01:45:55,600 --> 01:45:59,050
因此 我们相应地将下面的所有其他部分移位 

2096
01:45:59,050 --> 01:46:01,907
如果好奇的话 我们在这节课上也会这么做 

2097
01:46:01,907 --> 01:46:04,240
所以我要轻松地看完最后一对选手 

2098
01:46:04,240 --> 01:46:07,000
Ppale SELECT更新只是一种模糊状态

2099
01:46:07,000 --> 01:46:13,330
这让我们可以在我们的游戏中添加一些元素 比如用户选择 

2100
01:46:13,330 --> 01:46:18,850
在我们的PaddleSelectState中 我们立即进行转换 

2101
01:46:18,850 --> 01:46:21,370
而不是现在去[INAUDIBLE]PlayState 

2102
01:46:21,370 --> 01:46:26,140
当我们点击开始游戏时 我们将从开始到划桨选择 

2103
01:46:26,140 --> 01:46:27,310
所以我们要去...

2104
01:46:27,310 --> 01:46:29,200
然后是Paddle Select类本身 

2105
01:46:32,170 --> 01:46:35,080
CurrentPaddle得到一个 然后它基本上

2106
01:46:35,080 --> 01:46:42,210
我们在这里画两个箭头

2107
01:46:42,210 --> 01:46:47,260
所以如果我们是第一名--在这个例子中 我想我们是第三名--

2108
01:46:47,260 --> 01:46:49,990
那么这两个箭头都将是完全不透明的 

2109
01:46:49,990 --> 01:46:53,320
但如果我们在左边或右边 他们应该变暗对我们说 

2110
01:46:53,320 --> 01:46:55,528
我们不能再左右移动了因为我们

2111
01:46:55,528 --> 01:47:00,100
在索引1或4或5处 只有那么多颜色 

2112
01:47:00,100 --> 01:47:02,170
然后渲染这个颜色变量

2113
01:47:02,170 --> 01:47:07,976
就是用我们之前用过的四元表 

2114
01:47:07,976 --> 01:47:09,100
然后只是指令 

2115
01:47:09,100 --> 01:47:13,360
然后从那里我们将最终过渡到ServeState

2116
01:47:13,360 --> 01:47:18,100
而不是从StartState转到ServeState 

2117
01:47:18,100 --> 01:47:20,590
所有的代码都在这里 

2118
01:47:20,590 --> 01:47:22,540
我们在放音效 

2119
01:47:22,540 --> 01:47:26,654
然后确保我们也播放不同的声音

2120
01:47:26,654 --> 01:47:29,320
效果取决于它们是在左边还是右边 

2121
01:47:29,320 --> 01:47:30,880
如果他们在左边想往左走 

2122
01:47:30,880 --> 01:47:33,940
它应该像一个声音 听起来有点粗糙 

2123
01:47:33,940 --> 01:47:35,680
让他们知道不能向左走

2124
01:47:35,680 --> 01:47:38,350
而右边缘则相反 

2125
01:47:38,350 --> 01:47:42,770
一旦他们按下回车键

2126
01:47:42,770 --> 01:47:46,940
他们想要 他们会得到球拍 

2127
01:47:46,940 --> 01:47:50,770
我们将实例化一个paddle 将其传递到ServeState 

2128
01:47:50,770 --> 01:47:53,710
and we're going to take current当前Paddle桨from the state状态 which哪一个

2129
01:47:53,710 --> 01:47:59,920
就是他们在不同的拨片之间滚动得到的值 

2130
01:47:59,920 --> 01:48:06,280
然后是最后一个更新 这是几乎每堂课我最喜欢的部分

2131
01:48:06,280 --> 01:48:09,850
我想是音乐的更新 

2132
01:48:09,850 --> 01:48:15,130
而所有这一切实际上只是音乐集发挥在主要.lua 

2133
01:48:15,130 --> 01:48:19,410
然后将循环设置为真 这样就有了一个博弈

2134
01:48:19,410 --> 01:48:20,660
这是我们的Paddle Select 

2135
01:48:20,660 --> 01:48:25,960
请注意 左右两边的箭头是半透明的 

2136
01:48:25,960 --> 01:48:30,310
听起来有点难 但当我现在按下

2137
01:48:30,310 --> 01:48:33,890
有点像是有一点粗糙的声音 

2138
01:48:33,890 --> 01:48:35,080
我们选择红色 

2139
01:48:35,080 --> 01:48:37,900
我们转到第一级 然后转换到ServeState

2140
01:48:37,900 --> 01:48:43,240
PaddleSelectState 然后我们就像往常一样玩游戏 

2141
01:48:43,240 --> 01:48:45,060
这基本上就是它的全部 

2142
01:48:45,060 --> 01:48:48,018
有几个功能我们没有时间去真正了解

2143
01:48:48,018 --> 01:48:51,374
比如确保我们在一定数量的点数

2144
01:48:51,374 --> 01:48:53,290
已经过去了 但我鼓励你去看看

2145
01:48:53,290 --> 01:48:56,290
当你触发一次命中的时候 

2146
01:48:56,290 --> 01:48:58,930
在PlayState中有一些逻辑可以说 哦 

2147
01:48:58,930 --> 01:49:01,467
如果他们已经超过了当前的复苏门槛 

2148
01:49:01,467 --> 01:49:04,300
让我们为球员增加一颗心 你知道的 让他们继续比赛 

2149
01:49:04,300 --> 01:49:06,008
只是为了奖励他们的高分 

2150
01:49:08,470 --> 01:49:10,410
下一次我们将介绍一些概念 

2151
01:49:10,410 --> 01:49:11,300
所以基本的着色器 

2152
01:49:11,300 --> 01:49:13,550
着色器就像可以在显卡上运行的小程序

2153
01:49:13,550 --> 01:49:16,210
并制作奇特的效果 但我们不会深入到太多细节 

2154
01:49:16,210 --> 01:49:17,140
匿名函数 

2155
01:49:17,140 --> 01:49:21,119
我们在Lua中看到了很多关于Love的匿名函数 

2156
01:49:21,119 --> 01:49:23,410
它们只是没有名称的函数 您可以

2157
01:49:23,410 --> 01:49:26,410
将它们用作函数参数 并用它们做各种很酷的事情 

2158
01:49:26,410 --> 01:49:29,140
下周我们做事的时候 我们会用它们做回调

2159
01:49:29,140 --> 01:49:31,480
比如Twening 它正在获得一些价值

2160
01:49:31,480 --> 01:49:35,190
并让它随着时间的推移插入到其他东西中 

2161
01:49:35,190 --> 01:49:38,440
因为现在我们基本上只是根据速度进行更新 

2162
01:49:38,440 --> 01:49:40,609
但我们并没有真正按照时间来做任何事情 

2163
01:49:40,609 --> 01:49:42,400
所以我们将更详细地了解这一点

2164
01:49:42,400 --> 01:49:46,600
下周将有一个名为Timer的图书馆 这真的很棒 

2165
01:49:46,600 --> 01:49:50,050
允许您对事物进行计时 然后将事物链接在一起 

2166
01:49:50,050 --> 01:49:52,670
如果熟悉的话 我们会报道第三场比赛 

2167
01:49:52,670 --> 01:49:54,130
这基本上就是糖果粉碎传奇 

2168
01:49:54,130 --> 01:49:57,130
我们将使用不同的瓷砖设置 但这是相同的想法 

2169
01:49:57,130 --> 01:49:59,500
我们将不得不计算如何真正找出

2170
01:49:59,500 --> 01:50:02,500
无论我们是否在网格中找到了匹配 我们的瓷砖网格 

2171
01:50:02,500 --> 01:50:06,820
然后相应地移动这些块 然后做所有其他逻辑 加分数 

2172
01:50:06,820 --> 01:50:10,810
然后基本上 因为它是糖果粉碎传奇和游戏的基础

2173
01:50:10,810 --> 01:50:13,720
对于它的本质 我们将不得不讨论如何在某种程度上生成

2174
01:50:13,720 --> 01:50:17,076
这些地图在程序上具有动态布局的瓦片 

2175
01:50:17,076 --> 01:50:19,450
在某种程度上 也不是从任何火柴开始

2176
01:50:19,450 --> 01:50:22,199
因为那就没有任何意义了 因为比赛已经

2177
01:50:22,199 --> 01:50:23,230
来解决问题 

2178
01:50:23,230 --> 01:50:26,740
如果下周有时间的话我们会抽出一点时间

2179
01:50:26,740 --> 01:50:28,810
再次谈论精灵艺术和调色板 

2180
01:50:28,810 --> 01:50:32,490
也许我会向你们展示如何将图像从一个

2181
01:50:32,490 --> 01:50:35,200
调色板到另一个 比如 我使用的一个程序 Aseprite 

2182
01:50:35,200 --> 01:50:40,200
但你可以在任何类型的大型照片编辑软件中做到这一点 

2183
01:50:40,200 --> 01:50:44,990
第二项任务是《越狱》的几个扩展 

2184
01:50:44,990 --> 01:50:50,100
所以如果你注意到床单上有几个小精灵

2185
01:50:50,100 --> 01:50:51,240
在底部--

2186
01:50:51,240 --> 01:50:53,580
所以 去掉四边形轮廓吧 

2187
01:50:53,580 --> 01:50:56,580
所以下面这些小东西 我猜 

2188
01:50:56,580 --> 01:50:57,909
它们应该是能量充沛的 

2189
01:50:57,909 --> 01:50:58,950
它们看起来像是通电了 

2190
01:50:58,950 --> 01:51:01,790
但pset的目标是实现通电 

2191
01:51:01,790 --> 01:51:05,939
一旦启动 当你抓住它的时候 

2192
01:51:05,939 --> 01:51:08,730
你会得到两个额外的球 或者实际上你想要多少球 

2193
01:51:08,730 --> 01:51:12,270
它将在你的那个之外产生 并自己检测碰撞 

2194
01:51:12,270 --> 01:51:14,760
所以你会有几个 他们会为你得分 

2195
01:51:14,760 --> 01:51:18,450
当然 只有当最后一个球落在屏幕表面以下时

2196
01:51:18,450 --> 01:51:20,700
你是否应该触发一场游戏结束 

2197
01:51:20,700 --> 01:51:22,930
然后我想让你们加上--这也会

2198
01:51:22,930 --> 01:51:24,763
比说明书更详细--但我会

2199
01:51:24,763 --> 01:51:26,970
喜欢你把成长和萎缩加到桨上 

2200
01:51:26,970 --> 01:51:29,925
所以目前 我们有四种不同大小的球拍 

2201
01:51:29,925 --> 01:51:31,230
但我们没有使用它们 

2202
01:51:31,230 --> 01:51:34,380
所以如果我们得到了足够的分数或我们失去了分数 那就好了

2203
01:51:34,380 --> 01:51:37,890
分数 而不是生活 我们增加或减少桨的大小

2204
01:51:37,890 --> 01:51:40,260
因此 我们要引入另一个层面的挑战

2205
01:51:40,260 --> 01:51:42,630
或者缺乏挑战 

2206
01:51:42,630 --> 01:51:46,620
最后 最后一部分也在精灵表中 

2207
01:51:46,620 --> 01:51:54,040
这里有一个钥匙块 这里有一个钥匙电源

2208
01:51:54,040 --> 01:52:00,504
所以让力量来 用你的桨把力量捡起来 

2209
01:52:00,504 --> 01:52:02,670
只有当你有了这种力量 

2210
01:52:02,670 --> 01:52:06,069
能用钥匙打破障碍 

2211
01:52:06,069 --> 01:52:07,860
你应该考虑到这点

2212
01:52:07,860 --> 01:52:09,360
你也可以在生成水平时使用 

2213
01:52:09,360 --> 01:52:12,420
所以你也必须用水平仪弄脏你的手 

2214
01:52:12,420 --> 01:52:14,670
但总的来说 这就是突破 

2215
01:52:14,670 --> 01:52:16,170
我们下次见 

2216
01:52:16,170 --> 01:52:18,020
谢谢
