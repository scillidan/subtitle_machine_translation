
1
00:00:00,000 --> 00:00:02,465
[音乐播放]
[MUSIC PLAYING]

2
00:00:24,287 --> 00:00:25,370
大卫·J·马兰：好的 
DAVID J. MALAN: All right.

3
00:00:25,370 --> 00:00:28,730
这是CS50的S介绍用PYTHON编程 
This is CS50'S Introduction to Programming with Python.

4
00:00:28,730 --> 00:00:30,050
我叫大卫·马兰 
My name is David Malan.

5
00:00:30,050 --> 00:00:32,210
在过去的许多周里 我们专注于
And over these past many weeks have we focused

6
00:00:32,210 --> 00:00:36,020
关于函数和变量 然后是条件句和循环 
on functions and variables early on, then conditionals, and loops,

7
00:00:36,020 --> 00:00:39,030
和异常、一些库、单元测试文件
and exceptions, a bit of libraries, unit test file

8
00:00:39,030 --> 00:00:42,050
布局、正则表达式、面向对象编程
layout, regular expressions, object-oriented programming,

9
00:00:42,050 --> 00:00:43,520
真的 诸如此类 
and really, et cetera.

10
00:00:43,520 --> 00:00:45,770
事实上 这就是我们今天关注的地方
And indeed, that's where we focus today, is

11
00:00:45,770 --> 00:00:48,710
关于您可以使用Python和编程做的更多事情
on all the more that you can do with Python and programming

12
00:00:48,710 --> 00:00:52,410
更广泛地说 也超出了这些基本概念中的一些 
more generally beyond some of those fundamental concepts as well.

13
00:00:52,410 --> 00:00:55,340
事实上 如果您开始浏览有关Python的文档
In fact, if you start to flip through the documentation for Python

14
00:00:55,340 --> 00:00:59,570
以及它的所有形式 所有这些形式都可以在docs.python.org上访问 
and all of its form, all of which is as always accessible at docs.python.org,

15
00:00:59,570 --> 00:01:03,770
您将看到有关Python自己的教程和库的其他文档 
you'll see additional documentation on Python's own tutorial and library,

16
00:01:03,770 --> 00:01:05,510
它的参考 它的使用方法 
its reference, its how-to.

17
00:01:05,510 --> 00:01:09,540
在所有这些不同的文档以及其他更多的在线文档中 
And among all of those various documents as well as others more online,

18
00:01:09,540 --> 00:01:12,530
你会看到有一些我们没有完全触及的花边新闻 
you'll see that there's some tidbits that we didn't quite touch on.

19
00:01:12,530 --> 00:01:15,560
事实上 尽管我们在过去的几周里
And indeed, even though we themed these past several weeks

20
00:01:15,560 --> 00:01:19,430
围绕着相当广泛的主题 这些主题对做
of around fairly broad topics that are rather essential for doing

21
00:01:19,430 --> 00:01:22,160
事实证明 Python中的典型问题类型
typical types of problems in Python, it turns out

22
00:01:22,160 --> 00:01:25,460
还有相当多的其他功能 我们不一定
there's quite a number of other features as well, that we didn't necessarily

23
00:01:25,460 --> 00:01:27,950
涉及到 这不一定适合在任何
touch on, that didn't necessarily fit within any

24
00:01:27,950 --> 00:01:30,560
这些首要概念 或者可能有
of those overarching concepts, or might have

25
00:01:30,560 --> 00:01:33,770
如果我们在课程太早的时候做 那就有点太早了 
been a little too much too soon if we did them too early on in the course.

26
00:01:33,770 --> 00:01:36,320
所以 在今天 我们的最后一堂课 嗯 我们
And so, in today, our final lecture, well, we

27
00:01:36,320 --> 00:01:38,990
真正关注您可以使用Python做的更多事情
focus really on all the more that you can do with Python

28
00:01:38,990 --> 00:01:42,740
希望能激发你自学的胃口 
and hopefully whet your appetite for teaching yourself all the more to.

29
00:01:42,740 --> 00:01:45,680
例如 在Python的各种数据类型中 
For instance, among Python's various data types,

30
00:01:45,680 --> 00:01:49,130
还有另一个我们还没有机会使用的 那就是一套 
there's this other one that we haven't had occasion to yet use, namely, a set.

31
00:01:49,130 --> 00:01:52,040
在数学中 集合通常是值的集合
In mathematics, a set is typically a collection of values

32
00:01:52,040 --> 00:01:53,820
其中没有复制品 
wherein there are no duplicates.

33
00:01:53,820 --> 00:01:55,170
所以这并不是一份完整的清单 
So it's not quite a list.

34
00:01:55,170 --> 00:01:58,790
它比那更特别一点 因为不知何故 任何复制品都是
It's a bit more special than that in that somehow any duplicates are

35
00:01:58,790 --> 00:01:59,990
为你淘汰了 
eliminated for you.

36
00:01:59,990 --> 00:02:03,200
实际上 在Python中 这是一种实际的数据类型
Well, it turns out within Python, this is an actual data type

37
00:02:03,200 --> 00:02:05,690
您自己可以在代码中使用的 
that you yourself can use in your code.

38
00:02:05,690 --> 00:02:08,330
通过这里的文档 您是否可以
And via the documentation here, might you

39
00:02:08,330 --> 00:02:10,580
能够发现这是一个有用的问题
be able to glean that it's a useful problem

40
00:02:10,580 --> 00:02:13,430
如果您想以某种方式自动过滤掉重复项 
if you want to somehow automatically filter out duplicates.

41
00:02:13,430 --> 00:02:16,250
所以让我继续 转到VS代码这里 
So let me go ahead and go over to VS Code here.

42
00:02:16,250 --> 00:02:20,210
让我继续向你们展示一个我之前创建的文件 
And let me go ahead and show you a file that I created a bit of in advance,

43
00:02:20,210 --> 00:02:23,300
我们在这里有一个名为house.py的文件 
whereby we have a file here called houses.py.

44
00:02:23,300 --> 00:02:26,420
在House.py中 我已经开始准备了
And in houses.py, I already went ahead and whipped up

45
00:02:26,420 --> 00:02:29,990
其中的一大份学生名单是
a big list of students inside of which is

46
00:02:29,990 --> 00:02:33,470
一些词典 每本词典代表一个学生的名字
a number of dictionaries, each of which represents a student's name

47
00:02:33,470 --> 00:02:35,310
和豪斯分别 
and house respectively.

48
00:02:35,310 --> 00:02:37,080
现在 这是一本相当大的词典 
Now, this is a pretty sizable dictionary.

49
00:02:37,080 --> 00:02:39,560
因此 它适合于对相同的东西进行迭代 
And so, it lends itself to iteration over the same.

50
00:02:39,560 --> 00:02:42,810
假设这里的目标很简单 就是找出 
And suppose that the goal here was quite simply to figure out,

51
00:02:42,810 --> 00:02:46,735
那么 在哈利波特的世界里 霍格沃茨有哪些独特的房子呢？
well, what are the unique houses at Hogwarts in the world of Harry Potter?

52
00:02:46,735 --> 00:02:49,610
也许 如果不需要知道这些细节就好了
It would be nice, perhaps, to not have to know these kinds of details

53
00:02:49,610 --> 00:02:50,570
或者上网查一查 
or look them up online.

54
00:02:50,570 --> 00:02:54,500
在这里 我们有一组学生 尽管不是详尽的 所有的房子 
Here we have a set of students, albeit not exhaustive, with all of the houses.

55
00:02:54,500 --> 00:02:58,550
但是 在这些在座的学生中 他们居住的独特的房子是什么？
But among these students here, what are the unique houses in which they live?

56
00:02:58,550 --> 00:03:00,800
嗯 我当然可以 作为一个人 看看这个
Well, I could certainly, as a human, just eyeball this

57
00:03:00,800 --> 00:03:03,650
告诉你 是格兰芬多、斯莱特林和拉文克劳 
and tell you that it's, well, Gryffindor, Slytherin, and Ravenclaw.

58
00:03:03,650 --> 00:03:06,620
但是我们如何才能开始为这些学生编程呢？
But how can we go about doing it programmatically for these students

59
00:03:06,620 --> 00:03:07,520
也是?
as well?

60
00:03:07,520 --> 00:03:09,360
那么 让我们先采取一种方法 
Well, let's take one approach first here.

61
00:03:09,360 --> 00:03:11,240
让我到房子里去 
Let me go into houses.py.

62
00:03:11,240 --> 00:03:15,170
让我提议我们首先创建一个空名单怎么样
And let me propose that we first how about create an empty list

63
00:03:15,170 --> 00:03:20,390
所谓的房子 我将在其中唯一地积累每一所房子 
called houses in which I'm going to accumulate each of the houses uniquely.

64
00:03:20,390 --> 00:03:24,920
所以每次我重复这一系列词典的时候 
So every time I iterate through this list of dictionaries,

65
00:03:24,920 --> 00:03:28,830
如果我以前没见过一栋房子 我才会把它加到这个名单上 
I'm only going to add a house to this list if I haven't seen it before.

66
00:03:28,830 --> 00:03:30,020
那么我该怎么表达呢？
So how do I express that?

67
00:03:30,020 --> 00:03:34,130
好 让我重复一下所有的学生 在学生中 
Well, let me iterate over all of the students with for student in students,

68
00:03:34,130 --> 00:03:35,550
就像我们过去所做的那样 
as we've done in the past.

69
00:03:35,550 --> 00:03:37,200
现在让我问你一个问题
And let me ask you a question now.

70
00:03:37,200 --> 00:03:40,400
所以如果现在学生的房子--
So if the current student's house--

71
00:03:40,400 --> 00:03:43,550
注意我正在索引当前学生
and notice that I'm indexing into the current student

72
00:03:43,550 --> 00:03:46,580
因为我知道它们是字典或字典对象 
because I know they are a dictionary or dict object,

73
00:03:46,580 --> 00:03:51,830
如果那个学生的房子不在我的房子名单上
and if that student's house is not in my house's list,

74
00:03:51,830 --> 00:03:56,480
然后 缩进 我要说房子 附加 
then, indented, am I going to say houses.append,

75
00:03:56,480 --> 00:03:58,190
因为房子也是一个列表
because again, houses is a list.

76
00:03:58,190 --> 00:04:02,120
我要把那栋房子加到名单上 
And I'm going to append that particular house to the list.

77
00:04:02,120 --> 00:04:04,130
在最下面 让我继续
Then at the very bottom here, let me go ahead

78
00:04:04,130 --> 00:04:07,880
在这里做一些有趣的事情 
and do something somewhat interesting here and say, for each of the houses

79
00:04:07,880 --> 00:04:11,360
我可以说是房子 
that I've accumulated in, I could just say houses.

80
00:04:11,360 --> 00:04:14,917
但是如果我只说房子 那么一下子积累起来有什么意义呢？
But if I just say houses, what was the point of accumulating them all at once?

81
00:04:14,917 --> 00:04:16,709
我可以循环做一遍 
I could just do this whole thing in a loop.

82
00:04:16,709 --> 00:04:19,190
我们至少去把那些房子分类吧
Let's at least go about and sort those houses

83
00:04:19,190 --> 00:04:22,550
sorted 也就是按顺序进入字符串 
with sorted, which is going to the strings alphabetically.

84
00:04:22,550 --> 00:04:25,520
让我们继续打印每一栋房子 
And let's go ahead therein and print each of the houses.

85
00:04:25,520 --> 00:04:27,260
让我在我的终端窗口
Let me go ahead now in my terminal window

86
00:04:27,260 --> 00:04:29,715
运行houses.py的Python并按Enter键 
and run Python of houses.py and hit Enter.

87
00:04:29,715 --> 00:04:30,590
这就是了
And there we have it.

88
00:04:30,590 --> 00:04:34,220
格兰芬多 拉文克劳 斯莱特林按字母顺序排列 
Gryffindor, Ravenclaw, Slytherin in alphabetical order,

89
00:04:34,220 --> 00:04:37,280
即使在这上面的字典列表中 
even though in the list of dictionaries up here,

90
00:04:37,280 --> 00:04:40,960
从技术上讲 我们看到这些的顺序是格兰芬多 格兰芬多 
technically the order in which we saw these was Gryffindor, Gryffindor,

91
00:04:40,960 --> 00:04:43,190
格兰芬多 斯莱特林 拉文克劳 
Gryffindor, Slytherin, Ravenclaw.

92
00:04:43,190 --> 00:04:46,620
因此 我的代码似乎已经正确地对它们进行了排序 
So indeed, my code seems to have sorted them properly.

93
00:04:46,620 --> 00:04:48,110
所以这完全没问题 
So this is perfectly fine.

94
00:04:48,110 --> 00:04:50,600
这是解决这个问题的一种方法 
And it's one way of solving this problem.

95
00:04:50,600 --> 00:04:55,070
但事实证明 我们可以使用更多内置在Python语言中的东西 
But it turns out we could use more that's built into the language Python

96
00:04:55,070 --> 00:04:56,690
自己解决这个问题
to solve this problem ourself.

97
00:04:56,690 --> 00:05:00,470
在这里我是在重新发明一个轮子 一个集合的概念
Here I'm rather reinventing a wheel, really the notion of a set

98
00:05:00,470 --> 00:05:02,610
在那里重复的东西被我消除了 
wherein duplicates are eliminated for me.

99
00:05:02,610 --> 00:05:04,580
所以让我继续清理我的终端窗口
So let me go ahead and clear my terminal window

100
00:05:04,580 --> 00:05:07,580
或者改变我在这里使用的对象类型 
and perhaps change the type of object I'm using here.

101
00:05:07,580 --> 00:05:09,650
而不是一个列表 这也可以写
Instead of a list, which could also be written

102
00:05:09,650 --> 00:05:11,960
创建一个空列表 让我继续
like this to create an empty list, let me go ahead

103
00:05:11,960 --> 00:05:15,740
并创建一个空集 借此我调用一个函数 
and create an empty set, whereby I call a function called

104
00:05:15,740 --> 00:05:18,500
它将返回Python中的某个对象
set that's going to return to me some object in Python

105
00:05:18,500 --> 00:05:21,950
它表示集合的概念 其中重复项自动
that represents this notion of a set wherein duplicates are automatically

106
00:05:21,950 --> 00:05:22,730
被淘汰了 
eliminated.

107
00:05:22,730 --> 00:05:24,650
现在 我可以收紧我的代码 
And now, I can tighten up my code.

108
00:05:24,650 --> 00:05:27,370
因为我自己不需要使用这个如果条件 
Because I don't have to use this if condition myself.

109
00:05:27,370 --> 00:05:29,590
我想我可以做这样的事情 
I think I can just do something like this.

110
00:05:29,590 --> 00:05:32,650
在我的循环中 让我来做房子 
Inside of my loop, let me do houses.add.

111
00:05:32,650 --> 00:05:35,800
所以它不是集合的追加 而是列表的追加 
So it's not append for a set, it's append for a list.

112
00:05:35,800 --> 00:05:39,220
但它是根据文档添加到一组中的 
But it's add to a set per the documentation.

113
00:05:39,220 --> 00:05:42,490
那么让我继续添加这个在校生的房子 
Then let me go ahead and add this current student's house.

114
00:05:42,490 --> 00:05:45,110
现在 我认为我的其余代码可以是相同的 
And now, I think the rest of my code can be the same.

115
00:05:45,110 --> 00:05:48,670
我现在信任的是在Python中设置的文档
I'm just now trusting per the documentation for set in Python

116
00:05:48,670 --> 00:05:50,860
它会为我过滤掉重复的内容 
that it's going to filter out duplicates for me.

117
00:05:50,860 --> 00:05:55,240
我可以盲目地把这些房子都加到布景里
And I can just blindly add, add, add, add all of these houses to the set

118
00:05:55,240 --> 00:05:57,850
任何已经在那里的复制品都将消失 
and any duplicates already there will be gone.

119
00:05:57,850 --> 00:06:00,550
Pythonofhoues.py并回车 
Python of houses.py and Enter.

120
00:06:00,550 --> 00:06:04,480
瞧 我们又回到了和这三个人的生意上 
And voila, we're back in business with just those three there as well.

121
00:06:04,480 --> 00:06:08,890
让我在这里暂停一下 看看现在是否有任何关于set的用法的问题 
Let me pause here to see if there's any questions now on this use of set, which

122
00:06:08,890 --> 00:06:11,380
只是您可以使用的另一种数据类型
is just another data type that's available to you,

123
00:06:11,380 --> 00:06:14,620
您可以在以下情况下接触到的另一个类：
another class in the world of Python that you can reach for when

124
00:06:14,620 --> 00:06:16,750
解决一些像这样的问题 
solving some problem like this.

125
00:06:16,750 --> 00:06:19,330
学生：我们如何在一组中找到一件物品 
STUDENT: How can we locate an item in a set,

126
00:06:19,330 --> 00:06:22,148
例如 在那一组中找到格兰芬多？
for example, find Gryffindor in that set?

127
00:06:22,148 --> 00:06:24,190
大卫·J·马兰：你如何在一套中找到一件物品？
DAVID J. MALAN: How do you find an item in a set?

128
00:06:24,190 --> 00:06:28,030
您可以使用与我们以前针对列表所做的非常相似的语法 
You can use very similar syntax as we've done for a list before.

129
00:06:28,030 --> 00:06:34,630
你可以像If Gryffindor in House Then那样使用语法 
You can use syntax like if Gryffindor in houses then,

130
00:06:34,630 --> 00:06:36,980
你可以按照这样的思路回答一个问题 
and you can answer a question along those lines.

131
00:06:36,980 --> 00:06:40,790
因此 您也可以使用in和not in以及类似的函数 
So you can use in and not in and similar functions as well.

132
00:06:40,790 --> 00:06:42,250
片场还有其他问题吗？
Other questions on set?

133
00:06:42,250 --> 00:06:45,730
学生：看 如果你有一个相似的房子名字 会发生什么？
STUDENT: Look what happens if you have a similar house name?

134
00:06:45,730 --> 00:06:48,520
比方说 可能不是斯莱特林 而是
Let's say instead of Slytherin, it is maybe

135
00:06:48,520 --> 00:06:52,000
O而不是I 将循环For循环
an O instead of an I. Will the for loop loop

136
00:06:52,000 --> 00:06:56,800
在房子名字里的每一个字母里吗？
throughout each of those letters in the house name?

137
00:06:56,800 --> 00:06:59,270
大卫·J·马兰：它会比较这些字符串 
DAVID J. MALAN: It would compare the strings.

138
00:06:59,270 --> 00:07:01,810
所以如果斯莱特林不止一次出现 但
So if Slytherin appears more than once but is

139
00:07:01,810 --> 00:07:04,720
略有拼写错误或大写 如果我没记错的话 
slightly misspelled or capitalized, if I heard you right,

140
00:07:04,720 --> 00:07:08,230
这些看起来像是截然不同的字符串 
those would appear to be distinct strings.

141
00:07:08,230 --> 00:07:11,420
所以你会在结果中得到两个版本的斯莱特林 
So you would get both versions of Slytherin in the result.

142
00:07:11,420 --> 00:07:14,500
然而 我们在过去已经看到了如何清理用户数据
However, we've seen in the past how we can clean up users' data

143
00:07:14,500 --> 00:07:15,910
如果它确实可能会变得一团糟 
if indeed it might be messy.

144
00:07:15,910 --> 00:07:19,030
我们可以强制一切大写 或全部小写 
We could force everything to uppercase, or everything to lowercase,

145
00:07:19,030 --> 00:07:22,270
或者我们可以利用STR中内置的功能 
or we could use capitalize the function built into strs,

146
00:07:22,270 --> 00:07:25,300
或者是可以帮我们处理一些清理工作的书名 
or title case that would handle some of the cleanup for us.

147
00:07:25,300 --> 00:07:28,930
在本例中 因为数据不是来自使用输入的人类
In this case, because the data is not coming from humans using the input

148
00:07:28,930 --> 00:07:31,600
函数 我提前写了代码 比较安全
function, I wrote the code in advance, it's safer

149
00:07:31,600 --> 00:07:33,760
假设我把房子弄对了 
to assume that I got the houses right.

150
00:07:33,760 --> 00:07:37,000
但如果它来自用户 那么这绝对是一个风险 
But that's absolutely a risk if it's coming from users.

151
00:07:37,000 --> 00:07:39,850
请允许我将我们的注意力转回到其他一些功能上
Allow me to turn our attention back to some of the other features

152
00:07:39,850 --> 00:07:43,390
在这里 如果我们进一步深入研究文档 我们可以在Python中利用它
here that we can leverage in Python if we dig further into the documentation

153
00:07:43,390 --> 00:07:45,130
并阅读有关其功能的更多信息 
and read up more on its features.

154
00:07:45,130 --> 00:07:47,380
嗯 在一些语言中 有这样一个概念
Well, in some language, there's this notion

155
00:07:47,380 --> 00:07:51,520
全局变量 因此您可以定义符合以下条件的变量
of global variables, whereby you can define a variable that's either

156
00:07:51,520 --> 00:07:54,280
函数的局部性 正如我们多次看到的 
local to a function, as we've seen many times,

157
00:07:54,280 --> 00:07:58,450
或者 如果您将一个变量放在所有函数之外 
or if you put a variable outside of all of your functions,

158
00:07:58,450 --> 00:08:01,060
可能接近文件的顶部 这通常会
perhaps near the top of your file, that would generally

159
00:08:01,060 --> 00:08:03,340
被认为是一个全局变量 
be considered a global variable.

160
00:08:03,340 --> 00:08:06,350
或者 在Python的世界中 它可能特定于模块 
Or in the world of Python, it might be specific to the module.

161
00:08:06,350 --> 00:08:09,610
但无论出于何种意图和目的 它都将针对给定的程序运行
But for all intents and purposes, it's going to behave for a given program

162
00:08:09,610 --> 00:08:11,080
就好像它是全球性的一样 
as though it is global.

163
00:08:11,080 --> 00:08:13,120
然而 事实证明 如果你这样做
However, it turns out that if you do this

164
00:08:13,120 --> 00:08:16,750
当你解决一些问题时 你有多种功能
when solving some problem down the line, whereby you have multiple functions

165
00:08:16,750 --> 00:08:20,590
你确实有一个或多个在这些函数之外的变量 
and you do have one or more variables that are outside of those functions,

166
00:08:20,590 --> 00:08:26,470
您可能无法像您想象的那样轻松地更改这些变量 
you might not be able to change those variables as easily as you might think.

167
00:08:26,470 --> 00:08:28,930
所以 确实 让我回到VS代码这里 
So indeed, let me go back to VS Code here.

168
00:08:28,930 --> 00:08:32,289
稍后 我将继续创建一个新文件 如何
And in just a moment, I'm going to go ahead and create a new file, how about

169
00:08:32,289 --> 00:08:34,419
名为ban.py 
called bank.py.

170
00:08:34,419 --> 00:08:36,730
让我们继续并实现银行的概念
Let's go ahead and implement the notion of a bank

171
00:08:36,730 --> 00:08:40,960
在那里我们可以用各种形式存储像钱这样的东西 
wherein we can store things like money in various forms.

172
00:08:40,960 --> 00:08:42,710
让我继续做这件事 
And let me go ahead and do this.

173
00:08:42,710 --> 00:08:44,890
让我们继续并实现一个非常简单的银行
Let me go ahead and implement a very simple bank

174
00:08:44,890 --> 00:08:48,550
这只是记录我的总余额 即美元或美分的数量
that simply keeps track of my total balance, the number of dollars or cents

175
00:08:48,550 --> 00:08:50,410
或者我可能在这个银行里存的任何东西 
or whatever I might be storing in this bank.

176
00:08:50,410 --> 00:08:53,560
我将在顶部给自己一个称为Balance的变量 它
And I'm going to give myself a variable called balance at the top, which

177
00:08:53,560 --> 00:08:55,970
是一个整数 设置为零 
is an integer, a set to zero.

178
00:08:55,970 --> 00:08:58,902
现在让我继续定义一个主要函数 就像我们经常做的那样 
Now let me go ahead and define a main function as we often do.

179
00:08:58,902 --> 00:09:02,110
在我的主要函数中 让我继续打印出来 引用引号 
And inside of my main function, let me go ahead and print out, quote unquote,

180
00:09:02,110 --> 00:09:05,290
余额 然后打印出余额本身的值 
balance, and then print out the value of balance itself.

181
00:09:05,290 --> 00:09:10,570
传递给印刷品 就像我们经常做的那样 不止一个论点 所以他们得到了
Passing to print, as we've often done, more than one argument so that they get

182
00:09:10,570 --> 00:09:12,520
由一个空格隔开 
separated by a single white space.

183
00:09:12,520 --> 00:09:15,340
现在 既然我有一个主要的功能 真正的搭建舞台
And now, since I have a main function, really setting the stage

184
00:09:15,340 --> 00:09:17,470
为了很快做更多有趣的事情 让我们
for doing more interesting things soon, let

185
00:09:17,470 --> 00:09:20,860
如果这个文件的名字是这样的 我会继续做我们的惯例
me go ahead and do our usual if the name of this file

186
00:09:20,860 --> 00:09:25,060
等于等于下划线Main 然后继续调用Main 
equals equals underscore underscore main, then go ahead and call main.

187
00:09:25,060 --> 00:09:28,450
这是一个非常短的程序 但它可能
So this is a terribly short program, but it's perhaps

188
00:09:28,450 --> 00:09:31,630
代表您可能如何在Python中解决一些未来的问题 
representative of how you might solve some future problem in Python.

189
00:09:31,630 --> 00:09:34,390
这样你就有了一个主要功能 它最终会做
Whereby you have a main function that's going to eventually do

190
00:09:34,390 --> 00:09:35,780
一些有趣的东西 
some interesting stuff.

191
00:09:35,780 --> 00:09:38,590
在文件的顶部 您有一个或多个变量
And at the top of your file, you have one or more variables

192
00:09:38,590 --> 00:09:41,590
放在那里很有用 因为这样你就知道它们在哪里了 
that are just useful to keep there because then you know where they are.

193
00:09:41,590 --> 00:09:45,560
也许不只是Main 其他函数也可以访问它们 
And perhaps not just main but other functions can access them as well.

194
00:09:45,560 --> 00:09:46,420
让我们来看看 
So let's see.

195
00:09:46,420 --> 00:09:49,720
当我运行这个程序时 BANK.PY的PYTHON 
When I run this program, Python of bank.py,

196
00:09:49,720 --> 00:09:52,870
到目前为止 我希望根据我自己的直觉 我会去
I would hope based on my own intuition thus far that I'm going

197
00:09:52,870 --> 00:09:54,880
以确保我目前的余额为零 
to see that my current balance is zero.

198
00:09:54,880 --> 00:09:59,800
也就是说 即使在第一行定义了余额变量 
That is to say, even though the balance variable is defined on line one,

199
00:09:59,800 --> 00:10:03,550
希望我还能在Main内的五个地方在线打印出来 
hopefully I can still print it online five inside of main,

200
00:10:03,550 --> 00:10:07,120
即使在我的主要职能中没有定义平衡 
even though balance was not defined in my main function.

201
00:10:07,120 --> 00:10:07,820
我们开始吧 
Here we go.

202
00:10:07,820 --> 00:10:08,500
按Enter键 
Hitting Enter.

203
00:10:08,500 --> 00:10:10,540
好了 平衡为零 
And voila, balance zero.

204
00:10:10,540 --> 00:10:12,010
因此 它似乎确实奏效了 
So it does seem to work.

205
00:10:12,010 --> 00:10:15,730
即使您在函数外部声明了一个在Python中的变量 
Even if you declare a variable in Python outside of your functions,

206
00:10:15,730 --> 00:10:17,500
看起来您可以访问它 
it appears that you can access it.

207
00:10:17,500 --> 00:10:22,870
即使在Main这样的函数中 也可以读取该变量的值 
You can read the value of that variable even inside of a function like main.

208
00:10:22,870 --> 00:10:24,880
好了 现在让我们来点冒险吧 
Well, let's get a little more adventurous now.

209
00:10:24,880 --> 00:10:27,380
因为这个计划真的没有解决任何人的问题 
Because this program really isn't solving anyone's problems.

210
00:10:27,380 --> 00:10:29,390
让我们继续实施更多的银行 
Let's go ahead and implement more of a bank,

211
00:10:29,390 --> 00:10:31,880
比如将钱存入银行的能力
like the ability to deposit money into the bank

212
00:10:31,880 --> 00:10:33,573
并从银行取款 
and to withdraw money from the bank.

213
00:10:33,573 --> 00:10:35,990
从而为我提供了更多的函数 这些函数很可能
Thereby giving me some more functions that might very well

214
00:10:35,990 --> 00:10:37,880
需要访问相同的变量 
need to access that same variable.

215
00:10:37,880 --> 00:10:39,710
让我在这里清除我的终端窗口 
Let me clear my terminal window here.

216
00:10:39,710 --> 00:10:42,440
现在让我先假装一下
And let me go ahead and pretend for the moment

217
00:10:42,440 --> 00:10:47,300
我有能力存入 比如说 100美元或100个硬币 
that I have the ability to deposit, say, $100 or 100 coins,

218
00:10:47,300 --> 00:10:49,190
无论这里的货币单位是什么 
whatever the unit of currency is here.

219
00:10:49,190 --> 00:10:51,680
然后 也许我想直接退缩
And then, maybe I want to withdraw straight

220
00:10:51,680 --> 00:10:54,620
拿走50个同样的美元或硬币 
away 50 of those same dollars or coins.

221
00:10:54,620 --> 00:10:57,770
现在 让我继续在Main的底部打印出来
And now, let me go ahead and just print out at the bottom of main

222
00:10:57,770 --> 00:11:01,340
我的新平衡应该是什么 这样在一个理想的世界里 
what my new balance should be so that in an ideal world,

223
00:11:01,340 --> 00:11:06,470
一旦我存了100 然后取了50 从0开始 
once I have deposited 100 then withdrawn 50, after starting at 0,

224
00:11:06,470 --> 00:11:11,430
我认为我在第八行的新余额确实应该是50 
I'd like to think that my new balance on line eight should indeed be 50.

225
00:11:11,430 --> 00:11:11,930
好的 
All right.

226
00:11:11,930 --> 00:11:13,700
但我还没有实现这些功能 
But I haven't implemented these functions yet.

227
00:11:13,700 --> 00:11:15,620
所以让我们像过去一样做这件事 
So let's do that as we've done in the past.

228
00:11:15,620 --> 00:11:18,680
下面 我将继续定义另一个函数存款 
Down here, I'm going to go ahead and define another function deposit.

229
00:11:18,680 --> 00:11:22,640
我要说的是 对于一些硬币 需要一个名为n的参数
I'm going to say that it takes an argument called n for a number of coins

230
00:11:22,640 --> 00:11:23,910
或美元或类似的东西 
or dollars or the like.

231
00:11:23,910 --> 00:11:25,220
我就是要这么做 
And I'm just going to do this.

232
00:11:25,220 --> 00:11:28,280
我要继续说 平衡加等于n 
I'm going to go ahead and say, balance plus equals n,

233
00:11:28,280 --> 00:11:30,230
从而改变n的值 
thereby changing the value of n.

234
00:11:30,230 --> 00:11:33,680
我可以说得更详细一些 Balance等于Balance+n 
I could do it more verbosely, balance equals balance plus n.

235
00:11:33,680 --> 00:11:36,980
但我将在这里使用较短的手写记法 
But I'm going to use the shorter hand notation here instead.

236
00:11:36,980 --> 00:11:38,510
现在 让我们来执行撤退 
And now, let's implement withdraw.

237
00:11:38,510 --> 00:11:40,730
因此 定义一个名为Retroke的函数 
So define a function called withdraw.

238
00:11:40,730 --> 00:11:43,160
它也将接受一个变量--一个参数
It too is going to take a variable-- an argument

239
00:11:43,160 --> 00:11:45,410
N表示美元或硬币的数量 
n for number of dollars or coins.

240
00:11:45,410 --> 00:11:48,560
现在 我要继续从平衡中减去
And now, I'm going to go ahead and subtract from balance

241
00:11:48,560 --> 00:11:51,690
使用负号也等于n 
using minus equals n as well.

242
00:11:51,690 --> 00:11:55,010
如果此文件的名称为Main 我仍将调用Main 
And I'm still going to call main if the name of this file is main.

243
00:11:55,010 --> 00:11:56,370
那么我做了什么呢？
So what have I done?

244
00:11:56,370 --> 00:12:00,860
我刚才总共添加了三个函数 而不是一个 所有这些函数
I've just added not just one but three functions total, all of which

245
00:12:00,860 --> 00:12:06,050
显然需要通过打印、递增来访问余额 
apparently need to access balance by printing it, incrementing it,

246
00:12:06,050 --> 00:12:08,670
或者减少它 就像我们在这里看到的 
or decrementing it, as we've seen here.

247
00:12:08,670 --> 00:12:09,170
好的 
All right.

248
00:12:09,170 --> 00:12:11,690
让我继续下去 在这里重点介绍这三个功能 
Let me go ahead and focus on these three functions here.

249
00:12:11,690 --> 00:12:16,490
让我返回到我的终端窗口 运行ban.py的Python并按Enter键 
Let me go back to my terminal window and run Python of bank.py and hit Enter.

250
00:12:16,490 --> 00:12:17,420
哇哦 
And wow.

251
00:12:17,420 --> 00:12:20,970
看起来我们在这里引入了一些问题 
Seems like we've introduced some number of problems here.

252
00:12:20,970 --> 00:12:23,010
这些问题是什么？
And what are these problems?

253
00:12:23,010 --> 00:12:28,670
嗯 非绑定局部错误可能是我们第一次在这里看到这种错误 
Well, unbound local error is perhaps the first time we've seen this one here.

254
00:12:28,670 --> 00:12:32,720
赋值前引用的局部变量余额 
Local variable balance referenced before assignment.

255
00:12:32,720 --> 00:12:35,720
这有点误导 绝对令人困惑 
And that's a bit misleading, definitely confusing.

256
00:12:35,720 --> 00:12:40,700
因为我绝对在代码的顶端分配了值平衡 
Because I absolutely assigned balance of value on the top of my code.

257
00:12:40,700 --> 00:12:44,355
事实上 如果我向后滚动 那里没有任何变化或丢失 
And indeed, if I scroll back up, nothing has changed or been lost up there.

258
00:12:44,355 --> 00:12:45,980
它肯定是被赋予了价值 
It's definitely been assigned to value.

259
00:12:45,980 --> 00:12:49,970
现在在第12行 看起来 当存款被调用时
And now on line 12, it would seem, that when deposit is called

260
00:12:49,970 --> 00:12:53,160
我只是想再次访问该变量 
I'm just trying to access that variable again.

261
00:12:53,160 --> 00:12:59,610
因此 直观地说 如何解释这个错误消息 未绑定的本地错误？
So intuitively, what might explain this error message, unbound local error?

262
00:12:59,610 --> 00:13:02,630
在那里 Python告诉了我们什么 它可以或不可以
What is Python telling us there that Python can or can't

263
00:13:02,630 --> 00:13:06,410
当涉及到这些所谓的全局变量时
do when it comes to these so-called global variables that

264
00:13:06,410 --> 00:13:08,430
都在我文件的首位？
are at the top of my file?

265
00:13:08,430 --> 00:13:12,110
学生：所以如果你想改变这个变量 
STUDENT: So if you want to change this variable,

266
00:13:12,110 --> 00:13:17,090
您应该编写一个内部Left函数Main 
you should write an inside left function main.

267
00:13:17,090 --> 00:13:19,740
和全局变量不变 
And the global variable unchangeable.

268
00:13:19,740 --> 00:13:20,615
大卫·J·马兰：是的 
DAVID J. MALAN: Yeah.

269
00:13:20,615 --> 00:13:21,448
学生：[听不见]
STUDENT: [INAUDIBLE]

270
00:13:21,448 --> 00:13:23,990
大卫·J·马兰：如果你想改变这个值 
DAVID J. MALAN: So if you want to change the value,

271
00:13:23,990 --> 00:13:26,240
它可能需要是函数的本地属性 
it might need to be local to the function.

272
00:13:26,240 --> 00:13:29,660
如果您试图在函数中更改全局变量 
If you are trying to change a global variable though in a function,

273
00:13:29,660 --> 00:13:31,620
这显然行不通 
it clearly does not work.

274
00:13:31,620 --> 00:13:33,800
因此 可以读取全局变量 
So it's OK to read a global variable.

275
00:13:33,800 --> 00:13:36,270
读意思、访问它、打印它等等 
Read meaning access it and print it and so forth.

276
00:13:36,270 --> 00:13:40,010
但显然 您不能以相同的方式写入全局变量
But apparently, you can't write to a global variable in the same way

277
00:13:40,010 --> 00:13:41,640
在这些功能中的一个中 
from within one of these functions.

278
00:13:41,640 --> 00:13:42,140
好的 
All right.

279
00:13:42,140 --> 00:13:43,700
好吧 也许解决办法就是这么做 
Well, maybe the fix is to do this.

280
00:13:43,700 --> 00:13:45,740
让我清除终端窗口和错误 
Let me clear my terminal window and that error.

281
00:13:45,740 --> 00:13:47,210
也许我可以这么做 
And maybe I could just do this.

282
00:13:47,210 --> 00:13:48,800
让我们去掉全局变量 
Let's get rid of the global variable.

283
00:13:48,800 --> 00:13:52,460
让我们继续 例如 把它放在Main中 
And let's go ahead and put it, for instance, inside of main.

284
00:13:52,460 --> 00:13:54,140
这种做法现在可能奏效吗？
Might this now work?

285
00:13:54,140 --> 00:13:55,430
好的 现在让我试试这个 
Well, let me try this now.

286
00:13:55,430 --> 00:13:59,150
Bank.py的蟒蛇回车 
Python of Bank.py Enter.

287
00:13:59,150 --> 00:14:00,980
仅凭这一点并不能解决问题 
That alone did not solve it.

288
00:14:00,980 --> 00:14:03,320
我仍然有一个未绑定的本地错误 
I still have an unbound local error.

289
00:14:03,320 --> 00:14:06,860
不过 这一次是出于不同的原因 
This time though, it's for a different reason.

290
00:14:06,860 --> 00:14:13,350
现在 根据定义 第二行上的余额是一个局部变量 
It turns out now that balance on line two is by definition a local variable.

291
00:14:13,350 --> 00:14:16,670
局部变量是存在于函数上下文中的变量 至少
A local variable is one that exists in the context of a function, at least

292
00:14:16,670 --> 00:14:17,390
在这种情况下 
in this case.

293
00:14:17,390 --> 00:14:20,120
全局变量是相反的 不是这样的 
A global variable is the opposite, one that does not,

294
00:14:20,120 --> 00:14:21,900
例如 在我的文件顶部 
for instance at the top of my file.

295
00:14:21,900 --> 00:14:24,500
因此 这是在Python中的另一个区别 
So here is another distinction in Python.

296
00:14:24,500 --> 00:14:27,650
如果在函数中声明变量 如main 
If you declare a variable in a function, like main,

297
00:14:27,650 --> 00:14:29,720
就像我在二号线上做的平衡一样 
just as I've done on line two with balance,

298
00:14:29,720 --> 00:14:31,760
它确实是该功能的本地功能 
it is indeed local to that function.

299
00:14:31,760 --> 00:14:36,030
存款和取款不能访问相同变量 
Deposit and withdraw do not have access to that same variable.

300
00:14:36,030 --> 00:14:36,530
为什么？
Why?

301
00:14:36,530 --> 00:14:38,030
因为它是从本地到美因河 
Because it's local to main.

302
00:14:38,030 --> 00:14:41,150
因此 你会认为我们现在有点陷入了这个恶性循环 
And so, you would think now we're kind of stuck in this vicious cycle.

303
00:14:41,150 --> 00:14:45,120
好吧 也许解决方案是在全球范围内转移平衡
Well, maybe the solution then is to move balance globally

304
00:14:45,120 --> 00:14:47,030
因此 所有三个功能都可以访问它 
so all three functions can access it.

305
00:14:47,030 --> 00:14:50,840
但很明显 正如埃琳娜所指出的那样 我们不能因此改变它 
But clearly, where we began, as Elena noted, we can't therefore change it.

306
00:14:50,840 --> 00:14:53,930
因此 在Python中解决此问题的方法就是
So it turns out the solution to this problem in Python

307
00:14:53,930 --> 00:14:56,487
具有讽刺意味的是 这里正是这个关键词 
is ironically exactly this keyword here.

308
00:14:56,487 --> 00:14:58,820
这有点不同 你可能会看到 如果你
It's a little different as you might have seen if you've

309
00:14:58,820 --> 00:15:00,380
以前用其他语言编写的程序 
programmed before in other languages.

310
00:15:00,380 --> 00:15:02,600
但在Python语言中确实有一个关键词叫
But there's indeed a keyword in Python called

311
00:15:02,600 --> 00:15:06,170
GLOBAL 允许您告诉函数 嘿 这
global that allows you to tell a function that, hey, this

312
00:15:06,170 --> 00:15:08,030
不是您本地的变量 
is not a variable that's local to you.

313
00:15:08,030 --> 00:15:11,460
我的意思是它是一个全局变量 我想让你们编辑它 
I mean it to be a global variable that I want you to edit.

314
00:15:11,460 --> 00:15:14,180
因此 如果我返回到VS代码 清除我的终端
So if I go back to VS Code here, clearing my terminal

315
00:15:14,180 --> 00:15:15,810
窗口来消除该错误 
window to get rid of that error.

316
00:15:15,810 --> 00:15:17,870
让我继续并撤消我刚刚所做的更改
Let me go ahead and undo the change I just made

317
00:15:17,870 --> 00:15:20,450
把平衡放回我档案的首位 
and put balance back at the top of my file.

318
00:15:20,450 --> 00:15:22,920
但这一次 我要做的是
But this time, what I'm going to do is I'm

319
00:15:22,920 --> 00:15:28,890
我将通知我的两个函数 它们需要更改余额的值 
going to inform my two functions that need to change the value of balance,

320
00:15:28,890 --> 00:15:34,420
它确实是全球性的 在这里再次输入Global Balance以及
that it is indeed global, by typing global balance again here as well as

321
00:15:34,420 --> 00:15:34,920
这里 
here.

322
00:15:34,920 --> 00:15:36,480
全球平衡 
Global balance.

323
00:15:36,480 --> 00:15:40,980
我仍然在第13行和第18行保留相同的代码行 即
I still leave the same lines of code now on lines 13 and 18, that increment

324
00:15:40,980 --> 00:15:42,090
和减量平衡 
and decrement balance.

325
00:15:42,090 --> 00:15:46,860
但是现在使用关键字GLOBAL有点像是在暗示 
But this now use of keyword global is a little bit of a clue to Python that,

326
00:15:46,860 --> 00:15:47,610
哦 好的 
oh, OK.

327
00:15:47,610 --> 00:15:48,782
这不是一个局部变量 
It's not a local variable.

328
00:15:48,782 --> 00:15:50,490
这不是您引入的错误 
This is not a bug that you've introduced.

329
00:15:50,490 --> 00:15:53,860
你的意思是让我在上面编辑这个变量 
You mean for me to edit this variable up above.

330
00:15:53,860 --> 00:15:57,750
现在 让我继续在我的终端窗口中运行BANK.PY的Python 
So now, let me go ahead in my terminal window and run Python of bank.py.

331
00:15:57,750 --> 00:16:03,540
我希望看到我的余额是0加100减50等于 
I'm hoping to see that my balance is zero plus 100 minus 50 is 50.

332
00:16:03,540 --> 00:16:04,740
事实上 现在就是这样 
And indeed, it now is.

333
00:16:04,740 --> 00:16:08,370
根据我在第五行的第一个打印语句 它从零开始 
It starts off at zero per my first print statement on line five.

334
00:16:08,370 --> 00:16:13,140
但最终结果是总共50美元 低于第八行的数字 
But it ends up at 50 total at below that on line eight.

335
00:16:13,140 --> 00:16:15,480
让我在这里暂停一下 看看现在是否有任何问题
Let me pause here to see if now there's any questions

336
00:16:15,480 --> 00:16:18,090
在这些全局或局部变量上 
on these global or local variables.

337
00:16:18,090 --> 00:16:23,250
学生：当你全局声明一个变量 并且
STUDENT: What happens when you declare a variable globally, and as

338
00:16:23,250 --> 00:16:26,037
在全局相同的变量中和在函数中？
in the same variable globally and in a function?

339
00:16:26,037 --> 00:16:27,370
大卫·J·马兰：问得好 
DAVID J. MALAN: A good question.

340
00:16:27,370 --> 00:16:29,703
你总是在想所谓的角落案件 
You're always thinking about the so-called corner cases.

341
00:16:29,703 --> 00:16:33,510
因此 如果您全局声明一个变量 比如在文件的顶部 
So if you declare a variable both globally, like at the top of your file,

342
00:16:33,510 --> 00:16:38,700
然后是函数内部的同名变量 同名 
and then an identically named variable inside of a function, same name,

343
00:16:38,700 --> 00:16:41,940
可以说 后者将落后于前者 
the latter will shadow, so to speak, the former.

344
00:16:41,940 --> 00:16:46,110
也就是说 您将能够使用后者 即局部变量 
That is, you'll be able to use the latter, that is the local variable.

345
00:16:46,110 --> 00:16:49,020
但它不会对全球变量产生影响 
But it will have no effect on the global variable.

346
00:16:49,020 --> 00:16:53,260
暂时 Python将只知道局部变量的存在 
Temporarily, Python will only know that the local variable exists.

347
00:16:53,260 --> 00:16:56,430
因此 总的来说 经验法则是 不要那样做 
So in general, the rule of thumb is, just don't do that.

348
00:16:56,430 --> 00:16:58,500
它不仅可能在您的代码中产生错误
Not only might it create bugs in your code

349
00:16:58,500 --> 00:17:01,120
因为你不会完全改变你想要改变的东西 
because you don't quite change what you intend to change.

350
00:17:01,120 --> 00:17:05,140
对于其他读者来说 这可能也不是显而易见的 
It's also perhaps non-obvious to other readers as well.

351
00:17:05,140 --> 00:17:07,680
关于全球人或本地人的其他问题？
Other questions on globals or locals?

352
00:17:07,680 --> 00:17:09,720
学生：好的 如果我们决定增加平衡呢
STUDENT: OK, what if we decide to add balance

353
00:17:09,720 --> 00:17:11,516
作为Main函数中的参数？
as an argument inside the main function?

354
00:17:11,516 --> 00:17:13,349
大卫·J·马兰：是的 又是一种良好的直觉 
DAVID J. MALAN: Yeah, another good instinct.

355
00:17:13,349 --> 00:17:16,530
但在这种情况下 这也不会解决问题 
But in this case, that also is not going to solve the problem.

356
00:17:16,530 --> 00:17:21,510
因为如果将一个像Balance这样的变量传递给每个函数
Because if you pass in a variable like balance to each of the functions

357
00:17:21,510 --> 00:17:24,089
然后在该函数中更改它 它
and then change it within that function, it's

358
00:17:24,089 --> 00:17:27,030
实际上只会改变它的本地副本 
only going to be changing in effect a local copy thereof.

359
00:17:27,030 --> 00:17:30,490
它不会改变那些功能之外的东西 
It's not going to be changing what's outside of those functions.

360
00:17:30,490 --> 00:17:33,330
所以我认为我们需要一个更好的方法 
So I think we actually need a better way altogether.

361
00:17:33,330 --> 00:17:36,720
事实上 请允许我过渡到一个修改
And in fact, allow me to transition to perhaps a modification

362
00:17:36,720 --> 00:17:38,010
同样的节目 
of this same program.

363
00:17:38,010 --> 00:17:40,710
回想一下 我们最近看到的
Recall that we looked most recently at this notion

364
00:17:40,710 --> 00:17:42,600
面向对象的编程 
of object-oriented programming.

365
00:17:42,600 --> 00:17:47,010
因此你可以模拟真实世界的实体 比如银行 
Whereby you can model real world entities, for instance a bank,

366
00:17:47,010 --> 00:17:50,490
你可以建模和封装信息
and you can model and encapsulate information

367
00:17:50,490 --> 00:17:52,680
关于现实世界中的实体 例如 
about that real world entity, for instance,

368
00:17:52,680 --> 00:17:54,580
比如某人的账户余额
like someone's account balance.

369
00:17:54,580 --> 00:17:56,700
所以我建议我们真的这么做 
So let me propose that we actually do this.

370
00:17:56,700 --> 00:17:58,950
让我们从bank.py开始 
Let me start from scratch with bank.py.

371
00:17:58,950 --> 00:18:01,140
完全去掉全局变量 
Get rid of the global variable altogether.

372
00:18:01,140 --> 00:18:03,960
并实际使用一些面向对象的代码 
And actually use some object-oriented code.

373
00:18:03,960 --> 00:18:08,550
让我定义一个名为account的类来表示某人的银行帐户 
Let me define a class called account to represent someone's bank account.

374
00:18:08,550 --> 00:18:13,740
然后 让我继续使用init方法进行初始化 
And then, let me go ahead and initialize with my init method, which

375
00:18:13,740 --> 00:18:17,010
同样 按照惯例 它至少接受一个名为self的参数 
again, takes by convention at least one argument called self.

376
00:18:17,010 --> 00:18:20,790
我来初始化每个人的银行账户
Let me go ahead and initialize every person's bank account

377
00:18:20,790 --> 00:18:22,650
变成零之类的值
to some value like zero.

378
00:18:22,650 --> 00:18:23,890
我该怎么做？
Now, how can I do that?

379
00:18:23,890 --> 00:18:27,540
好的 我继续做自我平衡等于零 
Well, I'm going to go ahead and do self.balance equals zero.

380
00:18:27,540 --> 00:18:30,210
从而给我一个名为
Thereby giving me an instance variable called

381
00:18:30,210 --> 00:18:33,030
此帐户的余额初始化为零 
balance initialized for this account to zero.

382
00:18:33,030 --> 00:18:35,490
但我会积极地回忆起我们是如何
But I'm going to proactively remember how we also

383
00:18:35,490 --> 00:18:38,250
引入了这种属性的概念 
introduced this notion of properties which might otherwise

384
00:18:38,250 --> 00:18:40,720
与我的实例变量名冲突 
collide with the names of my instance variables.

385
00:18:40,720 --> 00:18:42,690
所以按照惯例我会这么做 
So just by convention I'm going to do this.

386
00:18:42,690 --> 00:18:45,630
我要主动重命名这个实例变量
I'm going to rename this instance variable proactively

387
00:18:45,630 --> 00:18:49,740
来强调平衡 以有效地表明它是私人的 甚至
to underscore balance to effectively indicate that it's private, even

388
00:18:49,740 --> 00:18:51,570
尽管Python并没有强制这样做 
though that's not enforced by Python.

389
00:18:51,570 --> 00:18:53,940
这只是我的一个视觉线索 
It's just a visual clue to myself that this

390
00:18:53,940 --> 00:18:57,900
是我不应该 或者其他代码不应该触及的 
is something that really I should not-- or other code should not touch,

391
00:18:57,900 --> 00:18:59,970
在这个类中只有函数 
just functions in this class.

392
00:18:59,970 --> 00:19:01,540
现在 让我继续做这个 
Now, let me go ahead and do this.

393
00:19:01,540 --> 00:19:03,540
让我继续定义一个实际的函数
Let me go ahead and define an actual function

394
00:19:03,540 --> 00:19:07,620
所谓的平衡 它实际上是一种财产 
called balance that really is going to be a property whose purpose in life

395
00:19:07,620 --> 00:19:10,380
就是恢复自我平衡 
is just to return self.balance.

396
00:19:10,380 --> 00:19:13,200
我要明确地说 这确实是
And I'm going to go explicitly and say this is indeed

397
00:19:13,200 --> 00:19:15,360
这一类的财产 
a property of this class.

398
00:19:15,360 --> 00:19:18,270
现在 让我继续并重新实现另外两个功能 
Now, let me go ahead and re-implement those other two functions,

399
00:19:18,270 --> 00:19:21,850
存取款 但限于本课程的范围内 
deposit and withdraw, but in the confines of this class.

400
00:19:21,850 --> 00:19:24,900
所以我要说 定义存款 
So I'm going to say, define deposit.

401
00:19:24,900 --> 00:19:27,420
它将一如既往地接受自己的论点 
It's going to take in an argument self as always,

402
00:19:27,420 --> 00:19:31,410
但另加一元 要存入若干美元或硬币.
but an additional one n, a number of dollars or coins to deposit.

403
00:19:31,410 --> 00:19:33,120
我现在该如何操纵这一点呢？
And how do I now manipulate this?

404
00:19:33,120 --> 00:19:37,560
好的 我要做自己 _天平加等于n 
Well, I'm going to do self._balance plus equals n.

405
00:19:37,560 --> 00:19:43,260
现在在这里 我要做def取款 就像存款一样 
And now down here, I'm going to do def withdraw self n, just like for deposit.

406
00:19:43,260 --> 00:19:47,250
但在这里 我要做的是 平衡减去n 
But here, I'm going to do self.balance minus equals n.

407
00:19:47,250 --> 00:19:50,430
现在 如果我低于这门课 我就
And now, if I go down below this class, I'm

408
00:19:50,430 --> 00:19:52,620
接下来 我将自己定义为一个主要功能
going to go ahead and define myself a main function

409
00:19:52,620 --> 00:19:54,390
这样我现在就可以试一试了 
just so I can try this now out.

410
00:19:54,390 --> 00:19:58,530
接下来 我将通过调用Account创建一个Account对象
I'm going to go ahead and create an account object by calling the account

411
00:19:58,530 --> 00:20:02,130
构造函数 它是带两个圆括号的类名
constructor, that is the name of the class with two parentheses

412
00:20:02,130 --> 00:20:04,350
如果我没有向init传递任何参数 
if I'm not passing in any arguments to init.

413
00:20:04,350 --> 00:20:07,830
我现在要继续 像以前一样打印出我的帐户余额 
I'm going to go ahead now and print out as before the balance of my account.

414
00:20:07,830 --> 00:20:12,420
但要做到这一点 我将像这样访问该帐户的属性 
But to do that, I'm going to access the property of that account like this.

415
00:20:12,420 --> 00:20:16,470
我现在要继续说 再存100美元或硬币
And I'm going to go ahead now and say, deposit another $100 or coins

416
00:20:16,470 --> 00:20:18,300
加100元押金 
with deposit 100.

417
00:20:18,300 --> 00:20:22,620
我将继续前进 像以前一样 现在也立即退出
And I'm going to go ahead, like before, and also now immediately withdraw

418
00:20:22,620 --> 00:20:25,140
不管是什么原因 50个一样的 
for whatever reason 50 of the same.

419
00:20:25,140 --> 00:20:27,120
现在 我要最后一次打印
And now, I'm going to print one last time

420
00:20:27,120 --> 00:20:31,383
Balance后跟Account Balance再次访问该属性 
balance followed by account.balance, again, accessing that property.

421
00:20:31,383 --> 00:20:34,050
当然 为了让这整件事起作用 我需要一个这样的
And for this whole thing to work, of course, I need one of these

422
00:20:34,050 --> 00:20:39,030
如果名称等于等于下划线Main 则继续并调用Main 
if name equals equals underscore main, then go ahead and call main.

423
00:20:39,030 --> 00:20:42,270
现在 在我运行这个之前 您将看到它相当迅速地升级 
Now, before I run this, you'll see that it rather escalated quickly.

424
00:20:42,270 --> 00:20:45,390
我手头有一个非常简单的目标 那就是实现银行的概念 
I had a very simple goal at hand to implement the notion of a bank.

425
00:20:45,390 --> 00:20:49,530
我最终完美地实现了这一点
And I was able to implement that perfectly fine ultimately

426
00:20:49,530 --> 00:20:53,550
通过声明BALANCE是全局的 但然后告诉我的每个函数
by declaring balance to be global but then to tell each of my functions

427
00:20:53,550 --> 00:20:54,990
它确实是全球性的 
that it is indeed global.

428
00:20:54,990 --> 00:20:59,130
但这并不是我们可以使用的最好的封装形式
But that's not really the best form of encapsulation we have at our disposal

429
00:20:59,130 --> 00:20:59,670
现在 
now.

430
00:20:59,670 --> 00:21:02,100
根据我们对面向对象编程的关注 
Per our focus on object-oriented programming,

431
00:21:02,100 --> 00:21:05,760
如果我们试图实现一些真实世界的实体 比如银行账户 
if we're trying to implement some real world entity like an account at a bank,

432
00:21:05,760 --> 00:21:07,770
这就是课程允许我们做的事情 
that's what classes allow us to do.

433
00:21:07,770 --> 00:21:10,380
它让我们可以解决同样的问题 也许只是一点点
And it allows us to solve that same problem perhaps a little

434
00:21:10,380 --> 00:21:14,010
更干净 当然 如果我们要积累越来越多的函数
more cleanly, certainly if we're going to accumulate more and more functions

435
00:21:14,010 --> 00:21:15,610
或随时间推移的方法 
or methods over time.

436
00:21:15,610 --> 00:21:19,800
所以 如果我在这里没有犯任何错误 如果我运行BANK.PY的Python并点击
So if I didn't make any mistakes here, if I run Python of bank.py and hit

437
00:21:19,800 --> 00:21:23,550
现在进入 你会看到它工作得很好 
Enter now, you'll see that it just works just fine.

438
00:21:23,550 --> 00:21:26,490
因为在Python类的世界里 
Because in the world of classes in Python,

439
00:21:26,490 --> 00:21:29,550
根据定义 这些所谓的实例变量
these so-called instance variables are by definition

440
00:21:29,550 --> 00:21:33,180
该类中的所有方法都可以访问
accessible to all of the methods in that class

441
00:21:33,180 --> 00:21:39,240
因为我们都是通过这个特殊的参数本身访问它们 
because we're accessing them all by way of that special parameter self.

442
00:21:39,240 --> 00:21:40,440
那么 用哪种方式来做呢？
So which way to do it?

443
00:21:40,440 --> 00:21:43,260
对于一个相当小的脚本 其中您只需
For a reasonably small script wherein you are simply

444
00:21:43,260 --> 00:21:47,728
试图实现一个包含一些全局信息的脚本 
trying to implement a script that has some global information,

445
00:21:47,728 --> 00:21:50,520
就像你需要在别处操纵的账户余额一样 
like an account balance that you then need to manipulate elsewhere,

446
00:21:50,520 --> 00:21:52,930
GLOBAL关键字是该问题的一种解决方案 
the global keyword is a solution to that problem.

447
00:21:52,930 --> 00:21:55,890
但总的来说 在许多语言中 
But generally speaking, in many languages,

448
00:21:55,890 --> 00:21:58,800
在某种程度上 其中使用了全局变量
Python to some extent among them, using global variables

449
00:21:58,800 --> 00:22:03,030
因为事情可能很快就会变得一团糟 所以人们往往会皱起眉头 
tends to be frowned upon only because things can get messy quickly.

450
00:22:03,030 --> 00:22:07,470
而且你的信息的确切位置很快就会变得不那么明显
And it can become less obvious quickly exactly where your information is

451
00:22:07,470 --> 00:22:10,150
存储 如果有些在这里 有些在你的函数中 
stored, if some of it's up here, some of it's in your function.

452
00:22:10,150 --> 00:22:15,180
因此 一般来说 经验法则是谨慎使用全局变量 
So generally, the rule of thumb is to use global variables sparingly.

453
00:22:15,180 --> 00:22:18,390
尽管从技术上讲 在Python中 这些全局变量
Though technically speaking, in Python these global variables

454
00:22:18,390 --> 00:22:21,870
从技术上讲 对于我们的模块来说是本地的 如果我们确实实现了
are technically local to our module if we were indeed implementing

455
00:22:21,870 --> 00:22:23,830
一个图书馆 而不仅仅是一个程序 
a library and not just a program.

456
00:22:23,830 --> 00:22:27,010
因此 简而言之 尽量少用全局变量 
So in short, try to use global variables sparingly.

457
00:22:27,010 --> 00:22:30,120
但当你这样做的时候 同样的问题也有解决方案 
But when you do, there is a solution to these same problems.

458
00:22:30,120 --> 00:22:35,280
现在是关于全球化的问题 还是关于我们重新实施相同理念的问题
Questions now on globals or our reimplementation of the same idea

459
00:22:35,280 --> 00:22:40,030
但是使用成熟的面向对象编程呢？
but using full-fledged object-oriented programming?

460
00:22:40,030 --> 00:22:44,163
学生：我只是想问 这个属性是做什么的？
STUDENT: I just would like to ask, what this property does?

461
00:22:44,163 --> 00:22:45,830
大卫·J·马兰：这处房产的用途 
DAVID J. MALAN: What this property does.

462
00:22:45,830 --> 00:22:47,740
所以如果我回到VS Code 你会看到
So if I go back to VS Code here, you'll see

463
00:22:47,740 --> 00:22:50,530
这是我们在课上学到的一种技术
that this was a technique we looked at in our lecture

464
00:22:50,530 --> 00:22:52,150
关于面向对象的编程 
on object-oriented programming.

465
00:22:52,150 --> 00:22:57,400
因此 属性是以某种方式保护的实例变量 
Whereby a property is a instance variable that somehow protected.

466
00:22:57,400 --> 00:23:01,490
它允许我控制它可以读写 
It allows me to control it can be read and written.

467
00:23:01,490 --> 00:23:04,870
所以在这种情况下 我只有通常所说的二传手 
So in this case, I only have what's called generally a setter.

468
00:23:04,870 --> 00:23:05,710
或者抱歉 
And or sorry.

469
00:23:05,710 --> 00:23:08,372
在这种情况下 我只有通常所说的获取器 
In this case, I only have what's generally called a getter.

470
00:23:08,372 --> 00:23:10,330
而且这里没有提到Getter这个词 
And there's no mention of the word getter here.

471
00:23:10,330 --> 00:23:12,250
这只是“财产手段” 
This is just @property means.

472
00:23:12,250 --> 00:23:15,550
这种功能平衡将允许我 回忆一下 
That function balance will allow me, recall,

473
00:23:15,550 --> 00:23:18,160
使用这样的语法 我可以假装
to use syntax like this, where I can pretend

474
00:23:18,160 --> 00:23:22,360
好像Balance确实是不带下划线的实例变量 
as though balance is indeed with no underscore an instance variable.

475
00:23:22,360 --> 00:23:27,220
但我现在可以防止像我在Main中那样的代码试图改变平衡 
But I can now prevent code like mine in main from trying to change balance.

476
00:23:27,220 --> 00:23:29,650
因为我没有二传手 所以我不会
Because I do not have a setter, I would not

477
00:23:29,650 --> 00:23:32,500
能够执行类似帐户余额等于1,000的操作
be able to do something like account balance equals 1,000

478
00:23:32,500 --> 00:23:36,370
只给自己1000或硬币 因为我还没有定义二传手 
to just give myself 1,000 or coins because I have not defined a setter.

479
00:23:36,370 --> 00:23:39,460
因此 根据我们对面向对象编程的关注 
So again, per our focus on object-oriented programming,

480
00:23:39,460 --> 00:23:42,910
这些属性只是允许我进行一些更细粒度的控制 
these properties just allow me some finer-grained control.

481
00:23:42,910 --> 00:23:46,750
一些语言允许您定义变量 可以说 
Some languages allow you to define variables that are, so to speak,

482
00:23:46,750 --> 00:23:47,380
常量 
constant.

483
00:23:47,380 --> 00:23:49,870
也就是说 一旦您为它们设置了一个值 
That is, once you have set a value to them,

484
00:23:49,870 --> 00:23:52,297
您不能更改该变量的值 
you cannot change the value of that variable.

485
00:23:52,297 --> 00:23:54,130
这往往是一件好事 因为它
And that tends to be a good thing because it

486
00:23:54,130 --> 00:23:55,810
允许您进行防御性编程 
allows you to program defensively.

487
00:23:55,810 --> 00:23:58,570
以防你不小心 或者其他人 
Just in case you accidentally, or someone else,

488
00:23:58,570 --> 00:24:01,640
意外地试图修改该变量的值 
accidentally tries to modify the value of that variable,

489
00:24:01,640 --> 00:24:06,430
如果您在某种语言中将其声明为常量 则不能更改它 
if you have declared it in some language as a constant, it cannot be changed,

490
00:24:06,430 --> 00:24:09,490
或者通常不费很大力气就不能改变 
or usually cannot be changed without great effort.

491
00:24:09,490 --> 00:24:13,150
不幸的是 在Python语言中 我们再次使用了这种荣誉系统 
Unfortunately, in Python, we're again on the sort of honor system here.

492
00:24:13,150 --> 00:24:15,430
我们有惯例来表明某件事
Where we have conventions to indicate that something

493
00:24:15,430 --> 00:24:17,260
应该像对待常量一样对待 
should be treated as though it's constant.

494
00:24:17,260 --> 00:24:19,760
但这实际上并不是由语言强制执行的 
But that's not actually enforced by the language.

495
00:24:19,760 --> 00:24:22,000
举个例子 让我回到VS代码 
So for instance, let me go back here to VS Code.

496
00:24:22,000 --> 00:24:25,240
让我创建一个新文件 比如 名为meows.py 
And let me create a new file, for instance, called meows.py.

497
00:24:25,240 --> 00:24:28,690
让我们看看我们是否能实现猫在屏幕上喵喵叫的概念 
And let's see if we can't implement the notion of a cat meowing on the screen.

498
00:24:28,690 --> 00:24:31,510
所以我会用代码meows.py 
So I'll do code of meows.py.

499
00:24:31,510 --> 00:24:34,360
在meows.py中 让我举个例子
And in meows.py, let me go ahead for instance

500
00:24:34,360 --> 00:24:38,120
然后实现一个非常简单的程序 让一只猫叫三次 
and implement a very simple program that just has a cat meowing three times.

501
00:24:38,120 --> 00:24:39,280
不如这样吧
So how about this.

502
00:24:39,280 --> 00:24:45,260
对于i在3的范围内 继续并打印出来 引号内 喵 
For i in the range of three, go ahead and print out, quote unquote, meow.

503
00:24:45,260 --> 00:24:45,760
好吧
All right.

504
00:24:45,760 --> 00:24:48,580
好吧 我们已经看到在过去我们如何可以清理这一点 
Well, we've seen in the past how we can clean this up a little bit.

505
00:24:48,580 --> 00:24:50,455
例如 如果我没有用i 
For instance, if I'm not actually using i,

506
00:24:50,455 --> 00:24:52,720
我还不如用Python的方法把它的名字
I might as well Pythonically just change the name

507
00:24:52,720 --> 00:24:55,900
要加下划线的变量 尽管它没有函数
of that variable to underscore even though that has no functional

508
00:24:55,900 --> 00:24:56,710
效果在这里 
effect here.

509
00:24:56,710 --> 00:25:01,210
但这里我们有三个随机硬编码的 
But here we have this three randomly hardcoded, that is,

510
00:25:01,210 --> 00:25:02,950
在我的代码中显式输入 
typed explicitly into my code.

511
00:25:02,950 --> 00:25:06,670
当你的代码只有两行时 这完全不是什么大不了的事情 
And it's totally not a big deal when your code is only two lines.

512
00:25:06,670 --> 00:25:09,610
但想象一下 这是一个更大的计划 
But imagine that this is a much bigger program with dozens

513
00:25:09,610 --> 00:25:10,930
或者甚至数百行 
or even hundreds of lines.

514
00:25:10,930 --> 00:25:14,890
想象一下其中一条线上有个3 
And imagine that one of those lines just has a three in there somewhere.

515
00:25:14,890 --> 00:25:17,050
你不会轻易找到那三个的 
You're never going to find that three very easily.

516
00:25:17,050 --> 00:25:18,640
这很容易被忽视
And it's going to be very easily overlooked

517
00:25:18,640 --> 00:25:20,440
你或同事或其他人
by you or colleagues or others that you've

518
00:25:20,440 --> 00:25:25,460
在你的代码里硬编码了一个像3这样的神奇值
hardcoded some magic value like a three right there in your code.

519
00:25:25,460 --> 00:25:28,540
因此 这往往是最佳实践 不仅在Python中 而且在其他语言中 
So it tends to be best practice, not just in Python but other languages

520
00:25:28,540 --> 00:25:31,660
同样 任何时候你有一个常数 
as well, any time you have what is essentially a constant,

521
00:25:31,660 --> 00:25:34,030
就像永远不会改变的数字3 
like a number three that shouldn't ever change,

522
00:25:34,030 --> 00:25:37,760
是至少让它冒泡 把它放在代码的顶部 
is to at least let it bubble up, surface it to the top of your code,

523
00:25:37,760 --> 00:25:41,380
这样代码的常量值就很明显了 
so that it's just obvious what your code's constant values are.

524
00:25:41,380 --> 00:25:42,910
所以 我的意思是 
And so, by that I mean this.

525
00:25:42,910 --> 00:25:44,860
在这个文件的顶部 它可能会
At the top of this file, it would probably

526
00:25:44,860 --> 00:25:48,370
明天对同事说清楚一点 坦白地说 对我来说 
be a little clearer to colleagues, and frankly, me tomorrow

527
00:25:48,370 --> 00:25:52,150
在我忘了今天做了什么之后 
after I've forgotten what I did today, to define a variable like meows

528
00:25:52,150 --> 00:25:53,650
并将其设置为3 
and set it equal to three.

529
00:25:53,650 --> 00:25:57,340
然后 不是在这里硬编码三个或更低 
And then, instead of hardcoding three here or even lower

530
00:25:57,340 --> 00:26:01,750
在一个更大的程序中 让我继续传递变量的值
in a much bigger program, let me just go ahead and pass in that variable's value

531
00:26:01,750 --> 00:26:02,570
到我的循环 
to my loop.

532
00:26:02,570 --> 00:26:04,630
所以现在对我来说很明显
So that now it's just kind of obvious to me

533
00:26:04,630 --> 00:26:06,940
猫咪叫的次数显然就是猫咪叫的次数 
that meows is apparently the number of times to meow.

534
00:26:06,940 --> 00:26:10,300
如果我想改变它 我唯一需要改变的代码
And if I ever want to change it, the only code I have to change

535
00:26:10,300 --> 00:26:11,643
在我档案的最顶端 
is at the very top of my file.

536
00:26:11,643 --> 00:26:14,560
我不需要到处钓鱼 也不需要想着什么会坏掉 
I don't need to go fishing around or figure out what's going to break,

537
00:26:14,560 --> 00:26:15,610
我需要改变什么 
what do I need to change.

538
00:26:15,610 --> 00:26:19,330
我只知道我可以在顶部更改这些常量 
I just know that I can change these constants up at the top.

539
00:26:19,330 --> 00:26:23,050
不过 使用Python的问题在于 它实际上并不
The problem though with Python is that Python doesn't actually

540
00:26:23,050 --> 00:26:24,640
使变量保持不变 
make variables constant.

541
00:26:24,640 --> 00:26:27,640
这在Python和其他一些语言中确实是一种约定
It's indeed a convention in Python and some other languages

542
00:26:27,640 --> 00:26:31,390
当你想要向世界表明的时候 至少要把你的变量大写
to at least capitalize your variables when you want to indicate to the world

543
00:26:31,390 --> 00:26:33,370
你不应该碰这个 
that you should not touch this.

544
00:26:33,370 --> 00:26:34,720
它是恒定不变的 
It is constant.

545
00:26:34,720 --> 00:26:38,067
但在我的代码中几乎没有任何东西阻止我说 
But there is literally nothing in my code preventing me from saying,

546
00:26:38,067 --> 00:26:38,650
你猜怎么着？
you know what?

547
00:26:38,650 --> 00:26:41,440
今天 我感觉自己像是四只猫 
Today I feel like four meows instead.

548
00:26:41,440 --> 00:26:42,460
这会奏效的 
That would work.

549
00:26:42,460 --> 00:26:44,260
在其他语言中 虽然通常有
In other languages though there's typically

550
00:26:44,260 --> 00:26:47,200
句法上的关键字或某些其他机制
a keyword or some other mechanism syntactically that

551
00:26:47,200 --> 00:26:51,940
将允许您阻止当前执行第三行 
would allow you to prevent line three currently from executing.

552
00:26:51,940 --> 00:26:55,510
因此 当您尝试运行代码时 实际上会收到一条错误消息
So that when you try to run your code, you would actually get an error message

553
00:26:55,510 --> 00:26:57,770
明确地说 你不能这样做 
explicitly saying, you cannot do that.

554
00:26:57,770 --> 00:27:00,370
所以 在荣誉体系上 Python又一次显得更加重要了
So Python, again, is a bit more on the honor system

555
00:27:00,370 --> 00:27:02,680
相反 当涉及到这些约定时 
when it comes to these conventions instead.

556
00:27:02,680 --> 00:27:06,190
现在 事实证明还有其他类型的常量 引用不引用 
Now, it turns out there's other types of constants, quote unquote,

557
00:27:06,190 --> 00:27:07,932
这是巨蟒通常会表现出来的 
that Python typically manifests.

558
00:27:07,932 --> 00:27:10,640
事实上 让我继续下去 改变一下这一点 
And in fact, let me go ahead and change this around a little bit.

559
00:27:10,640 --> 00:27:12,140
让我删除这个版本的猫咪 
Let me delete this version of meows.

560
00:27:12,140 --> 00:27:15,430
让我再次介绍一下我们讨论过的一个班级
And let me introduce, again, a class from our discussion

561
00:27:15,430 --> 00:27:18,070
面向对象编程的一部分 就像表示
of object-oriented programming, like a class representing

562
00:27:18,070 --> 00:27:20,710
一只猫 另一个真实世界的实体 
a cat, another real-world entity.

563
00:27:20,710 --> 00:27:23,650
回想一下 在类中 您不仅可以拥有
Recall that within classes, you can have not just

564
00:27:23,650 --> 00:27:26,170
实例变量和类变量 
instance variables but class variables.

565
00:27:26,170 --> 00:27:30,430
也就是说 类中的变量本身并不在自身内部 
That is variables inside of the class that aren't inside of self, per se,

566
00:27:30,430 --> 00:27:33,490
但是类中的所有方法都可以访问它们 
but they're accessible to all of the methods inside of that class.

567
00:27:33,490 --> 00:27:36,340
这里也是一样 有一个惯例 但没有强制执行
Here too, there's a convention but not enforced

568
00:27:36,340 --> 00:27:40,840
通过拥有类常量的Python 从而在类内部 
by Python of having class constants, whereby inside of the class,

569
00:27:40,840 --> 00:27:45,220
您可能希望有一个应该、应该、不应该更改的变量 
you might want to have a variable that should, should, should not be changed.

570
00:27:45,220 --> 00:27:49,040
但您只是想通过将其名称大写来在视觉上表明这一点 
But you just want to indicate that visually by capitalizing its name.

571
00:27:49,040 --> 00:27:51,820
例如 如果一只猫的默认猫叫声数量
So for instance, if the default number of meows for a cat

572
00:27:51,820 --> 00:27:55,480
应该是三个 我可以在我的班级里
is meant to be three, I can literally inside of my class

573
00:27:55,480 --> 00:27:58,360
但在我定义的任何方法之外
but outside of any of my defined methods just

574
00:27:58,360 --> 00:28:02,390
创建一个全部用相同的值大写的类变量 
create a class variable all capitalized with that same value.

575
00:28:02,390 --> 00:28:05,500
然后 如果我想创造一种方法 比如猫叫 
And then, if I want to create a method, like meow,

576
00:28:05,500 --> 00:28:09,710
例如 正如我们所知 作为一个实例方法 它可能会接受self 
for instance, which as an instance method might take in self as we know.

577
00:28:09,710 --> 00:28:13,130
然后 我可能会在这里用我的循环来下划线--
And then, I might have my loop here for underscore in the range of--

578
00:28:13,130 --> 00:28:14,380
现在我需要访问这个 
and now I need to access this.

579
00:28:14,380 --> 00:28:17,980
约定将会说猫叫以表明
The convention would be to say cat.meows to make clear

580
00:28:17,980 --> 00:28:22,570
我想要与名为cat的类相关联的猫叫声变量 
that I want the meows variable that's associated with the class called cat.

581
00:28:22,570 --> 00:28:25,780
然后 我将继续打印出其中一条猫咪叫声 
Then I'm going to go ahead and print out one of these meows.

582
00:28:25,780 --> 00:28:29,230
现在 在我的代码底部 在类之外 让我继续
And now, at the bottom of my code, outside of the class, let me go ahead

583
00:28:29,230 --> 00:28:30,380
做这样的事情 
and do something like this.

584
00:28:30,380 --> 00:28:33,340
让我使用CAT构造函数实例化一只猫 
Let me instantiate a cat using the cat constructor.

585
00:28:33,340 --> 00:28:34,690
请注意这一点很重要 
Notice this is important.

586
00:28:34,690 --> 00:28:38,710
根据我们对OOP的讨论 这个类是按照约定大写的 
Per our discussion of OOP, the class is capitalized by convention.

587
00:28:38,710 --> 00:28:41,360
但这里的变量是小写的 
But the variable over here is lowercase.

588
00:28:41,360 --> 00:28:44,030
我可以称它为C或其他任何东西 
And I could call it just C or anything else.

589
00:28:44,030 --> 00:28:47,440
但我有点喜欢这里叫它小猫和大猫的对称性 
But I kind of like the symmetry of calling it little cat here and big cat,

590
00:28:47,440 --> 00:28:48,730
可以这么说 就在这里 
so to speak, over here.

591
00:28:48,730 --> 00:28:51,550
现在 如果我想让这只特别的猫叫
And now, if I want this particular cat to meow

592
00:28:51,550 --> 00:28:55,660
默认的三次 我可以像这样做猫咪 
that default number of three times, I can just do cat.meow like this.

593
00:28:55,660 --> 00:29:01,990
该方法将在第五行中访问该类常量 
And that method meow is going to, per line five, access that class constant.

594
00:29:01,990 --> 00:29:04,390
但同样 它只是在事实中是不变的--
But again, it's constant only in the fact--

595
00:29:04,390 --> 00:29:08,770
只是在你不应该碰它的意义上 并不是说它实际上
only in the sense that you should not touch that, not that it's actually

596
00:29:08,770 --> 00:29:11,500
将由语言强制执行 
going to be enforced by the language.

597
00:29:11,500 --> 00:29:15,040
那么 让我继续使用Python of meows.py来运行它 
Let me go ahead then and run this with Python of meows.py.

598
00:29:15,040 --> 00:29:18,250
它就在那里 我们的三只猫叫 喵 喵 
And there it is, three of our meows, meow, meow.

599
00:29:18,250 --> 00:29:22,480
事实证明 Python是一种动态类型的语言 
It turns out that Python is a dynamically typed language.

600
00:29:22,480 --> 00:29:24,520
也就是说 它不是强类型的 
That is to say, it's not strongly typed.

601
00:29:24,520 --> 00:29:27,520
因此 当你想要一个整型的时候 你必须告诉程序
Whereby when you want an int, you have to tell the program

602
00:29:27,520 --> 00:29:28,870
您使用的是一个整型 
that you are using an int.

603
00:29:28,870 --> 00:29:32,350
您不必告诉程序您正在使用字符串或浮点数 
You don't have to tell the program that you are using a str, or a float,

604
00:29:32,350 --> 00:29:34,150
或者一套 或者其他任何东西 
or a set, or anything else.

605
00:29:34,150 --> 00:29:37,450
一般来说 到目前为止 你和我 当我们创造变量时 
Generally speaking, to date, you and I, when we're creating variables,

606
00:29:37,450 --> 00:29:39,190
我们只需为变量命名即可 
we just give a variable a name.

607
00:29:39,190 --> 00:29:42,850
我们经常在等号中给它赋值 
We frequently assign it using in the equal sign some other value.

608
00:29:42,850 --> 00:29:44,950
老实说 Python只是一种动态
And honestly, Python just kind of dynamically

609
00:29:44,950 --> 00:29:47,590
找出它是哪种类型的变量 
figures out what type of variable it is.

610
00:29:47,590 --> 00:29:51,790
如果是 引用单引号Hello world 变量将是一个str 
If it's, quote unquote Hello, world, the variable is going to be a str.

611
00:29:51,790 --> 00:29:55,820
如果它是50 那么变量的整数将是一个整型 
If it's 50, the integer the variable is going to be an int.

612
00:29:55,820 --> 00:30:00,310
现在 在其他语言中 包括C、C++和Java等 
Now, in other languages, including C, and C++, and Java, and others,

613
00:30:00,310 --> 00:30:05,050
程序员有时需要指定哪些类型
it's sometimes necessary for the programmer to specify what types

614
00:30:05,050 --> 00:30:07,810
你想要的东西的变量 
of variables you want something to be.

615
00:30:07,810 --> 00:30:11,710
这样做的好处是它帮助您更容易地检测到错误 
The upside of that is that it helps you detect bugs more readily.

616
00:30:11,710 --> 00:30:15,760
因为如果您打算让变量存储字符串或整数 
Because if you intend for a variable to store a string or an integer,

617
00:30:15,760 --> 00:30:19,900
但是您不小心存储了一个整数或字符串 反之亦然
but you accidentally store an integer or a string, the opposite, or something

618
00:30:19,900 --> 00:30:24,583
否则 您的语言可以为您检测到这种错误 
else altogether, your language can detect that kind of mistake for you.

619
00:30:24,583 --> 00:30:26,500
例如 当你去运行程序时 
When you go, for instance, to run the program,

620
00:30:26,500 --> 00:30:28,420
它可以说 不 你犯了一个错误 
it can say, no, you've made a mistake.

621
00:30:28,420 --> 00:30:31,840
您可以在您的实际用户检测到相同数量之前修复该问题 
And you can fix that before your actual users detect as much.

622
00:30:31,840 --> 00:30:35,770
在Python语言中也是如此 这是一个更友好的环境
In Python too here, it's again, more of a friendly environment

623
00:30:35,770 --> 00:30:38,680
您可以在其中提供有关Python本身的提示
where you can provide hints to Python itself

624
00:30:38,680 --> 00:30:41,230
关于变量应该是什么类型 
as to what type a variable should be.

625
00:30:41,230 --> 00:30:44,620
但语言本身并没有严格执行这些规定 
But the language itself does not strongly enforce these.

626
00:30:44,620 --> 00:30:48,820
相反 您可以使用一个工具来告诉您是否
Rather, you can use a tool that will tell you whether or not

627
00:30:48,820 --> 00:30:50,620
您正确地使用了变量 
you're using a variable correctly.

628
00:30:50,620 --> 00:30:53,440
但它通常是一个以程序员的身份运行的工具
But it's typically a tool you would run as the programmer

629
00:30:53,440 --> 00:30:56,140
在你真正向世界发布你的代码之前 
before you actually release your code to the world.

630
00:30:56,140 --> 00:30:59,770
或者 如果你有某种自动化的流程 你可以运行这种工具
Or if you have some kind of automated process, you can run this kind of tool

631
00:30:59,770 --> 00:31:03,730
就像您可以使用其他程序重新格式化或链接到您的代码一样
just like you could reformat or link to your code with some other program

632
00:31:03,730 --> 00:31:06,470
在你真正将其公之于众之前 
before you actually release it to the world.

633
00:31:06,470 --> 00:31:09,220
那么 我们应该如何使用这些所谓的类型提示呢？
So how might we go about using these so-called type hints?

634
00:31:09,220 --> 00:31:12,700
好的 它们在Python自己的文档中的常见位置进行了记录 
Well, they're documented in the usual place in Python's own documentation.

635
00:31:12,700 --> 00:31:14,500
事实证明 有一个项目
And it turns out there's a program that's

636
00:31:14,500 --> 00:31:17,950
非常流行的检查代码是否
pretty popular for checking whether or not your code is

637
00:31:17,950 --> 00:31:19,990
坚持你自己的类型提示 
adhering to your own type hints.

638
00:31:19,990 --> 00:31:22,052
这个程序在这里被称为mypy 
And that program here is called mypy.

639
00:31:22,052 --> 00:31:23,260
这只是几个中的一个 
And it's just one of several.

640
00:31:23,260 --> 00:31:26,020
但这个特别受欢迎 可以很容易地安装
But this one is particularly popular and can be easily installed

641
00:31:26,020 --> 00:31:29,380
以通常的方式使用pip安装mypy 
in the usual way with pip install mypy.

642
00:31:29,380 --> 00:31:31,900
它自己的文档在这里的URL上 
And its own documentation is at this URL here.

643
00:31:31,900 --> 00:31:36,160
但是我们将非常简单地使用它来检查我们的变量是否确实
But we'll use it quite simply to check whether or not our variables are indeed

644
00:31:36,160 --> 00:31:37,660
使用正确的类型 
using the right types.

645
00:31:37,660 --> 00:31:39,550
那么 我们该如何着手做这件事呢？
So how can we go about doing this?

646
00:31:39,550 --> 00:31:43,150
好了 让我回到VS代码 清除我的终端窗口 
All right, let me go back here to VS Code, clear my terminal window,

647
00:31:43,150 --> 00:31:46,180
事实上 删除当前的meows.py 
and in fact erase meows.py as it currently was.

648
00:31:46,180 --> 00:31:49,240
让我们实现一个不同版本的猫咪 非常简单
And let's implement a different version of meows that quite simply

649
00:31:49,240 --> 00:31:52,303
有一个名为猫咪的功能 可以在屏幕上进行实际的猫咪叫声 
has a function called meow that does the actual meowing on the screen.

650
00:31:52,303 --> 00:31:54,970
然后 我将继续向下调用该函数
And then, I'm just going to go ahead and call that function down

651
00:31:54,970 --> 00:31:55,690
接近底部 
toward the bottom.

652
00:31:55,690 --> 00:31:58,357
为了简单起见 我不打算费心使用main函数
I'm not going to bother with a main function just for simplicity

653
00:31:58,357 --> 00:32:01,090
这样我们就可以一如既往地专注于新事物 
so that we can focus as always only on what's new.

654
00:32:01,090 --> 00:32:03,940
所以在这里 我们定义了一个名为meow的函数 
So here we are defining a function called meow.

655
00:32:03,940 --> 00:32:08,920
猫叫需要很多次 比如n代表数字 
It's going to take a number of times to meow, for instance n for number.

656
00:32:08,920 --> 00:32:11,170
在这个函数内部 我要做的是
And inside of this function, I'm going to do

657
00:32:11,170 --> 00:32:16,430
我通常在n的范围内加下划线 继续打印 引用不引用 
my usual for underscore in the range of n go ahead and print, quote unquote,

658
00:32:16,430 --> 00:32:16,930
喵星人 
meow.

659
00:32:16,930 --> 00:32:19,900
因此 根据我们前面的代码 我认为这是正确的 
So based on our earlier code, I think this is correct.

660
00:32:19,900 --> 00:32:22,158
我没有费心将变量定义为I 
I've not bothered defining the variable as i.

661
00:32:22,158 --> 00:32:24,950
我改为使用下划线 因为我不会在任何地方使用它 
I'm instead using the underscore because I'm not using it anywhere.

662
00:32:24,950 --> 00:32:27,580
但我想我现在有了一个工作职能 它的人生目标
But I think I now have a working function whose purpose in life

663
00:32:27,580 --> 00:32:31,400
就是猫叫0次、1次、2次、3次或更多次 
is to meow zero, or one, or two, or three, or more times.

664
00:32:31,400 --> 00:32:34,073
好的 让我们再次使用这个函数 不用担心main 
Well, let's use this function, again, not bothering with main.

665
00:32:34,073 --> 00:32:37,240
我只会把我的功能放在最上面 因为只有一个 
I'm just going to keep my function at the very top because there's only one.

666
00:32:37,240 --> 00:32:40,292
我将把我的代码写在第六行 
And I'm going to write my code here on line six.

667
00:32:40,292 --> 00:32:41,500
所以我要给自己--
So I'm going to give myself--

668
00:32:41,500 --> 00:32:43,692
我要向用户索要一个号码 
I'm going to ask the user for a number.

669
00:32:43,692 --> 00:32:45,400
我将继续并提示他们
And I'm going to go ahead and prompt them

670
00:32:45,400 --> 00:32:48,730
以惯常的方式猫叫那么多次 
in the usual way for that number of times to meow.

671
00:32:48,730 --> 00:32:52,870
现在 我要继续用这个号码叫猫咪 
And now, I'm going to go ahead and call meow on that number.

672
00:32:52,870 --> 00:32:56,080
现在 你们中的一些人可能会看到我已经做错了什么 
Now, some of you might see what I've already done wrong.

673
00:32:56,080 --> 00:32:57,460
但也许我自己并不这样认为 
But perhaps I myself don't.

674
00:32:57,460 --> 00:33:01,330
所以让我进入我的终端窗口并运行Python of meows.py 
So let me go into my terminal window and run Python of meows.py,

675
00:33:01,330 --> 00:33:03,220
这样做的目的是为了促使我 
the goal being to prompt me.

676
00:33:03,220 --> 00:33:04,460
这似乎奏效了 
This seems to be working.

677
00:33:04,460 --> 00:33:05,860
我要打三个字 
I'm going to type in three.

678
00:33:05,860 --> 00:33:10,690
我希望现在的猫咪功能会打印出三次猫咪 
And I would expect now the meow function to print out meow three times.

679
00:33:10,690 --> 00:33:11,800
进来吧 
Enter.

680
00:33:11,800 --> 00:33:12,850
但是没有 
But no.

681
00:33:12,850 --> 00:33:17,200
这里有某种类型的错误 无法解释字符串对象
There's some kind of type error here. str object cannot be interpreted

682
00:33:17,200 --> 00:33:18,760
作为一个整数 
as an integer.

683
00:33:18,760 --> 00:33:21,590
为什么会这样呢？
Why might that be?

684
00:33:21,590 --> 00:33:23,530
为什么会这样呢？
Why might that be?

685
00:33:23,530 --> 00:33:28,230
学生：因为输入函数返回的是字符串 而不是整数 
STUDENT: Because the input function returns a string instead of an integer.

686
00:33:28,230 --> 00:33:29,230
大卫·J·马兰：没错 
DAVID J. MALAN: Exactly.

687
00:33:29,230 --> 00:33:32,530
INPUT函数返回字符串或字符串 而不是整型 
The input function returns a string or a str, not an int.

688
00:33:32,530 --> 00:33:35,530
所以在过去 当然 我们对这个问题的解决方案
So in the past, of course, our solution to this problem

689
00:33:35,530 --> 00:33:39,250
通过使用int函数将字符串转换为int 
has just been to convert the string to an int by using the int function.

690
00:33:39,250 --> 00:33:42,010
但现在 让我开始更有防御性的编程
But now, let me start programming more defensively

691
00:33:42,010 --> 00:33:46,660
所以老实说 我根本没有发现自己处于这种情况 
so that honestly, I don't even find myself in this situation at all.

692
00:33:46,660 --> 00:33:48,260
让我继续做这件事 
Let me go ahead and do this.

693
00:33:48,260 --> 00:33:51,760
让我将所谓的类型提示添加到我的函数中
Let me add what's called a type hint to my function that

694
00:33:51,760 --> 00:33:56,890
显式地为meow指定应该传递什么类型的变量 
explicitly specifies for meow what type of variable should be passed in.

695
00:33:56,890 --> 00:33:59,830
现在 我将继续更改代码的第一行
I'm going to go ahead now and change the very first line of my code

696
00:33:59,830 --> 00:34:05,020
和我的函数来指定n冒号应该是整型
and my function to specify that n colon should be an int

697
00:34:05,020 --> 00:34:07,420
这是一个类型提示 事实是我已经
and this is a type hint, the fact that I've

698
00:34:07,420 --> 00:34:10,929
添加了冒号、空格 单词int没有创建
added a colon, a space, and the word int is not creating

699
00:34:10,929 --> 00:34:12,920
另一个整型或类似的东西 
another int or anything like that.

700
00:34:12,920 --> 00:34:17,170
这只是一个提示 一个注解 对Python来说 
It's just a hint, an annotation, so to speak to Python,

701
00:34:17,170 --> 00:34:22,190
左边这个名为n的变量应该是一个整型 
that this variable on the left called n should be an int.

702
00:34:22,190 --> 00:34:25,330
不幸的是 Python本身并不关心这一点 
Now, unfortunately, Python itself doesn't care.

703
00:34:25,330 --> 00:34:28,150
因为同样 这些类型提示不是由语言强制执行的 
Because again, these type hints are not enforced by the language.

704
00:34:28,150 --> 00:34:29,650
这是经过精心设计的 
And that's by design.

705
00:34:29,650 --> 00:34:31,540
语言本身和社区更喜欢
The language itself and the community prefers

706
00:34:31,540 --> 00:34:34,719
Python应该是动态类型的 而不是强类型的
that Python be dynamically typed, not so strongly typed

707
00:34:34,719 --> 00:34:36,760
要求这些东西是真的
as to require these things to be true.

708
00:34:36,760 --> 00:34:41,360
但是如果我运行meows.py 再次输入3 同样的错误仍然存在 
But if I run meows.py, type in three again, the same error is there.

709
00:34:41,360 --> 00:34:46,989
但是让我来试试这个mypy程序 一个程序的例子 
But let me go about trying this mypy program, an example of a program that

710
00:34:46,989 --> 00:34:48,530
理解类型提示 
understands type hints.

711
00:34:48,530 --> 00:34:53,500
如果我主动运行它 我自己就能在代码中找到这样的bug
And if I run it proactively myself can find bugs like this in my code

712
00:34:53,500 --> 00:34:58,030
在我 或者更糟的是 一个用户 实际运行并遇到一些神秘的东西之前 
before I, or worse, a user, actually runs and encounters something cryptic

713
00:34:58,030 --> 00:34:59,770
比如这里的类型错误 
like this type error here.

714
00:34:59,770 --> 00:35:05,260
让我清除我的终端窗口 这次运行我的空间meows.py 
Let me clear my terminal window and this time run mypy space meows.py.

715
00:35:05,260 --> 00:35:10,300
所以我将在我的程序中运行mypy 但我不会运行Python本身 
So I'm going to run mypy on my program, but I'm not running Python itself.

716
00:35:10,300 --> 00:35:13,280
当我按回车键时 我们会看到这个 
When I hit Enter, we'll see this.

717
00:35:13,280 --> 00:35:13,780
好吧
All right.

718
00:35:13,780 --> 00:35:17,770
我们现在看到我在第七行发现了一个明显的错误 
We see now that mypy found apparently an error on line seven.

719
00:35:17,770 --> 00:35:23,080
错误 meow的参数1具有不兼容的类型str（应为int） 
Error, argument one to meow has incompatible type str expected int.

720
00:35:23,080 --> 00:35:24,670
所以这仍然是一个错误消息 
So it's still an error message.

721
00:35:24,670 --> 00:35:27,880
但我的用户不会使用mypy 
But mypy is not a program that my users would use.

722
00:35:27,880 --> 00:35:31,240
这是一个你和我作为程序员都会使用的程序 
This is a program that you and I as programmers would use.

723
00:35:31,240 --> 00:35:35,200
因为我们已经运行了这段代码 例如 
And because we have run this code now before we, for instance, released

724
00:35:35,200 --> 00:35:39,400
我现在甚至可以在代码被调用或运行之前看到 
this program to the world, I can now see even before the code is called or run,

725
00:35:39,400 --> 00:35:43,730
哦 我好像用我的论点来喵错了 
oh, I seem to be using my argument to meow wrong.

726
00:35:43,730 --> 00:35:45,880
我最好想办法解决这个问题 
I had better fix this somehow.

727
00:35:45,880 --> 00:35:49,030
其实我可以给你一些提示
Well, I can actually go about in hints adding

728
00:35:49,030 --> 00:35:53,650
类型提示 甚至是我自己的变量 以便以另一种方式捕获它 
type hints even to my own variables here so as to catch this another way too.

729
00:35:53,650 --> 00:35:57,640
如果我在第六行知道我已经创建了一个变量number 
If I know on line six that I'm creating already a variable called number,

730
00:35:57,640 --> 00:36:02,560
我已经知道我在给input的返回值赋值equal
and I know already that I'm assigning equal to the return value of input,

731
00:36:02,560 --> 00:36:07,120
我可以给我的电脑和类似的工具另一个提示 然后说 你知道吗？
I could give mypy and tools like it another hint and say, you know what?

732
00:36:07,120 --> 00:36:10,510
这个叫做number的变量也应该是一个int 
This variable called number should also be an int.

733
00:36:10,510 --> 00:36:14,650
也就是说 如果我现在开始养成注释的习惯 
That is to say, if I now start getting into the habit of annotating

734
00:36:14,650 --> 00:36:17,740
所有函数的变量和参数
all of my variables and arguments to functions,

735
00:36:17,740 --> 00:36:20,530
也许我的电脑能帮我找到
maybe mypy can actually help me find things

736
00:36:20,530 --> 00:36:24,430
在我开始运行Python之前 我也会很快地 
quite quickly as well before I get to the point of running Python itself.

737
00:36:24,430 --> 00:36:26,050
我们再来一次 
Let's go ahead and try this again.

738
00:36:26,050 --> 00:36:28,930
Mypy的meows.py和点击回车 
Mypy of meows.py and hit Enter.

739
00:36:28,930 --> 00:36:31,870
这一次 请注意mypy实际上找到了
And this time, notice that mypy actually found

740
00:36:31,870 --> 00:36:34,120
犯错误的速度要快一点 
the mistake a little more quickly.

741
00:36:34,120 --> 00:36:38,860
请注意 这一次它在第六行发现 错误 不兼容的类型
Notice this time it found on line six that, error, incompatible types

742
00:36:38,860 --> 00:36:42,820
赋值表达式的类型为str 变量的类型为int 
and assignment expression has type str, variable has type int.

743
00:36:42,820 --> 00:36:45,940
所以在我还没来得及叫猫咪之前 
So before I even got to the point of calling meow,

744
00:36:45,940 --> 00:36:50,350
第六行 通过此类型提示 在由mypy使用和分析时
line six, via this type hint, when used and analyzed by mypy

745
00:36:50,350 --> 00:36:52,060
帮我找到了 哦 等一下 
has helped me find, oh, wait a minute.

746
00:36:52,060 --> 00:36:55,060
我不应该为输入的返回值赋值
I shouldn't be assigning the return value of input

747
00:36:55,060 --> 00:36:57,920
添加到我的变量名为number的位置 
to my variable called number in the first place.

748
00:36:57,920 --> 00:36:58,420
为什么？
Why?

749
00:36:58,420 --> 00:37:01,460
Mypy刚才向我指出 返回一个字符串 
Mypy has just pointed out to me that one returns a str.

750
00:37:01,460 --> 00:37:02,890
我正在等待一个整型 
I'm expecting an int.

751
00:37:02,890 --> 00:37:05,002
现在让我来解决这个问题吧 
Let me fix this now instead.

752
00:37:05,002 --> 00:37:06,460
因此 让我清除我的终端窗口 
So let me clear my terminal window.

753
00:37:06,460 --> 00:37:08,380
现在 让我来做你们大多数人可能会做的事情
And now, let me do what most of you were probably

754
00:37:08,380 --> 00:37:11,380
在经历了这么多周之后 我想我一开始就应该这么做 
thinking I should have done in the first place after all of these weeks.

755
00:37:11,380 --> 00:37:15,580
但现在 让我们继续将输入的返回值转换为整数 
But now, let me go ahead and convert the return value of input to an integer.

756
00:37:15,580 --> 00:37:17,950
为了今天的目的 我不会尝试
For today's purposes, I'm not going to try

757
00:37:17,950 --> 00:37:19,733
以捕捉任何异常或类似情况 
to catch any exceptions or the like.

758
00:37:19,733 --> 00:37:22,400
我们只需要假设用户正确地输入了这些内容 
We're just going to assume that the user types this in properly.

759
00:37:22,400 --> 00:37:26,830
现在 让我继续运行mypy of meows.py 
And now, let me go ahead and run mypy of meows.py,

760
00:37:26,830 --> 00:37:31,450
不仅向我的参数、函数添加了类型提示 
having not only added to type hints to my argument, to my function,

761
00:37:31,450 --> 00:37:33,940
赋给我的变量 在第六行 
to my variable down here on line six.

762
00:37:33,940 --> 00:37:36,620
我现在也解决了这个问题本身 
And I've also now fixed the problem itself.

763
00:37:36,620 --> 00:37:38,090
让我继续运行mypy 
Let me go ahead and run mypy.

764
00:37:38,090 --> 00:37:41,480
并且成功 在一个源文件中没有发现任何问题 
And success, no issues found in one source file.

765
00:37:41,480 --> 00:37:44,900
现在 对我来说更合理的是去经营一些
Now, it's more reasonable for me to go and run something

766
00:37:44,900 --> 00:37:49,280
就像猫叫声中的巨蟒一样 至少当我输入三个字时 我会相信它
like Python of meows and just trust that when I type in three, at least

767
00:37:49,280 --> 00:37:51,560
我不会遇到打字错误 
I'm not going to get a type error.

768
00:37:51,560 --> 00:37:54,680
也就是说 作为一名程序员 我没有搞砸
That is, I didn't mess up as a programmer with respect

769
00:37:54,680 --> 00:37:56,100
我的变量的类型 
to the types of my variables.

770
00:37:56,100 --> 00:37:56,600
为什么？
Why?

771
00:37:56,600 --> 00:37:58,642
因为我一开始写代码的时候 
Because when I wrote the code in the first place,

772
00:37:58,642 --> 00:38:00,620
我提供了这些注释 这些提示
I provided these annotations, these hints

773
00:38:00,620 --> 00:38:04,820
告诉像mypy这样的工具我的意图最好是
that inform tools like mypy that my intention had better

774
00:38:04,820 --> 00:38:07,730
与实际代码所做的事情保持一致 
line up with what the actual code does.

775
00:38:07,730 --> 00:38:13,160
让我在这里暂停一下 看看现在是否有关于类型提示或mypy的问题 
Let me pause here and see if there's now any questions on type hints or mypy.

776
00:38:13,160 --> 00:38:17,030
学生：这是常见的吗 或者这些被使用的有多常见？
STUDENT: Is it common or how common is it for those to be used?

777
00:38:17,030 --> 00:38:20,960
或者只是它更多地用于更复杂的代码中
Or is it just that it's more used in more complex code

778
00:38:20,960 --> 00:38:26,150
很难保证你真的
where it's more difficult to ensure that you're actually

779
00:38:26,150 --> 00:38:28,900
使用正确的类型 就像使用变量一样
using the correct type in the way that you're using the variables?

780
00:38:28,900 --> 00:38:30,442
大卫·J·马兰：这是个好问题 
DAVID J. MALAN: It's a good question.

781
00:38:30,442 --> 00:38:32,000
这是个见仁见智的问题 
And it's rather a matter of opinion.

782
00:38:32,000 --> 00:38:36,230
Python被设计得更通用和灵活 
Python was designed to be a little more versatile and flexible when

783
00:38:36,230 --> 00:38:39,980
其中一些细节 部分是为了可写性 
it comes to some of these details, partly for writeability, to make

784
00:38:39,980 --> 00:38:42,407
编写代码更容易、更快 部分原因是为了提高性能
it easier and faster to write code, partly for performance

785
00:38:42,407 --> 00:38:44,240
这样像Python这样的程序
so that the program like Python doesn't have

786
00:38:44,240 --> 00:38:45,710
去检查这些细节 
to bother checking these kinds of details,

787
00:38:45,710 --> 00:38:47,420
我们可以直接进入代码
we can just get right into the code.

788
00:38:47,420 --> 00:38:50,990
然而 实际情况是 
The reality, though, is that strong type checks

789
00:38:50,990 --> 00:38:54,120
对你的代码的正确性来说是件好事 
do tend to be a good thing for the correctness of your code.

790
00:38:54,120 --> 00:38:54,620
为什么要这样？
Why?

791
00:38:54,620 --> 00:38:58,970
因为像mypy这样的程序可以在你的代码运行之前 
Because programs like mypy can find, before your code is even run,

792
00:38:58,970 --> 00:39:01,430
如果已经知道有错误的话 
if there's already known to be an error.

793
00:39:01,430 --> 00:39:04,280
它往往有利于防御性编程 
And it tends to be good for defensive programming.

794
00:39:04,280 --> 00:39:09,560
因此 在Python生态系统中 
So the situation essentially is that within the Python ecosystem,

795
00:39:09,560 --> 00:39:12,260
你可以用这种方式来注释你的类型 
you can annotate your types in this way.

796
00:39:12,260 --> 00:39:14,900
您可以使用工具来使用这些类型提示 
You can use tools to use those type hints.

797
00:39:14,900 --> 00:39:17,630
但到目前为止 Python本身并没有强制执行
But to date, Python itself does not enforce

798
00:39:17,630 --> 00:39:20,270
或期望执行这些公约 
or expect to enforce these conventions.

799
00:39:20,270 --> 00:39:23,420
在更大的代码库中 在专业代码库中 
In larger code bases, in professional code bases,

800
00:39:23,420 --> 00:39:27,548
商业代码库 可能取决于项目经理
commercial code bases, probably depending on the project manager

801
00:39:27,548 --> 00:39:29,840
或者取决于工程团队 
or depending on the engineering team they may very well

802
00:39:29,840 --> 00:39:31,620
希望自己使用类型提示 
want themselves to be using type hints.

803
00:39:31,620 --> 00:39:32,120
为什么要这样？
Why?

804
00:39:32,120 --> 00:39:34,760
如果它能减少漏洞的可能性 
If it just decreases the probability of bugs.

805
00:39:34,760 --> 00:39:39,260
事实上 让我现在提议 我--想象一个情况 
In fact, let me propose now that I-- imagine a situation where

806
00:39:39,260 --> 00:39:45,020
而不是期望meow打印meow meow meow一些次数 
instead of expecting that meow prints meow, meow, meow some number of times,

807
00:39:45,020 --> 00:39:48,800
假设我不小心假设meow函数
suppose that I accidentally assume that the meow function

808
00:39:48,800 --> 00:39:51,650
只返回几次meow 
just returns meow some number of times.

809
00:39:51,650 --> 00:39:53,990
例如 我们在关注单元测试时看到 
We saw, for instance when focusing on unit tests

810
00:39:53,990 --> 00:39:57,260
有返回值的函数是件好事
that it tends to be a good thing to have functions that return values,

811
00:39:57,260 --> 00:40:00,770
不管是int还是字符串 
be it an int or a string, rather than just having some side effect

812
00:40:00,770 --> 00:40:02,460
比如自己打印东西
like printing things out themselves.

813
00:40:02,460 --> 00:40:04,370
所以 也许我仍然保持着这种心态 
So perhaps I'm still in that mindset.

814
00:40:04,370 --> 00:40:07,160
我只是一时误会了
And I've just assumed mistakenly for the moment

815
00:40:07,160 --> 00:40:11,810
这种猫叫返回一个值 就像猫叫 猫叫 或者猫叫 
that meow returns a value, like meow, or meow meow, or meow meow meow,

816
00:40:11,810 --> 00:40:15,620
一大串猫咪 而不是自己打印出来的 
a big string of some number of meows, rather than just printing it itself,

817
00:40:15,620 --> 00:40:18,080
就像现在三号线上很明显的那样 
as it clearly does at the moment on line three.

818
00:40:18,080 --> 00:40:21,770
因此 假设我意外地做了这样的事情 
And therefore, suppose that I accidentally did something like this.

819
00:40:21,770 --> 00:40:27,230
假设我这样做了 而不是简单地获得数字并将其传递给猫咪 
Rather than just getting the number and passing it to meow, suppose I did this.

820
00:40:27,230 --> 00:40:31,850
假设我声明了一些--一个新的变量 叫做猫咪 
Suppose I declared a number of-- a new variable called meows,

821
00:40:31,850 --> 00:40:34,730
我认为其类型应该是str 
the type of which I think should be str.

822
00:40:34,730 --> 00:40:37,490
假设 再一次 我意外地假设
And suppose, again, I assume accidentally

823
00:40:37,490 --> 00:40:42,170
那猫叫回传给我一连串的猫叫 所以我自己
that meow returns to me a string of those meows so that I myself

824
00:40:42,170 --> 00:40:43,430
然后可以稍后打印它们 
can then print them later.

825
00:40:43,430 --> 00:40:47,070
可以说 这会更有利于测试我的猫咪功能 
This would be a little more conducive, arguably, to testing my meow function.

826
00:40:47,070 --> 00:40:47,570
为什么？
Why?

827
00:40:47,570 --> 00:40:51,380
因为我可以预料到它还会叫 或者叫 
Because I could expect that it's returning meow, or meow meow,

828
00:40:51,380 --> 00:40:53,600
或者猫咪 用新的线隔开 
or meow meow meow, separated by new lines,

829
00:40:53,600 --> 00:40:56,990
返回一个字符串 然后我可以断言等于
returning a str that I could then assert equals

830
00:40:56,990 --> 00:40:59,875
我希望它会出现在类似单元测试的东西中 
what I expect it to be in something like a unit test.

831
00:40:59,875 --> 00:41:02,000
我现在不会费心编写任何单元测试 
I'm not going to bother writing any unit tests now.

832
00:41:02,000 --> 00:41:04,880
但让我们假设这就是我现在的心态 
But let's just suppose that's the mindset I'm now in.

833
00:41:04,880 --> 00:41:08,060
所以 在第七行 我假设我
And so, on line seven I'm assuming that I

834
00:41:08,060 --> 00:41:12,860
我想将meow的返回值赋给一个名为meow的新变量 该变量
want to assign the return value of meow to a new variable called meows which

835
00:41:12,860 --> 00:41:16,340
我已经使用该类型提示将其注释为字符串 
I've annotated with this type hint as being a str,

836
00:41:16,340 --> 00:41:18,210
这样我们就能看到另一个变量 
just so we can see another variable.

837
00:41:18,210 --> 00:41:20,990
这不是int 而是一个str 
This one is not an int but a str instead.

838
00:41:20,990 --> 00:41:25,340
好 现在让我继续运行这段代码 meows.py的Python 
Well, let me go ahead and run this code now, Python of meows.py,

839
00:41:25,340 --> 00:41:27,170
回车 输入三个 
Enter, typing in three.

840
00:41:27,170 --> 00:41:29,300
你会看到一个奇怪的虫子 
And you'll see a curious bug.

841
00:41:29,300 --> 00:41:31,490
没有猫叫没有猫叫 
Meow meow meow none.

842
00:41:31,490 --> 00:41:33,000
好吧 为什么呢？
Well, why is that?

843
00:41:33,000 --> 00:41:37,310
现在看来 我的猫咪功能只有一个副作用 
Well, it turns out at the moment, my meow function only has a side effect.

844
00:41:37,310 --> 00:41:39,650
它只是打印了几次猫咪 
It just prints out meow some number of times.

845
00:41:39,650 --> 00:41:42,080
它不会显式返回值 因为它
It doesn't explicitly return a value as it

846
00:41:42,080 --> 00:41:44,810
如果那里真的有Return关键字 那就好了 
would if there were literally the return keyword there.

847
00:41:44,810 --> 00:41:47,270
那么 在默认情况下 当Python中的函数
By default then, when a function in Python

848
00:41:47,270 --> 00:41:50,870
不显式返回值 它的隐式返回值
does not explicitly return a value, its implicit return value

849
00:41:50,870 --> 00:41:52,340
实际上是没有的 
is in effect none.

850
00:41:52,340 --> 00:41:55,850
所以 我们在这里看到的是--在第八行 
And so, what we're seeing here is this-- on line eight,

851
00:41:55,850 --> 00:42:01,970
因为我正在为meow赋值 返回值为None 
because I'm assigning the return value of meow, which is none,

852
00:42:01,970 --> 00:42:08,660
对于我的猫咪变量 第三行是仍在打印猫咪的猫咪 
to my meows variable, line three is what's still printing meow meow meow.

853
00:42:08,660 --> 00:42:12,290
第八行现在错误地不打印任何内容 
And line eight is what's now incorrectly printing none.

854
00:42:12,290 --> 00:42:16,430
因为我意外地认为meow返回一个值 但它不是 
Because I accidentally thought that meow returns a value, but it doesn't.

855
00:42:16,430 --> 00:42:18,770
因此 它的返回值实际上是无 
So its return value is effectively none.

856
00:42:18,770 --> 00:42:22,920
所以我在底部奇怪地印上了“无”这个词 
So I'm printing very weirdly the word none at the bottom.

857
00:42:22,920 --> 00:42:26,180
那么 我怎样才能着手捕捉到这种错误呢？
So how could I go about catching this kind of mistake too?

858
00:42:26,180 --> 00:42:27,510
我可能会犯这个错误 
I might make this mistake.

859
00:42:27,510 --> 00:42:29,690
但如果我养成了这个习惯 也许频率会更低
But maybe with less frequency if I'm in the habit

860
00:42:29,690 --> 00:42:34,700
使用这个称为类型提示的新功能来注释我的代码 
of annotating my code with this new feature called type hints.

861
00:42:34,700 --> 00:42:36,520
你在这里能做的就是 
What you can do here is this.

862
00:42:36,520 --> 00:42:39,060
让我清理我的终端窗口来处理那个神器 
Let me clear my terminal window to get rid of that artifact.

863
00:42:39,060 --> 00:42:43,860
在这里 让我另外指定一些看起来很有趣的语法
And up here, let me additionally specify with some funny looking syntax

864
00:42:43,860 --> 00:42:48,840
我的猫咪功能实际上是被设计成没有返回任何东西 
that my meow function actually by design returns none.

865
00:42:48,840 --> 00:42:51,300
所以你真的使用了这个箭头符号 
So you literally use this arrow notation.

866
00:42:51,300 --> 00:42:56,400
在Python中 当提示函数的返回值是什么时 
In Python when hinting what the return value of a function is,

867
00:42:56,400 --> 00:42:57,750
你会这么做的 
you would do this.

868
00:42:57,750 --> 00:43:02,760
括号后有空格、连字符、大于号、
After the parentheses, a space, a hyphen, a greater than symbol,

869
00:43:02,760 --> 00:43:06,270
如箭头 然后是另一个空格 然后是返回值的类型 
like an arrow, and then another space, and then the type of the return value.

870
00:43:06,270 --> 00:43:07,800
就目前而言 它确实会--
For now, it's indeed going to--

871
00:43:07,800 --> 00:43:10,080
[燕子]对不起 请不要退货 
[SWALLOWS] excuse me, return none.

872
00:43:10,080 --> 00:43:12,990
但现在 至少我可以像这样抓到它 
But now, at least I can catch it like this.

873
00:43:12,990 --> 00:43:17,010
如果我现在不是在我的代码上运行Python而是mypy 这将是一种习惯
If I now run not Python but mypy on my code, which would be a habit

874
00:43:17,010 --> 00:43:18,960
我现在开始学习如何使用类型提示 
I'm now getting into if using type hints.

875
00:43:18,960 --> 00:43:22,770
在运行程序之前 请检查我是否正确使用了所有类型 
Check that I'm using all of my types correctly before I even run my program.

876
00:43:22,770 --> 00:43:27,930
我们会看到现在Mypy已经在网上找到了七个猫 引用引述 
We'll see that now mypy has found online seven that meow, quote unquote,

877
00:43:27,930 --> 00:43:29,770
不返回值 
does not return a value.

878
00:43:29,770 --> 00:43:34,530
Mypy知道这一点 因为我已经主动注释了我的猫咪功能
And mypy knows that because I have proactively annotated my meow function

879
00:43:34,530 --> 00:43:37,840
作为其返回值为None 
as having none as its return value.

880
00:43:37,840 --> 00:43:39,720
所以现在 Mypy可以检测到这一点 
So now, mypy can detect that.

881
00:43:39,720 --> 00:43:41,610
我现在应该意识到 哦 等一下 
I should now realize, oh, wait a minute.

882
00:43:41,610 --> 00:43:44,220
我在这里太愚蠢了 
I'm being foolish here.

883
00:43:44,220 --> 00:43:46,230
显然 Meow不返回值 
Meow clearly does not return a value.

884
00:43:46,230 --> 00:43:49,350
我不应该像在7号线上那样对待它 
I should not be treating it like it does on line seven.

885
00:43:49,350 --> 00:43:52,200
现在让我开始实际解决这个问题 
Let me go about actually fixing this now.

886
00:43:52,200 --> 00:43:53,970
那么 我该如何着手解决这个问题呢？
So how do I go about fixing this?

887
00:43:53,970 --> 00:43:56,700
那么 让我们练习一下我们在专注于单元测试时所宣扬的内容 
Well, let's practice what we preached in our focus on unit tests,

888
00:43:56,700 --> 00:44:00,240
拥有像猫咪这样的功能不会像打印本身一样产生副作用 
having a function like meow not have side effects like printing itself.

889
00:44:00,240 --> 00:44:02,860
但让我们让它返回实际的字符串 
But let's have it return the actual string.

890
00:44:02,860 --> 00:44:04,890
我实际上可以干净利落地做这件事 
And I can actually do this kind of cleanly.

891
00:44:04,890 --> 00:44:08,560
让我在这里清除终端窗口中的错误消息 
Let me clear my error message in my terminal window here.

892
00:44:08,560 --> 00:44:10,110
让我把这里的循环去掉 
Let me get rid of the loop here.

893
00:44:10,110 --> 00:44:14,010
让我说这一次 好的 好的 猫咪会回来的
Let me say this time that OK, fine, meow is going to return

894
00:44:14,010 --> 00:44:16,770
值、实际字符串或字符串 
a value, an actual str or string.

895
00:44:16,770 --> 00:44:18,640
因此 我将None更改为str 
So I've changed none to str.

896
00:44:18,640 --> 00:44:20,980
现在 我可以用任何方式来实现这一点 
And now, I can implement this in any number of ways,

897
00:44:20,980 --> 00:44:21,990
甚至可以使用循环 
maybe even using a loop.

898
00:44:21,990 --> 00:44:25,260
但回想一下 我们在Python中有这样的语法 我认为 
But recall that we have this syntax in Python, which will, I think,

899
00:44:25,260 --> 00:44:27,010
为我们解决这个问题 
solve this problem for us.

900
00:44:27,010 --> 00:44:32,640
如果我想返回一个由n个猫咪组成的字符串 我实际上可以做的是 
If I want to return a string of n meows, what I can actually do,

901
00:44:32,640 --> 00:44:33,540
回想一下 这就是 
recall, is this.

902
00:44:33,540 --> 00:44:39,540
返回引号 反斜杠n 乘以那个数字n 
Return quote unquote meow, backslash n, times that number n.

903
00:44:39,540 --> 00:44:41,970
所以这是一个巧妙的俏皮话 避免了
So it's kind of a clever one-liner, avoids

904
00:44:41,970 --> 00:44:44,640
需要一个for循环或更复杂的东西 
the need for a for loop or something more involved than that,

905
00:44:44,640 --> 00:44:50,730
简单地说 将猫咪的反斜杠n对自己乘三次 或n次 
to just say, multiply meow backslash n against itself three times, or n times,

906
00:44:50,730 --> 00:44:55,710
在这种情况下 一般来说 这样我就可以得到一大串零叫 一 
in this case, in general, so that I get back a big string of zero meows, one,

907
00:44:55,710 --> 00:44:58,530
取而代之的是更多的两声、三声或更多的叫声 
two, three, or many more meows instead.

908
00:44:58,530 --> 00:45:01,810
我想现在我在第六行的代码实际上是正确的 
I think now my code on line six is actually correct.

909
00:45:01,810 --> 00:45:04,410
现在我已经改变了猫咪的行为方式
Now I've changed meow to behave the way I was

910
00:45:04,410 --> 00:45:06,610
假装它总是奏效 
pretending to assume it always worked.

911
00:45:06,610 --> 00:45:11,910
所以我存储了一个str类型的变量 
So I'm storing in meows plural a variable that's of type str.

912
00:45:11,910 --> 00:45:16,830
因为现在 meow确实有一个字符串类型本身的返回值
Because now, meow does have a return value of type str itself

913
00:45:16,830 --> 00:45:20,440
根据此类型提示也是如此 
per this type hint as well.

914
00:45:20,440 --> 00:45:20,940
好的 
All right.

915
00:45:20,940 --> 00:45:22,830
现在让我继续打印猫咪 
Let me go ahead now and print meows.

916
00:45:22,830 --> 00:45:27,840
但因为我的每个猫咪都有一个尾随的新行 反斜杠n 
But because each of my meows comes with a trailing new line, the backslash n,

917
00:45:27,840 --> 00:45:30,750
我要主动修复一个小小的审美缺陷 
I'm going to proactively fix what would be a minor aesthetic bug.

918
00:45:30,750 --> 00:45:33,630
我只想避免输出额外的新行
And I'm just going to avoid outputting an extra new line

919
00:45:33,630 --> 00:45:35,250
在这三个国家的末尾 
at the end of those three.

920
00:45:35,250 --> 00:45:41,190
所以如果我现在运行Python of meows.py 输入3 这就是我的喵喵喵 
So if I run Python of meows.py now, type in three, there's my meow meow meow.

921
00:45:41,190 --> 00:45:45,450
而现在 什么都不提了 
And now, no mention of none.

922
00:45:45,450 --> 00:45:50,430
现在关于类型提示的问题 以及mypy中的这些注释 
Questions now on type hints, and these annotations in mypy,

923
00:45:50,430 --> 00:45:55,170
并使用它们来防御性地编写代码 希望这些代码能够减少
and using them to defensively write code that just decreases hopefully

924
00:45:55,170 --> 00:45:57,450
你自己感染病毒的可能性有多大？
the probability of your own bugs?

925
00:45:57,450 --> 00:46:04,230
学生：返回的三组是带双引号的吗？
STUDENT: Is the return three set have double quotes that

926
00:46:04,230 --> 00:46:10,020
有猫咪斜杠n 为什么程序不把它当作[？字符串？？]
have meow slash n, why the program don't take it as a [? string? ?]

927
00:46:10,020 --> 00:46:13,230
大卫·J·马兰：为什么节目不把它当作一种--奇怪的东西？
DAVID J. MALAN: Why does the program not take it as a-- as strange?

928
00:46:13,230 --> 00:46:14,370
学生：[听不见] 是的 
STUDENT: [INAUDIBLE], yeah.

929
00:46:14,370 --> 00:46:17,160
大卫·J·马兰：回想一下在这堂课的早期
DAVID J. MALAN: So recall that early on in the class

930
00:46:17,160 --> 00:46:19,800
我们将加号视为连接运算符
we looked at plus as a concatenation operator that

931
00:46:19,800 --> 00:46:22,050
允许您在左侧和右侧连接字符串 
allows you to join a string on the left and the right.

932
00:46:22,050 --> 00:46:26,820
乘法也是字符串的重载运算符 
Multiplication is also an overloaded operator for strings.

933
00:46:26,820 --> 00:46:30,870
因此 如果左边有一个字符串 右边有一个整型 
Whereby if you have a string on the left and an int on the right,

934
00:46:30,870 --> 00:46:35,250
可以说 它将通过连接或连接来乘以字符串
it will multiply the string, so to speak, by concatenating or joining

935
00:46:35,250 --> 00:46:38,350
那么多的猫叫加在一起 
that many meows all together.

936
00:46:38,350 --> 00:46:40,770
因此 这是面向对象编程的一个特性
So this is a feature of object-oriented programming

937
00:46:40,770 --> 00:46:45,540
和我们过去看到的操作符重载 
and an operator overloading as we saw it in the past.

938
00:46:45,540 --> 00:46:49,290
关于类型提示或输入的其他问题 
Other questions on type hints or mypy.

939
00:46:49,290 --> 00:46:54,468
学生：我们能不能不对这个变量数字的数据类型进行类型转换？
STUDENT: Can we not typecast this data type of this variable number?

940
00:46:54,468 --> 00:46:55,260
大卫·J·马兰：没有 
DAVID J. MALAN: No.

941
00:46:55,260 --> 00:46:57,300
你还是--让我更正一下术语 
You still-- and let me correct the terminology.

942
00:46:57,300 --> 00:47:00,870
在这种情况下 它不会被称为类型转换 因为它不像C#
It wouldn't be called typecasting in this context because it's not like C

943
00:47:00,870 --> 00:47:03,450
或者C++ 在这些类型之间存在等价性 
or C++ where there's an equivalence between these types.

944
00:47:03,450 --> 00:47:07,980
从技术上讲 您正在将第5行的a str转换为int 
You're technically converting on line five a str to an int.

945
00:47:07,980 --> 00:47:09,900
你还是得这么做 
You do still have to do this.

946
00:47:09,900 --> 00:47:12,060
例如 因为Mypy会对你大喊大叫
Because mypy, for instance, would yell at you

947
00:47:12,060 --> 00:47:15,850
如果您试图将右侧的字符串赋给左侧的int 
if you were trying to assign a str on the right to an int on the left.

948
00:47:15,850 --> 00:47:18,420
您仍然必须使用int函数 
You must still use the int function.

949
00:47:18,420 --> 00:47:20,290
INT本身仍然是一个函数 
Int itself is still a function.

950
00:47:20,290 --> 00:47:21,330
这不是类型提示 
It's not a type hint.

951
00:47:21,330 --> 00:47:26,340
但在这些类型提示中 int一词现在被以另一种方式使用 
But the word int is being used in another way now in these type hints.

952
00:47:26,340 --> 00:47:30,300
因此 这个int仍然是一个函数调用 一如既往 
So this int is still a function call as it always has been.

953
00:47:30,300 --> 00:47:33,690
左侧的语法是关键字int的另一种用法
This syntax on the left is another use of the keyword int

954
00:47:33,690 --> 00:47:35,680
而是以这些类型提示的形式 
but in the form of these type hints.

955
00:47:35,680 --> 00:47:39,170
因此 您仍然需要自己进行转换 
So you still have to do the conversion yourself.

956
00:47:39,170 --> 00:47:39,670
好的 
All right.

957
00:47:39,670 --> 00:47:44,050
让我建议我们过渡到Python的另一个有价值的功能
Let me propose that we transition to another feature of Python that's worth

958
00:47:44,050 --> 00:47:47,200
知道 特别是因为它是你会在野外看到的
knowing, especially since it's one that you'll see in the wild

959
00:47:47,200 --> 00:47:49,810
当你看到其他人编写的代码或库时 
when you see code or libraries that other folks have written,

960
00:47:49,810 --> 00:47:53,500
即被称为文档字符串或文档字符串的东西 
namely something known as a doc string or document strings.

961
00:47:53,500 --> 00:47:55,450
事实证明 在巨蟒的世界里
It turns out in the world of Python there

962
00:47:55,450 --> 00:47:59,680
是一种标准化的方式 根据另一个PEP Python增强提案 这一个
is a standardized way per another pep, Python Enhancement Proposal, this one

963
00:47:59,680 --> 00:48:05,830
257 这实质上标准化了您应该如何记录您的功能
257, that essentially standardizes how you should document your functions

964
00:48:05,830 --> 00:48:07,940
以及代码的其他方面 
among other aspects of your code.

965
00:48:07,940 --> 00:48:12,790
因此 例如 让我回到我的meows.py文件 
And so, for instance, let me go back to my meows.py file here.

966
00:48:12,790 --> 00:48:16,000
让我建议我们现在开始记录这些代码
And let me propose that we now start documenting this code

967
00:48:16,000 --> 00:48:18,550
也是为了让我知道猫叫函数的作用 
too so that I know what the meow function does.

968
00:48:18,550 --> 00:48:23,170
事实上 使用文档字符串表示法进行此操作的标准方法
And in fact, the standard way of doing this using doc string notation

969
00:48:23,170 --> 00:48:24,490
将如下所示 
would be as follows.

970
00:48:24,490 --> 00:48:27,460
注释此函数 而不是在其上方 因为您
To comment this function, not above it, as you

971
00:48:27,460 --> 00:48:31,520
通常可能有处理代码的习惯 但实际上是在代码内部 
might be in the habit of doing with code in general, but actually inside of it.

972
00:48:31,520 --> 00:48:35,260
但不是像这样用通常的散列评论符号来评论它 
But instead of commenting it like this with the usual hash comment sign,

973
00:48:35,260 --> 00:48:40,840
就像猫叫n次一样 结果是当你正式对接时--
like meow n times, it turns out that when you're formally docking--

974
00:48:40,840 --> 00:48:45,020
当您正式记录像这种情况下的meow这样的函数时 
when you're formally documenting a function like meow in this case,

975
00:48:45,020 --> 00:48:48,310
可以说 您不使用常规的内联注释 
you don't use regular inline comments, so to speak.

976
00:48:48,310 --> 00:48:50,440
您可以改用此语法 
You use this syntax instead.

977
00:48:50,440 --> 00:48:54,760
您可以使用三引号 可以是双引号 也可以是单引号 
You use triple quotation marks, either double or single.

978
00:48:54,760 --> 00:48:58,270
然后你写下你的评论 喵n次 
Then you write out your comment, meow n times.

979
00:48:58,270 --> 00:49:01,040
然后你在最后再写一遍同样的内容 
And then you write the same again at the end.

980
00:49:01,040 --> 00:49:03,370
所以要么是开头和结尾的三个双引号
So either three double quotes at the start and the end

981
00:49:03,370 --> 00:49:05,710
或者在开头和结尾加三个单引号 
or three single quotes at the start and the end.

982
00:49:05,710 --> 00:49:08,380
而Python已经在其中内置了某些工具
And Python has built into it certain tools

983
00:49:08,380 --> 00:49:13,420
以及某些假设 如果它检测到有使用
and certain assumptions that if it detects that there is a comment using

984
00:49:13,420 --> 00:49:16,780
此文档字符串的格式为左右三引号 
this doc string format triple quotes on the left and the right,

985
00:49:16,780 --> 00:49:20,210
它将假定这确实是该函数的文档 
it will assume that that's indeed the documentation for that function.

986
00:49:20,210 --> 00:49:23,770
事实证明 在Python生态系统中 有很多工具
And it turns out in the Python ecosystem, there's a lot of tools

987
00:49:23,770 --> 00:49:28,300
 然后可以用它来自动分析代码 提取
that you can then use to analyze your code automatically, extract

988
00:49:28,300 --> 00:49:31,750
所有这些文档字符串 甚至生成
all of these document strings for you, and even generate

989
00:49:31,750 --> 00:49:36,530
网页或PDF文档 用于您自己的功能 
web pages or PDFs of documentation for your own function.

990
00:49:36,530 --> 00:49:39,970
因此 如果你遵守这些惯例 就会有这些惯例
So there's these conventions via which if you adhere to them

991
00:49:39,970 --> 00:49:43,270
您可以开始为其他人记录您的代码
you can start documenting your code as for other people

992
00:49:43,270 --> 00:49:46,900
通过从您自己的代码自动生成文档
by generating automatically the documentation from your own code

993
00:49:46,900 --> 00:49:49,480
而无需手动从头开始编写内容 
without writing something up from scratch manually.

994
00:49:49,480 --> 00:49:53,650
现在 结果是如果您的函数确实接受参数
Now, it turns out if your function does take arguments

995
00:49:53,650 --> 00:49:56,830
也许做得更多 关于如何做有多种约定
and perhaps does a bit more, there are multiple conventions for how

996
00:49:56,830 --> 00:49:59,365
您可以为人类程序员记录
you can document for the human programmers that

997
00:49:59,365 --> 00:50:01,990
可能正在使用你的功能 无论是你 还是同事 
might be using your function, whether it's you, or a colleague,

998
00:50:01,990 --> 00:50:05,320
或互联网上的其他人 实际使用这些文档
or someone else on the internet, to actually use these docs

999
00:50:05,320 --> 00:50:08,270
字符串来标准化其中的信息 
strings to standardize the information therein.

1000
00:50:08,270 --> 00:50:10,180
所以你可能会看到这个 
So you might see this instead.

1001
00:50:10,180 --> 00:50:13,960
现在使用上面和下面相同的三重引号 
Using these same triple quotes above and below now,

1002
00:50:13,960 --> 00:50:19,420
你可能会看到你对这个功能的一句话解释 喵--
you might see your one-sentence explanation of the function, meows--

1003
00:50:19,420 --> 00:50:21,520
喵叫n次 
meow n times.

1004
00:50:21,520 --> 00:50:23,710
有时根据款式和用途 
Sometimes depending on the style and use,

1005
00:50:23,710 --> 00:50:27,220
它实际上可能仍然在第一行 但它下面有一个空行 
it might actually still be on the first line but with a blank line below it.

1006
00:50:27,220 --> 00:50:29,560
但我会把每一件东西都统一缩进 
But I'll keep everything uniformly indented.

1007
00:50:29,560 --> 00:50:34,000
这是一些流行的Python文档工具使用的约定
And this is a convention used by some popular Python documentation tools

1008
00:50:34,000 --> 00:50:34,660
也是 
as well.

1009
00:50:34,660 --> 00:50:39,850
您可以这样说语法--param n冒号 然后描述什么是n
You would say syntax like this-- param n colon, and then a description of what n

1010
00:50:39,850 --> 00:50:42,520
就是 猫叫的次数 
is, number of times to meow.

1011
00:50:42,520 --> 00:50:47,890
然后是冒号类型n冒号int 这只表示n的类型
Then colon type n colon int, which just indicates that the type of n

1012
00:50:47,890 --> 00:50:49,010
是一个整数 
is an integer.

1013
00:50:49,010 --> 00:50:53,050
然后 如果此函数实际上可以引发异常 
Then, if this function could actually raise an exception,

1014
00:50:53,050 --> 00:50:54,400
您也可以记录这一点 
you can document that too.

1015
00:50:54,400 --> 00:50:56,770
事实上 这并不是真的--
And actually, it's not really--

1016
00:50:56,770 --> 00:50:58,660
好吧 这可以说是我的错误 
well, it's arguably my mistake here.

1017
00:50:58,660 --> 00:51:01,990
如果n作为自变量进入 并且实际上不是整型 
If n comes in as an argument and is not, in fact, an int,

1018
00:51:01,990 --> 00:51:04,810
也许它是一个浮点 或者一个字符串 或者其他什么东西 
maybe it's a float, or a string, or something else,

1019
00:51:04,810 --> 00:51:08,060
这里的乘法符号不起作用 
the multiplication sign here is not going to work.

1020
00:51:08,060 --> 00:51:09,760
它不会使字符串倍增 
It's not going to multiply the string.

1021
00:51:09,760 --> 00:51:13,040
根据我的经验 它将触发一个类型错误 
It's going to trigger what I know from experience to be a type error.

1022
00:51:13,040 --> 00:51:16,240
所以我将继续在我自己的文档中积极地说
So I'm going to go ahead and proactively say in my own documentation

1023
00:51:16,240 --> 00:51:20,830
从技术上讲 这个函数如果使用不当 可能会引发类型错误 
that this function, technically, if you use it wrong could raise a type error,

1024
00:51:20,830 --> 00:51:23,740
尽管我在这里用这个注解来暗示
even though I'm hinting up here with this annotation

1025
00:51:23,740 --> 00:51:25,660
您应该传入一个int 
that you should pass in an int.

1026
00:51:25,660 --> 00:51:27,440
同样 Python不会强制执行这一点 
Again, Python doesn't enforce that.

1027
00:51:27,440 --> 00:51:29,500
所以如果你传递一个浮点数 这可能 事实上 
So if you pass in a float, this might, in fact,

1028
00:51:29,500 --> 00:51:31,520
引发此函数的类型错误 
raise this function a type error.

1029
00:51:31,520 --> 00:51:35,740
因此 如果n不是整型 就可能发生这种情况 
And so, that might happen if n is not an int.

1030
00:51:35,740 --> 00:51:39,730
最后 为了让其他程序员明白起见 我可能会说 
And then, lastly, I might say for clarity's sake for other programmers,

1031
00:51:39,730 --> 00:51:44,630
此函数返回一个由n个猫叫声组成的字符串 每行一个 
this function returns a string of n meows, one per line.

1032
00:51:44,630 --> 00:51:49,150
该值的返回类型 r类型 将是字符串 
And the return type of that value, r type, is going to be str.

1033
00:51:49,150 --> 00:51:54,410
现在 我在这里使用的所有语法本身并不是Python 
Now, all of this syntax here as I've used it is not Python per se.

1034
00:51:54,410 --> 00:51:56,740
这是一种称为重组文本的约定 它
This is a convention known as restructured text, which

1035
00:51:56,740 --> 00:51:58,930
是一种类似于标记的语言 它
is a form of markdown-like language that's

1036
00:51:58,930 --> 00:52:02,600
用于文档、网站、博客 甚至更多 
used for documentation, for websites, for blogs, and even more.

1037
00:52:02,600 --> 00:52:06,400
但这是在Python世界中流行的约定之一
But it's one of the popular conventions within the world of Python

1038
00:52:06,400 --> 00:52:08,570
来记录您自己的功能 
to document your own functions.

1039
00:52:08,570 --> 00:52:12,460
因此 这基本上与类型提示没有任何关系 
So this does not have anything to do fundamentally with type hints.

1040
00:52:12,460 --> 00:52:15,280
类型提示是Python的一项功能 
Type hints are a feature of Python.

1041
00:52:15,280 --> 00:52:19,840
我在这里所做的只是遵守第三方惯例
What I'm doing here is just adhering to a third party convention

1042
00:52:19,840 --> 00:52:24,580
从一开始就在一个Python文档字符串之间插入
of putting in between a Python doc string from the start

1043
00:52:24,580 --> 00:52:29,470
最后是某种标准格式 以便这些第三方工具可以
to the end a certain standard format so that these third party tools can

1044
00:52:29,470 --> 00:52:31,960
从上到下 从左到右分析我的代码 
analyze my code for me top to bottom, left to right,

1045
00:52:31,960 --> 00:52:35,260
理想的情况是为我生成文档 
and ideally generate documentation for me.

1046
00:52:35,260 --> 00:52:38,590
它可以生成PDF、网页或其他内容 
It can generate a PDF, a web page, or something else,

1047
00:52:38,590 --> 00:52:41,730
这样我或我的同事就不需要仅仅写
so that I or my colleagues don't need to not just only write

1048
00:52:41,730 --> 00:52:45,240
代码 而且还手动为我们的代码创建文档 
code but also manually create documentation for our code.

1049
00:52:45,240 --> 00:52:50,880
我们可以将所有东西放在一起 并使用工具为我们生成相同的东西 
We can keep everything together and use tools to generate the same for us.

1050
00:52:50,880 --> 00:52:55,050
现在对这些文档字符串有什么问题吗？
Any questions now on these doc strings, which

1051
00:52:55,050 --> 00:52:59,010
同样 还有一个惯例是经常记录您自己的代码
again are a convention of documenting your own code often

1052
00:52:59,010 --> 00:53:01,487
遵循一些标准语法吗？
following some standard syntax?

1053
00:53:01,487 --> 00:53:02,070
学生：是的 
STUDENT: Yeah.

1054
00:53:02,070 --> 00:53:06,150
所以 当你说你会把它记录下来并放到PDF中时 
So when you say you would document it and put it in a PDF,

1055
00:53:06,150 --> 00:53:10,300
这样做的目的是发布它并共享您的功能吗
is the purpose of doing this to publish it and share your function

1056
00:53:10,300 --> 00:53:12,105
这样其他用户就可以使用它了吗？
so other users can use it?

1057
00:53:12,105 --> 00:53:13,230
大卫·J·马兰：当然 
DAVID J. MALAN: Absolutely.

1058
00:53:13,230 --> 00:53:16,620
过去我们在安装一些第三方库的时候 比如说 
In the past, when we have installed some third party libraries, for instance,

1059
00:53:16,620 --> 00:53:18,240
就在几周前 
cowsay a few weeks back.

1060
00:53:18,240 --> 00:53:20,952
回想一下 我向您展示了它的功能 
Recall that I showed you what functions it had.

1061
00:53:20,952 --> 00:53:23,160
但如果你读了文档 你可能真的
But if you read the documentation, you might actually

1062
00:53:23,160 --> 00:53:27,350
确保该程序的作者为我们记录了这一点 
see that it was documented for us by the author of that program.

1063
00:53:27,350 --> 00:53:29,850
现在 我不相信他们在使用这种特殊的语法 
Now, I don't believe they were using this particular syntax.

1064
00:53:29,850 --> 00:53:31,920
但这对你我来说绝对是有用的
But it was definitely useful for you and me

1065
00:53:31,920 --> 00:53:35,850
能够阅读一些网页或PDF 告诉我们如何使用图书馆
to be able to read some web page or PDF telling us how to use the library

1066
00:53:35,850 --> 00:53:38,850
而不是浪费时间阅读别人的代码
rather than wasting time reading through someone else's code

1067
00:53:38,850 --> 00:53:42,040
并试图推断存在哪些功能以及如何使用它们 
and trying to infer what functions exist and how to use them.

1068
00:53:42,040 --> 00:53:45,090
它只是倾向于对开发人员更友好
It just tends to be much more developer-friendly to have

1069
00:53:45,090 --> 00:53:49,360
我们自己的代码或库的适当文档也是如此 
proper documentation for our own code or libraries as well.

1070
00:53:49,360 --> 00:53:50,430
还有其他问题吗？
Other questions?

1071
00:53:50,430 --> 00:53:51,450
学生：是的 
STUDENT: Yeah.

1072
00:53:51,450 --> 00:53:55,350
当使用文档字符串时 当它被用来生成PDF或其他什么时 
When with doc strings, when it's used to generate a PDF or whatever,

1073
00:53:55,350 --> 00:53:57,970
它包括任何代码吗？
does it include any of the code?

1074
00:53:57,970 --> 00:54:01,740
因此 如果你在评论中引用了 
So if you're referencing in your comment,

1075
00:54:01,740 --> 00:54:04,740
如果您在注释本身中引用代码 并且
if you're referencing the code in the comment itself and

1076
00:54:04,740 --> 00:54:07,110
如果没有看到代码 可能就没有意义了 
might not make sense without seeing the code.

1077
00:54:07,110 --> 00:54:09,843
它--这些包括它吗？
Does it-- do these include it?

1078
00:54:09,843 --> 00:54:11,760
大卫·J·马兰：简而言之 你可以做到 
DAVID J. MALAN: Short answer, you can do that.

1079
00:54:11,760 --> 00:54:13,420
不是在我在这里使用的惯例中 
Not in the convention I'm using here.

1080
00:54:13,420 --> 00:54:18,330
但实际上有一种聪明的方法可以在您的文档字符串中写入
But there's actually a clever way to write in your doc strings

1081
00:54:18,330 --> 00:54:23,320
函数的样例输入和函数的样例输出 
sample inputs to your functions and sample outputs for your functions.

1082
00:54:23,320 --> 00:54:25,950
如果您使用的是我们没有讨论过的其他工具 
And if you use a different tool that we've not discussed,

1083
00:54:25,950 --> 00:54:29,670
该工具将使用这些样例输入运行您的代码 
that tool will run your code using those sample inputs.

1084
00:54:29,670 --> 00:54:32,890
它将检查您的输出是否与您的样本输出匹配 
It will check that your outputs match your sample outputs.

1085
00:54:32,890 --> 00:54:36,090
如果没有 程序就会对你大喊大叫 说你在某个地方出了问题 
And if not, the program will yell at you saying, you've got a bug somewhere.

1086
00:54:36,090 --> 00:54:38,550
所以这是另一种你可以
So this is just another way where you can

1087
00:54:38,550 --> 00:54:44,040
使用文档字符串不仅可以记录代码 甚至可以捕获代码中的错误 
use doc strings to not only document but even catch errors in your code.

1088
00:54:44,040 --> 00:54:44,910
这件事已经很多了 
This has been a lot.

1089
00:54:44,910 --> 00:54:46,170
而且还有更多的事情要做 
And there's a bit more to go.

1090
00:54:46,170 --> 00:54:48,503
为什么我们不在这里休息五分钟呢？
Why don't we go ahead here and take a five-minute break.

1091
00:54:48,503 --> 00:54:51,660
当我们继续时 我们将看看Python的另一个功能 
And when we resume, we'll take a look at yet another feature of Python, yet

1092
00:54:51,660 --> 00:54:53,950
另一个更快编写代码的库 
another library to write code faster.

1093
00:54:53,950 --> 00:54:54,450
好的 
All right.

1094
00:54:54,450 --> 00:54:58,770
假设我们想要修改这个meow程序以实际接受它的输入 而不是
Suppose we want to modify this meows program to actually take its input not

1095
00:54:58,770 --> 00:55:02,070
从闪烁提示符中的输入功能 但从命令行 
from the input function in the blinking prompt but from the command line.

1096
00:55:02,070 --> 00:55:04,862
回想一下 在我们讨论库时 您可以使用一些
Recall in our discussion of libraries, that you could use something

1097
00:55:04,862 --> 00:55:07,752
像sys.argv一样获取命令行参数
like sys.argv to get at command line arguments

1098
00:55:07,752 --> 00:55:10,210
当你运行你的程序时 人类所提供的 
that a human has provided when you're running your program.

1099
00:55:10,210 --> 00:55:12,060
所以我们为什么不制作一个版本的猫咪呢
So why don't we whip up a version of meow

1100
00:55:12,060 --> 00:55:15,280
它使用命令行参数 而不是同样的输入 
that uses command line arguments instead of, again, input.

1101
00:55:15,280 --> 00:55:18,030
因此 我将继续删除我们到目前为止所做的工作 
So I'm going to go ahead and delete what we've done here thus far.

1102
00:55:18,030 --> 00:55:21,540
让我建议我们像过去一样导入系统 
And let me propose that we import sys as we've done in the past.

1103
00:55:21,540 --> 00:55:22,870
让我们开始行动吧 
And let's do this.

1104
00:55:22,870 --> 00:55:27,720
如果用户不键入任何命令行参数 情况会怎样？
How about if the user does not type any command line arguments.

1105
00:55:27,720 --> 00:55:29,910
那么我的程序只会猫叫一次 这样它就会
Then my program will just meow once, just so that it

1106
00:55:29,910 --> 00:55:32,070
做一些视觉上有趣的事情 
does something visually interesting.

1107
00:55:32,070 --> 00:55:35,310
否则 我们还为用户提供一个选项
Otherwise, let's also give the user an option

1108
00:55:35,310 --> 00:55:39,000
来指定我想让猫叫几次 
to specify how many times I want the cat to meow.

1109
00:55:39,000 --> 00:55:40,230
所以 让我们从简单的开始 
So let's start simple.

1110
00:55:40,230 --> 00:55:42,480
首先 让我们继续做这件事 
Let's first of all go ahead and do this.

1111
00:55:42,480 --> 00:55:47,790
如果sys.argv的长度等于1 
If the length of sys.argv equals equals one,

1112
00:55:47,790 --> 00:55:52,050
也就是说 用户只输入程序的名称 之后不输入其他内容
that is the user only typed the name of the program and nothing else after

1113
00:55:52,050 --> 00:55:52,950
那--
the--

1114
00:55:52,950 --> 00:55:58,350
在他们的指挥下 那么我们就像这样打印出一只猫叫 
in their command, then let's go ahead and just print out one meow like this.

1115
00:55:58,350 --> 00:56:02,200
否则 现在 让我们继续打印出类似这样的东西 
Else for now, let's go ahead and print out something like this.

1116
00:56:02,200 --> 00:56:04,980
否则继续打印 比方说 用法
Else go ahead and print out, let's say, usage

1117
00:56:04,980 --> 00:56:08,220
对于该程序 将使用meows.py 
for the program, which will be usage of meows.py,

1118
00:56:08,220 --> 00:56:12,360
只是为了让用户知道程序本身名为meows.py 
just so that the user knows that the program itself is called meows.py.

1119
00:56:12,360 --> 00:56:16,410
现在 让我转到我的终端窗口 开始输入Python of meows.py 
Now let me go down to my terminal window and start to type Python of meows.py.

1120
00:56:16,410 --> 00:56:20,070
此时 请注意sys.argv的长度
And at this point, notice that the length of sys.argv

1121
00:56:20,070 --> 00:56:21,300
确实应该是其中之一 
should indeed be one.

1122
00:56:21,300 --> 00:56:21,900
为什么？
Why?

1123
00:56:21,900 --> 00:56:25,500
嗯 这个名字根本不会出现在sys.argv中 
Well, Python the name doesn't end up in sys.argv at all ever.

1124
00:56:25,500 --> 00:56:28,470
但是meows.py 文件的名称是这样的 
But meows.py, the name of the file does.

1125
00:56:28,470 --> 00:56:31,320
它将以sys.argv为零 
And it's going to go in sys.argv zero.

1126
00:56:31,320 --> 00:56:32,592
但这只是其中一个因素 
But that's only one element.

1127
00:56:32,592 --> 00:56:34,050
所以这个东西的长度是1 
So the length of this thing is one.

1128
00:56:34,050 --> 00:56:35,470
右边没有更多的东西了 
There's nothing more to the right.

1129
00:56:35,470 --> 00:56:38,610
所以 当我现在按回车键时 我们应该会看到 确实 一声喵叫 
So when I hit Enter now we should see, indeed, one meow.

1130
00:56:38,610 --> 00:56:43,530
如果我不合作 假设我做了类似猫咪三次进入的事情 
If I don't cooperate, suppose I do something like meows three Enter.

1131
00:56:43,530 --> 00:56:46,800
然后我会看到一个提醒 这就是你使用程序的方式 
Then I'm going to see a reminder that this is how you use the program.

1132
00:56:46,800 --> 00:56:49,050
这是一种常见的约定 逐字打印出来
And this is a common convention to literally print out

1133
00:56:49,050 --> 00:56:52,140
单词用法 冒号 然后是程序的名称 
the word usage, a colon, then the name of the program,

1134
00:56:52,140 --> 00:56:54,240
也许还有一些关于如何使用它的解释 
and maybe some explanation of how to use it.

1135
00:56:54,240 --> 00:56:56,070
所以我把它弄得很简单 
So I'm keeping it very simple.

1136
00:56:56,070 --> 00:56:57,600
但让我们更花哨一点 
But let's be a little fancier.

1137
00:56:57,600 --> 00:57:01,770
如果我真的想让用户输入的内容不是三个 而是一些
What if I really wanted the user to type in maybe not three, but something

1138
00:57:01,770 --> 00:57:03,060
更加老练 
more sophisticated.

1139
00:57:03,060 --> 00:57:07,300
事实上 当从命令行控制程序时 
And in fact, when controlling programs from the command line,

1140
00:57:07,300 --> 00:57:11,550
提供通常被称为开关或标志的东西是非常常见的 
it's very common to provide what are often called switches or flags,

1141
00:57:11,550 --> 00:57:16,830
借此传入类似破折号n的内容 这在语义上意味着
whereby you pass in something like dash n, which semantically means

1142
00:57:16,830 --> 00:57:19,620
这个次数 然后通常是一个空格 
this number of times, then often a space,

1143
00:57:19,620 --> 00:57:21,420
然后是类似数字3的东西 
and then something like the number three.

1144
00:57:21,420 --> 00:57:24,940
这仍然允许我在命令行做其他事情 如果我想的话 
This still allows me to do other things at the command line if I want.

1145
00:57:24,940 --> 00:57:28,200
但事实上我已经标准化了我提供命令行的方式
But the fact that I've standardized on how I'm providing command line

1146
00:57:28,200 --> 00:57:30,690
此程序的参数为破折号n 3
arguments to this program with dash n three

1147
00:57:30,690 --> 00:57:34,440
只是我的程序现在更可靠的方式
is just a more reliable way now of my program

1148
00:57:34,440 --> 00:57:36,240
知道这三个字是什么意思 
knowing what does the three mean.

1149
00:57:36,240 --> 00:57:39,838
如果我只做meows.py space Three 就不那么明显了 
It's a little less obvious if I just do meows.py space three.

1150
00:57:39,838 --> 00:57:41,130
那么 这三个词是什么意思？
Well, what does the three mean?

1151
00:57:41,130 --> 00:57:44,087
至少使用像破折号nThree这样的语法 尤其是
At least with syntax like dash n three, especially

1152
00:57:44,087 --> 00:57:46,170
如果您已经阅读了此程序的文档 
if you've read the documentation for this program,

1153
00:57:46,170 --> 00:57:48,780
最终 哦 破折号n表示次数 
ultimately, oh, dash n means number of times.

1154
00:57:48,780 --> 00:57:49,290
明白了 
Got it.

1155
00:57:49,290 --> 00:57:51,990
这是一种传递两个额外参数的方式
It's a way of passing in two additional arguments

1156
00:57:51,990 --> 00:57:54,070
但这两者之间有一定的联系 
but that have some relationship between them.

1157
00:57:54,070 --> 00:57:58,830
那么 我如何修改我的程序以理解破折号n3呢？
So how do I modify my program to understand dash n three?

1158
00:57:58,830 --> 00:58:01,650
嗯 如果我像这样使用sys 我可以这样做 
Well, if I'm using sys like this, I could do this.

1159
00:58:01,650 --> 00:58:07,830
如果sys.argv的长度这次等于三 
elif the length of sys.argv equals this time three.

1160
00:58:07,830 --> 00:58:13,680
因为请注意 在我的提示下 有一、二、三件事 
Because notice, there's one, two, three things at my prompt.

1161
00:58:13,680 --> 00:58:17,910
因此 sys.argv是由空格分隔的0、1和2、3个元素 
So sys.argv is zero, one, and two, three things total separated by spaces.

1162
00:58:17,910 --> 00:58:19,380
如果等于三--
If it equals three--

1163
00:58:19,380 --> 00:58:27,000
为了安全起见 sys.argv括号1等于破折号n 
and let's be safe, and sys.argv bracket one equals equals dash n,

1164
00:58:27,000 --> 00:58:29,320
那么让我们继续做这件事 
then let's go ahead and do this.

1165
00:58:29,320 --> 00:58:37,680
让我们继续并将2的sys.argv转换为整数
Let's go ahead and convert sys.argv of two to an integer

1166
00:58:37,680 --> 00:58:40,560
并将其赋给一个变量 例如 名为n的变量 
and assign it to a variable, for instance, called n.

1167
00:58:40,560 --> 00:58:42,240
然后 让我们继续这样做 
And then, let's go ahead and do this.

1168
00:58:42,240 --> 00:58:46,470
对于n范围内的下划线 让我们继续
For underscore in the range of n, let's go ahead

1169
00:58:46,470 --> 00:58:48,395
打印出其中的一些猫咪叫声 
and print out some of these meows.

1170
00:58:48,395 --> 00:58:51,270
现在 也许还有机会巩固我的印刷线
Now, there's still an opportunity maybe to consolidate my print lines

1171
00:58:51,270 --> 00:58:51,730
用猫叫 
with meow.

1172
00:58:51,730 --> 00:58:53,897
但就目前而言 我将把这些想法分开 
But for now, I'm going to keep these ideas separate.

1173
00:58:53,897 --> 00:58:58,120
所以我将像以前一样处理缺省情况 这里没有参数 
So I'm going to handle the default case with no arguments up here as before.

1174
00:58:58,120 --> 00:59:01,530
现在 更有趣的是 我要把这一点讲清楚 
And now, more interestingly, I'm going to do this to be clear.

1175
00:59:01,530 --> 00:59:05,070
我将检查用户是否向我提供了三个命令行参数 即名称
I'm going to check if the user gave me three command line arguments, the name

1176
00:59:05,070 --> 00:59:07,710
程序的名称、破折号n和一个数字 
of the program, dash n, and a number.

1177
00:59:07,710 --> 00:59:15,030
如果他们在sys.argv中给我的第二个东西确实等于破折号n 
If indeed the second thing they gave me in sys.argv of 1 equals equals dash n,

1178
00:59:15,030 --> 00:59:19,410
然后我将假设接下来的事情 sys.argv of Two
then I'm going to assume that the next thing, sys.argv of two

1179
00:59:19,410 --> 00:59:21,030
将是一个整数 
is going to be an integer.

1180
00:59:21,030 --> 00:59:24,420
我会把它转换成这样 并存储在这个变量n中 
And I'll convert it to such and store it in this variable n.

1181
00:59:24,420 --> 00:59:28,960
现在 只要使用一个循环 我就会打印出这么多次的猫咪 
And now, just using a loop, I'm going to print out meow that many times.

1182
00:59:28,960 --> 00:59:32,190
好的 这是我们之前对循环的关注的一种结合 
All right, so it's kind of a combination of our earlier focus on loops,

1183
00:59:32,190 --> 00:59:34,290
我们之前的重点是命令行参数 
our earlier focus on command line arguments,

1184
00:59:34,290 --> 00:59:36,570
我只是在创建一个程序 让我可以宣称
just creating a program that allow me to claim

1185
00:59:36,570 --> 00:59:39,750
代表了许多命令行程序的工作方式 
is representative of how a lot of command line programs work,

1186
00:59:39,750 --> 00:59:42,130
尽管我们通常不会像这样使用太多 
even though we've typically not used many like this.

1187
00:59:42,130 --> 00:59:45,090
但这是非常常见的配置一个程序 一个 
But it's very common to configure a program, one,

1188
00:59:45,090 --> 00:59:47,700
您将在命令行中使用某些内容运行它
you're about to run it at the command line with something

1189
00:59:47,700 --> 00:59:51,120
就像这些命令行参数 如破折号n或其他破折号 
like these command line arguments like dash n or dash something else.

1190
00:59:51,120 --> 00:59:53,430
现在 我将继续并按Enter键 
Now, I'm going to go ahead and hit Enter.

1191
00:59:53,430 --> 00:59:57,360
我想我应该看到 确实 三只猫叫 
And I think I should see, indeed, three meows.

1192
00:59:57,360 --> 01:00:02,250
相比之下 如果我在最后做两次 我应该会看到两声喵叫 
By contrast, if I do two at the end, I should see two meows.

1193
01:00:02,250 --> 01:00:04,980
如果我做了一次 我应该会看到一只猫叫 
If I do one, I should see one meow.

1194
01:00:04,980 --> 01:00:07,860
坦率地说 如果我完全忽略这一点 
And frankly, if I just omit this altogether,

1195
01:00:07,860 --> 01:00:12,420
我也应该看到一个猫咪 因为这是我之前的默认情况 
I should see one meow as well, because that was my default case earlier.

1196
01:00:12,420 --> 01:00:17,880
现在 让我们假设这个项目最终
And now, let me allow us to assume that this program eventually

1197
01:00:17,880 --> 01:00:19,020
变得更复杂了 
gets more complicated.

1198
01:00:19,020 --> 01:00:22,620
让我们想象一个我不想只支持破折号n的世界 
Let's imagine a world where I don't want to support just dash n.

1199
01:00:22,620 --> 01:00:25,980
也许我想支持破折号a 破折号b 破折号c 
Maybe I want to support dash a, and dash b, and dash c,

1200
01:00:25,980 --> 01:00:27,870
和破折号d 还有很多其他的 
and dash d, and a whole lot of others.

1201
01:00:27,870 --> 01:00:30,400
或者 在这一点上 我应该给他们一些话 
Or heck, at that point, I should maybe give them words.

1202
01:00:30,400 --> 01:00:32,220
所以可能是个破折号 破折号 数字 
So maybe it's a dash, dash, number.

1203
01:00:32,220 --> 01:00:35,700
这确实是计算中的一个惯例 
It's indeed a convention in computing typically

1204
01:00:35,700 --> 01:00:40,620
使用单破折号和一个字母 如n 但使用双破折号
to use single dashes with a single letter, like n, but use double dashes

1205
01:00:40,620 --> 01:00:42,930
如果你真的用了一个完整的词比如数字
if you're actually using a whole word like number.

1206
01:00:42,930 --> 01:00:45,900
所以命令行参数可能是破折号n 或者
So the command line argument might be dash n, or maybe

1207
01:00:45,900 --> 01:00:47,490
是破折号 破折号号码 
it's dash, dash number.

1208
01:00:47,490 --> 01:00:50,490
但你可以想象这段代码有多复杂
But you can imagine just how complicated the code gets

1209
01:00:50,490 --> 01:00:54,448
如果现在您想支持破折号n、破折号a、破折号b、破折号c等等 
if now you want to support dash n, dash a, dash b, dash c, and so forth.

1210
01:00:54,448 --> 01:00:56,740
你得到处检查 
You're going to have to be checking all over the place.

1211
01:00:56,740 --> 01:00:58,532
如果它们的顺序不一样呢？
And what if they come in a different order?

1212
01:00:58,532 --> 01:01:00,570
你得先检查破折号 
You're going to have to check is dash n first,

1213
01:01:00,570 --> 01:01:02,910
还是第二第三还是第四
or is it second, or is it third, or is it's fourth?

1214
01:01:02,910 --> 01:01:06,240
我的意思是 这只是变得非常痛苦非常快
I mean, this just becomes very painful very quickly

1215
01:01:06,240 --> 01:01:09,840
只是做一些相对简单的事情 比如允许用户传递命令 
just to do something relatively simple like allow the user to pass command

1216
01:01:09,840 --> 01:01:11,700
将参数行放入程序中 
line arguments into your program.

1217
01:01:11,700 --> 01:01:15,390
这就是为什么图书馆总是存在 
Well, this is why, as always, there exist libraries.

1218
01:01:15,390 --> 01:01:18,240
Python附带的另一个库
And another library that comes with Python

1219
01:01:18,240 --> 01:01:22,350
可能值得了解的是这个叫做argparse的 
that's probably worth knowing something about is this one here called argparse.

1220
01:01:22,350 --> 01:01:26,640
事实上 我自己或CS50的团队用Python编写了很多工具 
In fact, with a lot of the tools I myself or CS50's team writes in Python,

1221
01:01:26,640 --> 01:01:29,490
我们经常使用argparse 
we very frequently use argparse whenever they

1222
01:01:29,490 --> 01:01:33,390
比我们的课堂演示要复杂得多 
are more complicated than a lot of our class demos and a little more similar

1223
01:01:33,390 --> 01:01:37,890
我们希望允许用户传入配置选项
to this one where we want to allow the user to pass in configuration options

1224
01:01:37,890 --> 01:01:39,420
在命令行中 
at the command line.

1225
01:01:39,420 --> 01:01:43,500
通过支持破折号N 破折号A 破折号B 破折号C 
And by supporting things like dash n, or dash a, or dash b, or dash c,

1226
01:01:43,500 --> 01:01:46,770
argparse是一个库 
argparse is a library that per its documentation

1227
01:01:46,770 --> 01:01:51,240
可以说 它只是处理所有这些解析 这些命令行分析
just handles all of this parsing so to speak, this analysis of command line

1228
01:01:51,240 --> 01:01:54,150
自动为您提供参数 以便您可以专注于
arguments for you automatically so you can focus

1229
01:01:54,150 --> 01:01:57,420
编写程序中有趣的部分 而不是命令行
on writing the interesting parts of your program, not the command line

1230
01:01:57,420 --> 01:01:58,780
论点部分 
arguments part.

1231
01:01:58,780 --> 01:02:00,160
那么我们该如何使用它呢？
So how might we use this?

1232
01:02:00,160 --> 01:02:02,040
让我们回到VS Code 
Well, let me go back to VS Code here.

1233
01:02:02,040 --> 01:02:03,630
我来清空终端窗口 
Let me clear my terminal window.

1234
01:02:03,630 --> 01:02:06,690
我建议用not sys重写这个代码
And let me propose that I rewrite this using not sys

1235
01:02:06,690 --> 01:02:08,037
但实际上使用的是argparse 
but actually using argparse.

1236
01:02:08,037 --> 01:02:10,620
我先从简单的开始 然后再逐步完善 
And I'm going to start a little simple and then build back up.

1237
01:02:10,620 --> 01:02:15,960
现在让我把所有这些都扔掉 转而导入argparse 
So let me throw all of this away for now and instead import argparse.

1238
01:02:15,960 --> 01:02:17,910
Argparse是argument parser的缩写 
Argparse stands for argument parser.

1239
01:02:17,910 --> 01:02:22,000
解析的意思是阅读它 把它拆开来分析 
To parse something means to read it, kind of pick it apart to analyze it.

1240
01:02:22,000 --> 01:02:24,300
所以这对我来说确实是这样 
So this is indeed going to do just that for me.

1241
01:02:24,300 --> 01:02:25,950
现在 让我继续做这个 
Now, let me go ahead and do this.

1242
01:02:25,950 --> 01:02:27,780
对于这个图书馆来说 
And for this library, it's helpful to know

1243
01:02:27,780 --> 01:02:30,600
一点面向对象的编程就像我们现在做的一样 
a little object-oriented programming like we all now do.

1244
01:02:30,600 --> 01:02:32,630
我将创建一个名为parser的变量 
I'm going to create a variable called parser.

1245
01:02:32,630 --> 01:02:34,255
不过 我想怎么叫都行 
Though I could call it anything I want.

1246
01:02:34,255 --> 01:02:40,270
我将把它设置为等于argparse.ArgumentParser的返回值 
I'm going to set it equal to the return value of argparse.ArgumentParser,

1247
01:02:40,270 --> 01:02:43,450
有一个大写的A和一个大写的P. A构造函数
with a capital A and a capital P. A constructor

1248
01:02:43,450 --> 01:02:47,650
Python自带的一个名为argument parser的类
for a class called argument parser that comes with Python itself

1249
01:02:47,650 --> 01:02:49,300
在这个图书馆里
within this library here.

1250
01:02:49,300 --> 01:02:52,690
现在 我要配置这个参数解析器
Now, I'm going to configure this argument parser

1251
01:02:52,690 --> 01:02:55,330
了解特定的命令行参数
to know about the specific command line arguments

1252
01:02:55,330 --> 01:02:58,010
我想在我的项目中支持的项目 
that I myself want to support in my program.

1253
01:02:58,010 --> 01:03:01,760
所以我会这样做 parser.add_argument 
So I'm going to do this, parser.add_argument.

1254
01:03:01,760 --> 01:03:04,990
这显然是解析器对象中的一个方法 
So that's apparently a method in the parser object.

1255
01:03:04,990 --> 01:03:07,600
我要加一个破折号n的参数 
I'm going to add an argument of dash n.

1256
01:03:07,600 --> 01:03:08,470
很简单
Easy enough.

1257
01:03:08,470 --> 01:03:11,772
现在我将继续实际解析命令行参数 
Now I'm going to go ahead and actually parse the command line arguments.

1258
01:03:11,772 --> 01:03:14,230
我将使用args 或者我可以将变量命名为任何值
I'm going to do args, or I could call the variable anything

1259
01:03:14,230 --> 01:03:17,890
我想要 解析器 解析器 
I want, parser.parseargs.

1260
01:03:17,890 --> 01:03:23,410
默认情况下 parseargs会自动为我查找sys.argv 
And by default, parseargs is going to automatically look at sys.argv for me.

1261
01:03:23,410 --> 01:03:25,450
我不需要自己导入sys 
I don't need to import sys myself.

1262
01:03:25,450 --> 01:03:30,670
我可以留下参数解析器 它的代码来导入sys 看看sys.argv 
I can leave the argument parser, its code to import sys, look at sys.argv,

1263
01:03:30,670 --> 01:03:34,000
找出破折号N或其他东西的实际位置
and figure out where dash n or anything else actually is.

1264
01:03:34,000 --> 01:03:36,970
好的是 这行代码
And what's nice now, because this line of code

1265
01:03:36,970 --> 01:03:42,250
这里导致解析器已经解析了所有的命令行参数 
here results in the parser having parsed all of the command line arguments,

1266
01:03:42,250 --> 01:03:46,360
我现在在变量args中有了这个对象
I now have this object in this variable called args inside

1267
01:03:46,360 --> 01:03:48,790
其中所有的值都是这些命令的值
of which are all of the values of those command

1268
01:03:48,790 --> 01:03:51,630
行参数 不管它们以什么顺序出现 
line arguments, no matter what order they appeared in.

1269
01:03:51,630 --> 01:03:54,130
当我只有一个的时候没什么大不了的 因为它只是
Not such a big deal when I've only got one because it's only

1270
01:03:54,130 --> 01:03:55,840
最后要去一个地方 
going to go in one place at the end.

1271
01:03:55,840 --> 01:03:58,342
但如果我有破折号n 破折号a 破折号b 破折号c 
But if I've got dash n, dash a, dash b, dash c,

1272
01:03:58,342 --> 01:04:00,550
你可以想象它们的顺序都不同 
you could imagine them being in all different orders.

1273
01:04:00,550 --> 01:04:02,467
它们绝对不一定要按字母顺序排列 
They definitely don't have to be alphabetical.

1274
01:04:02,467 --> 01:04:05,260
用户应该能够以他们想要的任何顺序键入它们 
The user should be able to type them in any order they want.

1275
01:04:05,260 --> 01:04:06,790
这在可用性方面更好 
That's better for usability.

1276
01:04:06,790 --> 01:04:09,430
Arg Parser将为我解决所有这些问题 
Arg parser is going to figure all of that out for me.

1277
01:04:09,430 --> 01:04:11,200
我现在要做的就是这个 
And all I have to do now is this.

1278
01:04:11,200 --> 01:04:16,300
如果我想迭代这么多数量的参数
If I want to iterate over that many numbers of arguments

1279
01:04:16,300 --> 01:04:18,310
更确切地说 这么多猫叫 我能做到 
and that many meows rather, I can do this.

1280
01:04:18,310 --> 01:04:24,280
用于在args.n的int转换范围内加下划线 
For underscore in the range of the int conversion of args.n.

1281
01:04:24,280 --> 01:04:27,340
因此 点是我们一直使用的访问内容的语法
So dot is the syntax we kept using to access things

1282
01:04:27,340 --> 01:04:29,860
就像对象内部的属性一样 
like properties inside of an object.

1283
01:04:29,860 --> 01:04:31,150
这就是ARGS的含义 
And that's what args is.

1284
01:04:31,150 --> 01:04:34,360
它是parse args函数为我返回的对象 
It's the object returned by the parse args function for me.

1285
01:04:34,360 --> 01:04:39,040
我现在要继续 打印出来 引用引语 猫叫这么多次 
I'm going to go ahead now and print out, quote unquote, meow this many times.

1286
01:04:39,040 --> 01:04:41,080
所以这并不是非常简单 
So it's not super simple.

1287
01:04:41,080 --> 01:04:45,520
这是我需要编写并理解的三行新代码 
These are three new lines of code I need to write and rather understand.

1288
01:04:45,520 --> 01:04:48,010
但它已经更简单、更紧凑了
But it's already a little simpler and more compact

1289
01:04:48,010 --> 01:04:52,540
而不是我的IF、ELIF、OR、AND 以及所有的布尔逻辑 
than my if, and my elif, and my ors, and my ands, and all of that Boolean logic.

1290
01:04:52,540 --> 01:04:54,560
它为我处理了很多这样的事情 
It's handling a lot of this for me.

1291
01:04:54,560 --> 01:04:58,780
因此 如果我没有犯任何错误 现在让我在meows.py Enter中运行Python 
So if I didn't make any mistakes, let me run Python now of meows.py Enter.

1292
01:04:58,780 --> 01:05:01,630
我确实在这里犯了一个错误 
And I did make a mistake here.

1293
01:05:01,630 --> 01:05:03,170
我确实犯了一个错误 
I did make a mistake.

1294
01:05:03,170 --> 01:05:05,620
现在这里出什么问题了？
What's wrong here now?

1295
01:05:05,620 --> 01:05:06,280
怎么了？
What's wrong?

1296
01:05:06,280 --> 01:05:08,860
嗯 我绝对没有按照我想要的方式来经营 
Well, I definitely didn't run it the way I intend.

1297
01:05:08,860 --> 01:05:11,110
因此 破折号n三次进入 
So dash n three Enter.

1298
01:05:11,110 --> 01:05:12,490
所以它确实起作用了 
So it does work.

1299
01:05:12,490 --> 01:05:16,990
但如果我不合作 这实际上似乎是一个更糟糕的版本 
But if I don't cooperate, this actually seems to be a worse version.

1300
01:05:16,990 --> 01:05:20,620
如果我没有传入破折号n和一个数字 它只会因为输入错误而出错 
If I don't pass in dash n and a number, it just errors with a type error.

1301
01:05:20,620 --> 01:05:22,000
Int必须是字符串 
Int must be a string.

1302
01:05:22,000 --> 01:05:23,260
没有一个是得到回报的 
None is what came back.

1303
01:05:23,260 --> 01:05:25,000
所以很明显这里有一个错误 
So there's clearly an error here.

1304
01:05:25,000 --> 01:05:27,160
但图书馆更加灵活 
But the library is more flexible.

1305
01:05:27,160 --> 01:05:31,220
实际上 我可以提供一些关于如何使用这个东西的文档 
I can actually provide some documentation on how to use this thing.

1306
01:05:31,220 --> 01:05:32,860
那我怎么知道怎么用这个呢？
So how do I know how to use this?

1307
01:05:32,860 --> 01:05:35,500
嗯 通常在Python语言中是常规的
Well, typically it's conventional in Python

1308
01:05:35,500 --> 01:05:39,160
并在许多编程环境中运行程序
and in a lot of programming environments to run a program

1309
01:05:39,160 --> 01:05:42,970
带有特殊参数的破折号h或破折号帮助 
with a special argument, dash h or dash dash help.

1310
01:05:42,970 --> 01:05:46,270
我几乎总是会说 到那时你会
And almost always I will claim you'll then

1311
01:05:46,270 --> 01:05:47,898
查看某种用法信息 
see some kind of usage information.

1312
01:05:47,898 --> 01:05:49,690
事实上 这就是我现在看到的 
And indeed, that's what I'm looking at now.

1313
01:05:49,690 --> 01:05:53,332
我刚刚运行了Python of meows.py空格破折号h 
I just ran Python of meows.py space dash h.

1314
01:05:53,332 --> 01:05:54,040
我会再来一次 
I'll do it again.

1315
01:05:54,040 --> 01:05:57,820
让我清除我的屏幕 这一次用英语做破折号帮助 回车 
Let me clear my screen and this time do dash dash help in English, Enter.

1316
01:05:57,820 --> 01:05:59,320
我也看到了同样的事情 
And I see the same thing.

1317
01:05:59,320 --> 01:06:01,510
目前它并不是很有用 
It's not very useful at the moment.

1318
01:06:01,510 --> 01:06:04,540
它只是告诉我这里的用法是什么 
It just shows me what the usage is up here.

1319
01:06:04,540 --> 01:06:06,200
这是一种有趣的现象 
And this is kind of interesting.

1320
01:06:06,200 --> 01:06:08,470
这是计算中的标准语法 
This is a standard syntax in computing.

1321
01:06:08,470 --> 01:06:11,200
我们以前在Python的文档中看到过这一点 
And we've kind of seen it in Python's documentation before.

1322
01:06:11,200 --> 01:06:14,530
当然 这只是意味着程序的名称是meows.py 
This just means that the program's name is, of course, meows.py.

1323
01:06:14,530 --> 01:06:20,060
方括号在文档中几乎总是这样 这意味着它是可选的 
Square brackets as almost always in documentation means it's optional.

1324
01:06:20,060 --> 01:06:22,862
所以我不需要输入破折号h 但我可以 
So I don't have to type dash h, but I can.

1325
01:06:22,862 --> 01:06:27,220
我不需要输入破折号n和另一个值 但我可以 
I don't have to type dash n and another value, but I can.

1326
01:06:27,220 --> 01:06:30,400
然后 下面是对这些选项的一些解释 
And then, down here is some explanation of these options,

1327
01:06:30,400 --> 01:06:32,530
更详细地告诉我 我也可以
and more verbosely showing me that I can also

1328
01:06:32,530 --> 01:06:34,900
DASH DASH帮助 而不是DASH 
do dash dash help and not just dash h.

1329
01:06:34,900 --> 01:06:36,075
但这太普通了 
But this is so generic.

1330
01:06:36,075 --> 01:06:37,700
这和我的计划无关 
This has nothing to do with my program.

1331
01:06:37,700 --> 01:06:39,783
这不会对我的用户有所帮助 因为我实际上
This is not going to help my users when I actually

1332
01:06:39,783 --> 01:06:41,390
向全世界发布这款软件 
release this software for the world.

1333
01:06:41,390 --> 01:06:43,000
因此 让我继续改进它 
So let me go ahead and improve it.

1334
01:06:43,000 --> 01:06:46,960
让我在我的参数解析器中添加一个人类将会看到的描述 
Let me add a description to my argument parser that the humans will see.

1335
01:06:46,960 --> 01:06:51,220
像猫一样叫 引述 将是这个名字的价值
Meow like a cat, quote unquote, is going to be the value of this named

1336
01:06:51,220 --> 01:06:52,690
参数称为Description 
parameter called description.

1337
01:06:52,690 --> 01:06:56,830
我还可以在我的破折号n中添加一个帮助参数
And let me also add a help parameter to my dash n

1338
01:06:56,830 --> 01:07:01,630
这个论点只是解释了破折号n的意思 猫咪的次数 
argument that just explains what dash n means, number of times to meow,

1339
01:07:01,630 --> 01:07:02,657
引用不引用 
quote unquote.

1340
01:07:02,657 --> 01:07:04,240
我不会再做任何改变了 
I'm not going to change anything else.

1341
01:07:04,240 --> 01:07:08,680
但我将返回到我的终端窗口 运行Python of Meow 
But I am going to go back to my terminal window and run Python of meow.

1342
01:07:08,680 --> 01:07:13,750
我将运行Python of meows.py dash h 或者等效破折号Help 
I'm going to run Python of meows.py dash h, or equivalently dash dash help.

1343
01:07:13,750 --> 01:07:17,570
现在请注意 这对用户更加友好 
And now notice that this is a little more user friendly.

1344
01:07:17,570 --> 01:07:19,900
如果我向上滚动 我们仍然可以看到相同的用法 
If I scroll up, we still see the same usage.

1345
01:07:19,900 --> 01:07:22,660
但是有一句简单的英语解释
But there's a quick sentence in English of explanation

1346
01:07:22,660 --> 01:07:24,310
这个程序的猫叫声就像猫一样 
that this program meows like a cat.

1347
01:07:24,310 --> 01:07:28,540
如果我现在看看选项 哦 这就是n的意思 
And if I look at the options now, oh, that's what n means.

1348
01:07:28,540 --> 01:07:30,940
这是猫咪叫的次数 
It's the number of times to meow.

1349
01:07:30,940 --> 01:07:34,280
这个大写的N 一个心理变量 如果你愿意的话 
And this capital N, a mental variable, if you will,

1350
01:07:34,280 --> 01:07:37,930
只是向我表明我需要按照惯例键入一个数字
is just indicating to me that I need to type a number by convention

1351
01:07:37,930 --> 01:07:40,780
在小写的破折号n之后 
after the lower case dash n.

1352
01:07:40,780 --> 01:07:43,930
所以 尽管如此 还是很好的 
So it would be nice though, all that said,

1353
01:07:43,930 --> 01:07:47,800
如果我的程序在没有任何命令行的情况下运行时仍然没有崩溃
if my program still didn't just break when I run it without any command line

1354
01:07:47,800 --> 01:07:48,490
争论 
arguments.

1355
01:07:48,490 --> 01:07:52,090
理想情况下 我的程序会像处理我的手动版本一样处理这件事
Ideally, my program would handle this just like my manual version

1356
01:07:52,090 --> 01:07:54,430
当我自己使用sys.argv时就是这样 
did when I used sys.argv myself.

1357
01:07:54,430 --> 01:07:58,540
因此 我们只需要向该库添加更多功能 
So we just need to add a little more functionality to this library.

1358
01:07:58,540 --> 01:08:02,230
如果我阅读文档 我会看到Add参数
And if I read the documentation, I'll see that add argument

1359
01:08:02,230 --> 01:08:04,450
接受另一个命名参数 
takes yet another named argument.

1360
01:08:04,450 --> 01:08:09,070
如果需要 可以为破折号n指定一个默认值 例如1 
If you want, you can specify a default value for dash n, for instance, one.

1361
01:08:09,070 --> 01:08:10,300
我会在那里做的 
And I'll do that there.

1362
01:08:10,300 --> 01:08:13,930
你可以进一步指定它必须是一个整型 
And you can further specify that it's got to be an int.

1363
01:08:13,930 --> 01:08:15,910
这还能让我做些什么呢
And what this will additionally allow me to do

1364
01:08:15,910 --> 01:08:20,890
就是如果我告诉arg解析器确保破折号n的值是一个整数 
is if I tell arg parser to make sure that the value of dash n is an int,

1365
01:08:20,890 --> 01:08:22,810
我不需要手动进行转换 
I don't need to do the conversion manually.

1366
01:08:22,810 --> 01:08:25,689
我可以在7号线上相信 当
I can just trust down on line seven that when

1367
01:08:25,689 --> 01:08:29,800
我访问Args对象中名为n的属性 
I access the property called n inside of my args object,

1368
01:08:29,800 --> 01:08:32,080
对我来说 这将自动成为一个整型 
it's going to be automatically an int for me.

1369
01:08:32,080 --> 01:08:34,689
再说一次 这就是图书馆的价值 
And again, this is the value of a library.

1370
01:08:34,689 --> 01:08:37,450
让它为你做所有的工作 这样你就可以回来了
Let it do all of the work for you so you can get back

1371
01:08:37,450 --> 01:08:40,090
专注于手头的有趣项目 
to focusing on the interesting project at hand,

1372
01:08:40,090 --> 01:08:42,520
不管你要解决的是什么问题 
whatever problem it is you're trying to solve.

1373
01:08:42,520 --> 01:08:45,939
在这种情况下 诚然 没有那么有趣 但像猫一样喵叫 
In this case, granted, not that interesting, but meowing like a cat.

1374
01:08:45,939 --> 01:08:49,779
现在让我继续运行Python of meows.py并按Enter键 
Let me go ahead now and run Python of meows.py and hit Enter.

1375
01:08:49,779 --> 01:08:52,250
这一次 没有争论 
This time, no arguments.

1376
01:08:52,250 --> 01:08:53,410
现在它在猫咪叫 
And now it meows.

1377
01:08:53,410 --> 01:08:53,979
为什么？
Why?

1378
01:08:53,979 --> 01:08:58,930
因为我指定如果我作为用户不指定破折号n 
Because I specified that if I don't, as a user, specify dash n,

1379
01:08:58,930 --> 01:09:01,149
很明显 它的缺省值为1 
it's going to have a default value of one apparently.

1380
01:09:01,149 --> 01:09:04,569
而且我不必将该值从字符串转换为整型
And I don't have to convert that value from a str to an int

1381
01:09:04,569 --> 01:09:09,760
因为我告诉Arg解析器 请为我设置一个整型 
because I told arg parser please just make this an int for me.

1382
01:09:09,760 --> 01:09:14,939
现在有任何关于argparse的问题吗 或者实际上是关于这个原理的问题
Any questions now on argparse, or really this principle

1383
01:09:14,939 --> 01:09:19,290
只是外包商品的东西 每个人的程序
of just outsourcing the commodity stuff, the stuff that everyone's program

1384
01:09:19,290 --> 01:09:22,950
最终需要这样做 这样你才能专注于你自己最有趣的部分 
eventually needs to do so that you can focus on the juicy part yourself.

1385
01:09:22,950 --> 01:09:25,319
学生：args.n包含什么？
STUDENT: What does args.n contain?

1386
01:09:25,319 --> 01:09:27,359
大卫·J·马兰：Ars.n包含什么？
DAVID J. MALAN: What does args.n contain?

1387
01:09:27,359 --> 01:09:35,609
它包含人类在破折号n后的空格后键入的整数 
It contains the integer that the human typed after a space after dash n.

1388
01:09:35,609 --> 01:09:36,220
问得好 
Good question.

1389
01:09:36,220 --> 01:09:38,729
还有其他问题吗？
Other questions?

1390
01:09:38,729 --> 01:09:40,473
学生：是的 
STUDENT: Yeah.

1391
01:09:40,473 --> 01:09:45,200
当您指定参数的类型时 
When you specify the type for the argument, what

1392
01:09:45,200 --> 01:09:49,250
如果--这是否基本上处理用户输入的异常
happens if-- does that basically handle the exception if the user inputs

1393
01:09:49,250 --> 01:09:50,450
在这种情况下是一根线吗？
a string in this case?

1394
01:09:50,450 --> 01:09:51,290
大卫·J·马兰：这是一个非常好的问题 
DAVID J. MALAN: A really good question.

1395
01:09:51,290 --> 01:09:54,502
假设人类没有键入数字 因此也没有输入 
Suppose that the human does not type a number and therefore not an in.

1396
01:09:54,502 --> 01:09:55,710
好吧 让我们看看会发生什么 
Well, let's see what happens.

1397
01:09:55,710 --> 01:10:01,730
所以 巨蟒的meows.py破折号n狗 其中狗显然不是一个数字 
So Python of meows.py dash n dog, where dog is obviously not a number.

1398
01:10:01,730 --> 01:10:02,450
进来吧 
Enter.

1399
01:10:02,450 --> 01:10:06,140
看 我们看到一条自动生成的错误消息 
And voila, we see an automatically generated error message.

1400
01:10:06,140 --> 01:10:07,730
诚然 这有点神秘 
A little cryptic, admittedly.

1401
01:10:07,730 --> 01:10:10,160
但我看到了一个提醒 它的用法是什么
But I'm seeing a reminder of what the usage is

1402
01:10:10,160 --> 01:10:13,820
以及对这一点的无效之处的一个次要解释 
and a minor explanation of what is invalid about this.

1403
01:10:13,820 --> 01:10:15,830
再一次 这是允许你 这是
And again, this is what allows you, this is

1404
01:10:15,830 --> 01:10:19,040
是什么让我能够专注于编写我们真正关心的代码
what allows me to focus on writing the actual code we care about

1405
01:10:19,040 --> 01:10:22,280
只是让图书馆为我们自动处理一些东西 
and just letting the library automate some of this stuff for us.

1406
01:10:22,280 --> 01:10:23,150
好的 
All right.

1407
01:10:23,150 --> 01:10:26,270
好吧 请允许我提议 现在我们来看看另一个特征
Well, allow me to propose now that we take a look at one other feature

1408
01:10:26,270 --> 01:10:28,190
我们以前见过的巨蟒 
of Python that we've seen before.

1409
01:10:28,190 --> 01:10:32,630
但事实证明 随着我们的程序变得更加强大 我们可以更有效地使用它
But it turns out we can use it even more powerfully as our programs become

1410
01:10:32,630 --> 01:10:35,990
变得更加复杂 我们试图解决的问题就会变成
more sophisticated and the problems we're trying to solve themselves become

1411
01:10:35,990 --> 01:10:36,830
更多的参与 
more involved.

1412
01:10:36,830 --> 01:10:42,020
让我继续前进 转到VS Code 结束meows.py 
Let me go ahead and turn to VS Code, closing out meows.py,

1413
01:10:42,020 --> 01:10:45,050
例如 创建一个名为unpack.py的新文件 
and creating a new file for instance, called unpack.py.

1414
01:10:45,050 --> 01:10:47,120
所以unpack.py的代码 
So code of unpack.py.

1415
01:10:47,120 --> 01:10:49,357
让我来提醒我们 拆开行李是什么意思 
And let me just remind us what we mean by unpacking.

1416
01:10:49,357 --> 01:10:52,190
因为这实际上是我们以前见过的Python的一个特性 
Because this is actually a feature of Python that we've seen before.

1417
01:10:52,190 --> 01:10:54,770
例如 假设我编写了一个程序 
For instance, suppose that I write a program that

1418
01:10:54,770 --> 01:10:58,040
提示用户输入他们的名字 如David space Malan 
prompts the user for their name, like David space Malan.

1419
01:10:58,040 --> 01:11:01,160
如果我们可以拆分用户名不是很好吗
Wouldn't it be nice if we could split the user's name

1420
01:11:01,160 --> 01:11:02,593
变成两个独立的变量？
into two separate variables?

1421
01:11:02,593 --> 01:11:05,760
当我们在过去做到这一点时 我们用了几种不同的方式 
And when we've done this in the past, we've done it in a few different ways.

1422
01:11:05,760 --> 01:11:10,910
但其中一项涉及拆解从那里返回的单一价值 
But one of them involved unpacking a single value that comes back from that,

1423
01:11:10,910 --> 01:11:13,340
类似于列表或一些其他数据结构 
like a list or some other data structure,

1424
01:11:13,340 --> 01:11:15,750
并立即将其转化为两个变量 
and putting it immediately into two variables.

1425
01:11:15,750 --> 01:11:16,890
所以让我们在这里开始吧 
So let's do this here.

1426
01:11:16,890 --> 01:11:20,360
让我们继续调用输入函数 
Let me go ahead and call the input function,

1427
01:11:20,360 --> 01:11:24,020
问别人你叫什么名字 问号 
asking someone what's your name, question mark.

1428
01:11:24,020 --> 01:11:27,770
然后 让我继续 只是在一个单独的空格上有点天真地分开 
Then, let me go ahead and just split a little naively on a single space.

1429
01:11:27,770 --> 01:11:29,960
所以我假设目前唯一的用户
So I'm assuming that the only users at the moment

1430
01:11:29,960 --> 01:11:32,570
是不是像我这样的人 大卫·斯派克·马兰 
are people like me, David space Malan.

1431
01:11:32,570 --> 01:11:34,310
没有中间名 没有多个名字 
No middle names, no multiple names.

1432
01:11:34,310 --> 01:11:37,610
它只有一个和两个 这本身就可能对其他用户来说是错误的 
It's just one and two, which itself could be buggy for other users.

1433
01:11:37,610 --> 01:11:39,950
但现在 我简单地说 只是为了提醒我们
But for now, I'm keeping it simple, just to remind us

1434
01:11:39,950 --> 01:11:43,572
我现在可以用类似于first这样代码来解包返回值
that I can now unpack that return value with something like first

1435
01:11:43,572 --> 01:11:47,287
最后一个下划线等于输入的返回值 
underscore last equals the return value of input.

1436
01:11:47,287 --> 01:11:49,370
现在我可以继续做这样的事情 
And now I can go ahead and do something like this,

1437
01:11:49,370 --> 01:11:53,340
就像用f字符串打印 Hello 逗号 然后用大括号括起来 
like printing out with an f string, Hello, comma, and then in curly braces,

1438
01:11:53,340 --> 01:11:53,840
第一 
first.

1439
01:11:53,840 --> 01:11:57,500
如果我只是想问候自己或任何其他用户 您好 大卫 
If I just want to greet myself or any other user as, Hello, David,

1440
01:11:57,500 --> 01:11:58,820
没有姓氏 
without the last name.

1441
01:11:58,820 --> 01:12:00,770
坦率地说 如果我不用姓 
And frankly, if I'm not using the last name,

1442
01:12:00,770 --> 01:12:04,580
回想一下 一个Python约定只是将其命名为下划线 以表明
recall that a Python convention is just to name it underscore to make clear

1443
01:12:04,580 --> 01:12:06,650
你知道你没有使用那个值 
that you know you're not using that value.

1444
01:12:06,650 --> 01:12:10,590
但它确实需要存在 因为您同时解包了两个值 
But it does need to be there because you're unpacking two values at once.

1445
01:12:10,590 --> 01:12:13,310
因此 如果我运行这个程序 它不会那么陌生 
So if I run this, it won't be all that unfamiliar.

1446
01:12:13,310 --> 01:12:15,470
我现在要运行的是unpack.py的Python 
I'm just going to run now Python of unpack.py.

1447
01:12:15,470 --> 01:12:17,660
我将输入David Malan 它只有一个空格 
I'll type in David Malan, which has a single space.

1448
01:12:17,660 --> 01:12:20,510
现在我们看到了 你好 逗号 大卫 
And there we have it, Hello, comma, David.

1449
01:12:20,510 --> 01:12:25,130
好吧 事实证明 还有其他方法可以解开价值 
Well, it turns out that there's other ways to unpack values.

1450
01:12:25,130 --> 01:12:27,980
此外 Python还提供了其他功能 尤其是
And there's other features that Python offers, especially

1451
01:12:27,980 --> 01:12:31,220
在定义和使用函数时 
when it comes to defining and using functions.

1452
01:12:31,220 --> 01:12:33,658
这是稍微多一点的中间功能 
And this is slightly more intermediate functionality,

1453
01:12:33,658 --> 01:12:35,450
如果你愿意 这是很有用的 因为你可以
if you will, that's useful, because you can

1454
01:12:35,450 --> 01:12:38,150
开始编写更优雅、更强大的代码 一旦您
start to write even more elegant and powerful code once you

1455
01:12:38,150 --> 01:12:40,650
熟悉这样的语法 
get comfortable with syntax like this.

1456
01:12:40,650 --> 01:12:43,190
所以让我继续并建议我们不只是玩 
So let me go ahead and propose that we not just play with,

1457
01:12:43,190 --> 01:12:48,140
你好的名字了 但相反 做一些也许
Hello names anymore, but instead do something maybe

1458
01:12:48,140 --> 01:12:50,230
又牵扯到毒品了
involving some coinage again.

1459
01:12:50,230 --> 01:12:51,980
所以也许不是美元和美分 但也许 
So maybe not dollars and cents, but maybe,

1460
01:12:51,980 --> 01:12:54,530
又像过去一样 一些大帆船和镰刀 
again, as in the past, some galleons, and sickles,

1461
01:12:54,530 --> 01:12:57,590
其中有一个数学关系 
and knuts which among which there's a mathematical relationship as

1462
01:12:57,590 --> 01:13:00,680
魔法世界里有多少人是平等的
to how many of those in the wizarding world equal each other.

1463
01:13:00,680 --> 01:13:02,160
让我继续做这个 
And let me go ahead and do this.

1464
01:13:02,160 --> 01:13:05,750
让我定义一个简单的函数total它告诉我
Let me define a simple function called total that just tells me

1465
01:13:05,750 --> 01:13:10,280
一个人在古灵阁的金库的总价值 巫师银行 
the total value of someone's vault in Gringotts, the wizarding bank, based

1466
01:13:10,280 --> 01:13:13,050
他们有多少加隆 镰刀和坚果
on how many galleons, sickles, and knuts that they have,

1467
01:13:13,050 --> 01:13:15,920
这些都是魔法世界的货币
which again, are currencies from the wizarding world as opposed

1468
01:13:15,920 --> 01:13:17,460
我们真实的人类世界
to our actual human world.

1469
01:13:17,460 --> 01:13:21,140
所以这个total函数可能会接受一个像加隆和镰刀这样的变量
So this total function might take a variable like galleons and sickles

1470
01:13:21,140 --> 01:13:22,457
还有这样的坚果
and knuts like this.

1471
01:13:22,457 --> 01:13:25,040
然后 它会返回公式 我承认
And then, it's going to return the formula, which I admittedly

1472
01:13:25,040 --> 01:13:26,120
我自己也不得不抬头 
had to look up myself.

1473
01:13:26,120 --> 01:13:30,800
事实证明 将加隆和镰刀
And it turns out that the formula for converting galleons and sickles

1474
01:13:30,800 --> 01:13:32,510
就是这个
to knuts would be this.

1475
01:13:32,510 --> 01:13:39,710
加隆乘以17再加上镰刀 再乘以29 
Galleons times 17 plus sickles, then times all of that by 29 and then

1476
01:13:39,710 --> 01:13:41,540
添加单个knuts 
add in the individual knuts.

1477
01:13:41,540 --> 01:13:45,230
不知道这在书或电影中有什么细节 
Not sure in what detail this came up in the books or movies.

1478
01:13:45,230 --> 01:13:47,370
但我们有了官方公式 
But here we have it, the official formula.

1479
01:13:47,370 --> 01:13:47,870
好吧
All right.

1480
01:13:47,870 --> 01:13:49,770
现在我们开始吧
Now let's go ahead and do this.

1481
01:13:49,770 --> 01:13:53,390
让我们继续 只使用一些样本输入来调用total函数 
Let me go ahead and call the total function with just some sample inputs.

1482
01:13:53,390 --> 01:13:58,880
假设像哈利这样的人有100加隆、50镰刀和25克努特 
Suppose that someone like Harry has 100 galleons, 50 sickles, and 25 knuts.

1483
01:13:58,880 --> 01:14:01,310
让我把它打印在屏幕上 
Let me go ahead and print that out on the screen.

1484
01:14:01,310 --> 01:14:05,210
如果total返回一个整数 我认为这个算术表达式
Well, if total returns an integer, which I think this arithmetic expression

1485
01:14:05,210 --> 01:14:10,280
我会做的 让我继续存储 而是传递total的返回值
will do, let me go ahead and store, rather, pass the return value of total

1486
01:14:10,280 --> 01:14:11,300
打印.
to print.

1487
01:14:11,300 --> 01:14:13,940
为了清楚起见 让我在最后写上Knuts 所以呢？
And then just for clarity, let me write knuts at the end So?

1488
01:14:13,940 --> 01:14:18,050
我知道这里的度量单位确实是knuts总数 
I know that the unit of measure here is indeed knuts in total.

1489
01:14:18,050 --> 01:14:19,880
现在 让我在终端窗口中
Now, let me go ahead in my terminal window

1490
01:14:19,880 --> 01:14:22,310
运行unpack.py的Python并按Enter键 
and run Python of unpack.py and hit Enter.

1491
01:14:22,310 --> 01:14:27,350
从数学上看 如果我的数学是正确的 
And it turns out mathematically that if I got my math correct,

1492
01:14:27,350 --> 01:14:36,320
100艘帆船加50把镰刀再加25克朗等于50,775克朗 
100 galleons plus 50 sickles plus 25 knuts equals in total 50,775 knuts.

1493
01:14:36,320 --> 01:14:39,170
只是为了避免在这里使用我们自己的人类货币 
Just avoiding having to use our own human currency here.

1494
01:14:39,170 --> 01:14:43,740
但至少到目前为止 我还没有做任何拆包的事情 
But I'm not doing anything along the lines of unpacking at least just yet.

1495
01:14:43,740 --> 01:14:45,710
既然我这样做了 让我来求婚吧 
Let me propose now that I do this.

1496
01:14:45,710 --> 01:14:48,110
为了便于讨论 让我提议
Just for the sake of discussion, let me propose

1497
01:14:48,110 --> 01:14:50,480
我让整个函数保持原样 
that I leave the total function as is.

1498
01:14:50,480 --> 01:14:54,270
但让我继续下去 把我所有的硬币都存储在一个列表中 
But let me go ahead and just store all of my coins in a list.

1499
01:14:54,270 --> 01:14:59,300
所以硬币按从左到右的顺序 100 50 25 它
So coins in order from left to right, 100, 50, 25, it

1500
01:14:59,300 --> 01:15:01,640
只是因为不管这个故事的目的是什么
just because for whatever purposes in this story

1501
01:15:01,640 --> 01:15:05,570
我把我所有的硬币都按这个顺序列在一张单子上 
I have all of my coinage in a list in this order.

1502
01:15:05,570 --> 01:15:08,250
有点像钱包或钱包 
Kind of a purse or wallet of sorts.

1503
01:15:08,250 --> 01:15:09,830
好吧 我怎么才能把这个传进去呢？
Well, how can I pass this in?

1504
01:15:09,830 --> 01:15:12,170
好吧 我不会两次硬编码相同的值 
Well, I'm not going to hard-code the same values twice.

1505
01:15:12,170 --> 01:15:14,150
只是为了讨论 我怎么能
Just for the sake of discussion, how could I

1506
01:15:14,150 --> 01:15:18,440
是否将列表的各个元素传递给我的Total函数？
pass in the individual elements of a list to my total function?

1507
01:15:18,440 --> 01:15:21,110
当然 我可以一如既往地对待这份名单
Well, of course, I could treat this list as I always

1508
01:15:21,110 --> 01:15:24,890
使用数字索引 通过将硬币放在括号0中 
do using numeric indices by doing coins bracket zero,

1509
01:15:24,890 --> 01:15:27,620
硬币括号一 硬币括号二 
coins bracket one, coins bracket two.

1510
01:15:27,620 --> 01:15:29,660
所以这是老派的东西 有清单 
So this is old-school stuff with lists.

1511
01:15:29,660 --> 01:15:32,540
如果我有一个名为Coins的清单 有三个元素 
If I've got a list called coins and there's three elements,

1512
01:15:32,540 --> 01:15:37,070
这些元素的索引或索引分别为0、1和2
the indices or indexes of those elements are zero, one, and two respectively

1513
01:15:37,070 --> 01:15:38,070
从左到右 
from left to right.

1514
01:15:38,070 --> 01:15:42,740
所以我现在要做的就是传入第一个元素
So all I'm doing here now is passing in the first element

1515
01:15:42,740 --> 01:15:47,210
从大帆船的名单中 第二个元素是镰刀 
from that list as galleons, the second element of that list as sickles,

1516
01:15:47,210 --> 01:15:50,810
这张清单的第三个元素是我的坚果 
and the third element of this list as my knuts.

1517
01:15:50,810 --> 01:15:53,270
当然 这与签名一致
And that lines up with, of course, the signature

1518
01:15:53,270 --> 01:15:57,110
这个函数 正如Total所期望的那样 我已经传递了这三个
of this function, which as total expects that I've passed in those three

1519
01:15:57,110 --> 01:15:59,152
事物按从左到右的顺序排列 
things in that order left to right.

1520
01:15:59,152 --> 01:16:01,610
让我继续跑吧 只是为了确保我没有摔断
Let me go ahead and run, just to make sure I haven't broken

1521
01:16:01,610 --> 01:16:03,650
任何内容 解包.py并按Enter键 
anything, unpack.py and hit Enter.

1522
01:16:03,650 --> 01:16:06,380
而且 算术仍然是正确的 
And the math still checks out.

1523
01:16:06,380 --> 01:16:08,810
但这变得有点冗长了--
But this is getting a little verbose--

1524
01:16:08,810 --> 01:16:10,040
有点长篇大论 
a little verbose.

1525
01:16:10,040 --> 01:16:13,970
如果我能把硬币清单递给你
And wouldn't it be nice if I could just pass the list of coins

1526
01:16:13,970 --> 01:16:15,500
到这个总的功能吗？
to this total function?

1527
01:16:15,500 --> 01:16:20,540
如果我能说点什么就好了 硬币 
Wouldn't it be nice if I could just say something like this, coins.

1528
01:16:20,540 --> 01:16:28,380
但让我停下来问一下大家 为什么这实际上不能像现在这样工作？
But let me pause and ask the group, why would this not actually work as is?

1529
01:16:28,380 --> 01:16:30,900
从技术上讲 这三个都通过了 
It technically is passing in all three.

1530
01:16:30,900 --> 01:16:34,140
但是为什么我运行这个的时候会出现错误呢？
But why would I get some kind of error when I run this?

1531
01:16:34,140 --> 01:16:35,340
埃里克？
Eric?

1532
01:16:35,340 --> 01:16:38,455
因为你要把一份名单交给大帆船 
STUDENT: Because you are passing a list to galleons.

1533
01:16:38,455 --> 01:16:39,330
DAVID J. MALAN：是的 
DAVID J. MALAN: Yeah.

1534
01:16:39,330 --> 01:16:42,900
我给加隆发了一份名单 没有给镰刀和坚果的 
I'm passing a list to galleons and nothing for sickles and knuts.

1535
01:16:42,900 --> 01:16:44,830
请注意 它们没有默认值 
And notice, those don't have default values.

1536
01:16:44,830 --> 01:16:46,770
第一行没有等号
There's no equal signs on that first line

1537
01:16:46,770 --> 01:16:49,020
这意味着Python不会知道
of code, which means Python is not going to know

1538
01:16:49,020 --> 01:16:51,340
这里应该假定什么值 
what value should be assumed there.

1539
01:16:51,340 --> 01:16:53,790
所以看起来好像是行不通的 
So it just seems like it's not going to work.

1540
01:16:53,790 --> 01:16:55,710
另外 这是错误的类型 正如埃里克所指出的 
Plus, it's the wrong type, as Eric notes.

1541
01:16:55,710 --> 01:16:59,470
它是一个列表 而不是之前的整数 
It's a list and it's not an integer as it was before.

1542
01:16:59,470 --> 01:17:01,500
让我们运行这个错误的版本 
So let's actually run this incorrect version,

1543
01:17:01,500 --> 01:17:04,920
Python of unpack.py Enter type error.
Python of unpack.py Enter, type error.

1544
01:17:04,920 --> 01:17:06,880
这可能是你所期望的 
And that is probably what you might expect,

1545
01:17:06,880 --> 01:17:08,580
就像我把这里的人搞得一团糟
like I'm messing up with the types here.

1546
01:17:08,580 --> 01:17:12,120
我需要传入两个位置参数 sickles
And I am required to pass in two positional arguments, sickles

1547
01:17:12,120 --> 01:17:13,920
和knuts 甚至没有通过 
and knuts, that were not even passed.

1548
01:17:13,920 --> 01:17:15,750
所以我肯定犯了错 
So I've definitely erred here.

1549
01:17:15,750 --> 01:17:18,780
但如果唯一的解决办法
But it certainly seems unfortunate if the only solution to this

1550
01:17:18,780 --> 01:17:22,893
就是做我之前做的 索引到第一个元素 index
is to do what I previously did, which is index into the first element, index

1551
01:17:22,893 --> 01:17:24,810
索引到第三个元素 
into the second element, index into the third.

1552
01:17:24,810 --> 01:17:27,360
你可以想象 有了更大的功能 
You can imagine, with bigger fancier functions that

1553
01:17:27,360 --> 01:17:30,810
我会用更多的论证 这会变得非常冗长 
take even more arguments, this is going to get very verbose and honestly

1554
01:17:30,810 --> 01:17:35,070
很容易受到错误的影响 我的错别字 
very vulnerable, potentially, to just mistakes, typos on my part.

1555
01:17:35,070 --> 01:17:38,400
但这里也是你可以做已知的事情的地方 
But here too is where you can do what's known, again,

1556
01:17:38,400 --> 01:17:41,250
在Python中解包一个值 
as unpacking a value in Python.

1557
01:17:41,250 --> 01:17:44,970
现在 一个列表包含多个值 
Right now, a list is packed with multiple values.

1558
01:17:44,970 --> 01:17:49,538
我当前的列表有这三个值 分别为100、50和25 
My current list has these three values, 100, 50, and 25 respectively.

1559
01:17:49,538 --> 01:17:51,330
但它们都在这张单子上 
But they're all packed up in this one list.

1560
01:17:51,330 --> 01:17:54,450
如果我能打开那张单子 
Wouldn't it be nice if I could unpack that list,

1561
01:17:54,450 --> 01:17:59,820
就像我之前解包str类的拆分的返回值一样
just like I previously unpacked the return value of the str class's split

1562
01:17:59,820 --> 01:18:02,220
功能也有很多 
function into multiple things too.

1563
01:18:02,220 --> 01:18:04,350
事实上 我可以做到 
And indeed, I can do just that.

1564
01:18:04,350 --> 01:18:10,480
事实上 Python允许我传递的不是硬币 而是星币 
Python actually allows me to pass in not coins but star coins.

1565
01:18:10,480 --> 01:18:13,890
因此 如果您在变量的开头使用单个星号 
So if you use a single asterisk at the beginning of your variable,

1566
01:18:13,890 --> 01:18:15,540
这会把它拆开的 
that will unpack it.

1567
01:18:15,540 --> 01:18:20,340
它将需要一个序列 在这里是三个大小的硬币 
And it will take one sequence, in this case coins of size three,

1568
01:18:20,340 --> 01:18:25,200
如果你愿意的话 把它分解成三个单独的论点 
and explode it, if you will, unpack it into three individual arguments.

1569
01:18:25,200 --> 01:18:26,430
不需要逗号 
No commas are needed.

1570
01:18:26,430 --> 01:18:28,170
Python只会为您处理这一点 
Python just handles this for you.

1571
01:18:28,170 --> 01:18:32,040
但传递星币的效果是
But the effect of passing in star coins is

1572
01:18:32,040 --> 01:18:36,400
传递该名单中的个别成员 
to pass in the individual members of that list.

1573
01:18:36,400 --> 01:18:39,540
在这种情况下 它们将分别是100、50和25 
Which in this case are going to be 100, 50, and 25 respectively.

1574
01:18:39,540 --> 01:18:42,480
这很完美 因为现在它将与大帆船排成一列 
Which is perfect, because now it's going to line up with galleons,

1575
01:18:42,480 --> 01:18:44,320
分别是镰刀和坚果 
sickles, knuts respectively.

1576
01:18:44,320 --> 01:18:49,500
所以现在 当我运行unpack.py的Python时 我们又回到了业务中
So now when I run Python of unpack.py, we're back in business

1577
01:18:49,500 --> 01:18:50,670
算术证明了这一点 
and the math checks out.

1578
01:18:50,670 --> 01:18:54,390
但我已经通过引入这个新符号来清理我的代码 它
But I've cleaned up my code by just introducing this new symbol, which

1579
01:18:54,390 --> 01:18:58,030
当然 我们已经在乘法和类似的其他上下文中使用过 
we've used, of course, in other contexts for multiplication and the like.

1580
01:18:58,030 --> 01:19:02,130
但现在 它也被用来以这种方式拆包 
But now, it's also used for unpacking in this way.

1581
01:19:02,130 --> 01:19:04,740
对我们刚刚做的事有疑问吗？
Questions on what we've just done?

1582
01:19:04,740 --> 01:19:09,090
它是一个单一的运营商 但它已经相当强大了 
It's a single operator, but it's already quite powerful.

1583
01:19:09,090 --> 01:19:12,180
因为它允许我们提取数据结构并将其解包
Because it allows us to take a data structure and unpack it

1584
01:19:12,180 --> 01:19:14,340
并逐一传递 
and pass it in individually.

1585
01:19:14,340 --> 01:19:22,890
学生：这对元组、集合、字典、字典也适用吗？
STUDENT: Does that work for tuples, sets, dicts, dictionaries as well?

1586
01:19:22,890 --> 01:19:25,430
大卫·J·马兰：是的 Tuples 
DAVID J. MALAN: Tuples, yes.

1587
01:19:25,430 --> 01:19:27,530
套装我不知道 
Sets I don't know.

1588
01:19:27,530 --> 01:19:32,000
[?兰申？？]我不知道秩序是否得到了维护 
[? Ranshin? ?] I don't know if order is preserved.

1589
01:19:32,000 --> 01:19:33,110
不是的 
No.

1590
01:19:33,110 --> 01:19:37,103
哦 是不是没有 还是你在查？
Oh, is that no it does not, or you're checking?

1591
01:19:37,103 --> 01:19:38,020
秩序没有得到维护 
Order's not preserved.

1592
01:19:38,020 --> 01:19:40,900
所以它不能和SET一起工作？
So it wouldn't work with set?

1593
01:19:40,900 --> 01:19:42,090
它不适用于SET 
It does not work with set.

1594
01:19:42,090 --> 01:19:43,710
不适用于SET 
Does not work with set.

1595
01:19:43,710 --> 01:19:46,770
抱歉 我在这里用语音搜索只是为了省去一些按键 
Sorry, I'm verbally googling here just to save us some keystrokes.

1596
01:19:46,770 --> 01:19:51,062
因此 它适用于秩序确实保持不变的枚举 
So it would work for enumerations that where order is indeed preserved.

1597
01:19:51,062 --> 01:19:52,770
稍后我们将看到另一个例子
And we'll see another example in a moment

1598
01:19:52,770 --> 01:19:55,520
它实际上可以在词典中以不同的方式使用 
where it actually can be used in a different way for dictionaries,

1599
01:19:55,520 --> 01:19:57,420
它现在确实维持着秩序 
which nowadays do preserve order.

1600
01:19:57,420 --> 01:20:00,720
关于用这种方式拆包还有什么问题吗？
Other questions on unpacking in this way?

1601
01:20:00,720 --> 01:20:01,350
学生：是的 
STUDENT: Yes.

1602
01:20:01,350 --> 01:20:02,070
嗨 
Hi.

1603
01:20:02,070 --> 01:20:02,987
大卫·J·马兰：你好 
DAVID J. MALAN: Hello.

1604
01:20:02,987 --> 01:20:07,290
学生：你能用解包的方法得到值吗 比如10加50
STUDENT: Can you use unpacking to get the value, for example 10 plus 50

1605
01:20:07,290 --> 01:20:13,205
加25而不是for循环 然后结果加？
plus 25 instead of a for loop and then result plus?

1606
01:20:13,205 --> 01:20:14,580
大卫·J·马兰：简短的回答是否定的 
DAVID J. MALAN: Short answer, no.

1607
01:20:14,580 --> 01:20:18,030
如果您想要单个值 您应该只对其进行索引 在本例中 
If you want the individual values, you should be just indexing, in this case,

1608
01:20:18,030 --> 01:20:20,710
进入那些特定的地点 
into those specific locations.

1609
01:20:20,710 --> 01:20:25,767
这将返回多个值 相当于逗号分隔的列表 
This is returning multiple values, the equivalent of a comma separated list.

1610
01:20:25,767 --> 01:20:27,600
因此 如果您使用较早的方法
So you would use the earlier approach if you

1611
01:20:27,600 --> 01:20:30,060
关心各个地点 
cared about the individual locations.

1612
01:20:30,060 --> 01:20:32,670
还有一个关于拆包的问题怎么样？
How about one other question on unpacking?

1613
01:20:32,670 --> 01:20:35,190
学生：如果我们宣布--
STUDENT: What if we have declared--

1614
01:20:35,190 --> 01:20:37,500
我们声明了一些缺省值 
we declare some default values.

1615
01:20:37,500 --> 01:20:44,690
如果你用这个作为两个点 它会正确地出去 还是会跳过它？
And if you use this as two points, will it go out right, or will it skip it?

1616
01:20:44,690 --> 01:20:45,940
大卫·J·马兰：问得好 
DAVID J. MALAN: Good question.

1617
01:20:45,940 --> 01:20:47,773
如果我没听错 比如 
If I heard you right, what if, for instance,

1618
01:20:47,773 --> 01:20:51,900
该列表在这里有四个类似的值 而您仍在将其解包
the list has four values like this here and you're still unpacking it

1619
01:20:51,900 --> 01:20:53,730
当只有三个人的时候 这是意料之中的 
when it's only three that's expected.

1620
01:20:53,730 --> 01:20:54,570
好吧 让我们试一试 
Well, let's try it.

1621
01:20:54,570 --> 01:20:58,140
Python of unpack.py Enter 
Python of unpack.py Enter.

1622
01:20:58,140 --> 01:20:59,280
另一个类型错误 
Another type error.

1623
01:20:59,280 --> 01:21:02,560
这一次 它需要三个立场论点 但给出了四个 
This time it takes three positional arguments but four were given.

1624
01:21:02,560 --> 01:21:06,390
因此 作为程序员 我们有责任在这种情况下不这样做 
So the onus is on us as the programmer not to do that in this case.

1625
01:21:06,390 --> 01:21:09,090
所以可能很脆弱 但如果我是
So potentially fragile, but avoidable if I'm

1626
01:21:09,090 --> 01:21:11,470
控制此列表的内容 
controlling the contents of this list.

1627
01:21:11,470 --> 01:21:14,730
事实上 让我提议现在我们来看看这个的另一个变种 
In fact, let me propose now that we take a look at another variant of this.

1628
01:21:14,730 --> 01:21:18,480
因此 我们不仅使用位置论元 
Whereby we use not just positional arguments,

1629
01:21:18,480 --> 01:21:21,720
我们相信第一种是帆船 第二种是镰刀 
whereby we trust that the first is galleons, the second is sickles,

1630
01:21:21,720 --> 01:21:22,680
第三个是克努茨 
the third is knuts.

1631
01:21:22,680 --> 01:21:25,950
假设我们实际上传递了名称 就像我们在Python中被允许做的那样 
Suppose that we actually passed in the names as we're allowed to do in Python.

1632
01:21:25,950 --> 01:21:28,560
然后 从技术上讲 我们可以按任何顺序传递它们
And then, technically, we could pass them in in any order

1633
01:21:28,560 --> 01:21:31,830
而Python会使用命名参数来解决这个问题 
and Python would figure it out using named parameters instead.

1634
01:21:31,830 --> 01:21:32,940
好吧 我该怎么做呢？
Well, how might I do this?

1635
01:21:32,940 --> 01:21:35,190
嗯 一开始会有一点倒退 
Well, it's going to be a bit of a regression at first.

1636
01:21:35,190 --> 01:21:37,560
因此 让我在这里删除这个列表 
So let me get rid of this list here.

1637
01:21:37,560 --> 01:21:41,520
现在让我将其更改为仅手动传递我关心的值 
Let me change this now to just manually passing the values I care about.

1638
01:21:41,520 --> 01:21:44,010
大帆船 我想还是等于100 
Galleons I want to still equal 100.

1639
01:21:44,010 --> 01:21:46,380
Sickles我想等于50 
Sickles I want to equal 50.

1640
01:21:46,380 --> 01:21:49,540
和坚果 我想等于25 
And knuts I want to equal 25.

1641
01:21:49,540 --> 01:21:52,140
所以这是老式的参数传递 
So this is old-school parameter passing.

1642
01:21:52,140 --> 01:21:53,310
它不再是定位的 
It's no longer positional.

1643
01:21:53,310 --> 01:21:56,040
我正在显式地指定这些参数的名称 
I'm explicitly specifying the names of these arguments.

1644
01:21:56,040 --> 01:21:58,830
但这会奏效的 因为这是
But that's just going to work because that's

1645
01:21:58,830 --> 01:22:02,520
我的Total函数中这些参数的名称到底是什么
exactly what the names of these parameters are in my total function

1646
01:22:02,520 --> 01:22:03,240
和以前一样 
as before.

1647
01:22:03,240 --> 01:22:05,790
尽管如此 让我们确保我没有打碎任何东西 
Let's make sure I, nonetheless, did not break anything.

1648
01:22:05,790 --> 01:22:10,020
让我们运行unpack.py Enter的Python 
Let's run Python of unpack.py Enter.

1649
01:22:10,020 --> 01:22:13,800
我们有了它 还有50775克朗 
And there we have it, still 50,775 knuts.

1650
01:22:13,800 --> 01:22:21,150
好吧 一旦你开始给事物命名和取值 命名和取值 
Well, once you start giving things names and values, names and values,

1651
01:22:21,150 --> 01:22:25,290
这可能会让人想起我们最通用的数据之一
that probably should bring to mind one of our most versatile data

1652
01:22:25,290 --> 01:22:29,670
结构 甚至是字典中的结构 
structures in Python and even other languages, that of a dictionary.

1653
01:22:29,670 --> 01:22:33,600
请记住 字典只是键值对、名称的集合
Remember that a dictionary is just a collection of key value pairs, names

1654
01:22:33,600 --> 01:22:35,200
以及他们各自的价值观 
and their respective values.

1655
01:22:35,200 --> 01:22:37,330
因此 这种方式打开了一个机会 
So this kind of opens up an opportunity.

1656
01:22:37,330 --> 01:22:38,470
如果我这么做了呢 
What if I did this.

1657
01:22:38,470 --> 01:22:42,810
如果由于某种原因 我的程序中确实有一个变量
What if I actually had for some reason in my program on a variable

1658
01:22:42,810 --> 01:22:44,190
和以前一样 它被称为硬币 
as before called coins.

1659
01:22:44,190 --> 01:22:47,460
但不是像以前那样将其列为三个值的列表 
But instead of making it a list of three values like before,

1660
01:22:47,460 --> 01:22:49,240
如果它是一本合适的词典呢？
what if it's a proper dictionary?

1661
01:22:49,240 --> 01:22:53,910
所以如果是大帆船 引用引号 其中100个是冒号100 
So what if it's galleons, quote unquote, colon 100 for 100 of those,

1662
01:22:53,910 --> 01:22:59,415
Sickles引用了其中的50个 Knuts引用了其中的25个 
sickles quote unquote and 50 of those, and knuts quote unquote 25 of those,

1663
01:22:59,415 --> 01:23:02,790
每一个都用冒号隔开 
each of those separated by colons.

1664
01:23:02,790 --> 01:23:06,120
让我把我的方括号固定到这个时间
And let me fix my square brackets to this time

1665
01:23:06,120 --> 01:23:10,200
花括号 回想一下 这是我们在词典中使用的符号
be curly braces, which, recall, is the symbol we use for dictionaries

1666
01:23:10,200 --> 01:23:12,240
或在Python中对对象进行DICT 
or dict objects in Python.

1667
01:23:12,240 --> 01:23:14,880
所以现在 我有一本叫Coins的词典 
So now, I have a dictionary called coins.

1668
01:23:14,880 --> 01:23:15,790
不是一份名单 
Not a list.

1669
01:23:15,790 --> 01:23:20,430
它是钥匙和价值的集合 三把钥匙 帆船 镰刀 坚果 
It's a collection of keys and values, three keys, galleons, sickles, knuts,

1670
01:23:20,430 --> 01:23:24,180
和三个值 分别为100、50和25 
and three values, 100, 50, and 25 respectively.

1671
01:23:24,180 --> 01:23:29,910
如果我现在将这些单独的值传递到我的总函数中 
If I were to now pass these individual values into my total function,

1672
01:23:29,910 --> 01:23:32,800
我可以用我的词典一如既往地做这件事 
I could do it as always with my dictionary.

1673
01:23:32,800 --> 01:23:34,140
所以我现在用老派的方式来做 
So I'm doing it old-school now.

1674
01:23:34,140 --> 01:23:36,060
硬币是我词典的名字 
Coins is the name of my dictionary.

1675
01:23:36,060 --> 01:23:39,960
我不像列表那样用数字来索引 而是用词来索引 
I index into it not with numbers like with lists, but with words.

1676
01:23:39,960 --> 01:23:44,250
所以大帆船 像这样的弦 硬币 引号 
So galleons, strings like this, coins, quote unquote,

1677
01:23:44,250 --> 01:23:46,210
那里有方括号里的镰刀 
sickles in square brackets there.

1678
01:23:46,210 --> 01:23:49,500
最后是硬币 方括号 不引用 坚果 
And then lastly, coins, square brackets, quote unquote, knuts.

1679
01:23:49,500 --> 01:23:51,540
所以它变得--它又是冗长的 
So it's getting-- it's verbose again.

1680
01:23:51,540 --> 01:23:53,340
这可能不是最好的下坡路 
This is not maybe the best road to go down.

1681
01:23:53,340 --> 01:23:54,940
但我们稍后会后退一步 
But we'll backpedal in a moment.

1682
01:23:54,940 --> 01:23:58,800
这就是如何 如果你碰巧把所有的硬币都储存起来了
This is just how, if you happen to have all of your coins stored

1683
01:23:58,800 --> 01:24:02,580
在词典中 你可以把帆船、镰刀和坚果
in a dictionary, you could pass the galleons, sickles, and knuts

1684
01:24:02,580 --> 01:24:04,543
分别放入您的功能中 
into your function respectively.

1685
01:24:04,543 --> 01:24:06,210
让我们确保我没有打碎任何东西 
Let's make sure I didn't break anything.

1686
01:24:06,210 --> 01:24:10,290
让我们重新运行unpack.py的Python 我们仍然很好 
Let's rerun Python of unpack.py, and we're still good.

1687
01:24:10,290 --> 01:24:12,390
现在 我们怎么会有这样的情况呢？
Now, how could we get to a situation like this?

1688
01:24:12,390 --> 01:24:16,740
好的 像往常一样 想象一下这个程序比这里的稍微长一点 
Well, as always, imagine this program is a little longer than this one here.

1689
01:24:16,740 --> 01:24:19,230
不知何故 你在使用一本词典
And somehow you're using a dictionary maybe

1690
01:24:19,230 --> 01:24:21,630
只是为了跟踪某人的钱包或钱包 
just to keep track of someone's purse or wallet,

1691
01:24:21,630 --> 01:24:24,450
比如他们每种类型的硬币有多少 
like how many coins of each type that they have.

1692
01:24:24,450 --> 01:24:27,120
因此 使用词典是完全合理的 
And as such, it's perfectly reasonable to use a dictionary.

1693
01:24:27,120 --> 01:24:29,010
但然后你想要打印出总数 
But then you want to print out the total.

1694
01:24:29,010 --> 01:24:29,700
然后把它补上 
And darn it.

1695
01:24:29,700 --> 01:24:34,650
如果Total函数不需要字典 因此您不能这样做
If that total function does not expect a dictionary so you cannot just do

1696
01:24:34,650 --> 01:24:37,380
一些好的和简单的东西 比如在硬币中传递 
something nice and simple like pass in coins.

1697
01:24:37,380 --> 01:24:39,690
出于我们前面看到的原因 这将是一个类型错误 
For reasons we saw earlier, that would be a type error.

1698
01:24:39,690 --> 01:24:42,480
Total需要三个参数 三个整数 
Total expects three arguments, three integers.

1699
01:24:42,480 --> 01:24:44,890
你不能就这么传一本词典 
You can't just pass in a dictionary.

1700
01:24:44,890 --> 01:24:48,330
但如果这就是你用来存储个人钱包的数据结构
But if that's the data structure you're using to store the person's purse

1701
01:24:48,330 --> 01:24:51,090
或者钱包 嗯 这是一种不幸
or wallet, well, it's kind of unfortunate

1702
01:24:51,090 --> 01:24:54,180
我们在这些数据类型之间存在这种冲突 
that we have this clash between these data types.

1703
01:24:54,180 --> 01:24:55,990
好吧 这就是我们能做的 
Well, here's what we can do.

1704
01:24:55,990 --> 01:24:57,420
我们不能把硬币放进去 
We can't pass in coins.

1705
01:24:57,420 --> 01:25:00,750
因为请注意 如果我尝试这样做并运行unpack.py的Python 
Because watch, if I try doing that and run Python of unpack.py,

1706
01:25:00,750 --> 01:25:02,850
我们收到另一个类型错误 
we're getting another type error.

1707
01:25:02,850 --> 01:25:05,160
缺少两个必需的位置参数 
Missing two required positional arguments.

1708
01:25:05,160 --> 01:25:08,700
镰刀和坚果 我必须通过三件事 
Sickles and knuts, I have to pass in three things.

1709
01:25:08,700 --> 01:25:14,310
但是 令人惊叹的是 Python还允许您解开词典 
But, wonderfully, Python allows you to unpack dictionaries as well.

1710
01:25:14,310 --> 01:25:18,450
对于词典来说 你不是使用一个星号 而是两个 
For a dictionary, you don't use a single asterisk, you use two.

1711
01:25:18,450 --> 01:25:21,960
以及该语法的作用是什么
And what this syntax has the effect of doing

1712
01:25:21,960 --> 01:25:26,070
正在传递三个带名称的值 
is passing in three values with names.

1713
01:25:26,070 --> 01:25:30,870
它的效果是传递等同于100个逗号的帆船 
It has the effect of passing in galleons equals 100 comma,

1714
01:25:30,870 --> 01:25:35,880
镰刀等于50个逗号 坚果等于25个 
sickles equals 50 comma, knuts equals 25.

1715
01:25:35,880 --> 01:25:39,570
因此 它具有类似于列表解包的效果 
And so, it has the similar effect to the list unpacking.

1716
01:25:39,570 --> 01:25:44,550
但这只是传入的值 实际上是用逗号分隔的100、50、25 
But that just passed in the values, 100, 50, 25 separated by commas in effect.

1717
01:25:44,550 --> 01:25:48,270
在解压缩词典时 它会传入键
When unpacking a dictionary, it passes in the keys

1718
01:25:48,270 --> 01:25:52,590
并且在概念上用等号分隔的值
and the values separated conceptually with equal signs

1719
01:25:52,590 --> 01:25:55,290
就像我们的函数所期望的那样 
just like our function expects.

1720
01:25:55,290 --> 01:25:59,310
所以如果我现在再次运行unpack.py的Python 我们仍然是好的 
So if I now run Python of unpack.py again, we're still good,

1721
01:25:59,310 --> 01:26:01,230
但我们又加强了代码
but we've tightened our code up again.

1722
01:26:01,230 --> 01:26:03,240
现在 我给了自己另一个选择 
And now, I'm giving myself yet another option.

1723
01:26:03,240 --> 01:26:08,910
我可以把巫师的钱包或钱包放在他们的...
I can either store a wizard's purse or wallets in their--

1724
01:26:08,910 --> 01:26:10,440
就像我们之前做的那样 
in a list as we did earlier.

1725
01:26:10,440 --> 01:26:13,410
或者我可以把它存储在一个更多功能的地方--甚至更多
Or I can store it in a little more versatility-- with even more

1726
01:26:13,410 --> 01:26:16,270
用字典来代替 
specificity using a dictionary instead.

1727
01:26:16,270 --> 01:26:18,270
所以 说清楚点 让我倒回去 
And so, to be clear, let me rewind.

1728
01:26:18,270 --> 01:26:22,230
星星硬币是一样的 如果我倒带
Star star coins is the same thing if I rewind

1729
01:26:22,230 --> 01:26:26,430
第一个命名参数的例子
a little bit to our first example of named arguments

1730
01:26:26,430 --> 01:26:28,680
和我在这里强调的是一样的 
is equivalent to what I've highlighted here.

1731
01:26:28,680 --> 01:26:32,940
当你解压缩一个字典时 它会传入所有的键
When you unpack a dictionary, it passes in all of the keys

1732
01:26:32,940 --> 01:26:36,840
所有的值都和这里的语法一样 
and all of the values much like the syntax here.

1733
01:26:36,840 --> 01:26:39,780
但让我把它收紧 回到我们离开的地方 
But let me tighten it up and go to where we left off.

1734
01:26:39,780 --> 01:26:41,790
现在有什么问题吗？
Questions now on unpacking?

1735
01:26:41,790 --> 01:26:44,280
我们能不能在这本字典里 
STUDENT: Can we have a-- in this dictionary,

1736
01:26:44,280 --> 01:26:49,500
我们能不能用一个常量名值对来代替 
can we have instead of having a constant name value pair, can we have

1737
01:26:49,500 --> 01:26:52,913
名称值对的数量是可变的？
a variable number of name value pairs?

1738
01:26:52,913 --> 01:26:54,330
大卫·J·马兰：简短的回答 是的 
DAVID J. MALAN: Short answer, yes.

1739
01:26:54,330 --> 01:26:57,630
你可以有三个以上的键值对 就像我在这里一样 
You can have more than three key value pairs as I have here.

1740
01:26:57,630 --> 01:27:01,920
但是如果总函数是
But it's not going to work unpacking it if the total function is

1741
01:27:01,920 --> 01:27:03,420
预计只有三个 
expecting only three.

1742
01:27:03,420 --> 01:27:06,750
所以如果我在这里添加一些东西 比如让我介绍便士
So if I were to add something here, like let me introduce pennies

1743
01:27:06,750 --> 01:27:07,950
魔法世界
to the wizarding world.

1744
01:27:07,950 --> 01:27:11,220
假设我有一便士 例如 
And suppose I have one penny, for instance.

1745
01:27:11,220 --> 01:27:17,440
现在我运行同样的代码 unpack.py的Python 我们又回到了一个类型错误
And now I run this same code, Python of unpack.py, we're back to a type error

1746
01:27:17,440 --> 01:27:17,940
再
again.

1747
01:27:17,940 --> 01:27:20,940
当我得到一个意想不到的关键字参数便士 
Whereby I got an unexpected keyword argument pennies,

1748
01:27:20,940 --> 01:27:24,090
因为这不是Total函数所期望的 
because that is not expected by the total function.

1749
01:27:24,090 --> 01:27:27,790
我们马上就会看到 一个很好的解决方案 
We will see in just a moment, wonderfully, a solution though to that.

1750
01:27:27,790 --> 01:27:29,790
但现在 它不起作用 
But for now, it does not work.

1751
01:27:29,790 --> 01:27:33,150
关于用字典或清单拆包的其他问题？
Other questions on unpacking with dictionaries or lists?

1752
01:27:33,150 --> 01:27:37,230
在列表值中 我们给出了相同数量的参数
STUDENT: In list-- in list values, we gave the same number of arguments

1753
01:27:37,230 --> 01:27:40,470
我们在函数中声明了一个默认值 
and we declared a default value in the function.

1754
01:27:40,470 --> 01:27:44,070
现在 如果你用这个星号 它会覆盖那个值吗
Now, if you use this asterisk, will it overwrite that value

1755
01:27:44,070 --> 01:27:46,427
还是跳过默认值
or will it skip that default value?

1756
01:27:46,427 --> 01:27:47,760
大卫·J·马兰：问得好 
DAVID J. MALAN: A good question.

1757
01:27:47,760 --> 01:27:51,660
例如 如果我们在这里有缺省值 
If we did have default values up here, for instance,

1758
01:27:51,660 --> 01:27:56,670
等于零 那就是好的一面 
equals zero, equals zero, equals zero, the upside of that,

1759
01:27:56,670 --> 01:27:59,730
回想一下 从我们之前对函数的论点的讨论中 
recall, from our discussion of arguments to functions a while back,

1760
01:27:59,730 --> 01:28:02,760
现在你不需要传递所有这些值了 
is that now you don't have to pass in all of those values.

1761
01:28:02,760 --> 01:28:05,070
它们将默认为这些零 
They will default to those zeros.

1762
01:28:05,070 --> 01:28:08,220
因此 您可以传递少于三个值 
Therefore, you could pass in fewer than three values,

1763
01:28:08,220 --> 01:28:11,910
使用在此场景中未打包的列表或词典 
either using a list or a dictionary that's unpacked in this scenario.

1764
01:28:11,910 --> 01:28:15,360
我故意不这么做是因为我想让我们
I deliberately did not do that because I wanted us to encounter

1765
01:28:15,360 --> 01:28:16,980
在这种情况下 这个特定的错误 
this specific error in this case.

1766
01:28:16,980 --> 01:28:21,270
但你绝对可以回到过去 添加这些默认设置 
But you could absolutely go back and add those defaults.

1767
01:28:21,270 --> 01:28:24,840
所以事实证明 这个单星号或这个双星号
So it turns out that this single asterisks or this double asterisk

1768
01:28:24,840 --> 01:28:27,060
不仅用于拆包的上下文中 
is not only used in the context of unpacking.

1769
01:28:27,060 --> 01:28:30,990
在Python中 该语法实际上用作可视指示器
That same syntax is actually used as a visual indicator in Python

1770
01:28:30,990 --> 01:28:33,900
当在函数中时 它本身很可能
when in a function itself might very well

1771
01:28:33,900 --> 01:28:36,960
接受数量可变的参数 
take a variable number of arguments.

1772
01:28:36,960 --> 01:28:39,210
也就是说 一个函数可以是可变的 
That is to say, a function can be variadic.

1773
01:28:39,210 --> 01:28:41,880
这意味着它不一定需要 比如说 
Which means that it doesn't necessarily have to take, say,

1774
01:28:41,880 --> 01:28:43,920
具体有三个论点 
three arguments specifically.

1775
01:28:43,920 --> 01:28:46,020
即使它们有或没有缺省值 
Even if they do or don't have default values,

1776
01:28:46,020 --> 01:28:49,990
它可能需要零个 或者一个 或者两个 或者三个 
it can take maybe zero, or one, or two, or three.

1777
01:28:49,990 --> 01:28:52,770
事实证明 实现相同想法的语法是
And it turns out the syntax for implementing the same idea is

1778
01:28:52,770 --> 01:28:54,490
在精神上非常相似 
quite similar in spirit.

1779
01:28:54,490 --> 01:28:56,820
事实上 让我回到VS代码这里 
In fact, let me go back to VS Code here.

1780
01:28:56,820 --> 01:28:59,130
让我建议我们从这个代码开始
And let me propose that we start over with this code

1781
01:28:59,130 --> 01:29:01,800
摆脱我们对帆船、镰刀和坚果的概念 
and get rid of our notion of galleons, and sickles, and knuts,

1782
01:29:01,800 --> 01:29:04,383
做一些更普通的事情 这样我们就可以
and do something just a little more generic just so that we've

1783
01:29:04,383 --> 01:29:05,800
我看到了这个的语法 
seen the syntax for this.

1784
01:29:05,800 --> 01:29:09,240
假设我按如下方式定义一个函数 
Suppose that I define a function as follows.

1785
01:29:09,240 --> 01:29:11,490
定义一个函数 我们称它为f 
Define a function, let's call it f.

1786
01:29:11,490 --> 01:29:15,210
该函数不会接受特定数量的参数
And that function is not going to take a specific number of arguments

1787
01:29:15,210 --> 01:29:16,440
但它是一种可变的 
but a variable one.

1788
01:29:16,440 --> 01:29:18,930
因此 我将继续在这里使用这个语法 
And so, I'm going to go ahead and use this syntax here,

1789
01:29:18,930 --> 01:29:23,440
星形参数 这表明该函数确实是可变的 
star args, which indicates that this function is indeed variadic.

1790
01:29:23,440 --> 01:29:26,850
它需要一些可变数量的位置参数 
It takes some variable number of positional arguments.

1791
01:29:26,850 --> 01:29:29,820
位置 在这个意义上 它们通常从左到右 
Positional in the sense that they go typically from left to right.

1792
01:29:29,820 --> 01:29:32,550
但我还不知道我想支持多少人 
But I don't know how many just yet I want to support.

1793
01:29:32,550 --> 01:29:34,560
假设我还想支持
Suppose that I additionally want to support

1794
01:29:34,560 --> 01:29:36,720
一些关键字参数 即 
some number of keyword arguments, that is,

1795
01:29:36,720 --> 01:29:40,140
可以选择调用的命名参数
named parameters that can be called optionally

1796
01:29:40,140 --> 01:29:42,160
每个人都用自己的名字 
and individually by their own name.

1797
01:29:42,160 --> 01:29:44,200
嗯 从语法上讲 这里的惯例是
Well, the convention syntactically here would

1798
01:29:44,200 --> 01:29:46,900
就是用两颗星 然后用矮子 
be to use two stars and then kwargs.

1799
01:29:46,900 --> 01:29:50,290
我可以叫args 或者kwargs 任何我想要的东西 
I could call args, or kwargs, anything else that I want.

1800
01:29:50,290 --> 01:29:53,860
但是您会在Python自己的文档中经常看到这样一个约定
But a convention you'll frequently see in Python's own documentation

1801
01:29:53,860 --> 01:29:57,280
当你有像这样的占位符作为一些参数时
is that when you have placeholders like this for some number of arguments

1802
01:29:57,280 --> 01:30:03,220
和一些关键字参数 世界上倾向于使用args和kwargs 
and some number of keyword arguments, the world tends to use args and kwargs.

1803
01:30:03,220 --> 01:30:06,760
好的 在这个函数内部 让我们暂时做一些非常简单的事情 
Well, inside of this function, let's do something super simple just for now.

1804
01:30:06,760 --> 01:30:10,600
让我继续打印出字面上引用的位置 
Let me go ahead and print out literally quote unquote positional,

1805
01:30:10,600 --> 01:30:13,870
只是为了告诉自己 同时我的脑海里围绕着
just to indicate to myself while wrapping my mind around what's

1806
01:30:13,870 --> 01:30:16,810
接下来是什么位置论点 
going on here what the positional arguments are.

1807
01:30:16,810 --> 01:30:19,255
让我非常简单地打印出这些参数 
And let me quite simply print out those args.

1808
01:30:19,255 --> 01:30:21,130
这不是您通常会做的事情 
This is not something you would typically do.

1809
01:30:21,130 --> 01:30:23,050
你通常不会简单地接受这些论点
You don't typically just take in these arguments

1810
01:30:23,050 --> 01:30:24,925
然后打印出来 不管有多少 
and print them, no matter how many there are.

1811
01:30:24,925 --> 01:30:28,930
我现在只是诊断性地做这件事 以向您展示语法是如何工作的 
I'm just doing this diagnostically for now to show you how the syntax works.

1812
01:30:28,930 --> 01:30:31,120
现在 让我在我的文件的底部继续--
Now, let me go ahead at the bottom of my file--

1813
01:30:31,120 --> 01:30:34,090
这一次我不会费心使用主函数 这样我们就可以只专注于
and I won't bother with a main function this time so we can focus only

1814
01:30:34,090 --> 01:30:35,560
关于这个函数f 
on this function f.

1815
01:30:35,560 --> 01:30:38,260
让我继续用三个参数来调用f 
Let me go ahead and just call f with three arguments.

1816
01:30:38,260 --> 01:30:39,850
我将使用与前面相同的论点 
I'll use the same arguments as before.

1817
01:30:39,850 --> 01:30:42,670
但我还没有费心给它们起名字 比如大帆船 
But I didn't bother giving them names just yet, like galleons,

1818
01:30:42,670 --> 01:30:44,690
还有镰刀和坚果之类的东西 
and sickles, and knuts, and the like.

1819
01:30:44,690 --> 01:30:46,420
那我有什么呢？
So what do I have?

1820
01:30:46,420 --> 01:30:49,180
无论什么调用此函数f的程序 
A program that no matter what calls this function f,

1821
01:30:49,180 --> 01:30:51,760
但它首先在文件的顶部定义了f 
but it first defines f at the top of the file.

1822
01:30:51,760 --> 01:30:54,100
它需要一些位置论据 
It's taking some number of positional arguments,

1823
01:30:54,100 --> 01:30:56,110
一些命名参数 
some number of named arguments.

1824
01:30:56,110 --> 01:30:59,590
目前 我只是打印出位置信息 
And for the moment, I'm just printing out the positional ones.

1825
01:30:59,590 --> 01:31:01,610
让我继续在我的终端窗口中
Let me go ahead and in my terminal window

1826
01:31:01,610 --> 01:31:04,510
运行unpack.py的Python并按Enter键 
run Python of unpack.py and hit Enter.

1827
01:31:04,510 --> 01:31:07,930
您将看到传入的位置参数
And you'll see that the positional arguments passed in

1828
01:31:07,930 --> 01:31:09,520
显然这是--
are apparently this--

1829
01:31:09,520 --> 01:31:12,790
一个序列 100 50 25 
a sequence, 100, 50, 25.

1830
01:31:12,790 --> 01:31:13,900
但请注意这一点 
But notice this.

1831
01:31:13,900 --> 01:31:16,630
如果我在那里清除我的终端窗口并传入其他内容 
If I clear my terminal window there and pass in something else,

1832
01:31:16,630 --> 01:31:18,550
就像五个 第四个论点 
like five, a fourth argument.

1833
01:31:18,550 --> 01:31:22,450
以前 如果我尝试更改参数的数量
Previously, if I tried to change the number of arguments

1834
01:31:22,450 --> 01:31:27,250
我正在传递我的总函数 它只被定义为取三个 
I'm passing in to my total function, which was only defined as taking three,

1835
01:31:27,250 --> 01:31:29,920
我会得到一个打字错误 一些视觉提示
I would have gotten a type error, some visual indication

1836
01:31:29,920 --> 01:31:32,950
不 您不能传递更多或更少的参数
that, no, you can't pass in more or fewer arguments

1837
01:31:32,950 --> 01:31:35,410
而不是实际在函数定义中 
than is actually in the function's definition.

1838
01:31:35,410 --> 01:31:36,340
但现在看吧 
But now watch.

1839
01:31:36,340 --> 01:31:38,890
如果我运行unpack.py的Python 这一次
If I run Python of unpack.py, this time passing

1840
01:31:38,890 --> 01:31:44,500
在100 50 25和5中 第四个论点 所有四个
in 100, 50, 25, and 5, a fourth argument, all four of those

1841
01:31:44,500 --> 01:31:46,100
一切都很顺利 
went through just fine.

1842
01:31:46,100 --> 01:31:50,830
我可以删除所有这些 例如 现在 重新运行我的程序
I can get rid of all of those but one, for instance now, rerun my program

1843
01:31:50,830 --> 01:31:51,920
在清除我的屏幕之后 
after clearing my screen.

1844
01:31:51,920 --> 01:31:54,250
现在 我在这里只看到一个论点 
And now, I'll see just one argument here.

1845
01:31:54,250 --> 01:31:56,590
即使后面有逗号 后面什么也没有 
And even though there's a comma and nothing after it,

1846
01:31:56,590 --> 01:32:00,842
实际上 这是查看元组时的语法 因此
this is actually the syntax when seeing a tuple, in effect, whereby

1847
01:32:00,842 --> 01:32:02,800
逗号只是表示这确实是一个列表 
the comma just indicates this is indeed a list,

1848
01:32:02,800 --> 01:32:05,440
但这里面只有一种元素 
but there's only one element therein.

1849
01:32:05,440 --> 01:32:07,480
好吧 让我们也变得更好奇一点 
Well, let's get a little more curious too.

1850
01:32:07,480 --> 01:32:10,210
让我继续倒带到我们
Let me go ahead and rewind here to where we

1851
01:32:10,210 --> 01:32:11,890
一开始只有这三个价值观 
started with just those three values.

1852
01:32:11,890 --> 01:32:15,640
这一次 让我继续打印出我的命名论点 可以说 
And this time, let me go ahead and print out my named argument, so to speak,

1853
01:32:15,640 --> 01:32:18,430
这不是args而是kwargs 
which isn't args but kwargs.

1854
01:32:18,430 --> 01:32:21,280
同样 此语法中的位置参数排在第一位 
Again, the positional args in this syntax come first.

1855
01:32:21,280 --> 01:32:24,440
被命名的论点 粗鲁人排在第二位 
The named arguments, kwargs come second.

1856
01:32:24,440 --> 01:32:26,510
这是Python开出的药方 
That's what Python prescribes.

1857
01:32:26,510 --> 01:32:29,800
所以现在 让我继续下去 不要只传递这些数字 
So now, let me go ahead and not pass in just these numbers.

1858
01:32:29,800 --> 01:32:32,740
让我继续下去 传递实际命名的参数 
Let me go ahead and pass in actually named arguments.

1859
01:32:32,740 --> 01:32:36,850
现在让我来做一些更具体的事情 比如帆船等于100 
So let me do something now more specifically, like galleons equals 100,

1860
01:32:36,850 --> 01:32:40,257
镰刀等于50 坚果等于25 
and sickles equals 50, and knuts equals 25.

1861
01:32:40,257 --> 01:32:42,340
我不会费心和道达尔做任何数学运算 
I'm not going to bother doing any math with total.

1862
01:32:42,340 --> 01:32:46,060
我现在只想探讨一下这种功能 
I just want to poke around right now at this functionality of having

1863
01:32:46,060 --> 01:32:47,830
可变数量的参数 
a variable number of arguments.

1864
01:32:47,830 --> 01:32:53,920
现在的巧妙之处在于 如果我运行unpack.py的Python并按Enter 就没有问题了 
And what's neat now is if I run Python of unpack.py and hit Enter, no problem.

1865
01:32:53,920 --> 01:32:58,870
kwargs是一个自动的字典 
What kwargs is, is automatically a dictionary that

1866
01:32:58,870 --> 01:33:03,260
包含了所有传递给函数的命名参数 
contains all of the named arguments that were passed to my function.

1867
01:33:03,260 --> 01:33:05,860
也就是说 在设计自己的函数时 
Which is to say, when designing your own functions,

1868
01:33:05,860 --> 01:33:09,250
如果你想支持多个参数 
if you want to support more than one argument,

1869
01:33:09,250 --> 01:33:12,910
也许多于两个 三个 四个 也许是可变数量的参数 
maybe more than two, or three, or four, maybe a variable number of arguments,

1870
01:33:12,910 --> 01:33:17,080
实际上 您可以支持数量可变的位置参数 
indeed, you can support both a variable number of positional arguments

1871
01:33:17,080 --> 01:33:21,490
值逗号值逗号值 或任何数量的命名
that are just value comma value comma value, or any number of named

1872
01:33:21,490 --> 01:33:24,040
arguments 实际上是将参数的名称
arguments, where you actually put the name of the parameter

1873
01:33:24,040 --> 01:33:28,760
等于值 然后可能是一个逗号和更多相同的东西 
equals the value and then maybe a comma and some more of the same.

1874
01:33:28,760 --> 01:33:34,720
现在 我们已经在一些函数中看到过了 
So now, it turns out we have seen this before in some of the functions

1875
01:33:34,720 --> 01:33:36,250
我们曾经约会过
we've used to date.

1876
01:33:36,250 --> 01:33:41,440
我们不一定会把它叫做args或者kwargs 
We didn't necessarily see it called args or necessarily see it called kwargs.

1877
01:33:41,440 --> 01:33:44,920
但我们至少在野外看到了一个这样的例子 
But we have seen at least one example of this in the wild.

1878
01:33:44,920 --> 01:33:48,580
回想一下我们的老朋友print 我们已经用了好几个星期了 
Recall our old friend print, which we've been using now for weeks.

1879
01:33:48,580 --> 01:33:51,640
当我们第一次查看打印方式的文档时 
And when we first looked at the documentation for print way

1880
01:33:51,640 --> 01:33:54,590
当时它看起来有点像这样
back when, it looked a little something like this.

1881
01:33:54,590 --> 01:33:57,460
要打印的第一个参数是对象 
The first argument to print was objects.

1882
01:33:57,460 --> 01:34:00,070
我当时在星号处挥了挥手 
And I waved my hand at the time at the asterisk that

1883
01:34:00,070 --> 01:34:02,080
在变量名的开头 
was at the start of that variable name.

1884
01:34:02,080 --> 01:34:05,860
但是我们有separator 它的默认值是一个空格 
But then we had sep for separator, the default value of which was a space.

1885
01:34:05,860 --> 01:34:08,270
我们有n 默认值是一个新行 
We had n, the default value of which was a new line.

1886
01:34:08,270 --> 01:34:11,380
还有一些其他的名字的争论 我们挥手表示反对 
And then some other names arguments that we waved our hands at then

1887
01:34:11,380 --> 01:34:13,210
现在我也会这么做
and I'll again do now.

1888
01:34:13,210 --> 01:34:16,900
但是你现在可以从我们的重点中推断出
But what you can now perhaps infer from our emphasis

1889
01:34:16,900 --> 01:34:20,560
在今天的这些十字架上 单星或双星 
on these asterisks today, the single stars or the double stars,

1890
01:34:20,560 --> 01:34:21,520
你知道吗
is that you know what?

1891
01:34:21,520 --> 01:34:24,640
这是Python文档中的约定
This is the convention in Python's documentation

1892
01:34:24,640 --> 01:34:30,440
以指示print采用可变数量的参数 
to indicate that print takes a variable number of arguments.

1893
01:34:30,440 --> 01:34:33,610
所以如果我们看看打印的实际实现 
So if we were to look at the actual implementation of the print

1894
01:34:33,610 --> 01:34:36,070
Python自己的作者实现的函数 
function implemented by Python's own authors,

1895
01:34:36,070 --> 01:34:38,290
它很可能看起来像这样 
it might very well look something like this.

1896
01:34:38,290 --> 01:34:40,690
Def print 然后第一个我们的论点
Def print, and then the first our argument

1897
01:34:40,690 --> 01:34:43,240
将是星形对象 从而表明打印
would be star objects, thereby indicating that print

1898
01:34:43,240 --> 01:34:45,440
接受数量可变的参数 
takes a variable number of arguments.

1899
01:34:45,440 --> 01:34:48,070
下一个可能是Sep等于QUOTE
The next one of which might be sep equals quote unquote

1900
01:34:48,070 --> 01:34:51,730
也可以使用双引号 也可以使用文档中的单引号 
either using double quotes or as in the documentation single quotes too.

1901
01:34:51,730 --> 01:34:55,057
下一个可以是n 其缺省值是新行 
The next one of which might be n, the default value of which is a new line.

1902
01:34:55,057 --> 01:34:56,890
然后还有一些其他的命名参数
And then some of those other named arguments

1903
01:34:56,890 --> 01:34:58,400
我们也没有看过 
that we've not looked at as well.

1904
01:34:58,400 --> 01:35:00,880
然后 可能在打印函数内部
And then, maybe inside of the print function

1905
01:35:00,880 --> 01:35:03,250
可能是由Python的作者实现的
implemented by the authors of Python, maybe

1906
01:35:03,250 --> 01:35:06,130
在对象中有一个类似于for对象的for循环
there's a for loop like for object in objects

1907
01:35:06,130 --> 01:35:10,960
这允许他们迭代这些可变数量的对象中的每一个
that allows them to iterate over each of those variable number of objects

1908
01:35:10,960 --> 01:35:12,400
并逐一打印出来 
and print each of them.

1909
01:35:12,400 --> 01:35:15,220
这就是为什么在过去的节目中 你和我
And this is why in programs past, you and I

1910
01:35:15,220 --> 01:35:18,790
我能做的只是打印左括号和右括号
have been able to do just print open parentheses close parenthesis

1911
01:35:18,790 --> 01:35:19,930
里面什么都没有 
with nothing inside.

1912
01:35:19,930 --> 01:35:22,030
或者你和我已经能够打印出一些东西
Or you and I have been able to print out something

1913
01:35:22,030 --> 01:35:25,240
例如 Hello world 在这些括号中只有一个字符串 
like, Hello, world, a single string inside of those parentheses.

1914
01:35:25,240 --> 01:35:28,420
或者你和我能够做一段单独的弦乐 你好 
Or you and I have been able to do a single string, Hello,

1915
01:35:28,420 --> 01:35:30,880
然后是另一个不带引号的世界 
and then another string quote unquote world,

1916
01:35:30,880 --> 01:35:33,760
从而传递两个或更多的参数 
thereby passing in two arguments or even more.

1917
01:35:33,760 --> 01:35:38,080
所以我们很久以来就有能力使用各种函数 
So we've long had this ability to use variadic functions,

1918
01:35:38,080 --> 01:35:41,050
因此 您可以传入数量可变的参数 
whereby you can pass in a variable number of arguments.

1919
01:35:41,050 --> 01:35:45,730
您现在通过这个args和kwargs语法得到的是--
What you now have via this args and kwargs syntax--

1920
01:35:45,730 --> 01:35:48,250
但再说一次 它们不需要被称为--就是
but again, they do not need to be called that-- is

1921
01:35:48,250 --> 01:35:53,290
使用一颗或两颗星来实现这些类型功能能力
the ability using that star or two stars to implement those kinds of functions

1922
01:35:53,290 --> 01:35:55,040
你自己 
yourself.

1923
01:35:55,040 --> 01:35:58,880
刚才我自己的f函数并没有做任何有趣的事情 
My own f function a moment ago did not do anything all that interesting.

1924
01:35:58,880 --> 01:36:01,250
但它暗示了你如何 如果在未来
But it hints at how you could, if in the future

1925
01:36:01,250 --> 01:36:06,230
您有一个用于接受零个或一个或多个这两种类型的参数的用例 
you have a use case, for taking zero or one or more of either type of argument.

1926
01:36:06,230 --> 01:36:12,280
现在对这些类型的争论有什么问题吗？
Any questions now on these types of arguments?

1927
01:36:12,280 --> 01:36:17,830
学生：如果你打印kwargs 而论点就像一个列表 会发生什么？
STUDENT: What will happen if you print kwargs and the argument is like a list?

1928
01:36:17,830 --> 01:36:18,890
大卫·J·马兰：啊 
DAVID J. MALAN: Ah.

1929
01:36:18,890 --> 01:36:20,830
那么 如果像打印列表一样打印参数 会发生什么呢？
So what would happen if you print the argument like it's a list?

1930
01:36:20,830 --> 01:36:21,910
所以我认为我们看到了这一点 
So I think we saw that.

1931
01:36:21,910 --> 01:36:26,650
如果我把我的历史倒回到我有f函数的时候 
If I roll back in my history here to when I had that f function.

1932
01:36:26,650 --> 01:36:28,810
我把它命名为f只是为了非常普通 
Which I called f just to be very generic just so

1933
01:36:28,810 --> 01:36:30,760
我们可以玩弄一下语法 
we could play around with the syntax.

1934
01:36:30,760 --> 01:36:32,510
这就是我在这里所拥有的 
This is what I had here.

1935
01:36:32,510 --> 01:36:35,050
所以这是一个--
So this is a--

1936
01:36:35,050 --> 01:36:38,500
我传入了100个逗号50个逗号25 
I passed in 100 comma 50 comma 25.

1937
01:36:38,500 --> 01:36:41,500
它会自动存储在args中 
That gets automatically stored in args.

1938
01:36:41,500 --> 01:36:44,800
当我运行它时 你实际上可以看到值的序列
And when I run it, you can actually see that sequence of values

1939
01:36:44,800 --> 01:36:46,630
通过运行unpack.py的Python 
by running Python of unpack.py.

1940
01:36:46,630 --> 01:36:50,560
有一个序列都是以单一变量的形式出现的 
There is that sequence all in the form of one single variable.

1941
01:36:50,560 --> 01:36:52,600
我把它打印出来只是为了诊断 
I'm printing it just for diagnostic purposes.

1942
01:36:52,600 --> 01:36:54,940
这并不是一个真正有用或漂亮的程序 
This is not really a useful or pretty program.

1943
01:36:54,940 --> 01:36:59,740
但它暗示了我们如何才能访问整个价值序列 
But it hints at how we can access that whole sequence of values.

1944
01:36:59,740 --> 01:37:03,640
这里还有关于这种方法的其他问题吗？
Other questions on this approach here?

1945
01:37:03,640 --> 01:37:07,735
学生：我们能把Kwargs从一个函数传递到另一个函数吗？
STUDENT: Can we pass the kwargs from one function to another function?

1946
01:37:07,735 --> 01:37:08,860
大卫·J·马兰：当然 
DAVID J. MALAN: Absolutely.

1947
01:37:08,860 --> 01:37:11,260
您可以将其中任何一个传递给另一个函数 该函数
You can pass either of those to another function, which

1948
01:37:11,260 --> 01:37:14,560
如果您想包装另一个函数 您可能需要这样做 
you might want to do if you want to wrap another function,

1949
01:37:14,560 --> 01:37:17,260
提供一些附加功能 但仍
provide some additional functionality, but still

1950
01:37:17,260 --> 01:37:23,290
也将所有受支持的参数传递给基础函数 
pass in all of the supported arguments to the underlying function as well.

1951
01:37:23,290 --> 01:37:23,920
好的 
All right.

1952
01:37:23,920 --> 01:37:25,780
接下来这个怎么样 
How about this next.

1953
01:37:25,780 --> 01:37:29,860
事实证明 我们可以将其他一些工具添加到您的工具包中
It turns out that a few other tools we can add to your tool kit

1954
01:37:29,860 --> 01:37:33,670
与Python支持的编程模型的类型相关 
relate to the types of programming models that Python supports.

1955
01:37:33,670 --> 01:37:36,250
我们很久以前就开始专注于
We started out quite some time ago focusing really

1956
01:37:36,250 --> 01:37:38,440
关于在Python语言中的过程性编程 
on procedural programming in Python.

1957
01:37:38,440 --> 01:37:41,980
由此我们从上到下、从左到右编写代码 定义一些函数 
Whereby we wrote code top to bottom, left to right, defining some functions,

1958
01:37:41,980 --> 01:37:44,740
或者 如果你愿意 一路上的程序 
or if you will, procedures along the way,

1959
01:37:44,740 --> 01:37:47,110
定义变量 并产生副作用 
defining variables, and having side effects,

1960
01:37:47,110 --> 01:37:48,890
并根据需要赋值 
and assigning values as needed.

1961
01:37:48,890 --> 01:37:51,700
但后来我们最终引入或真正揭示了
But we then eventually introduced or really revealed

1962
01:37:51,700 --> 01:37:54,340
该Python也是非常面向对象的 
that Python is also very much object-oriented.

1963
01:37:54,340 --> 01:37:56,920
很多这样的变量 很多这样的类型
And a lot of those variables, a lot of those types

1964
01:37:56,920 --> 01:38:00,070
我们使用的所有时间实际上都是物体 
that we were using all that time were in fact objects,

1965
01:38:00,070 --> 01:38:02,950
来自特定类的对象 
objects that came from certain classes.

1966
01:38:02,950 --> 01:38:05,680
这些类是各种各样的模板 蓝图 
And those classes were templates of sorts, blueprints,

1967
01:38:05,680 --> 01:38:09,370
通过它 您可以在其中封装数据和功能 
via which you could encapsulate both data and functionality therein.

1968
01:38:09,370 --> 01:38:11,380
那么我们一路上也看到了一些提示
Well, we also saw along the way some hints

1969
01:38:11,380 --> 01:38:14,350
第三种编程范例 也就是Python 
of a third paradigm of programming that Python also,

1970
01:38:14,350 --> 01:38:18,310
在某种程度上支持 这被称为函数式编程 
to some extent, supports, which is known as functional programming.

1971
01:38:18,310 --> 01:38:21,250
其中的功能比以往任何时候都更加强大
Whereby functions are ever more powerful in that

1972
01:38:21,250 --> 01:38:25,630
它们往往不会有副作用 不会在全球范围内打印或改变状态 
they tend not to have side effects, no printing or changing of state globally.

1973
01:38:25,630 --> 01:38:28,120
相反 它们是完全独立的
But rather, they're completely self-contained

1974
01:38:28,120 --> 01:38:31,240
并可以作为输入和返回值 
and might take as inputs and return values.

1975
01:38:31,240 --> 01:38:34,510
这通常是我们开始整理东西时看到的一个范例 
And that's generally a paradigm we saw when we started sorting things,

1976
01:38:34,510 --> 01:38:37,660
特别是使用像我们的排序函数这样的函数
particularly with functions like our sort function

1977
01:38:37,660 --> 01:38:40,390
或Lambda函数时传入该函数
or Lambda function when we passed in the function

1978
01:38:40,390 --> 01:38:43,240
早在很久以前 我们就想用来排序列表 
we wanted to use to sort a list way back when.

1979
01:38:43,240 --> 01:38:46,690
好吧 事实证明 Python还具有其他功能
Well, it turns out Python has other functionality that

1980
01:38:46,690 --> 01:38:50,590
让人联想到函数式编程 而且确实是一种强大的方式
is reminiscent of functional programming and indeed is a powerful way

1981
01:38:50,590 --> 01:38:53,260
以更不同的方式解决问题 
to solve problems a little more differently still.

1982
01:38:53,260 --> 01:38:54,460
让我提出这一点 
Let me propose this.

1983
01:38:54,460 --> 01:38:57,940
让我提议我在VS代码中创建一个新程序
Let me propose that I whip up a new program here in VS Code

1984
01:38:57,940 --> 01:39:02,500
关闭我们的unpack.py 这一次创建另一个名为yell的程序 
by closing our unpack.py and this time creating another program called yell.

1985
01:39:02,500 --> 01:39:05,800
假设手头的目标是实现某种程序 从而允许用户
Suppose the goal at hand is to implement some program that allows the user

1986
01:39:05,800 --> 01:39:08,470
来传递一个输入 然后它喊出响应
to pass an input, and then it yells the response

1987
01:39:08,470 --> 01:39:10,450
通过强制所有内容都大写 
by forcing everything to uppercase.

1988
01:39:10,450 --> 01:39:12,790
我向那些戴着耳机的人道歉 
My apologies to those with headphones there.

1989
01:39:12,790 --> 01:39:13,960
我会调整的 
I'll modulate.

1990
01:39:13,960 --> 01:39:16,690
因此 让我继续运行yell.py的代码 
So let me go ahead and run code of yell.py.

1991
01:39:16,690 --> 01:39:19,360
在yell.py中 让我们继续并实现
And within yell.py, let's go ahead and implement

1992
01:39:19,360 --> 01:39:22,190
一个真正做到这一点的程序 
a program that really does just that.

1993
01:39:22,190 --> 01:39:24,730
让我们继续在这里定义一个主函数 
Let's go ahead and define a main function up here.

1994
01:39:24,730 --> 01:39:28,060
让我们暂时假设这个Yell函数已经存在
And let's assume for the moment that this yell function already exists

1995
01:39:28,060 --> 01:39:32,860
然后喊出这样的话：这是CS50 大写正确 不是全部大写 
and yell something like, This is CS50, properly capitalized, not in all caps.

1996
01:39:32,860 --> 01:39:37,090
现在 让我们继续使用def yell实现这个yell函数 
Now, let's go ahead and implement this yell function with def yell.

1997
01:39:37,090 --> 01:39:41,590
目前 它将只需要一个单词或短语 
It's going to take, for now, a single word or phrase.

1998
01:39:41,590 --> 01:39:42,760
让我们继续前进 
And let's go ahead.

1999
01:39:42,760 --> 01:39:44,530
我把它叫做短语 
And I'll call it phrase here.

2000
01:39:44,530 --> 01:39:48,820
接下来 我会打印出短语 
And I'm going to go ahead and just print out the phrase.upper.

2001
01:39:48,820 --> 01:39:51,910
这就是说 UPPER将会把HOLE这个东西变成大写 
So phrase.upper is going to force the hole thing to uppercase.

2002
01:39:51,910 --> 01:39:54,760
像往常一样 如果这个文件的名称等于
And as usual, down here if the name of this file equals

2003
01:39:54,760 --> 01:39:59,620
等于引号不加引号的main 那么让我们像往常一样继续 并调用main 
equals quote unquote main, then let's go ahead, as always, and call main.

2004
01:39:59,620 --> 01:40:00,642
所以让我们来运行这个 
So let's just run this.

2005
01:40:00,642 --> 01:40:03,100
但在很大程度上 这应该是相当简单的 
But for the most part, it should be fairly straightforward.

2006
01:40:03,100 --> 01:40:08,710
当我运行yell.py的Python时 屏幕上显示的是CS50 
When I run Python of yell.py, THIS IS CS50 is yelled on the screen.

2007
01:40:08,710 --> 01:40:09,730
好的 那很好 
All right, that's nice.

2008
01:40:09,730 --> 01:40:16,120
但是 Yell只期待一个短语 这并不是很好 
But it's not great that yell only expects a single phrase.

2009
01:40:16,120 --> 01:40:18,190
如果我可以 就像印刷品一样 不是很好吗
Wouldn't it be nice, like print, if I could

2010
01:40:18,190 --> 01:40:22,870
一般情况下 传入一个短语、两个、三个或多个单词
pass in one phrase, or two, or three, or really multiple words more generally

2011
01:40:22,870 --> 01:40:25,130
而是作为单独的词语本身 
but as individual words themselves.

2012
01:40:25,130 --> 01:40:29,380
所以让我稍微调整一下 把大喊大叫改为不是一个短语
So let me retool this a little bit and change yell to take in not a phrase

2013
01:40:29,380 --> 01:40:32,330
但是 像单词列表这样的东西怎么样？
but how about something like a list of words.

2014
01:40:32,330 --> 01:40:35,650
所以最终 我可以像这样喊喊叫 
So that ultimately, I can call yell like this.

2015
01:40:35,650 --> 01:40:41,380
引用不引用 这个在列表中 引用不引用 这个在列表中 
Quote unquote, this inside of a list, quote unquote, "This" inside of a list,

2016
01:40:41,380 --> 01:40:43,975
并且 在列表中引用不引号的“CS50” 
and, quote unquote, "CS50" inside of a list.

2017
01:40:43,975 --> 01:40:46,600
现在我不打算费心讨论类型提示或注释 
I'm not going to bother with type hints or annotations for now.

2018
01:40:46,600 --> 01:40:50,980
但我只是假设Yell现在已经被定义为接受一系列单词
But I'll just assume that yell has been defined now as taking a list of words

2019
01:40:50,980 --> 01:40:52,400
就像这里定义的那样 
as defined here.

2020
01:40:52,400 --> 01:40:54,670
但现在我想强迫他们全部使用小写字母 
But now I want to force them all to lowercase.

2021
01:40:54,670 --> 01:40:57,160
所以我不太想做这么简单的事情 
So I don't quite want to do something as simple as this.

2022
01:40:57,160 --> 01:41:02,890
就像单词中的单词一样 例如 我可以打印给定的单词
Like for word in words, I could, for instance, print that given word

2023
01:41:02,890 --> 01:41:05,500
也许现在就以一无所有结束这条线 
and maybe end the line with nothing right now.

2024
01:41:05,500 --> 01:41:10,090
但我认为如果我这样做 yell.py的巨蟒 不 这是不对的 
But I think if I do this, Python of yell.py, no, that's not right.

2025
01:41:10,090 --> 01:41:12,250
我没有强迫任何东西大写 
I haven't forced anything to uppercase.

2026
01:41:12,250 --> 01:41:13,700
所以让我们来解决这个问题 
So let's fix this.

2027
01:41:13,700 --> 01:41:15,620
那么 让我们继续执行以下操作 
Well, let's go ahead and do the following.

2028
01:41:15,620 --> 01:41:19,940
让我继续并按如下方式累积大写单词 
Let me go ahead and accumulate the uppercase words as follows.

2029
01:41:19,940 --> 01:41:22,120
让我创建一个名为UPERCASE的变量
Let me create a variable called uppercase

2030
01:41:22,120 --> 01:41:25,420
并使用方括号或我们的更多
and initialize it to an empty list using square brackets or our more

2031
01:41:25,420 --> 01:41:27,410
详细列表语法 
verbose list syntax.

2032
01:41:27,410 --> 01:41:31,780
现在 让我继续重复这些单词中的每一个 
And now, let me go ahead and iterate over each of those words in words.

2033
01:41:31,780 --> 01:41:37,840
对于它们中的每一个 让我们进入上面的大小写列表 附加到它
And for each of them, let's go into our upper cased list, append to it

2034
01:41:37,840 --> 01:41:41,020
当前单词的大写版本 
the current words uppercase version.

2035
01:41:41,020 --> 01:41:44,740
这是一种创建名为大写的新列表的方法
So this is a way of creating a new list called uppercase

2036
01:41:44,740 --> 01:41:48,070
这只是附加、附加、附加到该列表
that is just appending, appending, appending to that list

2037
01:41:48,070 --> 01:41:51,520
循环中的每个当前单词 但改为提升评级 
each of the current words in the loop but uppercased instead.

2038
01:41:51,520 --> 01:41:55,600
现在 让我继续打印出评价较高的榜单 
And now, just let me go ahead and print out the uppercased list.

2039
01:41:55,600 --> 01:41:56,870
这不太对 
This isn't quite right.

2040
01:41:56,870 --> 01:41:58,180
让我们看看这里会发生什么 
Let's see what happens here.

2041
01:41:58,180 --> 01:42:01,540
Yell.py的蟒蛇 好的 
Python of yell.py, OK.

2042
01:42:01,540 --> 01:42:04,090
这不太对 因为我觉得我不想
It's not quite right, because I don't think I want

2043
01:42:04,090 --> 01:42:06,100
那些引号或那些方括号 
those quotes or those square brackets.

2044
01:42:06,100 --> 01:42:07,100
我看到的是什么？
What am I seeing?

2045
01:42:07,100 --> 01:42:09,070
我实际上是在打印一份清单 
I'm actually printing a list.

2046
01:42:09,070 --> 01:42:13,155
但是 现在我们的一些解包语法可以派上用场 
But, but, but, here's where some of our unpacking syntax now can be useful.

2047
01:42:13,155 --> 01:42:15,280
我不需要改变我解决这个问题的方法 
I don't have to change my approach to this problem.

2048
01:42:15,280 --> 01:42:18,850
我只需添加一个星号就可以解开大写字母 
I can just unpack uppercase by adding a single star.

2049
01:42:18,850 --> 01:42:22,000
现在 让我继续并重新运行yell.py的Python 
And now, let me go ahead and rerun Python of yell.py.

2050
01:42:22,000 --> 01:42:24,370
现在 它实际上只是一种英语 
And now, it's actually just English.

2051
01:42:24,370 --> 01:42:26,980
没有像引号那样残留的Python语法 
There's no remnants of Python syntax like the quotes,

2052
01:42:26,980 --> 01:42:29,290
还有逗号和方括号 
and the commas, and the square brackets.

2053
01:42:29,290 --> 01:42:34,690
我现在解开了 这是CS50 作为三个单独的参数打印出来 
I've now unpacked, this is CS50 as three separate arguments to print.

2054
01:42:34,690 --> 01:42:38,510
因此 现在这种拆包技术似乎已经很有用了 
So already now, this unpacking technique would seem to be useful.

2055
01:42:38,510 --> 01:42:41,260
嗯 有点不幸的是 我现在
Well, it's a little unfortunate that I now

2056
01:42:41,260 --> 01:42:45,640
不过 我需要以这种方式调用带有值列表的Yell 
need to call yell though with a list of values in this way.

2057
01:42:45,640 --> 01:42:47,097
这根本不是常态 
This is just not the norm.

2058
01:42:47,097 --> 01:42:49,180
或者至少 它的用户界面不太友好
Or it's at least, it's not nearly as user-friendly

2059
01:42:49,180 --> 01:42:51,250
类似于打印函数 其中
as something like the print function where

2060
01:42:51,250 --> 01:42:54,580
我可以传入零个、一个、两个、三个或任意数量的参数 
I can pass in zero, or one, or two, or three, or any number of arguments.

2061
01:42:54,580 --> 01:42:58,570
为什么你要让我为你的喊叫功能只传递一个列表？
Why are you making me for your yell function pass in only a list?

2062
01:42:58,570 --> 01:42:59,530
嗯 我们可以做得更好 
Well, we can do better.

2063
01:42:59,530 --> 01:43:01,780
让我们采用我们学到的一些新惯例 
Let's adopt some of the new conventions we've learned.

2064
01:43:01,780 --> 01:43:05,500
让我们继续 通过去掉方括号来删除列表 
And let's go ahead and get rid of the list by removing the square brackets.

2065
01:43:05,500 --> 01:43:08,380
让我们来传递三个论点 
And let's just pass yell three arguments.

2066
01:43:08,380 --> 01:43:11,830
现在 我不想做一些事情 比如改变单词的定义
Now, I don't want to do something like change the definition of words

2067
01:43:11,830 --> 01:43:14,707
第一个单词 第二个单词 
to take in word one, word two.

2068
01:43:14,707 --> 01:43:16,540
这不会扩大规模 也不会
That's not going to scale and it's not going

2069
01:43:16,540 --> 01:43:18,190
处理不同数量的单词 
to handle different number of words.

2070
01:43:18,190 --> 01:43:19,840
但我们现在有一种技术 
But we have a technique now.

2071
01:43:19,840 --> 01:43:23,830
我们可以使用STAR ARGS 这将允许YELL功能
We can say star args, which will allow the yell function

2072
01:43:23,830 --> 01:43:25,870
可以接受任意数量的参数 
to accept any number of arguments.

2073
01:43:25,870 --> 01:43:28,900
为了具体起见 我们不要泛泛地称它为ARGS 
And just for specificity, let's not call it generically args.

2074
01:43:28,900 --> 01:43:33,250
让我们给它起个更不言自明的名字吧 就像明星词一样 
Let's name it something a little more self explanatory like star words.

2075
01:43:33,250 --> 01:43:37,310
这只是意味着我传入的单词数量是可变的 
This just means I have a variable number of words being passed in.

2076
01:43:37,310 --> 01:43:39,790
现在 我想 我已经取得了些许进步 
Now, I think, I've made a marginal improvement.

2077
01:43:39,790 --> 01:43:42,220
让我再运行一次 yell.py的Python 
Let me run this again, Python of yell.py.

2078
01:43:42,220 --> 01:43:45,050
这是全部大写的CS50 
This is CS50 is in all caps.

2079
01:43:45,050 --> 01:43:46,600
但这只是好一点而已 
But it's just a little better.

2080
01:43:46,600 --> 01:43:50,590
因为现在我可以像对待印刷品一样对待大喊大叫 
Because now I can treat yell just like I've long treated print,

2081
01:43:50,590 --> 01:43:53,980
你想传多少东西就传多少 印刷品会处理的 
pass in as many things as you want, and print will deal with it.

2082
01:43:53,980 --> 01:43:56,860
现在 我的大喊大叫功能看起来就像它看起来一样强大 
Now, my yell function is just as powerful it would seem.

2083
01:43:56,860 --> 01:44:00,820
更好的是 它还迫使所有内容都大写 
And better still, it also forces everything to uppercase.

2084
01:44:00,820 --> 01:44:03,250
事实证明 Python附带了一个名为
Well, it turns out Python comes with this function called

2085
01:44:03,250 --> 01:44:07,870
地图 它的生活目的是让你地图 也就是应用
map, whose purpose in life is to allow you to map, that is, apply

2086
01:44:07,870 --> 01:44:12,590
某些函数作用于某个序列中的每个元素 如列表 
some function to every element of some sequence like a list.

2087
01:44:12,590 --> 01:44:17,470
例如 如果我们想强制每个单词都大写 
So for instance, if we want to force to uppercase each of the words,

2088
01:44:17,470 --> 01:44:22,780
这是传入的单词列表中的CS50 
this is CS50 in the list of words that's been passed in, well,

2089
01:44:22,780 --> 01:44:27,740
我们实际上希望将大写函数映射到这些值中的每一个 
we essentially want to map the upper case function to each of those values.

2090
01:44:27,740 --> 01:44:30,130
那么 在Python中使用map可以做到这一点吗？
So using map in Python can I do just that?

2091
01:44:30,130 --> 01:44:31,900
让我回到这里来VS Code 
Let me go back here to VS Code.

2092
01:44:31,900 --> 01:44:35,800
现在让我提议我重新实现这一点 如下所示 
And let me propose now that I re-implement this as follows.

2093
01:44:35,800 --> 01:44:40,960
我去掉了这三行代码 去掉了那个循环
I get rid of all three of these lines here, getting rid of that loop

2094
01:44:40,960 --> 01:44:41,980
尤其是 
in particular.

2095
01:44:41,980 --> 01:44:45,100
让我仍然声明一个名为upperase的变量 
Let me still declare a variable called uppercased.

2096
01:44:45,100 --> 01:44:50,260
但让我将其设置为等于这个名为map的新函数的返回值 
But let me set it equal to the return value of this new function called map.

2097
01:44:50,260 --> 01:44:52,450
MAP在这里有两个参数 
Map takes two arguments here.

2098
01:44:52,450 --> 01:44:56,140
在本例中 是我想要
In this case, the name of a function that I want to

2099
01:44:56,140 --> 01:44:59,170
映射到一系列值 
map on to a sequence of values.

2100
01:44:59,170 --> 01:45:03,580
那么 我想对传入的每个单词应用什么函数呢？
Well, what function do I want to apply to every word that's been passed in?

2101
01:45:03,580 --> 01:45:05,470
嗯 事实证明 多亏了我的知识
Well, it turns out, thanks to my knowledge

2102
01:45:05,470 --> 01:45:09,310
现在谈到面向对象编程 我知道在str类中
now of object-oriented programming, I know that in the str class

2103
01:45:09,310 --> 01:45:11,320
有一个名为UPPER的函数 
there is a function called upper.

2104
01:45:11,320 --> 01:45:14,440
我们通常使用字符串的名称来调用它
We've usually called it by using the name of a string

2105
01:45:14,440 --> 01:45:18,400
可变的 上开的帕伦关闭帕伦 
variable.upper open paren close paren.

2106
01:45:18,400 --> 01:45:21,760
但是如果您阅读了str类的文档 
But if you read the documentation for the str class,

2107
01:45:21,760 --> 01:45:25,540
您将看到该函数实际上被描述为str.upper 
you'll see that the function is described indeed as str.upper.

2108
01:45:25,540 --> 01:45:30,250
我没有在str.upper的末尾使用圆括号 也就是打开和关闭 
I'm not using parentheses, open and close, at the end of str.upper.

2109
01:45:30,250 --> 01:45:31,960
因为我现在不想宣布 
Because I don't want to call it now.

2110
01:45:31,960 --> 01:45:36,050
我想把这个函数传递给map函数 
I want to pass this function to the map function,

2111
01:45:36,050 --> 01:45:40,390
因此映射可以以某种方式添加这些括号 可以这么说 并将其命名为
so that map can somehow add those parentheses, so to speak, and call it

2112
01:45:40,390 --> 01:45:43,040
这些单词中的每一个 
on every one of these words.

2113
01:45:43,040 --> 01:45:45,670
这就是MAP非常强大的功能 
And this is what map does quite powerfully,

2114
01:45:45,670 --> 01:45:48,040
并且确实是函数式编程的一个实例 
and is an instance, indeed, of functional programming.

2115
01:45:48,040 --> 01:45:51,700
因此 我将另一个函数传递给这个map函数 
Whereby I'm passing to this map function another function.

2116
01:45:51,700 --> 01:45:52,480
不是说了算 
Not calling it.

2117
01:45:52,480 --> 01:45:55,570
我只是通过某种形式的参考来传递它 
I'm just passing it in by a reference of sorts.

2118
01:45:55,570 --> 01:46:00,700
而MAP要为我做的就是重复这些单词 
And what map is going to do for me is iterate over each of those words,

2119
01:46:00,700 --> 01:46:04,210
对这些单词中的每一个调用str.Upper 然后返回
call str.upper on each of those words, and return

2120
01:46:04,210 --> 01:46:10,690
对我来说 一个全新的列表将所有这些结果都包含在一个列表中 
to me a brand new list containing all of those results together in one list.

2121
01:46:10,690 --> 01:46:14,320
它完全不需要我更加手动地使用
It completely obviates the need for me to do this more manually using

2122
01:46:14,320 --> 01:46:15,190
那份名单 
that list.

2123
01:46:15,190 --> 01:46:17,980
我仍然会使用星号大写来打印整个内容 
I'm still going to print the whole thing using star uppercase.

2124
01:46:17,980 --> 01:46:21,490
所以如果我拿回一个包含三个大写单词的列表 
So that if I get back a list of three uppercase words,

2125
01:46:21,490 --> 01:46:24,500
我要把它们拆开 全部打印出来 
I'm going to unpack them and print them all out.

2126
01:46:24,500 --> 01:46:25,750
所以让我们再来一次 
So let's run this again.

2127
01:46:25,750 --> 01:46:29,740
Yell.py的Python回车 
Python of yell.py Enter.

2128
01:46:29,740 --> 01:46:31,780
瞧 它还在工作 
And voila, it's still working.

2129
01:46:31,780 --> 01:46:34,480
但现在的密码更紧了--
But the code now is even more tight--

2130
01:46:34,480 --> 01:46:36,690
比以前更紧了 
even tighter than before.

2131
01:46:36,690 --> 01:46:38,440
所以事实证明我们还有另一种方法
So it turns out there's another way we can

2132
01:46:38,440 --> 01:46:40,690
以一种更好的方式解决这个问题
solve this problem in a way that's even more

2133
01:46:40,690 --> 01:46:42,700
毕德式的 或者至少是相当普遍的 
Pythonic, or at least quite common.

2134
01:46:42,700 --> 01:46:46,360
这是使用一种被称为列表理解的功能 
And that's using a feature known as a list comprehension.

2135
01:46:46,360 --> 01:46:48,380
如果你愿意的话 这是一个很重要的短语 
And it's a big phrase, if you will.

2136
01:46:48,380 --> 01:46:50,830
但它指的是使用Python为您提供的功能
But it refers to the ability in Python for you

2137
01:46:50,830 --> 01:46:54,550
为了非常容易地在不使用循环的情况下构建列表 
to very easily construct a list on the fly without using a loop,

2138
01:46:54,550 --> 01:46:57,250
而不调用Append和Append 而是执行所有操作
without calling append and append, but to do everything

2139
01:46:57,250 --> 01:47:00,370
总之 大胆地说 优雅的俏皮话 
in one, daresay, elegant one-liner.

2140
01:47:00,370 --> 01:47:06,003
那么 我该如何使用这个列表理解的概念呢？
So how can I go about using this notion of a list comprehension?

2141
01:47:06,003 --> 01:47:07,420
好吧 让我继续做这件事 
Well, let me go ahead and do this.

2142
01:47:07,420 --> 01:47:10,330
在yell.py中 在VS代码中 让我继续
In yell.py, in VS Code here, let me go ahead

2143
01:47:10,330 --> 01:47:12,430
并按如下方式改变我的方法 
and change my approach as follows.

2144
01:47:12,430 --> 01:47:16,070
与其使用地图 这是非常好和正确的这种方式 
Instead of using map, which is perfectly fine and correct in this way,

2145
01:47:16,070 --> 01:47:18,220
让我来给你们展示一下另一种方式 
let me just show you this other way as well.

2146
01:47:18,220 --> 01:47:22,710
列表理解是创建这样一个列表的机会 
A list comprehension is the opportunity to create a list like this,

2147
01:47:22,710 --> 01:47:24,550
使用这样的方括号 
using square brackets like this.

2148
01:47:24,550 --> 01:47:28,260
但是在这些方括号中编写一个Python表达式 
But inside of those square brackets to write a Python expression,

2149
01:47:28,260 --> 01:47:33,000
这实际上将为您动态生成一个全新的列表
that in effect is going to dynamically generate a brand new list for you

2150
01:47:33,000 --> 01:47:35,610
使用你写的一些逻辑 
using some logic you've written.

2151
01:47:35,610 --> 01:47:38,130
我在这里可能采取的方法是这样的 
And the approach I might take here is this.

2152
01:47:38,130 --> 01:47:43,800
如果我想在这个列表中存储每个单词的大写版本
If I want to store in this list the uppercase version of every word

2153
01:47:43,800 --> 01:47:47,130
在单词列表中 我可以这样做--
in that words list, I can do this--

2154
01:47:47,130 --> 01:47:53,010
一字不差 一字不差 
word.upper for word in words.

2155
01:47:53,010 --> 01:47:54,720
现在 这是一个很大的问题 
Now, this is a mouthful.

2156
01:47:54,720 --> 01:47:58,170
但我敢说 Python程序员喜欢这种功能
But I dare say Python programmers love this capability

2157
01:47:58,170 --> 01:48:02,340
能够在运行中定义其中的列表
of being able to define on the fly a list inside of which

2158
01:48:02,340 --> 01:48:06,300
是任何数量的值 你通常会这样做 至少我们已经做到了 
is any number of values that you would ordinarily, at least as we've done it,

2159
01:48:06,300 --> 01:48:09,630
使用循环构造 然后再次调用Append、Append和Append 
construct with a loop and again calling append, and append, and append.

2160
01:48:09,630 --> 01:48:12,810
但这通常需要两行、三行、四行或更多行 
But that usually takes two, three, four or more lines.

2161
01:48:12,810 --> 01:48:16,350
我在这里强调的这个清单理解
This list comprehension that I've highlighted here

2162
01:48:16,350 --> 01:48:20,190
现在是创造完全相同的东西的另一种方式--
is now an alternative way to create the exact same thing--

2163
01:48:20,190 --> 01:48:24,180
一张清单里面有一大堆被看好的词 
a list inside of which are a whole bunch of uppercased words.

2164
01:48:24,180 --> 01:48:24,990
哪几个词？
Which words?

2165
01:48:24,990 --> 01:48:30,180
对于传递给Yell的单词列表中的每个单词
For each word in the words list that was passed into yell

2166
01:48:30,180 --> 01:48:33,360
就会出现在这张清单上 
is what ends up in this list.

2167
01:48:33,360 --> 01:48:36,060
这里有关于这个语法的问题吗？
Questions on this syntax here?

2168
01:48:36,060 --> 01:48:38,640
这肯定需要一点时间来适应 
It definitely takes a little bit of getting used to.

2169
01:48:38,640 --> 01:48:42,300
因为左边有这个值 所以这个函数在这里调用 
Because you've got this value on the left, this function call here.

2170
01:48:42,300 --> 01:48:45,270
你在方括号里有这个循环 
You've got this loop inside of the square brackets.

2171
01:48:45,270 --> 01:48:48,810
但是 如果您习惯于以这种方式从左侧阅读代码
But if you become accustomed to reading the code in this way from left

2172
01:48:48,810 --> 01:48:51,510
向右 这意味着给我大写版本
to right, this means give me the uppercase version

2173
01:48:51,510 --> 01:48:55,080
在我的单词列表中 每个单词对应的单词 
of the word for each word in my words list.

2174
01:48:55,080 --> 01:48:57,790
关于列表理解的问题在这里？
Questions here on list comprehensions?

2175
01:48:57,790 --> 01:48:58,320
学生：嗨 
STUDENT: Hi.

2176
01:48:58,320 --> 01:49:05,237
你能像If Else一样做条件句 或者组合If、Elif、Else吗？
Can you do conditionals also, like if else, or combine if, elif, else?

2177
01:49:05,237 --> 01:49:06,570
大卫·J·马兰：的确 你可以 
DAVID J. MALAN: Indeed, you can.

2178
01:49:06,570 --> 01:49:08,760
让我回到那个问题上来 在那里我们将看到一个机会
And let me come back to that, where we'll see an opportunity

2179
01:49:08,760 --> 01:49:09,885
有条件地做某事 
to do things conditionally.

2180
01:49:09,885 --> 01:49:13,350
但现在 我只是将列表中的每个单词都放在上面 
But for now, I'm just uppercasing every word in the list.

2181
01:49:13,350 --> 01:49:14,110
问得好 
Good question.

2182
01:49:14,110 --> 01:49:16,277
还有其他问题吗？
Other questions?

2183
01:49:16,277 --> 01:49:16,860
学生：是的 
STUDENT: Yeah.

2184
01:49:16,860 --> 01:49:18,630
这是函数式编程吗？
Is this functional programming?

2185
01:49:18,630 --> 01:49:24,257
或者我的意思是 这个特殊的东西 我们用单词 单词中的一个单词？
Or I mean, this particular thing, we are using words.upper for a word in words?

2186
01:49:24,257 --> 01:49:25,590
大卫·J·马兰：不一定 
DAVID J. MALAN: Not necessarily.

2187
01:49:25,590 --> 01:49:28,060
我想说 这更多的是一种Python的特性 
This is more of a feature of Python, I would say.

2188
01:49:28,060 --> 01:49:28,560
学生：好的 
STUDENT: OK.

2189
01:49:28,560 --> 01:49:29,435
大卫·J·马兰：是的 
DAVID J. MALAN: Yeah.

2190
01:49:29,435 --> 01:49:33,690
MAP是我们使用Lambda的一个非常具体的化身
Map was one very specific incarnation of thereof our use of Lambda

2191
01:49:33,690 --> 01:49:36,690
并将其作为键属性传递给排序函数 
and passing it in as a key attribute to the sort function,

2192
01:49:36,690 --> 01:49:38,730
不久前的排序函数就是一个例子 
sorted function a while back was an example.

2193
01:49:38,730 --> 01:49:41,310
我们马上就要见面了 
And we're about to see one other.

2194
01:49:41,310 --> 01:49:43,680
所以我们甚至可以使用这些列表理解
So we can even use these list comprehension

2195
01:49:43,680 --> 01:49:46,840
筛选结果列表中的值或从中筛选出的值 
to filter values in or out of our resulting list.

2196
01:49:46,840 --> 01:49:50,250
事实上 在VS代码中 让我关闭yell.py并关闭我的终端
So in fact, in VS Code here, let me close yell.py and close my terminal

2197
01:49:50,250 --> 01:49:50,760
窗户 
window.

2198
01:49:50,760 --> 01:49:53,490
让我在这里创建一个新的项目 它的人生目标是
And let me create a new program here whose purpose in life

2199
01:49:53,490 --> 01:49:58,110
也许是用一张和以前一样的学生名单和一个更短的版本
maybe is to take a same list of students as before with a shorter version

2200
01:49:58,110 --> 01:50:02,370
只需过滤掉格兰芬多的所有学生 
thereof, and just filter out all of the students in Gryffindor.

2201
01:50:02,370 --> 01:50:06,090
因此 让我继续创建一个名为Gryffindors.py的文件 
So let me go ahead and create a file called Gryffindors.py.

2202
01:50:06,090 --> 01:50:10,170
我要继续复制我的学生名单之前的粘贴 
I'm going to go ahead and copy paste from before really my list of students,

2203
01:50:10,170 --> 01:50:13,230
至少从一开始就是赫敏、哈利、罗恩和德拉科
at least Hermione, Harry, Ron, and Draco from the start

2204
01:50:13,230 --> 01:50:17,430
在这里 只是为了让我能专注于一个学生
here, just so that I can focus on one student who

2205
01:50:17,430 --> 01:50:19,197
碰巧不是斯莱特林的 
happens not to be from Slytherin.

2206
01:50:19,197 --> 01:50:21,030
我现在要做的是 如果我想
And what I'm going to do here now, if I want

2207
01:50:21,030 --> 01:50:24,970
为了只过滤掉格兰芬多的学生 让我继续这样做 
to filter out only the Gryffindor students, let me go ahead and do this.

2208
01:50:24,970 --> 01:50:27,720
让我创建另一个名为Gryffindors的变量 它
Let me create another variable called Gryffindors, which

2209
01:50:27,720 --> 01:50:30,480
将等同于下面的列表 
is going to equal the following list.

2210
01:50:30,480 --> 01:50:32,680
而这将是一条更长的队伍 
And this is going to be a bit of a longer line.

2211
01:50:32,680 --> 01:50:34,830
所以我要主动移动我的方括号
So I'm going to proactively move my square brackets

2212
01:50:34,830 --> 01:50:36,480
放在两条不同的线上 
onto two separate lines.

2213
01:50:36,480 --> 01:50:39,240
现在 我将创建一个列表理解 
And I'm going to create now a list comprehension.

2214
01:50:39,240 --> 01:50:40,560
我想做这个 
I want to do this.

2215
01:50:40,560 --> 01:50:45,450
我希望这份名为格兰芬多的新名单包含每个学生的名字
I want this new list called Gryffindors to contain every student's name

2216
01:50:45,450 --> 01:50:49,560
对于学生名单中的每个学生 
for each student in the student's list.

2217
01:50:49,560 --> 01:50:57,150
但是 如果学生的房子等于引号格兰芬多 
But, but, but, if the student's house equals equals quote unquote Gryffindor.

2218
01:50:57,150 --> 01:51:01,290
所以这在精神上和我之前做的几乎是一样的
So this is nearly identical in spirit to what I just did earlier

2219
01:51:01,290 --> 01:51:04,260
根据传递的每个单词创建一个理解列表
to create a list comprehension out of each of the words passed

2220
01:51:04,260 --> 01:51:05,290
我的喊叫功能 
to my yell function.

2221
01:51:05,290 --> 01:51:07,620
但在这里 我这样做是有条件的 
But here, I'm doing so conditionally.

2222
01:51:07,620 --> 01:51:10,350
因此 我从我们对循环的关注中汲取灵感 
And so, I'm borrowing inspiration from our focus on loops,

2223
01:51:10,350 --> 01:51:14,670
从我们对条件句的关注中得到一些启发 
borrowing some inspiration from our focus on conditionals,

2224
01:51:14,670 --> 01:51:18,310
将其合并到相同的方括号符号中 
combining that into this same square bracket notation.

2225
01:51:18,310 --> 01:51:23,340
因此 格兰芬多最终是零个或多个学生的名字 
So that what Gryffindors ultimately is, is zero or more students' names.

2226
01:51:23,340 --> 01:51:26,340
其中包含的名字就是结果
And the names that are included are the result

2227
01:51:26,340 --> 01:51:32,100
迭代这些学生中的每一个 并且只包括在最终结果中
of iterating over each of those students and only including in the final result

2228
01:51:32,100 --> 01:51:35,550
房子碰巧是格兰芬多的学生 
the students whose house happens to be Gryffindor.

2229
01:51:35,550 --> 01:51:38,730
因此 当我继续使用Gryffindors.py的Python运行这段代码时
So when I go ahead and run this with Python of Gryffindors.py

2230
01:51:38,730 --> 01:51:42,150
然后按回车键 你就会看到 嗯 这里实际上什么都没有发生 
and hit Enter, you'll see, huh, nothing actually happened here.

2231
01:51:42,150 --> 01:51:44,320
嗯 那是因为我没有完成节目 
Well, that's because I didn't finish the program.

2232
01:51:44,320 --> 01:51:46,737
让我继续 用这个来结束这个程序 
Let me go ahead and actually finish the program with this.

2233
01:51:46,737 --> 01:51:50,760
格兰芬多复数中的每一个格兰芬多--
How about for each Gryffindor in Gryffindors plural--

2234
01:51:50,760 --> 01:51:54,480
更好的是 所以我提前做了所有这些工作是明智的 
and better yet, so that it's sensible that I did all of this work in advance,

2235
01:51:54,480 --> 01:51:56,490
让我继续对所有这些名字进行分类
let me go ahead and sort all of those names

2236
01:51:56,490 --> 01:51:58,800
使用我们熟悉的排序函数 
with our familiar sorted function.

2237
01:51:58,800 --> 01:52:02,970
现在让我们继续打印这些格兰芬多的每一个 
Let's go ahead now and print out each of these Gryffindors.

2238
01:52:02,970 --> 01:52:06,107
所以现在 注意 如果熟悉书和电影 
So now, notice, if familiar with the books and the movies,

2239
01:52:06,107 --> 01:52:08,190
你会知道这四个学生中只有三个
you'll know that only three of these four students

2240
01:52:08,190 --> 01:52:09,360
实际上是在格兰芬多 
are actually in Gryffindor.

2241
01:52:09,360 --> 01:52:14,070
如果我运行Gryffindor.py的巨蟒 我们会看到哈利、赫敏和罗恩 
And if I run Python of Gryffindor.py, there we see Harry, Hermione, and Ron,

2242
01:52:14,070 --> 01:52:17,080
但现在也是按顺序排列的 
but now in sorted order as well.

2243
01:52:17,080 --> 01:52:20,760
所以这只是我们解决同样问题的一种方法 而不仅仅是使用列表
So that's just one way we can solve this same problem using not just a list

2244
01:52:20,760 --> 01:52:24,810
理解 而是一种列表理解 其中包含这个条件 
comprehension but a list comprehension that has this conditional therein.

2245
01:52:24,810 --> 01:52:27,690
但也有其他方法来解决这个同样的问题 
But there's yet other ways to solve this same problem too.

2246
01:52:27,690 --> 01:52:30,570
然后我们回到Python的一些功能特性上来 
And we come back to some functional features of Python.

2247
01:52:30,570 --> 01:52:32,640
除了地图等功能外 还有
In addition to functions like map, there's

2248
01:52:32,640 --> 01:52:36,100
还有这个叫做滤镜 可以用来达到同样的效果 
also this one called filter that can be used to achieve the same effect,

2249
01:52:36,100 --> 01:52:38,760
但如果你愿意的话 用一种更实用的方法 
but with a more functional approach, if you will.

2250
01:52:38,760 --> 01:52:40,530
让我回到这里的VS代码 
Let me go back to VS Code here.

2251
01:52:40,530 --> 01:52:43,440
在相同的例子中 让我这样做 
And with the same example, let me do this.

2252
01:52:43,440 --> 01:52:47,550
让我像以前一样留下上面的原始名单 包括德拉科 
Let me leave the original list of above as before, including Draco,

2253
01:52:47,550 --> 01:52:49,530
他其实不是格兰芬多人 
who's not in fact from Gryffindor.

2254
01:52:49,530 --> 01:52:51,960
让我暂时定义一个名为
And let me temporarily define a function called

2255
01:52:51,960 --> 01:52:57,420
格兰芬多 它接受了某种价值 就像学生S 
is Gryffindor that takes in as a value something like a student S.

2256
01:52:57,420 --> 01:52:59,200
然后 让我们开始吧 
And then, let's do this.

2257
01:52:59,200 --> 01:53:04,920
让我们继续说 如果S引用的房子等于格兰芬多 
Let's go ahead and say if s quote unquote house equals equals Gryffindor,

2258
01:53:04,920 --> 01:53:08,530
然后继续前进 返回True 
then go ahead and return true.

2259
01:53:08,530 --> 01:53:12,525
否则 继续并返回FALSE 
Otherwise, go ahead and return false.

2260
01:53:12,525 --> 01:53:14,400
现在 我们以前见过像这样的条件句
Now, we've seen before conditionals like this

2261
01:53:14,400 --> 01:53:16,530
这些都是不必要的冗长 
that are a bit unnecessarily verbose.

2262
01:53:16,530 --> 01:53:18,930
我不需要有条件 如果我已经
I don't need to have a conditional if I'm already

2263
01:53:18,930 --> 01:53:21,400
在这里问一个布尔问题 
asking a Boolean question up here.

2264
01:53:21,400 --> 01:53:24,000
所以我实际上可以像我们过去做的那样收紧它
So I can actually tighten this up as we've done in the past

2265
01:53:24,000 --> 01:53:28,170
那么 学生的房子等于格兰芬多吗？
and just return does the student's house equal equal Gryffindor?

2266
01:53:28,170 --> 01:53:30,930
要么它是真的 要么不是 它是假的 
Either it does and it's true, or it doesn't in it's false.

2267
01:53:30,930 --> 01:53:33,150
我不需要显式返回True或False 
I don't need to explicitly return true or false.

2268
01:53:33,150 --> 01:53:36,570
我可以只返回那个布尔值 
I can just return the value of that Boolean.

2269
01:53:36,570 --> 01:53:38,350
让我们现在就去做这件事 
Let's go ahead now and do this.

2270
01:53:38,350 --> 01:53:40,140
和前面一样 我将创建一个变量
I'm going to create, as before, a variable

2271
01:53:40,140 --> 01:53:43,620
格兰芬多 这是我所有格兰芬多学生的名单
called Gryffindors, a list for all of my Gryffindor students

2272
01:53:43,620 --> 01:53:47,430
这一次等于调用Filter的结果 
that equals to, this time, the result of calling filter.

2273
01:53:47,430 --> 01:53:50,050
筛选器在这里至少接受两个参数 
Filter takes at least two arguments here,

2274
01:53:50,050 --> 01:53:54,830
其中之一是要调用的函数的名称是Gryffindor 
one of which is the name of a function to call is Gryffindor.

2275
01:53:54,830 --> 01:53:59,090
我将把这个函数应用到这个序列的每个元素上
And I'm going to apply that function to each of the elements of this sequence

2276
01:53:59,090 --> 01:53:59,820
这里 
here.

2277
01:53:59,820 --> 01:54:03,920
在本质上与地图如此相似 我传入了一个函数
So similar in spirit to map, I'm passing in a function

2278
01:54:03,920 --> 01:54:07,370
这将应用于序列中的每个元素 
that's going to be applied to each of the elements in the sequence.

2279
01:54:07,370 --> 01:54:11,070
但是map为序列中的每个元素返回一个值 
But map returns one value for each element in the sequence.

2280
01:54:11,070 --> 01:54:13,520
这就是我们强制所有单词都大写的方式 
That's how we forced all of the words to uppercase.

2281
01:54:13,520 --> 01:54:19,520
但如果我想有条件地把一个学生包括在我的结果格兰芬多
But if I want to conditionally include a student in my resulting Gryffindors

2282
01:54:19,520 --> 01:54:21,920
列表中 我可以改用过滤器 
list, I can use filter instead.

2283
01:54:21,920 --> 01:54:25,970
Filter期望它的第一个函数不是类似于str.upper的函数 
Filter expects its first function to be not something like str.upper,

2284
01:54:25,970 --> 01:54:28,340
而是返回True或False的函数 
but a function that returns true or false.

2285
01:54:28,340 --> 01:54:33,800
告诉我是否应该包括当前的学生
Tell me whether or not I should include or not include the current student

2286
01:54:33,800 --> 01:54:35,150
从最终名单中选出 
from the final list.

2287
01:54:35,150 --> 01:54:37,970
问题是 他们住在格兰芬多吗？
And the question being asked is, do they live in Gryffindor?

2288
01:54:37,970 --> 01:54:41,550
我们正在查字典里的房门钥匙 寻找答案 
We're checking the dictionary's house key for that answer.

2289
01:54:41,550 --> 01:54:45,410
因此 最终 我认为我们会得到非常相似的东西 
And so, ultimately, I think we'll be left with something quite similar.

2290
01:54:45,410 --> 01:54:52,040
对于排序版本中的格兰芬多--我们来看看格兰芬多中的格兰芬多 
For Gryffindor in the sorted version-- let's do for Gryffindor in Gryffindors,

2291
01:54:52,040 --> 01:54:56,150
那么让我们继续打印出现在的学生 格兰芬多的名字 
let's go ahead then and print out the current students, Gryffindor name.

2292
01:54:56,150 --> 01:54:58,010
它现在还不会被解决 
It's not going to be sorted just yet.

2293
01:54:58,010 --> 01:55:01,910
但是当我在这里运行这个版本的Python的Gryffindors.py并点击Enter时 
But when I run this version here Python of Gryffindors.py and hit Enter,

2294
01:55:01,910 --> 01:55:03,120
我们又可以继续做生意了
we're back in business.

2295
01:55:03,120 --> 01:55:03,800
还没分类
It's unsorted.

2296
01:55:03,800 --> 01:55:07,100
但我们有赫敏、哈利和罗恩 但没有德拉科 
But we have Hermione, Harry, and Ron, but not Draco.

2297
01:55:07,100 --> 01:55:09,380
如果你回想一下几周前 如果我们
And if you recall from a few weeks back, if we

2298
01:55:09,380 --> 01:55:13,190
如果你想要一个字典列表 我们也可以这样做 
want to even a list of dictionaries, we can still do that too.

2299
01:55:13,190 --> 01:55:16,790
我可以把格兰芬多称为复数 
I can call sorted on Gryffindors plural.

2300
01:55:16,790 --> 01:55:18,500
我可以传递一个密钥 
And I can pass in a key.

2301
01:55:18,500 --> 01:55:21,710
这个密钥可以有一个匿名函数 也就是 
And that key can have a anonymous function, a.k.a.

2302
01:55:21,710 --> 01:55:24,350
一个Lambda函数 它接受一个学生作为输入 
A Lambda function, that takes in a student as input,

2303
01:55:24,350 --> 01:55:29,750
调用它 然后返回值的引号名称 如果我的目标是
call it s, and then returns the value s quote unquote name, if my goal is

2304
01:55:29,750 --> 01:55:33,410
根据学生自己的名字进行排序
to sort by, indeed, students own names.

2305
01:55:33,410 --> 01:55:36,080
如果我继续运行Gryffindors.py的Python 
If I go ahead now and run Python of Gryffindors.py,

2306
01:55:36,080 --> 01:55:37,850
我看到了同样的学生名单 
I see the same list of students.

2307
01:55:37,850 --> 01:55:39,860
但这一次 它的排序 
But this time, it's sorted.

2308
01:55:39,860 --> 01:55:42,890
我们看到了两种解决这个问题的方法
So here we've seen two approaches to this particular problem

2309
01:55:42,890 --> 01:55:43,850
格兰芬多的学生
of Gryffindor students.

2310
01:55:43,850 --> 01:55:47,090
因此我们可以使用类似列表理解的东西 
Whereby we can either use something like a list comprehension,

2311
01:55:47,090 --> 01:55:50,360
在这个列表理解中做一些过滤 
and inside of that list comprehension do a bit of filtration,

2312
01:55:50,360 --> 01:55:53,480
包括一个if条件句
including an if conditional as I did.

2313
01:55:53,480 --> 01:55:55,940
或者我们可以采取更实用的方法
Or we can take a more functional approach

2314
01:55:55,940 --> 01:56:00,410
只需要使用这个过滤器函数 
by just using this filter function, passing into it the function

2315
01:56:00,410 --> 01:56:02,700
我想为自己做这些决定
that I want to make these decisions for me,

2316
01:56:02,700 --> 01:56:07,160
然后只包括那些返回true的人 
and then include only those for whom true is returned.

2317
01:56:07,160 --> 01:56:10,297
对这两种方法有什么问题吗？
Any questions on either of these two approaches?

2318
01:56:10,297 --> 01:56:10,880
是的 
STUDENT: Yeah.

2319
01:56:10,880 --> 01:56:14,090
我只是有个问题如果我们写一个代码
I just had a question, that if we write a code

2320
01:56:14,090 --> 01:56:17,090
就像在以前的版本中 所有内容都被塞进一行 
like in the previous version, where everything is stuffed into one line,

2321
01:56:17,090 --> 01:56:18,050
不会--
won't the--

2322
01:56:18,050 --> 01:56:24,770
如果我们检查代码的样式 那么它不会有问题吗？
if we check for the style of the code, then won't it have a problem with it

2323
01:56:24,770 --> 01:56:26,210
因为它的可读性更低
because it's less readable?

2324
01:56:26,210 --> 01:56:28,400
DAVID J. MALAN：像black这样的格式化程序也是如此
DAVID J. MALAN: So would a formatter like black

2325
01:56:28,400 --> 01:56:30,680
对这段代码的风格有问题吗
have a problem with the style of some of this code?

2326
01:56:30,680 --> 01:56:33,800
上一个 所有的东西都塞在一条线上 
STUDENT: The previous one, where the everything was tucked into one line.

2327
01:56:33,800 --> 01:56:34,190
[插话的声音]
[INTERPOSING VOICES]

2328
01:56:34,190 --> 01:56:35,690
大卫·J·马兰：哦 一个好问题 
DAVID J. MALAN: Oh, a good question.

2329
01:56:35,690 --> 01:56:38,610
像布莱克这样的人会对这段代码有意见吗？
Would something like Black have a problem with this code?

2330
01:56:38,610 --> 01:56:40,460
好吧 让我回到那个版本 
Well, let me rewind to that version, which

2331
01:56:40,460 --> 01:56:45,170
使用了更长的列表理解 
was using the somewhat longer list comprehension, which

2332
01:56:45,170 --> 01:56:50,160
看起来像是 如果我们回到足够远的地方 再给我几个解锁 
looked like, if we go far enough back, give me a few more undoes,

2333
01:56:50,160 --> 01:56:52,350
它最终看起来是这样的 
which looked like this ultimately.

2334
01:56:52,350 --> 01:56:55,500
让我继续在Gryffindors.py上运行Black 
Let me go ahead and run Black on Gryffindors.py.

2335
01:56:55,500 --> 01:56:59,170
你会看到我实际上--它稍微重新格式化了一下 
And you'll see that I actually-- it reformatted ever so slightly.

2336
01:56:59,170 --> 01:57:01,230
但我自己会主动解决这个问题 
But I proactively fix this myself.

2337
01:57:01,230 --> 01:57:03,720
如果我这么做了 而且只用了一行 
Had I done this and done it on just one line,

2338
01:57:03,720 --> 01:57:07,140
但我知道布莱克可能不喜欢这样 它会为我解决这个问题的 
but I knew that Black might not like that, it would have fixed it for me.

2339
01:57:07,140 --> 01:57:10,740
因此 我只是在自己编写代码之前主动修复了它 
So I just proactively fixed it before writing the code myself.

2340
01:57:10,740 --> 01:57:14,730
关于Gryffindors.py上的另一个问题怎么样？
How about time for one other question on Gryffindors.py

2341
01:57:14,730 --> 01:57:17,640
那么这种使用列表理解或过滤的方法呢？
and this approach of using a list comprehension or filter?

2342
01:57:17,640 --> 01:57:19,440
学生：是的 
STUDENT: Yeah.

2343
01:57:19,440 --> 01:57:24,360
使用Filter时 不是调用Gryffindor函数 
When using filter, instead of calling the function is Gryffindor,

2344
01:57:24,360 --> 01:57:29,328
你能把它放在滤镜里面吗？
can you use it right there inside filter?

2345
01:57:29,328 --> 01:57:31,620
大卫·J·马兰：你能用格兰芬多的功能吗？
DAVID J. MALAN: Can you use the function is Gryffindor?

2346
01:57:31,620 --> 01:57:33,685
所以你不会想这样称呼它的 
So you don't want to call it like this.

2347
01:57:33,685 --> 01:57:35,310
因为你不会想要这样做的 
Because you don't want to call it then.

2348
01:57:35,310 --> 01:57:39,180
您希望Filter为您调用函数 如果您是这个意思的话 
You want filter to call the function for you, if that's what you mean.

2349
01:57:39,180 --> 01:57:43,740
所以我只用它的名字来传递它 
So I pass it in only by its name instead.

2350
01:57:43,740 --> 01:57:50,040
学生：不 我的意思是 如果你能把报税表写成房子等于
STUDENT: No, I mean, if you can write the return as house equals

2351
01:57:50,040 --> 01:57:51,900
等于格兰芬多内线[INAUDIBLE] 
equals Gryffindor inside [INAUDIBLE].

2352
01:57:51,900 --> 01:57:53,520
大卫·J·马兰：是的 确实如此 
DAVID J. MALAN: Yes, indeed.

2353
01:57:53,520 --> 01:57:57,330
事实上 回想一下 我们以前确实使用过这些Lambda函数
In fact, so recall that we indeed used these Lambda functions way back

2354
01:57:57,330 --> 01:58:01,020
当我们想匿名传递一个又快又脏的函数时
when we wanted to pass in a quick and dirty function anonymously

2355
01:58:01,020 --> 01:58:05,040
以允许按词典的不同键进行筛选 
to allow sorted to filter by a different key of a dictionary.

2356
01:58:05,040 --> 01:58:06,490
我们可以在这里这样做 
We can do that here.

2357
01:58:06,490 --> 01:58:10,140
我实际上可以把它的本质理解为格兰芬多函数 
I can actually take the essence of this is Gryffindor function.

2358
01:58:10,140 --> 01:58:13,050
我可以在筛选器调用中更改此函数的名称
I can change the name of this function in my filter call

2359
01:58:13,050 --> 01:58:17,190
作为另一个Lambda函数 像S一样传入参数 
to be another Lambda function, passing in an argument like s,

2360
01:58:17,190 --> 01:58:19,560
就是这么回事 
and returning exactly that.

2361
01:58:19,560 --> 01:58:23,040
我现在可以一起删除我的is Gryffindor函数 
I can now delete my is Gryffindor function all together.

2362
01:58:23,040 --> 01:58:26,400
现在 当我运行Gryffindors.py的Python时 
And now, when I run Python of Gryffindors.py,

2363
01:58:26,400 --> 01:58:28,030
我还是得到了同样的答案 
I still get the same answer.

2364
01:58:28,030 --> 01:58:31,440
我并没有费心定义一个函数 只是为了使用它
And I've not bothered defining a function only to then use it

2365
01:58:31,440 --> 01:58:34,560
在一个且只有一个地方 
in one and only one place.

2366
01:58:34,560 --> 01:58:36,840
好吧 让我也提议我们给你装备
Well, let me propose too that we equip you

2367
01:58:36,840 --> 01:58:40,290
使用另一个工具包工具 即词典
with one other tool for your toolkit, namely dictionary

2368
01:58:40,290 --> 01:58:41,880
理解也是如此 
comprehensions as well.

2369
01:58:41,880 --> 01:58:45,210
诚然 语法开始变得更加奇怪 
And admittedly, the syntax is starting to get even weirder.

2370
01:58:45,210 --> 01:58:48,330
但随着你对所有这些基本类型和其他类型越来越熟悉 
But as you get more comfortable with all of these primitives and others,

2371
01:58:48,330 --> 01:58:51,900
这些只是您可以选择使用的工具 但也可能是强有力的工具
these are just tools that you can optionally but perhaps powerfully use

2372
01:58:51,900 --> 01:58:53,980
来解决未来的问题 
to solve future problems down the road.

2373
01:58:53,980 --> 01:58:58,230
有了词典的理解 我们就有能力在飞行中创造
And with a dictionary comprehension, we have the ability to create on the fly

2374
01:58:58,230 --> 01:59:01,200
有键和一些值的词典 但没有
a dictionary with keys and some values without having

2375
01:59:01,200 --> 01:59:05,580
要做到这一点 需要创建一个空词典 并创建一个for循环 
to do it old-school by creating an empty dictionary, and creating a for loop,

2376
01:59:05,580 --> 01:59:08,730
遍历该循环 并插入越来越多的键
and iterating over that loop, and inserting more and more keys

2377
01:59:08,730 --> 01:59:10,170
和值输入到字典中 
and values into the dictionary.

2378
01:59:10,170 --> 01:59:12,400
我们宁可一次做完这一切 
We can rather do it all at once.

2379
01:59:12,400 --> 01:59:14,640
所以事实上 让我回到VS代码这里 
So in fact, let me go back to VS Code here.

2380
01:59:14,640 --> 01:59:17,770
现在让我向你求婚 我要这么做 
And let me propose now that I do this.

2381
01:59:17,770 --> 01:59:23,070
让我继续 在这里以老式的方式开始 如下所示 
Let me go ahead and initially do it the old-fashioned way here as follows.

2382
01:59:23,070 --> 01:59:25,320
让我继续 简化并处理掉这些房子
Let me go ahead and simplify and get rid of the houses

2383
01:59:25,320 --> 01:59:30,060
这样我们现在就可以把注意力集中在学生名单上了 
all together so that we can focus for now just on a list of students' names.

2384
01:59:30,060 --> 01:59:32,620
我将继续运行学生 
I'm going to go ahead and run students.

2385
01:59:32,620 --> 01:59:37,200
我将继续写学生等于引用 赫敏 引用
I'm going to go ahead and write students equals quote unquote Hermione, quote

2386
01:59:37,200 --> 01:59:39,600
引用哈里的话 这一次我们会把它缩短 
unquote Harry, and we'll keep it even shorter this time,

2387
01:59:39,600 --> 01:59:42,480
引用罗恩的话 只有格兰芬多的那三个学生 
quote unquote Ron, only those three students in Gryffindor.

2388
01:59:42,480 --> 01:59:44,790
我现在要像过去一样积极主动地
I'm going to now proactively as we've done in the past

2389
01:59:44,790 --> 01:59:47,910
给自己开一张空单 这样我就有东西可以积累了
give myself an empty list, so that I have something to accumulate

2390
01:59:47,910 --> 01:59:49,905
中提供了这个问题的一些答案 
some answers to this problem in.

2391
01:59:49,905 --> 01:59:51,780
现在 我要做这样的事情 
And now, I'm going to do something like this.

2392
01:59:51,780 --> 01:59:55,450
对于学生和学生 所以我可以迭代他们每一个人 
For students and students, so I can iterate over each of them,

2393
01:59:55,450 --> 01:59:57,960
让我们继续 看看格兰芬多的名单
Let's go ahead and with the Gryffindors list

2394
01:59:57,960 --> 02:00:01,950
在它后面加上学生的名字 
append to it the name of the student.

2395
02:00:01,950 --> 02:00:04,260
所以引用不带引号的名字 然后是学生 这
So quote unquote name and then student, which

2396
02:00:04,260 --> 02:00:05,820
确实是他们在名单上的名字 
is indeed their name from that list.

2397
02:00:05,820 --> 02:00:09,003
现在 让我们继续 把这些学生都放在格兰芬多 
And now, let's go ahead and just put these students all in Gryffindor.

2398
02:00:09,003 --> 02:00:10,920
我知道这三个学生在格兰芬多 
I know these three students are in Gryffindor.

2399
02:00:10,920 --> 02:00:13,260
所以假设手头的问题是我
So suppose that the problem at hand is that I

2400
02:00:13,260 --> 02:00:18,190
我想建立一个只包含格兰芬多的词典列表
want to build up a list of dictionaries that only contains the Gryffindor

2401
02:00:18,190 --> 02:00:18,690
学生们 
students.

2402
02:00:18,690 --> 02:00:20,970
因此 它在某种程度上是对以前版本的一种倒退
So it's sort of a step back from the previous version

2403
02:00:20,970 --> 02:00:23,430
在那里我已经有了名字和房子 
where I already had the names and the houses.

2404
02:00:23,430 --> 02:00:26,640
现在 假设问题是我知道他们所有人的名字 
For now, just assume that the problem is I have all of their names,

2405
02:00:26,640 --> 02:00:29,550
但我还没有学生词典本身 
but I don't yet have the student dictionaries themselves.

2406
02:00:29,550 --> 02:00:34,380
因此 我正在重建我之前认为理所当然的同一结构 
So I'm rebuilding that same structure that I previously took for granted.

2407
02:00:34,380 --> 02:00:37,200
现在 让我们继续 只是为了讨论
Now, let's go ahead and just for the sake of discussion just

2408
02:00:37,200 --> 02:00:40,300
把这些格兰芬多打印出来 这样我们就能看到我们建造了什么 
print out these Gryffindors so we can see what we've built.

2409
02:00:40,300 --> 02:00:43,080
如果我在提示符中运行Gryffindors.py的Python 
If I run Python of Gryffindors.py in my prompt,

2410
02:00:43,080 --> 02:00:45,270
我看到了一些隐晦的语法 
I see a bit of a cryptic syntax.

2411
02:00:45,270 --> 02:00:47,640
但是 再说一次 寻找我们的小提示 
But again, look for our little hints.

2412
02:00:47,640 --> 02:00:51,120
我在末尾有一个方括号 在开头有一个方括号 
I've got a square bracket at the end and a square bracket at the beginning.

2413
02:00:51,120 --> 02:00:53,760
这表明 一如既往 这是一份名单 
And that indicates, as always, this is a list.

2414
02:00:53,760 --> 02:00:56,520
然后我就有了一大堆花括号
I then have a whole bunch of curly braces

2415
02:00:56,520 --> 02:00:58,740
有一大堆被引用的钥匙 
with a whole bunch of quoted keys.

2416
02:00:58,740 --> 02:01:00,630
按照惯例 它们碰巧是单引号 
They happen to be single quotes by convention

2417
02:01:00,630 --> 02:01:02,910
在词典上使用打印时 
when using print on a dictionary.

2418
02:01:02,910 --> 02:01:06,000
但这只是一个视觉指标 表明这是我的关键 
But that's just a visual indicator that that is my key.

2419
02:01:06,000 --> 02:01:08,190
第一个值是赫敏 
And the first value thereof is Hermione.

2420
02:01:08,190 --> 02:01:09,660
第二把钥匙是房子 
Second key is a house.

2421
02:01:09,660 --> 02:01:11,460
这个值就是格兰芬多 
This value thereof is Gryffindor.

2422
02:01:11,460 --> 02:01:15,420
然后是逗号 它将一个DICT对象与下一个DICT对象隔开 
Then there's a comma, which separates one dict object from the next.

2423
02:01:15,420 --> 02:01:17,370
如果我们抛开哈利和格兰芬多 
And if we look past Harry and Gryffindor,

2424
02:01:17,370 --> 02:01:21,450
哈利和格兰芬多和罗恩之间还有第二个逗号
there's a second comma which separates Harry and Gryffindor from Ron

2425
02:01:21,450 --> 02:01:22,540
格兰芬多也是 
and Gryffindor as well.

2426
02:01:22,540 --> 02:01:26,280
因此 简而言之 以下是一些代码 通过这些代码我可以相当手动地
So in short, here is some code whereby I fairly manually

2427
02:01:26,280 --> 02:01:30,330
在原本为空的列表中使用for循环构建
built up with a for loop in an otherwise initially empty list

2428
02:01:30,330 --> 02:01:35,910
与之前相同的数据结构 只是为格兰芬多学生减去了Draco 
the same data structure as before minus Draco just for Gryffindor students.

2429
02:01:35,910 --> 02:01:39,060
但这也是词典释义的地方
But here's where, again, with dictionary comprehensions

2430
02:01:39,060 --> 02:01:43,290
或者真的先列出理解 我们可以更简洁地做这件事吗？
or really list comprehensions first, can we do this a little more succinctly?

2431
02:01:43,290 --> 02:01:45,270
让我清除我的终端窗口 
Let me clear my terminal window.

2432
02:01:45,270 --> 02:01:49,720
让我们去掉这个最初为空的列表和这个for循环
Let's get rid of this initially empty list and this for loop

2433
02:01:49,720 --> 02:01:51,460
添加 添加 添加到它上面 
that appends, appends, appends to it.

2434
02:01:51,460 --> 02:01:52,960
我们就这么做吧 
And let's just do this.

2435
02:01:52,960 --> 02:01:58,120
Gryffindors变量将等于下面的列表理解 
A Gryffindors variable will equal the following list comprehension.

2436
02:01:58,120 --> 02:02:01,660
在这个列表里 我想要一本结构化的词典
Inside of that list, I want a dictionary structured

2437
02:02:01,660 --> 02:02:04,180
写着某人的名字和他们的名字 
with someone's name and their name.

2438
02:02:04,180 --> 02:02:07,420
某个人的房子 只是现在 格兰芬多 
Someone's house and only for now Gryffindor.

2439
02:02:07,420 --> 02:02:08,380
就是这样 
And that's it.

2440
02:02:08,380 --> 02:02:13,870
但我想要这些花括号里的一个Dict对象
But I want one of these dict objects here in these curly braces

2441
02:02:13,870 --> 02:02:18,110
对于每一个学生来说 在学生中 
for each student in students.

2442
02:02:18,110 --> 02:02:23,230
所以这里也是 在我用方括号列出的理解中 
So here too, inside of my list comprehension with my square brackets,

2443
02:02:23,230 --> 02:02:25,960
我想要一个标明的物体--
I want an object as indicate--

2444
02:02:25,960 --> 02:02:29,290
我想要一本花括号标明的词典 
I want a dictionary as indicated by the curly braces.

2445
02:02:29,290 --> 02:02:32,440
我希望每本词典都有两把钥匙--
I want each of those dictionaries to have two keys--

2446
02:02:32,440 --> 02:02:35,560
姓名和房屋 其值
name and house respectively, the values thereof

2447
02:02:35,560 --> 02:02:40,060
是学生的名字 这里只有Gryffindor 
are the student's name from earlier here and Gryffindor only.

2448
02:02:40,060 --> 02:02:43,300
我想从哪些学生那里创建这些词典对象？
Which students do I want to create those dict objects from?

2449
02:02:43,300 --> 02:02:45,230
嗯 对于学生中的学生来说 
Well, for student in students.

2450
02:02:45,230 --> 02:02:48,010
所以 再一次 在左边 我在最终列表中得到了我想要的东西 
So again, on the left I have what I want in the final list.

2451
02:02:48,010 --> 02:02:50,740
在右边 我有一个循环 这一次 是无条件的 
And on the right, I have a loop, and this time, no conditional.

2452
02:02:50,740 --> 02:02:54,140
我想把格兰芬多的这些学生都当作他们的家 
I want all of these students in Gryffindor as their house.

2453
02:02:54,140 --> 02:02:58,330
现在 让我们再次打印这段代码 即Python of Gryffindors.py并按Enter键 
Now, let's print this again, Python of Gryffindors.py and hit Enter.

2454
02:02:58,330 --> 02:03:00,950
现在 我们有了完全相同的产量 
And now, we have the exact same output.

2455
02:03:00,950 --> 02:03:03,520
所以不是三行 而是一行 
So instead of three lines it's just one.

2456
02:03:03,520 --> 02:03:06,520
乍一看 这本书有点神秘 
It's a little more cryptic to read at first glance.

2457
02:03:06,520 --> 02:03:09,520
但一旦熟悉了列表理解和这类语法 
But once familiar with list comprehensions and this sort of syntax,

2458
02:03:09,520 --> 02:03:12,560
这只是解决同样问题的另一种方式 
it's just another way of solving that same problem.

2459
02:03:12,560 --> 02:03:14,560
如果我想要改变这一点并简化该怎么办？
What if I want to change this and simplify?

2460
02:03:14,560 --> 02:03:18,100
如果我不想要我现在有的词典列表 那该怎么办？
What if I don't want a list of dictionaries, which I now have.

2461
02:03:18,100 --> 02:03:22,480
同样 根据方括号 我这里有一个包含三个DICT对象的列表 
Again, per the square brackets I have a list of three dict objects here.

2462
02:03:22,480 --> 02:03:25,660
如果我只想要一本更大的词典呢？
What if I just want one bigger dictionary

2463
02:03:25,660 --> 02:03:31,330
里面是一把钥匙 像赫敏冒号格兰芬多 哈里冒号
inside of which is a key like Hermione colon Gryffindor, Harry colon

2464
02:03:31,330 --> 02:03:33,670
格兰芬多 罗恩·科隆·格兰芬多 
Gryffindor, Ron colon Gryffindor.

2465
02:03:33,670 --> 02:03:34,600
我不需要名单 
I don't need a list.

2466
02:03:34,600 --> 02:03:36,430
我不需要每个学生单独使用物品 
I don't need separate objects per student.

2467
02:03:36,430 --> 02:03:40,060
我只想要一本大词典
I just want instead one big dictionary where

2468
02:03:40,060 --> 02:03:42,850
钥匙是学生的名字和他们房子的价值 
the keys are the students' names and the values of their house.

2469
02:03:42,850 --> 02:03:45,010
我想现在没有人会有
And I'm assuming for now no one's going to have

2470
02:03:45,010 --> 02:03:47,590
在这个世界上有一个相同的名字 
the same first name in this world.

2471
02:03:47,590 --> 02:03:49,280
好吧 我能做到的 
Well, I can do this.

2472
02:03:49,280 --> 02:03:53,680
让我在这里摆脱这一点 不是创建一个列表理解 但再次 
Let me get rid of this here and not create a list comprehension, but again,

2473
02:03:53,680 --> 02:03:56,230
这就是所谓的词典理解 
this thing known as a dictionary comprehension.

2474
02:03:56,230 --> 02:03:58,450
这里的视觉指示或差异
And the visual indicator or difference here

2475
02:03:58,450 --> 02:04:02,650
这一次 我们不再把它放在方括号里 
is that instead of being square brackets on the very outside, this time

2476
02:04:02,650 --> 02:04:04,820
它会变成花括号 
it's going to be curly braces instead.

2477
02:04:04,820 --> 02:04:08,770
在这些花括号里 我希望每个键都是什么？
So inside of these curly braces, what do I want every key to be?

2478
02:04:08,770 --> 02:04:11,170
我希望每个键都是学生的名字 
I want every key to be the student's name.

2479
02:04:11,170 --> 02:04:14,170
我希望现在所有的价值都是格兰芬多的 
I want every value for now to be Gryffindor.

2480
02:04:14,170 --> 02:04:17,980
我想为每一个学生做这些 
And I want to do this for each student in students.

2481
02:04:17,980 --> 02:04:20,470
现在 事情变得非常有趣 
And now, things are getting really interesting.

2482
02:04:20,470 --> 02:04:23,890
这是Python的另一种表现形式 
And this is another manifestation of Python in some views being

2483
02:04:23,890 --> 02:04:25,750
从左到右都很清晰 
very readable from left to right.

2484
02:04:25,750 --> 02:04:28,240
绝对需要练习和舒适 
Absolutely takes practice and comfort.

2485
02:04:28,240 --> 02:04:31,180
但这是在创造一个名为格兰芬多的变量
But this is creating a variable called Gryffindor

2486
02:04:31,180 --> 02:04:34,660
这是一个字典 每个花括号都有一个 
which is going to be a dictionary per these curly braces.

2487
02:04:34,660 --> 02:04:37,570
每个键都是某个学生的名字 
Every key is going to be the name of some student.

2488
02:04:37,570 --> 02:04:39,400
每个值都将是格兰芬多 
Every value is going to be Gryffindor.

2489
02:04:39,400 --> 02:04:40,930
什么学生的名字？
What names of what students?

2490
02:04:40,930 --> 02:04:43,930
好吧 这本字典的理解将是
Well, this dictionary comprehension will be

2491
02:04:43,930 --> 02:04:48,740
从学生名单中一次一个地构建 
constructed from the list of students one at a time.

2492
02:04:48,740 --> 02:04:51,490
所以当我现在打印这个的时候 语法看起来会有点不同
So when I print this now, the syntax will look a little different

2493
02:04:51,490 --> 02:04:53,770
因为它不是字典对象的列表 
because it's not a list of dictionary objects.

2494
02:04:53,770 --> 02:04:56,630
它本身只是一个更大的字典对象 
It's just one bigger dictionary object itself.

2495
02:04:56,630 --> 02:05:01,030
但现在打印格兰芬多的人给了我赫敏·科隆格兰芬多 哈利·科隆
But now printing Gryffindors gives me Hermione colon Gryffindor, Harry colon

2496
02:05:01,030 --> 02:05:05,560
格兰芬多 还有罗恩·科隆·格兰芬多 
Gryffindor, and Ron colon Gryffindor as well.

2497
02:05:05,560 --> 02:05:10,755
对于我们所说的字典解析 还有什么问题吗？
Any questions now on what we've called dictionary comprehensions as well?

2498
02:05:14,690 --> 02:05:15,955
有什么问题吗？
Any questions on here?

2499
02:05:18,670 --> 02:05:19,170
没有吗？
No?

2500
02:05:19,170 --> 02:05:23,070
好吧 让我们从Python的工具箱中介绍另一个函数 
Well, let's introduce one other function from Python's toolkit followed

2501
02:05:23,070 --> 02:05:25,770
最后一个特点和繁荣 
by one final feature and flourish.

2502
02:05:25,770 --> 02:05:27,630
然后你就可以走了
And then you're off on your way.

2503
02:05:27,630 --> 02:05:30,720
好吧 让我们继续回想一下 
Well, let's go ahead and think back to this.

2504
02:05:30,720 --> 02:05:34,860
回想一下 我们之前有一个简单的学生名单 
Recall some time ago that we had just a simple list of students

2505
02:05:34,860 --> 02:05:37,290
就像我们这里的赫敏哈利和罗恩
as we have here, Hermione, Harry, and Ron.

2506
02:05:37,290 --> 02:05:40,770
举个例子 很久以前 我们想要打印出来 
And for instance, way back when, we wanted to print out,

2507
02:05:40,770 --> 02:05:44,160
比如说排名从一 二 三 
for instance, their ranking from one, to two, to three.

2508
02:05:44,160 --> 02:05:48,000
不幸的是 当你为学生中的学生做这样的事情时 
Unfortunately, when you do something like this for student in students,

2509
02:05:48,000 --> 02:05:50,700
你可以很容易地打印出学生的名字 
you can print out the student's name quite easily.

2510
02:05:50,700 --> 02:05:53,220
当然 如果我使用Python的Gryffindors.py 
Of course, if I do Python of Gryffindors.py,

2511
02:05:53,220 --> 02:05:56,010
我把赫敏、哈里、罗恩按同样的顺序排列 
I get Hermione, Harry, Ron in that same order.

2512
02:05:56,010 --> 02:05:58,020
但我看不到任何数字排名 
But I don't see any numerical rank.

2513
02:05:58,020 --> 02:06:00,300
我看不到一号、二号或三号 
I see no number one, two, or three.

2514
02:06:00,300 --> 02:06:04,980
所以我也许可以用一种不同类型的for循环来做这件事 
So I could maybe do this with maybe a different type of for loop.

2515
02:06:04,980 --> 02:06:06,870
与其这样 不如我试试这个吧？
Instead of this, why don't I try this?

2516
02:06:06,870 --> 02:06:13,770
所以也许我可以在学生名单的长度范围内--
So maybe I could do for i in the range of the length of the students list--

2517
02:06:13,770 --> 02:06:15,670
我们以前也做过类似的事情 
and we've done something like this before.

2518
02:06:15,670 --> 02:06:19,320
然后我可以打印出我 我可以打印出学生的名字
And then I could print out i, and I could print out the student's name

2519
02:06:19,320 --> 02:06:22,528
通过在位置i处索引到该列表 
by indexing into that list at location i.

2520
02:06:22,528 --> 02:06:23,820
好吧 这看起来像什么？
Well, what does this look like?

2521
02:06:23,820 --> 02:06:27,180
如果我运行Gryffindors.py的Python 它就很接近了 
If I run Python of Gryffindors.py it's close.

2522
02:06:27,180 --> 02:06:29,130
但这些人不是程序员 
But these aren't programmers.

2523
02:06:29,130 --> 02:06:31,950
他们不一定认为自己是零指数 
They don't necessarily think of themselves as zero-indexed.

2524
02:06:31,950 --> 02:06:34,320
赫敏 他可能想成为第一个 而不是零 
Hermione he probably wants to be first not zero.

2525
02:06:34,320 --> 02:06:35,290
那么我们怎么才能解决这个问题呢？
So how can we fix this?

2526
02:06:35,290 --> 02:06:35,790
井 
Well.

2527
02:06:35,790 --> 02:06:37,260
只是一点算术 
Just a little bit of arithmetic.

2528
02:06:37,260 --> 02:06:40,897
当然 我可以打印出来 再加上一个 然后是学生的名字 
I could print out i plus one, of course, and then the student's name.

2529
02:06:40,897 --> 02:06:43,980
因此 如果我清除我的终端窗口并运行Gryffindors.py门禁的Python
So if I clear my terminal window and run Python of Gryffindors.py doorstop

2530
02:06:43,980 --> 02:06:47,760
再一次 现在我们有了这个枚举 一 二 
once more, now we have this enumeration, one, two,

2531
02:06:47,760 --> 02:06:49,470
这些学生每人三个 
three of each of these students.

2532
02:06:49,470 --> 02:06:51,540
但事实证明 Python实际上有
But it turns out that Python actually has

2533
02:06:51,540 --> 02:06:53,610
一直以来我都有另一个内置功能
had all this time another built-in function

2534
02:06:53,610 --> 02:06:55,230
你现在可能会觉得有用 
that you might now find useful.

2535
02:06:55,230 --> 02:06:57,210
那就是列举 
That is namely enumerate.

2536
02:06:57,210 --> 02:07:00,210
和枚举允许您解决这类问题
And enumerate allows you to solve this kind of problem

2537
02:07:00,210 --> 02:07:03,660
更简单地通过迭代某个序列
much more simply by iterating over some sequence

2538
02:07:03,660 --> 02:07:07,810
但并不是一次一个地找出每个值 
but finding out not each value one at a time,

2539
02:07:07,810 --> 02:07:12,630
而是一次一个值和它的指数 
but both the value one at a time and the index thereof.

2540
02:07:12,630 --> 02:07:15,010
它会同时返回两个答案 
It gives you back two answers at once.

2541
02:07:15,010 --> 02:07:18,240
因此 如果我现在返回到VS代码 并采用这种方法 
So if I go back to VS Code here now and take this approach,

2542
02:07:18,240 --> 02:07:21,990
我不需要做这个复杂的范围和长度 
I don't need to do this complicated range, and length,

2543
02:07:21,990 --> 02:07:23,730
然后我就到处跑了.
and then i all over the place.

2544
02:07:23,730 --> 02:07:25,620
我可以更简洁地做到这一点 
I can more succinctly do this.

2545
02:07:25,620 --> 02:07:31,560
我可以说我在枚举返回中逗号学生
I can say for i comma student in the enumerate return

2546
02:07:31,560 --> 02:07:33,550
重视学生的传授 
value passing in students.

2547
02:07:33,550 --> 02:07:36,150
所以这给我返回了一个枚举 如果你愿意的话 
So this gives me back an enumeration, if you will.

2548
02:07:36,150 --> 02:07:39,690
现在 我可以像以前一样打印i加1 
And now, I can go about printing i plus 1 as before.

2549
02:07:39,690 --> 02:07:41,190
我可以把学生的照片打印出来 
And I can print out the student.

2550
02:07:41,190 --> 02:07:44,625
因此 我不需要使用方括号I表示法来索引列表 
So I don't need to index into the list with bracket i notation.

2551
02:07:44,625 --> 02:07:45,750
我不需要给Range打电话 
I don't need to call range.

2552
02:07:45,750 --> 02:07:47,040
我不需要说长度 
I don't need to call length.

2553
02:07:47,040 --> 02:07:50,340
同样 枚举采用像这些学生一样的一系列值 
Again, enumerate takes a sequence of values like these students,

2554
02:07:50,340 --> 02:07:54,390
它允许我得到当前的索引0 1 2 
and it allows me to get back the current index zero, one, two,

2555
02:07:54,390 --> 02:07:58,630
和现值分别为赫敏、哈里、罗恩 
and the current value Hermione, Harry, Ron respectively.

2556
02:07:58,630 --> 02:08:00,330
所以现在 只要进一步收紧就行了 
So now, just tighten things up further.

2557
02:08:00,330 --> 02:08:01,955
事实上 这一直是我们在这里的主题 
And indeed, that's been our theme here.

2558
02:08:01,955 --> 02:08:04,770
我们能解决几周来一直在解决的问题吗？
Can we solve the same problems as we've been solving for weeks

2559
02:08:04,770 --> 02:08:09,320
但是 仅仅使用更多的这个工具包就可以收紧事情了吗？
but tighten things up using just more of this toolkit?

2560
02:08:09,320 --> 02:08:12,260
请允许我们为您的工具包配备最后一个工具 
Allow us to equip you with one final tool for your tool kit,

2561
02:08:12,260 --> 02:08:16,323
也就是说 这种从函数生成Python值的能力 
namely this ability to generate values in Python from functions.

2562
02:08:16,323 --> 02:08:18,990
这不是我们以前一定会遇到的问题 
This is not a problem that we've necessarily encountered before.

2563
02:08:18,990 --> 02:08:22,340
但事实证明 如果您正在编写一个读取或生成
But it turns out, if you're writing a function that reads or generates

2564
02:08:22,340 --> 02:08:24,500
大量数据 你的函数 你的程序 
lots of data, your function, your program,

2565
02:08:24,500 --> 02:08:26,990
您的计算机很可能会耗尽内存 
your computer might very well run out of memory.

2566
02:08:26,990 --> 02:08:30,410
并且您的程序可能无法继续运行 
And your program might not be able to run any further.

2567
02:08:30,410 --> 02:08:33,065
但事实证明这个问题有一个解决方案 那就是
But it turns out there's a solution to this problem that's

2568
02:08:33,065 --> 02:08:34,940
你的后口袋里可能有一些东西 
something you might have in your back pocket,

2569
02:08:34,940 --> 02:08:38,600
尤其是如果你在这门课结束后开始计算相当多的数字
particularly if after this course you start crunching quite a few numbers

2570
02:08:38,600 --> 02:08:40,460
并分析更多的数据 
and analyzing all the more data.

2571
02:08:40,460 --> 02:08:42,233
事实上 让我们回到这里的VS代码 
In fact, let's go back to VS Code here.

2572
02:08:42,233 --> 02:08:44,150
让我们继续创建一个程序 它是
And let's go ahead and create a program that's

2573
02:08:44,150 --> 02:08:47,113
也许在一天中的这个时候很及时 特别是
perhaps timely at this time of day, particularly

2574
02:08:47,113 --> 02:08:50,030
根据你所在时区的不同 你可能会感到更加困倦 
depending on your time zone, you might be feeling all the more sleepy.

2575
02:08:50,030 --> 02:08:52,100
但在美国 这是很常见的
But here in the US, it's quite common to be

2576
02:08:52,100 --> 02:08:54,590
在你挣扎的时候昏昏欲睡
lulled to sleep when you're struggling otherwise

2577
02:08:54,590 --> 02:08:56,240
通过在你的脑海中数羊 
by counting sheep in your head.

2578
02:08:56,240 --> 02:08:58,400
通常 就像卡通中描述的那样 你
And typically, as depicted in cartoons, you

2579
02:08:58,400 --> 02:09:01,580
你可能会在脑海中看到一只羊跳过栅栏 然后是两只 
might see in your mind's eye one sheep jumping over a fence, and then two,

2580
02:09:01,580 --> 02:09:03,138
然后是三只羊 然后是四只 
and then three sheep, and then four.

2581
02:09:03,138 --> 02:09:05,180
然后 最终 你可能会觉得很无聊
And then, eventually, you presumably get so bored

2582
02:09:05,180 --> 02:09:07,710
数着这些绵羊 你真的睡着了 
counting these sheep you actually do fall asleep.

2583
02:09:07,710 --> 02:09:11,570
因此 在VS代码中 让我们创建一个名为sleep.py的程序
So in VS Code here, let's create a program called sleep.py

2584
02:09:11,570 --> 02:09:14,810
这样我就可以打印出一些绵羊的数量
that allows me to print out some number of sheep

2585
02:09:14,810 --> 02:09:17,750
就像我在脑海里数着它们 
as though I'm counting them in my mind's eye.

2586
02:09:17,750 --> 02:09:19,610
通过这个项目 让我们做到这一点 
And via this program, let's do this.

2587
02:09:19,610 --> 02:09:22,250
让我们提示用户输入变量n 设置
Let's prompt the user for a variable n, setting

2588
02:09:22,250 --> 02:09:25,610
等于输入返回值的整数转换 
it equal to the integer conversion of the return value of input,

2589
02:09:25,610 --> 02:09:27,530
询问用户n是什么？
asking the user what's n?

2590
02:09:27,530 --> 02:09:29,720
他们想试着数一下有多少只羊？
For how many sheep do they want to try counting?

2591
02:09:29,720 --> 02:09:31,760
然后 让我们在这里做一个熟悉的for循环 
And then, let's do a familiar for loop here.

2592
02:09:31,760 --> 02:09:33,750
我们将一如既往地从零开始计数 
And we'll start counting from zero as always.

2593
02:09:33,750 --> 02:09:36,667
所以我们首先会有零只羊 然后是一只羊 然后是两只羊
So we'll first have zero sheep, then one sheep, then two sheep, and so

2594
02:09:36,667 --> 02:09:39,620
对于该值n的范围内的i 为ON 
on for i in the range of that value n.

2595
02:09:39,620 --> 02:09:40,880
继续打印出来吧 
Go ahead and print out.

2596
02:09:40,880 --> 02:09:44,090
我会在这里粘贴一个代表一只羊乘以I的表情符号 
And I'll paste here an emoji representing a sheep times i.

2597
02:09:44,090 --> 02:09:46,220
所以在第一次迭代中 我会看到零只绵羊 
So the first iteration I'll see zero sheep.

2598
02:09:46,220 --> 02:09:49,880
在第二次迭代中 您将看到一个 然后是两个 然后是多少个
The second iteration you'll see one, and then two, and then however many

2599
02:09:49,880 --> 02:09:53,330
由n指定 最终减去1 
specified by n ultimately minus one.

2600
02:09:53,330 --> 02:09:56,690
让我们在这里进入我的终端窗口 并运行sleep.py的Python 
Let's go down into my terminal window here and run Python of sleep.py.

2601
02:09:56,690 --> 02:09:59,450
我应该看到 确实 在输入 比方说 三
And I should see, indeed, after typing in, say, three

2602
02:09:59,450 --> 02:10:03,667
对于我的n值 没有羊 然后是一只羊 然后是两只羊 依此类推 
for my value of n, zero sheep, then one sheep, then two sheep, and so forth.

2603
02:10:03,667 --> 02:10:05,750
如果我把我的终端窗口做得更大 
And if I make my terminal window even bigger here,

2604
02:10:05,750 --> 02:10:08,990
当然 我们可以做更多的事情 例如 输入10 
we can, of course, do many more than this, typing in, for instance, 10.

2605
02:10:08,990 --> 02:10:11,870
你会看到随着时间的推移 我们会得到越来越多的羊 
And you'll see that we get more and more sheep as time passes,

2606
02:10:11,870 --> 02:10:15,740
想必在我脑海中的想象会变得更加乏味 
presumably becoming all the more tedious to envision in my mind's eye.

2607
02:10:15,740 --> 02:10:18,753
现在让我们继续练习我们所学到的东西
So let's now go ahead and practice what we've

2608
02:10:18,753 --> 02:10:21,170
当谈到这个程序的设计时 我一直在说教
been preaching when it comes to the design of this program

2609
02:10:21,170 --> 02:10:24,690
看看我们是否以及什么时候真的会遇到问题 
and see if and when we actually run into a problem.

2610
02:10:24,690 --> 02:10:27,830
现在让我继续进行 并将所有这些放在一个主函数中
Let me go ahead here now and put all of this in a main function

2611
02:10:27,830 --> 02:10:30,410
通过在这里一如既往地定义Main 
by defining main up here as always.

2612
02:10:30,410 --> 02:10:32,640
让我继续在这里缩进所有这些代码 
Let me go ahead and indent all of this code here.

2613
02:10:32,640 --> 02:10:34,890
然后 让我像往常一样有条件地这样做 
And then, let me just do this conditionally as always,

2614
02:10:34,890 --> 02:10:39,020
如果此文件的名称等于引号 则让我们继续
if the name of this file equals equals quote unquote main, let's go ahead

2615
02:10:39,020 --> 02:10:39,890
然后给Main打电话 
and call main.

2616
02:10:39,890 --> 02:10:43,520
让我们确保我还没有打碎任何东西 尽管从功能上讲
Let's make sure I didn't break anything just yet, even though functionally this

2617
02:10:43,520 --> 02:10:44,880
应该是差不多的 
should be nearly the same.

2618
02:10:44,880 --> 02:10:48,080
如果我输入三 我仍然是零 然后是一 
And if I type in three, I still have zero, then one,

2619
02:10:48,080 --> 02:10:50,180
然后屏幕上出现了两只羊 
then two sheep on the screen.

2620
02:10:50,180 --> 02:10:53,690
但我们一直习惯于创建助手函数
But we've been in the habit of course of creating helper functions

2621
02:10:53,690 --> 02:10:54,380
为了我们自己 
for ourselves.

2622
02:10:54,380 --> 02:10:56,510
也就是说 将我们的代码分解为
That is, factoring our code in a way that

2623
02:10:56,510 --> 02:11:00,530
允许我们抽象出某些功能 比如生成
allows us to abstract away certain functionality, like generating

2624
02:11:00,530 --> 02:11:03,093
将一些绵羊分成不同的功能 
some number of sheep into separate functions.

2625
02:11:03,093 --> 02:11:04,760
所以 第一 他们确实是抽象的 
So that, one, they're indeed abstracted.

2626
02:11:04,760 --> 02:11:07,302
我们不再需要考虑它们是如何实施的 
And we no longer have to think about how they're implemented.

2627
02:11:07,302 --> 02:11:09,860
我们甚至可以在项目中重复使用它们 就像在库中一样 
And we can even reuse them in projects as in libraries.

2628
02:11:09,860 --> 02:11:13,460
但我们现在也有测试这些功能的习惯
But we've also been in the habit too of now testing those functions

2629
02:11:13,460 --> 02:11:14,670
与单元测试一样 
as with unit tests.

2630
02:11:14,670 --> 02:11:17,660
所以我可能不应该把我所有的逻辑都放在Main里 
So I probably shouldn't keep all of my logic anyway in main.

2631
02:11:17,660 --> 02:11:19,280
让我们把其中的一些因素考虑在内 
And let's factor some of this out.

2632
02:11:19,280 --> 02:11:24,980
例如 如果我可以调用一个SHEEP函数 那不是很好吗
Wouldn't it be nice if I could, for instance, just call a sheep function

2633
02:11:24,980 --> 02:11:27,990
就像这里的这行代码一样 
as by taking this line of code here.

2634
02:11:27,990 --> 02:11:30,140
与其只在这里打印 不如让我们打印
And instead of just printing it here, let's print

2635
02:11:30,140 --> 02:11:32,270
新函数的返回值为
out the return value of a new function called

2636
02:11:32,270 --> 02:11:37,310
告诉函数要打印多少个绵羊的绵羊 在本例中是我 
sheep that tells the function how many sheep to print, i in this case.

2637
02:11:37,310 --> 02:11:40,610
让我们像往常一样在这里创建另一个名为SHEEP的函数 
Let's go down as always and create another function here called sheep.

2638
02:11:40,610 --> 02:11:43,910
SHEEP函数现在将接受一个参数n 该参数指定
The sheep function now will take a parameter n that specifies

2639
02:11:43,910 --> 02:11:45,960
你想还几只羊？
how many sheep do you want to return.

2640
02:11:45,960 --> 02:11:48,440
因此 我们可以像单元测试一样进行测试 
And so, that we can test this as with a unit test,

2641
02:11:48,440 --> 02:11:52,430
虽然我们不会在这里这样做 但让我继续 不打印绵羊的数量
though we won't do that here, let me go ahead and not print the number of sheep

2642
02:11:52,430 --> 02:11:53,720
就像通过副作用 
as via a side effect.

2643
02:11:53,720 --> 02:11:57,830
但让我继续下去 让我把其中的一只羊
But let me go ahead and return one of those sheep times n

2644
02:11:57,830 --> 02:12:00,980
这样用户就可以得到一整串羊 这是
so that the user gets back a whole string of sheep that's

2645
02:12:00,980 --> 02:12:03,320
要打印的适当数字 
the appropriate number to print.

2646
02:12:03,320 --> 02:12:05,270
所以从功能上来说 我认为我们还没有
So here too functionally, I don't think we've

2647
02:12:05,270 --> 02:12:06,890
从根本上改变了一切 
changed anything too fundamentally.

2648
02:12:06,890 --> 02:12:09,860
Pyep.py类型3的Python仍然为我们提供了
Python of sleep.py typing three still gives us

2649
02:12:09,860 --> 02:12:11,870
零 然后是一只 然后是两只羊 
zero, then one, and then two sheep.

2650
02:12:11,870 --> 02:12:18,170
但现在 我们至少有了一个专注于实施的框架
But now, we at least have a framework for focusing on the implementation

2651
02:12:18,170 --> 02:12:19,640
这种绵羊的功能 
of this sheep function.

2652
02:12:19,640 --> 02:12:24,890
但现在它还是主要功能 所以有点不雅观
But it's a little inelegant now that it's still up to the main function

2653
02:12:24,890 --> 02:12:26,330
来完成这个迭代 
to do this iteration.

2654
02:12:26,330 --> 02:12:28,610
我们在过去的第0周看到过 
We've seen in the past way back in week zero,

2655
02:12:28,610 --> 02:12:31,730
定义一个真正处理
wouldn't it be nice to define a function that actually handles

2656
02:12:31,730 --> 02:12:34,040
返回整个字符串的过程
the process of returning the entire string

2657
02:12:34,040 --> 02:12:38,180
我们想要的 而不是一次只有一排羊 
that we want rather than just one row of sheep at a time.

2658
02:12:38,180 --> 02:12:39,840
好吧 我想我们可以做到的 
Well, I think we can do this.

2659
02:12:39,840 --> 02:12:42,630
为什么不让我按照下面的方法去换羊呢？
Why don't I go ahead and change sheep as follows.

2660
02:12:42,630 --> 02:12:48,110
让我继续这里 首先创建一群一开始是空的羊
Let me go ahead here and first create a flock of sheep that's initially empty

2661
02:12:48,110 --> 02:12:49,410
使用空列表 
using an empty list.

2662
02:12:49,410 --> 02:12:55,640
那么对于n范围内的i 让我们继续并附加到该群中 
Then for i in the range of n, let's go ahead and append to that flock,

2663
02:12:55,640 --> 02:12:58,760
例如 一只羊乘以I 所以I
for instance, one sheep times i, so that I

2664
02:12:58,760 --> 02:13:02,570
继续添加零只羊 然后是一只羊 然后是两只羊 然后
keep adding to this list zero sheep, then one sheep, then two sheep, then

2665
02:13:02,570 --> 02:13:03,660
三个 以此类推 
three, and so forth.

2666
02:13:03,660 --> 02:13:06,500
然后 最终 我要把整群羊
And then, ultimately, I'm going to return the whole flock of sheep

2667
02:13:06,500 --> 02:13:07,130
立刻 
at once.

2668
02:13:07,130 --> 02:13:09,510
所以这将返回相当于所有
So this is going to return the equivalent of all

2669
02:13:09,510 --> 02:13:14,170
这样 啊 Main就可以处理它们的印刷了 
of those strings of sheep so that, ah, main can handle the printing thereof.

2670
02:13:14,170 --> 02:13:16,110
回到美因河畔 让我们开始吧 
So back up here in main, let's do this.

2671
02:13:16,110 --> 02:13:19,110
每只羊怎么样 我就叫它S 因为是羊
How about for each sheep, I'll call it s since sheep

2672
02:13:19,110 --> 02:13:24,210
既是单数也是复数 对于S来说 n的绵羊 它再次返回
is both singular and plural, for s in sheep of n, which again returns

2673
02:13:24,210 --> 02:13:27,960
给我一份所有绵羊的名单 整个羊群 让我们打印出来
to me a list of all of the sheep, the whole flock, let's just print

2674
02:13:27,960 --> 02:13:31,260
S 每只羊一只一只地出来 
out each sheep, s, one at a time.

2675
02:13:31,260 --> 02:13:33,300
所以 到目前为止 我认为这里一切都很好 
So, so far so good here, I think.

2676
02:13:33,300 --> 02:13:36,060
让我继续运行leep.py的Python并按Enter键 
Let me go ahead and run Python of sleep.py and hit Enter.

2677
02:13:36,060 --> 02:13:37,380
什么是n3 
What's n three.

2678
02:13:37,380 --> 02:13:40,560
而且 这似乎仍然运作得很好 
And that's still seems to work just fine.

2679
02:13:40,560 --> 02:13:45,300
但让我在这里有一点创意 看看
But let me get a little creative here and see

2680
02:13:45,300 --> 02:13:48,790
不只是我屏幕上的三只羊 可能还有10排羊 
not just three sheep on my screen but maybe 10 rows of sheep.

2681
02:13:48,790 --> 02:13:50,280
而且 这似乎也很管用 
And that too seems to work fine.

2682
02:13:50,280 --> 02:13:53,970
让我来点冒险 输入大概100只羊 
Let me get a little more adventurous and type in maybe 100 sheep.

2683
02:13:53,970 --> 02:13:56,100
公平地说 它开始看起来很难看 
And it's starting to look ugly, to be fair,

2684
02:13:56,100 --> 02:13:58,290
但它们都打印得很快 
but they're all printing out pretty fast.

2685
02:13:58,290 --> 02:14:02,610
让我继续尝试 屏幕上可能有1000只羊 
Let me go ahead and try again with maybe 1,000 sheep on the screen.

2686
02:14:02,610 --> 02:14:04,210
它们飞得很快 
And they flew by pretty fast.

2687
02:14:04,210 --> 02:14:05,310
它仍然很凌乱 
It's still pretty messy.

2688
02:14:05,310 --> 02:14:06,420
但他们都在那里 
But they're all there.

2689
02:14:06,420 --> 02:14:07,740
我们可以把它们都加起来 
We could count them all up.

2690
02:14:07,740 --> 02:14:11,610
不只是1000只羊 而是1万只羊怎么样？
How about not just 1,000 but 10,000 sheep?

2691
02:14:11,610 --> 02:14:13,080
嗯 这看起来也没问题 
Well, that too seems OK.

2692
02:14:13,080 --> 02:14:14,712
它花了大约10倍的时间 
It's taking like 10 times as long.

2693
02:14:14,712 --> 02:14:16,920
这就是为什么你会在屏幕上看到这个闪烁 
And that's why you see this flickering on the screen.

2694
02:14:16,920 --> 02:14:18,810
所有的羊都还在印刷 
All of the sheep are still printing.

2695
02:14:18,810 --> 02:14:22,420
但是 打印了大量的数据 
But, but, but, it's a lot of data being printed.

2696
02:14:22,420 --> 02:14:27,240
如果我再坚持下去 我们就有希望
If I hang in there a little longer, hopefully we'll

2697
02:14:27,240 --> 02:14:32,490
看着一万只羊都过来了 
see all 10,000 sheep coming to pass.

2698
02:14:32,490 --> 02:14:38,160
这是在这里的视频中 我们将加快时间 一个真正的在线 
This is here in the video where we will speed up time, a real online.

2699
02:14:38,160 --> 02:14:38,670
天啊
Oh my God.

2700
02:14:38,670 --> 02:14:40,410
这是很多羊 
This is a lot of sheep.

2701
02:14:40,410 --> 02:14:40,990
好了
There we go.

2702
02:14:40,990 --> 02:14:41,490
好的.
OK.

2703
02:14:41,490 --> 02:14:44,220
现在我所有的羊都被打印出来了 
And now all of my sheep have been printed.

2704
02:14:44,220 --> 02:14:46,320
所以它看起来工作得很好 
So it seems to be working just fine.

2705
02:14:46,320 --> 02:14:48,420
好吧 让我再大胆一点
Well, let me just be even more adventurous

2706
02:14:48,420 --> 02:14:50,220
好吧 让我试试运气
and, OK, let me try my luck.

2707
02:14:50,220 --> 02:14:56,930
让我试试 这次一百万只羊 按回车键怎么样？
Let me try, how about one million sheep this time and hit Enter?

2708
02:14:56,930 --> 02:14:58,250
Ha.
Ha.

2709
02:14:58,250 --> 02:15:03,070
有什么东西坏了 
Something's no longer working.

2710
02:15:03,070 --> 02:15:06,670
在我们等待剧透的同时 有没有人
While we wait for a spoiler here, does anyone

2711
02:15:06,670 --> 02:15:12,400
有没有直觉告诉我为什么我的程序突然停止打印绵羊了？
have any intuition for why my program suddenly stopped printing sheep?

2712
02:15:12,400 --> 02:15:17,320
这个版本出了什么问题 我在这里生成
What is going wrong in this version, wherein I'm generating

2713
02:15:17,320 --> 02:15:19,360
一大群羊吗
this really big flock of sheep?

2714
02:15:19,360 --> 02:15:22,745
我们可能已经耗尽了内存或计算能力 
STUDENT: We might have run out of memory or computation power.

2715
02:15:22,745 --> 02:15:23,620
DAVID J. MALAN：是的 
DAVID J. MALAN: Yeah.

2716
02:15:23,620 --> 02:15:26,020
也许我们真的在挑战我的Mac的极限
So maybe we're actually pushing the limits of my Mac,

2717
02:15:26,020 --> 02:15:30,760
我的PC 我的云服务器的内存或CPU 计算机的大脑 
my PCs, my cloud server's memory or CPU, the brains of the computer's

2718
02:15:30,760 --> 02:15:34,570
因为它只是试图产生
capabilities because it's just trying to generate

2719
02:15:34,570 --> 02:15:38,920
数量巨大的羊的名单 一百万只
massive, massive, massive lists of sheep, one million

2720
02:15:38,920 --> 02:15:41,950
每一排都有很多羊
of those rows of sheep, each of which has a huge number of sheep.

2721
02:15:41,950 --> 02:15:46,330
看起来我的电脑真的很难用 
And it seems that my computer here is honestly just really struggling.

2722
02:15:46,330 --> 02:15:48,340
现在这真的很不幸 
And this is really unfortunate now.

2723
02:15:48,340 --> 02:15:50,920
因为看起来即使这个项目很明显
Because it would seem that even though this program clearly

2724
02:15:50,920 --> 02:15:54,760
对1,000只羊来说效果很好 1万只羊 一次
works pretty well for 1,000 sheep, 10,000 sheep, once

2725
02:15:54,760 --> 02:15:58,520
你跨过了某个门槛 它就完全停止工作了
you cross some threshold, it just stops working altogether.

2726
02:15:58,520 --> 02:16:02,770
或者它只是需要太长的时间 该程序是有用的了 
Or it just takes way too long for the program to be useful anymore.

2727
02:16:02,770 --> 02:16:07,630
但这似乎有点傻 因为理论上 我绝对应该
But this seems a little silly, because theoretically, I should absolutely

2728
02:16:07,630 --> 02:16:10,450
如果我只打印一只羊 
be able to print all of these same sheep if I just printed one

2729
02:16:10,450 --> 02:16:15,430
然后马上印两张 然后印三张 四张 五张 
right away, then print two right away, then print three, then four, then five.

2730
02:16:15,430 --> 02:16:19,180
看起来这个问题的本质 如果我回到我的代码 
It seems that the essence of this problem, if I go back to my code,

2731
02:16:19,180 --> 02:16:24,610
是根据我的最佳实践 我试图实践我所宣扬的 
is that per my best practices that I'm trying to practice what I'm preaching,

2732
02:16:24,610 --> 02:16:26,920
似乎最根本的问题是 
it seems that the fundamental problem is that I've

2733
02:16:26,920 --> 02:16:31,000
通过创建一个叫做sheep的辅助函数 
modularized my code by creating this helper function called sheep,

2734
02:16:31,000 --> 02:16:34,570
他一生的目的就是做一代一代的绵羊
whose purpose in life is to do all of the generation of sheep

2735
02:16:34,570 --> 02:16:37,639
然后一次把它们全部送回来 
and then return all of them at once.

2736
02:16:37,639 --> 02:16:39,080
这不是更好吗？
Wouldn't it be better--

2737
02:16:39,080 --> 02:16:41,629
我真的能听到我的风扇现在就开着
and I can actually hear my fan turning on now even just

2738
02:16:41,629 --> 02:16:43,160
试图生出这些绵羊--
trying to generate these sheep--

2739
02:16:43,160 --> 02:16:46,940
把羊印成1 2 3 不是更好吗？
wouldn't it be better then to just print the sheep one, two, three,

2740
02:16:46,940 --> 02:16:47,959
一次四个？
four at a time?

2741
02:16:47,959 --> 02:16:49,219
嗯 我们可以这么做 
Well, we could do that.

2742
02:16:49,219 --> 02:16:51,260
但这确实是一种倒退 
But that's really a step backwards.

2743
02:16:51,260 --> 02:16:54,469
这与过去几周吸取的所有教训相矛盾 
That rather contradicts all of the lessons learned of the past few weeks.

2744
02:16:54,469 --> 02:16:57,709
通常情况下 不把所有东西都放在Main中是一件好事 
Where generally not putting everything in main is a good thing.

2745
02:16:57,709 --> 02:17:01,280
通常有一个附加功能 然后可以单独测试
Generally having an additional function that you can then test separately

2746
02:17:01,280 --> 02:17:02,790
使用单元测试是一件好事 
with unit tests is a good thing.

2747
02:17:02,790 --> 02:17:06,320
我们真的需要放弃所有这些最佳实践吗
Do we really need to give up all of those best practices just

2748
02:17:06,320 --> 02:17:09,469
打印出一些绵羊 然后在这里睡着？
to print out some sheep and here fall asleep?

2749
02:17:09,469 --> 02:17:12,770
嗯 事实证明这个问题是有解决方案的 
Well, it turns out there's a solution to this problem,

2750
02:17:12,770 --> 02:17:16,129
也就是以这些生成器的形式出现在Python中 
and namely in the form of these generators in Python.

2751
02:17:16,129 --> 02:17:18,410
您可以将函数定义为生成器 
You can define a function as a generator,

2752
02:17:18,410 --> 02:17:24,059
因此 它仍然可以为您的用户生成海量数据 
whereby it can still generate a massive amount of data for your users.

2753
02:17:24,059 --> 02:17:28,400
但您可以让它一次只返回其中的一小部分数据 
But you can have it return just a little bit of that data at a time.

2754
02:17:28,400 --> 02:17:31,940
您自己也可以用几乎相同的方式实现代码 
And you yourself can implement the code in almost the same way.

2755
02:17:31,940 --> 02:17:36,000
但你不必担心太多的东西会一下子被退回 
But you don't have to worry about too much getting returned all at once.

2756
02:17:36,000 --> 02:17:38,690
与Python的所有功能一样 这两个功能都有文档记录
These two, like all features of Python, are documented

2757
02:17:38,690 --> 02:17:40,670
在其中的官方文件中 
in the official documentation therein.

2758
02:17:40,670 --> 02:17:45,980
但你最终会发现 这一切归根结底都是这个关键字 
But what you'll find, ultimately, that it all boils down to this keyword here,

2759
02:17:45,980 --> 02:17:46,940
投降 
yield.

2760
02:17:46,940 --> 02:17:49,549
到目前为止 我们一直在制作函数 
Up until now, when we've been making functions,

2761
02:17:49,549 --> 02:17:54,260
我们一直在定义返回值的函数 如果有的话 
we have been defining functions that return values, if at all,

2762
02:17:54,260 --> 02:17:56,059
使用关键字Return 
using the keyword return.

2763
02:17:56,059 --> 02:17:58,040
事实上 如果我们回到我们这里的代码 
And indeed, if we go back to our code here,

2764
02:17:58,040 --> 02:17:59,969
这正是我一直在等待的 
that's exactly what I've been waiting for.

2765
02:17:59,969 --> 02:18:02,809
我一直在等着马上把整个鸟群送回来 
I've been waiting to return the whole flock at once.

2766
02:18:02,809 --> 02:18:05,690
不幸的是 如果你等得太久 而我们已经得到了 
Unfortunately, if you wait too long, and here we have it,

2767
02:18:05,690 --> 02:18:08,330
我的节目被引用了被扼杀了 
my program was quote unquote killed.

2768
02:18:08,330 --> 02:18:13,370
也就是说 我的计算机已经厌倦了有多少内存和CPU
That is to say, my computer got so fed up with how much memory and CPU

2769
02:18:13,370 --> 02:18:16,549
它试图使用它 只是说 不 你根本不会跑 
it was trying to use it just said, nope, you're not going to run at all.

2770
02:18:16,549 --> 02:18:17,660
这是不幸的 
And that's unfortunate.

2771
02:18:17,660 --> 02:18:20,420
现在我的程序不再适用于大量数字
Now my program no longer works for large numbers

2772
02:18:20,420 --> 02:18:24,110
睡眠--绵羊 如果我真的有麻烦 那就不好了
of sleeps-- sheeps, which is not good if I'm really having trouble

2773
02:18:24,110 --> 02:18:26,000
某天晚上睡着了 
falling asleep some night.

2774
02:18:26,000 --> 02:18:29,780
那么 我该如何使用Year来解决这个问题呢？
So how can I use yield to solve this problem instead?

2775
02:18:29,780 --> 02:18:31,070
好吧 那就让我来吧 
Well, let me do this.

2776
02:18:31,070 --> 02:18:36,740
与其在这个名为羊群的大名单上建立这个庞大的绵羊名单 
Instead of building up this massive list of sheep in this big list called flock,

2777
02:18:36,740 --> 02:18:38,660
让我们就这样做吧 
let's just do this instead.

2778
02:18:38,660 --> 02:18:41,660
让我继续下去 简化整个函数
Let me go ahead and simplify this whole function

2779
02:18:41,660 --> 02:18:46,670
如下所示 由此我对n的范围内的i进行迭代 
as follows, whereby I iterate for i in the range of n.

2780
02:18:46,670 --> 02:18:49,700
然后在每一次迭代中 在过去 我
And then on each iteration, in the past I

2781
02:18:49,700 --> 02:18:52,700
可能倾向于使用Return和Return
might have been inclined to use return and return

2782
02:18:52,700 --> 02:18:55,070
就像一只羊乘以我 
something like one sheep times i.

2783
02:18:55,070 --> 02:18:56,719
但这在这里行不通 
But this won't work here.

2784
02:18:56,719 --> 02:18:59,330
因为如果你想要一百万只羊而你
Because if you want a million sheep and you

2785
02:18:59,330 --> 02:19:03,290
开始一个for循环 表示i在一百万的范围内 
start a for loop saying for i in the range of a million,

2786
02:19:03,290 --> 02:19:06,469
您将立即返回意外的零只绵羊 
you're going to return accidentally zero sheep right away.

2787
02:19:06,469 --> 02:19:08,480
然后 这个功能基本上是无用的 
And then this function is essentially useless.

2788
02:19:08,480 --> 02:19:11,785
您不应该在这样的循环中间返回值
You shouldn't return a value in the middle of a loop like this

2789
02:19:11,785 --> 02:19:14,660
因为你不会得到这些后续迭代中的任何一个
because you're not going to get to any of these subsequent iterations

2790
02:19:14,660 --> 02:19:15,160
循环中的 
of the loop.

2791
02:19:15,160 --> 02:19:17,809
它会迭代一次 然后砰的一声 你就会返回 
It's going to iterate once, and boom, you return.

2792
02:19:17,809 --> 02:19:20,870
但多亏了Python中的另一个关键字
But thanks to this other keyword in Python

2793
02:19:20,870 --> 02:19:26,540
名为Year 您可以告诉Python实际上只返回一个
called yield, you can tell Python to effectively return just one

2794
02:19:26,540 --> 02:19:28,740
从该循环中一次取值 
value at a time from this loop.

2795
02:19:28,740 --> 02:19:31,309
所以如果我回到我的代码的这个版本 
So if I go back to this version of my code here.

2796
02:19:31,309 --> 02:19:38,719
我说不是回报 而是收益 这就像是说一次返回一个值 
And I say not return but yield, this is like saying return one value at a time,

2797
02:19:38,719 --> 02:19:42,770
一次返回一个值 一次返回一个值 
return one value at a time, return one value at a time.

2798
02:19:42,770 --> 02:19:45,500
For循环将继续工作 我将
The for loop will keep working and I will

2799
02:19:45,500 --> 02:19:49,880
继续从零到一 到二 一直到一百万 
keep counting from zero, to one, to two, all the way up toward one million.

2800
02:19:49,880 --> 02:19:52,970
但每一次 这个函数都会给你
But each time, the function is just going to hand you

2801
02:19:52,970 --> 02:19:54,260
回溯一小段数据 
back a little piece of data.

2802
02:19:54,260 --> 02:19:57,890
可以说 它只会产生一小部分数据 
It's going to generate, so to speak, just a little bit of that data,

2803
02:19:57,890 --> 02:19:59,570
并不是所有的数据一次都有 
not all of the data at once.

2804
02:19:59,570 --> 02:20:00,440
这很好 
And that's good.

2805
02:20:00,440 --> 02:20:04,010
因为我的计算机有相当大的内存 当然足够容纳
Because my computer has a decent amount of RAM, certainly enough to fit

2806
02:20:04,010 --> 02:20:05,120
一排羊 
one row of sheep.

2807
02:20:05,120 --> 02:20:07,400
显然 它没有足够的内存来容纳它 
It just doesn't have enough memory to fit, apparently,

2808
02:20:07,400 --> 02:20:10,430
一百万排这么多的羊 
one million rows of so many sheep.

2809
02:20:10,430 --> 02:20:15,410
所以现在 如果我在终端窗口运行sleep.py的Python 
So now, if I go to my terminal window and run Python of sleep.py and hit

2810
02:20:15,410 --> 02:20:16,910
输入 n是什么？
Enter, what's n?

2811
02:20:16,910 --> 02:20:20,210
三个也行 零个 一个 两个.
Three would still work-- zero, then one, and then two.

2812
02:20:20,210 --> 02:20:23,930
让我继续增加这个的大小 然后运行Python的sleep. py 
Let me go ahead and increase the size of this here and run Python of sleep.py.

2813
02:20:23,930 --> 02:20:27,980
让我们像以前一样尝试一百万 然后按Enter键 
Let's try one million as before and hit Enter.

2814
02:20:27,980 --> 02:20:31,002
现在我马上看到了结果 
And now I immediately see results.

2815
02:20:31,002 --> 02:20:32,960
我不认为我们会等到所有这些羊
I don't think we'll wait for all of these sheep

2816
02:20:32,960 --> 02:20:35,870
打印出来 因为那样的话 我们就都睡着了
to be printed, because then we will literally all be asleep.

2817
02:20:35,870 --> 02:20:40,310
但是你会注意到现在程序没有挂起 
But what you'll notice happening now is the program is not hanging,

2818
02:20:40,310 --> 02:20:40,810
可以这么说
so to speak.

2819
02:20:40,810 --> 02:20:43,227
不是等待 等待 思考 思考 
It's not waiting, and waiting, and thinking, and thinking,

2820
02:20:43,227 --> 02:20:45,260
并试图一次产生整个群体 
and trying to generate the entire flock at once.

2821
02:20:45,260 --> 02:20:48,187
它只是一次产生一排羊 
It's just generating one row of sheep at a time.

2822
02:20:48,187 --> 02:20:51,020
它在屏幕上闪烁 因为它们太多了 
And it's flickering on the screen because there are so many of them.

2823
02:20:51,020 --> 02:20:52,700
这都要归功于屈服 
And that's all thanks to yield.

2824
02:20:52,700 --> 02:20:57,530
它一次生成一点数据 而不是一次生成全部数据 
It's generating a little bit of data at a time, not all at once.

2825
02:20:57,530 --> 02:21:03,030
现在对这个叫做发电机的功能有什么问题吗？
Any questions now on this feature called generators?

2826
02:21:06,260 --> 02:21:07,760
有什么问题吗？
Any questions at all?

2827
02:21:07,760 --> 02:21:10,910
再加一个术语到这个混合体中 只是为了让你听到它 
To add one more piece of terminology to the mix, just so you've heard it.

2828
02:21:10,910 --> 02:21:17,840
这里的相同功能是返回我们现在在技术上称为迭代器的东西 
This same feature here is returning what we'll technically now call an iterator.

2829
02:21:17,840 --> 02:21:20,000
Yield返回一个迭代器 
Yield is returning an iterator that allows

2830
02:21:20,000 --> 02:21:25,550
你自己的代码 你自己的for循环 
your own code, your own for loop in main to iterate over these generated values

2831
02:21:25,550 --> 02:21:27,450
一次一个
one at a time.

2832
02:21:27,450 --> 02:21:34,010
问：这个收益率实际上是如何在引擎盖下工作的？
STUDENT: How does this yield actually works under the hood?

2833
02:21:34,010 --> 02:21:38,545
我的意思是 它使用多线程吗？
I mean, is it using multithreading?

2834
02:21:38,545 --> 02:21:40,670
DAVID J. MALAN：你可以把它的实现
DAVID J. MALAN: You can think of the implementation

2835
02:21:40,670 --> 02:21:42,860
在这个意义上是异步的 
as being asynchronous in this sense.

2836
02:21:42,860 --> 02:21:48,050
函数立即返回一个值 
Whereby the function is returning a value immediately and then

2837
02:21:48,050 --> 02:21:50,900
然后再还给你一个
subsequently giving you back another one as well.

2838
02:21:50,900 --> 02:21:52,910
在引擎盖下面 到底发生了什么
Underneath the hood, what's really happening

2839
02:21:52,910 --> 02:21:55,740
发电机只是为你保留状态 
is the generator is just retaining state for you.

2840
02:21:55,740 --> 02:21:58,790
它不会从上到下运行整个循环
It does not going to run the entire loop from top to bottom

2841
02:21:58,790 --> 02:22:00,140
然后返回一个值
and then return a value.

2842
02:22:00,140 --> 02:22:02,660
它将进行一次迭代并产生一个结果 
It's going to do one iteration and yield a result.

2843
02:22:02,660 --> 02:22:07,460
如果你愿意的话 Python会暂停这个函数 
And the Python for you is going to suspend the function, if you will,

2844
02:22:07,460 --> 02:22:09,650
但请记住它是在什么迭代上 
but remember on what iteration it was.

2845
02:22:09,650 --> 02:22:12,170
所以当你下一次迭代它的时候 
So the next time you iterate over it, as is

2846
02:22:12,170 --> 02:22:14,570
在Main中的for循环中会反复发生 
going to happen again and again in this for loop in main,

2847
02:22:14,570 --> 02:22:17,570
你一次又一次地得到另一个值 
you get back another value again and again.

2848
02:22:17,570 --> 02:22:20,300
所以产生回报 实际上 这个东西叫做迭代器 
So yield returns, indeed, this thing called an iterator.

2849
02:22:20,300 --> 02:22:24,690
该迭代器可以像在循环中一样一次一个元素地跳过 
And that iterator can be stepped over as in a loop one element at a time.

2850
02:22:24,690 --> 02:22:27,410
但在语言方面 Python会为您处理所有这些
But the language, Python handles all of that for you

2851
02:22:27,410 --> 02:22:32,120
这样你就不需要自己做所有底层的管道工作了 
so that you don't need to do all of the underlying plumbing yourself.

2852
02:22:32,120 --> 02:22:36,510
关于这些生成器和积分器的另一个问题如何？
How about time for one other question on these generators and integrators

2853
02:22:36,510 --> 02:22:38,990
当我们的羊继续飞过的时候？
as our sheep continue to fly by?

2854
02:22:38,990 --> 02:22:41,960
学生：所以如果每一次迭代 程序
STUDENT: So if every iteration, the program

2855
02:22:41,960 --> 02:22:46,270
是否会将内存归还给系统 这样程序就不会崩溃？
will return the memory to the system so the program will not crash?

2856
02:22:46,270 --> 02:22:47,270
大卫·J·马兰：正确 
DAVID J. MALAN: Correct.

2857
02:22:47,270 --> 02:22:50,840
在每次迭代中 它只返回一个绵羊字符串 即
On each iteration, it's only returning the one string of sheep that's

2858
02:22:50,840 --> 02:22:53,030
适用于i的当前值 
appropriate for the current value of i.

2859
02:22:53,030 --> 02:22:57,080
它并不是试图返回相同的所有100万行 
It is not trying to return all million rows of the same.

2860
02:22:57,080 --> 02:23:00,470
因此 它使用的内存量只有百万分之一 
And therefore, it uses really one millionth the amount of memory,

2861
02:23:00,470 --> 02:23:03,980
尽管这有点过于简单化了 
although that's a bit of an oversimplification.

2862
02:23:03,980 --> 02:23:04,850
好的 
All right.

2863
02:23:04,850 --> 02:23:07,040
当这些绵羊继续飞过 
As these sheep continue to fly across the,

2864
02:23:07,040 --> 02:23:10,130
现在让我继续 打断一下 
screen let me now go ahead and interrupt this,

2865
02:23:10,130 --> 02:23:13,460
过去 您可能不得不在自己的代码中使用无限循环 
as you might have had to in the past with infinite loops in your own code.

2866
02:23:13,460 --> 02:23:16,250
尽管这不是无限的 但它真的很长--控制
Even though this isn't infinite, it's just really long-- control

2867
02:23:16,250 --> 02:23:19,400
C会用你的键盘中断那个程序 给我
C will interrupt with your keyboard that program, giving me

2868
02:23:19,400 --> 02:23:21,950
控制我的电脑 
back control of my computer.

2869
02:23:21,950 --> 02:23:25,760
好了 我们现在是在CS50的结尾 S介绍
Well, here we are at the end of CS50's Introduction

2870
02:23:25,760 --> 02:23:27,200
到使用Python语言编程 
to Programming with Python.

2871
02:23:27,200 --> 02:23:31,700
如果今天 特别是所有的日子 感觉像是真正的升级
And if today in particular of all days felt like a real escalation

2872
02:23:31,700 --> 02:23:34,040
很快 我就会意识到这些真的--
real quickly, realize that these are really--

2873
02:23:34,040 --> 02:23:37,700
这些只是工具包中的附加工具 或许是可选工具
these are just additional perhaps optional tools in your toolkit

2874
02:23:37,700 --> 02:23:40,520
你可以在过去学到的所有教训上再加一笔 
that you can add to all of the past lessons learned.

2875
02:23:40,520 --> 02:23:43,723
因此 当您退出本课程并处理其他课程或项目时
So that as you exit from this course and tackle other courses or projects

2876
02:23:43,723 --> 02:23:45,890
你自己 你有更多的心理模型
of your own, you have all the more of a mental model

2877
02:23:45,890 --> 02:23:49,220
更像是一个工具箱 用来解决同样的问题 
and all the more of a toolbox with which to solve those same problems.

2878
02:23:49,220 --> 02:23:52,010
如果我们现在回想一下就在几周前 
If we think back now just a few weeks ago,

2879
02:23:52,010 --> 02:23:55,193
这可能是我们重点关注的函数和变量
it was probably in our focus on functions and variables

2880
02:23:55,193 --> 02:23:56,610
你刚开始挣扎的时候 
that you first started struggling.

2881
02:23:56,610 --> 02:23:59,120
但现在回想起来 如果你回顾这些问题
But now in retrospect, if you look back at those problems

2882
02:23:59,120 --> 02:24:01,670
而那些相同的问题集 几率也是相同的问题
and those same problems sets, odds are those same problems

2883
02:24:01,670 --> 02:24:03,560
现在对你来说太容易了 
would come all too easily to you now.

2884
02:24:03,560 --> 02:24:05,870
条件句是这门课的下一步 其中
Conditionals was the next step in the class, wherein

2885
02:24:05,870 --> 02:24:08,810
我们给了你提问和获得答案的能力
we gave you the ability to ask questions and get answers

2886
02:24:08,810 --> 02:24:10,940
因此在您的代码中有条件地执行操作 
and therefore do things conditionally in your code.

2887
02:24:10,940 --> 02:24:12,355
我们今天又绕了一圈 
We came full circle today.

2888
02:24:12,355 --> 02:24:15,230
你可以看到 你现在可以使用相同类型的条件句
And you can see that you can now use those same kinds of conditionals

2889
02:24:15,230 --> 02:24:18,680
现在用清单理解和词典来做一些更花哨的事情
now to do fancier things with list comprehension and dictionary

2890
02:24:18,680 --> 02:24:19,970
理解和类似的东西 
comprehensions and the like.

2891
02:24:19,970 --> 02:24:23,450
当然 几个星期以来 循环已经无处不在 包括今天
Loops, of course, have been omnipresent now for weeks, including today

2892
02:24:23,450 --> 02:24:25,070
当我们建造那些相同的结构时 
as we built up those same structures.

2893
02:24:25,070 --> 02:24:26,750
当然 有些事情可能会出错 
And of course, something can go wrong.

2894
02:24:26,750 --> 02:24:29,600
异常和异常处理是我们的机制
And exceptions and exception handling was our mechanism

2895
02:24:29,600 --> 02:24:34,022
不仅用于捕获代码中的错误 还用于引发您自己的异常 
for not only catching errors in code but also raising your own exception.

2896
02:24:34,022 --> 02:24:36,980
因此 如果您正在为其他人编写代码奠定基础 
So that if you're laying the foundation to write code for other people,

2897
02:24:36,980 --> 02:24:39,590
就像在库的形式中一样 您也可以这样做 
as in the form of libraries, you can do that too.

2898
02:24:39,590 --> 02:24:43,190
当然 库不仅可以使用 而且现在还可以自己编写 
Libraries, of course, are things you can not only use but now write on your own,

2899
02:24:43,190 --> 02:24:45,713
它可以是一个小模块或整个代码包
be it a small module or whole package of code

2900
02:24:45,713 --> 02:24:47,880
你想与世界各地的人分享的东西 
that you want to share with others around the world.

2901
02:24:47,880 --> 02:24:52,250
更好的是 你能为你自己的代码 你的库 
And even better, can you write tests for your own code, for your libraries,

2902
02:24:52,250 --> 02:24:53,402
对于其他人的代码也是如此 
for other's code as well.

2903
02:24:53,402 --> 02:24:55,610
所以最终 你可以更有信心
So that ultimately, you can be all the more confident

2904
02:24:55,610 --> 02:24:57,470
今天不仅你的代码是正确的 
that not only your code is correct today.

2905
02:24:57,470 --> 02:24:59,780
但如果您明天对代码进行更改 
But if you make a change to your code tomorrow,

2906
02:24:59,780 --> 02:25:02,960
你没有打碎任何东西 至少根据你的测试
you haven't broken anything, at least according to your tests

2907
02:25:02,960 --> 02:25:04,580
如果他们继续通过的话 
if they continue to pass.

2908
02:25:04,580 --> 02:25:07,400
与此同时 文件I/O是现在存储的一种方式
File I/O though, meanwhile, was a way of now storing

2909
02:25:07,400 --> 02:25:10,160
数据不仅存在于计算机内存中 就像所有这些绵羊一样 
data not just in the computer's memory like all of these sheep,

2910
02:25:10,160 --> 02:25:13,700
但实际上是将东西持久地、长期地存储到磁盘上 
but actually storing things persistently, longer term to disk,

2911
02:25:13,700 --> 02:25:17,510
在CSV或更像二进制文件(如图像)中 
being in a CSV or something more like a binary file like an image.

2912
02:25:17,510 --> 02:25:20,240
使用正则表达式 您就可以
With regular expressions, you then had the ability

2913
02:25:20,240 --> 02:25:23,870
表示模式并实际验证数据或提取数据
to express patterns and actually validate data or extract data

2914
02:25:23,870 --> 02:25:24,620
从信息中 
from information.

2915
02:25:24,620 --> 02:25:28,280
如今 当世界上如此多的人
All the more of a useful technique nowadays when so much of the world

2916
02:25:28,280 --> 02:25:31,370
正在尝试分析和处理大规模的数据 其中一些
is trying to analyze and process data at scale, some of which

2917
02:25:31,370 --> 02:25:35,300
可能实际上从一开始就相当混乱 
might in fact be quite messy from the get-go.

2918
02:25:35,300 --> 02:25:38,090
然后 当然 最近的面向对象编程 
And then, of course, most recently, object-oriented programming,

2919
02:25:38,090 --> 02:25:40,610
解决同类问题的机会
an opportunity to solve the same kinds of problems

2920
02:25:40,610 --> 02:25:42,770
但以一种略有不同的视角 一种
but with a slightly different perspective, a way

2921
02:25:42,770 --> 02:25:47,600
来封装和表示真实世界的实体 这一次是在代码中 
to encapsulate and to represent real world entities, this time in code.

2922
02:25:47,600 --> 02:25:50,720
今天 当然 还有很多其他的工具
And today, of course, et cetera with so many other tools

2923
02:25:50,720 --> 02:25:54,110
你可以补充说 它不一定属于之前的任何一项
that you can add that didn't necessarily fall under any of those earlier

2924
02:25:54,110 --> 02:25:57,410
但雨伞是有用的功能和数据类型 
umbrellas but are useful functions, and data types,

2925
02:25:57,410 --> 02:26:00,260
和技术 再一次 在你的后口袋里
and techniques just to have, again, in your back pocket

2926
02:26:00,260 --> 02:26:03,830
还有其他解决问题的机制 
as yet other mechanisms for solving problems as well.

2927
02:26:03,830 --> 02:26:07,170
不仅让每个人都睡着了 我还想了另一种方式来结束
Not just putting everyone to sleep, but I thought another way to end

2928
02:26:07,170 --> 02:26:11,670
试着一起写最后一个程序可能会更有说服力 
might be a little more vocally to try writing one final program together,

2929
02:26:11,670 --> 02:26:15,030
这一次使用了我们过去见过的库 也使用了其他库 
this one using a library we've seen in the past, as well as one other.

2930
02:26:15,030 --> 02:26:19,800
我擅自在我的电脑上安装了一个文本到语音库
I've taken the liberty of installing a text to speech library on my computer

2931
02:26:19,800 --> 02:26:20,550
这里 
here.

2932
02:26:20,550 --> 02:26:25,530
接下来 我可能会打开一个名为say.py的新文件
And I'm going to go ahead, perhaps, and open a new file here called say.py

2933
02:26:25,530 --> 02:26:26,610
在VS代码中 
in VS Code.

2934
02:26:26,610 --> 02:26:32,430
接下来 我要先介绍一下我们自己的朋友 进口牛仔 
And I'm going to go ahead here and first import our own friend, import cowsay.

2935
02:26:32,430 --> 02:26:37,500
我将在这里导入这个新的库 导入pyttsx3 
And I'm going to import this new library here, import pyttsx3,

2936
02:26:37,500 --> 02:26:39,540
Python文本到语音库 
the Python text to speech library.

2937
02:26:39,540 --> 02:26:42,900
现在 根据我事先读过的文件 
And now, per its documentation, which I read in advance,

2938
02:26:42,900 --> 02:26:45,540
我将在这里为自己创建一个变量 
I'm going to go ahead and create a variable for myself here,

2939
02:26:45,540 --> 02:26:52,530
引擎等于pyttsx3 init以初始化用于文本到语音的库 
engine equals pyttsx3 init to initialize that library for text to speech.

2940
02:26:52,530 --> 02:26:56,160
然后 我将询问用户 我希望听到什么？
I'm going to then ask the user, well, what do I want to hear spoken?

2941
02:26:56,160 --> 02:26:57,660
我可能会做这样的事 
And I might do something like this.

2942
02:26:57,660 --> 02:27:00,840
名为this的变量等于INPUT的返回值 
A variable called this equals the return value of input.

2943
02:27:00,840 --> 02:27:03,000
这将是我简单的问题 
What's this shall be my simple question.

2944
02:27:03,000 --> 02:27:05,310
这一次 我将把它作为一根弦 
And I'm going to keep it this time as a string.

2945
02:27:05,310 --> 02:27:06,870
我们已经看到了如何使用牛仔 
We've seen how to use cowsay.

2946
02:27:06,870 --> 02:27:09,420
我们可以做牛仔 牛的这个 
We can do cowsay.cow of this.

2947
02:27:09,420 --> 02:27:12,600
原来这个新的库可以让我使用自己的引擎
Turns out this new library can allow me to use its own engine

2948
02:27:12,600 --> 02:27:14,800
我也是这么说的 
to say this as well.

2949
02:27:14,800 --> 02:27:19,020
但是 最终 我将不得不运行引擎 运行和等待 
But then, ultimately, I'm going to have to run the engine.runAndWait,

2950
02:27:19,020 --> 02:27:21,750
以防它是一个很长的短语或句子要说 
just in case it's a long phrase or sentence to be said.

2951
02:27:21,750 --> 02:27:22,830
但仅此而已 
But that's it.

2952
02:27:22,830 --> 02:27:27,000
在短短八行代码中 我不仅显然将拥有一头牛
In just eight lines of code, not only am I apparently going to have a cow

2953
02:27:27,000 --> 02:27:32,010
出现在屏幕上 关闭我们现在 但也一些合成的文本 
appear on the screen to close us out now but also some synthesized text.

2954
02:27:32,010 --> 02:27:35,732
最终 我们希望通过这门课程 您不仅学习了Python 
Ultimately then we hope with this course that you've not only learned Python,

2955
02:27:35,732 --> 02:27:37,440
你不仅学会了编程 
that you've not only learned programming,

2956
02:27:37,440 --> 02:27:39,440
但你真的学会了如何解决问题 
but you've really learned how to solve problems,

2957
02:27:39,440 --> 02:27:42,180
以及最终如何自学新的语言 
and ultimately how to teach yourself new languages.

2958
02:27:42,180 --> 02:27:45,597
有趣的是 我自己也是几年前才学会的 
Funny enough, I myself only learned Python just a few years ago.

2959
02:27:45,597 --> 02:27:48,930
尽管我确实查阅了一些正式的文件和资源
And even though I certainly went through some formal documentation and resources

2960
02:27:48,930 --> 02:27:52,530
在网上 我主要学到了我现在知道的甚至是
online, I mostly learned what I know now and even what

2961
02:27:52,530 --> 02:27:55,740
我不得不通过问很多问题来再次学习今天的课程 
I had to learn again for today by just asking lots of questions,

2962
02:27:55,740 --> 02:27:59,600
无论是谷歌的朋友 还是比我更精通这门语言的朋友们 
be it of Google, or friends, who are more versed in this language than I.

2963
02:27:59,600 --> 02:28:02,470
因此 拥有这种本能 拥有这种词汇[INAUDIBLE]
And so, having that instinct, having that vocabulary [INAUDIBLE]

2964
02:28:02,470 --> 02:28:05,550
向其他人提问以搜索问题的答案 
which to ask questions of others to search for answers to questions,

2965
02:28:05,550 --> 02:28:08,790
现在 您完全有了足够的Python基础
you absolutely now have enough of a foundation in Python

2966
02:28:08,790 --> 02:28:11,217
和编程让你自己离开并站立起来 
and programming to go off and stand on your own.

2967
02:28:11,217 --> 02:28:13,800
所以你当然可以--我们欢迎并鼓励你去
So you can certainly-- and you're welcome and encouraged to go

2968
02:28:13,800 --> 02:28:16,830
上并学习其他课程 特别是关于Python和编程的课程 
on and take other courses in Python and programming specifically.

2969
02:28:16,830 --> 02:28:19,350
但更好的是 越快越好
But better still, as quickly as you can, is

2970
02:28:19,350 --> 02:28:22,200
去找一些个人感兴趣的项目
to find some project that's personally of interest that

2971
02:28:22,200 --> 02:28:24,030
使用Python或其他某种语言 
uses Python or some other language.

2972
02:28:24,030 --> 02:28:26,730
因为至少从我自己的经验来看 我往往学得最好
Because at least from my own experience, I tend to learn best

2973
02:28:26,730 --> 02:28:29,880
我希望你也能通过实际应用这些技能来实现 
and I hope you might too by actually applying these skills.

2974
02:28:29,880 --> 02:28:32,700
不是针对课堂上的问题 而是真的
Not to problems in the classroom, but really truly

2975
02:28:32,700 --> 02:28:34,980
真实世界中的问题 
to problems in the real world.

2976
02:28:34,980 --> 02:28:39,180
请允许我在这里查看我的全屏终端窗口 
Allow me with all that said to look at my full screen terminal window here.

2977
02:28:39,180 --> 02:28:44,010
运行Say.py的Python 最后一次祈祷
Run Python of say.py, crossing my fingers one final time in

2978
02:28:44,010 --> 02:28:46,860
希望我没有犯任何错误或错误 
hopes that I've not made any mistakes or bugs.

2979
02:28:46,860 --> 02:28:47,790
现在我们开始吧 
And here we go.

2980
02:28:47,790 --> 02:28:50,620
Pay.py的巨蟒提示我 这是什么？
Python of say.py prompting me, what's this?

2981
02:28:50,620 --> 02:28:52,740
我们就在这里结束吧 
How about we end on this note here.

2982
02:28:55,420 --> 02:28:57,480
电脑：这是CS50 
COMPUTER: This was CS50.

