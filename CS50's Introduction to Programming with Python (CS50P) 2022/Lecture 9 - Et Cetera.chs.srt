1
00:00:24,287 --> 00:00:25,370
大卫·J·马兰：好的 

2
00:00:25,370 --> 00:00:28,730
这是CS50的S介绍用PYTHON编程 

3
00:00:28,730 --> 00:00:30,050
我叫大卫·马兰 

4
00:00:30,050 --> 00:00:32,210
在过去的许多周里 我们专注于

5
00:00:32,210 --> 00:00:36,020
关于函数和变量 然后是条件句和循环 

6
00:00:36,020 --> 00:00:39,030
和异常、一些库、单元测试文件

7
00:00:39,030 --> 00:00:42,050
布局、正则表达式、面向对象编程

8
00:00:42,050 --> 00:00:43,520
真的 诸如此类 

9
00:00:43,520 --> 00:00:45,770
事实上 这就是我们今天关注的地方

10
00:00:45,770 --> 00:00:48,710
关于您可以使用Python和编程做的更多事情

11
00:00:48,710 --> 00:00:52,410
更广泛地说 也超出了这些基本概念中的一些 

12
00:00:52,410 --> 00:00:55,340
事实上 如果您开始浏览有关Python的文档

13
00:00:55,340 --> 00:00:59,570
以及它的所有形式 所有这些形式都可以在docs.python.org上访问 

14
00:00:59,570 --> 00:01:03,770
您将看到有关Python自己的教程和库的其他文档 

15
00:01:03,770 --> 00:01:05,510
它的参考 它的使用方法 

16
00:01:05,510 --> 00:01:09,540
在所有这些不同的文档以及其他更多的在线文档中 

17
00:01:09,540 --> 00:01:12,530
你会看到有一些我们没有完全触及的花边新闻 

18
00:01:12,530 --> 00:01:15,560
事实上 尽管我们在过去的几周里

19
00:01:15,560 --> 00:01:19,430
围绕着相当广泛的主题 这些主题对做

20
00:01:19,430 --> 00:01:22,160
事实证明 Python中的典型问题类型

21
00:01:22,160 --> 00:01:25,460
还有相当多的其他功能 我们不一定

22
00:01:25,460 --> 00:01:27,950
涉及到 这不一定适合在任何

23
00:01:27,950 --> 00:01:30,560
这些首要概念 或者可能有

24
00:01:30,560 --> 00:01:33,770
如果我们在课程太早的时候做 那就有点太早了 

25
00:01:33,770 --> 00:01:36,320
所以 在今天 我们的最后一堂课 嗯 我们

26
00:01:36,320 --> 00:01:38,990
真正关注您可以使用Python做的更多事情

27
00:01:38,990 --> 00:01:42,740
希望能激发你自学的胃口 

28
00:01:42,740 --> 00:01:45,680
例如 在Python的各种数据类型中 

29
00:01:45,680 --> 00:01:49,130
还有另一个我们还没有机会使用的 那就是一套 

30
00:01:49,130 --> 00:01:52,040
在数学中 集合通常是值的集合

31
00:01:52,040 --> 00:01:53,820
其中没有复制品 

32
00:01:53,820 --> 00:01:55,170
所以这并不是一份完整的清单 

33
00:01:55,170 --> 00:01:58,790
它比那更特别一点 因为不知何故 任何复制品都是

34
00:01:58,790 --> 00:01:59,990
为你淘汰了 

35
00:01:59,990 --> 00:02:03,200
实际上 在Python中 这是一种实际的数据类型

36
00:02:03,200 --> 00:02:05,690
您自己可以在代码中使用的 

37
00:02:05,690 --> 00:02:08,330
通过这里的文档 您是否可以

38
00:02:08,330 --> 00:02:10,580
能够发现这是一个有用的问题

39
00:02:10,580 --> 00:02:13,430
如果您想以某种方式自动过滤掉重复项 

40
00:02:13,430 --> 00:02:16,250
所以让我继续 转到VS代码这里 

41
00:02:16,250 --> 00:02:20,210
让我继续向你们展示一个我之前创建的文件 

42
00:02:20,210 --> 00:02:23,300
我们在这里有一个名为house.py的文件 

43
00:02:23,300 --> 00:02:26,420
在House.py中 我已经开始准备了

44
00:02:26,420 --> 00:02:29,990
其中的一大份学生名单是

45
00:02:29,990 --> 00:02:33,470
一些词典 每本词典代表一个学生的名字

46
00:02:33,470 --> 00:02:35,310
和豪斯分别 

47
00:02:35,310 --> 00:02:37,080
现在 这是一本相当大的词典 

48
00:02:37,080 --> 00:02:39,560
因此 它适合于对相同的东西进行迭代 

49
00:02:39,560 --> 00:02:42,810
假设这里的目标很简单 就是找出 

50
00:02:42,810 --> 00:02:46,735
那么 在哈利波特的世界里 霍格沃茨有哪些独特的房子呢？

51
00:02:46,735 --> 00:02:49,610
也许 如果不需要知道这些细节就好了

52
00:02:49,610 --> 00:02:50,570
或者上网查一查 

53
00:02:50,570 --> 00:02:54,500
在这里 我们有一组学生 尽管不是详尽的 所有的房子 

54
00:02:54,500 --> 00:02:58,550
但是 在这些在座的学生中 他们居住的独特的房子是什么？

55
00:02:58,550 --> 00:03:00,800
嗯 我当然可以 作为一个人 看看这个

56
00:03:00,800 --> 00:03:03,650
告诉你 是格兰芬多、斯莱特林和拉文克劳 

57
00:03:03,650 --> 00:03:06,620
但是我们如何才能开始为这些学生编程呢？

58
00:03:06,620 --> 00:03:07,520
也是?

59
00:03:07,520 --> 00:03:09,360
那么 让我们先采取一种方法 

60
00:03:09,360 --> 00:03:11,240
让我到房子里去 

61
00:03:11,240 --> 00:03:15,170
让我提议我们首先创建一个空名单怎么样

62
00:03:15,170 --> 00:03:20,390
所谓的房子 我将在其中唯一地积累每一所房子 

63
00:03:20,390 --> 00:03:24,920
所以每次我重复这一系列词典的时候 

64
00:03:24,920 --> 00:03:28,830
如果我以前没见过一栋房子 我才会把它加到这个名单上 

65
00:03:28,830 --> 00:03:30,020
那么我该怎么表达呢？

66
00:03:30,020 --> 00:03:34,130
好 让我重复一下所有的学生 在学生中 

67
00:03:34,130 --> 00:03:35,550
就像我们过去所做的那样 

68
00:03:35,550 --> 00:03:37,200
现在让我问你一个问题

69
00:03:37,200 --> 00:03:40,400
所以如果现在学生的房子--

70
00:03:40,400 --> 00:03:43,550
注意我正在索引当前学生

71
00:03:43,550 --> 00:03:46,580
因为我知道它们是字典或字典对象 

72
00:03:46,580 --> 00:03:51,830
如果那个学生的房子不在我的房子名单上

73
00:03:51,830 --> 00:03:56,480
然后 缩进 我要说房子 附加 

74
00:03:56,480 --> 00:03:58,190
因为房子也是一个列表

75
00:03:58,190 --> 00:04:02,120
我要把那栋房子加到名单上 

76
00:04:02,120 --> 00:04:04,130
在最下面 让我继续

77
00:04:04,130 --> 00:04:07,880
在这里做一些有趣的事情 

78
00:04:07,880 --> 00:04:11,360
我可以说是房子 

79
00:04:11,360 --> 00:04:14,917
但是如果我只说房子 那么一下子积累起来有什么意义呢？

80
00:04:14,917 --> 00:04:16,709
我可以循环做一遍 

81
00:04:16,709 --> 00:04:19,190
我们至少去把那些房子分类吧

82
00:04:19,190 --> 00:04:22,550
sorted 也就是按顺序进入字符串 

83
00:04:22,550 --> 00:04:25,520
让我们继续打印每一栋房子 

84
00:04:25,520 --> 00:04:27,260
让我在我的终端窗口

85
00:04:27,260 --> 00:04:29,715
运行houses.py的Python并按Enter键 

86
00:04:29,715 --> 00:04:30,590
这就是了

87
00:04:30,590 --> 00:04:34,220
格兰芬多 拉文克劳 斯莱特林按字母顺序排列 

88
00:04:34,220 --> 00:04:37,280
即使在这上面的字典列表中 

89
00:04:37,280 --> 00:04:40,960
从技术上讲 我们看到这些的顺序是格兰芬多 格兰芬多 

90
00:04:40,960 --> 00:04:43,190
格兰芬多 斯莱特林 拉文克劳 

91
00:04:43,190 --> 00:04:46,620
因此 我的代码似乎已经正确地对它们进行了排序 

92
00:04:46,620 --> 00:04:48,110
所以这完全没问题 

93
00:04:48,110 --> 00:04:50,600
这是解决这个问题的一种方法 

94
00:04:50,600 --> 00:04:55,070
但事实证明 我们可以使用更多内置在Python语言中的东西 

95
00:04:55,070 --> 00:04:56,690
自己解决这个问题

96
00:04:56,690 --> 00:05:00,470
在这里我是在重新发明一个轮子 一个集合的概念

97
00:05:00,470 --> 00:05:02,610
在那里重复的东西被我消除了 

98
00:05:02,610 --> 00:05:04,580
所以让我继续清理我的终端窗口

99
00:05:04,580 --> 00:05:07,580
或者改变我在这里使用的对象类型 

100
00:05:07,580 --> 00:05:09,650
而不是一个列表 这也可以写

101
00:05:09,650 --> 00:05:11,960
创建一个空列表 让我继续

102
00:05:11,960 --> 00:05:15,740
并创建一个空集 借此我调用一个函数 

103
00:05:15,740 --> 00:05:18,500
它将返回Python中的某个对象

104
00:05:18,500 --> 00:05:21,950
它表示集合的概念 其中重复项自动

105
00:05:21,950 --> 00:05:22,730
被淘汰了 

106
00:05:22,730 --> 00:05:24,650
现在 我可以收紧我的代码 

107
00:05:24,650 --> 00:05:27,370
因为我自己不需要使用这个如果条件 

108
00:05:27,370 --> 00:05:29,590
我想我可以做这样的事情 

109
00:05:29,590 --> 00:05:32,650
在我的循环中 让我来做房子 

110
00:05:32,650 --> 00:05:35,800
所以它不是集合的追加 而是列表的追加 

111
00:05:35,800 --> 00:05:39,220
但它是根据文档添加到一组中的 

112
00:05:39,220 --> 00:05:42,490
那么让我继续添加这个在校生的房子 

113
00:05:42,490 --> 00:05:45,110
现在 我认为我的其余代码可以是相同的 

114
00:05:45,110 --> 00:05:48,670
我现在信任的是在Python中设置的文档

115
00:05:48,670 --> 00:05:50,860
它会为我过滤掉重复的内容 

116
00:05:50,860 --> 00:05:55,240
我可以盲目地把这些房子都加到布景里

117
00:05:55,240 --> 00:05:57,850
任何已经在那里的复制品都将消失 

118
00:05:57,850 --> 00:06:00,550
Pythonofhoues.py并回车 

119
00:06:00,550 --> 00:06:04,480
瞧 我们又回到了和这三个人的生意上 

120
00:06:04,480 --> 00:06:08,890
让我在这里暂停一下 看看现在是否有任何关于set的用法的问题 

121
00:06:08,890 --> 00:06:11,380
只是您可以使用的另一种数据类型

122
00:06:11,380 --> 00:06:14,620
您可以在以下情况下接触到的另一个类：

123
00:06:14,620 --> 00:06:16,750
解决一些像这样的问题 

124
00:06:16,750 --> 00:06:19,330
学生：我们如何在一组中找到一件物品 

125
00:06:19,330 --> 00:06:22,148
例如 在那一组中找到格兰芬多？

126
00:06:22,148 --> 00:06:24,190
大卫·J·马兰：你如何在一套中找到一件物品？

127
00:06:24,190 --> 00:06:28,030
您可以使用与我们以前针对列表所做的非常相似的语法 

128
00:06:28,030 --> 00:06:34,630
你可以像If Gryffindor in House Then那样使用语法 

129
00:06:34,630 --> 00:06:36,980
你可以按照这样的思路回答一个问题 

130
00:06:36,980 --> 00:06:40,790
因此 您也可以使用in和not in以及类似的函数 

131
00:06:40,790 --> 00:06:42,250
片场还有其他问题吗？

132
00:06:42,250 --> 00:06:45,730
学生：看 如果你有一个相似的房子名字 会发生什么？

133
00:06:45,730 --> 00:06:48,520
比方说 可能不是斯莱特林 而是

134
00:06:48,520 --> 00:06:52,000
O而不是I 将循环For循环

135
00:06:52,000 --> 00:06:56,800
在房子名字里的每一个字母里吗？

136
00:06:56,800 --> 00:06:59,270
大卫·J·马兰：它会比较这些字符串 

137
00:06:59,270 --> 00:07:01,810
所以如果斯莱特林不止一次出现 但

138
00:07:01,810 --> 00:07:04,720
略有拼写错误或大写 如果我没记错的话 

139
00:07:04,720 --> 00:07:08,230
这些看起来像是截然不同的字符串 

140
00:07:08,230 --> 00:07:11,420
所以你会在结果中得到两个版本的斯莱特林 

141
00:07:11,420 --> 00:07:14,500
然而 我们在过去已经看到了如何清理用户数据

142
00:07:14,500 --> 00:07:15,910
如果它确实可能会变得一团糟 

143
00:07:15,910 --> 00:07:19,030
我们可以强制一切大写 或全部小写 

144
00:07:19,030 --> 00:07:22,270
或者我们可以利用STR中内置的功能 

145
00:07:22,270 --> 00:07:25,300
或者是可以帮我们处理一些清理工作的书名 

146
00:07:25,300 --> 00:07:28,930
在本例中 因为数据不是来自使用输入的人类

147
00:07:28,930 --> 00:07:31,600
函数 我提前写了代码 比较安全

148
00:07:31,600 --> 00:07:33,760
假设我把房子弄对了 

149
00:07:33,760 --> 00:07:37,000
但如果它来自用户 那么这绝对是一个风险 

150
00:07:37,000 --> 00:07:39,850
请允许我将我们的注意力转回到其他一些功能上

151
00:07:39,850 --> 00:07:43,390
在这里 如果我们进一步深入研究文档 我们可以在Python中利用它

152
00:07:43,390 --> 00:07:45,130
并阅读有关其功能的更多信息 

153
00:07:45,130 --> 00:07:47,380
嗯 在一些语言中 有这样一个概念

154
00:07:47,380 --> 00:07:51,520
全局变量 因此您可以定义符合以下条件的变量

155
00:07:51,520 --> 00:07:54,280
函数的局部性 正如我们多次看到的 

156
00:07:54,280 --> 00:07:58,450
或者 如果您将一个变量放在所有函数之外 

157
00:07:58,450 --> 00:08:01,060
可能接近文件的顶部 这通常会

158
00:08:01,060 --> 00:08:03,340
被认为是一个全局变量 

159
00:08:03,340 --> 00:08:06,350
或者 在Python的世界中 它可能特定于模块 

160
00:08:06,350 --> 00:08:09,610
但无论出于何种意图和目的 它都将针对给定的程序运行

161
00:08:09,610 --> 00:08:11,080
就好像它是全球性的一样 

162
00:08:11,080 --> 00:08:13,120
然而 事实证明 如果你这样做

163
00:08:13,120 --> 00:08:16,750
当你解决一些问题时 你有多种功能

164
00:08:16,750 --> 00:08:20,590
你确实有一个或多个在这些函数之外的变量 

165
00:08:20,590 --> 00:08:26,470
您可能无法像您想象的那样轻松地更改这些变量 

166
00:08:26,470 --> 00:08:28,930
所以 确实 让我回到VS代码这里 

167
00:08:28,930 --> 00:08:32,289
稍后 我将继续创建一个新文件 如何

168
00:08:32,289 --> 00:08:34,419
名为ban.py 

169
00:08:34,419 --> 00:08:36,730
让我们继续并实现银行的概念

170
00:08:36,730 --> 00:08:40,960
在那里我们可以用各种形式存储像钱这样的东西 

171
00:08:40,960 --> 00:08:42,710
让我继续做这件事 

172
00:08:42,710 --> 00:08:44,890
让我们继续并实现一个非常简单的银行

173
00:08:44,890 --> 00:08:48,550
这只是记录我的总余额 即美元或美分的数量

174
00:08:48,550 --> 00:08:50,410
或者我可能在这个银行里存的任何东西 

175
00:08:50,410 --> 00:08:53,560
我将在顶部给自己一个称为Balance的变量 它

176
00:08:53,560 --> 00:08:55,970
是一个整数 设置为零 

177
00:08:55,970 --> 00:08:58,902
现在让我继续定义一个主要函数 就像我们经常做的那样 

178
00:08:58,902 --> 00:09:02,110
在我的主要函数中 让我继续打印出来 引用引号 

179
00:09:02,110 --> 00:09:05,290
余额 然后打印出余额本身的值 

180
00:09:05,290 --> 00:09:10,570
传递给印刷品 就像我们经常做的那样 不止一个论点 所以他们得到了

181
00:09:10,570 --> 00:09:12,520
由一个空格隔开 

182
00:09:12,520 --> 00:09:15,340
现在 既然我有一个主要的功能 真正的搭建舞台

183
00:09:15,340 --> 00:09:17,470
为了很快做更多有趣的事情 让我们

184
00:09:17,470 --> 00:09:20,860
如果这个文件的名字是这样的 我会继续做我们的惯例

185
00:09:20,860 --> 00:09:25,060
等于等于下划线Main 然后继续调用Main 

186
00:09:25,060 --> 00:09:28,450
这是一个非常短的程序 但它可能

187
00:09:28,450 --> 00:09:31,630
代表您可能如何在Python中解决一些未来的问题 

188
00:09:31,630 --> 00:09:34,390
这样你就有了一个主要功能 它最终会做

189
00:09:34,390 --> 00:09:35,780
一些有趣的东西 

190
00:09:35,780 --> 00:09:38,590
在文件的顶部 您有一个或多个变量

191
00:09:38,590 --> 00:09:41,590
放在那里很有用 因为这样你就知道它们在哪里了 

192
00:09:41,590 --> 00:09:45,560
也许不只是Main 其他函数也可以访问它们 

193
00:09:45,560 --> 00:09:46,420
让我们来看看 

194
00:09:46,420 --> 00:09:49,720
当我运行这个程序时 BANK.PY的PYTHON 

195
00:09:49,720 --> 00:09:52,870
到目前为止 我希望根据我自己的直觉 我会去

196
00:09:52,870 --> 00:09:54,880
以确保我目前的余额为零 

197
00:09:54,880 --> 00:09:59,800
也就是说 即使在第一行定义了余额变量 

198
00:09:59,800 --> 00:10:03,550
希望我还能在Main内的五个地方在线打印出来 

199
00:10:03,550 --> 00:10:07,120
即使在我的主要职能中没有定义平衡 

200
00:10:07,120 --> 00:10:07,820
我们开始吧 

201
00:10:07,820 --> 00:10:08,500
按Enter键 

202
00:10:08,500 --> 00:10:10,540
好了 平衡为零 

203
00:10:10,540 --> 00:10:12,010
因此 它似乎确实奏效了 

204
00:10:12,010 --> 00:10:15,730
即使您在函数外部声明了一个在Python中的变量 

205
00:10:15,730 --> 00:10:17,500
看起来您可以访问它 

206
00:10:17,500 --> 00:10:22,870
即使在Main这样的函数中 也可以读取该变量的值 

207
00:10:22,870 --> 00:10:24,880
好了 现在让我们来点冒险吧 

208
00:10:24,880 --> 00:10:27,380
因为这个计划真的没有解决任何人的问题 

209
00:10:27,380 --> 00:10:29,390
让我们继续实施更多的银行 

210
00:10:29,390 --> 00:10:31,880
比如将钱存入银行的能力

211
00:10:31,880 --> 00:10:33,573
并从银行取款 

212
00:10:33,573 --> 00:10:35,990
从而为我提供了更多的函数 这些函数很可能

213
00:10:35,990 --> 00:10:37,880
需要访问相同的变量 

214
00:10:37,880 --> 00:10:39,710
让我在这里清除我的终端窗口 

215
00:10:39,710 --> 00:10:42,440
现在让我先假装一下

216
00:10:42,440 --> 00:10:47,300
我有能力存入 比如说 100美元或100个硬币 

217
00:10:47,300 --> 00:10:49,190
无论这里的货币单位是什么 

218
00:10:49,190 --> 00:10:51,680
然后 也许我想直接退缩

219
00:10:51,680 --> 00:10:54,620
拿走50个同样的美元或硬币 

220
00:10:54,620 --> 00:10:57,770
现在 让我继续在Main的底部打印出来

221
00:10:57,770 --> 00:11:01,340
我的新平衡应该是什么 这样在一个理想的世界里 

222
00:11:01,340 --> 00:11:06,470
一旦我存了100 然后取了50 从0开始 

223
00:11:06,470 --> 00:11:11,430
我认为我在第八行的新余额确实应该是50 

224
00:11:11,430 --> 00:11:11,930
好的 

225
00:11:11,930 --> 00:11:13,700
但我还没有实现这些功能 

226
00:11:13,700 --> 00:11:15,620
所以让我们像过去一样做这件事 

227
00:11:15,620 --> 00:11:18,680
下面 我将继续定义另一个函数存款 

228
00:11:18,680 --> 00:11:22,640
我要说的是 对于一些硬币 需要一个名为n的参数

229
00:11:22,640 --> 00:11:23,910
或美元或类似的东西 

230
00:11:23,910 --> 00:11:25,220
我就是要这么做 

231
00:11:25,220 --> 00:11:28,280
我要继续说 平衡加等于n 

232
00:11:28,280 --> 00:11:30,230
从而改变n的值 

233
00:11:30,230 --> 00:11:33,680
我可以说得更详细一些 Balance等于Balance+n 

234
00:11:33,680 --> 00:11:36,980
但我将在这里使用较短的手写记法 

235
00:11:36,980 --> 00:11:38,510
现在 让我们来执行撤退 

236
00:11:38,510 --> 00:11:40,730
因此 定义一个名为Retroke的函数 

237
00:11:40,730 --> 00:11:43,160
它也将接受一个变量--一个参数

238
00:11:43,160 --> 00:11:45,410
N表示美元或硬币的数量 

239
00:11:45,410 --> 00:11:48,560
现在 我要继续从平衡中减去

240
00:11:48,560 --> 00:11:51,690
使用负号也等于n 

241
00:11:51,690 --> 00:11:55,010
如果此文件的名称为Main 我仍将调用Main 

242
00:11:55,010 --> 00:11:56,370
那么我做了什么呢？

243
00:11:56,370 --> 00:12:00,860
我刚才总共添加了三个函数 而不是一个 所有这些函数

244
00:12:00,860 --> 00:12:06,050
显然需要通过打印、递增来访问余额 

245
00:12:06,050 --> 00:12:08,670
或者减少它 就像我们在这里看到的 

246
00:12:08,670 --> 00:12:09,170
好的 

247
00:12:09,170 --> 00:12:11,690
让我继续下去 在这里重点介绍这三个功能 

248
00:12:11,690 --> 00:12:16,490
让我返回到我的终端窗口 运行ban.py的Python并按Enter键 

249
00:12:16,490 --> 00:12:17,420
哇哦 

250
00:12:17,420 --> 00:12:20,970
看起来我们在这里引入了一些问题 

251
00:12:20,970 --> 00:12:23,010
这些问题是什么？

252
00:12:23,010 --> 00:12:28,670
嗯 非绑定局部错误可能是我们第一次在这里看到这种错误 

253
00:12:28,670 --> 00:12:32,720
赋值前引用的局部变量余额 

254
00:12:32,720 --> 00:12:35,720
这有点误导 绝对令人困惑 

255
00:12:35,720 --> 00:12:40,700
因为我绝对在代码的顶端分配了值平衡 

256
00:12:40,700 --> 00:12:44,355
事实上 如果我向后滚动 那里没有任何变化或丢失 

257
00:12:44,355 --> 00:12:45,980
它肯定是被赋予了价值 

258
00:12:45,980 --> 00:12:49,970
现在在第12行 看起来 当存款被调用时

259
00:12:49,970 --> 00:12:53,160
我只是想再次访问该变量 

260
00:12:53,160 --> 00:12:59,610
因此 直观地说 如何解释这个错误消息 未绑定的本地错误？

261
00:12:59,610 --> 00:13:02,630
在那里 Python告诉了我们什么 它可以或不可以

262
00:13:02,630 --> 00:13:06,410
当涉及到这些所谓的全局变量时

263
00:13:06,410 --> 00:13:08,430
都在我文件的首位？

264
00:13:08,430 --> 00:13:12,110
学生：所以如果你想改变这个变量 

265
00:13:12,110 --> 00:13:17,090
您应该编写一个内部Left函数Main 

266
00:13:17,090 --> 00:13:19,740
和全局变量不变 

267
00:13:19,740 --> 00:13:20,615
大卫·J·马兰：是的 

268
00:13:20,615 --> 00:13:21,448
学生：[听不见]

269
00:13:21,448 --> 00:13:23,990
大卫·J·马兰：如果你想改变这个值 

270
00:13:23,990 --> 00:13:26,240
它可能需要是函数的本地属性 

271
00:13:26,240 --> 00:13:29,660
如果您试图在函数中更改全局变量 

272
00:13:29,660 --> 00:13:31,620
这显然行不通 

273
00:13:31,620 --> 00:13:33,800
因此 可以读取全局变量 

274
00:13:33,800 --> 00:13:36,270
读意思、访问它、打印它等等 

275
00:13:36,270 --> 00:13:40,010
但显然 您不能以相同的方式写入全局变量

276
00:13:40,010 --> 00:13:41,640
在这些功能中的一个中 

277
00:13:41,640 --> 00:13:42,140
好的 

278
00:13:42,140 --> 00:13:43,700
好吧 也许解决办法就是这么做 

279
00:13:43,700 --> 00:13:45,740
让我清除终端窗口和错误 

280
00:13:45,740 --> 00:13:47,210
也许我可以这么做 

281
00:13:47,210 --> 00:13:48,800
让我们去掉全局变量 

282
00:13:48,800 --> 00:13:52,460
让我们继续 例如 把它放在Main中 

283
00:13:52,460 --> 00:13:54,140
这种做法现在可能奏效吗？

284
00:13:54,140 --> 00:13:55,430
好的 现在让我试试这个 

285
00:13:55,430 --> 00:13:59,150
Bank.py的蟒蛇回车 

286
00:13:59,150 --> 00:14:00,980
仅凭这一点并不能解决问题 

287
00:14:00,980 --> 00:14:03,320
我仍然有一个未绑定的本地错误 

288
00:14:03,320 --> 00:14:06,860
不过 这一次是出于不同的原因 

289
00:14:06,860 --> 00:14:13,350
现在 根据定义 第二行上的余额是一个局部变量 

290
00:14:13,350 --> 00:14:16,670
局部变量是存在于函数上下文中的变量 至少

291
00:14:16,670 --> 00:14:17,390
在这种情况下 

292
00:14:17,390 --> 00:14:20,120
全局变量是相反的 不是这样的 

293
00:14:20,120 --> 00:14:21,900
例如 在我的文件顶部 

294
00:14:21,900 --> 00:14:24,500
因此 这是在Python中的另一个区别 

295
00:14:24,500 --> 00:14:27,650
如果在函数中声明变量 如main 

296
00:14:27,650 --> 00:14:29,720
就像我在二号线上做的平衡一样 

297
00:14:29,720 --> 00:14:31,760
它确实是该功能的本地功能 

298
00:14:31,760 --> 00:14:36,030
存款和取款不能访问相同变量 

299
00:14:36,030 --> 00:14:36,530
为什么？

300
00:14:36,530 --> 00:14:38,030
因为它是从本地到美因河 

301
00:14:38,030 --> 00:14:41,150
因此 你会认为我们现在有点陷入了这个恶性循环 

302
00:14:41,150 --> 00:14:45,120
好吧 也许解决方案是在全球范围内转移平衡

303
00:14:45,120 --> 00:14:47,030
因此 所有三个功能都可以访问它 

304
00:14:47,030 --> 00:14:50,840
但很明显 正如埃琳娜所指出的那样 我们不能因此改变它 

305
00:14:50,840 --> 00:14:53,930
因此 在Python中解决此问题的方法就是

306
00:14:53,930 --> 00:14:56,487
具有讽刺意味的是 这里正是这个关键词 

307
00:14:56,487 --> 00:14:58,820
这有点不同 你可能会看到 如果你

308
00:14:58,820 --> 00:15:00,380
以前用其他语言编写的程序 

309
00:15:00,380 --> 00:15:02,600
但在Python语言中确实有一个关键词叫

310
00:15:02,600 --> 00:15:06,170
GLOBAL 允许您告诉函数 嘿 这

311
00:15:06,170 --> 00:15:08,030
不是您本地的变量 

312
00:15:08,030 --> 00:15:11,460
我的意思是它是一个全局变量 我想让你们编辑它 

313
00:15:11,460 --> 00:15:14,180
因此 如果我返回到VS代码 清除我的终端

314
00:15:14,180 --> 00:15:15,810
窗口来消除该错误 

315
00:15:15,810 --> 00:15:17,870
让我继续并撤消我刚刚所做的更改

316
00:15:17,870 --> 00:15:20,450
把平衡放回我档案的首位 

317
00:15:20,450 --> 00:15:22,920
但这一次 我要做的是

318
00:15:22,920 --> 00:15:28,890
我将通知我的两个函数 它们需要更改余额的值 

319
00:15:28,890 --> 00:15:34,420
它确实是全球性的 在这里再次输入Global Balance以及

320
00:15:34,420 --> 00:15:34,920
这里 

321
00:15:34,920 --> 00:15:36,480
全球平衡 

322
00:15:36,480 --> 00:15:40,980
我仍然在第13行和第18行保留相同的代码行 即

323
00:15:40,980 --> 00:15:42,090
和减量平衡 

324
00:15:42,090 --> 00:15:46,860
但是现在使用关键字GLOBAL有点像是在暗示 

325
00:15:46,860 --> 00:15:47,610
哦 好的 

326
00:15:47,610 --> 00:15:48,782
这不是一个局部变量 

327
00:15:48,782 --> 00:15:50,490
这不是您引入的错误 

328
00:15:50,490 --> 00:15:53,860
你的意思是让我在上面编辑这个变量 

329
00:15:53,860 --> 00:15:57,750
现在 让我继续在我的终端窗口中运行BANK.PY的Python 

330
00:15:57,750 --> 00:16:03,540
我希望看到我的余额是0加100减50等于 

331
00:16:03,540 --> 00:16:04,740
事实上 现在就是这样 

332
00:16:04,740 --> 00:16:08,370
根据我在第五行的第一个打印语句 它从零开始 

333
00:16:08,370 --> 00:16:13,140
但最终结果是总共50美元 低于第八行的数字 

334
00:16:13,140 --> 00:16:15,480
让我在这里暂停一下 看看现在是否有任何问题

335
00:16:15,480 --> 00:16:18,090
在这些全局或局部变量上 

336
00:16:18,090 --> 00:16:23,250
学生：当你全局声明一个变量 并且

337
00:16:23,250 --> 00:16:26,037
在全局相同的变量中和在函数中？

338
00:16:26,037 --> 00:16:27,370
大卫·J·马兰：问得好 

339
00:16:27,370 --> 00:16:29,703
你总是在想所谓的角落案件 

340
00:16:29,703 --> 00:16:33,510
因此 如果您全局声明一个变量 比如在文件的顶部 

341
00:16:33,510 --> 00:16:38,700
然后是函数内部的同名变量 同名 

342
00:16:38,700 --> 00:16:41,940
可以说 后者将落后于前者 

343
00:16:41,940 --> 00:16:46,110
也就是说 您将能够使用后者 即局部变量 

344
00:16:46,110 --> 00:16:49,020
但它不会对全球变量产生影响 

345
00:16:49,020 --> 00:16:53,260
暂时 Python将只知道局部变量的存在 

346
00:16:53,260 --> 00:16:56,430
因此 总的来说 经验法则是 不要那样做 

347
00:16:56,430 --> 00:16:58,500
它不仅可能在您的代码中产生错误

348
00:16:58,500 --> 00:17:01,120
因为你不会完全改变你想要改变的东西 

349
00:17:01,120 --> 00:17:05,140
对于其他读者来说 这可能也不是显而易见的 

350
00:17:05,140 --> 00:17:07,680
关于全球人或本地人的其他问题？

351
00:17:07,680 --> 00:17:09,720
学生：好的 如果我们决定增加平衡呢

352
00:17:09,720 --> 00:17:11,516
作为Main函数中的参数？

353
00:17:11,516 --> 00:17:13,349
大卫·J·马兰：是的 又是一种良好的直觉 

354
00:17:13,349 --> 00:17:16,530
但在这种情况下 这也不会解决问题 

355
00:17:16,530 --> 00:17:21,510
因为如果将一个像Balance这样的变量传递给每个函数

356
00:17:21,510 --> 00:17:24,089
然后在该函数中更改它 它

357
00:17:24,089 --> 00:17:27,030
实际上只会改变它的本地副本 

358
00:17:27,030 --> 00:17:30,490
它不会改变那些功能之外的东西 

359
00:17:30,490 --> 00:17:33,330
所以我认为我们需要一个更好的方法 

360
00:17:33,330 --> 00:17:36,720
事实上 请允许我过渡到一个修改

361
00:17:36,720 --> 00:17:38,010
同样的节目 

362
00:17:38,010 --> 00:17:40,710
回想一下 我们最近看到的

363
00:17:40,710 --> 00:17:42,600
面向对象的编程 

364
00:17:42,600 --> 00:17:47,010
因此你可以模拟真实世界的实体 比如银行 

365
00:17:47,010 --> 00:17:50,490
你可以建模和封装信息

366
00:17:50,490 --> 00:17:52,680
关于现实世界中的实体 例如 

367
00:17:52,680 --> 00:17:54,580
比如某人的账户余额

368
00:17:54,580 --> 00:17:56,700
所以我建议我们真的这么做 

369
00:17:56,700 --> 00:17:58,950
让我们从bank.py开始 

370
00:17:58,950 --> 00:18:01,140
完全去掉全局变量 

371
00:18:01,140 --> 00:18:03,960
并实际使用一些面向对象的代码 

372
00:18:03,960 --> 00:18:08,550
让我定义一个名为account的类来表示某人的银行帐户 

373
00:18:08,550 --> 00:18:13,740
然后 让我继续使用init方法进行初始化 

374
00:18:13,740 --> 00:18:17,010
同样 按照惯例 它至少接受一个名为self的参数 

375
00:18:17,010 --> 00:18:20,790
我来初始化每个人的银行账户

376
00:18:20,790 --> 00:18:22,650
变成零之类的值

377
00:18:22,650 --> 00:18:23,890
我该怎么做？

378
00:18:23,890 --> 00:18:27,540
好的 我继续做自我平衡等于零 

379
00:18:27,540 --> 00:18:30,210
从而给我一个名为

380
00:18:30,210 --> 00:18:33,030
此帐户的余额初始化为零 

381
00:18:33,030 --> 00:18:35,490
但我会积极地回忆起我们是如何

382
00:18:35,490 --> 00:18:38,250
引入了这种属性的概念 

383
00:18:38,250 --> 00:18:40,720
与我的实例变量名冲突 

384
00:18:40,720 --> 00:18:42,690
所以按照惯例我会这么做 

385
00:18:42,690 --> 00:18:45,630
我要主动重命名这个实例变量

386
00:18:45,630 --> 00:18:49,740
来强调平衡 以有效地表明它是私人的 甚至

387
00:18:49,740 --> 00:18:51,570
尽管Python并没有强制这样做 

388
00:18:51,570 --> 00:18:53,940
这只是我的一个视觉线索 

389
00:18:53,940 --> 00:18:57,900
是我不应该 或者其他代码不应该触及的 

390
00:18:57,900 --> 00:18:59,970
在这个类中只有函数 

391
00:18:59,970 --> 00:19:01,540
现在 让我继续做这个 

392
00:19:01,540 --> 00:19:03,540
让我继续定义一个实际的函数

393
00:19:03,540 --> 00:19:07,620
所谓的平衡 它实际上是一种财产 

394
00:19:07,620 --> 00:19:10,380
就是恢复自我平衡 

395
00:19:10,380 --> 00:19:13,200
我要明确地说 这确实是

396
00:19:13,200 --> 00:19:15,360
这一类的财产 

397
00:19:15,360 --> 00:19:18,270
现在 让我继续并重新实现另外两个功能 

398
00:19:18,270 --> 00:19:21,850
存取款 但限于本课程的范围内 

399
00:19:21,850 --> 00:19:24,900
所以我要说 定义存款 

400
00:19:24,900 --> 00:19:27,420
它将一如既往地接受自己的论点 

401
00:19:27,420 --> 00:19:31,410
但另加一元 要存入若干美元或硬币.

402
00:19:31,410 --> 00:19:33,120
我现在该如何操纵这一点呢？

403
00:19:33,120 --> 00:19:37,560
好的 我要做自己 _天平加等于n 

404
00:19:37,560 --> 00:19:43,260
现在在这里 我要做def取款 就像存款一样 

405
00:19:43,260 --> 00:19:47,250
但在这里 我要做的是 平衡减去n 

406
00:19:47,250 --> 00:19:50,430
现在 如果我低于这门课 我就

407
00:19:50,430 --> 00:19:52,620
接下来 我将自己定义为一个主要功能

408
00:19:52,620 --> 00:19:54,390
这样我现在就可以试一试了 

409
00:19:54,390 --> 00:19:58,530
接下来 我将通过调用Account创建一个Account对象

410
00:19:58,530 --> 00:20:02,130
构造函数 它是带两个圆括号的类名

411
00:20:02,130 --> 00:20:04,350
如果我没有向init传递任何参数 

412
00:20:04,350 --> 00:20:07,830
我现在要继续 像以前一样打印出我的帐户余额 

413
00:20:07,830 --> 00:20:12,420
但要做到这一点 我将像这样访问该帐户的属性 

414
00:20:12,420 --> 00:20:16,470
我现在要继续说 再存100美元或硬币

415
00:20:16,470 --> 00:20:18,300
加100元押金 

416
00:20:18,300 --> 00:20:22,620
我将继续前进 像以前一样 现在也立即退出

417
00:20:22,620 --> 00:20:25,140
不管是什么原因 50个一样的 

418
00:20:25,140 --> 00:20:27,120
现在 我要最后一次打印

419
00:20:27,120 --> 00:20:31,383
Balance后跟Account Balance再次访问该属性 

420
00:20:31,383 --> 00:20:34,050
当然 为了让这整件事起作用 我需要一个这样的

421
00:20:34,050 --> 00:20:39,030
如果名称等于等于下划线Main 则继续并调用Main 

422
00:20:39,030 --> 00:20:42,270
现在 在我运行这个之前 您将看到它相当迅速地升级 

423
00:20:42,270 --> 00:20:45,390
我手头有一个非常简单的目标 那就是实现银行的概念 

424
00:20:45,390 --> 00:20:49,530
我最终完美地实现了这一点

425
00:20:49,530 --> 00:20:53,550
通过声明BALANCE是全局的 但然后告诉我的每个函数

426
00:20:53,550 --> 00:20:54,990
它确实是全球性的 

427
00:20:54,990 --> 00:20:59,130
但这并不是我们可以使用的最好的封装形式

428
00:20:59,130 --> 00:20:59,670
现在 

429
00:20:59,670 --> 00:21:02,100
根据我们对面向对象编程的关注 

430
00:21:02,100 --> 00:21:05,760
如果我们试图实现一些真实世界的实体 比如银行账户 

431
00:21:05,760 --> 00:21:07,770
这就是课程允许我们做的事情 

432
00:21:07,770 --> 00:21:10,380
它让我们可以解决同样的问题 也许只是一点点

433
00:21:10,380 --> 00:21:14,010
更干净 当然 如果我们要积累越来越多的函数

434
00:21:14,010 --> 00:21:15,610
或随时间推移的方法 

435
00:21:15,610 --> 00:21:19,800
所以 如果我在这里没有犯任何错误 如果我运行BANK.PY的Python并点击

436
00:21:19,800 --> 00:21:23,550
现在进入 你会看到它工作得很好 

437
00:21:23,550 --> 00:21:26,490
因为在Python类的世界里 

438
00:21:26,490 --> 00:21:29,550
根据定义 这些所谓的实例变量

439
00:21:29,550 --> 00:21:33,180
该类中的所有方法都可以访问

440
00:21:33,180 --> 00:21:39,240
因为我们都是通过这个特殊的参数本身访问它们 

441
00:21:39,240 --> 00:21:40,440
那么 用哪种方式来做呢？

442
00:21:40,440 --> 00:21:43,260
对于一个相当小的脚本 其中您只需

443
00:21:43,260 --> 00:21:47,728
试图实现一个包含一些全局信息的脚本 

444
00:21:47,728 --> 00:21:50,520
就像你需要在别处操纵的账户余额一样 

445
00:21:50,520 --> 00:21:52,930
GLOBAL关键字是该问题的一种解决方案 

446
00:21:52,930 --> 00:21:55,890
但总的来说 在许多语言中 

447
00:21:55,890 --> 00:21:58,800
在某种程度上 其中使用了全局变量

448
00:21:58,800 --> 00:22:03,030
因为事情可能很快就会变得一团糟 所以人们往往会皱起眉头 

449
00:22:03,030 --> 00:22:07,470
而且你的信息的确切位置很快就会变得不那么明显

450
00:22:07,470 --> 00:22:10,150
存储 如果有些在这里 有些在你的函数中 

451
00:22:10,150 --> 00:22:15,180
因此 一般来说 经验法则是谨慎使用全局变量 

452
00:22:15,180 --> 00:22:18,390
尽管从技术上讲 在Python中 这些全局变量

453
00:22:18,390 --> 00:22:21,870
从技术上讲 对于我们的模块来说是本地的 如果我们确实实现了

454
00:22:21,870 --> 00:22:23,830
一个图书馆 而不仅仅是一个程序 

455
00:22:23,830 --> 00:22:27,010
因此 简而言之 尽量少用全局变量 

456
00:22:27,010 --> 00:22:30,120
但当你这样做的时候 同样的问题也有解决方案 

457
00:22:30,120 --> 00:22:35,280
现在是关于全球化的问题 还是关于我们重新实施相同理念的问题

458
00:22:35,280 --> 00:22:40,030
但是使用成熟的面向对象编程呢？

459
00:22:40,030 --> 00:22:44,163
学生：我只是想问 这个属性是做什么的？

460
00:22:44,163 --> 00:22:45,830
大卫·J·马兰：这处房产的用途 

461
00:22:45,830 --> 00:22:47,740
所以如果我回到VS Code 你会看到

462
00:22:47,740 --> 00:22:50,530
这是我们在课上学到的一种技术

463
00:22:50,530 --> 00:22:52,150
关于面向对象的编程 

464
00:22:52,150 --> 00:22:57,400
因此 属性是以某种方式保护的实例变量 

465
00:22:57,400 --> 00:23:01,490
它允许我控制它可以读写 

466
00:23:01,490 --> 00:23:04,870
所以在这种情况下 我只有通常所说的二传手 

467
00:23:04,870 --> 00:23:05,710
或者抱歉 

468
00:23:05,710 --> 00:23:08,372
在这种情况下 我只有通常所说的获取器 

469
00:23:08,372 --> 00:23:10,330
而且这里没有提到Getter这个词 

470
00:23:10,330 --> 00:23:12,250
这只是“财产手段” 

471
00:23:12,250 --> 00:23:15,550
这种功能平衡将允许我 回忆一下 

472
00:23:15,550 --> 00:23:18,160
使用这样的语法 我可以假装

473
00:23:18,160 --> 00:23:22,360
好像Balance确实是不带下划线的实例变量 

474
00:23:22,360 --> 00:23:27,220
但我现在可以防止像我在Main中那样的代码试图改变平衡 

475
00:23:27,220 --> 00:23:29,650
因为我没有二传手 所以我不会

476
00:23:29,650 --> 00:23:32,500
能够执行类似帐户余额等于1,000的操作

477
00:23:32,500 --> 00:23:36,370
只给自己1000或硬币 因为我还没有定义二传手 

478
00:23:36,370 --> 00:23:39,460
因此 根据我们对面向对象编程的关注 

479
00:23:39,460 --> 00:23:42,910
这些属性只是允许我进行一些更细粒度的控制 

480
00:23:42,910 --> 00:23:46,750
一些语言允许您定义变量 可以说 

481
00:23:46,750 --> 00:23:47,380
常量 

482
00:23:47,380 --> 00:23:49,870
也就是说 一旦您为它们设置了一个值 

483
00:23:49,870 --> 00:23:52,297
您不能更改该变量的值 

484
00:23:52,297 --> 00:23:54,130
这往往是一件好事 因为它

485
00:23:54,130 --> 00:23:55,810
允许您进行防御性编程 

486
00:23:55,810 --> 00:23:58,570
以防你不小心 或者其他人 

487
00:23:58,570 --> 00:24:01,640
意外地试图修改该变量的值 

488
00:24:01,640 --> 00:24:06,430
如果您在某种语言中将其声明为常量 则不能更改它 

489
00:24:06,430 --> 00:24:09,490
或者通常不费很大力气就不能改变 

490
00:24:09,490 --> 00:24:13,150
不幸的是 在Python语言中 我们再次使用了这种荣誉系统 

491
00:24:13,150 --> 00:24:15,430
我们有惯例来表明某件事

492
00:24:15,430 --> 00:24:17,260
应该像对待常量一样对待 

493
00:24:17,260 --> 00:24:19,760
但这实际上并不是由语言强制执行的 

494
00:24:19,760 --> 00:24:22,000
举个例子 让我回到VS代码 

495
00:24:22,000 --> 00:24:25,240
让我创建一个新文件 比如 名为meows.py 

496
00:24:25,240 --> 00:24:28,690
让我们看看我们是否能实现猫在屏幕上喵喵叫的概念 

497
00:24:28,690 --> 00:24:31,510
所以我会用代码meows.py 

498
00:24:31,510 --> 00:24:34,360
在meows.py中 让我举个例子

499
00:24:34,360 --> 00:24:38,120
然后实现一个非常简单的程序 让一只猫叫三次 

500
00:24:38,120 --> 00:24:39,280
不如这样吧

501
00:24:39,280 --> 00:24:45,260
对于i在3的范围内 继续并打印出来 引号内 喵 

502
00:24:45,260 --> 00:24:45,760
好吧

503
00:24:45,760 --> 00:24:48,580
好吧 我们已经看到在过去我们如何可以清理这一点 

504
00:24:48,580 --> 00:24:50,455
例如 如果我没有用i 

505
00:24:50,455 --> 00:24:52,720
我还不如用Python的方法把它的名字

506
00:24:52,720 --> 00:24:55,900
要加下划线的变量 尽管它没有函数

507
00:24:55,900 --> 00:24:56,710
效果在这里 

508
00:24:56,710 --> 00:25:01,210
但这里我们有三个随机硬编码的 

509
00:25:01,210 --> 00:25:02,950
在我的代码中显式输入 

510
00:25:02,950 --> 00:25:06,670
当你的代码只有两行时 这完全不是什么大不了的事情 

511
00:25:06,670 --> 00:25:09,610
但想象一下 这是一个更大的计划 

512
00:25:09,610 --> 00:25:10,930
或者甚至数百行 

513
00:25:10,930 --> 00:25:14,890
想象一下其中一条线上有个3 

514
00:25:14,890 --> 00:25:17,050
你不会轻易找到那三个的 

515
00:25:17,050 --> 00:25:18,640
这很容易被忽视

516
00:25:18,640 --> 00:25:20,440
你或同事或其他人

517
00:25:20,440 --> 00:25:25,460
在你的代码里硬编码了一个像3这样的神奇值

518
00:25:25,460 --> 00:25:28,540
因此 这往往是最佳实践 不仅在Python中 而且在其他语言中 

519
00:25:28,540 --> 00:25:31,660
同样 任何时候你有一个常数 

520
00:25:31,660 --> 00:25:34,030
就像永远不会改变的数字3 

521
00:25:34,030 --> 00:25:37,760
是至少让它冒泡 把它放在代码的顶部 

522
00:25:37,760 --> 00:25:41,380
这样代码的常量值就很明显了 

523
00:25:41,380 --> 00:25:42,910
所以 我的意思是 

524
00:25:42,910 --> 00:25:44,860
在这个文件的顶部 它可能会

525
00:25:44,860 --> 00:25:48,370
明天对同事说清楚一点 坦白地说 对我来说 

526
00:25:48,370 --> 00:25:52,150
在我忘了今天做了什么之后 

527
00:25:52,150 --> 00:25:53,650
并将其设置为3 

528
00:25:53,650 --> 00:25:57,340
然后 不是在这里硬编码三个或更低 

529
00:25:57,340 --> 00:26:01,750
在一个更大的程序中 让我继续传递变量的值

530
00:26:01,750 --> 00:26:02,570
到我的循环 

531
00:26:02,570 --> 00:26:04,630
所以现在对我来说很明显

532
00:26:04,630 --> 00:26:06,940
猫咪叫的次数显然就是猫咪叫的次数 

533
00:26:06,940 --> 00:26:10,300
如果我想改变它 我唯一需要改变的代码

534
00:26:10,300 --> 00:26:11,643
在我档案的最顶端 

535
00:26:11,643 --> 00:26:14,560
我不需要到处钓鱼 也不需要想着什么会坏掉 

536
00:26:14,560 --> 00:26:15,610
我需要改变什么 

537
00:26:15,610 --> 00:26:19,330
我只知道我可以在顶部更改这些常量 

538
00:26:19,330 --> 00:26:23,050
不过 使用Python的问题在于 它实际上并不

539
00:26:23,050 --> 00:26:24,640
使变量保持不变 

540
00:26:24,640 --> 00:26:27,640
这在Python和其他一些语言中确实是一种约定

541
00:26:27,640 --> 00:26:31,390
当你想要向世界表明的时候 至少要把你的变量大写

542
00:26:31,390 --> 00:26:33,370
你不应该碰这个 

543
00:26:33,370 --> 00:26:34,720
它是恒定不变的 

544
00:26:34,720 --> 00:26:38,067
但在我的代码中几乎没有任何东西阻止我说 

545
00:26:38,067 --> 00:26:38,650
你猜怎么着？

546
00:26:38,650 --> 00:26:41,440
今天 我感觉自己像是四只猫 

547
00:26:41,440 --> 00:26:42,460
这会奏效的 

548
00:26:42,460 --> 00:26:44,260
在其他语言中 虽然通常有

549
00:26:44,260 --> 00:26:47,200
句法上的关键字或某些其他机制

550
00:26:47,200 --> 00:26:51,940
将允许您阻止当前执行第三行 

551
00:26:51,940 --> 00:26:55,510
因此 当您尝试运行代码时 实际上会收到一条错误消息

552
00:26:55,510 --> 00:26:57,770
明确地说 你不能这样做 

553
00:26:57,770 --> 00:27:00,370
所以 在荣誉体系上 Python又一次显得更加重要了

554
00:27:00,370 --> 00:27:02,680
相反 当涉及到这些约定时 

555
00:27:02,680 --> 00:27:06,190
现在 事实证明还有其他类型的常量 引用不引用 

556
00:27:06,190 --> 00:27:07,932
这是巨蟒通常会表现出来的 

557
00:27:07,932 --> 00:27:10,640
事实上 让我继续下去 改变一下这一点 

558
00:27:10,640 --> 00:27:12,140
让我删除这个版本的猫咪 

559
00:27:12,140 --> 00:27:15,430
让我再次介绍一下我们讨论过的一个班级

560
00:27:15,430 --> 00:27:18,070
面向对象编程的一部分 就像表示

561
00:27:18,070 --> 00:27:20,710
一只猫 另一个真实世界的实体 

562
00:27:20,710 --> 00:27:23,650
回想一下 在类中 您不仅可以拥有

563
00:27:23,650 --> 00:27:26,170
实例变量和类变量 

564
00:27:26,170 --> 00:27:30,430
也就是说 类中的变量本身并不在自身内部 

565
00:27:30,430 --> 00:27:33,490
但是类中的所有方法都可以访问它们 

566
00:27:33,490 --> 00:27:36,340
这里也是一样 有一个惯例 但没有强制执行

567
00:27:36,340 --> 00:27:40,840
通过拥有类常量的Python 从而在类内部 

568
00:27:40,840 --> 00:27:45,220
您可能希望有一个应该、应该、不应该更改的变量 

569
00:27:45,220 --> 00:27:49,040
但您只是想通过将其名称大写来在视觉上表明这一点 

570
00:27:49,040 --> 00:27:51,820
例如 如果一只猫的默认猫叫声数量

571
00:27:51,820 --> 00:27:55,480
应该是三个 我可以在我的班级里

572
00:27:55,480 --> 00:27:58,360
但在我定义的任何方法之外

573
00:27:58,360 --> 00:28:02,390
创建一个全部用相同的值大写的类变量 

574
00:28:02,390 --> 00:28:05,500
然后 如果我想创造一种方法 比如猫叫 

575
00:28:05,500 --> 00:28:09,710
例如 正如我们所知 作为一个实例方法 它可能会接受self 

576
00:28:09,710 --> 00:28:13,130
然后 我可能会在这里用我的循环来下划线--

577
00:28:13,130 --> 00:28:14,380
现在我需要访问这个 

578
00:28:14,380 --> 00:28:17,980
约定将会说猫叫以表明

579
00:28:17,980 --> 00:28:22,570
我想要与名为cat的类相关联的猫叫声变量 

580
00:28:22,570 --> 00:28:25,780
然后 我将继续打印出其中一条猫咪叫声 

581
00:28:25,780 --> 00:28:29,230
现在 在我的代码底部 在类之外 让我继续

582
00:28:29,230 --> 00:28:30,380
做这样的事情 

583
00:28:30,380 --> 00:28:33,340
让我使用CAT构造函数实例化一只猫 

584
00:28:33,340 --> 00:28:34,690
请注意这一点很重要 

585
00:28:34,690 --> 00:28:38,710
根据我们对OOP的讨论 这个类是按照约定大写的 

586
00:28:38,710 --> 00:28:41,360
但这里的变量是小写的 

587
00:28:41,360 --> 00:28:44,030
我可以称它为C或其他任何东西 

588
00:28:44,030 --> 00:28:47,440
但我有点喜欢这里叫它小猫和大猫的对称性 

589
00:28:47,440 --> 00:28:48,730
可以这么说 就在这里 

590
00:28:48,730 --> 00:28:51,550
现在 如果我想让这只特别的猫叫

591
00:28:51,550 --> 00:28:55,660
默认的三次 我可以像这样做猫咪 

592
00:28:55,660 --> 00:29:01,990
该方法将在第五行中访问该类常量 

593
00:29:01,990 --> 00:29:04,390
但同样 它只是在事实中是不变的--

594
00:29:04,390 --> 00:29:08,770
只是在你不应该碰它的意义上 并不是说它实际上

595
00:29:08,770 --> 00:29:11,500
将由语言强制执行 

596
00:29:11,500 --> 00:29:15,040
那么 让我继续使用Python of meows.py来运行它 

597
00:29:15,040 --> 00:29:18,250
它就在那里 我们的三只猫叫 喵 喵 

598
00:29:18,250 --> 00:29:22,480
事实证明 Python是一种动态类型的语言 

599
00:29:22,480 --> 00:29:24,520
也就是说 它不是强类型的 

600
00:29:24,520 --> 00:29:27,520
因此 当你想要一个整型的时候 你必须告诉程序

601
00:29:27,520 --> 00:29:28,870
您使用的是一个整型 

602
00:29:28,870 --> 00:29:32,350
您不必告诉程序您正在使用字符串或浮点数 

603
00:29:32,350 --> 00:29:34,150
或者一套 或者其他任何东西 

604
00:29:34,150 --> 00:29:37,450
一般来说 到目前为止 你和我 当我们创造变量时 

605
00:29:37,450 --> 00:29:39,190
我们只需为变量命名即可 

606
00:29:39,190 --> 00:29:42,850
我们经常在等号中给它赋值 

607
00:29:42,850 --> 00:29:44,950
老实说 Python只是一种动态

608
00:29:44,950 --> 00:29:47,590
找出它是哪种类型的变量 

609
00:29:47,590 --> 00:29:51,790
如果是 引用单引号Hello world 变量将是一个str 

610
00:29:51,790 --> 00:29:55,820
如果它是50 那么变量的整数将是一个整型 

611
00:29:55,820 --> 00:30:00,310
现在 在其他语言中 包括C、C++和Java等 

612
00:30:00,310 --> 00:30:05,050
程序员有时需要指定哪些类型

613
00:30:05,050 --> 00:30:07,810
你想要的东西的变量 

614
00:30:07,810 --> 00:30:11,710
这样做的好处是它帮助您更容易地检测到错误 

615
00:30:11,710 --> 00:30:15,760
因为如果您打算让变量存储字符串或整数 

616
00:30:15,760 --> 00:30:19,900
但是您不小心存储了一个整数或字符串 反之亦然

617
00:30:19,900 --> 00:30:24,583
否则 您的语言可以为您检测到这种错误 

618
00:30:24,583 --> 00:30:26,500
例如 当你去运行程序时 

619
00:30:26,500 --> 00:30:28,420
它可以说 不 你犯了一个错误 

620
00:30:28,420 --> 00:30:31,840
您可以在您的实际用户检测到相同数量之前修复该问题 

621
00:30:31,840 --> 00:30:35,770
在Python语言中也是如此 这是一个更友好的环境

622
00:30:35,770 --> 00:30:38,680
您可以在其中提供有关Python本身的提示

623
00:30:38,680 --> 00:30:41,230
关于变量应该是什么类型 

624
00:30:41,230 --> 00:30:44,620
但语言本身并没有严格执行这些规定 

625
00:30:44,620 --> 00:30:48,820
相反 您可以使用一个工具来告诉您是否

626
00:30:48,820 --> 00:30:50,620
您正确地使用了变量 

627
00:30:50,620 --> 00:30:53,440
但它通常是一个以程序员的身份运行的工具

628
00:30:53,440 --> 00:30:56,140
在你真正向世界发布你的代码之前 

629
00:30:56,140 --> 00:30:59,770
或者 如果你有某种自动化的流程 你可以运行这种工具

630
00:30:59,770 --> 00:31:03,730
就像您可以使用其他程序重新格式化或链接到您的代码一样

631
00:31:03,730 --> 00:31:06,470
在你真正将其公之于众之前 

632
00:31:06,470 --> 00:31:09,220
那么 我们应该如何使用这些所谓的类型提示呢？

633
00:31:09,220 --> 00:31:12,700
好的 它们在Python自己的文档中的常见位置进行了记录 

634
00:31:12,700 --> 00:31:14,500
事实证明 有一个项目

635
00:31:14,500 --> 00:31:17,950
非常流行的检查代码是否

636
00:31:17,950 --> 00:31:19,990
坚持你自己的类型提示 

637
00:31:19,990 --> 00:31:22,052
这个程序在这里被称为mypy 

638
00:31:22,052 --> 00:31:23,260
这只是几个中的一个 

639
00:31:23,260 --> 00:31:26,020
但这个特别受欢迎 可以很容易地安装

640
00:31:26,020 --> 00:31:29,380
以通常的方式使用pip安装mypy 

641
00:31:29,380 --> 00:31:31,900
它自己的文档在这里的URL上 

642
00:31:31,900 --> 00:31:36,160
但是我们将非常简单地使用它来检查我们的变量是否确实

643
00:31:36,160 --> 00:31:37,660
使用正确的类型 

644
00:31:37,660 --> 00:31:39,550
那么 我们该如何着手做这件事呢？

645
00:31:39,550 --> 00:31:43,150
好了 让我回到VS代码 清除我的终端窗口 

646
00:31:43,150 --> 00:31:46,180
事实上 删除当前的meows.py 

647
00:31:46,180 --> 00:31:49,240
让我们实现一个不同版本的猫咪 非常简单

648
00:31:49,240 --> 00:31:52,303
有一个名为猫咪的功能 可以在屏幕上进行实际的猫咪叫声 

649
00:31:52,303 --> 00:31:54,970
然后 我将继续向下调用该函数

650
00:31:54,970 --> 00:31:55,690
接近底部 

651
00:31:55,690 --> 00:31:58,357
为了简单起见 我不打算费心使用main函数

652
00:31:58,357 --> 00:32:01,090
这样我们就可以一如既往地专注于新事物 

653
00:32:01,090 --> 00:32:03,940
所以在这里 我们定义了一个名为meow的函数 

654
00:32:03,940 --> 00:32:08,920
猫叫需要很多次 比如n代表数字 

655
00:32:08,920 --> 00:32:11,170
在这个函数内部 我要做的是

656
00:32:11,170 --> 00:32:16,430
我通常在n的范围内加下划线 继续打印 引用不引用 

657
00:32:16,430 --> 00:32:16,930
喵星人 

658
00:32:16,930 --> 00:32:19,900
因此 根据我们前面的代码 我认为这是正确的 

659
00:32:19,900 --> 00:32:22,158
我没有费心将变量定义为I 

660
00:32:22,158 --> 00:32:24,950
我改为使用下划线 因为我不会在任何地方使用它 

661
00:32:24,950 --> 00:32:27,580
但我想我现在有了一个工作职能 它的人生目标

662
00:32:27,580 --> 00:32:31,400
就是猫叫0次、1次、2次、3次或更多次 

663
00:32:31,400 --> 00:32:34,073
好的 让我们再次使用这个函数 不用担心main 

664
00:32:34,073 --> 00:32:37,240
我只会把我的功能放在最上面 因为只有一个 

665
00:32:37,240 --> 00:32:40,292
我将把我的代码写在第六行 

666
00:32:40,292 --> 00:32:41,500
所以我要给自己--

667
00:32:41,500 --> 00:32:43,692
我要向用户索要一个号码 

668
00:32:43,692 --> 00:32:45,400
我将继续并提示他们

669
00:32:45,400 --> 00:32:48,730
以惯常的方式猫叫那么多次 

670
00:32:48,730 --> 00:32:52,870
现在 我要继续用这个号码叫猫咪 

671
00:32:52,870 --> 00:32:56,080
现在 你们中的一些人可能会看到我已经做错了什么 

672
00:32:56,080 --> 00:32:57,460
但也许我自己并不这样认为 

673
00:32:57,460 --> 00:33:01,330
所以让我进入我的终端窗口并运行Python of meows.py 

674
00:33:01,330 --> 00:33:03,220
这样做的目的是为了促使我 

675
00:33:03,220 --> 00:33:04,460
这似乎奏效了 

676
00:33:04,460 --> 00:33:05,860
我要打三个字 

677
00:33:05,860 --> 00:33:10,690
我希望现在的猫咪功能会打印出三次猫咪 

678
00:33:10,690 --> 00:33:11,800
进来吧 

679
00:33:11,800 --> 00:33:12,850
但是没有 

680
00:33:12,850 --> 00:33:17,200
这里有某种类型的错误 无法解释字符串对象

681
00:33:17,200 --> 00:33:18,760
作为一个整数 

682
00:33:18,760 --> 00:33:21,590
为什么会这样呢？

683
00:33:21,590 --> 00:33:23,530
为什么会这样呢？

684
00:33:23,530 --> 00:33:28,230
学生：因为输入函数返回的是字符串 而不是整数 

685
00:33:28,230 --> 00:33:29,230
大卫·J·马兰：没错 

686
00:33:29,230 --> 00:33:32,530
INPUT函数返回字符串或字符串 而不是整型 

687
00:33:32,530 --> 00:33:35,530
所以在过去 当然 我们对这个问题的解决方案

688
00:33:35,530 --> 00:33:39,250
通过使用int函数将字符串转换为int 

689
00:33:39,250 --> 00:33:42,010
但现在 让我开始更有防御性的编程

690
00:33:42,010 --> 00:33:46,660
所以老实说 我根本没有发现自己处于这种情况 

691
00:33:46,660 --> 00:33:48,260
让我继续做这件事 

692
00:33:48,260 --> 00:33:51,760
让我将所谓的类型提示添加到我的函数中

693
00:33:51,760 --> 00:33:56,890
显式地为meow指定应该传递什么类型的变量 

694
00:33:56,890 --> 00:33:59,830
现在 我将继续更改代码的第一行

695
00:33:59,830 --> 00:34:05,020
和我的函数来指定n冒号应该是整型

696
00:34:05,020 --> 00:34:07,420
这是一个类型提示 事实是我已经

697
00:34:07,420 --> 00:34:10,929
添加了冒号、空格 单词int没有创建

698
00:34:10,929 --> 00:34:12,920
另一个整型或类似的东西 

699
00:34:12,920 --> 00:34:17,170
这只是一个提示 一个注解 对Python来说 

700
00:34:17,170 --> 00:34:22,190
左边这个名为n的变量应该是一个整型 

701
00:34:22,190 --> 00:34:25,330
不幸的是 Python本身并不关心这一点 

702
00:34:25,330 --> 00:34:28,150
因为同样 这些类型提示不是由语言强制执行的 

703
00:34:28,150 --> 00:34:29,650
这是经过精心设计的 

704
00:34:29,650 --> 00:34:31,540
语言本身和社区更喜欢

705
00:34:31,540 --> 00:34:34,719
Python应该是动态类型的 而不是强类型的

706
00:34:34,719 --> 00:34:36,760
要求这些东西是真的

707
00:34:36,760 --> 00:34:41,360
但是如果我运行meows.py 再次输入3 同样的错误仍然存在 

708
00:34:41,360 --> 00:34:46,989
但是让我来试试这个mypy程序 一个程序的例子 

709
00:34:46,989 --> 00:34:48,530
理解类型提示 

710
00:34:48,530 --> 00:34:53,500
如果我主动运行它 我自己就能在代码中找到这样的bug

711
00:34:53,500 --> 00:34:58,030
在我 或者更糟的是 一个用户 实际运行并遇到一些神秘的东西之前 

712
00:34:58,030 --> 00:34:59,770
比如这里的类型错误 

713
00:34:59,770 --> 00:35:05,260
让我清除我的终端窗口 这次运行我的空间meows.py 

714
00:35:05,260 --> 00:35:10,300
所以我将在我的程序中运行mypy 但我不会运行Python本身 

715
00:35:10,300 --> 00:35:13,280
当我按回车键时 我们会看到这个 

716
00:35:13,280 --> 00:35:13,780
好吧

717
00:35:13,780 --> 00:35:17,770
我们现在看到我在第七行发现了一个明显的错误 

718
00:35:17,770 --> 00:35:23,080
错误 meow的参数1具有不兼容的类型str（应为int） 

719
00:35:23,080 --> 00:35:24,670
所以这仍然是一个错误消息 

720
00:35:24,670 --> 00:35:27,880
但我的用户不会使用mypy 

721
00:35:27,880 --> 00:35:31,240
这是一个你和我作为程序员都会使用的程序 

722
00:35:31,240 --> 00:35:35,200
因为我们已经运行了这段代码 例如 

723
00:35:35,200 --> 00:35:39,400
我现在甚至可以在代码被调用或运行之前看到 

724
00:35:39,400 --> 00:35:43,730
哦 我好像用我的论点来喵错了 

725
00:35:43,730 --> 00:35:45,880
我最好想办法解决这个问题 

726
00:35:45,880 --> 00:35:49,030
其实我可以给你一些提示

727
00:35:49,030 --> 00:35:53,650
类型提示 甚至是我自己的变量 以便以另一种方式捕获它 

728
00:35:53,650 --> 00:35:57,640
如果我在第六行知道我已经创建了一个变量number 

729
00:35:57,640 --> 00:36:02,560
我已经知道我在给input的返回值赋值equal

730
00:36:02,560 --> 00:36:07,120
我可以给我的电脑和类似的工具另一个提示 然后说 你知道吗？

731
00:36:07,120 --> 00:36:10,510
这个叫做number的变量也应该是一个int 

732
00:36:10,510 --> 00:36:14,650
也就是说 如果我现在开始养成注释的习惯 

733
00:36:14,650 --> 00:36:17,740
所有函数的变量和参数

734
00:36:17,740 --> 00:36:20,530
也许我的电脑能帮我找到

735
00:36:20,530 --> 00:36:24,430
在我开始运行Python之前 我也会很快地 

736
00:36:24,430 --> 00:36:26,050
我们再来一次 

737
00:36:26,050 --> 00:36:28,930
Mypy的meows.py和点击回车 

738
00:36:28,930 --> 00:36:31,870
这一次 请注意mypy实际上找到了

739
00:36:31,870 --> 00:36:34,120
犯错误的速度要快一点 

740
00:36:34,120 --> 00:36:38,860
请注意 这一次它在第六行发现 错误 不兼容的类型

741
00:36:38,860 --> 00:36:42,820
赋值表达式的类型为str 变量的类型为int 

742
00:36:42,820 --> 00:36:45,940
所以在我还没来得及叫猫咪之前 

743
00:36:45,940 --> 00:36:50,350
第六行 通过此类型提示 在由mypy使用和分析时

744
00:36:50,350 --> 00:36:52,060
帮我找到了 哦 等一下 

745
00:36:52,060 --> 00:36:55,060
我不应该为输入的返回值赋值

746
00:36:55,060 --> 00:36:57,920
添加到我的变量名为number的位置 

747
00:36:57,920 --> 00:36:58,420
为什么？

748
00:36:58,420 --> 00:37:01,460
Mypy刚才向我指出 返回一个字符串 

749
00:37:01,460 --> 00:37:02,890
我正在等待一个整型 

750
00:37:02,890 --> 00:37:05,002
现在让我来解决这个问题吧 

751
00:37:05,002 --> 00:37:06,460
因此 让我清除我的终端窗口 

752
00:37:06,460 --> 00:37:08,380
现在 让我来做你们大多数人可能会做的事情

753
00:37:08,380 --> 00:37:11,380
在经历了这么多周之后 我想我一开始就应该这么做 

754
00:37:11,380 --> 00:37:15,580
但现在 让我们继续将输入的返回值转换为整数 

755
00:37:15,580 --> 00:37:17,950
为了今天的目的 我不会尝试

756
00:37:17,950 --> 00:37:19,733
以捕捉任何异常或类似情况 

757
00:37:19,733 --> 00:37:22,400
我们只需要假设用户正确地输入了这些内容 

758
00:37:22,400 --> 00:37:26,830
现在 让我继续运行mypy of meows.py 

759
00:37:26,830 --> 00:37:31,450
不仅向我的参数、函数添加了类型提示 

760
00:37:31,450 --> 00:37:33,940
赋给我的变量 在第六行 

761
00:37:33,940 --> 00:37:36,620
我现在也解决了这个问题本身 

762
00:37:36,620 --> 00:37:38,090
让我继续运行mypy 

763
00:37:38,090 --> 00:37:41,480
并且成功 在一个源文件中没有发现任何问题 

764
00:37:41,480 --> 00:37:44,900
现在 对我来说更合理的是去经营一些

765
00:37:44,900 --> 00:37:49,280
就像猫叫声中的巨蟒一样 至少当我输入三个字时 我会相信它

766
00:37:49,280 --> 00:37:51,560
我不会遇到打字错误 

767
00:37:51,560 --> 00:37:54,680
也就是说 作为一名程序员 我没有搞砸

768
00:37:54,680 --> 00:37:56,100
我的变量的类型 

769
00:37:56,100 --> 00:37:56,600
为什么？

770
00:37:56,600 --> 00:37:58,642
因为我一开始写代码的时候 

771
00:37:58,642 --> 00:38:00,620
我提供了这些注释 这些提示

772
00:38:00,620 --> 00:38:04,820
告诉像mypy这样的工具我的意图最好是

773
00:38:04,820 --> 00:38:07,730
与实际代码所做的事情保持一致 

774
00:38:07,730 --> 00:38:13,160
让我在这里暂停一下 看看现在是否有关于类型提示或mypy的问题 

775
00:38:13,160 --> 00:38:17,030
学生：这是常见的吗 或者这些被使用的有多常见？

776
00:38:17,030 --> 00:38:20,960
或者只是它更多地用于更复杂的代码中

777
00:38:20,960 --> 00:38:26,150
很难保证你真的

778
00:38:26,150 --> 00:38:28,900
使用正确的类型 就像使用变量一样

779
00:38:28,900 --> 00:38:30,442
大卫·J·马兰：这是个好问题 

780
00:38:30,442 --> 00:38:32,000
这是个见仁见智的问题 

781
00:38:32,000 --> 00:38:36,230
Python被设计得更通用和灵活 

782
00:38:36,230 --> 00:38:39,980
其中一些细节 部分是为了可写性 

783
00:38:39,980 --> 00:38:42,407
编写代码更容易、更快 部分原因是为了提高性能

784
00:38:42,407 --> 00:38:44,240
这样像Python这样的程序

785
00:38:44,240 --> 00:38:45,710
去检查这些细节 

786
00:38:45,710 --> 00:38:47,420
我们可以直接进入代码

787
00:38:47,420 --> 00:38:50,990
然而 实际情况是 

788
00:38:50,990 --> 00:38:54,120
对你的代码的正确性来说是件好事 

789
00:38:54,120 --> 00:38:54,620
为什么要这样？

790
00:38:54,620 --> 00:38:58,970
因为像mypy这样的程序可以在你的代码运行之前 

791
00:38:58,970 --> 00:39:01,430
如果已经知道有错误的话 

792
00:39:01,430 --> 00:39:04,280
它往往有利于防御性编程 

793
00:39:04,280 --> 00:39:09,560
因此 在Python生态系统中 

794
00:39:09,560 --> 00:39:12,260
你可以用这种方式来注释你的类型 

795
00:39:12,260 --> 00:39:14,900
您可以使用工具来使用这些类型提示 

796
00:39:14,900 --> 00:39:17,630
但到目前为止 Python本身并没有强制执行

797
00:39:17,630 --> 00:39:20,270
或期望执行这些公约 

798
00:39:20,270 --> 00:39:23,420
在更大的代码库中 在专业代码库中 

799
00:39:23,420 --> 00:39:27,548
商业代码库 可能取决于项目经理

800
00:39:27,548 --> 00:39:29,840
或者取决于工程团队 

801
00:39:29,840 --> 00:39:31,620
希望自己使用类型提示 

802
00:39:31,620 --> 00:39:32,120
为什么要这样？

803
00:39:32,120 --> 00:39:34,760
如果它能减少漏洞的可能性 

804
00:39:34,760 --> 00:39:39,260
事实上 让我现在提议 我--想象一个情况 

805
00:39:39,260 --> 00:39:45,020
而不是期望meow打印meow meow meow一些次数 

806
00:39:45,020 --> 00:39:48,800
假设我不小心假设meow函数

807
00:39:48,800 --> 00:39:51,650
只返回几次meow 

808
00:39:51,650 --> 00:39:53,990
例如 我们在关注单元测试时看到 

809
00:39:53,990 --> 00:39:57,260
有返回值的函数是件好事

810
00:39:57,260 --> 00:40:00,770
不管是int还是字符串 

811
00:40:00,770 --> 00:40:02,460
比如自己打印东西

812
00:40:02,460 --> 00:40:04,370
所以 也许我仍然保持着这种心态 

813
00:40:04,370 --> 00:40:07,160
我只是一时误会了

814
00:40:07,160 --> 00:40:11,810
这种猫叫返回一个值 就像猫叫 猫叫 或者猫叫 

815
00:40:11,810 --> 00:40:15,620
一大串猫咪 而不是自己打印出来的 

816
00:40:15,620 --> 00:40:18,080
就像现在三号线上很明显的那样 

817
00:40:18,080 --> 00:40:21,770
因此 假设我意外地做了这样的事情 

818
00:40:21,770 --> 00:40:27,230
假设我这样做了 而不是简单地获得数字并将其传递给猫咪 

819
00:40:27,230 --> 00:40:31,850
假设我声明了一些--一个新的变量 叫做猫咪 

820
00:40:31,850 --> 00:40:34,730
我认为其类型应该是str 

821
00:40:34,730 --> 00:40:37,490
假设 再一次 我意外地假设

822
00:40:37,490 --> 00:40:42,170
那猫叫回传给我一连串的猫叫 所以我自己

823
00:40:42,170 --> 00:40:43,430
然后可以稍后打印它们 

824
00:40:43,430 --> 00:40:47,070
可以说 这会更有利于测试我的猫咪功能 

825
00:40:47,070 --> 00:40:47,570
为什么？

826
00:40:47,570 --> 00:40:51,380
因为我可以预料到它还会叫 或者叫 

827
00:40:51,380 --> 00:40:53,600
或者猫咪 用新的线隔开 

828
00:40:53,600 --> 00:40:56,990
返回一个字符串 然后我可以断言等于

829
00:40:56,990 --> 00:40:59,875
我希望它会出现在类似单元测试的东西中 

830
00:40:59,875 --> 00:41:02,000
我现在不会费心编写任何单元测试 

831
00:41:02,000 --> 00:41:04,880
但让我们假设这就是我现在的心态 

832
00:41:04,880 --> 00:41:08,060
所以 在第七行 我假设我

833
00:41:08,060 --> 00:41:12,860
我想将meow的返回值赋给一个名为meow的新变量 该变量

834
00:41:12,860 --> 00:41:16,340
我已经使用该类型提示将其注释为字符串 

835
00:41:16,340 --> 00:41:18,210
这样我们就能看到另一个变量 

836
00:41:18,210 --> 00:41:20,990
这不是int 而是一个str 

837
00:41:20,990 --> 00:41:25,340
好 现在让我继续运行这段代码 meows.py的Python 

838
00:41:25,340 --> 00:41:27,170
回车 输入三个 

839
00:41:27,170 --> 00:41:29,300
你会看到一个奇怪的虫子 

840
00:41:29,300 --> 00:41:31,490
没有猫叫没有猫叫 

841
00:41:31,490 --> 00:41:33,000
好吧 为什么呢？

842
00:41:33,000 --> 00:41:37,310
现在看来 我的猫咪功能只有一个副作用 

843
00:41:37,310 --> 00:41:39,650
它只是打印了几次猫咪 

844
00:41:39,650 --> 00:41:42,080
它不会显式返回值 因为它

845
00:41:42,080 --> 00:41:44,810
如果那里真的有Return关键字 那就好了 

846
00:41:44,810 --> 00:41:47,270
那么 在默认情况下 当Python中的函数

847
00:41:47,270 --> 00:41:50,870
不显式返回值 它的隐式返回值

848
00:41:50,870 --> 00:41:52,340
实际上是没有的 

849
00:41:52,340 --> 00:41:55,850
所以 我们在这里看到的是--在第八行 

850
00:41:55,850 --> 00:42:01,970
因为我正在为meow赋值 返回值为None 

851
00:42:01,970 --> 00:42:08,660
对于我的猫咪变量 第三行是仍在打印猫咪的猫咪 

852
00:42:08,660 --> 00:42:12,290
第八行现在错误地不打印任何内容 

853
00:42:12,290 --> 00:42:16,430
因为我意外地认为meow返回一个值 但它不是 

854
00:42:16,430 --> 00:42:18,770
因此 它的返回值实际上是无 

855
00:42:18,770 --> 00:42:22,920
所以我在底部奇怪地印上了“无”这个词 

856
00:42:22,920 --> 00:42:26,180
那么 我怎样才能着手捕捉到这种错误呢？

857
00:42:26,180 --> 00:42:27,510
我可能会犯这个错误 

858
00:42:27,510 --> 00:42:29,690
但如果我养成了这个习惯 也许频率会更低

859
00:42:29,690 --> 00:42:34,700
使用这个称为类型提示的新功能来注释我的代码 

860
00:42:34,700 --> 00:42:36,520
你在这里能做的就是 

861
00:42:36,520 --> 00:42:39,060
让我清理我的终端窗口来处理那个神器 

862
00:42:39,060 --> 00:42:43,860
在这里 让我另外指定一些看起来很有趣的语法

863
00:42:43,860 --> 00:42:48,840
我的猫咪功能实际上是被设计成没有返回任何东西 

864
00:42:48,840 --> 00:42:51,300
所以你真的使用了这个箭头符号 

865
00:42:51,300 --> 00:42:56,400
在Python中 当提示函数的返回值是什么时 

866
00:42:56,400 --> 00:42:57,750
你会这么做的 

867
00:42:57,750 --> 00:43:02,760
括号后有空格、连字符、大于号、

868
00:43:02,760 --> 00:43:06,270
如箭头 然后是另一个空格 然后是返回值的类型 

869
00:43:06,270 --> 00:43:07,800
就目前而言 它确实会--

870
00:43:07,800 --> 00:43:10,080
[燕子]对不起 请不要退货 

871
00:43:10,080 --> 00:43:12,990
但现在 至少我可以像这样抓到它 

872
00:43:12,990 --> 00:43:17,010
如果我现在不是在我的代码上运行Python而是mypy 这将是一种习惯

873
00:43:17,010 --> 00:43:18,960
我现在开始学习如何使用类型提示 

874
00:43:18,960 --> 00:43:22,770
在运行程序之前 请检查我是否正确使用了所有类型 

875
00:43:22,770 --> 00:43:27,930
我们会看到现在Mypy已经在网上找到了七个猫 引用引述 

876
00:43:27,930 --> 00:43:29,770
不返回值 

877
00:43:29,770 --> 00:43:34,530
Mypy知道这一点 因为我已经主动注释了我的猫咪功能

878
00:43:34,530 --> 00:43:37,840
作为其返回值为None 

879
00:43:37,840 --> 00:43:39,720
所以现在 Mypy可以检测到这一点 

880
00:43:39,720 --> 00:43:41,610
我现在应该意识到 哦 等一下 

881
00:43:41,610 --> 00:43:44,220
我在这里太愚蠢了 

882
00:43:44,220 --> 00:43:46,230
显然 Meow不返回值 

883
00:43:46,230 --> 00:43:49,350
我不应该像在7号线上那样对待它 

884
00:43:49,350 --> 00:43:52,200
现在让我开始实际解决这个问题 

885
00:43:52,200 --> 00:43:53,970
那么 我该如何着手解决这个问题呢？

886
00:43:53,970 --> 00:43:56,700
那么 让我们练习一下我们在专注于单元测试时所宣扬的内容 

887
00:43:56,700 --> 00:44:00,240
拥有像猫咪这样的功能不会像打印本身一样产生副作用 

888
00:44:00,240 --> 00:44:02,860
但让我们让它返回实际的字符串 

889
00:44:02,860 --> 00:44:04,890
我实际上可以干净利落地做这件事 

890
00:44:04,890 --> 00:44:08,560
让我在这里清除终端窗口中的错误消息 

891
00:44:08,560 --> 00:44:10,110
让我把这里的循环去掉 

892
00:44:10,110 --> 00:44:14,010
让我说这一次 好的 好的 猫咪会回来的

893
00:44:14,010 --> 00:44:16,770
值、实际字符串或字符串 

894
00:44:16,770 --> 00:44:18,640
因此 我将None更改为str 

895
00:44:18,640 --> 00:44:20,980
现在 我可以用任何方式来实现这一点 

896
00:44:20,980 --> 00:44:21,990
甚至可以使用循环 

897
00:44:21,990 --> 00:44:25,260
但回想一下 我们在Python中有这样的语法 我认为 

898
00:44:25,260 --> 00:44:27,010
为我们解决这个问题 

899
00:44:27,010 --> 00:44:32,640
如果我想返回一个由n个猫咪组成的字符串 我实际上可以做的是 

900
00:44:32,640 --> 00:44:33,540
回想一下 这就是 

901
00:44:33,540 --> 00:44:39,540
返回引号 反斜杠n 乘以那个数字n 

902
00:44:39,540 --> 00:44:41,970
所以这是一个巧妙的俏皮话 避免了

903
00:44:41,970 --> 00:44:44,640
需要一个for循环或更复杂的东西 

904
00:44:44,640 --> 00:44:50,730
简单地说 将猫咪的反斜杠n对自己乘三次 或n次 

905
00:44:50,730 --> 00:44:55,710
在这种情况下 一般来说 这样我就可以得到一大串零叫 一 

906
00:44:55,710 --> 00:44:58,530
取而代之的是更多的两声、三声或更多的叫声 

907
00:44:58,530 --> 00:45:01,810
我想现在我在第六行的代码实际上是正确的 

908
00:45:01,810 --> 00:45:04,410
现在我已经改变了猫咪的行为方式

909
00:45:04,410 --> 00:45:06,610
假装它总是奏效 

910
00:45:06,610 --> 00:45:11,910
所以我存储了一个str类型的变量 

911
00:45:11,910 --> 00:45:16,830
因为现在 meow确实有一个字符串类型本身的返回值

912
00:45:16,830 --> 00:45:20,440
根据此类型提示也是如此 

913
00:45:20,440 --> 00:45:20,940
好的 

914
00:45:20,940 --> 00:45:22,830
现在让我继续打印猫咪 

915
00:45:22,830 --> 00:45:27,840
但因为我的每个猫咪都有一个尾随的新行 反斜杠n 

916
00:45:27,840 --> 00:45:30,750
我要主动修复一个小小的审美缺陷 

917
00:45:30,750 --> 00:45:33,630
我只想避免输出额外的新行

918
00:45:33,630 --> 00:45:35,250
在这三个国家的末尾 

919
00:45:35,250 --> 00:45:41,190
所以如果我现在运行Python of meows.py 输入3 这就是我的喵喵喵 

920
00:45:41,190 --> 00:45:45,450
而现在 什么都不提了 

921
00:45:45,450 --> 00:45:50,430
现在关于类型提示的问题 以及mypy中的这些注释 

922
00:45:50,430 --> 00:45:55,170
并使用它们来防御性地编写代码 希望这些代码能够减少

923
00:45:55,170 --> 00:45:57,450
你自己感染病毒的可能性有多大？

924
00:45:57,450 --> 00:46:04,230
学生：返回的三组是带双引号的吗？

925
00:46:04,230 --> 00:46:10,020
有猫咪斜杠n 为什么程序不把它当作[？字符串？？]

926
00:46:10,020 --> 00:46:13,230
大卫·J·马兰：为什么节目不把它当作一种--奇怪的东西？

927
00:46:13,230 --> 00:46:14,370
学生：[听不见] 是的 

928
00:46:14,370 --> 00:46:17,160
大卫·J·马兰：回想一下在这堂课的早期

929
00:46:17,160 --> 00:46:19,800
我们将加号视为连接运算符

930
00:46:19,800 --> 00:46:22,050
允许您在左侧和右侧连接字符串 

931
00:46:22,050 --> 00:46:26,820
乘法也是字符串的重载运算符 

932
00:46:26,820 --> 00:46:30,870
因此 如果左边有一个字符串 右边有一个整型 

933
00:46:30,870 --> 00:46:35,250
可以说 它将通过连接或连接来乘以字符串

934
00:46:35,250 --> 00:46:38,350
那么多的猫叫加在一起 

935
00:46:38,350 --> 00:46:40,770
因此 这是面向对象编程的一个特性

936
00:46:40,770 --> 00:46:45,540
和我们过去看到的操作符重载 

937
00:46:45,540 --> 00:46:49,290
关于类型提示或输入的其他问题 

938
00:46:49,290 --> 00:46:54,468
学生：我们能不能不对这个变量数字的数据类型进行类型转换？

939
00:46:54,468 --> 00:46:55,260
大卫·J·马兰：没有 

940
00:46:55,260 --> 00:46:57,300
你还是--让我更正一下术语 

941
00:46:57,300 --> 00:47:00,870
在这种情况下 它不会被称为类型转换 因为它不像C#

942
00:47:00,870 --> 00:47:03,450
或者C++ 在这些类型之间存在等价性 

943
00:47:03,450 --> 00:47:07,980
从技术上讲 您正在将第5行的a str转换为int 

944
00:47:07,980 --> 00:47:09,900
你还是得这么做 

945
00:47:09,900 --> 00:47:12,060
例如 因为Mypy会对你大喊大叫

946
00:47:12,060 --> 00:47:15,850
如果您试图将右侧的字符串赋给左侧的int 

947
00:47:15,850 --> 00:47:18,420
您仍然必须使用int函数 

948
00:47:18,420 --> 00:47:20,290
INT本身仍然是一个函数 

949
00:47:20,290 --> 00:47:21,330
这不是类型提示 

950
00:47:21,330 --> 00:47:26,340
但在这些类型提示中 int一词现在被以另一种方式使用 

951
00:47:26,340 --> 00:47:30,300
因此 这个int仍然是一个函数调用 一如既往 

952
00:47:30,300 --> 00:47:33,690
左侧的语法是关键字int的另一种用法

953
00:47:33,690 --> 00:47:35,680
而是以这些类型提示的形式 

954
00:47:35,680 --> 00:47:39,170
因此 您仍然需要自己进行转换 

955
00:47:39,170 --> 00:47:39,670
好的 

956
00:47:39,670 --> 00:47:44,050
让我建议我们过渡到Python的另一个有价值的功能

957
00:47:44,050 --> 00:47:47,200
知道 特别是因为它是你会在野外看到的

958
00:47:47,200 --> 00:47:49,810
当你看到其他人编写的代码或库时 

959
00:47:49,810 --> 00:47:53,500
即被称为文档字符串或文档字符串的东西 

960
00:47:53,500 --> 00:47:55,450
事实证明 在巨蟒的世界里

961
00:47:55,450 --> 00:47:59,680
是一种标准化的方式 根据另一个PEP Python增强提案 这一个

962
00:47:59,680 --> 00:48:05,830
257 这实质上标准化了您应该如何记录您的功能

963
00:48:05,830 --> 00:48:07,940
以及代码的其他方面 

964
00:48:07,940 --> 00:48:12,790
因此 例如 让我回到我的meows.py文件 

965
00:48:12,790 --> 00:48:16,000
让我建议我们现在开始记录这些代码

966
00:48:16,000 --> 00:48:18,550
也是为了让我知道猫叫函数的作用 

967
00:48:18,550 --> 00:48:23,170
事实上 使用文档字符串表示法进行此操作的标准方法

968
00:48:23,170 --> 00:48:24,490
将如下所示 

969
00:48:24,490 --> 00:48:27,460
注释此函数 而不是在其上方 因为您

970
00:48:27,460 --> 00:48:31,520
通常可能有处理代码的习惯 但实际上是在代码内部 

971
00:48:31,520 --> 00:48:35,260
但不是像这样用通常的散列评论符号来评论它 

972
00:48:35,260 --> 00:48:40,840
就像猫叫n次一样 结果是当你正式对接时--

973
00:48:40,840 --> 00:48:45,020
当您正式记录像这种情况下的meow这样的函数时 

974
00:48:45,020 --> 00:48:48,310
可以说 您不使用常规的内联注释 

975
00:48:48,310 --> 00:48:50,440
您可以改用此语法 

976
00:48:50,440 --> 00:48:54,760
您可以使用三引号 可以是双引号 也可以是单引号 

977
00:48:54,760 --> 00:48:58,270
然后你写下你的评论 喵n次 

978
00:48:58,270 --> 00:49:01,040
然后你在最后再写一遍同样的内容 

979
00:49:01,040 --> 00:49:03,370
所以要么是开头和结尾的三个双引号

980
00:49:03,370 --> 00:49:05,710
或者在开头和结尾加三个单引号 

981
00:49:05,710 --> 00:49:08,380
而Python已经在其中内置了某些工具

982
00:49:08,380 --> 00:49:13,420
以及某些假设 如果它检测到有使用

983
00:49:13,420 --> 00:49:16,780
此文档字符串的格式为左右三引号 

984
00:49:16,780 --> 00:49:20,210
它将假定这确实是该函数的文档 

985
00:49:20,210 --> 00:49:23,770
事实证明 在Python生态系统中 有很多工具

986
00:49:23,770 --> 00:49:28,300
 然后可以用它来自动分析代码 提取

987
00:49:28,300 --> 00:49:31,750
所有这些文档字符串 甚至生成

988
00:49:31,750 --> 00:49:36,530
网页或PDF文档 用于您自己的功能 

989
00:49:36,530 --> 00:49:39,970
因此 如果你遵守这些惯例 就会有这些惯例

990
00:49:39,970 --> 00:49:43,270
您可以开始为其他人记录您的代码

991
00:49:43,270 --> 00:49:46,900
通过从您自己的代码自动生成文档

992
00:49:46,900 --> 00:49:49,480
而无需手动从头开始编写内容 

993
00:49:49,480 --> 00:49:53,650
现在 结果是如果您的函数确实接受参数

994
00:49:53,650 --> 00:49:56,830
也许做得更多 关于如何做有多种约定

995
00:49:56,830 --> 00:49:59,365
您可以为人类程序员记录

996
00:49:59,365 --> 00:50:01,990
可能正在使用你的功能 无论是你 还是同事 

997
00:50:01,990 --> 00:50:05,320
或互联网上的其他人 实际使用这些文档

998
00:50:05,320 --> 00:50:08,270
字符串来标准化其中的信息 

999
00:50:08,270 --> 00:50:10,180
所以你可能会看到这个 

1000
00:50:10,180 --> 00:50:13,960
现在使用上面和下面相同的三重引号 

1001
00:50:13,960 --> 00:50:19,420
你可能会看到你对这个功能的一句话解释 喵--

1002
00:50:19,420 --> 00:50:21,520
喵叫n次 

1003
00:50:21,520 --> 00:50:23,710
有时根据款式和用途 

1004
00:50:23,710 --> 00:50:27,220
它实际上可能仍然在第一行 但它下面有一个空行 

1005
00:50:27,220 --> 00:50:29,560
但我会把每一件东西都统一缩进 

1006
00:50:29,560 --> 00:50:34,000
这是一些流行的Python文档工具使用的约定

1007
00:50:34,000 --> 00:50:34,660
也是 

1008
00:50:34,660 --> 00:50:39,850
您可以这样说语法--param n冒号 然后描述什么是n

1009
00:50:39,850 --> 00:50:42,520
就是 猫叫的次数 

1010
00:50:42,520 --> 00:50:47,890
然后是冒号类型n冒号int 这只表示n的类型

1011
00:50:47,890 --> 00:50:49,010
是一个整数 

1012
00:50:49,010 --> 00:50:53,050
然后 如果此函数实际上可以引发异常 

1013
00:50:53,050 --> 00:50:54,400
您也可以记录这一点 

1014
00:50:54,400 --> 00:50:56,770
事实上 这并不是真的--

1015
00:50:56,770 --> 00:50:58,660
好吧 这可以说是我的错误 

1016
00:50:58,660 --> 00:51:01,990
如果n作为自变量进入 并且实际上不是整型 

1017
00:51:01,990 --> 00:51:04,810
也许它是一个浮点 或者一个字符串 或者其他什么东西 

1018
00:51:04,810 --> 00:51:08,060
这里的乘法符号不起作用 

1019
00:51:08,060 --> 00:51:09,760
它不会使字符串倍增 

1020
00:51:09,760 --> 00:51:13,040
根据我的经验 它将触发一个类型错误 

1021
00:51:13,040 --> 00:51:16,240
所以我将继续在我自己的文档中积极地说

1022
00:51:16,240 --> 00:51:20,830
从技术上讲 这个函数如果使用不当 可能会引发类型错误 

1023
00:51:20,830 --> 00:51:23,740
尽管我在这里用这个注解来暗示

1024
00:51:23,740 --> 00:51:25,660
您应该传入一个int 

1025
00:51:25,660 --> 00:51:27,440
同样 Python不会强制执行这一点 

1026
00:51:27,440 --> 00:51:29,500
所以如果你传递一个浮点数 这可能 事实上 

1027
00:51:29,500 --> 00:51:31,520
引发此函数的类型错误 

1028
00:51:31,520 --> 00:51:35,740
因此 如果n不是整型 就可能发生这种情况 

1029
00:51:35,740 --> 00:51:39,730
最后 为了让其他程序员明白起见 我可能会说 

1030
00:51:39,730 --> 00:51:44,630
此函数返回一个由n个猫叫声组成的字符串 每行一个 

1031
00:51:44,630 --> 00:51:49,150
该值的返回类型 r类型 将是字符串 

1032
00:51:49,150 --> 00:51:54,410
现在 我在这里使用的所有语法本身并不是Python 

1033
00:51:54,410 --> 00:51:56,740
这是一种称为重组文本的约定 它

1034
00:51:56,740 --> 00:51:58,930
是一种类似于标记的语言 它

1035
00:51:58,930 --> 00:52:02,600
用于文档、网站、博客 甚至更多 

1036
00:52:02,600 --> 00:52:06,400
但这是在Python世界中流行的约定之一

1037
00:52:06,400 --> 00:52:08,570
来记录您自己的功能 

1038
00:52:08,570 --> 00:52:12,460
因此 这基本上与类型提示没有任何关系 

1039
00:52:12,460 --> 00:52:15,280
类型提示是Python的一项功能 

1040
00:52:15,280 --> 00:52:19,840
我在这里所做的只是遵守第三方惯例

1041
00:52:19,840 --> 00:52:24,580
从一开始就在一个Python文档字符串之间插入

1042
00:52:24,580 --> 00:52:29,470
最后是某种标准格式 以便这些第三方工具可以

1043
00:52:29,470 --> 00:52:31,960
从上到下 从左到右分析我的代码 

1044
00:52:31,960 --> 00:52:35,260
理想的情况是为我生成文档 

1045
00:52:35,260 --> 00:52:38,590
它可以生成PDF、网页或其他内容 

1046
00:52:38,590 --> 00:52:41,730
这样我或我的同事就不需要仅仅写

1047
00:52:41,730 --> 00:52:45,240
代码 而且还手动为我们的代码创建文档 

1048
00:52:45,240 --> 00:52:50,880
我们可以将所有东西放在一起 并使用工具为我们生成相同的东西 

1049
00:52:50,880 --> 00:52:55,050
现在对这些文档字符串有什么问题吗？

1050
00:52:55,050 --> 00:52:59,010
同样 还有一个惯例是经常记录您自己的代码

1051
00:52:59,010 --> 00:53:01,487
遵循一些标准语法吗？

1052
00:53:01,487 --> 00:53:02,070
学生：是的 

1053
00:53:02,070 --> 00:53:06,150
所以 当你说你会把它记录下来并放到PDF中时 

1054
00:53:06,150 --> 00:53:10,300
这样做的目的是发布它并共享您的功能吗

1055
00:53:10,300 --> 00:53:12,105
这样其他用户就可以使用它了吗？

1056
00:53:12,105 --> 00:53:13,230
大卫·J·马兰：当然 

1057
00:53:13,230 --> 00:53:16,620
过去我们在安装一些第三方库的时候 比如说 

1058
00:53:16,620 --> 00:53:18,240
就在几周前 

1059
00:53:18,240 --> 00:53:20,952
回想一下 我向您展示了它的功能 

1060
00:53:20,952 --> 00:53:23,160
但如果你读了文档 你可能真的

1061
00:53:23,160 --> 00:53:27,350
确保该程序的作者为我们记录了这一点 

1062
00:53:27,350 --> 00:53:29,850
现在 我不相信他们在使用这种特殊的语法 

1063
00:53:29,850 --> 00:53:31,920
但这对你我来说绝对是有用的

1064
00:53:31,920 --> 00:53:35,850
能够阅读一些网页或PDF 告诉我们如何使用图书馆

1065
00:53:35,850 --> 00:53:38,850
而不是浪费时间阅读别人的代码

1066
00:53:38,850 --> 00:53:42,040
并试图推断存在哪些功能以及如何使用它们 

1067
00:53:42,040 --> 00:53:45,090
它只是倾向于对开发人员更友好

1068
00:53:45,090 --> 00:53:49,360
我们自己的代码或库的适当文档也是如此 

1069
00:53:49,360 --> 00:53:50,430
还有其他问题吗？

1070
00:53:50,430 --> 00:53:51,450
学生：是的 

1071
00:53:51,450 --> 00:53:55,350
当使用文档字符串时 当它被用来生成PDF或其他什么时 

1072
00:53:55,350 --> 00:53:57,970
它包括任何代码吗？

1073
00:53:57,970 --> 00:54:01,740
因此 如果你在评论中引用了 

1074
00:54:01,740 --> 00:54:04,740
如果您在注释本身中引用代码 并且

1075
00:54:04,740 --> 00:54:07,110
如果没有看到代码 可能就没有意义了 

1076
00:54:07,110 --> 00:54:09,843
它--这些包括它吗？

1077
00:54:09,843 --> 00:54:11,760
大卫·J·马兰：简而言之 你可以做到 

1078
00:54:11,760 --> 00:54:13,420
不是在我在这里使用的惯例中 

1079
00:54:13,420 --> 00:54:18,330
但实际上有一种聪明的方法可以在您的文档字符串中写入

1080
00:54:18,330 --> 00:54:23,320
函数的样例输入和函数的样例输出 

1081
00:54:23,320 --> 00:54:25,950
如果您使用的是我们没有讨论过的其他工具 

1082
00:54:25,950 --> 00:54:29,670
该工具将使用这些样例输入运行您的代码 

1083
00:54:29,670 --> 00:54:32,890
它将检查您的输出是否与您的样本输出匹配 

1084
00:54:32,890 --> 00:54:36,090
如果没有 程序就会对你大喊大叫 说你在某个地方出了问题 

1085
00:54:36,090 --> 00:54:38,550
所以这是另一种你可以

1086
00:54:38,550 --> 00:54:44,040
使用文档字符串不仅可以记录代码 甚至可以捕获代码中的错误 

1087
00:54:44,040 --> 00:54:44,910
这件事已经很多了 

1088
00:54:44,910 --> 00:54:46,170
而且还有更多的事情要做 

1089
00:54:46,170 --> 00:54:48,503
为什么我们不在这里休息五分钟呢？

1090
00:54:48,503 --> 00:54:51,660
当我们继续时 我们将看看Python的另一个功能 

1091
00:54:51,660 --> 00:54:53,950
另一个更快编写代码的库 

1092
00:54:53,950 --> 00:54:54,450
好的 

1093
00:54:54,450 --> 00:54:58,770
假设我们想要修改这个meow程序以实际接受它的输入 而不是

1094
00:54:58,770 --> 00:55:02,070
从闪烁提示符中的输入功能 但从命令行 

1095
00:55:02,070 --> 00:55:04,862
回想一下 在我们讨论库时 您可以使用一些

1096
00:55:04,862 --> 00:55:07,752
像sys.argv一样获取命令行参数

1097
00:55:07,752 --> 00:55:10,210
当你运行你的程序时 人类所提供的 

1098
00:55:10,210 --> 00:55:12,060
所以我们为什么不制作一个版本的猫咪呢

1099
00:55:12,060 --> 00:55:15,280
它使用命令行参数 而不是同样的输入 

1100
00:55:15,280 --> 00:55:18,030
因此 我将继续删除我们到目前为止所做的工作 

1101
00:55:18,030 --> 00:55:21,540
让我建议我们像过去一样导入系统 

1102
00:55:21,540 --> 00:55:22,870
让我们开始行动吧 

1103
00:55:22,870 --> 00:55:27,720
如果用户不键入任何命令行参数 情况会怎样？

1104
00:55:27,720 --> 00:55:29,910
那么我的程序只会猫叫一次 这样它就会

1105
00:55:29,910 --> 00:55:32,070
做一些视觉上有趣的事情 

1106
00:55:32,070 --> 00:55:35,310
否则 我们还为用户提供一个选项

1107
00:55:35,310 --> 00:55:39,000
来指定我想让猫叫几次 

1108
00:55:39,000 --> 00:55:40,230
所以 让我们从简单的开始 

1109
00:55:40,230 --> 00:55:42,480
首先 让我们继续做这件事 

1110
00:55:42,480 --> 00:55:47,790
如果sys.argv的长度等于1 

1111
00:55:47,790 --> 00:55:52,050
也就是说 用户只输入程序的名称 之后不输入其他内容

1112
00:55:52,050 --> 00:55:52,950
那--

1113
00:55:52,950 --> 00:55:58,350
在他们的指挥下 那么我们就像这样打印出一只猫叫 

1114
00:55:58,350 --> 00:56:02,200
否则 现在 让我们继续打印出类似这样的东西 

1115
00:56:02,200 --> 00:56:04,980
否则继续打印 比方说 用法

1116
00:56:04,980 --> 00:56:08,220
对于该程序 将使用meows.py 

1117
00:56:08,220 --> 00:56:12,360
只是为了让用户知道程序本身名为meows.py 

1118
00:56:12,360 --> 00:56:16,410
现在 让我转到我的终端窗口 开始输入Python of meows.py 

1119
00:56:16,410 --> 00:56:20,070
此时 请注意sys.argv的长度

1120
00:56:20,070 --> 00:56:21,300
确实应该是其中之一 

1121
00:56:21,300 --> 00:56:21,900
为什么？

1122
00:56:21,900 --> 00:56:25,500
嗯 这个名字根本不会出现在sys.argv中 

1123
00:56:25,500 --> 00:56:28,470
但是meows.py 文件的名称是这样的 

1124
00:56:28,470 --> 00:56:31,320
它将以sys.argv为零 

1125
00:56:31,320 --> 00:56:32,592
但这只是其中一个因素 

1126
00:56:32,592 --> 00:56:34,050
所以这个东西的长度是1 

1127
00:56:34,050 --> 00:56:35,470
右边没有更多的东西了 

1128
00:56:35,470 --> 00:56:38,610
所以 当我现在按回车键时 我们应该会看到 确实 一声喵叫 

1129
00:56:38,610 --> 00:56:43,530
如果我不合作 假设我做了类似猫咪三次进入的事情 

1130
00:56:43,530 --> 00:56:46,800
然后我会看到一个提醒 这就是你使用程序的方式 

1131
00:56:46,800 --> 00:56:49,050
这是一种常见的约定 逐字打印出来

1132
00:56:49,050 --> 00:56:52,140
单词用法 冒号 然后是程序的名称 

1133
00:56:52,140 --> 00:56:54,240
也许还有一些关于如何使用它的解释 

1134
00:56:54,240 --> 00:56:56,070
所以我把它弄得很简单 

1135
00:56:56,070 --> 00:56:57,600
但让我们更花哨一点 

1136
00:56:57,600 --> 00:57:01,770
如果我真的想让用户输入的内容不是三个 而是一些

1137
00:57:01,770 --> 00:57:03,060
更加老练 

1138
00:57:03,060 --> 00:57:07,300
事实上 当从命令行控制程序时 

1139
00:57:07,300 --> 00:57:11,550
提供通常被称为开关或标志的东西是非常常见的 

1140
00:57:11,550 --> 00:57:16,830
借此传入类似破折号n的内容 这在语义上意味着

1141
00:57:16,830 --> 00:57:19,620
这个次数 然后通常是一个空格 

1142
00:57:19,620 --> 00:57:21,420
然后是类似数字3的东西 

1143
00:57:21,420 --> 00:57:24,940
这仍然允许我在命令行做其他事情 如果我想的话 

1144
00:57:24,940 --> 00:57:28,200
但事实上我已经标准化了我提供命令行的方式

1145
00:57:28,200 --> 00:57:30,690
此程序的参数为破折号n 3

1146
00:57:30,690 --> 00:57:34,440
只是我的程序现在更可靠的方式

1147
00:57:34,440 --> 00:57:36,240
知道这三个字是什么意思 

1148
00:57:36,240 --> 00:57:39,838
如果我只做meows.py space Three 就不那么明显了 

1149
00:57:39,838 --> 00:57:41,130
那么 这三个词是什么意思？

1150
00:57:41,130 --> 00:57:44,087
至少使用像破折号nThree这样的语法 尤其是

1151
00:57:44,087 --> 00:57:46,170
如果您已经阅读了此程序的文档 

1152
00:57:46,170 --> 00:57:48,780
最终 哦 破折号n表示次数 

1153
00:57:48,780 --> 00:57:49,290
明白了 

1154
00:57:49,290 --> 00:57:51,990
这是一种传递两个额外参数的方式

1155
00:57:51,990 --> 00:57:54,070
但这两者之间有一定的联系 

1156
00:57:54,070 --> 00:57:58,830
那么 我如何修改我的程序以理解破折号n3呢？

1157
00:57:58,830 --> 00:58:01,650
嗯 如果我像这样使用sys 我可以这样做 

1158
00:58:01,650 --> 00:58:07,830
如果sys.argv的长度这次等于三 

1159
00:58:07,830 --> 00:58:13,680
因为请注意 在我的提示下 有一、二、三件事 

1160
00:58:13,680 --> 00:58:17,910
因此 sys.argv是由空格分隔的0、1和2、3个元素 

1161
00:58:17,910 --> 00:58:19,380
如果等于三--

1162
00:58:19,380 --> 00:58:27,000
为了安全起见 sys.argv括号1等于破折号n 

1163
00:58:27,000 --> 00:58:29,320
那么让我们继续做这件事 

1164
00:58:29,320 --> 00:58:37,680
让我们继续并将2的sys.argv转换为整数

1165
00:58:37,680 --> 00:58:40,560
并将其赋给一个变量 例如 名为n的变量 

1166
00:58:40,560 --> 00:58:42,240
然后 让我们继续这样做 

1167
00:58:42,240 --> 00:58:46,470
对于n范围内的下划线 让我们继续

1168
00:58:46,470 --> 00:58:48,395
打印出其中的一些猫咪叫声 

1169
00:58:48,395 --> 00:58:51,270
现在 也许还有机会巩固我的印刷线

1170
00:58:51,270 --> 00:58:51,730
用猫叫 

1171
00:58:51,730 --> 00:58:53,897
但就目前而言 我将把这些想法分开 

1172
00:58:53,897 --> 00:58:58,120
所以我将像以前一样处理缺省情况 这里没有参数 

1173
00:58:58,120 --> 00:59:01,530
现在 更有趣的是 我要把这一点讲清楚 

1174
00:59:01,530 --> 00:59:05,070
我将检查用户是否向我提供了三个命令行参数 即名称

1175
00:59:05,070 --> 00:59:07,710
程序的名称、破折号n和一个数字 

1176
00:59:07,710 --> 00:59:15,030
如果他们在sys.argv中给我的第二个东西确实等于破折号n 

1177
00:59:15,030 --> 00:59:19,410
然后我将假设接下来的事情 sys.argv of Two

1178
00:59:19,410 --> 00:59:21,030
将是一个整数 

1179
00:59:21,030 --> 00:59:24,420
我会把它转换成这样 并存储在这个变量n中 

1180
00:59:24,420 --> 00:59:28,960
现在 只要使用一个循环 我就会打印出这么多次的猫咪 

1181
00:59:28,960 --> 00:59:32,190
好的 这是我们之前对循环的关注的一种结合 

1182
00:59:32,190 --> 00:59:34,290
我们之前的重点是命令行参数 

1183
00:59:34,290 --> 00:59:36,570
我只是在创建一个程序 让我可以宣称

1184
00:59:36,570 --> 00:59:39,750
代表了许多命令行程序的工作方式 

1185
00:59:39,750 --> 00:59:42,130
尽管我们通常不会像这样使用太多 

1186
00:59:42,130 --> 00:59:45,090
但这是非常常见的配置一个程序 一个 

1187
00:59:45,090 --> 00:59:47,700
您将在命令行中使用某些内容运行它

1188
00:59:47,700 --> 00:59:51,120
就像这些命令行参数 如破折号n或其他破折号 

1189
00:59:51,120 --> 00:59:53,430
现在 我将继续并按Enter键 

1190
00:59:53,430 --> 00:59:57,360
我想我应该看到 确实 三只猫叫 

1191
00:59:57,360 --> 01:00:02,250
相比之下 如果我在最后做两次 我应该会看到两声喵叫 

1192
01:00:02,250 --> 01:00:04,980
如果我做了一次 我应该会看到一只猫叫 

1193
01:00:04,980 --> 01:00:07,860
坦率地说 如果我完全忽略这一点 

1194
01:00:07,860 --> 01:00:12,420
我也应该看到一个猫咪 因为这是我之前的默认情况 

1195
01:00:12,420 --> 01:00:17,880
现在 让我们假设这个项目最终

1196
01:00:17,880 --> 01:00:19,020
变得更复杂了 

1197
01:00:19,020 --> 01:00:22,620
让我们想象一个我不想只支持破折号n的世界 

1198
01:00:22,620 --> 01:00:25,980
也许我想支持破折号a 破折号b 破折号c 

1199
01:00:25,980 --> 01:00:27,870
和破折号d 还有很多其他的 

1200
01:00:27,870 --> 01:00:30,400
或者 在这一点上 我应该给他们一些话 

1201
01:00:30,400 --> 01:00:32,220
所以可能是个破折号 破折号 数字 

1202
01:00:32,220 --> 01:00:35,700
这确实是计算中的一个惯例 

1203
01:00:35,700 --> 01:00:40,620
使用单破折号和一个字母 如n 但使用双破折号

1204
01:00:40,620 --> 01:00:42,930
如果你真的用了一个完整的词比如数字

1205
01:00:42,930 --> 01:00:45,900
所以命令行参数可能是破折号n 或者

1206
01:00:45,900 --> 01:00:47,490
是破折号 破折号号码 

1207
01:00:47,490 --> 01:00:50,490
但你可以想象这段代码有多复杂

1208
01:00:50,490 --> 01:00:54,448
如果现在您想支持破折号n、破折号a、破折号b、破折号c等等 

1209
01:00:54,448 --> 01:00:56,740
你得到处检查 

1210
01:00:56,740 --> 01:00:58,532
如果它们的顺序不一样呢？

1211
01:00:58,532 --> 01:01:00,570
你得先检查破折号 

1212
01:01:00,570 --> 01:01:02,910
还是第二第三还是第四

1213
01:01:02,910 --> 01:01:06,240
我的意思是 这只是变得非常痛苦非常快

1214
01:01:06,240 --> 01:01:09,840
只是做一些相对简单的事情 比如允许用户传递命令 

1215
01:01:09,840 --> 01:01:11,700
将参数行放入程序中 

1216
01:01:11,700 --> 01:01:15,390
这就是为什么图书馆总是存在 

1217
01:01:15,390 --> 01:01:18,240
Python附带的另一个库

1218
01:01:18,240 --> 01:01:22,350
可能值得了解的是这个叫做argparse的 

1219
01:01:22,350 --> 01:01:26,640
事实上 我自己或CS50的团队用Python编写了很多工具 

1220
01:01:26,640 --> 01:01:29,490
我们经常使用argparse 

1221
01:01:29,490 --> 01:01:33,390
比我们的课堂演示要复杂得多 

1222
01:01:33,390 --> 01:01:37,890
我们希望允许用户传入配置选项

1223
01:01:37,890 --> 01:01:39,420
在命令行中 

1224
01:01:39,420 --> 01:01:43,500
通过支持破折号N 破折号A 破折号B 破折号C 

1225
01:01:43,500 --> 01:01:46,770
argparse是一个库 

1226
01:01:46,770 --> 01:01:51,240
可以说 它只是处理所有这些解析 这些命令行分析

1227
01:01:51,240 --> 01:01:54,150
自动为您提供参数 以便您可以专注于

1228
01:01:54,150 --> 01:01:57,420
编写程序中有趣的部分 而不是命令行

1229
01:01:57,420 --> 01:01:58,780
论点部分 

1230
01:01:58,780 --> 01:02:00,160
那么我们该如何使用它呢？

1231
01:02:00,160 --> 01:02:02,040
让我们回到VS Code 

1232
01:02:02,040 --> 01:02:03,630
我来清空终端窗口 

1233
01:02:03,630 --> 01:02:06,690
我建议用not sys重写这个代码

1234
01:02:06,690 --> 01:02:08,037
但实际上使用的是argparse 

1235
01:02:08,037 --> 01:02:10,620
我先从简单的开始 然后再逐步完善 

1236
01:02:10,620 --> 01:02:15,960
现在让我把所有这些都扔掉 转而导入argparse 

1237
01:02:15,960 --> 01:02:17,910
Argparse是argument parser的缩写 

1238
01:02:17,910 --> 01:02:22,000
解析的意思是阅读它 把它拆开来分析 

1239
01:02:22,000 --> 01:02:24,300
所以这对我来说确实是这样 

1240
01:02:24,300 --> 01:02:25,950
现在 让我继续做这个 

1241
01:02:25,950 --> 01:02:27,780
对于这个图书馆来说 

1242
01:02:27,780 --> 01:02:30,600
一点面向对象的编程就像我们现在做的一样 

1243
01:02:30,600 --> 01:02:32,630
我将创建一个名为parser的变量 

1244
01:02:32,630 --> 01:02:34,255
不过 我想怎么叫都行 

1245
01:02:34,255 --> 01:02:40,270
我将把它设置为等于argparse.ArgumentParser的返回值 

1246
01:02:40,270 --> 01:02:43,450
有一个大写的A和一个大写的P. A构造函数

1247
01:02:43,450 --> 01:02:47,650
Python自带的一个名为argument parser的类

1248
01:02:47,650 --> 01:02:49,300
在这个图书馆里

1249
01:02:49,300 --> 01:02:52,690
现在 我要配置这个参数解析器

1250
01:02:52,690 --> 01:02:55,330
了解特定的命令行参数

1251
01:02:55,330 --> 01:02:58,010
我想在我的项目中支持的项目 

1252
01:02:58,010 --> 01:03:01,760
所以我会这样做 parser.add_argument 

1253
01:03:01,760 --> 01:03:04,990
这显然是解析器对象中的一个方法 

1254
01:03:04,990 --> 01:03:07,600
我要加一个破折号n的参数 

1255
01:03:07,600 --> 01:03:08,470
很简单

1256
01:03:08,470 --> 01:03:11,772
现在我将继续实际解析命令行参数 

1257
01:03:11,772 --> 01:03:14,230
我将使用args 或者我可以将变量命名为任何值

1258
01:03:14,230 --> 01:03:17,890
我想要 解析器 解析器 

1259
01:03:17,890 --> 01:03:23,410
默认情况下 parseargs会自动为我查找sys.argv 

1260
01:03:23,410 --> 01:03:25,450
我不需要自己导入sys 

1261
01:03:25,450 --> 01:03:30,670
我可以留下参数解析器 它的代码来导入sys 看看sys.argv 

1262
01:03:30,670 --> 01:03:34,000
找出破折号N或其他东西的实际位置

1263
01:03:34,000 --> 01:03:36,970
好的是 这行代码

1264
01:03:36,970 --> 01:03:42,250
这里导致解析器已经解析了所有的命令行参数 

1265
01:03:42,250 --> 01:03:46,360
我现在在变量args中有了这个对象

1266
01:03:46,360 --> 01:03:48,790
其中所有的值都是这些命令的值

1267
01:03:48,790 --> 01:03:51,630
行参数 不管它们以什么顺序出现 

1268
01:03:51,630 --> 01:03:54,130
当我只有一个的时候没什么大不了的 因为它只是

1269
01:03:54,130 --> 01:03:55,840
最后要去一个地方 

1270
01:03:55,840 --> 01:03:58,342
但如果我有破折号n 破折号a 破折号b 破折号c 

1271
01:03:58,342 --> 01:04:00,550
你可以想象它们的顺序都不同 

1272
01:04:00,550 --> 01:04:02,467
它们绝对不一定要按字母顺序排列 

1273
01:04:02,467 --> 01:04:05,260
用户应该能够以他们想要的任何顺序键入它们 

1274
01:04:05,260 --> 01:04:06,790
这在可用性方面更好 

1275
01:04:06,790 --> 01:04:09,430
Arg Parser将为我解决所有这些问题 

1276
01:04:09,430 --> 01:04:11,200
我现在要做的就是这个 

1277
01:04:11,200 --> 01:04:16,300
如果我想迭代这么多数量的参数

1278
01:04:16,300 --> 01:04:18,310
更确切地说 这么多猫叫 我能做到 

1279
01:04:18,310 --> 01:04:24,280
用于在args.n的int转换范围内加下划线 

1280
01:04:24,280 --> 01:04:27,340
因此 点是我们一直使用的访问内容的语法

1281
01:04:27,340 --> 01:04:29,860
就像对象内部的属性一样 

1282
01:04:29,860 --> 01:04:31,150
这就是ARGS的含义 

1283
01:04:31,150 --> 01:04:34,360
它是parse args函数为我返回的对象 

1284
01:04:34,360 --> 01:04:39,040
我现在要继续 打印出来 引用引语 猫叫这么多次 

1285
01:04:39,040 --> 01:04:41,080
所以这并不是非常简单 

1286
01:04:41,080 --> 01:04:45,520
这是我需要编写并理解的三行新代码 

1287
01:04:45,520 --> 01:04:48,010
但它已经更简单、更紧凑了

1288
01:04:48,010 --> 01:04:52,540
而不是我的IF、ELIF、OR、AND 以及所有的布尔逻辑 

1289
01:04:52,540 --> 01:04:54,560
它为我处理了很多这样的事情 

1290
01:04:54,560 --> 01:04:58,780
因此 如果我没有犯任何错误 现在让我在meows.py Enter中运行Python 

1291
01:04:58,780 --> 01:05:01,630
我确实在这里犯了一个错误 

1292
01:05:01,630 --> 01:05:03,170
我确实犯了一个错误 

1293
01:05:03,170 --> 01:05:05,620
现在这里出什么问题了？

1294
01:05:05,620 --> 01:05:06,280
怎么了？

1295
01:05:06,280 --> 01:05:08,860
嗯 我绝对没有按照我想要的方式来经营 

1296
01:05:08,860 --> 01:05:11,110
因此 破折号n三次进入 

1297
01:05:11,110 --> 01:05:12,490
所以它确实起作用了 

1298
01:05:12,490 --> 01:05:16,990
但如果我不合作 这实际上似乎是一个更糟糕的版本 

1299
01:05:16,990 --> 01:05:20,620
如果我没有传入破折号n和一个数字 它只会因为输入错误而出错 

1300
01:05:20,620 --> 01:05:22,000
Int必须是字符串 

1301
01:05:22,000 --> 01:05:23,260
没有一个是得到回报的 

1302
01:05:23,260 --> 01:05:25,000
所以很明显这里有一个错误 

1303
01:05:25,000 --> 01:05:27,160
但图书馆更加灵活 

1304
01:05:27,160 --> 01:05:31,220
实际上 我可以提供一些关于如何使用这个东西的文档 

1305
01:05:31,220 --> 01:05:32,860
那我怎么知道怎么用这个呢？

1306
01:05:32,860 --> 01:05:35,500
嗯 通常在Python语言中是常规的

1307
01:05:35,500 --> 01:05:39,160
并在许多编程环境中运行程序

1308
01:05:39,160 --> 01:05:42,970
带有特殊参数的破折号h或破折号帮助 

1309
01:05:42,970 --> 01:05:46,270
我几乎总是会说 到那时你会

1310
01:05:46,270 --> 01:05:47,898
查看某种用法信息 

1311
01:05:47,898 --> 01:05:49,690
事实上 这就是我现在看到的 

1312
01:05:49,690 --> 01:05:53,332
我刚刚运行了Python of meows.py空格破折号h 

1313
01:05:53,332 --> 01:05:54,040
我会再来一次 

1314
01:05:54,040 --> 01:05:57,820
让我清除我的屏幕 这一次用英语做破折号帮助 回车 

1315
01:05:57,820 --> 01:05:59,320
我也看到了同样的事情 

1316
01:05:59,320 --> 01:06:01,510
目前它并不是很有用 

1317
01:06:01,510 --> 01:06:04,540
它只是告诉我这里的用法是什么 

1318
01:06:04,540 --> 01:06:06,200
这是一种有趣的现象 

1319
01:06:06,200 --> 01:06:08,470
这是计算中的标准语法 

1320
01:06:08,470 --> 01:06:11,200
我们以前在Python的文档中看到过这一点 

1321
01:06:11,200 --> 01:06:14,530
当然 这只是意味着程序的名称是meows.py 

1322
01:06:14,530 --> 01:06:20,060
方括号在文档中几乎总是这样 这意味着它是可选的 

1323
01:06:20,060 --> 01:06:22,862
所以我不需要输入破折号h 但我可以 

1324
01:06:22,862 --> 01:06:27,220
我不需要输入破折号n和另一个值 但我可以 

1325
01:06:27,220 --> 01:06:30,400
然后 下面是对这些选项的一些解释 

1326
01:06:30,400 --> 01:06:32,530
更详细地告诉我 我也可以

1327
01:06:32,530 --> 01:06:34,900
DASH DASH帮助 而不是DASH 

1328
01:06:34,900 --> 01:06:36,075
但这太普通了 

1329
01:06:36,075 --> 01:06:37,700
这和我的计划无关 

1330
01:06:37,700 --> 01:06:39,783
这不会对我的用户有所帮助 因为我实际上

1331
01:06:39,783 --> 01:06:41,390
向全世界发布这款软件 

1332
01:06:41,390 --> 01:06:43,000
因此 让我继续改进它 

1333
01:06:43,000 --> 01:06:46,960
让我在我的参数解析器中添加一个人类将会看到的描述 

1334
01:06:46,960 --> 01:06:51,220
像猫一样叫 引述 将是这个名字的价值

1335
01:06:51,220 --> 01:06:52,690
参数称为Description 

1336
01:06:52,690 --> 01:06:56,830
我还可以在我的破折号n中添加一个帮助参数

1337
01:06:56,830 --> 01:07:01,630
这个论点只是解释了破折号n的意思 猫咪的次数 

1338
01:07:01,630 --> 01:07:02,657
引用不引用 

1339
01:07:02,657 --> 01:07:04,240
我不会再做任何改变了 

1340
01:07:04,240 --> 01:07:08,680
但我将返回到我的终端窗口 运行Python of Meow 

1341
01:07:08,680 --> 01:07:13,750
我将运行Python of meows.py dash h 或者等效破折号Help 

1342
01:07:13,750 --> 01:07:17,570
现在请注意 这对用户更加友好 

1343
01:07:17,570 --> 01:07:19,900
如果我向上滚动 我们仍然可以看到相同的用法 

1344
01:07:19,900 --> 01:07:22,660
但是有一句简单的英语解释

1345
01:07:22,660 --> 01:07:24,310
这个程序的猫叫声就像猫一样 

1346
01:07:24,310 --> 01:07:28,540
如果我现在看看选项 哦 这就是n的意思 

1347
01:07:28,540 --> 01:07:30,940
这是猫咪叫的次数 

1348
01:07:30,940 --> 01:07:34,280
这个大写的N 一个心理变量 如果你愿意的话 

1349
01:07:34,280 --> 01:07:37,930
只是向我表明我需要按照惯例键入一个数字

1350
01:07:37,930 --> 01:07:40,780
在小写的破折号n之后 

1351
01:07:40,780 --> 01:07:43,930
所以 尽管如此 还是很好的 

1352
01:07:43,930 --> 01:07:47,800
如果我的程序在没有任何命令行的情况下运行时仍然没有崩溃

1353
01:07:47,800 --> 01:07:48,490
争论 

1354
01:07:48,490 --> 01:07:52,090
理想情况下 我的程序会像处理我的手动版本一样处理这件事

1355
01:07:52,090 --> 01:07:54,430
当我自己使用sys.argv时就是这样 

1356
01:07:54,430 --> 01:07:58,540
因此 我们只需要向该库添加更多功能 

1357
01:07:58,540 --> 01:08:02,230
如果我阅读文档 我会看到Add参数

1358
01:08:02,230 --> 01:08:04,450
接受另一个命名参数 

1359
01:08:04,450 --> 01:08:09,070
如果需要 可以为破折号n指定一个默认值 例如1 

1360
01:08:09,070 --> 01:08:10,300
我会在那里做的 

1361
01:08:10,300 --> 01:08:13,930
你可以进一步指定它必须是一个整型 

1362
01:08:13,930 --> 01:08:15,910
这还能让我做些什么呢

1363
01:08:15,910 --> 01:08:20,890
就是如果我告诉arg解析器确保破折号n的值是一个整数 

1364
01:08:20,890 --> 01:08:22,810
我不需要手动进行转换 

1365
01:08:22,810 --> 01:08:25,689
我可以在7号线上相信 当

1366
01:08:25,689 --> 01:08:29,800
我访问Args对象中名为n的属性 

1367
01:08:29,800 --> 01:08:32,080
对我来说 这将自动成为一个整型 

1368
01:08:32,080 --> 01:08:34,689
再说一次 这就是图书馆的价值 

1369
01:08:34,689 --> 01:08:37,450
让它为你做所有的工作 这样你就可以回来了

1370
01:08:37,450 --> 01:08:40,090
专注于手头的有趣项目 

1371
01:08:40,090 --> 01:08:42,520
不管你要解决的是什么问题 

1372
01:08:42,520 --> 01:08:45,939
在这种情况下 诚然 没有那么有趣 但像猫一样喵叫 

1373
01:08:45,939 --> 01:08:49,779
现在让我继续运行Python of meows.py并按Enter键 

1374
01:08:49,779 --> 01:08:52,250
这一次 没有争论 

1375
01:08:52,250 --> 01:08:53,410
现在它在猫咪叫 

1376
01:08:53,410 --> 01:08:53,979
为什么？

1377
01:08:53,979 --> 01:08:58,930
因为我指定如果我作为用户不指定破折号n 

1378
01:08:58,930 --> 01:09:01,149
很明显 它的缺省值为1 

1379
01:09:01,149 --> 01:09:04,569
而且我不必将该值从字符串转换为整型

1380
01:09:04,569 --> 01:09:09,760
因为我告诉Arg解析器 请为我设置一个整型 

1381
01:09:09,760 --> 01:09:14,939
现在有任何关于argparse的问题吗 或者实际上是关于这个原理的问题

1382
01:09:14,939 --> 01:09:19,290
只是外包商品的东西 每个人的程序

1383
01:09:19,290 --> 01:09:22,950
最终需要这样做 这样你才能专注于你自己最有趣的部分 

1384
01:09:22,950 --> 01:09:25,319
学生：args.n包含什么？

1385
01:09:25,319 --> 01:09:27,359
大卫·J·马兰：Ars.n包含什么？

1386
01:09:27,359 --> 01:09:35,609
它包含人类在破折号n后的空格后键入的整数 

1387
01:09:35,609 --> 01:09:36,220
问得好 

1388
01:09:36,220 --> 01:09:38,729
还有其他问题吗？

1389
01:09:38,729 --> 01:09:40,473
学生：是的 

1390
01:09:40,473 --> 01:09:45,200
当您指定参数的类型时 

1391
01:09:45,200 --> 01:09:49,250
如果--这是否基本上处理用户输入的异常

1392
01:09:49,250 --> 01:09:50,450
在这种情况下是一根线吗？

1393
01:09:50,450 --> 01:09:51,290
大卫·J·马兰：这是一个非常好的问题 

1394
01:09:51,290 --> 01:09:54,502
假设人类没有键入数字 因此也没有输入 

1395
01:09:54,502 --> 01:09:55,710
好吧 让我们看看会发生什么 

1396
01:09:55,710 --> 01:10:01,730
所以 巨蟒的meows.py破折号n狗 其中狗显然不是一个数字 

1397
01:10:01,730 --> 01:10:02,450
进来吧 

1398
01:10:02,450 --> 01:10:06,140
看 我们看到一条自动生成的错误消息 

1399
01:10:06,140 --> 01:10:07,730
诚然 这有点神秘 

1400
01:10:07,730 --> 01:10:10,160
但我看到了一个提醒 它的用法是什么

1401
01:10:10,160 --> 01:10:13,820
以及对这一点的无效之处的一个次要解释 

1402
01:10:13,820 --> 01:10:15,830
再一次 这是允许你 这是

1403
01:10:15,830 --> 01:10:19,040
是什么让我能够专注于编写我们真正关心的代码

1404
01:10:19,040 --> 01:10:22,280
只是让图书馆为我们自动处理一些东西 

1405
01:10:22,280 --> 01:10:23,150
好的 

1406
01:10:23,150 --> 01:10:26,270
好吧 请允许我提议 现在我们来看看另一个特征

1407
01:10:26,270 --> 01:10:28,190
我们以前见过的巨蟒 

1408
01:10:28,190 --> 01:10:32,630
但事实证明 随着我们的程序变得更加强大 我们可以更有效地使用它

1409
01:10:32,630 --> 01:10:35,990
变得更加复杂 我们试图解决的问题就会变成

1410
01:10:35,990 --> 01:10:36,830
更多的参与 

1411
01:10:36,830 --> 01:10:42,020
让我继续前进 转到VS Code 结束meows.py 

1412
01:10:42,020 --> 01:10:45,050
例如 创建一个名为unpack.py的新文件 

1413
01:10:45,050 --> 01:10:47,120
所以unpack.py的代码 

1414
01:10:47,120 --> 01:10:49,357
让我来提醒我们 拆开行李是什么意思 

1415
01:10:49,357 --> 01:10:52,190
因为这实际上是我们以前见过的Python的一个特性 

1416
01:10:52,190 --> 01:10:54,770
例如 假设我编写了一个程序 

1417
01:10:54,770 --> 01:10:58,040
提示用户输入他们的名字 如David space Malan 

1418
01:10:58,040 --> 01:11:01,160
如果我们可以拆分用户名不是很好吗

1419
01:11:01,160 --> 01:11:02,593
变成两个独立的变量？

1420
01:11:02,593 --> 01:11:05,760
当我们在过去做到这一点时 我们用了几种不同的方式 

1421
01:11:05,760 --> 01:11:10,910
但其中一项涉及拆解从那里返回的单一价值 

1422
01:11:10,910 --> 01:11:13,340
类似于列表或一些其他数据结构 

1423
01:11:13,340 --> 01:11:15,750
并立即将其转化为两个变量 

1424
01:11:15,750 --> 01:11:16,890
所以让我们在这里开始吧 

1425
01:11:16,890 --> 01:11:20,360
让我们继续调用输入函数 

1426
01:11:20,360 --> 01:11:24,020
问别人你叫什么名字 问号 

1427
01:11:24,020 --> 01:11:27,770
然后 让我继续 只是在一个单独的空格上有点天真地分开 

1428
01:11:27,770 --> 01:11:29,960
所以我假设目前唯一的用户

1429
01:11:29,960 --> 01:11:32,570
是不是像我这样的人 大卫·斯派克·马兰 

1430
01:11:32,570 --> 01:11:34,310
没有中间名 没有多个名字 

1431
01:11:34,310 --> 01:11:37,610
它只有一个和两个 这本身就可能对其他用户来说是错误的 

1432
01:11:37,610 --> 01:11:39,950
但现在 我简单地说 只是为了提醒我们

1433
01:11:39,950 --> 01:11:43,572
我现在可以用类似于first这样代码来解包返回值

1434
01:11:43,572 --> 01:11:47,287
最后一个下划线等于输入的返回值 

1435
01:11:47,287 --> 01:11:49,370
现在我可以继续做这样的事情 

1436
01:11:49,370 --> 01:11:53,340
就像用f字符串打印 Hello 逗号 然后用大括号括起来 

1437
01:11:53,340 --> 01:11:53,840
第一 

1438
01:11:53,840 --> 01:11:57,500
如果我只是想问候自己或任何其他用户 您好 大卫 

1439
01:11:57,500 --> 01:11:58,820
没有姓氏 

1440
01:11:58,820 --> 01:12:00,770
坦率地说 如果我不用姓 

1441
01:12:00,770 --> 01:12:04,580
回想一下 一个Python约定只是将其命名为下划线 以表明

1442
01:12:04,580 --> 01:12:06,650
你知道你没有使用那个值 

1443
01:12:06,650 --> 01:12:10,590
但它确实需要存在 因为您同时解包了两个值 

1444
01:12:10,590 --> 01:12:13,310
因此 如果我运行这个程序 它不会那么陌生 

1445
01:12:13,310 --> 01:12:15,470
我现在要运行的是unpack.py的Python 

1446
01:12:15,470 --> 01:12:17,660
我将输入David Malan 它只有一个空格 

1447
01:12:17,660 --> 01:12:20,510
现在我们看到了 你好 逗号 大卫 

1448
01:12:20,510 --> 01:12:25,130
好吧 事实证明 还有其他方法可以解开价值 

1449
01:12:25,130 --> 01:12:27,980
此外 Python还提供了其他功能 尤其是

1450
01:12:27,980 --> 01:12:31,220
在定义和使用函数时 

1451
01:12:31,220 --> 01:12:33,658
这是稍微多一点的中间功能 

1452
01:12:33,658 --> 01:12:35,450
如果你愿意 这是很有用的 因为你可以

1453
01:12:35,450 --> 01:12:38,150
开始编写更优雅、更强大的代码 一旦您

1454
01:12:38,150 --> 01:12:40,650
熟悉这样的语法 

1455
01:12:40,650 --> 01:12:43,190
所以让我继续并建议我们不只是玩 

1456
01:12:43,190 --> 01:12:48,140
你好的名字了 但相反 做一些也许

1457
01:12:48,140 --> 01:12:50,230
又牵扯到毒品了

1458
01:12:50,230 --> 01:12:51,980
所以也许不是美元和美分 但也许 

1459
01:12:51,980 --> 01:12:54,530
又像过去一样 一些大帆船和镰刀 

1460
01:12:54,530 --> 01:12:57,590
其中有一个数学关系 

1461
01:12:57,590 --> 01:13:00,680
魔法世界里有多少人是平等的

1462
01:13:00,680 --> 01:13:02,160
让我继续做这个 

1463
01:13:02,160 --> 01:13:05,750
让我定义一个简单的函数total它告诉我

1464
01:13:05,750 --> 01:13:10,280
一个人在古灵阁的金库的总价值 巫师银行 

1465
01:13:10,280 --> 01:13:13,050
他们有多少加隆 镰刀和坚果

1466
01:13:13,050 --> 01:13:15,920
这些都是魔法世界的货币

1467
01:13:15,920 --> 01:13:17,460
我们真实的人类世界

1468
01:13:17,460 --> 01:13:21,140
所以这个total函数可能会接受一个像加隆和镰刀这样的变量

1469
01:13:21,140 --> 01:13:22,457
还有这样的坚果

1470
01:13:22,457 --> 01:13:25,040
然后 它会返回公式 我承认

1471
01:13:25,040 --> 01:13:26,120
我自己也不得不抬头 

1472
01:13:26,120 --> 01:13:30,800
事实证明 将加隆和镰刀

1473
01:13:30,800 --> 01:13:32,510
就是这个

1474
01:13:32,510 --> 01:13:39,710
加隆乘以17再加上镰刀 再乘以29 

1475
01:13:39,710 --> 01:13:41,540
添加单个knuts 

1476
01:13:41,540 --> 01:13:45,230
不知道这在书或电影中有什么细节 

1477
01:13:45,230 --> 01:13:47,370
但我们有了官方公式 

1478
01:13:47,370 --> 01:13:47,870
好吧

1479
01:13:47,870 --> 01:13:49,770
现在我们开始吧

1480
01:13:49,770 --> 01:13:53,390
让我们继续 只使用一些样本输入来调用total函数 

1481
01:13:53,390 --> 01:13:58,880
假设像哈利这样的人有100加隆、50镰刀和25克努特 

1482
01:13:58,880 --> 01:14:01,310
让我把它打印在屏幕上 

1483
01:14:01,310 --> 01:14:05,210
如果total返回一个整数 我认为这个算术表达式

1484
01:14:05,210 --> 01:14:10,280
我会做的 让我继续存储 而是传递total的返回值

1485
01:14:10,280 --> 01:14:11,300
打印.

1486
01:14:11,300 --> 01:14:13,940
为了清楚起见 让我在最后写上Knuts 所以呢？

1487
01:14:13,940 --> 01:14:18,050
我知道这里的度量单位确实是knuts总数 

1488
01:14:18,050 --> 01:14:19,880
现在 让我在终端窗口中

1489
01:14:19,880 --> 01:14:22,310
运行unpack.py的Python并按Enter键 

1490
01:14:22,310 --> 01:14:27,350
从数学上看 如果我的数学是正确的 

1491
01:14:27,350 --> 01:14:36,320
100艘帆船加50把镰刀再加25克朗等于50,775克朗 

1492
01:14:36,320 --> 01:14:39,170
只是为了避免在这里使用我们自己的人类货币 

1493
01:14:39,170 --> 01:14:43,740
但至少到目前为止 我还没有做任何拆包的事情 

1494
01:14:43,740 --> 01:14:45,710
既然我这样做了 让我来求婚吧 

1495
01:14:45,710 --> 01:14:48,110
为了便于讨论 让我提议

1496
01:14:48,110 --> 01:14:50,480
我让整个函数保持原样 

1497
01:14:50,480 --> 01:14:54,270
但让我继续下去 把我所有的硬币都存储在一个列表中 

1498
01:14:54,270 --> 01:14:59,300
所以硬币按从左到右的顺序 100 50 25 它

1499
01:14:59,300 --> 01:15:01,640
只是因为不管这个故事的目的是什么

1500
01:15:01,640 --> 01:15:05,570
我把我所有的硬币都按这个顺序列在一张单子上 

1501
01:15:05,570 --> 01:15:08,250
有点像钱包或钱包 

1502
01:15:08,250 --> 01:15:09,830
好吧 我怎么才能把这个传进去呢？

1503
01:15:09,830 --> 01:15:12,170
好吧 我不会两次硬编码相同的值 

1504
01:15:12,170 --> 01:15:14,150
只是为了讨论 我怎么能

1505
01:15:14,150 --> 01:15:18,440
是否将列表的各个元素传递给我的Total函数？

1506
01:15:18,440 --> 01:15:21,110
当然 我可以一如既往地对待这份名单

1507
01:15:21,110 --> 01:15:24,890
使用数字索引 通过将硬币放在括号0中 

1508
01:15:24,890 --> 01:15:27,620
硬币括号一 硬币括号二 

1509
01:15:27,620 --> 01:15:29,660
所以这是老派的东西 有清单 

1510
01:15:29,660 --> 01:15:32,540
如果我有一个名为Coins的清单 有三个元素 

1511
01:15:32,540 --> 01:15:37,070
这些元素的索引或索引分别为0、1和2

1512
01:15:37,070 --> 01:15:38,070
从左到右 

1513
01:15:38,070 --> 01:15:42,740
所以我现在要做的就是传入第一个元素

1514
01:15:42,740 --> 01:15:47,210
从大帆船的名单中 第二个元素是镰刀 

1515
01:15:47,210 --> 01:15:50,810
这张清单的第三个元素是我的坚果 

1516
01:15:50,810 --> 01:15:53,270
当然 这与签名一致

1517
01:15:53,270 --> 01:15:57,110
这个函数 正如Total所期望的那样 我已经传递了这三个

1518
01:15:57,110 --> 01:15:59,152
事物按从左到右的顺序排列 

1519
01:15:59,152 --> 01:16:01,610
让我继续跑吧 只是为了确保我没有摔断

1520
01:16:01,610 --> 01:16:03,650
任何内容 解包.py并按Enter键 

1521
01:16:03,650 --> 01:16:06,380
而且 算术仍然是正确的 

1522
01:16:06,380 --> 01:16:08,810
但这变得有点冗长了--

1523
01:16:08,810 --> 01:16:10,040
有点长篇大论 

1524
01:16:10,040 --> 01:16:13,970
如果我能把硬币清单递给你

1525
01:16:13,970 --> 01:16:15,500
到这个总的功能吗？

1526
01:16:15,500 --> 01:16:20,540
如果我能说点什么就好了 硬币 

1527
01:16:20,540 --> 01:16:28,380
但让我停下来问一下大家 为什么这实际上不能像现在这样工作？

1528
01:16:28,380 --> 01:16:30,900
从技术上讲 这三个都通过了 

1529
01:16:30,900 --> 01:16:34,140
但是为什么我运行这个的时候会出现错误呢？

1530
01:16:34,140 --> 01:16:35,340
埃里克？

1531
01:16:35,340 --> 01:16:38,455
因为你要把一份名单交给大帆船 

1532
01:16:38,455 --> 01:16:39,330
DAVID J. MALAN：是的 

1533
01:16:39,330 --> 01:16:42,900
我给加隆发了一份名单 没有给镰刀和坚果的 

1534
01:16:42,900 --> 01:16:44,830
请注意 它们没有默认值 

1535
01:16:44,830 --> 01:16:46,770
第一行没有等号

1536
01:16:46,770 --> 01:16:49,020
这意味着Python不会知道

1537
01:16:49,020 --> 01:16:51,340
这里应该假定什么值 

1538
01:16:51,340 --> 01:16:53,790
所以看起来好像是行不通的 

1539
01:16:53,790 --> 01:16:55,710
另外 这是错误的类型 正如埃里克所指出的 

1540
01:16:55,710 --> 01:16:59,470
它是一个列表 而不是之前的整数 

1541
01:16:59,470 --> 01:17:01,500
让我们运行这个错误的版本 

1542
01:17:01,500 --> 01:17:04,920
Python of unpack.py Enter type error.

1543
01:17:04,920 --> 01:17:06,880
这可能是你所期望的 

1544
01:17:06,880 --> 01:17:08,580
就像我把这里的人搞得一团糟

1545
01:17:08,580 --> 01:17:12,120
我需要传入两个位置参数 sickles

1546
01:17:12,120 --> 01:17:13,920
和knuts 甚至没有通过 

1547
01:17:13,920 --> 01:17:15,750
所以我肯定犯了错 

1548
01:17:15,750 --> 01:17:18,780
但如果唯一的解决办法

1549
01:17:18,780 --> 01:17:22,893
就是做我之前做的 索引到第一个元素 index

1550
01:17:22,893 --> 01:17:24,810
索引到第三个元素 

1551
01:17:24,810 --> 01:17:27,360
你可以想象 有了更大的功能 

1552
01:17:27,360 --> 01:17:30,810
我会用更多的论证 这会变得非常冗长 

1553
01:17:30,810 --> 01:17:35,070
很容易受到错误的影响 我的错别字 

1554
01:17:35,070 --> 01:17:38,400
但这里也是你可以做已知的事情的地方 

1555
01:17:38,400 --> 01:17:41,250
在Python中解包一个值 

1556
01:17:41,250 --> 01:17:44,970
现在 一个列表包含多个值 

1557
01:17:44,970 --> 01:17:49,538
我当前的列表有这三个值 分别为100、50和25 

1558
01:17:49,538 --> 01:17:51,330
但它们都在这张单子上 

1559
01:17:51,330 --> 01:17:54,450
如果我能打开那张单子 

1560
01:17:54,450 --> 01:17:59,820
就像我之前解包str类的拆分的返回值一样

1561
01:17:59,820 --> 01:18:02,220
功能也有很多 

1562
01:18:02,220 --> 01:18:04,350
事实上 我可以做到 

1563
01:18:04,350 --> 01:18:10,480
事实上 Python允许我传递的不是硬币 而是星币 

1564
01:18:10,480 --> 01:18:13,890
因此 如果您在变量的开头使用单个星号 

1565
01:18:13,890 --> 01:18:15,540
这会把它拆开的 

1566
01:18:15,540 --> 01:18:20,340
它将需要一个序列 在这里是三个大小的硬币 

1567
01:18:20,340 --> 01:18:25,200
如果你愿意的话 把它分解成三个单独的论点 

1568
01:18:25,200 --> 01:18:26,430
不需要逗号 

1569
01:18:26,430 --> 01:18:28,170
Python只会为您处理这一点 

1570
01:18:28,170 --> 01:18:32,040
但传递星币的效果是

1571
01:18:32,040 --> 01:18:36,400
传递该名单中的个别成员 

1572
01:18:36,400 --> 01:18:39,540
在这种情况下 它们将分别是100、50和25 

1573
01:18:39,540 --> 01:18:42,480
这很完美 因为现在它将与大帆船排成一列 

1574
01:18:42,480 --> 01:18:44,320
分别是镰刀和坚果 

1575
01:18:44,320 --> 01:18:49,500
所以现在 当我运行unpack.py的Python时 我们又回到了业务中

1576
01:18:49,500 --> 01:18:50,670
算术证明了这一点 

1577
01:18:50,670 --> 01:18:54,390
但我已经通过引入这个新符号来清理我的代码 它

1578
01:18:54,390 --> 01:18:58,030
当然 我们已经在乘法和类似的其他上下文中使用过 

1579
01:18:58,030 --> 01:19:02,130
但现在 它也被用来以这种方式拆包 

1580
01:19:02,130 --> 01:19:04,740
对我们刚刚做的事有疑问吗？

1581
01:19:04,740 --> 01:19:09,090
它是一个单一的运营商 但它已经相当强大了 

1582
01:19:09,090 --> 01:19:12,180
因为它允许我们提取数据结构并将其解包

1583
01:19:12,180 --> 01:19:14,340
并逐一传递 

1584
01:19:14,340 --> 01:19:22,890
学生：这对元组、集合、字典、字典也适用吗？

1585
01:19:22,890 --> 01:19:25,430
大卫·J·马兰：是的 Tuples 

1586
01:19:25,430 --> 01:19:27,530
套装我不知道 

1587
01:19:27,530 --> 01:19:32,000
[?兰申？？]我不知道秩序是否得到了维护 

1588
01:19:32,000 --> 01:19:33,110
不是的 

1589
01:19:33,110 --> 01:19:37,103
哦 是不是没有 还是你在查？

1590
01:19:37,103 --> 01:19:38,020
秩序没有得到维护 

1591
01:19:38,020 --> 01:19:40,900
所以它不能和SET一起工作？

1592
01:19:40,900 --> 01:19:42,090
它不适用于SET 

1593
01:19:42,090 --> 01:19:43,710
不适用于SET 

1594
01:19:43,710 --> 01:19:46,770
抱歉 我在这里用语音搜索只是为了省去一些按键 

1595
01:19:46,770 --> 01:19:51,062
因此 它适用于秩序确实保持不变的枚举 

1596
01:19:51,062 --> 01:19:52,770
稍后我们将看到另一个例子

1597
01:19:52,770 --> 01:19:55,520
它实际上可以在词典中以不同的方式使用 

1598
01:19:55,520 --> 01:19:57,420
它现在确实维持着秩序 

1599
01:19:57,420 --> 01:20:00,720
关于用这种方式拆包还有什么问题吗？

1600
01:20:00,720 --> 01:20:01,350
学生：是的 

1601
01:20:01,350 --> 01:20:02,070
嗨 

1602
01:20:02,070 --> 01:20:02,987
大卫·J·马兰：你好 

1603
01:20:02,987 --> 01:20:07,290
学生：你能用解包的方法得到值吗 比如10加50

1604
01:20:07,290 --> 01:20:13,205
加25而不是for循环 然后结果加？

1605
01:20:13,205 --> 01:20:14,580
大卫·J·马兰：简短的回答是否定的 

1606
01:20:14,580 --> 01:20:18,030
如果您想要单个值 您应该只对其进行索引 在本例中 

1607
01:20:18,030 --> 01:20:20,710
进入那些特定的地点 

1608
01:20:20,710 --> 01:20:25,767
这将返回多个值 相当于逗号分隔的列表 

1609
01:20:25,767 --> 01:20:27,600
因此 如果您使用较早的方法

1610
01:20:27,600 --> 01:20:30,060
关心各个地点 

1611
01:20:30,060 --> 01:20:32,670
还有一个关于拆包的问题怎么样？

1612
01:20:32,670 --> 01:20:35,190
学生：如果我们宣布--

1613
01:20:35,190 --> 01:20:37,500
我们声明了一些缺省值 

1614
01:20:37,500 --> 01:20:44,690
如果你用这个作为两个点 它会正确地出去 还是会跳过它？

1615
01:20:44,690 --> 01:20:45,940
大卫·J·马兰：问得好 

1616
01:20:45,940 --> 01:20:47,773
如果我没听错 比如 

1617
01:20:47,773 --> 01:20:51,900
该列表在这里有四个类似的值 而您仍在将其解包

1618
01:20:51,900 --> 01:20:53,730
当只有三个人的时候 这是意料之中的 

1619
01:20:53,730 --> 01:20:54,570
好吧 让我们试一试 

1620
01:20:54,570 --> 01:20:58,140
Python of unpack.py Enter 

1621
01:20:58,140 --> 01:20:59,280
另一个类型错误 

1622
01:20:59,280 --> 01:21:02,560
这一次 它需要三个立场论点 但给出了四个 

1623
01:21:02,560 --> 01:21:06,390
因此 作为程序员 我们有责任在这种情况下不这样做 

1624
01:21:06,390 --> 01:21:09,090
所以可能很脆弱 但如果我是

1625
01:21:09,090 --> 01:21:11,470
控制此列表的内容 

1626
01:21:11,470 --> 01:21:14,730
事实上 让我提议现在我们来看看这个的另一个变种 

1627
01:21:14,730 --> 01:21:18,480
因此 我们不仅使用位置论元 

1628
01:21:18,480 --> 01:21:21,720
我们相信第一种是帆船 第二种是镰刀 

1629
01:21:21,720 --> 01:21:22,680
第三个是克努茨 

1630
01:21:22,680 --> 01:21:25,950
假设我们实际上传递了名称 就像我们在Python中被允许做的那样 

1631
01:21:25,950 --> 01:21:28,560
然后 从技术上讲 我们可以按任何顺序传递它们

1632
01:21:28,560 --> 01:21:31,830
而Python会使用命名参数来解决这个问题 

1633
01:21:31,830 --> 01:21:32,940
好吧 我该怎么做呢？

1634
01:21:32,940 --> 01:21:35,190
嗯 一开始会有一点倒退 

1635
01:21:35,190 --> 01:21:37,560
因此 让我在这里删除这个列表 

1636
01:21:37,560 --> 01:21:41,520
现在让我将其更改为仅手动传递我关心的值 

1637
01:21:41,520 --> 01:21:44,010
大帆船 我想还是等于100 

1638
01:21:44,010 --> 01:21:46,380
Sickles我想等于50 

1639
01:21:46,380 --> 01:21:49,540
和坚果 我想等于25 

1640
01:21:49,540 --> 01:21:52,140
所以这是老式的参数传递 

1641
01:21:52,140 --> 01:21:53,310
它不再是定位的 

1642
01:21:53,310 --> 01:21:56,040
我正在显式地指定这些参数的名称 

1643
01:21:56,040 --> 01:21:58,830
但这会奏效的 因为这是

1644
01:21:58,830 --> 01:22:02,520
我的Total函数中这些参数的名称到底是什么

1645
01:22:02,520 --> 01:22:03,240
和以前一样 

1646
01:22:03,240 --> 01:22:05,790
尽管如此 让我们确保我没有打碎任何东西 

1647
01:22:05,790 --> 01:22:10,020
让我们运行unpack.py Enter的Python 

1648
01:22:10,020 --> 01:22:13,800
我们有了它 还有50775克朗 

1649
01:22:13,800 --> 01:22:21,150
好吧 一旦你开始给事物命名和取值 命名和取值 

1650
01:22:21,150 --> 01:22:25,290
这可能会让人想起我们最通用的数据之一

1651
01:22:25,290 --> 01:22:29,670
结构 甚至是字典中的结构 

1652
01:22:29,670 --> 01:22:33,600
请记住 字典只是键值对、名称的集合

1653
01:22:33,600 --> 01:22:35,200
以及他们各自的价值观 

1654
01:22:35,200 --> 01:22:37,330
因此 这种方式打开了一个机会 

1655
01:22:37,330 --> 01:22:38,470
如果我这么做了呢 

1656
01:22:38,470 --> 01:22:42,810
如果由于某种原因 我的程序中确实有一个变量

1657
01:22:42,810 --> 01:22:44,190
和以前一样 它被称为硬币 

1658
01:22:44,190 --> 01:22:47,460
但不是像以前那样将其列为三个值的列表 

1659
01:22:47,460 --> 01:22:49,240
如果它是一本合适的词典呢？

1660
01:22:49,240 --> 01:22:53,910
所以如果是大帆船 引用引号 其中100个是冒号100 

1661
01:22:53,910 --> 01:22:59,415
Sickles引用了其中的50个 Knuts引用了其中的25个 

1662
01:22:59,415 --> 01:23:02,790
每一个都用冒号隔开 

1663
01:23:02,790 --> 01:23:06,120
让我把我的方括号固定到这个时间

1664
01:23:06,120 --> 01:23:10,200
花括号 回想一下 这是我们在词典中使用的符号

1665
01:23:10,200 --> 01:23:12,240
或在Python中对对象进行DICT 

1666
01:23:12,240 --> 01:23:14,880
所以现在 我有一本叫Coins的词典 

1667
01:23:14,880 --> 01:23:15,790
不是一份名单 

1668
01:23:15,790 --> 01:23:20,430
它是钥匙和价值的集合 三把钥匙 帆船 镰刀 坚果 

1669
01:23:20,430 --> 01:23:24,180
和三个值 分别为100、50和25 

1670
01:23:24,180 --> 01:23:29,910
如果我现在将这些单独的值传递到我的总函数中 

1671
01:23:29,910 --> 01:23:32,800
我可以用我的词典一如既往地做这件事 

1672
01:23:32,800 --> 01:23:34,140
所以我现在用老派的方式来做 

1673
01:23:34,140 --> 01:23:36,060
硬币是我词典的名字 

1674
01:23:36,060 --> 01:23:39,960
我不像列表那样用数字来索引 而是用词来索引 

1675
01:23:39,960 --> 01:23:44,250
所以大帆船 像这样的弦 硬币 引号 

1676
01:23:44,250 --> 01:23:46,210
那里有方括号里的镰刀 

1677
01:23:46,210 --> 01:23:49,500
最后是硬币 方括号 不引用 坚果 

1678
01:23:49,500 --> 01:23:51,540
所以它变得--它又是冗长的 

1679
01:23:51,540 --> 01:23:53,340
这可能不是最好的下坡路 

1680
01:23:53,340 --> 01:23:54,940
但我们稍后会后退一步 

1681
01:23:54,940 --> 01:23:58,800
这就是如何 如果你碰巧把所有的硬币都储存起来了

1682
01:23:58,800 --> 01:24:02,580
在词典中 你可以把帆船、镰刀和坚果

1683
01:24:02,580 --> 01:24:04,543
分别放入您的功能中 

1684
01:24:04,543 --> 01:24:06,210
让我们确保我没有打碎任何东西 

1685
01:24:06,210 --> 01:24:10,290
让我们重新运行unpack.py的Python 我们仍然很好 

1686
01:24:10,290 --> 01:24:12,390
现在 我们怎么会有这样的情况呢？

1687
01:24:12,390 --> 01:24:16,740
好的 像往常一样 想象一下这个程序比这里的稍微长一点 

1688
01:24:16,740 --> 01:24:19,230
不知何故 你在使用一本词典

1689
01:24:19,230 --> 01:24:21,630
只是为了跟踪某人的钱包或钱包 

1690
01:24:21,630 --> 01:24:24,450
比如他们每种类型的硬币有多少 

1691
01:24:24,450 --> 01:24:27,120
因此 使用词典是完全合理的 

1692
01:24:27,120 --> 01:24:29,010
但然后你想要打印出总数 

1693
01:24:29,010 --> 01:24:29,700
然后把它补上 

1694
01:24:29,700 --> 01:24:34,650
如果Total函数不需要字典 因此您不能这样做

1695
01:24:34,650 --> 01:24:37,380
一些好的和简单的东西 比如在硬币中传递 

1696
01:24:37,380 --> 01:24:39,690
出于我们前面看到的原因 这将是一个类型错误 

1697
01:24:39,690 --> 01:24:42,480
Total需要三个参数 三个整数 

1698
01:24:42,480 --> 01:24:44,890
你不能就这么传一本词典 

1699
01:24:44,890 --> 01:24:48,330
但如果这就是你用来存储个人钱包的数据结构

1700
01:24:48,330 --> 01:24:51,090
或者钱包 嗯 这是一种不幸

1701
01:24:51,090 --> 01:24:54,180
我们在这些数据类型之间存在这种冲突 

1702
01:24:54,180 --> 01:24:55,990
好吧 这就是我们能做的 

1703
01:24:55,990 --> 01:24:57,420
我们不能把硬币放进去 

1704
01:24:57,420 --> 01:25:00,750
因为请注意 如果我尝试这样做并运行unpack.py的Python 

1705
01:25:00,750 --> 01:25:02,850
我们收到另一个类型错误 

1706
01:25:02,850 --> 01:25:05,160
缺少两个必需的位置参数 

1707
01:25:05,160 --> 01:25:08,700
镰刀和坚果 我必须通过三件事 

1708
01:25:08,700 --> 01:25:14,310
但是 令人惊叹的是 Python还允许您解开词典 

1709
01:25:14,310 --> 01:25:18,450
对于词典来说 你不是使用一个星号 而是两个 

1710
01:25:18,450 --> 01:25:21,960
以及该语法的作用是什么

1711
01:25:21,960 --> 01:25:26,070
正在传递三个带名称的值 

1712
01:25:26,070 --> 01:25:30,870
它的效果是传递等同于100个逗号的帆船 

1713
01:25:30,870 --> 01:25:35,880
镰刀等于50个逗号 坚果等于25个 

1714
01:25:35,880 --> 01:25:39,570
因此 它具有类似于列表解包的效果 

1715
01:25:39,570 --> 01:25:44,550
但这只是传入的值 实际上是用逗号分隔的100、50、25 

1716
01:25:44,550 --> 01:25:48,270
在解压缩词典时 它会传入键

1717
01:25:48,270 --> 01:25:52,590
并且在概念上用等号分隔的值

1718
01:25:52,590 --> 01:25:55,290
就像我们的函数所期望的那样 

1719
01:25:55,290 --> 01:25:59,310
所以如果我现在再次运行unpack.py的Python 我们仍然是好的 

1720
01:25:59,310 --> 01:26:01,230
但我们又加强了代码

1721
01:26:01,230 --> 01:26:03,240
现在 我给了自己另一个选择 

1722
01:26:03,240 --> 01:26:08,910
我可以把巫师的钱包或钱包放在他们的...

1723
01:26:08,910 --> 01:26:10,440
就像我们之前做的那样 

1724
01:26:10,440 --> 01:26:13,410
或者我可以把它存储在一个更多功能的地方--甚至更多

1725
01:26:13,410 --> 01:26:16,270
用字典来代替 

1726
01:26:16,270 --> 01:26:18,270
所以 说清楚点 让我倒回去 

1727
01:26:18,270 --> 01:26:22,230
星星硬币是一样的 如果我倒带

1728
01:26:22,230 --> 01:26:26,430
第一个命名参数的例子

1729
01:26:26,430 --> 01:26:28,680
和我在这里强调的是一样的 

1730
01:26:28,680 --> 01:26:32,940
当你解压缩一个字典时 它会传入所有的键

1731
01:26:32,940 --> 01:26:36,840
所有的值都和这里的语法一样 

1732
01:26:36,840 --> 01:26:39,780
但让我把它收紧 回到我们离开的地方 

1733
01:26:39,780 --> 01:26:41,790
现在有什么问题吗？

1734
01:26:41,790 --> 01:26:44,280
我们能不能在这本字典里 

1735
01:26:44,280 --> 01:26:49,500
我们能不能用一个常量名值对来代替 

1736
01:26:49,500 --> 01:26:52,913
名称值对的数量是可变的？

1737
01:26:52,913 --> 01:26:54,330
大卫·J·马兰：简短的回答 是的 

1738
01:26:54,330 --> 01:26:57,630
你可以有三个以上的键值对 就像我在这里一样 

1739
01:26:57,630 --> 01:27:01,920
但是如果总函数是

1740
01:27:01,920 --> 01:27:03,420
预计只有三个 

1741
01:27:03,420 --> 01:27:06,750
所以如果我在这里添加一些东西 比如让我介绍便士

1742
01:27:06,750 --> 01:27:07,950
魔法世界

1743
01:27:07,950 --> 01:27:11,220
假设我有一便士 例如 

1744
01:27:11,220 --> 01:27:17,440
现在我运行同样的代码 unpack.py的Python 我们又回到了一个类型错误

1745
01:27:17,440 --> 01:27:17,940
再

1746
01:27:17,940 --> 01:27:20,940
当我得到一个意想不到的关键字参数便士 

1747
01:27:20,940 --> 01:27:24,090
因为这不是Total函数所期望的 

1748
01:27:24,090 --> 01:27:27,790
我们马上就会看到 一个很好的解决方案 

1749
01:27:27,790 --> 01:27:29,790
但现在 它不起作用 

1750
01:27:29,790 --> 01:27:33,150
关于用字典或清单拆包的其他问题？

1751
01:27:33,150 --> 01:27:37,230
在列表值中 我们给出了相同数量的参数

1752
01:27:37,230 --> 01:27:40,470
我们在函数中声明了一个默认值 

1753
01:27:40,470 --> 01:27:44,070
现在 如果你用这个星号 它会覆盖那个值吗

1754
01:27:44,070 --> 01:27:46,427
还是跳过默认值

1755
01:27:46,427 --> 01:27:47,760
大卫·J·马兰：问得好 

1756
01:27:47,760 --> 01:27:51,660
例如 如果我们在这里有缺省值 

1757
01:27:51,660 --> 01:27:56,670
等于零 那就是好的一面 

1758
01:27:56,670 --> 01:27:59,730
回想一下 从我们之前对函数的论点的讨论中 

1759
01:27:59,730 --> 01:28:02,760
现在你不需要传递所有这些值了 

1760
01:28:02,760 --> 01:28:05,070
它们将默认为这些零 

1761
01:28:05,070 --> 01:28:08,220
因此 您可以传递少于三个值 

1762
01:28:08,220 --> 01:28:11,910
使用在此场景中未打包的列表或词典 

1763
01:28:11,910 --> 01:28:15,360
我故意不这么做是因为我想让我们

1764
01:28:15,360 --> 01:28:16,980
在这种情况下 这个特定的错误 

1765
01:28:16,980 --> 01:28:21,270
但你绝对可以回到过去 添加这些默认设置 

1766
01:28:21,270 --> 01:28:24,840
所以事实证明 这个单星号或这个双星号

1767
01:28:24,840 --> 01:28:27,060
不仅用于拆包的上下文中 

1768
01:28:27,060 --> 01:28:30,990
在Python中 该语法实际上用作可视指示器

1769
01:28:30,990 --> 01:28:33,900
当在函数中时 它本身很可能

1770
01:28:33,900 --> 01:28:36,960
接受数量可变的参数 

1771
01:28:36,960 --> 01:28:39,210
也就是说 一个函数可以是可变的 

1772
01:28:39,210 --> 01:28:41,880
这意味着它不一定需要 比如说 

1773
01:28:41,880 --> 01:28:43,920
具体有三个论点 

1774
01:28:43,920 --> 01:28:46,020
即使它们有或没有缺省值 

1775
01:28:46,020 --> 01:28:49,990
它可能需要零个 或者一个 或者两个 或者三个 

1776
01:28:49,990 --> 01:28:52,770
事实证明 实现相同想法的语法是

1777
01:28:52,770 --> 01:28:54,490
在精神上非常相似 

1778
01:28:54,490 --> 01:28:56,820
事实上 让我回到VS代码这里 

1779
01:28:56,820 --> 01:28:59,130
让我建议我们从这个代码开始

1780
01:28:59,130 --> 01:29:01,800
摆脱我们对帆船、镰刀和坚果的概念 

1781
01:29:01,800 --> 01:29:04,383
做一些更普通的事情 这样我们就可以

1782
01:29:04,383 --> 01:29:05,800
我看到了这个的语法 

1783
01:29:05,800 --> 01:29:09,240
假设我按如下方式定义一个函数 

1784
01:29:09,240 --> 01:29:11,490
定义一个函数 我们称它为f 

1785
01:29:11,490 --> 01:29:15,210
该函数不会接受特定数量的参数

1786
01:29:15,210 --> 01:29:16,440
但它是一种可变的 

1787
01:29:16,440 --> 01:29:18,930
因此 我将继续在这里使用这个语法 

1788
01:29:18,930 --> 01:29:23,440
星形参数 这表明该函数确实是可变的 

1789
01:29:23,440 --> 01:29:26,850
它需要一些可变数量的位置参数 

1790
01:29:26,850 --> 01:29:29,820
位置 在这个意义上 它们通常从左到右 

1791
01:29:29,820 --> 01:29:32,550
但我还不知道我想支持多少人 

1792
01:29:32,550 --> 01:29:34,560
假设我还想支持

1793
01:29:34,560 --> 01:29:36,720
一些关键字参数 即 

1794
01:29:36,720 --> 01:29:40,140
可以选择调用的命名参数

1795
01:29:40,140 --> 01:29:42,160
每个人都用自己的名字 

1796
01:29:42,160 --> 01:29:44,200
嗯 从语法上讲 这里的惯例是

1797
01:29:44,200 --> 01:29:46,900
就是用两颗星 然后用矮子 

1798
01:29:46,900 --> 01:29:50,290
我可以叫args 或者kwargs 任何我想要的东西 

1799
01:29:50,290 --> 01:29:53,860
但是您会在Python自己的文档中经常看到这样一个约定

1800
01:29:53,860 --> 01:29:57,280
当你有像这样的占位符作为一些参数时

1801
01:29:57,280 --> 01:30:03,220
和一些关键字参数 世界上倾向于使用args和kwargs 

1802
01:30:03,220 --> 01:30:06,760
好的 在这个函数内部 让我们暂时做一些非常简单的事情 

1803
01:30:06,760 --> 01:30:10,600
让我继续打印出字面上引用的位置 

1804
01:30:10,600 --> 01:30:13,870
只是为了告诉自己 同时我的脑海里围绕着

1805
01:30:13,870 --> 01:30:16,810
接下来是什么位置论点 

1806
01:30:16,810 --> 01:30:19,255
让我非常简单地打印出这些参数 

1807
01:30:19,255 --> 01:30:21,130
这不是您通常会做的事情 

1808
01:30:21,130 --> 01:30:23,050
你通常不会简单地接受这些论点

1809
01:30:23,050 --> 01:30:24,925
然后打印出来 不管有多少 

1810
01:30:24,925 --> 01:30:28,930
我现在只是诊断性地做这件事 以向您展示语法是如何工作的 

1811
01:30:28,930 --> 01:30:31,120
现在 让我在我的文件的底部继续--

1812
01:30:31,120 --> 01:30:34,090
这一次我不会费心使用主函数 这样我们就可以只专注于

1813
01:30:34,090 --> 01:30:35,560
关于这个函数f 

1814
01:30:35,560 --> 01:30:38,260
让我继续用三个参数来调用f 

1815
01:30:38,260 --> 01:30:39,850
我将使用与前面相同的论点 

1816
01:30:39,850 --> 01:30:42,670
但我还没有费心给它们起名字 比如大帆船 

1817
01:30:42,670 --> 01:30:44,690
还有镰刀和坚果之类的东西 

1818
01:30:44,690 --> 01:30:46,420
那我有什么呢？

1819
01:30:46,420 --> 01:30:49,180
无论什么调用此函数f的程序 

1820
01:30:49,180 --> 01:30:51,760
但它首先在文件的顶部定义了f 

1821
01:30:51,760 --> 01:30:54,100
它需要一些位置论据 

1822
01:30:54,100 --> 01:30:56,110
一些命名参数 

1823
01:30:56,110 --> 01:30:59,590
目前 我只是打印出位置信息 

1824
01:30:59,590 --> 01:31:01,610
让我继续在我的终端窗口中

1825
01:31:01,610 --> 01:31:04,510
运行unpack.py的Python并按Enter键 

1826
01:31:04,510 --> 01:31:07,930
您将看到传入的位置参数

1827
01:31:07,930 --> 01:31:09,520
显然这是--

1828
01:31:09,520 --> 01:31:12,790
一个序列 100 50 25 

1829
01:31:12,790 --> 01:31:13,900
但请注意这一点 

1830
01:31:13,900 --> 01:31:16,630
如果我在那里清除我的终端窗口并传入其他内容 

1831
01:31:16,630 --> 01:31:18,550
就像五个 第四个论点 

1832
01:31:18,550 --> 01:31:22,450
以前 如果我尝试更改参数的数量

1833
01:31:22,450 --> 01:31:27,250
我正在传递我的总函数 它只被定义为取三个 

1834
01:31:27,250 --> 01:31:29,920
我会得到一个打字错误 一些视觉提示

1835
01:31:29,920 --> 01:31:32,950
不 您不能传递更多或更少的参数

1836
01:31:32,950 --> 01:31:35,410
而不是实际在函数定义中 

1837
01:31:35,410 --> 01:31:36,340
但现在看吧 

1838
01:31:36,340 --> 01:31:38,890
如果我运行unpack.py的Python 这一次

1839
01:31:38,890 --> 01:31:44,500
在100 50 25和5中 第四个论点 所有四个

1840
01:31:44,500 --> 01:31:46,100
一切都很顺利 

1841
01:31:46,100 --> 01:31:50,830
我可以删除所有这些 例如 现在 重新运行我的程序

1842
01:31:50,830 --> 01:31:51,920
在清除我的屏幕之后 

1843
01:31:51,920 --> 01:31:54,250
现在 我在这里只看到一个论点 

1844
01:31:54,250 --> 01:31:56,590
即使后面有逗号 后面什么也没有 

1845
01:31:56,590 --> 01:32:00,842
实际上 这是查看元组时的语法 因此

1846
01:32:00,842 --> 01:32:02,800
逗号只是表示这确实是一个列表 

1847
01:32:02,800 --> 01:32:05,440
但这里面只有一种元素 

1848
01:32:05,440 --> 01:32:07,480
好吧 让我们也变得更好奇一点 

1849
01:32:07,480 --> 01:32:10,210
让我继续倒带到我们

1850
01:32:10,210 --> 01:32:11,890
一开始只有这三个价值观 

1851
01:32:11,890 --> 01:32:15,640
这一次 让我继续打印出我的命名论点 可以说 

1852
01:32:15,640 --> 01:32:18,430
这不是args而是kwargs 

1853
01:32:18,430 --> 01:32:21,280
同样 此语法中的位置参数排在第一位 

1854
01:32:21,280 --> 01:32:24,440
被命名的论点 粗鲁人排在第二位 

1855
01:32:24,440 --> 01:32:26,510
这是Python开出的药方 

1856
01:32:26,510 --> 01:32:29,800
所以现在 让我继续下去 不要只传递这些数字 

1857
01:32:29,800 --> 01:32:32,740
让我继续下去 传递实际命名的参数 

1858
01:32:32,740 --> 01:32:36,850
现在让我来做一些更具体的事情 比如帆船等于100 

1859
01:32:36,850 --> 01:32:40,257
镰刀等于50 坚果等于25 

1860
01:32:40,257 --> 01:32:42,340
我不会费心和道达尔做任何数学运算 

1861
01:32:42,340 --> 01:32:46,060
我现在只想探讨一下这种功能 

1862
01:32:46,060 --> 01:32:47,830
可变数量的参数 

1863
01:32:47,830 --> 01:32:53,920
现在的巧妙之处在于 如果我运行unpack.py的Python并按Enter 就没有问题了 

1864
01:32:53,920 --> 01:32:58,870
kwargs是一个自动的字典 

1865
01:32:58,870 --> 01:33:03,260
包含了所有传递给函数的命名参数 

1866
01:33:03,260 --> 01:33:05,860
也就是说 在设计自己的函数时 

1867
01:33:05,860 --> 01:33:09,250
如果你想支持多个参数 

1868
01:33:09,250 --> 01:33:12,910
也许多于两个 三个 四个 也许是可变数量的参数 

1869
01:33:12,910 --> 01:33:17,080
实际上 您可以支持数量可变的位置参数 

1870
01:33:17,080 --> 01:33:21,490
值逗号值逗号值 或任何数量的命名

1871
01:33:21,490 --> 01:33:24,040
arguments 实际上是将参数的名称

1872
01:33:24,040 --> 01:33:28,760
等于值 然后可能是一个逗号和更多相同的东西 

1873
01:33:28,760 --> 01:33:34,720
现在 我们已经在一些函数中看到过了 

1874
01:33:34,720 --> 01:33:36,250
我们曾经约会过

1875
01:33:36,250 --> 01:33:41,440
我们不一定会把它叫做args或者kwargs 

1876
01:33:41,440 --> 01:33:44,920
但我们至少在野外看到了一个这样的例子 

1877
01:33:44,920 --> 01:33:48,580
回想一下我们的老朋友print 我们已经用了好几个星期了 

1878
01:33:48,580 --> 01:33:51,640
当我们第一次查看打印方式的文档时 

1879
01:33:51,640 --> 01:33:54,590
当时它看起来有点像这样

1880
01:33:54,590 --> 01:33:57,460
要打印的第一个参数是对象 

1881
01:33:57,460 --> 01:34:00,070
我当时在星号处挥了挥手 

1882
01:34:00,070 --> 01:34:02,080
在变量名的开头 

1883
01:34:02,080 --> 01:34:05,860
但是我们有separator 它的默认值是一个空格 

1884
01:34:05,860 --> 01:34:08,270
我们有n 默认值是一个新行 

1885
01:34:08,270 --> 01:34:11,380
还有一些其他的名字的争论 我们挥手表示反对 

1886
01:34:11,380 --> 01:34:13,210
现在我也会这么做

1887
01:34:13,210 --> 01:34:16,900
但是你现在可以从我们的重点中推断出

1888
01:34:16,900 --> 01:34:20,560
在今天的这些十字架上 单星或双星 

1889
01:34:20,560 --> 01:34:21,520
你知道吗

1890
01:34:21,520 --> 01:34:24,640
这是Python文档中的约定

1891
01:34:24,640 --> 01:34:30,440
以指示print采用可变数量的参数 

1892
01:34:30,440 --> 01:34:33,610
所以如果我们看看打印的实际实现 

1893
01:34:33,610 --> 01:34:36,070
Python自己的作者实现的函数 

1894
01:34:36,070 --> 01:34:38,290
它很可能看起来像这样 

1895
01:34:38,290 --> 01:34:40,690
Def print 然后第一个我们的论点

1896
01:34:40,690 --> 01:34:43,240
将是星形对象 从而表明打印

1897
01:34:43,240 --> 01:34:45,440
接受数量可变的参数 

1898
01:34:45,440 --> 01:34:48,070
下一个可能是Sep等于QUOTE

1899
01:34:48,070 --> 01:34:51,730
也可以使用双引号 也可以使用文档中的单引号 

1900
01:34:51,730 --> 01:34:55,057
下一个可以是n 其缺省值是新行 

1901
01:34:55,057 --> 01:34:56,890
然后还有一些其他的命名参数

1902
01:34:56,890 --> 01:34:58,400
我们也没有看过 

1903
01:34:58,400 --> 01:35:00,880
然后 可能在打印函数内部

1904
01:35:00,880 --> 01:35:03,250
可能是由Python的作者实现的

1905
01:35:03,250 --> 01:35:06,130
在对象中有一个类似于for对象的for循环

1906
01:35:06,130 --> 01:35:10,960
这允许他们迭代这些可变数量的对象中的每一个

1907
01:35:10,960 --> 01:35:12,400
并逐一打印出来 

1908
01:35:12,400 --> 01:35:15,220
这就是为什么在过去的节目中 你和我

1909
01:35:15,220 --> 01:35:18,790
我能做的只是打印左括号和右括号

1910
01:35:18,790 --> 01:35:19,930
里面什么都没有 

1911
01:35:19,930 --> 01:35:22,030
或者你和我已经能够打印出一些东西

1912
01:35:22,030 --> 01:35:25,240
例如 Hello world 在这些括号中只有一个字符串 

1913
01:35:25,240 --> 01:35:28,420
或者你和我能够做一段单独的弦乐 你好 

1914
01:35:28,420 --> 01:35:30,880
然后是另一个不带引号的世界 

1915
01:35:30,880 --> 01:35:33,760
从而传递两个或更多的参数 

1916
01:35:33,760 --> 01:35:38,080
所以我们很久以来就有能力使用各种函数 

1917
01:35:38,080 --> 01:35:41,050
因此 您可以传入数量可变的参数 

1918
01:35:41,050 --> 01:35:45,730
您现在通过这个args和kwargs语法得到的是--

1919
01:35:45,730 --> 01:35:48,250
但再说一次 它们不需要被称为--就是

1920
01:35:48,250 --> 01:35:53,290
使用一颗或两颗星来实现这些类型功能能力

1921
01:35:53,290 --> 01:35:55,040
你自己 

1922
01:35:55,040 --> 01:35:58,880
刚才我自己的f函数并没有做任何有趣的事情 

1923
01:35:58,880 --> 01:36:01,250
但它暗示了你如何 如果在未来

1924
01:36:01,250 --> 01:36:06,230
您有一个用于接受零个或一个或多个这两种类型的参数的用例 

1925
01:36:06,230 --> 01:36:12,280
现在对这些类型的争论有什么问题吗？

1926
01:36:12,280 --> 01:36:17,830
学生：如果你打印kwargs 而论点就像一个列表 会发生什么？

1927
01:36:17,830 --> 01:36:18,890
大卫·J·马兰：啊 

1928
01:36:18,890 --> 01:36:20,830
那么 如果像打印列表一样打印参数 会发生什么呢？

1929
01:36:20,830 --> 01:36:21,910
所以我认为我们看到了这一点 

1930
01:36:21,910 --> 01:36:26,650
如果我把我的历史倒回到我有f函数的时候 

1931
01:36:26,650 --> 01:36:28,810
我把它命名为f只是为了非常普通 

1932
01:36:28,810 --> 01:36:30,760
我们可以玩弄一下语法 

1933
01:36:30,760 --> 01:36:32,510
这就是我在这里所拥有的 

1934
01:36:32,510 --> 01:36:35,050
所以这是一个--

1935
01:36:35,050 --> 01:36:38,500
我传入了100个逗号50个逗号25 

1936
01:36:38,500 --> 01:36:41,500
它会自动存储在args中 

1937
01:36:41,500 --> 01:36:44,800
当我运行它时 你实际上可以看到值的序列

1938
01:36:44,800 --> 01:36:46,630
通过运行unpack.py的Python 

1939
01:36:46,630 --> 01:36:50,560
有一个序列都是以单一变量的形式出现的 

1940
01:36:50,560 --> 01:36:52,600
我把它打印出来只是为了诊断 

1941
01:36:52,600 --> 01:36:54,940
这并不是一个真正有用或漂亮的程序 

1942
01:36:54,940 --> 01:36:59,740
但它暗示了我们如何才能访问整个价值序列 

1943
01:36:59,740 --> 01:37:03,640
这里还有关于这种方法的其他问题吗？

1944
01:37:03,640 --> 01:37:07,735
学生：我们能把Kwargs从一个函数传递到另一个函数吗？

1945
01:37:07,735 --> 01:37:08,860
大卫·J·马兰：当然 

1946
01:37:08,860 --> 01:37:11,260
您可以将其中任何一个传递给另一个函数 该函数

1947
01:37:11,260 --> 01:37:14,560
如果您想包装另一个函数 您可能需要这样做 

1948
01:37:14,560 --> 01:37:17,260
提供一些附加功能 但仍

1949
01:37:17,260 --> 01:37:23,290
也将所有受支持的参数传递给基础函数 

1950
01:37:23,290 --> 01:37:23,920
好的 

1951
01:37:23,920 --> 01:37:25,780
接下来这个怎么样 

1952
01:37:25,780 --> 01:37:29,860
事实证明 我们可以将其他一些工具添加到您的工具包中

1953
01:37:29,860 --> 01:37:33,670
与Python支持的编程模型的类型相关 

1954
01:37:33,670 --> 01:37:36,250
我们很久以前就开始专注于

1955
01:37:36,250 --> 01:37:38,440
关于在Python语言中的过程性编程 

1956
01:37:38,440 --> 01:37:41,980
由此我们从上到下、从左到右编写代码 定义一些函数 

1957
01:37:41,980 --> 01:37:44,740
或者 如果你愿意 一路上的程序 

1958
01:37:44,740 --> 01:37:47,110
定义变量 并产生副作用 

1959
01:37:47,110 --> 01:37:48,890
并根据需要赋值 

1960
01:37:48,890 --> 01:37:51,700
但后来我们最终引入或真正揭示了

1961
01:37:51,700 --> 01:37:54,340
该Python也是非常面向对象的 

1962
01:37:54,340 --> 01:37:56,920
很多这样的变量 很多这样的类型

1963
01:37:56,920 --> 01:38:00,070
我们使用的所有时间实际上都是物体 

1964
01:38:00,070 --> 01:38:02,950
来自特定类的对象 

1965
01:38:02,950 --> 01:38:05,680
这些类是各种各样的模板 蓝图 

1966
01:38:05,680 --> 01:38:09,370
通过它 您可以在其中封装数据和功能 

1967
01:38:09,370 --> 01:38:11,380
那么我们一路上也看到了一些提示

1968
01:38:11,380 --> 01:38:14,350
第三种编程范例 也就是Python 

1969
01:38:14,350 --> 01:38:18,310
在某种程度上支持 这被称为函数式编程 

1970
01:38:18,310 --> 01:38:21,250
其中的功能比以往任何时候都更加强大

1971
01:38:21,250 --> 01:38:25,630
它们往往不会有副作用 不会在全球范围内打印或改变状态 

1972
01:38:25,630 --> 01:38:28,120
相反 它们是完全独立的

1973
01:38:28,120 --> 01:38:31,240
并可以作为输入和返回值 

1974
01:38:31,240 --> 01:38:34,510
这通常是我们开始整理东西时看到的一个范例 

1975
01:38:34,510 --> 01:38:37,660
特别是使用像我们的排序函数这样的函数

1976
01:38:37,660 --> 01:38:40,390
或Lambda函数时传入该函数

1977
01:38:40,390 --> 01:38:43,240
早在很久以前 我们就想用来排序列表 

1978
01:38:43,240 --> 01:38:46,690
好吧 事实证明 Python还具有其他功能

1979
01:38:46,690 --> 01:38:50,590
让人联想到函数式编程 而且确实是一种强大的方式

1980
01:38:50,590 --> 01:38:53,260
以更不同的方式解决问题 

1981
01:38:53,260 --> 01:38:54,460
让我提出这一点 

1982
01:38:54,460 --> 01:38:57,940
让我提议我在VS代码中创建一个新程序

1983
01:38:57,940 --> 01:39:02,500
关闭我们的unpack.py 这一次创建另一个名为yell的程序 

1984
01:39:02,500 --> 01:39:05,800
假设手头的目标是实现某种程序 从而允许用户

1985
01:39:05,800 --> 01:39:08,470
来传递一个输入 然后它喊出响应

1986
01:39:08,470 --> 01:39:10,450
通过强制所有内容都大写 

1987
01:39:10,450 --> 01:39:12,790
我向那些戴着耳机的人道歉 

1988
01:39:12,790 --> 01:39:13,960
我会调整的 

1989
01:39:13,960 --> 01:39:16,690
因此 让我继续运行yell.py的代码 

1990
01:39:16,690 --> 01:39:19,360
在yell.py中 让我们继续并实现

1991
01:39:19,360 --> 01:39:22,190
一个真正做到这一点的程序 

1992
01:39:22,190 --> 01:39:24,730
让我们继续在这里定义一个主函数 

1993
01:39:24,730 --> 01:39:28,060
让我们暂时假设这个Yell函数已经存在

1994
01:39:28,060 --> 01:39:32,860
然后喊出这样的话：这是CS50 大写正确 不是全部大写 

1995
01:39:32,860 --> 01:39:37,090
现在 让我们继续使用def yell实现这个yell函数 

1996
01:39:37,090 --> 01:39:41,590
目前 它将只需要一个单词或短语 

1997
01:39:41,590 --> 01:39:42,760
让我们继续前进 

1998
01:39:42,760 --> 01:39:44,530
我把它叫做短语 

1999
01:39:44,530 --> 01:39:48,820
接下来 我会打印出短语 

2000
01:39:48,820 --> 01:39:51,910
这就是说 UPPER将会把HOLE这个东西变成大写 

2001
01:39:51,910 --> 01:39:54,760
像往常一样 如果这个文件的名称等于

2002
01:39:54,760 --> 01:39:59,620
等于引号不加引号的main 那么让我们像往常一样继续 并调用main 

2003
01:39:59,620 --> 01:40:00,642
所以让我们来运行这个 

2004
01:40:00,642 --> 01:40:03,100
但在很大程度上 这应该是相当简单的 

2005
01:40:03,100 --> 01:40:08,710
当我运行yell.py的Python时 屏幕上显示的是CS50 

2006
01:40:08,710 --> 01:40:09,730
好的 那很好 

2007
01:40:09,730 --> 01:40:16,120
但是 Yell只期待一个短语 这并不是很好 

2008
01:40:16,120 --> 01:40:18,190
如果我可以 就像印刷品一样 不是很好吗

2009
01:40:18,190 --> 01:40:22,870
一般情况下 传入一个短语、两个、三个或多个单词

2010
01:40:22,870 --> 01:40:25,130
而是作为单独的词语本身 

2011
01:40:25,130 --> 01:40:29,380
所以让我稍微调整一下 把大喊大叫改为不是一个短语

2012
01:40:29,380 --> 01:40:32,330
但是 像单词列表这样的东西怎么样？

2013
01:40:32,330 --> 01:40:35,650
所以最终 我可以像这样喊喊叫 

2014
01:40:35,650 --> 01:40:41,380
引用不引用 这个在列表中 引用不引用 这个在列表中 

2015
01:40:41,380 --> 01:40:43,975
并且 在列表中引用不引号的“CS50” 

2016
01:40:43,975 --> 01:40:46,600
现在我不打算费心讨论类型提示或注释 

2017
01:40:46,600 --> 01:40:50,980
但我只是假设Yell现在已经被定义为接受一系列单词

2018
01:40:50,980 --> 01:40:52,400
就像这里定义的那样 

2019
01:40:52,400 --> 01:40:54,670
但现在我想强迫他们全部使用小写字母 

2020
01:40:54,670 --> 01:40:57,160
所以我不太想做这么简单的事情 

2021
01:40:57,160 --> 01:41:02,890
就像单词中的单词一样 例如 我可以打印给定的单词

2022
01:41:02,890 --> 01:41:05,500
也许现在就以一无所有结束这条线 

2023
01:41:05,500 --> 01:41:10,090
但我认为如果我这样做 yell.py的巨蟒 不 这是不对的 

2024
01:41:10,090 --> 01:41:12,250
我没有强迫任何东西大写 

2025
01:41:12,250 --> 01:41:13,700
所以让我们来解决这个问题 

2026
01:41:13,700 --> 01:41:15,620
那么 让我们继续执行以下操作 

2027
01:41:15,620 --> 01:41:19,940
让我继续并按如下方式累积大写单词 

2028
01:41:19,940 --> 01:41:22,120
让我创建一个名为UPERCASE的变量

2029
01:41:22,120 --> 01:41:25,420
并使用方括号或我们的更多

2030
01:41:25,420 --> 01:41:27,410
详细列表语法 

2031
01:41:27,410 --> 01:41:31,780
现在 让我继续重复这些单词中的每一个 

2032
01:41:31,780 --> 01:41:37,840
对于它们中的每一个 让我们进入上面的大小写列表 附加到它

2033
01:41:37,840 --> 01:41:41,020
当前单词的大写版本 

2034
01:41:41,020 --> 01:41:44,740
这是一种创建名为大写的新列表的方法

2035
01:41:44,740 --> 01:41:48,070
这只是附加、附加、附加到该列表

2036
01:41:48,070 --> 01:41:51,520
循环中的每个当前单词 但改为提升评级 

2037
01:41:51,520 --> 01:41:55,600
现在 让我继续打印出评价较高的榜单 

2038
01:41:55,600 --> 01:41:56,870
这不太对 

2039
01:41:56,870 --> 01:41:58,180
让我们看看这里会发生什么 

2040
01:41:58,180 --> 01:42:01,540
Yell.py的蟒蛇 好的 

2041
01:42:01,540 --> 01:42:04,090
这不太对 因为我觉得我不想

2042
01:42:04,090 --> 01:42:06,100
那些引号或那些方括号 

2043
01:42:06,100 --> 01:42:07,100
我看到的是什么？

2044
01:42:07,100 --> 01:42:09,070
我实际上是在打印一份清单 

2045
01:42:09,070 --> 01:42:13,155
但是 现在我们的一些解包语法可以派上用场 

2046
01:42:13,155 --> 01:42:15,280
我不需要改变我解决这个问题的方法 

2047
01:42:15,280 --> 01:42:18,850
我只需添加一个星号就可以解开大写字母 

2048
01:42:18,850 --> 01:42:22,000
现在 让我继续并重新运行yell.py的Python 

2049
01:42:22,000 --> 01:42:24,370
现在 它实际上只是一种英语 

2050
01:42:24,370 --> 01:42:26,980
没有像引号那样残留的Python语法 

2051
01:42:26,980 --> 01:42:29,290
还有逗号和方括号 

2052
01:42:29,290 --> 01:42:34,690
我现在解开了 这是CS50 作为三个单独的参数打印出来 

2053
01:42:34,690 --> 01:42:38,510
因此 现在这种拆包技术似乎已经很有用了 

2054
01:42:38,510 --> 01:42:41,260
嗯 有点不幸的是 我现在

2055
01:42:41,260 --> 01:42:45,640
不过 我需要以这种方式调用带有值列表的Yell 

2056
01:42:45,640 --> 01:42:47,097
这根本不是常态 

2057
01:42:47,097 --> 01:42:49,180
或者至少 它的用户界面不太友好

2058
01:42:49,180 --> 01:42:51,250
类似于打印函数 其中

2059
01:42:51,250 --> 01:42:54,580
我可以传入零个、一个、两个、三个或任意数量的参数 

2060
01:42:54,580 --> 01:42:58,570
为什么你要让我为你的喊叫功能只传递一个列表？

2061
01:42:58,570 --> 01:42:59,530
嗯 我们可以做得更好 

2062
01:42:59,530 --> 01:43:01,780
让我们采用我们学到的一些新惯例 

2063
01:43:01,780 --> 01:43:05,500
让我们继续 通过去掉方括号来删除列表 

2064
01:43:05,500 --> 01:43:08,380
让我们来传递三个论点 

2065
01:43:08,380 --> 01:43:11,830
现在 我不想做一些事情 比如改变单词的定义

2066
01:43:11,830 --> 01:43:14,707
第一个单词 第二个单词 

2067
01:43:14,707 --> 01:43:16,540
这不会扩大规模 也不会

2068
01:43:16,540 --> 01:43:18,190
处理不同数量的单词 

2069
01:43:18,190 --> 01:43:19,840
但我们现在有一种技术 

2070
01:43:19,840 --> 01:43:23,830
我们可以使用STAR ARGS 这将允许YELL功能

2071
01:43:23,830 --> 01:43:25,870
可以接受任意数量的参数 

2072
01:43:25,870 --> 01:43:28,900
为了具体起见 我们不要泛泛地称它为ARGS 

2073
01:43:28,900 --> 01:43:33,250
让我们给它起个更不言自明的名字吧 就像明星词一样 

2074
01:43:33,250 --> 01:43:37,310
这只是意味着我传入的单词数量是可变的 

2075
01:43:37,310 --> 01:43:39,790
现在 我想 我已经取得了些许进步 

2076
01:43:39,790 --> 01:43:42,220
让我再运行一次 yell.py的Python 

2077
01:43:42,220 --> 01:43:45,050
这是全部大写的CS50 

2078
01:43:45,050 --> 01:43:46,600
但这只是好一点而已 

2079
01:43:46,600 --> 01:43:50,590
因为现在我可以像对待印刷品一样对待大喊大叫 

2080
01:43:50,590 --> 01:43:53,980
你想传多少东西就传多少 印刷品会处理的 

2081
01:43:53,980 --> 01:43:56,860
现在 我的大喊大叫功能看起来就像它看起来一样强大 

2082
01:43:56,860 --> 01:44:00,820
更好的是 它还迫使所有内容都大写 

2083
01:44:00,820 --> 01:44:03,250
事实证明 Python附带了一个名为

2084
01:44:03,250 --> 01:44:07,870
地图 它的生活目的是让你地图 也就是应用

2085
01:44:07,870 --> 01:44:12,590
某些函数作用于某个序列中的每个元素 如列表 

2086
01:44:12,590 --> 01:44:17,470
例如 如果我们想强制每个单词都大写 

2087
01:44:17,470 --> 01:44:22,780
这是传入的单词列表中的CS50 

2088
01:44:22,780 --> 01:44:27,740
我们实际上希望将大写函数映射到这些值中的每一个 

2089
01:44:27,740 --> 01:44:30,130
那么 在Python中使用map可以做到这一点吗？

2090
01:44:30,130 --> 01:44:31,900
让我回到这里来VS Code 

2091
01:44:31,900 --> 01:44:35,800
现在让我提议我重新实现这一点 如下所示 

2092
01:44:35,800 --> 01:44:40,960
我去掉了这三行代码 去掉了那个循环

2093
01:44:40,960 --> 01:44:41,980
尤其是 

2094
01:44:41,980 --> 01:44:45,100
让我仍然声明一个名为upperase的变量 

2095
01:44:45,100 --> 01:44:50,260
但让我将其设置为等于这个名为map的新函数的返回值 

2096
01:44:50,260 --> 01:44:52,450
MAP在这里有两个参数 

2097
01:44:52,450 --> 01:44:56,140
在本例中 是我想要

2098
01:44:56,140 --> 01:44:59,170
映射到一系列值 

2099
01:44:59,170 --> 01:45:03,580
那么 我想对传入的每个单词应用什么函数呢？

2100
01:45:03,580 --> 01:45:05,470
嗯 事实证明 多亏了我的知识

2101
01:45:05,470 --> 01:45:09,310
现在谈到面向对象编程 我知道在str类中

2102
01:45:09,310 --> 01:45:11,320
有一个名为UPPER的函数 

2103
01:45:11,320 --> 01:45:14,440
我们通常使用字符串的名称来调用它

2104
01:45:14,440 --> 01:45:18,400
可变的 上开的帕伦关闭帕伦 

2105
01:45:18,400 --> 01:45:21,760
但是如果您阅读了str类的文档 

2106
01:45:21,760 --> 01:45:25,540
您将看到该函数实际上被描述为str.upper 

2107
01:45:25,540 --> 01:45:30,250
我没有在str.upper的末尾使用圆括号 也就是打开和关闭 

2108
01:45:30,250 --> 01:45:31,960
因为我现在不想宣布 

2109
01:45:31,960 --> 01:45:36,050
我想把这个函数传递给map函数 

2110
01:45:36,050 --> 01:45:40,390
因此映射可以以某种方式添加这些括号 可以这么说 并将其命名为

2111
01:45:40,390 --> 01:45:43,040
这些单词中的每一个 

2112
01:45:43,040 --> 01:45:45,670
这就是MAP非常强大的功能 

2113
01:45:45,670 --> 01:45:48,040
并且确实是函数式编程的一个实例 

2114
01:45:48,040 --> 01:45:51,700
因此 我将另一个函数传递给这个map函数 

2115
01:45:51,700 --> 01:45:52,480
不是说了算 

2116
01:45:52,480 --> 01:45:55,570
我只是通过某种形式的参考来传递它 

2117
01:45:55,570 --> 01:46:00,700
而MAP要为我做的就是重复这些单词 

2118
01:46:00,700 --> 01:46:04,210
对这些单词中的每一个调用str.Upper 然后返回

2119
01:46:04,210 --> 01:46:10,690
对我来说 一个全新的列表将所有这些结果都包含在一个列表中 

2120
01:46:10,690 --> 01:46:14,320
它完全不需要我更加手动地使用

2121
01:46:14,320 --> 01:46:15,190
那份名单 

2122
01:46:15,190 --> 01:46:17,980
我仍然会使用星号大写来打印整个内容 

2123
01:46:17,980 --> 01:46:21,490
所以如果我拿回一个包含三个大写单词的列表 

2124
01:46:21,490 --> 01:46:24,500
我要把它们拆开 全部打印出来 

2125
01:46:24,500 --> 01:46:25,750
所以让我们再来一次 

2126
01:46:25,750 --> 01:46:29,740
Yell.py的Python回车 

2127
01:46:29,740 --> 01:46:31,780
瞧 它还在工作 

2128
01:46:31,780 --> 01:46:34,480
但现在的密码更紧了--

2129
01:46:34,480 --> 01:46:36,690
比以前更紧了 

2130
01:46:36,690 --> 01:46:38,440
所以事实证明我们还有另一种方法

2131
01:46:38,440 --> 01:46:40,690
以一种更好的方式解决这个问题

2132
01:46:40,690 --> 01:46:42,700
毕德式的 或者至少是相当普遍的 

2133
01:46:42,700 --> 01:46:46,360
这是使用一种被称为列表理解的功能 

2134
01:46:46,360 --> 01:46:48,380
如果你愿意的话 这是一个很重要的短语 

2135
01:46:48,380 --> 01:46:50,830
但它指的是使用Python为您提供的功能

2136
01:46:50,830 --> 01:46:54,550
为了非常容易地在不使用循环的情况下构建列表 

2137
01:46:54,550 --> 01:46:57,250
而不调用Append和Append 而是执行所有操作

2138
01:46:57,250 --> 01:47:00,370
总之 大胆地说 优雅的俏皮话 

2139
01:47:00,370 --> 01:47:06,003
那么 我该如何使用这个列表理解的概念呢？

2140
01:47:06,003 --> 01:47:07,420
好吧 让我继续做这件事 

2141
01:47:07,420 --> 01:47:10,330
在yell.py中 在VS代码中 让我继续

2142
01:47:10,330 --> 01:47:12,430
并按如下方式改变我的方法 

2143
01:47:12,430 --> 01:47:16,070
与其使用地图 这是非常好和正确的这种方式 

2144
01:47:16,070 --> 01:47:18,220
让我来给你们展示一下另一种方式 

2145
01:47:18,220 --> 01:47:22,710
列表理解是创建这样一个列表的机会 

2146
01:47:22,710 --> 01:47:24,550
使用这样的方括号 

2147
01:47:24,550 --> 01:47:28,260
但是在这些方括号中编写一个Python表达式 

2148
01:47:28,260 --> 01:47:33,000
这实际上将为您动态生成一个全新的列表

2149
01:47:33,000 --> 01:47:35,610
使用你写的一些逻辑 

2150
01:47:35,610 --> 01:47:38,130
我在这里可能采取的方法是这样的 

2151
01:47:38,130 --> 01:47:43,800
如果我想在这个列表中存储每个单词的大写版本

2152
01:47:43,800 --> 01:47:47,130
在单词列表中 我可以这样做--

2153
01:47:47,130 --> 01:47:53,010
一字不差 一字不差 

2154
01:47:53,010 --> 01:47:54,720
现在 这是一个很大的问题 

2155
01:47:54,720 --> 01:47:58,170
但我敢说 Python程序员喜欢这种功能

2156
01:47:58,170 --> 01:48:02,340
能够在运行中定义其中的列表

2157
01:48:02,340 --> 01:48:06,300
是任何数量的值 你通常会这样做 至少我们已经做到了 

2158
01:48:06,300 --> 01:48:09,630
使用循环构造 然后再次调用Append、Append和Append 

2159
01:48:09,630 --> 01:48:12,810
但这通常需要两行、三行、四行或更多行 

2160
01:48:12,810 --> 01:48:16,350
我在这里强调的这个清单理解

2161
01:48:16,350 --> 01:48:20,190
现在是创造完全相同的东西的另一种方式--

2162
01:48:20,190 --> 01:48:24,180
一张清单里面有一大堆被看好的词 

2163
01:48:24,180 --> 01:48:24,990
哪几个词？

2164
01:48:24,990 --> 01:48:30,180
对于传递给Yell的单词列表中的每个单词

2165
01:48:30,180 --> 01:48:33,360
就会出现在这张清单上 

2166
01:48:33,360 --> 01:48:36,060
这里有关于这个语法的问题吗？

2167
01:48:36,060 --> 01:48:38,640
这肯定需要一点时间来适应 

2168
01:48:38,640 --> 01:48:42,300
因为左边有这个值 所以这个函数在这里调用 

2169
01:48:42,300 --> 01:48:45,270
你在方括号里有这个循环 

2170
01:48:45,270 --> 01:48:48,810
但是 如果您习惯于以这种方式从左侧阅读代码

2171
01:48:48,810 --> 01:48:51,510
向右 这意味着给我大写版本

2172
01:48:51,510 --> 01:48:55,080
在我的单词列表中 每个单词对应的单词 

2173
01:48:55,080 --> 01:48:57,790
关于列表理解的问题在这里？

2174
01:48:57,790 --> 01:48:58,320
学生：嗨 

2175
01:48:58,320 --> 01:49:05,237
你能像If Else一样做条件句 或者组合If、Elif、Else吗？

2176
01:49:05,237 --> 01:49:06,570
大卫·J·马兰：的确 你可以 

2177
01:49:06,570 --> 01:49:08,760
让我回到那个问题上来 在那里我们将看到一个机会

2178
01:49:08,760 --> 01:49:09,885
有条件地做某事 

2179
01:49:09,885 --> 01:49:13,350
但现在 我只是将列表中的每个单词都放在上面 

2180
01:49:13,350 --> 01:49:14,110
问得好 

2181
01:49:14,110 --> 01:49:16,277
还有其他问题吗？

2182
01:49:16,277 --> 01:49:16,860
学生：是的 

2183
01:49:16,860 --> 01:49:18,630
这是函数式编程吗？

2184
01:49:18,630 --> 01:49:24,257
或者我的意思是 这个特殊的东西 我们用单词 单词中的一个单词？

2185
01:49:24,257 --> 01:49:25,590
大卫·J·马兰：不一定 

2186
01:49:25,590 --> 01:49:28,060
我想说 这更多的是一种Python的特性 

2187
01:49:28,060 --> 01:49:28,560
学生：好的 

2188
01:49:28,560 --> 01:49:29,435
大卫·J·马兰：是的 

2189
01:49:29,435 --> 01:49:33,690
MAP是我们使用Lambda的一个非常具体的化身

2190
01:49:33,690 --> 01:49:36,690
并将其作为键属性传递给排序函数 

2191
01:49:36,690 --> 01:49:38,730
不久前的排序函数就是一个例子 

2192
01:49:38,730 --> 01:49:41,310
我们马上就要见面了 

2193
01:49:41,310 --> 01:49:43,680
所以我们甚至可以使用这些列表理解

2194
01:49:43,680 --> 01:49:46,840
筛选结果列表中的值或从中筛选出的值 

2195
01:49:46,840 --> 01:49:50,250
事实上 在VS代码中 让我关闭yell.py并关闭我的终端

2196
01:49:50,250 --> 01:49:50,760
窗户 

2197
01:49:50,760 --> 01:49:53,490
让我在这里创建一个新的项目 它的人生目标是

2198
01:49:53,490 --> 01:49:58,110
也许是用一张和以前一样的学生名单和一个更短的版本

2199
01:49:58,110 --> 01:50:02,370
只需过滤掉格兰芬多的所有学生 

2200
01:50:02,370 --> 01:50:06,090
因此 让我继续创建一个名为Gryffindors.py的文件 

2201
01:50:06,090 --> 01:50:10,170
我要继续复制我的学生名单之前的粘贴 

2202
01:50:10,170 --> 01:50:13,230
至少从一开始就是赫敏、哈利、罗恩和德拉科

2203
01:50:13,230 --> 01:50:17,430
在这里 只是为了让我能专注于一个学生

2204
01:50:17,430 --> 01:50:19,197
碰巧不是斯莱特林的 

2205
01:50:19,197 --> 01:50:21,030
我现在要做的是 如果我想

2206
01:50:21,030 --> 01:50:24,970
为了只过滤掉格兰芬多的学生 让我继续这样做 

2207
01:50:24,970 --> 01:50:27,720
让我创建另一个名为Gryffindors的变量 它

2208
01:50:27,720 --> 01:50:30,480
将等同于下面的列表 

2209
01:50:30,480 --> 01:50:32,680
而这将是一条更长的队伍 

2210
01:50:32,680 --> 01:50:34,830
所以我要主动移动我的方括号

2211
01:50:34,830 --> 01:50:36,480
放在两条不同的线上 

2212
01:50:36,480 --> 01:50:39,240
现在 我将创建一个列表理解 

2213
01:50:39,240 --> 01:50:40,560
我想做这个 

2214
01:50:40,560 --> 01:50:45,450
我希望这份名为格兰芬多的新名单包含每个学生的名字

2215
01:50:45,450 --> 01:50:49,560
对于学生名单中的每个学生 

2216
01:50:49,560 --> 01:50:57,150
但是 如果学生的房子等于引号格兰芬多 

2217
01:50:57,150 --> 01:51:01,290
所以这在精神上和我之前做的几乎是一样的

2218
01:51:01,290 --> 01:51:04,260
根据传递的每个单词创建一个理解列表

2219
01:51:04,260 --> 01:51:05,290
我的喊叫功能 

2220
01:51:05,290 --> 01:51:07,620
但在这里 我这样做是有条件的 

2221
01:51:07,620 --> 01:51:10,350
因此 我从我们对循环的关注中汲取灵感 

2222
01:51:10,350 --> 01:51:14,670
从我们对条件句的关注中得到一些启发 

2223
01:51:14,670 --> 01:51:18,310
将其合并到相同的方括号符号中 

2224
01:51:18,310 --> 01:51:23,340
因此 格兰芬多最终是零个或多个学生的名字 

2225
01:51:23,340 --> 01:51:26,340
其中包含的名字就是结果

2226
01:51:26,340 --> 01:51:32,100
迭代这些学生中的每一个 并且只包括在最终结果中

2227
01:51:32,100 --> 01:51:35,550
房子碰巧是格兰芬多的学生 

2228
01:51:35,550 --> 01:51:38,730
因此 当我继续使用Gryffindors.py的Python运行这段代码时

2229
01:51:38,730 --> 01:51:42,150
然后按回车键 你就会看到 嗯 这里实际上什么都没有发生 

2230
01:51:42,150 --> 01:51:44,320
嗯 那是因为我没有完成节目 

2231
01:51:44,320 --> 01:51:46,737
让我继续 用这个来结束这个程序 

2232
01:51:46,737 --> 01:51:50,760
格兰芬多复数中的每一个格兰芬多--

2233
01:51:50,760 --> 01:51:54,480
更好的是 所以我提前做了所有这些工作是明智的 

2234
01:51:54,480 --> 01:51:56,490
让我继续对所有这些名字进行分类

2235
01:51:56,490 --> 01:51:58,800
使用我们熟悉的排序函数 

2236
01:51:58,800 --> 01:52:02,970
现在让我们继续打印这些格兰芬多的每一个 

2237
01:52:02,970 --> 01:52:06,107
所以现在 注意 如果熟悉书和电影 

2238
01:52:06,107 --> 01:52:08,190
你会知道这四个学生中只有三个

2239
01:52:08,190 --> 01:52:09,360
实际上是在格兰芬多 

2240
01:52:09,360 --> 01:52:14,070
如果我运行Gryffindor.py的巨蟒 我们会看到哈利、赫敏和罗恩 

2241
01:52:14,070 --> 01:52:17,080
但现在也是按顺序排列的 

2242
01:52:17,080 --> 01:52:20,760
所以这只是我们解决同样问题的一种方法 而不仅仅是使用列表

2243
01:52:20,760 --> 01:52:24,810
理解 而是一种列表理解 其中包含这个条件 

2244
01:52:24,810 --> 01:52:27,690
但也有其他方法来解决这个同样的问题 

2245
01:52:27,690 --> 01:52:30,570
然后我们回到Python的一些功能特性上来 

2246
01:52:30,570 --> 01:52:32,640
除了地图等功能外 还有

2247
01:52:32,640 --> 01:52:36,100
还有这个叫做滤镜 可以用来达到同样的效果 

2248
01:52:36,100 --> 01:52:38,760
但如果你愿意的话 用一种更实用的方法 

2249
01:52:38,760 --> 01:52:40,530
让我回到这里的VS代码 

2250
01:52:40,530 --> 01:52:43,440
在相同的例子中 让我这样做 

2251
01:52:43,440 --> 01:52:47,550
让我像以前一样留下上面的原始名单 包括德拉科 

2252
01:52:47,550 --> 01:52:49,530
他其实不是格兰芬多人 

2253
01:52:49,530 --> 01:52:51,960
让我暂时定义一个名为

2254
01:52:51,960 --> 01:52:57,420
格兰芬多 它接受了某种价值 就像学生S 

2255
01:52:57,420 --> 01:52:59,200
然后 让我们开始吧 

2256
01:52:59,200 --> 01:53:04,920
让我们继续说 如果S引用的房子等于格兰芬多 

2257
01:53:04,920 --> 01:53:08,530
然后继续前进 返回True 

2258
01:53:08,530 --> 01:53:12,525
否则 继续并返回FALSE 

2259
01:53:12,525 --> 01:53:14,400
现在 我们以前见过像这样的条件句

2260
01:53:14,400 --> 01:53:16,530
这些都是不必要的冗长 

2261
01:53:16,530 --> 01:53:18,930
我不需要有条件 如果我已经

2262
01:53:18,930 --> 01:53:21,400
在这里问一个布尔问题 

2263
01:53:21,400 --> 01:53:24,000
所以我实际上可以像我们过去做的那样收紧它

2264
01:53:24,000 --> 01:53:28,170
那么 学生的房子等于格兰芬多吗？

2265
01:53:28,170 --> 01:53:30,930
要么它是真的 要么不是 它是假的 

2266
01:53:30,930 --> 01:53:33,150
我不需要显式返回True或False 

2267
01:53:33,150 --> 01:53:36,570
我可以只返回那个布尔值 

2268
01:53:36,570 --> 01:53:38,350
让我们现在就去做这件事 

2269
01:53:38,350 --> 01:53:40,140
和前面一样 我将创建一个变量

2270
01:53:40,140 --> 01:53:43,620
格兰芬多 这是我所有格兰芬多学生的名单

2271
01:53:43,620 --> 01:53:47,430
这一次等于调用Filter的结果 

2272
01:53:47,430 --> 01:53:50,050
筛选器在这里至少接受两个参数 

2273
01:53:50,050 --> 01:53:54,830
其中之一是要调用的函数的名称是Gryffindor 

2274
01:53:54,830 --> 01:53:59,090
我将把这个函数应用到这个序列的每个元素上

2275
01:53:59,090 --> 01:53:59,820
这里 

2276
01:53:59,820 --> 01:54:03,920
在本质上与地图如此相似 我传入了一个函数

2277
01:54:03,920 --> 01:54:07,370
这将应用于序列中的每个元素 

2278
01:54:07,370 --> 01:54:11,070
但是map为序列中的每个元素返回一个值 

2279
01:54:11,070 --> 01:54:13,520
这就是我们强制所有单词都大写的方式 

2280
01:54:13,520 --> 01:54:19,520
但如果我想有条件地把一个学生包括在我的结果格兰芬多

2281
01:54:19,520 --> 01:54:21,920
列表中 我可以改用过滤器 

2282
01:54:21,920 --> 01:54:25,970
Filter期望它的第一个函数不是类似于str.upper的函数 

2283
01:54:25,970 --> 01:54:28,340
而是返回True或False的函数 

2284
01:54:28,340 --> 01:54:33,800
告诉我是否应该包括当前的学生

2285
01:54:33,800 --> 01:54:35,150
从最终名单中选出 

2286
01:54:35,150 --> 01:54:37,970
问题是 他们住在格兰芬多吗？

2287
01:54:37,970 --> 01:54:41,550
我们正在查字典里的房门钥匙 寻找答案 

2288
01:54:41,550 --> 01:54:45,410
因此 最终 我认为我们会得到非常相似的东西 

2289
01:54:45,410 --> 01:54:52,040
对于排序版本中的格兰芬多--我们来看看格兰芬多中的格兰芬多 

2290
01:54:52,040 --> 01:54:56,150
那么让我们继续打印出现在的学生 格兰芬多的名字 

2291
01:54:56,150 --> 01:54:58,010
它现在还不会被解决 

2292
01:54:58,010 --> 01:55:01,910
但是当我在这里运行这个版本的Python的Gryffindors.py并点击Enter时 

2293
01:55:01,910 --> 01:55:03,120
我们又可以继续做生意了

2294
01:55:03,120 --> 01:55:03,800
还没分类

2295
01:55:03,800 --> 01:55:07,100
但我们有赫敏、哈利和罗恩 但没有德拉科 

2296
01:55:07,100 --> 01:55:09,380
如果你回想一下几周前 如果我们

2297
01:55:09,380 --> 01:55:13,190
如果你想要一个字典列表 我们也可以这样做 

2298
01:55:13,190 --> 01:55:16,790
我可以把格兰芬多称为复数 

2299
01:55:16,790 --> 01:55:18,500
我可以传递一个密钥 

2300
01:55:18,500 --> 01:55:21,710
这个密钥可以有一个匿名函数 也就是 

2301
01:55:21,710 --> 01:55:24,350
一个Lambda函数 它接受一个学生作为输入 

2302
01:55:24,350 --> 01:55:29,750
调用它 然后返回值的引号名称 如果我的目标是

2303
01:55:29,750 --> 01:55:33,410
根据学生自己的名字进行排序

2304
01:55:33,410 --> 01:55:36,080
如果我继续运行Gryffindors.py的Python 

2305
01:55:36,080 --> 01:55:37,850
我看到了同样的学生名单 

2306
01:55:37,850 --> 01:55:39,860
但这一次 它的排序 

2307
01:55:39,860 --> 01:55:42,890
我们看到了两种解决这个问题的方法

2308
01:55:42,890 --> 01:55:43,850
格兰芬多的学生

2309
01:55:43,850 --> 01:55:47,090
因此我们可以使用类似列表理解的东西 

2310
01:55:47,090 --> 01:55:50,360
在这个列表理解中做一些过滤 

2311
01:55:50,360 --> 01:55:53,480
包括一个if条件句

2312
01:55:53,480 --> 01:55:55,940
或者我们可以采取更实用的方法

2313
01:55:55,940 --> 01:56:00,410
只需要使用这个过滤器函数 

2314
01:56:00,410 --> 01:56:02,700
我想为自己做这些决定

2315
01:56:02,700 --> 01:56:07,160
然后只包括那些返回true的人 

2316
01:56:07,160 --> 01:56:10,297
对这两种方法有什么问题吗？

2317
01:56:10,297 --> 01:56:10,880
是的 

2318
01:56:10,880 --> 01:56:14,090
我只是有个问题如果我们写一个代码

2319
01:56:14,090 --> 01:56:17,090
就像在以前的版本中 所有内容都被塞进一行 

2320
01:56:17,090 --> 01:56:18,050
不会--

2321
01:56:18,050 --> 01:56:24,770
如果我们检查代码的样式 那么它不会有问题吗？

2322
01:56:24,770 --> 01:56:26,210
因为它的可读性更低

2323
01:56:26,210 --> 01:56:28,400
DAVID J. MALAN：像black这样的格式化程序也是如此

2324
01:56:28,400 --> 01:56:30,680
对这段代码的风格有问题吗

2325
01:56:30,680 --> 01:56:33,800
上一个 所有的东西都塞在一条线上 

2326
01:56:33,800 --> 01:56:34,190
[插话的声音]

2327
01:56:34,190 --> 01:56:35,690
大卫·J·马兰：哦 一个好问题 

2328
01:56:35,690 --> 01:56:38,610
像布莱克这样的人会对这段代码有意见吗？

2329
01:56:38,610 --> 01:56:40,460
好吧 让我回到那个版本 

2330
01:56:40,460 --> 01:56:45,170
使用了更长的列表理解 

2331
01:56:45,170 --> 01:56:50,160
看起来像是 如果我们回到足够远的地方 再给我几个解锁 

2332
01:56:50,160 --> 01:56:52,350
它最终看起来是这样的 

2333
01:56:52,350 --> 01:56:55,500
让我继续在Gryffindors.py上运行Black 

2334
01:56:55,500 --> 01:56:59,170
你会看到我实际上--它稍微重新格式化了一下 

2335
01:56:59,170 --> 01:57:01,230
但我自己会主动解决这个问题 

2336
01:57:01,230 --> 01:57:03,720
如果我这么做了 而且只用了一行 

2337
01:57:03,720 --> 01:57:07,140
但我知道布莱克可能不喜欢这样 它会为我解决这个问题的 

2338
01:57:07,140 --> 01:57:10,740
因此 我只是在自己编写代码之前主动修复了它 

2339
01:57:10,740 --> 01:57:14,730
关于Gryffindors.py上的另一个问题怎么样？

2340
01:57:14,730 --> 01:57:17,640
那么这种使用列表理解或过滤的方法呢？

2341
01:57:17,640 --> 01:57:19,440
学生：是的 

2342
01:57:19,440 --> 01:57:24,360
使用Filter时 不是调用Gryffindor函数 

2343
01:57:24,360 --> 01:57:29,328
你能把它放在滤镜里面吗？

2344
01:57:29,328 --> 01:57:31,620
大卫·J·马兰：你能用格兰芬多的功能吗？

2345
01:57:31,620 --> 01:57:33,685
所以你不会想这样称呼它的 

2346
01:57:33,685 --> 01:57:35,310
因为你不会想要这样做的 

2347
01:57:35,310 --> 01:57:39,180
您希望Filter为您调用函数 如果您是这个意思的话 

2348
01:57:39,180 --> 01:57:43,740
所以我只用它的名字来传递它 

2349
01:57:43,740 --> 01:57:50,040
学生：不 我的意思是 如果你能把报税表写成房子等于

2350
01:57:50,040 --> 01:57:51,900
等于格兰芬多内线[INAUDIBLE] 

2351
01:57:51,900 --> 01:57:53,520
大卫·J·马兰：是的 确实如此 

2352
01:57:53,520 --> 01:57:57,330
事实上 回想一下 我们以前确实使用过这些Lambda函数

2353
01:57:57,330 --> 01:58:01,020
当我们想匿名传递一个又快又脏的函数时

2354
01:58:01,020 --> 01:58:05,040
以允许按词典的不同键进行筛选 

2355
01:58:05,040 --> 01:58:06,490
我们可以在这里这样做 

2356
01:58:06,490 --> 01:58:10,140
我实际上可以把它的本质理解为格兰芬多函数 

2357
01:58:10,140 --> 01:58:13,050
我可以在筛选器调用中更改此函数的名称

2358
01:58:13,050 --> 01:58:17,190
作为另一个Lambda函数 像S一样传入参数 

2359
01:58:17,190 --> 01:58:19,560
就是这么回事 

2360
01:58:19,560 --> 01:58:23,040
我现在可以一起删除我的is Gryffindor函数 

2361
01:58:23,040 --> 01:58:26,400
现在 当我运行Gryffindors.py的Python时 

2362
01:58:26,400 --> 01:58:28,030
我还是得到了同样的答案 

2363
01:58:28,030 --> 01:58:31,440
我并没有费心定义一个函数 只是为了使用它

2364
01:58:31,440 --> 01:58:34,560
在一个且只有一个地方 

2365
01:58:34,560 --> 01:58:36,840
好吧 让我也提议我们给你装备

2366
01:58:36,840 --> 01:58:40,290
使用另一个工具包工具 即词典

2367
01:58:40,290 --> 01:58:41,880
理解也是如此 

2368
01:58:41,880 --> 01:58:45,210
诚然 语法开始变得更加奇怪 

2369
01:58:45,210 --> 01:58:48,330
但随着你对所有这些基本类型和其他类型越来越熟悉 

2370
01:58:48,330 --> 01:58:51,900
这些只是您可以选择使用的工具 但也可能是强有力的工具

2371
01:58:51,900 --> 01:58:53,980
来解决未来的问题 

2372
01:58:53,980 --> 01:58:58,230
有了词典的理解 我们就有能力在飞行中创造

2373
01:58:58,230 --> 01:59:01,200
有键和一些值的词典 但没有

2374
01:59:01,200 --> 01:59:05,580
要做到这一点 需要创建一个空词典 并创建一个for循环 

2375
01:59:05,580 --> 01:59:08,730
遍历该循环 并插入越来越多的键

2376
01:59:08,730 --> 01:59:10,170
和值输入到字典中 

2377
01:59:10,170 --> 01:59:12,400
我们宁可一次做完这一切 

2378
01:59:12,400 --> 01:59:14,640
所以事实上 让我回到VS代码这里 

2379
01:59:14,640 --> 01:59:17,770
现在让我向你求婚 我要这么做 

2380
01:59:17,770 --> 01:59:23,070
让我继续 在这里以老式的方式开始 如下所示 

2381
01:59:23,070 --> 01:59:25,320
让我继续 简化并处理掉这些房子

2382
01:59:25,320 --> 01:59:30,060
这样我们现在就可以把注意力集中在学生名单上了 

2383
01:59:30,060 --> 01:59:32,620
我将继续运行学生 

2384
01:59:32,620 --> 01:59:37,200
我将继续写学生等于引用 赫敏 引用

2385
01:59:37,200 --> 01:59:39,600
引用哈里的话 这一次我们会把它缩短 

2386
01:59:39,600 --> 01:59:42,480
引用罗恩的话 只有格兰芬多的那三个学生 

2387
01:59:42,480 --> 01:59:44,790
我现在要像过去一样积极主动地

2388
01:59:44,790 --> 01:59:47,910
给自己开一张空单 这样我就有东西可以积累了

2389
01:59:47,910 --> 01:59:49,905
中提供了这个问题的一些答案 

2390
01:59:49,905 --> 01:59:51,780
现在 我要做这样的事情 

2391
01:59:51,780 --> 01:59:55,450
对于学生和学生 所以我可以迭代他们每一个人 

2392
01:59:55,450 --> 01:59:57,960
让我们继续 看看格兰芬多的名单

2393
01:59:57,960 --> 02:00:01,950
在它后面加上学生的名字 

2394
02:00:01,950 --> 02:00:04,260
所以引用不带引号的名字 然后是学生 这

2395
02:00:04,260 --> 02:00:05,820
确实是他们在名单上的名字 

2396
02:00:05,820 --> 02:00:09,003
现在 让我们继续 把这些学生都放在格兰芬多 

2397
02:00:09,003 --> 02:00:10,920
我知道这三个学生在格兰芬多 

2398
02:00:10,920 --> 02:00:13,260
所以假设手头的问题是我

2399
02:00:13,260 --> 02:00:18,190
我想建立一个只包含格兰芬多的词典列表

2400
02:00:18,190 --> 02:00:18,690
学生们 

2401
02:00:18,690 --> 02:00:20,970
因此 它在某种程度上是对以前版本的一种倒退

2402
02:00:20,970 --> 02:00:23,430
在那里我已经有了名字和房子 

2403
02:00:23,430 --> 02:00:26,640
现在 假设问题是我知道他们所有人的名字 

2404
02:00:26,640 --> 02:00:29,550
但我还没有学生词典本身 

2405
02:00:29,550 --> 02:00:34,380
因此 我正在重建我之前认为理所当然的同一结构 

2406
02:00:34,380 --> 02:00:37,200
现在 让我们继续 只是为了讨论

2407
02:00:37,200 --> 02:00:40,300
把这些格兰芬多打印出来 这样我们就能看到我们建造了什么 

2408
02:00:40,300 --> 02:00:43,080
如果我在提示符中运行Gryffindors.py的Python 

2409
02:00:43,080 --> 02:00:45,270
我看到了一些隐晦的语法 

2410
02:00:45,270 --> 02:00:47,640
但是 再说一次 寻找我们的小提示 

2411
02:00:47,640 --> 02:00:51,120
我在末尾有一个方括号 在开头有一个方括号 

2412
02:00:51,120 --> 02:00:53,760
这表明 一如既往 这是一份名单 

2413
02:00:53,760 --> 02:00:56,520
然后我就有了一大堆花括号

2414
02:00:56,520 --> 02:00:58,740
有一大堆被引用的钥匙 

2415
02:00:58,740 --> 02:01:00,630
按照惯例 它们碰巧是单引号 

2416
02:01:00,630 --> 02:01:02,910
在词典上使用打印时 

2417
02:01:02,910 --> 02:01:06,000
但这只是一个视觉指标 表明这是我的关键 

2418
02:01:06,000 --> 02:01:08,190
第一个值是赫敏 

2419
02:01:08,190 --> 02:01:09,660
第二把钥匙是房子 

2420
02:01:09,660 --> 02:01:11,460
这个值就是格兰芬多 

2421
02:01:11,460 --> 02:01:15,420
然后是逗号 它将一个DICT对象与下一个DICT对象隔开 

2422
02:01:15,420 --> 02:01:17,370
如果我们抛开哈利和格兰芬多 

2423
02:01:17,370 --> 02:01:21,450
哈利和格兰芬多和罗恩之间还有第二个逗号

2424
02:01:21,450 --> 02:01:22,540
格兰芬多也是 

2425
02:01:22,540 --> 02:01:26,280
因此 简而言之 以下是一些代码 通过这些代码我可以相当手动地

2426
02:01:26,280 --> 02:01:30,330
在原本为空的列表中使用for循环构建

2427
02:01:30,330 --> 02:01:35,910
与之前相同的数据结构 只是为格兰芬多学生减去了Draco 

2428
02:01:35,910 --> 02:01:39,060
但这也是词典释义的地方

2429
02:01:39,060 --> 02:01:43,290
或者真的先列出理解 我们可以更简洁地做这件事吗？

2430
02:01:43,290 --> 02:01:45,270
让我清除我的终端窗口 

2431
02:01:45,270 --> 02:01:49,720
让我们去掉这个最初为空的列表和这个for循环

2432
02:01:49,720 --> 02:01:51,460
添加 添加 添加到它上面 

2433
02:01:51,460 --> 02:01:52,960
我们就这么做吧 

2434
02:01:52,960 --> 02:01:58,120
Gryffindors变量将等于下面的列表理解 

2435
02:01:58,120 --> 02:02:01,660
在这个列表里 我想要一本结构化的词典

2436
02:02:01,660 --> 02:02:04,180
写着某人的名字和他们的名字 

2437
02:02:04,180 --> 02:02:07,420
某个人的房子 只是现在 格兰芬多 

2438
02:02:07,420 --> 02:02:08,380
就是这样 

2439
02:02:08,380 --> 02:02:13,870
但我想要这些花括号里的一个Dict对象

2440
02:02:13,870 --> 02:02:18,110
对于每一个学生来说 在学生中 

2441
02:02:18,110 --> 02:02:23,230
所以这里也是 在我用方括号列出的理解中 

2442
02:02:23,230 --> 02:02:25,960
我想要一个标明的物体--

2443
02:02:25,960 --> 02:02:29,290
我想要一本花括号标明的词典 

2444
02:02:29,290 --> 02:02:32,440
我希望每本词典都有两把钥匙--

2445
02:02:32,440 --> 02:02:35,560
姓名和房屋 其值

2446
02:02:35,560 --> 02:02:40,060
是学生的名字 这里只有Gryffindor 

2447
02:02:40,060 --> 02:02:43,300
我想从哪些学生那里创建这些词典对象？

2448
02:02:43,300 --> 02:02:45,230
嗯 对于学生中的学生来说 

2449
02:02:45,230 --> 02:02:48,010
所以 再一次 在左边 我在最终列表中得到了我想要的东西 

2450
02:02:48,010 --> 02:02:50,740
在右边 我有一个循环 这一次 是无条件的 

2451
02:02:50,740 --> 02:02:54,140
我想把格兰芬多的这些学生都当作他们的家 

2452
02:02:54,140 --> 02:02:58,330
现在 让我们再次打印这段代码 即Python of Gryffindors.py并按Enter键 

2453
02:02:58,330 --> 02:03:00,950
现在 我们有了完全相同的产量 

2454
02:03:00,950 --> 02:03:03,520
所以不是三行 而是一行 

2455
02:03:03,520 --> 02:03:06,520
乍一看 这本书有点神秘 

2456
02:03:06,520 --> 02:03:09,520
但一旦熟悉了列表理解和这类语法 

2457
02:03:09,520 --> 02:03:12,560
这只是解决同样问题的另一种方式 

2458
02:03:12,560 --> 02:03:14,560
如果我想要改变这一点并简化该怎么办？

2459
02:03:14,560 --> 02:03:18,100
如果我不想要我现在有的词典列表 那该怎么办？

2460
02:03:18,100 --> 02:03:22,480
同样 根据方括号 我这里有一个包含三个DICT对象的列表 

2461
02:03:22,480 --> 02:03:25,660
如果我只想要一本更大的词典呢？

2462
02:03:25,660 --> 02:03:31,330
里面是一把钥匙 像赫敏冒号格兰芬多 哈里冒号

2463
02:03:31,330 --> 02:03:33,670
格兰芬多 罗恩·科隆·格兰芬多 

2464
02:03:33,670 --> 02:03:34,600
我不需要名单 

2465
02:03:34,600 --> 02:03:36,430
我不需要每个学生单独使用物品 

2466
02:03:36,430 --> 02:03:40,060
我只想要一本大词典

2467
02:03:40,060 --> 02:03:42,850
钥匙是学生的名字和他们房子的价值 

2468
02:03:42,850 --> 02:03:45,010
我想现在没有人会有

2469
02:03:45,010 --> 02:03:47,590
在这个世界上有一个相同的名字 

2470
02:03:47,590 --> 02:03:49,280
好吧 我能做到的 

2471
02:03:49,280 --> 02:03:53,680
让我在这里摆脱这一点 不是创建一个列表理解 但再次 

2472
02:03:53,680 --> 02:03:56,230
这就是所谓的词典理解 

2473
02:03:56,230 --> 02:03:58,450
这里的视觉指示或差异

2474
02:03:58,450 --> 02:04:02,650
这一次 我们不再把它放在方括号里 

2475
02:04:02,650 --> 02:04:04,820
它会变成花括号 

2476
02:04:04,820 --> 02:04:08,770
在这些花括号里 我希望每个键都是什么？

2477
02:04:08,770 --> 02:04:11,170
我希望每个键都是学生的名字 

2478
02:04:11,170 --> 02:04:14,170
我希望现在所有的价值都是格兰芬多的 

2479
02:04:14,170 --> 02:04:17,980
我想为每一个学生做这些 

2480
02:04:17,980 --> 02:04:20,470
现在 事情变得非常有趣 

2481
02:04:20,470 --> 02:04:23,890
这是Python的另一种表现形式 

2482
02:04:23,890 --> 02:04:25,750
从左到右都很清晰 

2483
02:04:25,750 --> 02:04:28,240
绝对需要练习和舒适 

2484
02:04:28,240 --> 02:04:31,180
但这是在创造一个名为格兰芬多的变量

2485
02:04:31,180 --> 02:04:34,660
这是一个字典 每个花括号都有一个 

2486
02:04:34,660 --> 02:04:37,570
每个键都是某个学生的名字 

2487
02:04:37,570 --> 02:04:39,400
每个值都将是格兰芬多 

2488
02:04:39,400 --> 02:04:40,930
什么学生的名字？

2489
02:04:40,930 --> 02:04:43,930
好吧 这本字典的理解将是

2490
02:04:43,930 --> 02:04:48,740
从学生名单中一次一个地构建 

2491
02:04:48,740 --> 02:04:51,490
所以当我现在打印这个的时候 语法看起来会有点不同

2492
02:04:51,490 --> 02:04:53,770
因为它不是字典对象的列表 

2493
02:04:53,770 --> 02:04:56,630
它本身只是一个更大的字典对象 

2494
02:04:56,630 --> 02:05:01,030
但现在打印格兰芬多的人给了我赫敏·科隆格兰芬多 哈利·科隆

2495
02:05:01,030 --> 02:05:05,560
格兰芬多 还有罗恩·科隆·格兰芬多 

2496
02:05:05,560 --> 02:05:10,755
对于我们所说的字典解析 还有什么问题吗？

2497
02:05:14,690 --> 02:05:15,955
有什么问题吗？

2498
02:05:18,670 --> 02:05:19,170
没有吗？

2499
02:05:19,170 --> 02:05:23,070
好吧 让我们从Python的工具箱中介绍另一个函数 

2500
02:05:23,070 --> 02:05:25,770
最后一个特点和繁荣 

2501
02:05:25,770 --> 02:05:27,630
然后你就可以走了

2502
02:05:27,630 --> 02:05:30,720
好吧 让我们继续回想一下 

2503
02:05:30,720 --> 02:05:34,860
回想一下 我们之前有一个简单的学生名单 

2504
02:05:34,860 --> 02:05:37,290
就像我们这里的赫敏哈利和罗恩

2505
02:05:37,290 --> 02:05:40,770
举个例子 很久以前 我们想要打印出来 

2506
02:05:40,770 --> 02:05:44,160
比如说排名从一 二 三 

2507
02:05:44,160 --> 02:05:48,000
不幸的是 当你为学生中的学生做这样的事情时 

2508
02:05:48,000 --> 02:05:50,700
你可以很容易地打印出学生的名字 

2509
02:05:50,700 --> 02:05:53,220
当然 如果我使用Python的Gryffindors.py 

2510
02:05:53,220 --> 02:05:56,010
我把赫敏、哈里、罗恩按同样的顺序排列 

2511
02:05:56,010 --> 02:05:58,020
但我看不到任何数字排名 

2512
02:05:58,020 --> 02:06:00,300
我看不到一号、二号或三号 

2513
02:06:00,300 --> 02:06:04,980
所以我也许可以用一种不同类型的for循环来做这件事 

2514
02:06:04,980 --> 02:06:06,870
与其这样 不如我试试这个吧？

2515
02:06:06,870 --> 02:06:13,770
所以也许我可以在学生名单的长度范围内--

2516
02:06:13,770 --> 02:06:15,670
我们以前也做过类似的事情 

2517
02:06:15,670 --> 02:06:19,320
然后我可以打印出我 我可以打印出学生的名字

2518
02:06:19,320 --> 02:06:22,528
通过在位置i处索引到该列表 

2519
02:06:22,528 --> 02:06:23,820
好吧 这看起来像什么？

2520
02:06:23,820 --> 02:06:27,180
如果我运行Gryffindors.py的Python 它就很接近了 

2521
02:06:27,180 --> 02:06:29,130
但这些人不是程序员 

2522
02:06:29,130 --> 02:06:31,950
他们不一定认为自己是零指数 

2523
02:06:31,950 --> 02:06:34,320
赫敏 他可能想成为第一个 而不是零 

2524
02:06:34,320 --> 02:06:35,290
那么我们怎么才能解决这个问题呢？

2525
02:06:35,290 --> 02:06:35,790
井 

2526
02:06:35,790 --> 02:06:37,260
只是一点算术 

2527
02:06:37,260 --> 02:06:40,897
当然 我可以打印出来 再加上一个 然后是学生的名字 

2528
02:06:40,897 --> 02:06:43,980
因此 如果我清除我的终端窗口并运行Gryffindors.py门禁的Python

2529
02:06:43,980 --> 02:06:47,760
再一次 现在我们有了这个枚举 一 二 

2530
02:06:47,760 --> 02:06:49,470
这些学生每人三个 

2531
02:06:49,470 --> 02:06:51,540
但事实证明 Python实际上有

2532
02:06:51,540 --> 02:06:53,610
一直以来我都有另一个内置功能

2533
02:06:53,610 --> 02:06:55,230
你现在可能会觉得有用 

2534
02:06:55,230 --> 02:06:57,210
那就是列举 

2535
02:06:57,210 --> 02:07:00,210
和枚举允许您解决这类问题

2536
02:07:00,210 --> 02:07:03,660
更简单地通过迭代某个序列

2537
02:07:03,660 --> 02:07:07,810
但并不是一次一个地找出每个值 

2538
02:07:07,810 --> 02:07:12,630
而是一次一个值和它的指数 

2539
02:07:12,630 --> 02:07:15,010
它会同时返回两个答案 

2540
02:07:15,010 --> 02:07:18,240
因此 如果我现在返回到VS代码 并采用这种方法 

2541
02:07:18,240 --> 02:07:21,990
我不需要做这个复杂的范围和长度 

2542
02:07:21,990 --> 02:07:23,730
然后我就到处跑了.

2543
02:07:23,730 --> 02:07:25,620
我可以更简洁地做到这一点 

2544
02:07:25,620 --> 02:07:31,560
我可以说我在枚举返回中逗号学生

2545
02:07:31,560 --> 02:07:33,550
重视学生的传授 

2546
02:07:33,550 --> 02:07:36,150
所以这给我返回了一个枚举 如果你愿意的话 

2547
02:07:36,150 --> 02:07:39,690
现在 我可以像以前一样打印i加1 

2548
02:07:39,690 --> 02:07:41,190
我可以把学生的照片打印出来 

2549
02:07:41,190 --> 02:07:44,625
因此 我不需要使用方括号I表示法来索引列表 

2550
02:07:44,625 --> 02:07:45,750
我不需要给Range打电话 

2551
02:07:45,750 --> 02:07:47,040
我不需要说长度 

2552
02:07:47,040 --> 02:07:50,340
同样 枚举采用像这些学生一样的一系列值 

2553
02:07:50,340 --> 02:07:54,390
它允许我得到当前的索引0 1 2 

2554
02:07:54,390 --> 02:07:58,630
和现值分别为赫敏、哈里、罗恩 

2555
02:07:58,630 --> 02:08:00,330
所以现在 只要进一步收紧就行了 

2556
02:08:00,330 --> 02:08:01,955
事实上 这一直是我们在这里的主题 

2557
02:08:01,955 --> 02:08:04,770
我们能解决几周来一直在解决的问题吗？

2558
02:08:04,770 --> 02:08:09,320
但是 仅仅使用更多的这个工具包就可以收紧事情了吗？

2559
02:08:09,320 --> 02:08:12,260
请允许我们为您的工具包配备最后一个工具 

2560
02:08:12,260 --> 02:08:16,323
也就是说 这种从函数生成Python值的能力 

2561
02:08:16,323 --> 02:08:18,990
这不是我们以前一定会遇到的问题 

2562
02:08:18,990 --> 02:08:22,340
但事实证明 如果您正在编写一个读取或生成

2563
02:08:22,340 --> 02:08:24,500
大量数据 你的函数 你的程序 

2564
02:08:24,500 --> 02:08:26,990
您的计算机很可能会耗尽内存 

2565
02:08:26,990 --> 02:08:30,410
并且您的程序可能无法继续运行 

2566
02:08:30,410 --> 02:08:33,065
但事实证明这个问题有一个解决方案 那就是

2567
02:08:33,065 --> 02:08:34,940
你的后口袋里可能有一些东西 

2568
02:08:34,940 --> 02:08:38,600
尤其是如果你在这门课结束后开始计算相当多的数字

2569
02:08:38,600 --> 02:08:40,460
并分析更多的数据 

2570
02:08:40,460 --> 02:08:42,233
事实上 让我们回到这里的VS代码 

2571
02:08:42,233 --> 02:08:44,150
让我们继续创建一个程序 它是

2572
02:08:44,150 --> 02:08:47,113
也许在一天中的这个时候很及时 特别是

2573
02:08:47,113 --> 02:08:50,030
根据你所在时区的不同 你可能会感到更加困倦 

2574
02:08:50,030 --> 02:08:52,100
但在美国 这是很常见的

2575
02:08:52,100 --> 02:08:54,590
在你挣扎的时候昏昏欲睡

2576
02:08:54,590 --> 02:08:56,240
通过在你的脑海中数羊 

2577
02:08:56,240 --> 02:08:58,400
通常 就像卡通中描述的那样 你

2578
02:08:58,400 --> 02:09:01,580
你可能会在脑海中看到一只羊跳过栅栏 然后是两只 

2579
02:09:01,580 --> 02:09:03,138
然后是三只羊 然后是四只 

2580
02:09:03,138 --> 02:09:05,180
然后 最终 你可能会觉得很无聊

2581
02:09:05,180 --> 02:09:07,710
数着这些绵羊 你真的睡着了 

2582
02:09:07,710 --> 02:09:11,570
因此 在VS代码中 让我们创建一个名为sleep.py的程序

2583
02:09:11,570 --> 02:09:14,810
这样我就可以打印出一些绵羊的数量

2584
02:09:14,810 --> 02:09:17,750
就像我在脑海里数着它们 

2585
02:09:17,750 --> 02:09:19,610
通过这个项目 让我们做到这一点 

2586
02:09:19,610 --> 02:09:22,250
让我们提示用户输入变量n 设置

2587
02:09:22,250 --> 02:09:25,610
等于输入返回值的整数转换 

2588
02:09:25,610 --> 02:09:27,530
询问用户n是什么？

2589
02:09:27,530 --> 02:09:29,720
他们想试着数一下有多少只羊？

2590
02:09:29,720 --> 02:09:31,760
然后 让我们在这里做一个熟悉的for循环 

2591
02:09:31,760 --> 02:09:33,750
我们将一如既往地从零开始计数 

2592
02:09:33,750 --> 02:09:36,667
所以我们首先会有零只羊 然后是一只羊 然后是两只羊

2593
02:09:36,667 --> 02:09:39,620
对于该值n的范围内的i 为ON 

2594
02:09:39,620 --> 02:09:40,880
继续打印出来吧 

2595
02:09:40,880 --> 02:09:44,090
我会在这里粘贴一个代表一只羊乘以I的表情符号 

2596
02:09:44,090 --> 02:09:46,220
所以在第一次迭代中 我会看到零只绵羊 

2597
02:09:46,220 --> 02:09:49,880
在第二次迭代中 您将看到一个 然后是两个 然后是多少个

2598
02:09:49,880 --> 02:09:53,330
由n指定 最终减去1 

2599
02:09:53,330 --> 02:09:56,690
让我们在这里进入我的终端窗口 并运行sleep.py的Python 

2600
02:09:56,690 --> 02:09:59,450
我应该看到 确实 在输入 比方说 三

2601
02:09:59,450 --> 02:10:03,667
对于我的n值 没有羊 然后是一只羊 然后是两只羊 依此类推 

2602
02:10:03,667 --> 02:10:05,750
如果我把我的终端窗口做得更大 

2603
02:10:05,750 --> 02:10:08,990
当然 我们可以做更多的事情 例如 输入10 

2604
02:10:08,990 --> 02:10:11,870
你会看到随着时间的推移 我们会得到越来越多的羊 

2605
02:10:11,870 --> 02:10:15,740
想必在我脑海中的想象会变得更加乏味 

2606
02:10:15,740 --> 02:10:18,753
现在让我们继续练习我们所学到的东西

2607
02:10:18,753 --> 02:10:21,170
当谈到这个程序的设计时 我一直在说教

2608
02:10:21,170 --> 02:10:24,690
看看我们是否以及什么时候真的会遇到问题 

2609
02:10:24,690 --> 02:10:27,830
现在让我继续进行 并将所有这些放在一个主函数中

2610
02:10:27,830 --> 02:10:30,410
通过在这里一如既往地定义Main 

2611
02:10:30,410 --> 02:10:32,640
让我继续在这里缩进所有这些代码 

2612
02:10:32,640 --> 02:10:34,890
然后 让我像往常一样有条件地这样做 

2613
02:10:34,890 --> 02:10:39,020
如果此文件的名称等于引号 则让我们继续

2614
02:10:39,020 --> 02:10:39,890
然后给Main打电话 

2615
02:10:39,890 --> 02:10:43,520
让我们确保我还没有打碎任何东西 尽管从功能上讲

2616
02:10:43,520 --> 02:10:44,880
应该是差不多的 

2617
02:10:44,880 --> 02:10:48,080
如果我输入三 我仍然是零 然后是一 

2618
02:10:48,080 --> 02:10:50,180
然后屏幕上出现了两只羊 

2619
02:10:50,180 --> 02:10:53,690
但我们一直习惯于创建助手函数

2620
02:10:53,690 --> 02:10:54,380
为了我们自己 

2621
02:10:54,380 --> 02:10:56,510
也就是说 将我们的代码分解为

2622
02:10:56,510 --> 02:11:00,530
允许我们抽象出某些功能 比如生成

2623
02:11:00,530 --> 02:11:03,093
将一些绵羊分成不同的功能 

2624
02:11:03,093 --> 02:11:04,760
所以 第一 他们确实是抽象的 

2625
02:11:04,760 --> 02:11:07,302
我们不再需要考虑它们是如何实施的 

2626
02:11:07,302 --> 02:11:09,860
我们甚至可以在项目中重复使用它们 就像在库中一样 

2627
02:11:09,860 --> 02:11:13,460
但我们现在也有测试这些功能的习惯

2628
02:11:13,460 --> 02:11:14,670
与单元测试一样 

2629
02:11:14,670 --> 02:11:17,660
所以我可能不应该把我所有的逻辑都放在Main里 

2630
02:11:17,660 --> 02:11:19,280
让我们把其中的一些因素考虑在内 

2631
02:11:19,280 --> 02:11:24,980
例如 如果我可以调用一个SHEEP函数 那不是很好吗

2632
02:11:24,980 --> 02:11:27,990
就像这里的这行代码一样 

2633
02:11:27,990 --> 02:11:30,140
与其只在这里打印 不如让我们打印

2634
02:11:30,140 --> 02:11:32,270
新函数的返回值为

2635
02:11:32,270 --> 02:11:37,310
告诉函数要打印多少个绵羊的绵羊 在本例中是我 

2636
02:11:37,310 --> 02:11:40,610
让我们像往常一样在这里创建另一个名为SHEEP的函数 

2637
02:11:40,610 --> 02:11:43,910
SHEEP函数现在将接受一个参数n 该参数指定

2638
02:11:43,910 --> 02:11:45,960
你想还几只羊？

2639
02:11:45,960 --> 02:11:48,440
因此 我们可以像单元测试一样进行测试 

2640
02:11:48,440 --> 02:11:52,430
虽然我们不会在这里这样做 但让我继续 不打印绵羊的数量

2641
02:11:52,430 --> 02:11:53,720
就像通过副作用 

2642
02:11:53,720 --> 02:11:57,830
但让我继续下去 让我把其中的一只羊

2643
02:11:57,830 --> 02:12:00,980
这样用户就可以得到一整串羊 这是

2644
02:12:00,980 --> 02:12:03,320
要打印的适当数字 

2645
02:12:03,320 --> 02:12:05,270
所以从功能上来说 我认为我们还没有

2646
02:12:05,270 --> 02:12:06,890
从根本上改变了一切 

2647
02:12:06,890 --> 02:12:09,860
Pyep.py类型3的Python仍然为我们提供了

2648
02:12:09,860 --> 02:12:11,870
零 然后是一只 然后是两只羊 

2649
02:12:11,870 --> 02:12:18,170
但现在 我们至少有了一个专注于实施的框架

2650
02:12:18,170 --> 02:12:19,640
这种绵羊的功能 

2651
02:12:19,640 --> 02:12:24,890
但现在它还是主要功能 所以有点不雅观

2652
02:12:24,890 --> 02:12:26,330
来完成这个迭代 

2653
02:12:26,330 --> 02:12:28,610
我们在过去的第0周看到过 

2654
02:12:28,610 --> 02:12:31,730
定义一个真正处理

2655
02:12:31,730 --> 02:12:34,040
返回整个字符串的过程

2656
02:12:34,040 --> 02:12:38,180
我们想要的 而不是一次只有一排羊 

2657
02:12:38,180 --> 02:12:39,840
好吧 我想我们可以做到的 

2658
02:12:39,840 --> 02:12:42,630
为什么不让我按照下面的方法去换羊呢？

2659
02:12:42,630 --> 02:12:48,110
让我继续这里 首先创建一群一开始是空的羊

2660
02:12:48,110 --> 02:12:49,410
使用空列表 

2661
02:12:49,410 --> 02:12:55,640
那么对于n范围内的i 让我们继续并附加到该群中 

2662
02:12:55,640 --> 02:12:58,760
例如 一只羊乘以I 所以I

2663
02:12:58,760 --> 02:13:02,570
继续添加零只羊 然后是一只羊 然后是两只羊 然后

2664
02:13:02,570 --> 02:13:03,660
三个 以此类推 

2665
02:13:03,660 --> 02:13:06,500
然后 最终 我要把整群羊

2666
02:13:06,500 --> 02:13:07,130
立刻 

2667
02:13:07,130 --> 02:13:09,510
所以这将返回相当于所有

2668
02:13:09,510 --> 02:13:14,170
这样 啊 Main就可以处理它们的印刷了 

2669
02:13:14,170 --> 02:13:16,110
回到美因河畔 让我们开始吧 

2670
02:13:16,110 --> 02:13:19,110
每只羊怎么样 我就叫它S 因为是羊

2671
02:13:19,110 --> 02:13:24,210
既是单数也是复数 对于S来说 n的绵羊 它再次返回

2672
02:13:24,210 --> 02:13:27,960
给我一份所有绵羊的名单 整个羊群 让我们打印出来

2673
02:13:27,960 --> 02:13:31,260
S 每只羊一只一只地出来 

2674
02:13:31,260 --> 02:13:33,300
所以 到目前为止 我认为这里一切都很好 

2675
02:13:33,300 --> 02:13:36,060
让我继续运行leep.py的Python并按Enter键 

2676
02:13:36,060 --> 02:13:37,380
什么是n3 

2677
02:13:37,380 --> 02:13:40,560
而且 这似乎仍然运作得很好 

2678
02:13:40,560 --> 02:13:45,300
但让我在这里有一点创意 看看

2679
02:13:45,300 --> 02:13:48,790
不只是我屏幕上的三只羊 可能还有10排羊 

2680
02:13:48,790 --> 02:13:50,280
而且 这似乎也很管用 

2681
02:13:50,280 --> 02:13:53,970
让我来点冒险 输入大概100只羊 

2682
02:13:53,970 --> 02:13:56,100
公平地说 它开始看起来很难看 

2683
02:13:56,100 --> 02:13:58,290
但它们都打印得很快 

2684
02:13:58,290 --> 02:14:02,610
让我继续尝试 屏幕上可能有1000只羊 

2685
02:14:02,610 --> 02:14:04,210
它们飞得很快 

2686
02:14:04,210 --> 02:14:05,310
它仍然很凌乱 

2687
02:14:05,310 --> 02:14:06,420
但他们都在那里 

2688
02:14:06,420 --> 02:14:07,740
我们可以把它们都加起来 

2689
02:14:07,740 --> 02:14:11,610
不只是1000只羊 而是1万只羊怎么样？

2690
02:14:11,610 --> 02:14:13,080
嗯 这看起来也没问题 

2691
02:14:13,080 --> 02:14:14,712
它花了大约10倍的时间 

2692
02:14:14,712 --> 02:14:16,920
这就是为什么你会在屏幕上看到这个闪烁 

2693
02:14:16,920 --> 02:14:18,810
所有的羊都还在印刷 

2694
02:14:18,810 --> 02:14:22,420
但是 打印了大量的数据 

2695
02:14:22,420 --> 02:14:27,240
如果我再坚持下去 我们就有希望

2696
02:14:27,240 --> 02:14:32,490
看着一万只羊都过来了 

2697
02:14:32,490 --> 02:14:38,160
这是在这里的视频中 我们将加快时间 一个真正的在线 

2698
02:14:38,160 --> 02:14:38,670
天啊

2699
02:14:38,670 --> 02:14:40,410
这是很多羊 

2700
02:14:40,410 --> 02:14:40,990
好了

2701
02:14:40,990 --> 02:14:41,490
好的.

2702
02:14:41,490 --> 02:14:44,220
现在我所有的羊都被打印出来了 

2703
02:14:44,220 --> 02:14:46,320
所以它看起来工作得很好 

2704
02:14:46,320 --> 02:14:48,420
好吧 让我再大胆一点

2705
02:14:48,420 --> 02:14:50,220
好吧 让我试试运气

2706
02:14:50,220 --> 02:14:56,930
让我试试 这次一百万只羊 按回车键怎么样？

2707
02:14:56,930 --> 02:14:58,250
Ha.

2708
02:14:58,250 --> 02:15:03,070
有什么东西坏了 

2709
02:15:03,070 --> 02:15:06,670
在我们等待剧透的同时 有没有人

2710
02:15:06,670 --> 02:15:12,400
有没有直觉告诉我为什么我的程序突然停止打印绵羊了？

2711
02:15:12,400 --> 02:15:17,320
这个版本出了什么问题 我在这里生成

2712
02:15:17,320 --> 02:15:19,360
一大群羊吗

2713
02:15:19,360 --> 02:15:22,745
我们可能已经耗尽了内存或计算能力 

2714
02:15:22,745 --> 02:15:23,620
DAVID J. MALAN：是的 

2715
02:15:23,620 --> 02:15:26,020
也许我们真的在挑战我的Mac的极限

2716
02:15:26,020 --> 02:15:30,760
我的PC 我的云服务器的内存或CPU 计算机的大脑 

2717
02:15:30,760 --> 02:15:34,570
因为它只是试图产生

2718
02:15:34,570 --> 02:15:38,920
数量巨大的羊的名单 一百万只

2719
02:15:38,920 --> 02:15:41,950
每一排都有很多羊

2720
02:15:41,950 --> 02:15:46,330
看起来我的电脑真的很难用 

2721
02:15:46,330 --> 02:15:48,340
现在这真的很不幸 

2722
02:15:48,340 --> 02:15:50,920
因为看起来即使这个项目很明显

2723
02:15:50,920 --> 02:15:54,760
对1,000只羊来说效果很好 1万只羊 一次

2724
02:15:54,760 --> 02:15:58,520
你跨过了某个门槛 它就完全停止工作了

2725
02:15:58,520 --> 02:16:02,770
或者它只是需要太长的时间 该程序是有用的了 

2726
02:16:02,770 --> 02:16:07,630
但这似乎有点傻 因为理论上 我绝对应该

2727
02:16:07,630 --> 02:16:10,450
如果我只打印一只羊 

2728
02:16:10,450 --> 02:16:15,430
然后马上印两张 然后印三张 四张 五张 

2729
02:16:15,430 --> 02:16:19,180
看起来这个问题的本质 如果我回到我的代码 

2730
02:16:19,180 --> 02:16:24,610
是根据我的最佳实践 我试图实践我所宣扬的 

2731
02:16:24,610 --> 02:16:26,920
似乎最根本的问题是 

2732
02:16:26,920 --> 02:16:31,000
通过创建一个叫做sheep的辅助函数 

2733
02:16:31,000 --> 02:16:34,570
他一生的目的就是做一代一代的绵羊

2734
02:16:34,570 --> 02:16:37,639
然后一次把它们全部送回来 

2735
02:16:37,639 --> 02:16:39,080
这不是更好吗？

2736
02:16:39,080 --> 02:16:41,629
我真的能听到我的风扇现在就开着

2737
02:16:41,629 --> 02:16:43,160
试图生出这些绵羊--

2738
02:16:43,160 --> 02:16:46,940
把羊印成1 2 3 不是更好吗？

2739
02:16:46,940 --> 02:16:47,959
一次四个？

2740
02:16:47,959 --> 02:16:49,219
嗯 我们可以这么做 

2741
02:16:49,219 --> 02:16:51,260
但这确实是一种倒退 

2742
02:16:51,260 --> 02:16:54,469
这与过去几周吸取的所有教训相矛盾 

2743
02:16:54,469 --> 02:16:57,709
通常情况下 不把所有东西都放在Main中是一件好事 

2744
02:16:57,709 --> 02:17:01,280
通常有一个附加功能 然后可以单独测试

2745
02:17:01,280 --> 02:17:02,790
使用单元测试是一件好事 

2746
02:17:02,790 --> 02:17:06,320
我们真的需要放弃所有这些最佳实践吗

2747
02:17:06,320 --> 02:17:09,469
打印出一些绵羊 然后在这里睡着？

2748
02:17:09,469 --> 02:17:12,770
嗯 事实证明这个问题是有解决方案的 

2749
02:17:12,770 --> 02:17:16,129
也就是以这些生成器的形式出现在Python中 

2750
02:17:16,129 --> 02:17:18,410
您可以将函数定义为生成器 

2751
02:17:18,410 --> 02:17:24,059
因此 它仍然可以为您的用户生成海量数据 

2752
02:17:24,059 --> 02:17:28,400
但您可以让它一次只返回其中的一小部分数据 

2753
02:17:28,400 --> 02:17:31,940
您自己也可以用几乎相同的方式实现代码 

2754
02:17:31,940 --> 02:17:36,000
但你不必担心太多的东西会一下子被退回 

2755
02:17:36,000 --> 02:17:38,690
与Python的所有功能一样 这两个功能都有文档记录

2756
02:17:38,690 --> 02:17:40,670
在其中的官方文件中 

2757
02:17:40,670 --> 02:17:45,980
但你最终会发现 这一切归根结底都是这个关键字 

2758
02:17:45,980 --> 02:17:46,940
投降 

2759
02:17:46,940 --> 02:17:49,549
到目前为止 我们一直在制作函数 

2760
02:17:49,549 --> 02:17:54,260
我们一直在定义返回值的函数 如果有的话 

2761
02:17:54,260 --> 02:17:56,059
使用关键字Return 

2762
02:17:56,059 --> 02:17:58,040
事实上 如果我们回到我们这里的代码 

2763
02:17:58,040 --> 02:17:59,969
这正是我一直在等待的 

2764
02:17:59,969 --> 02:18:02,809
我一直在等着马上把整个鸟群送回来 

2765
02:18:02,809 --> 02:18:05,690
不幸的是 如果你等得太久 而我们已经得到了 

2766
02:18:05,690 --> 02:18:08,330
我的节目被引用了被扼杀了 

2767
02:18:08,330 --> 02:18:13,370
也就是说 我的计算机已经厌倦了有多少内存和CPU

2768
02:18:13,370 --> 02:18:16,549
它试图使用它 只是说 不 你根本不会跑 

2769
02:18:16,549 --> 02:18:17,660
这是不幸的 

2770
02:18:17,660 --> 02:18:20,420
现在我的程序不再适用于大量数字

2771
02:18:20,420 --> 02:18:24,110
睡眠--绵羊 如果我真的有麻烦 那就不好了

2772
02:18:24,110 --> 02:18:26,000
某天晚上睡着了 

2773
02:18:26,000 --> 02:18:29,780
那么 我该如何使用Year来解决这个问题呢？

2774
02:18:29,780 --> 02:18:31,070
好吧 那就让我来吧 

2775
02:18:31,070 --> 02:18:36,740
与其在这个名为羊群的大名单上建立这个庞大的绵羊名单 

2776
02:18:36,740 --> 02:18:38,660
让我们就这样做吧 

2777
02:18:38,660 --> 02:18:41,660
让我继续下去 简化整个函数

2778
02:18:41,660 --> 02:18:46,670
如下所示 由此我对n的范围内的i进行迭代 

2779
02:18:46,670 --> 02:18:49,700
然后在每一次迭代中 在过去 我

2780
02:18:49,700 --> 02:18:52,700
可能倾向于使用Return和Return

2781
02:18:52,700 --> 02:18:55,070
就像一只羊乘以我 

2782
02:18:55,070 --> 02:18:56,719
但这在这里行不通 

2783
02:18:56,719 --> 02:18:59,330
因为如果你想要一百万只羊而你

2784
02:18:59,330 --> 02:19:03,290
开始一个for循环 表示i在一百万的范围内 

2785
02:19:03,290 --> 02:19:06,469
您将立即返回意外的零只绵羊 

2786
02:19:06,469 --> 02:19:08,480
然后 这个功能基本上是无用的 

2787
02:19:08,480 --> 02:19:11,785
您不应该在这样的循环中间返回值

2788
02:19:11,785 --> 02:19:14,660
因为你不会得到这些后续迭代中的任何一个

2789
02:19:14,660 --> 02:19:15,160
循环中的 

2790
02:19:15,160 --> 02:19:17,809
它会迭代一次 然后砰的一声 你就会返回 

2791
02:19:17,809 --> 02:19:20,870
但多亏了Python中的另一个关键字

2792
02:19:20,870 --> 02:19:26,540
名为Year 您可以告诉Python实际上只返回一个

2793
02:19:26,540 --> 02:19:28,740
从该循环中一次取值 

2794
02:19:28,740 --> 02:19:31,309
所以如果我回到我的代码的这个版本 

2795
02:19:31,309 --> 02:19:38,719
我说不是回报 而是收益 这就像是说一次返回一个值 

2796
02:19:38,719 --> 02:19:42,770
一次返回一个值 一次返回一个值 

2797
02:19:42,770 --> 02:19:45,500
For循环将继续工作 我将

2798
02:19:45,500 --> 02:19:49,880
继续从零到一 到二 一直到一百万 

2799
02:19:49,880 --> 02:19:52,970
但每一次 这个函数都会给你

2800
02:19:52,970 --> 02:19:54,260
回溯一小段数据 

2801
02:19:54,260 --> 02:19:57,890
可以说 它只会产生一小部分数据 

2802
02:19:57,890 --> 02:19:59,570
并不是所有的数据一次都有 

2803
02:19:59,570 --> 02:20:00,440
这很好 

2804
02:20:00,440 --> 02:20:04,010
因为我的计算机有相当大的内存 当然足够容纳

2805
02:20:04,010 --> 02:20:05,120
一排羊 

2806
02:20:05,120 --> 02:20:07,400
显然 它没有足够的内存来容纳它 

2807
02:20:07,400 --> 02:20:10,430
一百万排这么多的羊 

2808
02:20:10,430 --> 02:20:15,410
所以现在 如果我在终端窗口运行sleep.py的Python 

2809
02:20:15,410 --> 02:20:16,910
输入 n是什么？

2810
02:20:16,910 --> 02:20:20,210
三个也行 零个 一个 两个.

2811
02:20:20,210 --> 02:20:23,930
让我继续增加这个的大小 然后运行Python的sleep. py 

2812
02:20:23,930 --> 02:20:27,980
让我们像以前一样尝试一百万 然后按Enter键 

2813
02:20:27,980 --> 02:20:31,002
现在我马上看到了结果 

2814
02:20:31,002 --> 02:20:32,960
我不认为我们会等到所有这些羊

2815
02:20:32,960 --> 02:20:35,870
打印出来 因为那样的话 我们就都睡着了

2816
02:20:35,870 --> 02:20:40,310
但是你会注意到现在程序没有挂起 

2817
02:20:40,310 --> 02:20:40,810
可以这么说

2818
02:20:40,810 --> 02:20:43,227
不是等待 等待 思考 思考 

2819
02:20:43,227 --> 02:20:45,260
并试图一次产生整个群体 

2820
02:20:45,260 --> 02:20:48,187
它只是一次产生一排羊 

2821
02:20:48,187 --> 02:20:51,020
它在屏幕上闪烁 因为它们太多了 

2822
02:20:51,020 --> 02:20:52,700
这都要归功于屈服 

2823
02:20:52,700 --> 02:20:57,530
它一次生成一点数据 而不是一次生成全部数据 

2824
02:20:57,530 --> 02:21:03,030
现在对这个叫做发电机的功能有什么问题吗？

2825
02:21:06,260 --> 02:21:07,760
有什么问题吗？

2826
02:21:07,760 --> 02:21:10,910
再加一个术语到这个混合体中 只是为了让你听到它 

2827
02:21:10,910 --> 02:21:17,840
这里的相同功能是返回我们现在在技术上称为迭代器的东西 

2828
02:21:17,840 --> 02:21:20,000
Yield返回一个迭代器 

2829
02:21:20,000 --> 02:21:25,550
你自己的代码 你自己的for循环 

2830
02:21:25,550 --> 02:21:27,450
一次一个

2831
02:21:27,450 --> 02:21:34,010
问：这个收益率实际上是如何在引擎盖下工作的？

2832
02:21:34,010 --> 02:21:38,545
我的意思是 它使用多线程吗？

2833
02:21:38,545 --> 02:21:40,670
DAVID J. MALAN：你可以把它的实现

2834
02:21:40,670 --> 02:21:42,860
在这个意义上是异步的 

2835
02:21:42,860 --> 02:21:48,050
函数立即返回一个值 

2836
02:21:48,050 --> 02:21:50,900
然后再还给你一个

2837
02:21:50,900 --> 02:21:52,910
在引擎盖下面 到底发生了什么

2838
02:21:52,910 --> 02:21:55,740
发电机只是为你保留状态 

2839
02:21:55,740 --> 02:21:58,790
它不会从上到下运行整个循环

2840
02:21:58,790 --> 02:22:00,140
然后返回一个值

2841
02:22:00,140 --> 02:22:02,660
它将进行一次迭代并产生一个结果 

2842
02:22:02,660 --> 02:22:07,460
如果你愿意的话 Python会暂停这个函数 

2843
02:22:07,460 --> 02:22:09,650
但请记住它是在什么迭代上 

2844
02:22:09,650 --> 02:22:12,170
所以当你下一次迭代它的时候 

2845
02:22:12,170 --> 02:22:14,570
在Main中的for循环中会反复发生 

2846
02:22:14,570 --> 02:22:17,570
你一次又一次地得到另一个值 

2847
02:22:17,570 --> 02:22:20,300
所以产生回报 实际上 这个东西叫做迭代器 

2848
02:22:20,300 --> 02:22:24,690
该迭代器可以像在循环中一样一次一个元素地跳过 

2849
02:22:24,690 --> 02:22:27,410
但在语言方面 Python会为您处理所有这些

2850
02:22:27,410 --> 02:22:32,120
这样你就不需要自己做所有底层的管道工作了 

2851
02:22:32,120 --> 02:22:36,510
关于这些生成器和积分器的另一个问题如何？

2852
02:22:36,510 --> 02:22:38,990
当我们的羊继续飞过的时候？

2853
02:22:38,990 --> 02:22:41,960
学生：所以如果每一次迭代 程序

2854
02:22:41,960 --> 02:22:46,270
是否会将内存归还给系统 这样程序就不会崩溃？

2855
02:22:46,270 --> 02:22:47,270
大卫·J·马兰：正确 

2856
02:22:47,270 --> 02:22:50,840
在每次迭代中 它只返回一个绵羊字符串 即

2857
02:22:50,840 --> 02:22:53,030
适用于i的当前值 

2858
02:22:53,030 --> 02:22:57,080
它并不是试图返回相同的所有100万行 

2859
02:22:57,080 --> 02:23:00,470
因此 它使用的内存量只有百万分之一 

2860
02:23:00,470 --> 02:23:03,980
尽管这有点过于简单化了 

2861
02:23:03,980 --> 02:23:04,850
好的 

2862
02:23:04,850 --> 02:23:07,040
当这些绵羊继续飞过 

2863
02:23:07,040 --> 02:23:10,130
现在让我继续 打断一下 

2864
02:23:10,130 --> 02:23:13,460
过去 您可能不得不在自己的代码中使用无限循环 

2865
02:23:13,460 --> 02:23:16,250
尽管这不是无限的 但它真的很长--控制

2866
02:23:16,250 --> 02:23:19,400
C会用你的键盘中断那个程序 给我

2867
02:23:19,400 --> 02:23:21,950
控制我的电脑 

2868
02:23:21,950 --> 02:23:25,760
好了 我们现在是在CS50的结尾 S介绍

2869
02:23:25,760 --> 02:23:27,200
到使用Python语言编程 

2870
02:23:27,200 --> 02:23:31,700
如果今天 特别是所有的日子 感觉像是真正的升级

2871
02:23:31,700 --> 02:23:34,040
很快 我就会意识到这些真的--

2872
02:23:34,040 --> 02:23:37,700
这些只是工具包中的附加工具 或许是可选工具

2873
02:23:37,700 --> 02:23:40,520
你可以在过去学到的所有教训上再加一笔 

2874
02:23:40,520 --> 02:23:43,723
因此 当您退出本课程并处理其他课程或项目时

2875
02:23:43,723 --> 02:23:45,890
你自己 你有更多的心理模型

2876
02:23:45,890 --> 02:23:49,220
更像是一个工具箱 用来解决同样的问题 

2877
02:23:49,220 --> 02:23:52,010
如果我们现在回想一下就在几周前 

2878
02:23:52,010 --> 02:23:55,193
这可能是我们重点关注的函数和变量

2879
02:23:55,193 --> 02:23:56,610
你刚开始挣扎的时候 

2880
02:23:56,610 --> 02:23:59,120
但现在回想起来 如果你回顾这些问题

2881
02:23:59,120 --> 02:24:01,670
而那些相同的问题集 几率也是相同的问题

2882
02:24:01,670 --> 02:24:03,560
现在对你来说太容易了 

2883
02:24:03,560 --> 02:24:05,870
条件句是这门课的下一步 其中

2884
02:24:05,870 --> 02:24:08,810
我们给了你提问和获得答案的能力

2885
02:24:08,810 --> 02:24:10,940
因此在您的代码中有条件地执行操作 

2886
02:24:10,940 --> 02:24:12,355
我们今天又绕了一圈 

2887
02:24:12,355 --> 02:24:15,230
你可以看到 你现在可以使用相同类型的条件句

2888
02:24:15,230 --> 02:24:18,680
现在用清单理解和词典来做一些更花哨的事情

2889
02:24:18,680 --> 02:24:19,970
理解和类似的东西 

2890
02:24:19,970 --> 02:24:23,450
当然 几个星期以来 循环已经无处不在 包括今天

2891
02:24:23,450 --> 02:24:25,070
当我们建造那些相同的结构时 

2892
02:24:25,070 --> 02:24:26,750
当然 有些事情可能会出错 

2893
02:24:26,750 --> 02:24:29,600
异常和异常处理是我们的机制

2894
02:24:29,600 --> 02:24:34,022
不仅用于捕获代码中的错误 还用于引发您自己的异常 

2895
02:24:34,022 --> 02:24:36,980
因此 如果您正在为其他人编写代码奠定基础 

2896
02:24:36,980 --> 02:24:39,590
就像在库的形式中一样 您也可以这样做 

2897
02:24:39,590 --> 02:24:43,190
当然 库不仅可以使用 而且现在还可以自己编写 

2898
02:24:43,190 --> 02:24:45,713
它可以是一个小模块或整个代码包

2899
02:24:45,713 --> 02:24:47,880
你想与世界各地的人分享的东西 

2900
02:24:47,880 --> 02:24:52,250
更好的是 你能为你自己的代码 你的库 

2901
02:24:52,250 --> 02:24:53,402
对于其他人的代码也是如此 

2902
02:24:53,402 --> 02:24:55,610
所以最终 你可以更有信心

2903
02:24:55,610 --> 02:24:57,470
今天不仅你的代码是正确的 

2904
02:24:57,470 --> 02:24:59,780
但如果您明天对代码进行更改 

2905
02:24:59,780 --> 02:25:02,960
你没有打碎任何东西 至少根据你的测试

2906
02:25:02,960 --> 02:25:04,580
如果他们继续通过的话 

2907
02:25:04,580 --> 02:25:07,400
与此同时 文件I/O是现在存储的一种方式

2908
02:25:07,400 --> 02:25:10,160
数据不仅存在于计算机内存中 就像所有这些绵羊一样 

2909
02:25:10,160 --> 02:25:13,700
但实际上是将东西持久地、长期地存储到磁盘上 

2910
02:25:13,700 --> 02:25:17,510
在CSV或更像二进制文件(如图像)中 

2911
02:25:17,510 --> 02:25:20,240
使用正则表达式 您就可以

2912
02:25:20,240 --> 02:25:23,870
表示模式并实际验证数据或提取数据

2913
02:25:23,870 --> 02:25:24,620
从信息中 

2914
02:25:24,620 --> 02:25:28,280
如今 当世界上如此多的人

2915
02:25:28,280 --> 02:25:31,370
正在尝试分析和处理大规模的数据 其中一些

2916
02:25:31,370 --> 02:25:35,300
可能实际上从一开始就相当混乱 

2917
02:25:35,300 --> 02:25:38,090
然后 当然 最近的面向对象编程 

2918
02:25:38,090 --> 02:25:40,610
解决同类问题的机会

2919
02:25:40,610 --> 02:25:42,770
但以一种略有不同的视角 一种

2920
02:25:42,770 --> 02:25:47,600
来封装和表示真实世界的实体 这一次是在代码中 

2921
02:25:47,600 --> 02:25:50,720
今天 当然 还有很多其他的工具

2922
02:25:50,720 --> 02:25:54,110
你可以补充说 它不一定属于之前的任何一项

2923
02:25:54,110 --> 02:25:57,410
但雨伞是有用的功能和数据类型 

2924
02:25:57,410 --> 02:26:00,260
和技术 再一次 在你的后口袋里

2925
02:26:00,260 --> 02:26:03,830
还有其他解决问题的机制 

2926
02:26:03,830 --> 02:26:07,170
不仅让每个人都睡着了 我还想了另一种方式来结束

2927
02:26:07,170 --> 02:26:11,670
试着一起写最后一个程序可能会更有说服力 

2928
02:26:11,670 --> 02:26:15,030
这一次使用了我们过去见过的库 也使用了其他库 

2929
02:26:15,030 --> 02:26:19,800
我擅自在我的电脑上安装了一个文本到语音库

2930
02:26:19,800 --> 02:26:20,550
这里 

2931
02:26:20,550 --> 02:26:25,530
接下来 我可能会打开一个名为say.py的新文件

2932
02:26:25,530 --> 02:26:26,610
在VS代码中 

2933
02:26:26,610 --> 02:26:32,430
接下来 我要先介绍一下我们自己的朋友 进口牛仔 

2934
02:26:32,430 --> 02:26:37,500
我将在这里导入这个新的库 导入pyttsx3 

2935
02:26:37,500 --> 02:26:39,540
Python文本到语音库 

2936
02:26:39,540 --> 02:26:42,900
现在 根据我事先读过的文件 

2937
02:26:42,900 --> 02:26:45,540
我将在这里为自己创建一个变量 

2938
02:26:45,540 --> 02:26:52,530
引擎等于pyttsx3 init以初始化用于文本到语音的库 

2939
02:26:52,530 --> 02:26:56,160
然后 我将询问用户 我希望听到什么？

2940
02:26:56,160 --> 02:26:57,660
我可能会做这样的事 

2941
02:26:57,660 --> 02:27:00,840
名为this的变量等于INPUT的返回值 

2942
02:27:00,840 --> 02:27:03,000
这将是我简单的问题 

2943
02:27:03,000 --> 02:27:05,310
这一次 我将把它作为一根弦 

2944
02:27:05,310 --> 02:27:06,870
我们已经看到了如何使用牛仔 

2945
02:27:06,870 --> 02:27:09,420
我们可以做牛仔 牛的这个 

2946
02:27:09,420 --> 02:27:12,600
原来这个新的库可以让我使用自己的引擎

2947
02:27:12,600 --> 02:27:14,800
我也是这么说的 

2948
02:27:14,800 --> 02:27:19,020
但是 最终 我将不得不运行引擎 运行和等待 

2949
02:27:19,020 --> 02:27:21,750
以防它是一个很长的短语或句子要说 

2950
02:27:21,750 --> 02:27:22,830
但仅此而已 

2951
02:27:22,830 --> 02:27:27,000
在短短八行代码中 我不仅显然将拥有一头牛

2952
02:27:27,000 --> 02:27:32,010
出现在屏幕上 关闭我们现在 但也一些合成的文本 

2953
02:27:32,010 --> 02:27:35,732
最终 我们希望通过这门课程 您不仅学习了Python 

2954
02:27:35,732 --> 02:27:37,440
你不仅学会了编程 

2955
02:27:37,440 --> 02:27:39,440
但你真的学会了如何解决问题 

2956
02:27:39,440 --> 02:27:42,180
以及最终如何自学新的语言 

2957
02:27:42,180 --> 02:27:45,597
有趣的是 我自己也是几年前才学会的 

2958
02:27:45,597 --> 02:27:48,930
尽管我确实查阅了一些正式的文件和资源

2959
02:27:48,930 --> 02:27:52,530
在网上 我主要学到了我现在知道的甚至是

2960
02:27:52,530 --> 02:27:55,740
我不得不通过问很多问题来再次学习今天的课程 

2961
02:27:55,740 --> 02:27:59,600
无论是谷歌的朋友 还是比我更精通这门语言的朋友们 

2962
02:27:59,600 --> 02:28:02,470
因此 拥有这种本能 拥有这种词汇[INAUDIBLE]

2963
02:28:02,470 --> 02:28:05,550
向其他人提问以搜索问题的答案 

2964
02:28:05,550 --> 02:28:08,790
现在 您完全有了足够的Python基础

2965
02:28:08,790 --> 02:28:11,217
和编程让你自己离开并站立起来 

2966
02:28:11,217 --> 02:28:13,800
所以你当然可以--我们欢迎并鼓励你去

2967
02:28:13,800 --> 02:28:16,830
上并学习其他课程 特别是关于Python和编程的课程 

2968
02:28:16,830 --> 02:28:19,350
但更好的是 越快越好

2969
02:28:19,350 --> 02:28:22,200
去找一些个人感兴趣的项目

2970
02:28:22,200 --> 02:28:24,030
使用Python或其他某种语言 

2971
02:28:24,030 --> 02:28:26,730
因为至少从我自己的经验来看 我往往学得最好

2972
02:28:26,730 --> 02:28:29,880
我希望你也能通过实际应用这些技能来实现 

2973
02:28:29,880 --> 02:28:32,700
不是针对课堂上的问题 而是真的

2974
02:28:32,700 --> 02:28:34,980
真实世界中的问题 

2975
02:28:34,980 --> 02:28:39,180
请允许我在这里查看我的全屏终端窗口 

2976
02:28:39,180 --> 02:28:44,010
运行Say.py的Python 最后一次祈祷

2977
02:28:44,010 --> 02:28:46,860
希望我没有犯任何错误或错误 

2978
02:28:46,860 --> 02:28:47,790
现在我们开始吧 

2979
02:28:47,790 --> 02:28:50,620
Pay.py的巨蟒提示我 这是什么？

2980
02:28:50,620 --> 02:28:52,740
我们就在这里结束吧 

2981
02:28:55,420 --> 02:28:57,480
电脑：这是CS50 