1
00:00:00,000 --> 00:00:03,444
[轻柔的管弦乐演奏]

2
00:00:24,110 --> 00:00:26,840
大卫·马兰：好了 这是CS50的S介绍

3
00:00:26,840 --> 00:00:28,190
到使用Python语言编程 

4
00:00:28,190 --> 00:00:32,009
我的名字是David Malan 这是我们关于函数和变量的一周 

5
00:00:32,009 --> 00:00:35,690
但很有可能的是 你们中的许多人 大多数人 以前从未真正编程过 

6
00:00:35,690 --> 00:00:37,790
因此 让我们从这样做开始吧 

7
00:00:37,790 --> 00:00:40,250
让我在这里继续 打开我的计算机

8
00:00:40,250 --> 00:00:43,220
在它上面 有一个名为Visual Studio Code或VS的程序

9
00:00:43,220 --> 00:00:45,650
代码 这是一个非常流行的程序

10
00:00:45,650 --> 00:00:47,220
用于实际编写代码 

11
00:00:47,220 --> 00:00:49,840
现在 您不必使用此特定工具编写代码 

12
00:00:49,840 --> 00:00:51,590
事实上 我们一天结束时所需要的

13
00:00:51,590 --> 00:00:54,742
是一种所谓的文本编辑器 一种编写文本的程序 

14
00:00:54,742 --> 00:00:57,200
见鬼 如果你真的想 你甚至可以用

15
00:00:57,200 --> 00:00:59,180
比如Google Docs或Microsoft Word 

16
00:00:59,180 --> 00:01:00,952
你必须以正确的格式保存它 

17
00:01:00,952 --> 00:01:04,160
但说到底 你所需要的只是一个写文本的程序

18
00:01:04,160 --> 00:01:06,170
因为这就是代码--文本 

19
00:01:06,170 --> 00:01:08,090
现在 在这个特别的项目中 我将

20
00:01:08,090 --> 00:01:10,550
能够创建一个或多个文件

21
00:01:10,550 --> 00:01:12,500
通过屏幕的这个顶部 

22
00:01:12,500 --> 00:01:14,810
我要做的就是潜入

23
00:01:14,810 --> 00:01:17,030
在我的屏幕底部做这件事 

24
00:01:17,030 --> 00:01:20,060
在我的屏幕底部是一个所谓的终端窗口

25
00:01:20,060 --> 00:01:25,310
这是底层的命令行界面或CLI界面

26
00:01:25,310 --> 00:01:29,340
电脑 无论是你的Mac还是你的PC 甚至是云中的某个服务器 

27
00:01:29,340 --> 00:01:32,240
我在这里要做的就是直接写“代码” 然后

28
00:01:32,240 --> 00:01:36,530
我要编码的文件的名称 例如 Hello.py 

29
00:01:36,530 --> 00:01:40,310
我们很快就会看到 您用Python编写的任何程序通常都有一个文件

30
00:01:40,310 --> 00:01:44,210
以.py结尾的名称 向计算机表明它确实是一个程序

31
00:01:44,210 --> 00:01:45,320
用Python语言编写的 

32
00:01:45,320 --> 00:01:48,440
现在你会看到在我屏幕的顶部 我有一个闪烁的光标 

33
00:01:48,440 --> 00:01:51,800
第一行--这是我的代码的第一行--

34
00:01:51,800 --> 00:01:55,730
然后是一个选项卡 它让我想起这个文件的名称Hello.py 

35
00:01:55,730 --> 00:01:58,370
虽然我对Python了解不多 

36
00:01:58,370 --> 00:02:00,770
我的第一个程序如下

37
00:02:00,770 --> 00:02:02,120
print（“hello world”） 

38
00:02:08,396 --> 00:02:10,729
你会看到 在我的键盘上 我的一些想法

39
00:02:10,729 --> 00:02:11,604
对我来说已经结束了 

40
00:02:11,604 --> 00:02:14,870
我只需要输入一个括号 另一个就会自动出现 

41
00:02:14,870 --> 00:02:18,590
这就是我们在这里看到的工具的特点 

42
00:02:18,590 --> 00:02:21,080
即使你以前从未编程过 

43
00:02:21,080 --> 00:02:25,610
你可以猜测 推断出这个简单的程序要做什么 

44
00:02:25,610 --> 00:02:28,250
只有一句台词 print（“hello world”） 

45
00:02:32,030 --> 00:02:33,830
实际上 当我最终运行这个程序时 

46
00:02:33,830 --> 00:02:35,948
它只会说 你好 世界 

47
00:02:35,948 --> 00:02:37,490
事实上 这是一个非常著名的--

48
00:02:37,490 --> 00:02:39,440
也许是最规范的程序 

49
00:02:39,440 --> 00:02:42,530
可以用Python或任何其他语言编写你的第一个程序 

50
00:02:42,530 --> 00:02:44,280
这就是我在这里所做的

51
00:02:44,280 --> 00:02:48,230
但在我的Mac电脑 我的PC 甚至我的手机上 我通常习惯 

52
00:02:48,230 --> 00:02:51,170
就像你一样 双击图标就能运行程序

53
00:02:51,170 --> 00:02:52,760
或者只是点击屏幕 

54
00:02:52,760 --> 00:02:54,920
但我在这里没有看到这样的图标 

55
00:02:54,920 --> 00:02:58,730
事实上 这是因为我现在的Mac电脑的界面

56
00:02:58,730 --> 00:03:02,180
或PC或云中的某个服务器 也只是一个CLI--

57
00:03:02,180 --> 00:03:04,340
命令行接口--尽管它

58
00:03:04,340 --> 00:03:07,820
我可能会觉得这是从菜单、按钮和图标中后退一步

59
00:03:07,820 --> 00:03:10,730
你和我每天都认为是理所当然的 你会发现 我们认为 

60
00:03:10,730 --> 00:03:13,670
它最终会是一个更强大的界面 

61
00:03:13,670 --> 00:03:16,920
在现实世界中的程序员中很流行 

62
00:03:16,920 --> 00:03:20,245
所以要运行这个程序 我必须使用一个命令

63
00:03:20,245 --> 00:03:23,120
我将把光标移回屏幕底部

64
00:03:23,120 --> 00:03:25,790
这里我之前已经运行了一个命令--

65
00:03:25,790 --> 00:03:30,410
在我的计算机中具有打开VS Code效果的命令Code 

66
00:03:30,410 --> 00:03:33,560
然后我传入了我想编码的文件名 

67
00:03:33,560 --> 00:03:36,000
现在我有机会输入第二个命令 

68
00:03:36,000 --> 00:03:38,090
你会看到第二个美元符号 

69
00:03:38,090 --> 00:03:41,360
这里的美元符号并不表示任何一种货币或货币 

70
00:03:41,360 --> 00:03:43,340
这只是一个普遍使用的符号

71
00:03:43,340 --> 00:03:46,610
以指示您的提示符--命令行界面需要的位置

72
00:03:46,610 --> 00:03:47,990
你需要把这些命令 

73
00:03:47,990 --> 00:03:51,530
现在我可以在这里运行的命令是这样的--

74
00:03:51,530 --> 00:03:55,310
我将运行Hello.py的Python 

75
00:03:55,310 --> 00:03:56,490
这是为什么呢？

76
00:03:56,490 --> 00:04:00,380
事实证明 当我用像Python语言这样的语言编写代码时 

77
00:04:00,380 --> 00:04:02,120
它当然存储在那个文件中--

78
00:04:02,120 --> 00:04:07,063
您好 但是我需要从上到下解释代码 

79
00:04:07,063 --> 00:04:09,230
从左到右 这样计算机就知道该怎么做了 

80
00:04:09,230 --> 00:04:10,940
事实上 在一天结束的时候 即使你不是真的

81
00:04:10,940 --> 00:04:12,920
对计算机了解很多 你可能已经

82
00:04:12,920 --> 00:04:16,790
听说计算机只懂0和1 也就是所谓的二进制

83
00:04:16,790 --> 00:04:17,390
系统 

84
00:04:17,390 --> 00:04:21,769
如果是这样的话 写着“打印”和圆括号的东西

85
00:04:21,769 --> 00:04:25,430
引用引述的Hello world 不一定是0和1 

86
00:04:25,430 --> 00:04:27,750
我们必须以某种方式将其转化为0和1

87
00:04:27,750 --> 00:04:29,000
计算机能理解的信息 

88
00:04:29,000 --> 00:04:33,360
现在幸运的是 只要你提前安装了这样的程序 

89
00:04:33,360 --> 00:04:36,380
有一个程序和一种叫做Python的语言 

90
00:04:36,380 --> 00:04:39,390
因此 Python不仅是我们要用来编写代码的语言 

91
00:04:39,390 --> 00:04:42,590
它也是一个程序 也就是众所周知的解释器

92
00:04:42,590 --> 00:04:46,490
您可以在自己的Mac或PC或云中的某个服务器上免费安装

93
00:04:46,490 --> 00:04:50,990
然后您可以运行该程序、该解释器 并将其作为输入传递给它

94
00:04:50,990 --> 00:04:53,870
您的文件的名称与我的类似 Hello.py 

95
00:04:53,870 --> 00:04:56,000
然后那个程序 那个解释器 就会

96
00:04:56,000 --> 00:04:59,210
掌握从上到下、从左到右阅读它的过程

97
00:04:59,210 --> 00:05:02,210
并有效地将其转换为那些0和1

98
00:05:02,210 --> 00:05:04,170
计算机可以理解的 

99
00:05:04,170 --> 00:05:05,360
所以我们就这么做吧 

100
00:05:05,360 --> 00:05:07,190
让我回到这里的VS代码 

101
00:05:07,190 --> 00:05:11,030
我已经输入了Hello.py的Python 但没有按回车键 

102
00:05:11,030 --> 00:05:13,430
这就是现在要开始的命令

103
00:05:13,430 --> 00:05:16,190
希望 如果我没有搞砸这一切 

104
00:05:16,190 --> 00:05:20,370
I should see my very first program's output to the screen.

105
00:05:20,370 --> 00:05:23,480
And voila, hello, world.

106
00:05:23,480 --> 00:05:25,970
So if you too have typed exactly that same code

107
00:05:25,970 --> 00:05:28,400
and have executed exactly that same command,

108
00:05:28,400 --> 00:05:32,840
you will have written your very first program in this case in Python.

109
00:05:32,840 --> 00:05:34,790
Well now let's take a step back and consider,

110
00:05:34,790 --> 00:05:37,190
what is it that we actually just did and what

111
00:05:37,190 --> 00:05:38,930
is it we're looking here on the screen?

112
00:05:38,930 --> 00:05:41,450
Well first and foremost, in most any programming language,

113
00:05:41,450 --> 00:05:43,950
you tend to have access to what are called functions.

114
00:05:43,950 --> 00:05:46,460
A function is like an action or a verb that

115
00:05:46,460 --> 00:05:48,800
lets you do something in the program.

116
00:05:48,800 --> 00:05:52,730
And generally speaking, any language comes with some predetermined set

117
00:05:52,730 --> 00:05:57,097
of functions-- some very basic actions or verbs that the computer will already

118
00:05:57,097 --> 00:05:59,180
know how to do for you, that the language, really,

119
00:05:59,180 --> 00:06:00,530
will know how to do for you.

120
00:06:00,530 --> 00:06:04,640
And you, the programmer, the human, can use those functions at will

121
00:06:04,640 --> 00:06:07,020
to get the computer to do those things.

122
00:06:07,020 --> 00:06:11,835
Now the program in question here, Hello.py is using one function.

123
00:06:11,835 --> 00:06:13,460
And you could perhaps guess what it is.

124
00:06:13,460 --> 00:06:16,760
That function is, of course, going to be this function print

125
00:06:16,760 --> 00:06:19,430
and that print function, of course, doesn't

126
00:06:19,430 --> 00:06:22,340
print some preordained string of text.

127
00:06:22,340 --> 00:06:26,240
That is to say, it prints whatever it is you want it to print.

128
00:06:26,240 --> 00:06:29,600
And here too, do we have another piece of terminology in the world

129
00:06:29,600 --> 00:06:31,430
of programming, namely arguments.

130
00:06:31,430 --> 00:06:36,830
An argument is an input to a function that somehow influences its behavior.

131
00:06:36,830 --> 00:06:38,660
The people who invented Python, of course,

132
00:06:38,660 --> 00:06:40,790
didn't necessarily know what it is you and I

133
00:06:40,790 --> 00:06:43,850
are going to want to print to the screen, so they designed this print

134
00:06:43,850 --> 00:06:46,580
function using these parentheses with the ability

135
00:06:46,580 --> 00:06:49,340
to take as input some string of text, be it

136
00:06:49,340 --> 00:06:52,250
in English or any other human language, that is

137
00:06:52,250 --> 00:06:56,540
what you want this function ultimately to print onto the screen.

138
00:06:56,540 --> 00:06:59,640
那么这个节目最终会在屏幕上做什么呢？

139
00:06:59,640 --> 00:07:01,070
嗯 当然是印刷品 

140
00:07:01,070 --> 00:07:03,230
它在屏幕上向我们展示了你好 世界 

141
00:07:03,230 --> 00:07:05,743
这在编程中通常被称为副作用 

142
00:07:05,743 --> 00:07:07,160
它可以是可视的 也可以是音频的 

143
00:07:07,160 --> 00:07:09,470
在这种情况下 它是出现在屏幕上的东西

144
00:07:09,470 --> 00:07:12,690
因此 功能确实会产生这些副作用 

145
00:07:12,690 --> 00:07:15,650
作为这个动词或动作 他们可以做的一件事是

146
00:07:15,650 --> 00:07:19,100
作为一个副作用显示在屏幕上 就像那些话

147
00:07:19,100 --> 00:07:20,240
我们想要的--

148
00:07:20,240 --> 00:07:21,870
你好 世界 

149
00:07:21,870 --> 00:07:25,080
这是我的第一个项目 你知道 我感觉很好 

150
00:07:25,080 --> 00:07:26,570
一切都按计划进行 

151
00:07:26,570 --> 00:07:28,490
我没有犯任何错误 但是 说实话 

152
00:07:28,490 --> 00:07:30,560
当你在学习如何编程 甚至

153
00:07:30,560 --> 00:07:34,250
几年后 一旦你学会了如何编程 你就会犯错 

154
00:07:34,250 --> 00:07:36,615
当然 这些错误是指

155
00:07:36,615 --> 00:07:38,990
一个你可能已经知道的术语 那就是臭虫 

156
00:07:38,990 --> 00:07:42,230
Bug是程序中的错误 它们可以采取多种形式 

157
00:07:42,230 --> 00:07:46,460
或许 让人欣慰的是 在接下来的几周里 

158
00:07:46,460 --> 00:07:48,450
你会犯很多错误的 

159
00:07:48,450 --> 00:07:51,320
你的代码中会有很多错误 就像我一样

160
00:07:51,320 --> 00:07:53,490
就像我现在还在做的那样 

161
00:07:53,490 --> 00:07:55,610
而这些错误本身就是错误

162
00:07:55,610 --> 00:07:57,230
这些都是你要解决的问题 

163
00:07:57,230 --> 00:07:59,540
在接下来的几周里 我们将为您提供

164
00:07:59,540 --> 00:08:03,760
许多工具 包括智力和技术 你可以通过这些工具来解决这些问题 

165
00:08:03,760 --> 00:08:07,010
但在第一次编写程序时 请不要气馁

166
00:08:07,010 --> 00:08:11,630
它甚至不是第一次起作用 随着时间的推移 通过练习 它会起作用的 

167
00:08:11,630 --> 00:08:12,810
而且有经验 

168
00:08:12,810 --> 00:08:15,200
所以现在让我故意犯一个错误

169
00:08:15,200 --> 00:08:18,710
有一个非零的机会 我可能已经意外地做了 

170
00:08:18,710 --> 00:08:19,760
但我很幸运 

171
00:08:19,760 --> 00:08:22,280
让我继续说下去 假设我忘了

172
00:08:22,280 --> 00:08:24,950
包括诸如右括号之类的内容

173
00:08:24,950 --> 00:08:26,570
在此行代码的末尾 

174
00:08:26,570 --> 00:08:30,451
代码几乎是正确的 大概有99%是正确的 

175
00:08:30,451 --> 00:08:32,659
但现在我已经指出了这一点 很明显

176
00:08:32,659 --> 00:08:34,820
它漏掉了那个右括号 

177
00:08:34,820 --> 00:08:39,530
但即使是那些看似微不足道的小细节 你和我作为人类

178
00:08:39,530 --> 00:08:40,740
不会真的在乎 

179
00:08:40,740 --> 00:08:44,300
如果你正在发送一封电子邮件或一条短信 不管是什么 那只是一个打字错误 

180
00:08:44,300 --> 00:08:45,605
这没什么大不了的 

181
00:08:45,605 --> 00:08:47,480
这对计算机来说将是一件大事 

182
00:08:47,480 --> 00:08:49,230
一台计算机将会把你从字面上理解 

183
00:08:49,230 --> 00:08:53,210
如果你没有以语言所期望的方式结束你的思想 

184
00:08:53,210 --> 00:08:55,380
它根本不一定会运行 

185
00:08:55,380 --> 00:08:56,112
那就让我们开始吧 

186
00:08:56,112 --> 00:08:58,820
我将在这里继续 并清除底部的屏幕

187
00:08:58,820 --> 00:09:01,340
这样我就可以重新开始了 我要继续前行

188
00:09:01,340 --> 00:09:05,420
我的程序的这个版本在进行了更改后删除了

189
00:09:05,420 --> 00:09:06,410
插入语 

190
00:09:06,410 --> 00:09:10,490
我将继续在Hello.py中再次输入Python 这一次

191
00:09:10,490 --> 00:09:13,040
当我按回车键时 我希望我能看到你好 世界 

192
00:09:13,040 --> 00:09:16,850
但这里我们在屏幕上有一个错误 即所谓的语法

193
00:09:16,850 --> 00:09:21,140
错误 指的是我在键盘上犯了一个错误 

194
00:09:21,140 --> 00:09:24,030
幸运的是 这一点非常简单 

195
00:09:24,030 --> 00:09:28,410
它确实说过这个左括号从来没有结束过 

196
00:09:28,410 --> 00:09:30,945
因此 这可能是相当直观的 

197
00:09:30,945 --> 00:09:33,320
现在我需要做的是 当然 我需要关闭它 

198
00:09:33,320 --> 00:09:36,530
不幸的是 有时我们会在接下来的几周里看到错误消息

199
00:09:36,530 --> 00:09:38,840
将不会是那么用户友好的 

200
00:09:38,840 --> 00:09:41,720
但是 再一次 有经验 有实践 你会吗？

201
00:09:41,720 --> 00:09:44,360
在调试这类程序方面做得更好 

202
00:09:44,360 --> 00:09:46,650
现在让我确保我确实正确地修复了它 

203
00:09:46,650 --> 00:09:50,420
现在让我继续运行Hello.py并按Enter键 瞧 

204
00:09:50,420 --> 00:09:51,890
我们又开始做生意了 

205
00:09:51,890 --> 00:09:55,430
好吧 让我在这里暂停一下 看看我们现在是否有什么问题

206
00:09:55,430 --> 00:10:02,480
关于Python本身、编写或运行这些最简单的程序 

207
00:10:02,480 --> 00:10:06,890
观众：我可以在Word或Microsoft Excel中编写代码吗？

208
00:10:06,890 --> 00:10:09,473
要做到这一点 障碍是什么？

209
00:10:09,473 --> 00:10:11,390
大卫·马兰：一个非常好的问题 请允许

210
00:10:11,390 --> 00:10:14,630
我要非常明确地对整个互联网说

211
00:10:14,630 --> 00:10:17,810
不应使用Microsoft Word编写代码 

212
00:10:17,810 --> 00:10:20,480
我提到这一点只是因为它是一种工具 通过它

213
00:10:20,480 --> 00:10:23,283
你可以写文本 而代码最终只是文本 

214
00:10:23,283 --> 00:10:24,950
但它不是适合这项工作的工具 

215
00:10:24,950 --> 00:10:27,890
我们不需要粗体、下划线、段落之类的东西 

216
00:10:27,890 --> 00:10:31,580
我们通常想要比Microsoft Word或Google Docs简单得多的东西 

217
00:10:31,580 --> 00:10:36,110
因此 VS Code只是一个更通用的文本编辑器的例子 

218
00:10:36,110 --> 00:10:39,110
它在生活中的目的是让你这个人类编辑文本 

219
00:10:39,110 --> 00:10:42,050
如今 这些文本编辑器提供了更多的功能 

220
00:10:42,050 --> 00:10:44,600
事实上 您会注意到 即使在我这里的代码中 

221
00:10:44,600 --> 00:10:47,570
虽然只有一行字 但还是有一点色彩的 

222
00:10:47,570 --> 00:10:49,910
对我来说 “打印”这个词是用蓝色显示的 

223
00:10:49,910 --> 00:10:51,050
括号是黑色的 

224
00:10:51,050 --> 00:10:54,290
我们将看到 随着我们编写更多的代码行 越来越多的行

225
00:10:54,290 --> 00:10:56,630
将以不同的颜色呈现出来 

226
00:10:56,630 --> 00:10:58,993
这只是文本编辑器的一个功能 

227
00:10:58,993 --> 00:11:01,910
我们还将看到它具有像这个内置的终端窗口这样的功能 

228
00:11:01,910 --> 00:11:05,120
它将有一个内置的工具来调试或发现问题

229
00:11:05,120 --> 00:11:05,780
带着密码 

230
00:11:05,780 --> 00:11:07,760
而且它现在是一个非常流行的工具 

231
00:11:07,760 --> 00:11:09,560
但还有很多其他人在那里 

232
00:11:09,560 --> 00:11:11,900
欢迎您在本课程及以后的课程中使用它们 

233
00:11:11,900 --> 00:11:14,120
我们碰巧在很大程度上用到了这个

234
00:11:14,120 --> 00:11:18,980
这也是因为你现在也可以在云中免费使用VS Code 

235
00:11:18,980 --> 00:11:22,190
下面是关于使用Python编程的另一个问题

236
00:11:22,190 --> 00:11:24,950
或者 你好 更广泛地说 是世界还是语法？

237
00:11:24,950 --> 00:11:28,850
观众：是啊 我是想问是不是

238
00:11:28,850 --> 00:11:31,923
可以使用终端窗口运行计算机吗？

239
00:11:31,923 --> 00:11:33,590
大卫·马兰：我想我听到了 是不是--

240
00:11:33,590 --> 00:11:37,530
是否可以在没有终端窗口的情况下运行该程序？

241
00:11:37,530 --> 00:11:38,030
你是不是

242
00:11:38,030 --> 00:11:38,540
观众：是的 先生 

243
00:11:38,540 --> 00:11:39,870
大卫·马兰：好吧 你又为我僵住了 

244
00:11:39,870 --> 00:11:41,730
但让我来推断一下问题是什么 

245
00:11:41,730 --> 00:11:44,660
所以在这个环境中 当我配置我的计算机时 

246
00:11:44,660 --> 00:11:48,320
我只能通过终端窗口运行这些Python程序 

247
00:11:48,320 --> 00:11:51,140
这对我 程序员 或者

248
00:11:51,140 --> 00:11:53,390
我想学习编程 但并不是很好

249
00:11:53,390 --> 00:11:57,050
如果你想发布这个软件并让其他人使用你的实际代码 

250
00:11:57,050 --> 00:12:01,550
你完全可以编写程序 然后让其他人使用 

251
00:12:01,550 --> 00:12:05,300
不是命令行界面 而是图形用户界面或GUI--

252
00:12:05,300 --> 00:12:08,390
GU I这只是一种机制 我认为 

253
00:12:08,390 --> 00:12:10,700
最好的开始写代码的方法

254
00:12:10,700 --> 00:12:14,045
因为最终它会给我们更多的控制权 

255
00:12:14,045 --> 00:12:15,920
请允许我在这里继续前进 但请感受到

256
00:12:15,920 --> 00:12:19,820
自由地继续提问 如果只是通过聊天的方式 

257
00:12:19,820 --> 00:12:23,690
现在让我们考虑一下如何改进这个程序 

258
00:12:23,690 --> 00:12:27,530
让我们来改进这个程序 使它更具互动性

259
00:12:27,530 --> 00:12:30,740
而不是假设每个人都想被欢迎

260
00:12:30,740 --> 00:12:32,120
更通用的名称是hello world 

261
00:12:32,120 --> 00:12:35,120
让我们看看我能不能让这个程序说一些像你好 大卫

262
00:12:35,120 --> 00:12:40,280
或者你好 耶利米或者你好 霍雷肖或者其他用户的名字 

263
00:12:40,280 --> 00:12:43,670
为了做到这一点 我将回到你好 pi

264
00:12:43,670 --> 00:12:46,950
我会在最上面再加一行代码

265
00:12:46,950 --> 00:12:52,490
比如 你叫什么名字 在末尾多加一个空格 

266
00:12:52,490 --> 00:12:55,530
所以我打印给用户一个问题 

267
00:12:55,530 --> 00:12:58,940
但现在我需要另一个函数来获取用户的输入 

268
00:12:58,940 --> 00:13:02,550
而且 完美的是 足够的Python带有一个名为input的函数 

269
00:13:02,550 --> 00:13:06,470
所以这里我要继续调用一个函数input open paren 

270
00:13:06,470 --> 00:13:07,400
近亲 

271
00:13:07,400 --> 00:13:11,000
这将提示用户 只是一个闪烁的光标等待

272
00:13:11,000 --> 00:13:12,440
让他们输入一些东西

273
00:13:12,440 --> 00:13:15,860
如果我读了输入函数的文档 

274
00:13:15,860 --> 00:13:18,210
它本身也需要一个参数 

275
00:13:18,210 --> 00:13:21,740
我不需要单独使用“print” 然后提示用户输入 

276
00:13:21,740 --> 00:13:25,100
所以我可以在我们使用它之前简化这个代码 

277
00:13:25,100 --> 00:13:28,430
我要继续从print中取出相同的字符串 

278
00:13:28,430 --> 00:13:30,800
把它作为输入函数的参数 

279
00:13:30,800 --> 00:13:32,383
彻底摆脱“印刷” 

280
00:13:32,383 --> 00:13:34,967
而且 事实上 这个“打印”无论如何都会添加一个新的行 

281
00:13:34,967 --> 00:13:37,340
现在我得到了一个提示 用户的光标在哪里

282
00:13:37,340 --> 00:13:41,030
最后会在队伍的最后眨眨眼问他们 你叫什么名字？

283
00:13:41,030 --> 00:13:46,580
在我的终端窗口中 我将运行Hello.py的Python 回车 

284
00:13:46,580 --> 00:13:47,150
好的.

285
00:13:47,150 --> 00:13:48,150
我们有进展了

286
00:13:48,150 --> 00:13:51,280
看来这个新的功能输入确实在促使我这个人类 

287
00:13:51,280 --> 00:13:51,780
for input输入.

288
00:13:51,780 --> 00:13:53,155
所以我要输入我的名字

289
00:13:53,155 --> 00:13:54,290
大卫--按回车键 

290
00:13:54,290 --> 00:13:57,440
不幸的是 这和我的名字没什么关系

291
00:13:57,440 --> 00:13:59,240
它会立即输出 

292
00:13:59,240 --> 00:14:01,160
好吧 好吧 我可以解决的 对吧？

293
00:14:01,160 --> 00:14:05,480
我可以在第二行把“world”改成“David”

294
00:14:05,480 --> 00:14:10,310
然后回到我的终端窗口 我可以在Hello.py上输入Python 回车 

295
00:14:10,310 --> 00:14:11,150
你叫什麽名字？

296
00:14:11,150 --> 00:14:12,410
大卫 进来 

297
00:14:12,410 --> 00:14:13,105
好了

298
00:14:13,105 --> 00:14:14,480
好了 现在我开始行动了 

299
00:14:14,480 --> 00:14:17,520
现在我的程序正在按预期工作 

300
00:14:17,520 --> 00:14:21,410
当然 这并不是真正的工作 因为预期在这里 

301
00:14:21,410 --> 00:14:25,070
让我继续假装是我的同事卡特 

302
00:14:25,070 --> 00:14:26,760
卡特的名字是这个 

303
00:14:26,760 --> 00:14:29,927
我会按回车键 然后我会看到 你好 卡特--

304
00:14:29,927 --> 00:14:32,520
显然不是 因为我硬编码了 可以这么说 

305
00:14:32,520 --> 00:14:35,010
我已经把我的名字写在字符串里了 

306
00:14:35,010 --> 00:14:40,040
所以我们现在需要一些方法来获取用户的输入

307
00:14:40,040 --> 00:14:41,780
并最终用它做些什么 

308
00:14:41,780 --> 00:14:44,930
为此 我们将利用编程的另一个特性 

309
00:14:44,930 --> 00:14:47,510
特别是某些功能的一个特征 即它们

310
00:14:47,510 --> 00:14:49,850
也可以有返回值 

311
00:14:49,850 --> 00:14:52,700
如果你再一次把输入看作是这个动作 

312
00:14:52,700 --> 00:14:55,880
这个动词--你实际上可以把它拟人化成一个人 

313
00:14:55,880 --> 00:14:58,130
就像你的一个朋友 你问了一个问题

314
00:14:58,130 --> 00:15:00,797
你让你的朋友去征求别人的意见--

315
00:15:00,797 --> 00:15:02,210
去问问那个人他们的名字 

316
00:15:02,210 --> 00:15:05,630
如果你的朋友回来时知道了那个人的名字 

317
00:15:05,630 --> 00:15:08,357
如果他们把那个名字还给你不是很好吗？

318
00:15:08,357 --> 00:15:10,940
比喻地说 这就是我们需要的功能 

319
00:15:10,940 --> 00:15:15,200
就是获得用户的输入 然后把它交回给我 这样我 作为程序员 

320
00:15:15,200 --> 00:15:16,610
可以用它做点什么 

321
00:15:16,610 --> 00:15:19,280
但如果要还给我的话 

322
00:15:19,280 --> 00:15:23,060
我有点想把它放在某个地方 这样我就可以把它打印回来了

323
00:15:23,060 --> 00:15:23,720
在屏幕上 

324
00:15:23,720 --> 00:15:26,970
我需要做的相当于拿出一张纸或便利贴 

325
00:15:26,970 --> 00:15:31,040
在这张纸上写下人类说过的话 

326
00:15:31,040 --> 00:15:34,650
这样我就可以将其作为输入输入到打印功能中 

327
00:15:34,650 --> 00:15:38,120
要做到这一点 我们将需要编程的另一个功能 即

328
00:15:38,120 --> 00:15:38,960
变量 

329
00:15:38,960 --> 00:15:42,410
可能性是 大多数人都熟悉数学课上的变量

330
00:15:42,410 --> 00:15:45,380
很久以前--x y z等等 

331
00:15:45,380 --> 00:15:48,110
嗯 编程也有同样的能力 这种能力

332
00:15:48,110 --> 00:15:51,560
要创建一个变量--在这个例子中 是在计算机的内存中--

333
00:15:51,560 --> 00:15:53,100
不仅仅是在一张纸上 

334
00:15:53,100 --> 00:15:55,620
该变量可以存储一个值--

335
00:15:55,620 --> 00:15:58,910
一个数字 一些文本 甚至一个图像或视频或更多 

336
00:15:58,910 --> 00:16:06,740
变量只是计算机内部某个值的容器

337
00:16:06,740 --> 00:16:08,300
或者在你自己的程序中 

338
00:16:08,300 --> 00:16:11,303
那么 我该如何用这种方式来表达自己呢？

339
00:16:11,303 --> 00:16:13,220
我想我要做的是介绍

340
00:16:13,220 --> 00:16:16,730
一个名称比x或y更有趣的变量 

341
00:16:16,730 --> 00:16:19,970
我可以这么说--x=输入 

342
00:16:19,970 --> 00:16:23,780
但我将在这里使用一个比典型数学变量更好的名称

343
00:16:23,780 --> 00:16:26,240
我要把我的变量按字面意思命名为“名称” 为什么？

344
00:16:26,240 --> 00:16:29,073
在编程方面 因为我面前有一个完整的键盘 

345
00:16:29,073 --> 00:16:32,150
我可以用更具描述性的术语来描述我正在写的东西 

346
00:16:32,150 --> 00:16:36,590
然而 现在有机会考虑一段特定的语法 

347
00:16:36,590 --> 00:16:39,470
我们看到了圆括号 我们看到了引号 所有这些

348
00:16:39,470 --> 00:16:42,020
在将输入传递给函数时是必需的 

349
00:16:42,020 --> 00:16:47,810
但是这个等号在右边的输入和名字之间

350
00:16:47,810 --> 00:16:49,820
左翼实际上很重要 

351
00:16:49,820 --> 00:16:52,490
从技术上讲 它本身并不是等号 

352
00:16:52,490 --> 00:16:56,060
与其说它意味着平等 不如说它意味着分配 

353
00:16:56,060 --> 00:16:59,000
因此 在Python和许多编程语言中 

354
00:16:59,000 --> 00:17:01,610
单个等号是赋值运算符

355
00:17:01,610 --> 00:17:03,860
具体来说 这意味着 你

356
00:17:03,860 --> 00:17:08,839
我想从右到左分配用户输入的任何内容 

357
00:17:08,839 --> 00:17:14,540
所以等号从右到左复制 不管返回

358
00:17:14,540 --> 00:17:17,420
右侧函数的值为 

359
00:17:17,420 --> 00:17:20,670
因此 输入函数显然是从用户那里获得输入的 

360
00:17:20,670 --> 00:17:24,140
这就是为什么我能够输入我的名字或卡特的名字 但它也

361
00:17:24,140 --> 00:17:29,390
有点像是在幕后把那个值 那个返回值 交给我

362
00:17:29,390 --> 00:17:30,230
程序员 

363
00:17:30,230 --> 00:17:33,680
如果我使用等号和变量 不管我怎么称呼它 

364
00:17:33,680 --> 00:17:38,460
我可以将该输入存储在该变量中 以便以后重复使用 

365
00:17:38,460 --> 00:17:40,670
所以现在 坐在计算机内存中的某个地方 

366
00:17:40,670 --> 00:17:44,870
是包含“David”引号、非引号或“Carter”引号的容器 

367
00:17:44,870 --> 00:17:47,490
不引用 或人类输入的任何内容 

368
00:17:47,490 --> 00:17:49,280
但在这里 很容易犯错误 

369
00:17:49,280 --> 00:17:53,850
假设我决定打印这个名字 所以

370
00:17:53,850 --> 00:17:57,800
我有种预感 你好 名字 

371
00:17:57,800 --> 00:18:00,440
只是输入变量的名称 

372
00:18:00,440 --> 00:18:05,300
现在让我继续运行Hello.py的Python 然后按Enter键 

373
00:18:05,300 --> 00:18:07,040
这会提示我输入我的名字 

374
00:18:07,040 --> 00:18:08,207
让我输入我的名字--

375
00:18:08,207 --> 00:18:10,440
D-A-V-I-D 但我还没有按回车键 

376
00:18:10,440 --> 00:18:15,350
也许通过聊天 当我现在按Enter键时 这里会发生什么？

377
00:18:15,350 --> 00:18:17,840
我希望它能说 你好 大卫 

378
00:18:17,840 --> 00:18:22,580
如果它说Hello world 我会很好 但我不想让它说它实际上是什么

379
00:18:22,580 --> 00:18:25,370
我们在聊天中看到的是 

380
00:18:25,370 --> 00:18:28,640
它可能会直接说你好 名字.

381
00:18:28,640 --> 00:18:30,030
所以这并不完全正确 

382
00:18:30,030 --> 00:18:34,250
所以我们需要另一种方法来打印变量的值

383
00:18:34,250 --> 00:18:36,785
而不仅仅是“名字”这个词“

384
00:18:36,785 --> 00:18:38,910
让我用几种不同的方式来尝试一下 

385
00:18:38,910 --> 00:18:40,890
让我试着这样做

386
00:18:40,890 --> 00:18:44,390
让我继续 也许撤销这一点 因为我已经得到了相当不错的

387
00:18:44,390 --> 00:18:45,550
打招呼 

388
00:18:45,550 --> 00:18:48,050
所以我们划清界限 好吧 

389
00:18:48,050 --> 00:18:50,360
我们至少把你好逗号赶出家门吧 

390
00:18:50,360 --> 00:18:53,790
现在让我们打印姓名 凭直觉 我将尝试这样做 

391
00:18:53,790 --> 00:18:55,115
我将再次使用打印--

392
00:18:55,115 --> 00:18:57,740
因为你可以根据需要多次使用这些函数

393
00:18:57,740 --> 00:19:02,660
我将把名为name的变量传递给print函数 

394
00:19:02,660 --> 00:19:04,730
但请注意我现在有点聪明了 

395
00:19:04,730 --> 00:19:07,970
我没有把它放在双引号里 因为我们已经看到了双引号

396
00:19:07,970 --> 00:19:10,610
引号的意思是打印出来

397
00:19:10,610 --> 00:19:13,700
我这次去掉引号是希望 

398
00:19:13,700 --> 00:19:19,440
现在通过将变量name传递给函数print 

399
00:19:19,440 --> 00:19:23,480
实际上 打印变量的内容 

400
00:19:23,480 --> 00:19:24,808
所谓的价值 

401
00:19:24,808 --> 00:19:26,600
好吧 我们就在这里开始吧 

402
00:19:26,600 --> 00:19:29,030
Hello.py的Python 输入 

403
00:19:29,030 --> 00:19:30,020
你叫什麽名字？

404
00:19:30,020 --> 00:19:30,590
大卫

405
00:19:30,590 --> 00:19:35,520
现在 我仍然交叉手指 我看到你好逗号大卫 

406
00:19:35,520 --> 00:19:36,020
好吧

407
00:19:36,020 --> 00:19:38,090
所以这不是最好的方案 

408
00:19:38,090 --> 00:19:40,670
可以说 我是在偷工减料 

409
00:19:40,670 --> 00:19:44,128
我在两条线上说你好 大卫 

410
00:19:44,128 --> 00:19:45,920
所以它不那么优雅 不那么漂亮 

411
00:19:45,920 --> 00:19:48,950
在英语中 它不像直接说出来那样符合语法

412
00:19:48,950 --> 00:19:52,820
所有在一个呼吸在一行 但至少我已经解决了这个问题 只是没有

413
00:19:52,820 --> 00:19:54,020
还很好 

414
00:19:54,020 --> 00:19:56,390
但现在让我退一步 

415
00:19:56,390 --> 00:19:59,070
我们应该熟悉的其他几个概念 

416
00:19:59,070 --> 00:20:03,260
这是因为我们的程序变得更长 它们不再只有一两行

417
00:20:03,260 --> 00:20:07,370
甚至三个 我们的节目最终会变成几十行 

418
00:20:07,370 --> 00:20:09,020
甚至可能有数百行之长 

419
00:20:09,020 --> 00:20:11,990
让我们为未来的成功铺平道路 

420
00:20:11,990 --> 00:20:14,840
事实证明 Python和许多编程语言

421
00:20:14,840 --> 00:20:17,120
也支持一种叫做评论的东西 

422
00:20:17,120 --> 00:20:21,200
注释是代码中对您自己的注释

423
00:20:21,200 --> 00:20:24,260
并且您可以通过特殊符号--在Python中--来包含注释

424
00:20:24,260 --> 00:20:26,150
它将是散列符号 通常是--

425
00:20:26,150 --> 00:20:27,980
这样你就可以写出等价的

426
00:20:27,980 --> 00:20:30,950
一张纸条给你自己 但不会破坏你的代码 

427
00:20:30,950 --> 00:20:33,380
电脑实际上会忽略你的评论 

428
00:20:33,380 --> 00:20:36,030
它就在你的身边 就在你的老师身边 

429
00:20:36,030 --> 00:20:38,030
它就在那里 只等着你的同事

430
00:20:38,030 --> 00:20:40,020
你最终是在分享这段代码 

431
00:20:40,020 --> 00:20:42,320
所以如果我回到这里的VS代码 我只是

432
00:20:42,320 --> 00:20:46,040
我想给这个节目添加一些评论 向我的老师解释一下 

433
00:20:46,040 --> 00:20:49,325
对我自己 对我的同事们 这个项目正在做的事情 

434
00:20:49,325 --> 00:20:50,700
好吧 那我们就这么做吧 

435
00:20:50,700 --> 00:20:54,020
我将在我的程序的最顶端 在第一行

436
00:20:54,020 --> 00:20:56,990
现在 我将把原来的代码行向下移动一点 

437
00:20:56,990 --> 00:21:00,530
我将添加一个散列 我将这样说 

438
00:21:00,530 --> 00:21:03,210
要求用户输入他们的姓名 

439
00:21:03,210 --> 00:21:05,040
现在 我不需要用那种语言 

440
00:21:05,040 --> 00:21:06,950
我不需要用那条短信 

441
00:21:06,950 --> 00:21:08,910
我可以使用任何人类语言 

442
00:21:08,910 --> 00:21:10,250
它不一定是英语 

443
00:21:10,250 --> 00:21:14,120
但我现在要说的是 在那个下面 只说这样的话--

444
00:21:14,120 --> 00:21:16,012
向用户问好 

445
00:21:16,012 --> 00:21:17,720
您会注意到 默认情况下 VS代码

446
00:21:17,720 --> 00:21:19,302
让我的评论变灰了 

447
00:21:19,302 --> 00:21:22,010
它们不再是蓝色 不再是红色 也不再是颜色 

448
00:21:22,010 --> 00:21:24,240
这只是因为它们是对我自己的笔记

449
00:21:24,240 --> 00:21:26,730
而计算机最终会忽略它们 

450
00:21:26,730 --> 00:21:29,350
但我们现在有两条评论--询问用户

451
00:21:29,350 --> 00:21:32,380
对于他们的名字 然后是第二条评论 向用户问好 

452
00:21:32,380 --> 00:21:35,590
我刚刚注释了每一段代码 

453
00:21:35,590 --> 00:21:40,180
就像每一行或多行复数代码一样 它们正在做一些值得注意的事情 

454
00:21:40,180 --> 00:21:40,750
为什么？

455
00:21:40,750 --> 00:21:43,120
好吧 明天早上当我醒来的时候

456
00:21:43,120 --> 00:21:47,740
睡了好一阵子 忘了前一天做了什么 

457
00:21:47,740 --> 00:21:49,840
评论很方便 只需查看

458
00:21:49,840 --> 00:21:52,510
用英语或你自己的人类语言

459
00:21:52,510 --> 00:21:55,810
这是一个程序 这样你就不需要阅读代码本身了

460
00:21:55,810 --> 00:21:59,200
而且 更好的是 如果未来可能出现错误 

461
00:21:59,200 --> 00:22:02,740
您可以阅读您的意图 然后您可以查看代码

462
00:22:02,740 --> 00:22:06,050
并确定您的代码现在是否正在执行您想要的操作 

463
00:22:06,050 --> 00:22:08,920
因此 对于这么小的程序来说 这并不是真正必要的 

464
00:22:08,920 --> 00:22:11,287
很明显 只有一行、两行或三行

465
00:22:11,287 --> 00:22:12,370
程序在做什么 

466
00:22:12,370 --> 00:22:14,668
阅读代码的速度和阅读注释一样快 

467
00:22:14,668 --> 00:22:16,960
但养成这个习惯通常是一件好事--

468
00:22:16,960 --> 00:22:21,220
每隔一行或几行注释代码 以提醒自己

469
00:22:21,220 --> 00:22:24,250
以及其他是您的意图和您的代码正在做什么 

470
00:22:24,250 --> 00:22:26,590
评论的好处也在于--

471
00:22:26,590 --> 00:22:30,940
评论也可以成为你自己的待办事项清单 

472
00:22:30,940 --> 00:22:33,850
在伪代码编程中有这样一个概念 

473
00:22:33,850 --> 00:22:35,350
伪码不是一种正式的东西 

474
00:22:35,350 --> 00:22:37,300
它不是一种特定的语言 

475
00:22:37,300 --> 00:22:40,090
它只是使用英语或你自己的人类语言

476
00:22:40,090 --> 00:22:44,590
简洁、有条不紊、有算法地表达你的想法 

477
00:22:44,590 --> 00:22:45,460
可以这么说 

478
00:22:45,460 --> 00:22:48,070
但是伪代码 因此 因为它不是Python

479
00:22:48,070 --> 00:22:51,130
它不一定是英语 它只是一种允许

480
00:22:51,130 --> 00:22:53,520
你甚至需要提前概述你的计划.

481
00:22:53,520 --> 00:22:56,532
举个例子 如果我今天不确定如何

482
00:22:56,532 --> 00:22:58,240
我想着手写这个程序

483
00:22:58,240 --> 00:23:01,720
但我不知道我想做什么 我本可以从今天开始

484
00:23:01,720 --> 00:23:04,570
只需在Hello.py中编写这段代码 

485
00:23:04,570 --> 00:23:07,870
没有代码 我可以只对自己写几条评论--

486
00:23:07,870 --> 00:23:09,460
步骤1 询问用户姓名 

487
00:23:09,460 --> 00:23:11,440
第二步 向用户问好 

488
00:23:11,440 --> 00:23:15,520
然后 一旦我用伪代码概述了我的程序 然后我就可以进去了

489
00:23:15,520 --> 00:23:18,190
然后说 好吧 我怎么向用户询问他们的名字呢？

490
00:23:18,190 --> 00:23:21,910
好吧 我可以输入“你叫什么名字”的问题？

491
00:23:21,910 --> 00:23:26,080
然后在左边 我可以放一个变量 然后把它赋值给它 

492
00:23:26,080 --> 00:23:27,730
好的 我该如何向用户问好呢？

493
00:23:27,730 --> 00:23:30,280
嗯 我知道我可以用印刷体在屏幕上说些什么 

494
00:23:30,280 --> 00:23:32,920
让我打个招呼 让我--

495
00:23:32,920 --> 00:23:35,210
好的 现在让我把这个人的名字打印出来 

496
00:23:35,210 --> 00:23:38,960
因此 伪代码是构建待办事项列表的一种很好的方式 

497
00:23:38,960 --> 00:23:41,680
尤其是如果您不知道如何编写代码 

498
00:23:41,680 --> 00:23:45,993
因为它将一个较大的程序分解成几个小任务 

499
00:23:45,993 --> 00:23:48,160
好吧 让我在这里停一下 看看现在有没有

500
00:23:48,160 --> 00:23:56,390
有关注释、伪代码、返回值或变量的任何问题 

501
00:23:56,390 --> 00:23:59,170
有什么问题我们可以在这里说清楚吗？

502
00:23:59,170 --> 00:24:02,500
听众：是的 我的问题是功能输入

503
00:24:02,500 --> 00:24:06,843
为任何类型的信息工作 还是只为文字工作？

504
00:24:06,843 --> 00:24:08,510
大卫·马兰：是的 这个问题问得很好 

505
00:24:08,510 --> 00:24:12,070
所以根据它的文档 我们将更多地查看正式文档

506
00:24:12,070 --> 00:24:14,290
很快 输入将会期待所谓的

507
00:24:14,290 --> 00:24:16,900
一个字符串 那是一个文本序列 不管它是什么

508
00:24:16,900 --> 00:24:19,030
用英语或任何其他人类语言 

509
00:24:19,030 --> 00:24:23,660
但它确实会期待用来提示用户的文本 

510
00:24:23,660 --> 00:24:24,340
问得好 

511
00:24:24,340 --> 00:24:26,632
如果可以的话 小组里的另一个问题怎么样？

512
00:24:26,632 --> 00:24:30,520
观众：我想问的是 我该如何发表几行评论呢？

513
00:24:30,520 --> 00:24:32,770
大卫·马兰：哦 你是怎么做很多评论的 

514
00:24:32,770 --> 00:24:34,000
如果我没听错的话？

515
00:24:34,000 --> 00:24:34,330
观众：是的 

516
00:24:34,330 --> 00:24:35,290
大卫·马兰：当然 

517
00:24:35,290 --> 00:24:38,380
你就会一直这样做下去 

518
00:24:38,380 --> 00:24:43,300
您只需为每行添加一个散列符号前缀 就像我在这里所做的那样 

519
00:24:43,300 --> 00:24:46,990
还有另一种在Python中执行多行注释的技术 即

520
00:24:46,990 --> 00:24:48,670
实际上往往有特殊的含义 

521
00:24:48,670 --> 00:24:53,650
你可以像这样做三个双引号 然后在这里做任何中间的事情

522
00:24:53,650 --> 00:24:54,910
是一种评论 

523
00:24:54,910 --> 00:24:55,960
这是另一种技术 

524
00:24:55,960 --> 00:24:57,502
或者 您也可以使用单引号 

525
00:24:57,502 --> 00:25:00,257
但我认为 下次会有更多关于这些的内容 

526
00:25:00,257 --> 00:25:02,590
好吧 好吧 你不会介意的 让我继续

527
00:25:02,590 --> 00:25:05,290
看看我们可以如何进一步改进这个项目

528
00:25:05,290 --> 00:25:07,570
还介绍了一些其他功能 我们可能

529
00:25:07,570 --> 00:25:10,100
想要考虑到随着时间的推移 

530
00:25:10,100 --> 00:25:13,270
所以事实证明 我们肯定可以改进这个项目

531
00:25:13,270 --> 00:25:17,020
因为我在这里偷工减料有点令人失望

532
00:25:17,020 --> 00:25:20,680
然后说你好 逗号 然后在新的一行打印出名字 

533
00:25:20,680 --> 00:25:21,700
好像我们能做得更好 

534
00:25:21,700 --> 00:25:24,760
当然 你在手机或笔记本上使用的大多数程序

535
00:25:24,760 --> 00:25:26,810
当人们需要时 将文本放在一起 

536
00:25:26,810 --> 00:25:28,243
那么 我们该如何着手做这件事呢？

537
00:25:28,243 --> 00:25:29,660
嗯 有几种不同的方法 

538
00:25:29,660 --> 00:25:32,890
事实上 这里的目标并不是要解决这个问题 

539
00:25:32,890 --> 00:25:35,290
但为了在编程中演示和强调这一点--

540
00:25:35,290 --> 00:25:38,080
Python和其他语言--有很多方法

541
00:25:38,080 --> 00:25:40,690
有时是为了解决同样的问题 

542
00:25:40,690 --> 00:25:42,830
这里有一个解决这个问题的方法 

543
00:25:42,830 --> 00:25:48,100
让我进去 现在让我来打个招呼 

544
00:25:48,100 --> 00:25:52,450
让我在该用户名的末尾添加 

545
00:25:52,450 --> 00:25:54,980
所以我正在以一种有趣的方式使用+ 

546
00:25:54,980 --> 00:25:56,560
本质上 这不是加法 

547
00:25:56,560 --> 00:25:59,290
很明显 我不是在加数字 但我确实加了

548
00:25:59,290 --> 00:26:04,840
我想把这个人的名字加到逗号字符串中 

549
00:26:04,840 --> 00:26:08,830
现在让我转到我的终端窗口并运行Hello.py的Python

550
00:26:08,830 --> 00:26:10,000
再次输入 

551
00:26:10,000 --> 00:26:10,750
你叫什么名字？

552
00:26:10,750 --> 00:26:11,920
我要把大卫打进去 

553
00:26:11,920 --> 00:26:12,940
进来吧 

554
00:26:12,940 --> 00:26:14,260
好了 好多了 

555
00:26:14,260 --> 00:26:18,160
这是更好的 但有一个小错误 尽管这里的美学 

556
00:26:18,160 --> 00:26:20,830
这里缺少空白处 但让我们在这里使用一些直觉 

557
00:26:20,830 --> 00:26:22,900
好吧 如果我漏掉了逗号后面的空格 

558
00:26:22,900 --> 00:26:25,780
为什么我不在这里手动添加它呢？

559
00:26:25,780 --> 00:26:30,670
现在让我重新运行程序Hello.py的Python Enter David Enter 

560
00:26:30,670 --> 00:26:31,540
这就对了 

561
00:26:31,540 --> 00:26:33,400
现在我们有了一些看起来更漂亮的东西

562
00:26:33,400 --> 00:26:34,570
在英语语法方面 

563
00:26:34,570 --> 00:26:36,640
你好 逗号 空格 大卫 

564
00:26:36,640 --> 00:26:40,060
现在如果我们倒带 你可能已经注意到了

565
00:26:40,060 --> 00:26:45,100
或者想知道为什么我的问号后面有这个看似多余的空格 

566
00:26:45,100 --> 00:26:45,940
也就是这里 

567
00:26:45,940 --> 00:26:48,790
问号后、双引号前有一个空格

568
00:26:48,790 --> 00:26:50,332
这也只是为了美观 

569
00:26:50,332 --> 00:26:53,315
我想将用户的光标向右移动一个空间

570
00:26:53,315 --> 00:26:55,690
所以当我输入他们的名字或他们输入他们的名字时 

571
00:26:55,690 --> 00:26:59,650
它不是紧挨着那个问号的 

572
00:26:59,650 --> 00:27:01,790
但我们还有其他方法可以做到这一点 

573
00:27:01,790 --> 00:27:05,080
事实证明 一些函数 其中包括打印 

574
00:27:05,080 --> 00:27:07,570
实际上有多个论据 

575
00:27:07,570 --> 00:27:11,200
事实证明 如果你把输入分离出来

576
00:27:11,200 --> 00:27:14,620
函数--即函数的所谓参数--加上逗号 

577
00:27:14,620 --> 00:27:19,250
你不能只传一次 还可以传两次 三次 四次 五次 往前 

578
00:27:19,250 --> 00:27:24,970
所以让我继续下去 不仅仅是你好 逗号 空格 还有随后的

579
00:27:24,970 --> 00:27:25,660
叫出名字 

580
00:27:25,660 --> 00:27:27,880
乍一看 这可能有点令人困惑

581
00:27:27,880 --> 00:27:30,297
因为现在我有两个逗号 但需要注意的是

582
00:27:30,297 --> 00:27:35,800
第一个逗号在我的引号内 这只是

583
00:27:35,800 --> 00:27:37,490
一种符合英语语法的东西 

584
00:27:37,490 --> 00:27:40,270
第二个逗号在引号之外 

585
00:27:40,270 --> 00:27:44,170
但现在有两种不同的论据需要发表 

586
00:27:44,170 --> 00:27:46,270
第一个参数是Hello、逗号、空格 

587
00:27:46,270 --> 00:27:49,490
第二个参数是名称变量本身 

588
00:27:49,490 --> 00:27:51,640
所以让我们来看看这是什么样子 

589
00:27:51,640 --> 00:27:53,620
Python of Hello.py 回车 

590
00:27:53,620 --> 00:27:54,460
你叫什么名字？

591
00:27:54,460 --> 00:27:55,060
大卫 

592
00:27:55,060 --> 00:27:56,050
进来吧 

593
00:27:56,050 --> 00:27:57,910
好吧 我有点矫枉过正了 

594
00:27:57,910 --> 00:28:00,040
出于某种原因 我现在有两个车位 

595
00:28:00,040 --> 00:28:02,080
事实证明 这是微妙的 当

596
00:28:02,080 --> 00:28:07,960
您将多个参数传递给print 它会自动为您插入一个空格 

597
00:28:07,960 --> 00:28:10,270
这件事之前并不重要 因为我

598
00:28:10,270 --> 00:28:16,510
通过使用+运算符 传入一个大参数以一次性打印所有内容 

599
00:28:16,510 --> 00:28:19,070
这一次 由于逗号的原因 我传入了两个 

600
00:28:19,070 --> 00:28:23,210
因此 如果我不想要额外的空间 我不需要自己传递一个空间 

601
00:28:23,210 --> 00:28:26,530
我可以这样做 现在注意到 如果我再次运行这个程序--

602
00:28:26,530 --> 00:28:29,560
Python of Hello.py 输入我的名字David 

603
00:28:29,560 --> 00:28:32,620
现在 从语法上看 它可能是我想要的 

604
00:28:32,620 --> 00:28:34,330
现在 这些方法中哪一种更好？

605
00:28:34,330 --> 00:28:37,840
这种方法使用带有两个参数的函数print--

606
00:28:37,840 --> 00:28:40,810
你好 逗号和名称变量 

607
00:28:40,810 --> 00:28:44,195
之前的版本 Recall 技术上使用了一个论点 

608
00:28:44,195 --> 00:28:45,820
尽管它看起来有点奇怪 

609
00:28:45,820 --> 00:28:49,270
这是一种观点 计算机就像数学家一样 

610
00:28:49,270 --> 00:28:51,950
我们首先要做的是括号内的内容 

611
00:28:51,950 --> 00:28:54,670
所以如果你在圆括号里有这串文字--

612
00:28:54,670 --> 00:28:58,350
你好 逗号和空格 我需要添加回来 

613
00:28:58,350 --> 00:29:01,050
然后你有一个+ 这意味着本身不是加法 

614
00:29:01,050 --> 00:29:05,400
而是串联--把左边的东西和右边的东西连接起来 

615
00:29:05,400 --> 00:29:08,400
这最终变成了英语短语--

616
00:29:08,400 --> 00:29:10,890
你好 逗号 空格 大卫 

617
00:29:10,890 --> 00:29:14,400
然后最终传递给函数的是什么

618
00:29:14,400 --> 00:29:18,870
从技术上讲是这样的 但它完全是动态的 

619
00:29:18,870 --> 00:29:23,860
这不是我像之前那样小心翼翼地输入大卫 

620
00:29:23,860 --> 00:29:27,930
它会动态计算出连接Hello后的值

621
00:29:27,930 --> 00:29:30,900
使用名称的值 然后最终传递

622
00:29:30,900 --> 00:29:33,750
作为唯一的论据发表 

623
00:29:33,750 --> 00:29:38,130
让我在这里暂停一下 看看是否有任何关于论点数量的问题

624
00:29:38,130 --> 00:29:41,250
现在 让我们来谈谈功能 

625
00:29:41,250 --> 00:29:43,950
观众：我们可以多次使用一个函数吗

626
00:29:43,950 --> 00:29:48,765
来解决我们在代码中可能多次遇到的某个问题？

627
00:29:48,765 --> 00:29:49,640
大卫·马兰：你可以的 

628
00:29:49,640 --> 00:29:52,700
您可以多次使用一个函数来解决某些问题 

629
00:29:52,700 --> 00:29:55,040
不过 我们很快就会看到 如果你发现自己

630
00:29:55,040 --> 00:29:58,620
当程序员再次以相同的方式解决问题时 

631
00:29:58,620 --> 00:30:00,560
再一次 一次又一次 事实证明你会

632
00:30:00,560 --> 00:30:02,450
能够做出自己的功能 这样你就可以

633
00:30:02,450 --> 00:30:07,130
不必一直重复使用语言附带的基本功能 

634
00:30:07,130 --> 00:30:10,890
观众：我对逗号和+号很好奇 

635
00:30:10,890 --> 00:30:15,320
所以在+号之后 我们能不能只给出一个变量 在逗号之后再给我们

636
00:30:15,320 --> 00:30:17,180
是否提供多变量状态？

637
00:30:17,180 --> 00:30:18,470
有什么关系？

638
00:30:18,470 --> 00:30:19,678
大卫·马兰：问得好 

639
00:30:19,678 --> 00:30:21,320
因此 在弦的上下文中--

640
00:30:21,320 --> 00:30:22,640
我一直在用这个词 

641
00:30:22,640 --> 00:30:25,130
“字符串”是编程语言中的一个技术术语

642
00:30:25,130 --> 00:30:29,570
同样 它意味着一系列文本--一个字符 一个单词 整个段落 

643
00:30:29,570 --> 00:30:30,080
不相上下 

644
00:30:30,080 --> 00:30:33,650
所以不只是使用+运算符 我们将

645
00:30:33,650 --> 00:30:37,790
看 对于在Python中的数字加法 就像我们在纸铅笔上做的那样 

646
00:30:37,790 --> 00:30:41,760
但它也用于连接左侧和右侧的字符串 

647
00:30:41,760 --> 00:30:44,180
如果你想组合的不只是两根弦--

648
00:30:44,180 --> 00:30:46,310
左和右--但第三和第四个 

649
00:30:46,310 --> 00:30:51,380
您完全可以继续使用+、+ 并将它们链接在一起

650
00:30:51,380 --> 00:30:52,460
就像在数学里一样 

651
00:30:52,460 --> 00:30:54,830
最终 这会开始看起来有点丑陋 

652
00:30:54,830 --> 00:30:57,080
我敢说 特别是当您的代码行变得很长的时候 

653
00:30:57,080 --> 00:31:00,200
所以有更好的方法 我们很快就会看到 

654
00:31:00,200 --> 00:31:01,670
也是一个很好的问题 

655
00:31:01,670 --> 00:31:04,190
好的 让我回到这里讨论的代码

656
00:31:04,190 --> 00:31:06,800
看看我们能不能给你们展示几种其他的方式

657
00:31:06,800 --> 00:31:10,520
来解决同样的问题 同时强调我们在技术上

658
00:31:10,520 --> 00:31:12,980
说到这里 是的 是弦 但甚至还有

659
00:31:12,980 --> 00:31:15,170
在Python中表示这些字符串的技术术语 

660
00:31:15,170 --> 00:31:19,700
这就是STR 可以说 S-T-R 简称为弦 

661
00:31:19,700 --> 00:31:22,220
如果你用其他语言编程 你可能知道 

662
00:31:22,220 --> 00:31:26,270
发明编程语言的人喜欢非常简洁 

663
00:31:26,270 --> 00:31:29,780
所以我们倾向于用相当简短的短语来描述事物 

664
00:31:29,780 --> 00:31:31,370
不一定是完整的单词 

665
00:31:31,370 --> 00:31:33,920
所以 虽然你可能会说“弦” 从技术上讲

666
00:31:33,920 --> 00:31:37,070
在Python语言中 我们真正谈论的是这些文本序列 

667
00:31:37,070 --> 00:31:38,300
严格来说是STR 

668
00:31:38,300 --> 00:31:41,450
这是程序中的实际数据类型 

669
00:31:41,450 --> 00:31:45,420
但我们很快就会发现 程序中还有其他类型的数据 

670
00:31:45,420 --> 00:31:48,980
事实上 让我们看看我们是否不能用另一种方式来改善这一点 

671
00:31:48,980 --> 00:31:52,550
我喜欢我们通过让一切保持一致而取得的进展--

672
00:31:52,550 --> 00:31:55,490
你好 大卫在同一条线路上 

673
00:31:55,490 --> 00:31:59,070
然而 在解决这个问题方面 我们还能做些什么呢？

674
00:31:59,070 --> 00:32:02,420
嗯 事实证明 我们并不需要完全放弃

675
00:32:02,420 --> 00:32:03,800
使用打印两次 

676
00:32:03,800 --> 00:32:07,460
让我倒回一点 回到以前的版本

677
00:32:07,460 --> 00:32:11,660
我真的不确定如何解决这个问题 所以我使用了一次打印

678
00:32:11,660 --> 00:32:14,090
只打印出Hello、空格和逗号 

679
00:32:14,090 --> 00:32:17,750
然后我再次使用打印来打印姓名 

680
00:32:17,750 --> 00:32:22,220
严格地说 这并不坏 但有一个视觉副作用

681
00:32:22,220 --> 00:32:23,270
这是我不喜欢的 

682
00:32:23,270 --> 00:32:26,540
把这两行文字分开看起来很难看

683
00:32:26,540 --> 00:32:27,600
彼此之间的距离 

684
00:32:27,600 --> 00:32:29,480
但还有另一种方法可以解决这个问题 

685
00:32:29,480 --> 00:32:34,130
显然 打印功能似乎是自动

686
00:32:34,130 --> 00:32:36,110
输出一个空行 

687
00:32:36,110 --> 00:32:39,380
它会自动将光标移动到下一行

688
00:32:39,380 --> 00:32:42,620
因为这就是为什么我在一条线路上看到Hello和David

689
00:32:42,620 --> 00:32:44,150
在下一个问题上 然后是我的提示--

690
00:32:44,150 --> 00:32:46,530
美元符号--在下面的那条线上 

691
00:32:46,530 --> 00:32:48,800
因此 印刷品似乎在自动推定

692
00:32:48,800 --> 00:32:51,230
您希望它将光标移动到下一行

693
00:32:51,230 --> 00:32:53,040
在你给它传递一些参数之后 

694
00:32:53,040 --> 00:32:54,890
但您可以覆盖该行为 

695
00:32:54,890 --> 00:32:58,400
同样 函数接受影响其行为的参数 

696
00:32:58,400 --> 00:33:00,740
你只需要知道这些论点是什么 

697
00:33:00,740 --> 00:33:06,560
事实证明 如果我们查看有关Python打印的文档

698
00:33:06,560 --> 00:33:09,980
函数 我们实际上可以在这里查看这个URL--

699
00:33:09,980 --> 00:33:14,150
在docs.python.org上可以找到所有的Python官方文档 

700
00:33:14,150 --> 00:33:17,870
如果我四处看看 我可以找到更具体的这个URL

701
00:33:17,870 --> 00:33:22,970
在这里 我可以找到所有可用的Python函数

702
00:33:22,970 --> 00:33:24,630
以及那里的文档 

703
00:33:24,630 --> 00:33:26,900
如果我走得更准确一点 我甚至可以

704
00:33:26,900 --> 00:33:30,230
查找打印函数本身的特定文档 

705
00:33:30,230 --> 00:33:31,980
而不是在浏览器中打开它 

706
00:33:31,980 --> 00:33:36,050
接下来 我将突出显示同一URL中的一行 即

707
00:33:36,050 --> 00:33:39,890
这是我们所见过的最神秘的东西 

708
00:33:39,890 --> 00:33:42,717
但这是打印功能的官方文档 

709
00:33:42,717 --> 00:33:45,800
在学习编程语言时 你能做的最好的事情之一就是

710
00:33:45,800 --> 00:33:48,110
老实说 就是学会阅读文档 

711
00:33:48,110 --> 00:33:51,920
因为真的 你所有问题的答案都会以某种方式

712
00:33:51,920 --> 00:33:55,430
尽管不可否认 这并不总是显而易见的 但一定要做到 

713
00:33:55,430 --> 00:33:57,290
我也会说 Python的文档

714
00:33:57,290 --> 00:34:01,460
这不一定是最容易的事情 特别是对于第一次或新手来说

715
00:34:01,460 --> 00:34:02,072
程序员 

716
00:34:02,072 --> 00:34:05,030
这也需要练习 所以如果你不是这样的话 试着不要感到不知所措

717
00:34:05,030 --> 00:34:06,292
当然你看到的是什么 

718
00:34:06,292 --> 00:34:08,000
但让我向您介绍一下这个例子 

719
00:34:08,000 --> 00:34:11,360
这也是来自Python官方文档的一行文本

720
00:34:11,360 --> 00:34:12,690
用于打印功能 

721
00:34:12,690 --> 00:34:14,659
这表明这是这样的--

722
00:34:14,659 --> 00:34:17,000
这个函数的名称当然是print 

723
00:34:17,000 --> 00:34:20,570
然后这里有一个括号和另一种紧凑的括号方式

724
00:34:20,570 --> 00:34:21,230
在那边 

725
00:34:21,230 --> 00:34:23,570
这些括号中的所有内容都是

726
00:34:23,570 --> 00:34:27,270
参数 潜在的参数 传递给函数 

727
00:34:27,270 --> 00:34:30,830
然而 当我们看到这些论点时

728
00:34:30,830 --> 00:34:34,400
在这样的文档中 从技术上讲 有一个不同的术语

729
00:34:34,400 --> 00:34:35,150
我们会用到的 

730
00:34:35,150 --> 00:34:37,920
从技术上讲 这些是该函数的参数 

731
00:34:37,920 --> 00:34:41,900
因此 当您谈论可以传递给函数的内容时

732
00:34:41,900 --> 00:34:45,679
这些输入被称为什么 这些就是参数 

733
00:34:45,679 --> 00:34:48,080
当您实际使用该函数并传递

734
00:34:48,080 --> 00:34:51,650
在这些圆括号内的值中 这些输入 

735
00:34:51,650 --> 00:34:53,580
这些值是参数 

736
00:34:53,580 --> 00:34:56,719
所以我们谈论的是完全相同的事情--参数和自变量

737
00:34:56,719 --> 00:34:58,850
实际上是一样的 但你的条款

738
00:34:58,850 --> 00:35:01,520
从不同的角度看问题的用处 

739
00:35:01,520 --> 00:35:04,220
当我们查看该函数可以采用的功能与

740
00:35:04,220 --> 00:35:06,210
您实际上是在传递到函数中 

741
00:35:06,210 --> 00:35:07,500
那么 这意味着什么呢？

742
00:35:07,500 --> 00:35:10,610
这个语法相当隐晦 但目前 

743
00:35:10,610 --> 00:35:14,360
只要知道一个星号 一个星星 然后是“物体”这个词

744
00:35:14,360 --> 00:35:17,330
意味着打印函数可以接受任意数量的对象 

745
00:35:17,330 --> 00:35:20,540
您可以传入0个文本字符串 1个字符串

746
00:35:20,540 --> 00:35:23,900
就像我做的那样 两根弦 或者 从技术上讲 无限多根弦

747
00:35:23,900 --> 00:35:27,170
如果您真的想要 尽管代码看起来不会很好 

748
00:35:27,170 --> 00:35:31,130
在那之后我们看到一个逗号 然后我们在这里看到另一个参数

749
00:35:31,130 --> 00:35:34,400
被称为SEP 在英语中是分离器的缩写 

750
00:35:34,400 --> 00:35:38,640
注意等号和单引号 空格 单引号 

751
00:35:38,640 --> 00:35:42,350
所以“太空”我还不知道那是什么 

752
00:35:42,350 --> 00:35:44,570
但我认为我们已经看到了这方面的暗示 

753
00:35:44,570 --> 00:35:46,430
让我们暂时把注意力集中在这个--

754
00:35:46,430 --> 00:35:50,720
打印函数接受另一个名为end的参数和默认参数

755
00:35:50,720 --> 00:35:54,560
该参数值显然是基于这个等号和这些

756
00:35:54,560 --> 00:35:57,020
引号 /n 

757
00:35:57,020 --> 00:36:00,260
如果你想加入聊天 那/n是什么？

758
00:36:00,260 --> 00:36:02,810
以前编程的人可能都看过这个 

759
00:36:02,810 --> 00:36:07,070
不过 如果您以前从未编写过程序 这看起来可能会非常神秘 

760
00:36:07,070 --> 00:36:12,530
反斜杠n表示换行 这是一种文本方式

761
00:36:12,530 --> 00:36:15,710
表明你是否以及何时有效地想要电脑

762
00:36:15,710 --> 00:36:19,490
要将光标移动到下一行 请创建新的文本行 

763
00:36:19,490 --> 00:36:22,310
因此 从技术上讲 如果我们阅读文档 

764
00:36:22,310 --> 00:36:23,960
我们将看到关于这一点的更多细节 

765
00:36:23,960 --> 00:36:28,550
事实上 在打印文档中有一个名为end的参数

766
00:36:28,550 --> 00:36:32,840
函数 这意味着默认情况下 此打印函数将结束

767
00:36:32,840 --> 00:36:35,240
每一行都有/n 

768
00:36:35,240 --> 00:36:37,670
你看到的不是字面上的/n 而是一个新的行 

769
00:36:37,670 --> 00:36:40,320
您会看到光标移动到下一行 

770
00:36:40,320 --> 00:36:42,500
现在按照这个逻辑 让我们后退一步 

771
00:36:42,500 --> 00:36:46,790
SEP Four分隔符--分隔符的缺省值

772
00:36:46,790 --> 00:36:49,460
显然是一个空格 

773
00:36:49,460 --> 00:36:51,020
那么 我们在哪里看到的呢？

774
00:36:51,020 --> 00:36:55,190
回想一下前面的一个例子 我传入的不只是一个 而是两个

775
00:36:55,190 --> 00:36:57,210
Print函数的参数 

776
00:36:57,210 --> 00:37:00,300
回想一下 他们之间有一个神奇的空间 

777
00:37:00,300 --> 00:37:02,540
事实上 他们有那个空间+我自己的空间

778
00:37:02,540 --> 00:37:05,720
这就是为什么我删除了我的空间 因为在这一点上它是额外的 

779
00:37:05,720 --> 00:37:09,620
因此 这只是意味着当您将多个参数传递给print时 默认情况下

780
00:37:09,620 --> 00:37:11,750
它们将被一个空格隔开 

781
00:37:11,750 --> 00:37:14,570
默认情况下 当您将参数传递给print时 

782
00:37:14,570 --> 00:37:17,880
整件事都将以一句新台词结束 

783
00:37:17,880 --> 00:37:19,850
现在 只要知道这一点 让我从字面上

784
00:37:19,850 --> 00:37:22,890
把我的手放在剩下的文件上 改天再说 

785
00:37:22,890 --> 00:37:24,890
印刷品可以做的事情还有很多 但我们

786
00:37:24,890 --> 00:37:29,360
我们将重点放在SEP上 让我们看看我们现在是否不能利用这一点

787
00:37:29,360 --> 00:37:31,010
来解决这个最初的问题 

788
00:37:31,010 --> 00:37:34,250
最初的问题是这样的 我不喜欢你好 大卫

789
00:37:34,250 --> 00:37:35,750
在两条不同的线路上 

790
00:37:35,750 --> 00:37:38,420
好吧 这又发生了 因为指纹是自动的

791
00:37:38,420 --> 00:37:41,810
打印出一个新的行 所以让我们告诉它不要这样做 

792
00:37:41,810 --> 00:37:47,150
让我们通过向第一次使用print传递第二个参数来说明这一点

793
00:37:47,150 --> 00:37:51,110
说结束=引用 不引用--

794
00:37:51,110 --> 00:37:54,840
NOT/N 这是自动设置的默认值 

795
00:37:54,840 --> 00:37:58,250
让我们引用它 不引用其他任何东西 

796
00:37:58,250 --> 00:38:01,850
让我们覆盖缺省值 这样就不会有新行了 

797
00:38:01,850 --> 00:38:03,560
从字面上看什么都没有 

798
00:38:03,560 --> 00:38:05,250
让我们看看会发生什么 

799
00:38:05,250 --> 00:38:08,270
现在让我转到我的终端窗口并清除它 

800
00:38:08,270 --> 00:38:10,672
我将运行Hello.py的Python 回车 

801
00:38:10,672 --> 00:38:12,380
我要输入我的名字 大卫和我

802
00:38:12,380 --> 00:38:16,280
我想现在一切都会保持一致 因为--

803
00:38:16,280 --> 00:38:22,460
它做到了--这一行 5 将打印出Hello 逗号 空格 

804
00:38:22,460 --> 00:38:24,710
但最后什么都没有 因为我

805
00:38:24,710 --> 00:38:26,450
改成了引用 不引用 

806
00:38:26,450 --> 00:38:29,210
第二行将打印名字 大卫 

807
00:38:29,210 --> 00:38:32,780
或者不管这个人的名字是什么 它会将光标移动到下一行

808
00:38:32,780 --> 00:38:36,230
因为我没有覆盖End There的值 

809
00:38:36,230 --> 00:38:39,710
为了更清楚地看到这一点 如果你做一些神秘的事情 

810
00:38:39,710 --> 00:38:41,420
我不知道发生了什么事 

811
00:38:41,420 --> 00:38:44,120
让我暂时在这里加三个问号 

812
00:38:44,120 --> 00:38:46,040
我们也会看到这一结果的 

813
00:38:46,040 --> 00:38:49,202
让我返回到我的终端窗口 运行问候的Python Py 

814
00:38:49,202 --> 00:38:49,910
你叫什么名字？

815
00:38:49,910 --> 00:38:50,420
大卫 

816
00:38:50,420 --> 00:38:54,207
现在你看到的是非常丑陋的输出 

817
00:38:54,207 --> 00:38:55,790
但你可以从字面上看到发生了什么 

818
00:38:55,790 --> 00:39:01,010
你好 逗号 空格 然后是三个问号 结束 打印语句 

819
00:39:01,010 --> 00:39:05,570
然后你会看到D-A-V-I-D 所以这不是个好结果 

820
00:39:05,570 --> 00:39:09,080
但它也表明了我们在这里也有多大的控制权 

821
00:39:09,080 --> 00:39:10,490
让我倒得更远一些 

822
00:39:10,490 --> 00:39:13,250
回想一下 在我们的另一个版本中 

823
00:39:13,250 --> 00:39:18,710
当我传入Hello、逗号和名字时 它们之间用一个空格隔开 

824
00:39:18,710 --> 00:39:22,340
所以 在Hello.py的Python中 D-A-V-I-D 回车 

825
00:39:22,340 --> 00:39:23,690
这招真的奏效了 

826
00:39:23,690 --> 00:39:27,950
那么 如果我们覆盖分隔符的SEP值 会怎么样？

827
00:39:27,950 --> 00:39:31,730
与其成为一个空间 我们可以说些什么

828
00:39:31,730 --> 00:39:35,030
就像 问号只是为了包装

829
00:39:35,030 --> 00:39:37,110
我们的脑子里想着那里正在发生的事情 

830
00:39:37,110 --> 00:39:41,300
现在让我执行Hello.py的Python D-A-V-I-D 回车 

831
00:39:41,300 --> 00:39:42,650
你会看到两个 

832
00:39:42,650 --> 00:39:43,850
这两个输入--

833
00:39:43,850 --> 00:39:47,840
你好 逗号和名字现在以一种难看的方式分隔

834
00:39:47,840 --> 00:39:52,580
三个问号 因为我已经覆盖了SEP的默认行为 

835
00:39:52,580 --> 00:39:54,803
即使文档使用了单引号 

836
00:39:54,803 --> 00:39:56,720
我一直有使用双引号的习惯 

837
00:39:56,720 --> 00:39:58,580
在Python中 您可以使用其中任何一个 

838
00:39:58,580 --> 00:40:01,620
严格地说 这并不重要 但你应该始终如一

839
00:40:01,620 --> 00:40:03,530
而且我通常都会用双引号 

840
00:40:03,530 --> 00:40:08,240
不过 Python的文档总是使用单引号 

841
00:40:08,240 --> 00:40:12,320
现在有关于这些参数类型的问题吗？

842
00:40:12,320 --> 00:40:15,290
请允许我提议我们给这些人一个正式的名字 

843
00:40:15,290 --> 00:40:19,220
到目前为止 当我们将值传递给印刷品时 

844
00:40:19,220 --> 00:40:22,160
这些被称为位置参数--在某种意义上是位置参数

845
00:40:22,160 --> 00:40:24,620
你传递给Print的第一件东西首先被打印出来 

846
00:40:24,620 --> 00:40:27,830
在第二次打印逗号之后传递到打印的第二件事 

847
00:40:27,830 --> 00:40:28,710
以此类推 

848
00:40:28,710 --> 00:40:32,210
但我们现在看到的还有一些称为命名参数的东西 

849
00:40:32,210 --> 00:40:37,550
命名为SEP、分隔符或结束 E-N-D表示行结束 

850
00:40:37,550 --> 00:40:40,910
这些都是命名参数 因为第一 它们是可选的

851
00:40:40,910 --> 00:40:44,450
您可以在打印语句的末尾传递它们 

852
00:40:44,450 --> 00:40:48,290
但您也可以按名称使用它们 

853
00:40:48,290 --> 00:40:51,050
观众：这可能是一个奇怪的问题 但我想知道 

854
00:40:51,050 --> 00:40:57,350
如果有人想要在引语中添加实际的引号怎么办

855
00:40:57,350 --> 00:40:57,920
马克？

856
00:40:57,920 --> 00:40:59,600
大卫·马兰：是的 我喜欢你的想法 

857
00:40:59,600 --> 00:41:01,880
这就是我们所说的角落案例 对吗？

858
00:41:01,880 --> 00:41:03,860
就在我们做完--对 这就是全部

859
00:41:03,860 --> 00:41:06,823
听起来很棒 至少在编程方面是这样 但是 等一下 

860
00:41:06,823 --> 00:41:08,240
如果您想打印报价 该怎么办？

861
00:41:08,240 --> 00:41:09,557
这是一个非常好的问题 

862
00:41:09,557 --> 00:41:11,390
好吧 让我们看看我们是不是不能解决这个问题 

863
00:41:11,390 --> 00:41:15,590
假设我想打印的不仅仅是用户名 

864
00:41:15,590 --> 00:41:16,940
让我进一步简化这一点 

865
00:41:16,940 --> 00:41:18,980
让我继续下去 把很多东西都处理掉 

866
00:41:18,980 --> 00:41:21,510
让我说几句 你好--

867
00:41:24,170 --> 00:41:26,240
也许我说的有点讽刺了 

868
00:41:26,240 --> 00:41:28,310
你好 (讽刺地)“朋友” 

869
00:41:28,310 --> 00:41:30,022
你知道 用那种语气 

870
00:41:30,022 --> 00:41:31,730
实际上 这是行不通的 

871
00:41:31,730 --> 00:41:36,260
因为你试图用引号在手指引号中表现出“朋友”的形象 

872
00:41:36,260 --> 00:41:38,070
但你也在试图结束这一判决 

873
00:41:38,070 --> 00:41:39,778
如果我试着运行它 我们就这么做 

874
00:41:39,778 --> 00:41:43,160
您将看到这只是无效的语法 

875
00:41:43,160 --> 00:41:44,420
也许你忘了一个逗号 

876
00:41:44,420 --> 00:41:45,920
这实际上有点烦人 

877
00:41:45,920 --> 00:41:48,822
有时 您看到的错误消息具有误导性 

878
00:41:48,822 --> 00:41:50,780
就像电脑 语言 并不是真的

879
00:41:50,780 --> 00:41:52,488
知道发生了什么 所以它会尽最大努力

880
00:41:52,488 --> 00:41:55,010
猜测 但这不一定是正确的 

881
00:41:55,010 --> 00:41:57,870
但我可以用几种方法来解决这个问题 

882
00:41:57,870 --> 00:41:59,160
我能做到的

883
00:41:59,160 --> 00:42:01,912
我可以将最外面的引号更改为单引号 

884
00:42:01,912 --> 00:42:03,620
因为再次回想起那一刻 我说你

885
00:42:03,620 --> 00:42:07,130
可以使用双引号或单引号 只要您是一致的 

886
00:42:07,130 --> 00:42:08,000
所以这很好 

887
00:42:08,000 --> 00:42:10,142
如果您在外部使用单引号 您将

888
00:42:10,142 --> 00:42:13,100
然后可以在内部使用双引号 您将从字面上看到它们 

889
00:42:13,100 --> 00:42:17,000
例如 如果我运行Hello.py的Python 我们就可以开始了 

890
00:42:17,000 --> 00:42:18,590
你好 “朋友”

891
00:42:18,590 --> 00:42:19,910
但还有另一种方法 

892
00:42:19,910 --> 00:42:23,450
如果您坚持使用双引号 就像您想要的那样 

893
00:42:23,450 --> 00:42:27,800
为了保持一致 您还可以再次使用该反斜杠字符 

894
00:42:27,800 --> 00:42:30,080
我们刚才看到了那辆车 

895
00:42:30,080 --> 00:42:33,380
这意味着我们不想让文字n出现在输出中 

896
00:42:33,380 --> 00:42:34,640
我们想要一个新的产品线 

897
00:42:34,640 --> 00:42:38,420
因此 反斜杠实际上代表了所谓的转义字符 

898
00:42:38,420 --> 00:42:40,430
转义字符是一个你不能仅仅

899
00:42:40,430 --> 00:42:43,130
一定要在键盘上打字一次 

900
00:42:43,130 --> 00:42:45,270
你需要用多个字符来表达它 

901
00:42:45,270 --> 00:42:50,920
所以我可以在这些内部双引号前面加反斜杠

902
00:42:50,920 --> 00:42:52,920
所以计算机意识到 哦 等一下 

903
00:42:52,920 --> 00:42:57,560
这些不是结束或开始思想的引语 而是字面上的引语 

904
00:42:57,560 --> 00:43:02,420
现在让我返回到我的终端窗口 运行Hello.py的Python 回车 

905
00:43:02,420 --> 00:43:04,800
现在 它也在发挥作用 

906
00:43:04,800 --> 00:43:08,390
因此 逃脱是一种通用的技术 它也允许我们这样做 

907
00:43:08,390 --> 00:43:12,230
如果可以的话 现在让我回顾一下这些例子

908
00:43:12,230 --> 00:43:14,810
然后回到我们停止的地方 用我的代码 

909
00:43:14,810 --> 00:43:18,200
我只是想撤销这一切 因为我想回到正题

910
00:43:18,200 --> 00:43:23,820
最终确定了解决这一问题的最终方法 

911
00:43:23,820 --> 00:43:26,300
好吧 事实证明我们还有另一种方法

912
00:43:26,300 --> 00:43:30,680
我们可以解决这个问题 这可能是最常做的事情

913
00:43:30,680 --> 00:43:35,030
现在 或者至少是在设置我们的时候最优雅的

914
00:43:35,030 --> 00:43:38,840
字符串的使用时间越来越长 

915
00:43:38,840 --> 00:43:43,620
您可以使用一个相对较新的Python特性来实现这一点 

916
00:43:43,620 --> 00:43:47,397
您可以直接在字符串中放入变量的名称 而不是这样

917
00:43:47,397 --> 00:43:49,230
因为我们已经看到这是错的 对吗？

918
00:43:49,230 --> 00:43:52,340
如果您这样做 您将看到您好 逗号 名字 

919
00:43:52,340 --> 00:43:53,580
但如果我这么做了呢？

920
00:43:53,580 --> 00:43:58,070
如果我用花括号或花括号将变量名括起来 会怎么样？

921
00:43:58,070 --> 00:44:00,830
注意VS Code实际上非常微妙地改变了它的颜色 

922
00:44:00,830 --> 00:44:03,590
所以VS Code知道这里发生了一些有趣的事情 

923
00:44:03,590 --> 00:44:08,060
让我运行这个程序 但是我还没有运行完 

924
00:44:08,060 --> 00:44:09,650
D-A-V-I-D 回车 

925
00:44:09,650 --> 00:44:13,430
好吧 显然不是我想要的 但我需要告诉Python

926
00:44:13,430 --> 00:44:15,140
这是一根特殊的弦 

927
00:44:15,140 --> 00:44:18,470
这就是我们所说的格式字符串或F字符串 

928
00:44:18,470 --> 00:44:21,660
在过去的几年中 一种相对较新的特性

929
00:44:21,660 --> 00:44:26,750
这告诉Python实际上以一种特殊的方式格式化字符串中的内容 

930
00:44:26,750 --> 00:44:29,480
从你所做的事情来看 这个符号有点奇怪 

931
00:44:29,480 --> 00:44:31,220
但这是世界的选择 

932
00:44:31,220 --> 00:44:35,390
如果你把F放在字符串的开头 

933
00:44:35,390 --> 00:44:40,160
就在第一个引号之前 这是一个关于Python的线索 哦 

934
00:44:40,160 --> 00:44:41,210
这是一根特殊的线 

935
00:44:41,210 --> 00:44:43,550
让我以一种特殊的方式为您格式化 

936
00:44:43,550 --> 00:44:45,380
现在让我重新运行程序 

937
00:44:45,380 --> 00:44:47,120
Python Hello.py 回车 

938
00:44:47,120 --> 00:44:48,410
D-A-V-I-D 回车 

939
00:44:48,410 --> 00:44:51,170
现在我们看到整个过程中的目标--

940
00:44:51,170 --> 00:44:52,395
你好 大卫 

941
00:44:52,395 --> 00:44:55,520
我们不是以这种方式开始的 因为我认为如果我们以第一种方式进行 

942
00:44:55,520 --> 00:44:57,330
你会想 我们为什么要这么做？

943
00:44:57,330 --> 00:44:58,850
这些神奇的符号是什么？

944
00:44:58,850 --> 00:45:02,370
但这只是解决同样问题的另一种方式 

945
00:45:02,370 --> 00:45:04,940
但让我提议我们现在就考虑

946
00:45:04,940 --> 00:45:06,920
我们可以用弦做的其他事情 

947
00:45:06,920 --> 00:45:11,190
事实证明 即使我们一直在做一些相对简单的操作

948
00:45:11,190 --> 00:45:14,665
在这里 我们通常一直相信用户会合作

949
00:45:14,665 --> 00:45:17,790
这就是说 他们实际上会输入我们想要的内容

950
00:45:17,790 --> 00:45:18,450
打字 

951
00:45:18,450 --> 00:45:20,850
然而 仅仅因为他们输入一个字符串并不意味着

952
00:45:20,850 --> 00:45:22,410
它看起来会像我们想要的那样 

953
00:45:22,410 --> 00:45:24,510
你和我 老实说 因为人类实际上

954
00:45:24,510 --> 00:45:27,840
在网站和应用程序上 喜欢不小心点击

955
00:45:27,840 --> 00:45:30,300
空格键很多 无论是在我们输入的开始

956
00:45:30,300 --> 00:45:33,460
或者在最后 可能是因为空格键往往太大了 

957
00:45:33,460 --> 00:45:35,790
意外的车位是很常见的

958
00:45:35,790 --> 00:45:37,950
在一些用户输入之前或之后 

959
00:45:37,950 --> 00:45:41,675
你和我肯定有不一定要大写单词的习惯

960
00:45:41,675 --> 00:45:42,300
就像我们应该做的那样 

961
00:45:42,300 --> 00:45:45,122
如果我们在发送短信 我们可能有点快

962
00:45:45,122 --> 00:45:46,830
把所有东西都用小写字母写出来 

963
00:45:46,830 --> 00:45:49,913
例如 如果这是你的风格 如果你的手机不能为你修复它 

964
00:45:49,913 --> 00:45:52,530
也许在一封正式的信中 你会适当地把东西大写 

965
00:45:52,530 --> 00:45:56,400
但你和我作为人类 我们不能真的被信任以一种好的方式打字

966
00:45:56,400 --> 00:45:58,870
在使用某个软件时 

967
00:45:58,870 --> 00:46:00,940
无论是一款应用程序、一个网站还是其他什么 

968
00:46:00,940 --> 00:46:04,560
但事实证明 弦本身就是

969
00:46:04,560 --> 00:46:06,450
具有很多内置功能 

970
00:46:06,450 --> 00:46:09,300
您可以在这里的Python自己的文档中看到所有这些内容 

971
00:46:09,300 --> 00:46:12,600
我们一直在讨论的字符串数据类型

972
00:46:12,600 --> 00:46:14,970
带有很多内置的功能

973
00:46:14,970 --> 00:46:18,360
意味着我们可以操作用户的输入来做更多的事情

974
00:46:18,360 --> 00:46:22,290
加入像Hello这样的东西 我们实际上可以清理它

975
00:46:22,290 --> 00:46:26,380
或者重新格式化它 希望它看起来对我们更好一点 

976
00:46:26,380 --> 00:46:29,070
所以让我回到我的代码 让我

977
00:46:29,070 --> 00:46:32,100
演示如果用户不合作可能会发生的情况 

978
00:46:32,100 --> 00:46:35,490
如果我在这里运行Hello.py的Python 请输入 

979
00:46:35,490 --> 00:46:38,890
让我草率地按几次空格键 

980
00:46:38,890 --> 00:46:39,390
为什么？

981
00:46:39,390 --> 00:46:40,890
我只是没有注意到 

982
00:46:40,890 --> 00:46:43,710
现在我要输入我的名字D-A-V-I-D 我不知道 

983
00:46:43,710 --> 00:46:45,510
我又按了几次空格键 

984
00:46:45,510 --> 00:46:46,620
就像是一团糟 

985
00:46:46,620 --> 00:46:47,785
都是小写的 

986
00:46:47,785 --> 00:46:50,160
这在语法上看起来不一定是正确的 

987
00:46:50,160 --> 00:46:51,900
它在这里和这里都有空间 

988
00:46:51,900 --> 00:46:54,030
程序将打印完全相同的内容

989
00:46:54,030 --> 00:46:55,890
这看起来真的很糟糕 至少如果我们

990
00:46:55,890 --> 00:46:57,900
优先考虑美学和语法 

991
00:46:57,900 --> 00:47:00,330
比如 为什么逗号后面有这么多空格？

992
00:47:00,330 --> 00:47:03,420
这不是一种很好的问候用户的方式 

993
00:47:03,420 --> 00:47:05,130
但我们可以把这件事清理干净 

994
00:47:05,130 --> 00:47:10,170
结果是内置到字符串中 同样是这种数据类型 所以

995
00:47:10,170 --> 00:47:12,780
可以说 这种类型的数据在Python中--

996
00:47:12,780 --> 00:47:15,730
是对该字符串进行实际操作的能力 

997
00:47:15,730 --> 00:47:20,280
所以让我这样做 我可以继续做这样的事情--

998
00:47:20,280 --> 00:47:23,820
名称=名称.条带 

999
00:47:23,820 --> 00:47:25,240
这是做什么用的？

1000
00:47:25,240 --> 00:47:30,460
从字符串中删除空格 

1001
00:47:30,460 --> 00:47:32,060
我这么说是什么意思？

1002
00:47:32,060 --> 00:47:33,910
在右手边 请注意我已经

1003
00:47:33,910 --> 00:47:36,700
写入了名为NAME的变量名 

1004
00:47:36,700 --> 00:47:40,120
然后我使用句点或点 然后我

1005
00:47:40,120 --> 00:47:42,520
似乎在做什么是一个函数 对吗？

1006
00:47:42,520 --> 00:47:46,300
到目前为止 每当我们看到一个函数时 我们都会看到该函数的名称--print

1007
00:47:46,300 --> 00:47:49,030
或输入 然后我们看到一个括号 然后是另一个括号 

1008
00:47:49,030 --> 00:47:50,678
这正是我在这里看到的 

1009
00:47:50,678 --> 00:47:52,720
但我使用这个函数的方式略有不同 

1010
00:47:52,720 --> 00:47:55,990
从技术上讲 这个函数在本文中称为方法 

1011
00:47:55,990 --> 00:47:57,620
我这么说是什么意思？

1012
00:47:57,620 --> 00:48:00,250
嗯 如果名字是一个字符串 又名 

1013
00:48:00,250 --> 00:48:03,130
Str 根据文件 事实证明 

1014
00:48:03,130 --> 00:48:07,630
在Python中有很多与字符串一起提供的函数 

1015
00:48:07,630 --> 00:48:10,150
您可以通过使用以下命令访问该功能

1016
00:48:10,150 --> 00:48:14,860
字符串的名称 就像这里的字面意思名称 然后是句点 然后是名称

1017
00:48:14,860 --> 00:48:18,220
函数 然后是一个左括号和一个右括号 

1018
00:48:18,220 --> 00:48:21,320
可能是圆括号里的一些论点 但在这种情况下 

1019
00:48:21,320 --> 00:48:22,900
它不需要任何争论 

1020
00:48:22,900 --> 00:48:26,320
我只想剥离左边的空间和空间

1021
00:48:26,320 --> 00:48:28,000
从用户输入的右侧 

1022
00:48:28,000 --> 00:48:29,210
但这还不够 

1023
00:48:29,210 --> 00:48:31,120
我想要记住 我已经脱下了

1024
00:48:31,120 --> 00:48:32,920
左边和右边的空白处 

1025
00:48:32,920 --> 00:48:35,470
所以我将在这里再次使用等号 

1026
00:48:35,470 --> 00:48:38,590
请注意 就像以前一样 这并不意味着平等 

1027
00:48:38,590 --> 00:48:40,940
这意味着从右到左进行分配 

1028
00:48:40,940 --> 00:48:43,900
所以当这里的这行代码--名称.条带--

1029
00:48:43,900 --> 00:48:46,600
回到我身边 也就是 

1030
00:48:46,600 --> 00:48:49,123
一个返回值 它将返回相同的东西

1031
00:48:49,123 --> 00:48:51,790
用户键入 但左侧不再有空格

1032
00:48:51,790 --> 00:48:54,370
或者是白色的[咯咯地笑]在右边 

1033
00:48:54,370 --> 00:48:56,860
所以等号赋值是这样的

1034
00:48:56,860 --> 00:49:00,190
要将该值从右侧复制到左侧 

1035
00:49:00,190 --> 00:49:04,820
从而更新My Name变量中的值 

1036
00:49:04,820 --> 00:49:07,240
所以你不仅可以给变量赋值 

1037
00:49:07,240 --> 00:49:10,300
你完全可以改变变量的值

1038
00:49:10,300 --> 00:49:12,817
通过使用赋值运算符 再次使用等号 

1039
00:49:12,817 --> 00:49:15,400
一次又一次 它会一直从右边复制

1040
00:49:15,400 --> 00:49:17,810
不管新值应该是多少 

1041
00:49:17,810 --> 00:49:23,740
所以现在如果我运行这个程序 Hello.py的Python 回车 

1042
00:49:23,740 --> 00:49:25,930
我有D-A-V-I--噢 我们再来一次 

1043
00:49:25,930 --> 00:49:29,170
空间 空间 d-a-v-i-d在所有的空间中 

1044
00:49:29,170 --> 00:49:30,760
空格 回车 

1045
00:49:30,760 --> 00:49:32,060
好多了

1046
00:49:32,060 --> 00:49:34,300
它还没有固定我的资本化 所以我仍然

1047
00:49:34,300 --> 00:49:38,050
第一个D有点马虎 但它已经剥离了

1048
00:49:38,050 --> 00:49:39,430
所有这些额外的空间 

1049
00:49:39,430 --> 00:49:41,170
很小的细节 对吧？

1050
00:49:41,170 --> 00:49:44,050
好像这并不那么令人兴奋 但是

1051
00:49:44,050 --> 00:49:47,440
这说明了你只用一行代码就能做什么 

1052
00:49:47,440 --> 00:49:49,160
我还能做什么

1053
00:49:49,160 --> 00:49:51,610
我可以把用户输入的信息大写 

1054
00:49:51,610 --> 00:49:53,390
我来试试这个 

1055
00:49:53,390 --> 00:49:59,810
我也可以这样做--name. capitalize 

1056
00:49:59,810 --> 00:50:03,420
所以让我把用户名大写 

1057
00:50:03,420 --> 00:50:05,170
再一次 我发表评论 

1058
00:50:05,170 --> 00:50:06,820
没有一个正确的方式来写评论 

1059
00:50:06,820 --> 00:50:08,770
我只是在这里用一些简短的英语短语

1060
00:50:08,770 --> 00:50:10,510
提醒自己我在做什么

1061
00:50:10,510 --> 00:50:12,190
这是怎么回事

1062
00:50:12,190 --> 00:50:15,310
让我继续运行Hello.py的Python 回车 

1063
00:50:15,310 --> 00:50:19,240
空间 d-a-v-i-d 空间 空间 输入 

1064
00:50:19,240 --> 00:50:19,960
好的.

1065
00:50:19,960 --> 00:50:21,580
现在看起来更漂亮了 对吧？

1066
00:50:21,580 --> 00:50:24,640
无论用户如何输入他们的名字 即使有点草率 

1067
00:50:24,640 --> 00:50:25,720
我正在修正 

1068
00:50:25,720 --> 00:50:27,313
但让我们试试别的 

1069
00:50:27,313 --> 00:50:28,730
我有点好奇了 

1070
00:50:28,730 --> 00:50:29,830
这个怎么样？

1071
00:50:29,830 --> 00:50:33,910
空间 d-a-v-i-d空间m-a-l-a-n--

1072
00:50:33,910 --> 00:50:35,530
我现在用我的姓

1073
00:50:35,530 --> 00:50:36,640
输入.

1074
00:50:36,640 --> 00:50:42,100
好吧 讽刺的是 “资本化”并不是真正的资本化我们想要的一切 

1075
00:50:42,100 --> 00:50:43,870
很明显资本化了什么？

1076
00:50:43,870 --> 00:50:45,580
只有第一封信 

1077
00:50:45,580 --> 00:50:48,940
结果是 Python中还有其他函数

1078
00:50:48,940 --> 00:50:49,960
有附带条件的

1079
00:50:49,960 --> 00:50:54,670
如果我们浏览文档 滚动浏览这样的URL 

1080
00:50:54,670 --> 00:50:58,540
我打赌我们会找到另一个解决方案 其中一个实际上就是这个 

1081
00:50:58,540 --> 00:51:01,180
让我们将其实际更改为标题 

1082
00:51:01,180 --> 00:51:03,550
还有另一个函数与字符串一起提供

1083
00:51:03,550 --> 00:51:07,120
被称为基于标题大写的标题 只是

1084
00:51:07,120 --> 00:51:09,310
像一本书或一个人的名字 大写

1085
00:51:09,310 --> 00:51:12,010
每个单词的第一个字母 

1086
00:51:12,010 --> 00:51:14,450
这将为我们做更多的工作 

1087
00:51:14,450 --> 00:51:15,880
所以让我们继续运行这个 

1088
00:51:15,880 --> 00:51:18,700
顺便说一句 我现在有点累了

1089
00:51:18,700 --> 00:51:22,130
一直在打字 一直在打字 

1090
00:51:22,130 --> 00:51:25,570
事实证明 当使用这样的命令行界面时 

1091
00:51:25,570 --> 00:51:28,000
实际上 您可以重新执行所有旧命令 

1092
00:51:28,000 --> 00:51:30,280
我刚才所做的就是我点击了向上箭头 

1093
00:51:30,280 --> 00:51:33,820
这会立即回顾我所有命令的历史记录

1094
00:51:33,820 --> 00:51:34,720
我打字最多的一次 

1095
00:51:34,720 --> 00:51:37,960
所以这是一种更快的方式让我再重复一遍

1096
00:51:37,960 --> 00:51:39,700
而不是手动输入所有内容 

1097
00:51:39,700 --> 00:51:42,850
让我继续按Enter 空格键 空格键 

1098
00:51:42,850 --> 00:51:47,110
D-a-v-i-d m-a-L-a-n空格 空格 全部小写 回车 

1099
00:51:47,110 --> 00:51:49,690
现在它看起来好多了 

1100
00:51:49,690 --> 00:51:52,030
现在我把东西都大写了 把东西都清理干净了 

1101
00:51:52,030 --> 00:51:53,200
但是我的代码呢？

1102
00:51:53,200 --> 00:51:55,930
我现在有八行代码 其中四行

1103
00:51:55,930 --> 00:51:58,030
是注释 其中四个是实际代码 

1104
00:51:58,030 --> 00:51:59,710
我真的需要这么多吗？

1105
00:51:59,710 --> 00:52:00,910
嗯 不一定 

1106
00:52:00,910 --> 00:52:03,520
看看我还能用Python语言做什么 

1107
00:52:03,520 --> 00:52:07,100
让我不必费心将用户名单独大写 

1108
00:52:07,100 --> 00:52:08,170
让我这么说吧--

1109
00:52:08,170 --> 00:52:12,970
并将用户名大写 

1110
00:52:12,970 --> 00:52:15,370
我可以将这些功能链接在一起 

1111
00:52:15,370 --> 00:52:18,130
我可以在这篇文章的末尾加上标题 

1112
00:52:18,130 --> 00:52:19,600
现在又是怎么回事？

1113
00:52:19,600 --> 00:52:21,440
再说一次 有这样一行代码 

1114
00:52:21,440 --> 00:52:24,490
你首先把注意力放在等号的右边 

1115
00:52:24,490 --> 00:52:26,470
然后我们就到等号的左边 

1116
00:52:26,470 --> 00:52:28,095
等号的右边是什么？

1117
00:52:28,095 --> 00:52:29,240
这条线在这里 

1118
00:52:29,240 --> 00:52:30,390
这是什么意思？

1119
00:52:30,390 --> 00:52:35,610
获取名称变量的值 如D-A-V-I-D空格M-A-L-A-N 

1120
00:52:35,610 --> 00:52:38,700
然后去掉左右两边的空白处 

1121
00:52:38,700 --> 00:52:40,920
这将返回一个值 

1122
00:52:40,920 --> 00:52:44,790
它将返回D-A-V-I-D空间M-A-L-A-N 不带任何空格

1123
00:52:44,790 --> 00:52:45,720
向左或向右 

1124
00:52:45,720 --> 00:52:47,940
您希望如何处理该返回值？

1125
00:52:47,940 --> 00:52:50,850
你想让它的标题大小写 也就是

1126
00:52:50,850 --> 00:52:54,330
检查结果字符串中的每个单词

1127
00:52:54,330 --> 00:52:57,000
并固定第一个单词的第一个字母 第一个字母

1128
00:52:57,000 --> 00:52:58,390
第二个词 以此类推 

1129
00:52:58,390 --> 00:53:00,330
然后--现在我们可以结束我们的想法了--

1130
00:53:00,330 --> 00:53:05,580
将整个代码从右向左复制到相同名称的变量中 

1131
00:53:05,580 --> 00:53:06,330
你知道吗？

1132
00:53:06,330 --> 00:53:08,340
我可以把这件事做得更进一步 

1133
00:53:08,340 --> 00:53:11,400
如果我们想的话 我们为什么不继续这样做呢？

1134
00:53:11,400 --> 00:53:16,890
让我摆脱所有这些 让我只做脱衣舞和标题

1135
00:53:16,890 --> 00:53:18,270
都在第一条线上 

1136
00:53:18,270 --> 00:53:21,380
现在我们已经从8行代码变成了4行代码 

1137
00:53:21,380 --> 00:53:22,740
它要紧得多 

1138
00:53:22,740 --> 00:53:23,880
这样整洁多了 

1139
00:53:23,880 --> 00:53:26,250
即使理性的人可能不同意 

1140
00:53:26,250 --> 00:53:30,090
可以说 它更好 因为它更容易阅读 

1141
00:53:30,090 --> 00:53:32,670
更少的代码行 更少的出错机会 

1142
00:53:32,670 --> 00:53:37,350
它只会让我继续处理我要解决的下一个问题 

1143
00:53:37,350 --> 00:53:41,730
好了 让我在这里暂停一下 看看是否有关于这些方法的问题 

1144
00:53:41,730 --> 00:53:45,540
方法是内置在一种值类型中的函数 

1145
00:53:45,540 --> 00:53:47,820
就像这些函数一样 

1146
00:53:47,820 --> 00:53:50,640
或者在我们刚才看到的F弦上 

1147
00:53:50,640 --> 00:53:51,390
观众：是的 嗨 

1148
00:53:51,390 --> 00:53:52,410
谢谢你 大卫 

1149
00:53:52,410 --> 00:53:56,190
那么有没有办法去掉空格之间的空格呢？

1150
00:53:56,190 --> 00:53:57,430
我可能会加进去的？

1151
00:53:57,430 --> 00:53:58,680
大卫·马兰：简单地说 没有 

1152
00:53:58,680 --> 00:54:01,060
如果您之前阅读了同一URL上的文档 

1153
00:54:01,060 --> 00:54:05,090
您将看到该条带从左侧和右侧移除 但不会从两者之间移除 

1154
00:54:05,090 --> 00:54:07,590
事实上 还有另外两个带有字符串的函数 

1155
00:54:07,590 --> 00:54:10,560
一条叫L条 一条叫R条 

1156
00:54:10,560 --> 00:54:12,378
这让你可以选择其中之一 

1157
00:54:12,378 --> 00:54:14,670
如果我们想要开始去除中间的空间 

1158
00:54:14,670 --> 00:54:17,760
我们将不得不玩一个完全不同的把戏 

1159
00:54:17,760 --> 00:54:22,380
观众：有多少函数可以像这样组合在一起 

1160
00:54:22,380 --> 00:54:23,160
加在一起 

1161
00:54:23,160 --> 00:54:24,930
那么我们可以合并多少个呢？

1162
00:54:24,930 --> 00:54:26,970
大卫·马兰：是的 这是一个非常好的问题 

1163
00:54:26,970 --> 00:54:30,177
从技术上讲 你想要多少就有多少 但到了某个时候

1164
00:54:30,177 --> 00:54:32,760
你的代码会开始看起来非常非常糟糕 对吗？

1165
00:54:32,760 --> 00:54:35,302
因为代码行会变得非常非常长 

1166
00:54:35,302 --> 00:54:38,130
它最终可能会一次又一次地缠绕在一起 

1167
00:54:38,130 --> 00:54:41,220
所以在某种程度上 你只是说 嗯-嗯 太多了 

1168
00:54:41,220 --> 00:54:44,340
然后你开始像我一样把它分成多行 

1169
00:54:44,340 --> 00:54:47,518
可能会根据需要将值重新赋值给变量 

1170
00:54:47,518 --> 00:54:49,060
这实际上是一个很好的问题 

1171
00:54:49,060 --> 00:54:52,830
如果我可以绕过你的问题 我是说 人们是怎么想的？

1172
00:54:52,830 --> 00:54:55,770
如果我们能继续把大家的手放下来一会儿 

1173
00:54:55,770 --> 00:54:57,690
让我问一下--

1174
00:54:57,690 --> 00:55:03,450
就是我现在做这件事的方式 用条幅、标题和输入

1175
00:55:03,450 --> 00:55:04,800
都在同一条线上--

1176
00:55:04,800 --> 00:55:07,290
比我以前的方法更好吗？

1177
00:55:07,290 --> 00:55:10,830
在缩放中 您可以使用是图标或否图标 

1178
00:55:10,830 --> 00:55:14,370
如果你认为这个版本更好 那就说是 

1179
00:55:14,370 --> 00:55:19,060
例如 如果你认为以前的版本更好 

1180
00:55:19,060 --> 00:55:23,310
在这里 我们所有的事情都爆发了 说不 

1181
00:55:23,310 --> 00:55:26,610
稍后我们再来看看原因 

1182
00:55:26,610 --> 00:55:30,000
我早些时候提出 理性的人可以持不同意见

1183
00:55:30,000 --> 00:55:32,730
这绝对是事实 

1184
00:55:32,730 --> 00:55:35,520
这样或那样做并不一定是最好的 

1185
00:55:35,520 --> 00:55:37,800
至少如果你能证明这一点的话 

1186
00:55:37,800 --> 00:55:41,280
让我回到这里的最新版本 

1187
00:55:41,280 --> 00:55:45,360
好的 我们看到了很多赞成者和反对者 

1188
00:55:45,360 --> 00:55:48,900
如果可以的话 我们何不去拜访其中一位赞成者呢？

1189
00:55:48,900 --> 00:55:52,710
投赞成票的人 为什么你认为这段代码的当前版本

1190
00:55:52,710 --> 00:55:57,330
真的比之前更长的代码版本更好吗？

1191
00:55:57,330 --> 00:55:59,110
观众：我觉得它的可读性更强 

1192
00:55:59,110 --> 00:56:03,030
所以我可以说 这就是名称变量 

1193
00:56:03,030 --> 00:56:07,360
它得到一些输入 然后删除空格并给它一个标题 

1194
00:56:07,360 --> 00:56:08,320
这就对了 

1195
00:56:08,320 --> 00:56:09,600
你有一个你好 名字 

1196
00:56:09,600 --> 00:56:10,860
大卫·马兰：是的 我认为这很合理 

1197
00:56:10,860 --> 00:56:12,660
它的可读性非常好 至少如果你有这个习惯的话 

1198
00:56:12,660 --> 00:56:14,660
就像你在英语里一样 从左到右阅读 

1199
00:56:14,660 --> 00:56:16,990
结果 它就像是一种非常自然的流动 

1200
00:56:16,990 --> 00:56:18,943
队伍并不是真的那么长 

1201
00:56:18,943 --> 00:56:20,860
当然 它非常适合屏幕 

1202
00:56:20,860 --> 00:56:21,870
所以我认为这是一个很好的论点 

1203
00:56:21,870 --> 00:56:23,310
不过 找个对立面怎么样？

1204
00:56:23,310 --> 00:56:27,810
投反对票的人 如果我们可以呼吁一个认为情况更糟的人 

1205
00:56:27,810 --> 00:56:31,410
观众：因为它根本读不懂 

1206
00:56:31,410 --> 00:56:37,300
好像排了很长的队 

1207
00:56:37,300 --> 00:56:39,170
所以我觉得还是分开比较好 

1208
00:56:39,170 --> 00:56:39,920
大卫·马兰：是的 

1209
00:56:39,920 --> 00:56:41,580
我觉得这也很有说服力 对吧？

1210
00:56:41,580 --> 00:56:43,050
它变得更长了一点 

1211
00:56:43,050 --> 00:56:46,890
尽管我在这里的句子--你的名字--相对较短 

1212
00:56:46,890 --> 00:56:49,530
你可以想象 这可能会很快变得更加丑陋

1213
00:56:49,530 --> 00:56:52,350
如果我问用户一个更长的问题 那就是

1214
00:56:52,350 --> 00:56:56,070
这会使这行代码更长 因此可读性更差 

1215
00:56:56,070 --> 00:56:59,970
对于我或我的同事来说 我可能不太清楚我正在打电话给Stand

1216
00:56:59,970 --> 00:57:01,530
也不知道我在叫什么头衔 

1217
00:57:01,530 --> 00:57:03,870
这可能是一种意想不到的惊喜 

1218
00:57:03,870 --> 00:57:05,460
所以我认为这也是合理的 

1219
00:57:05,460 --> 00:57:07,570
简而言之 这里没有正确的答案 

1220
00:57:07,570 --> 00:57:10,680
事实上 提高编程水平的过程的一部分

1221
00:57:10,680 --> 00:57:14,168
是获得自己的风格 还是为一家公司工作

1222
00:57:14,168 --> 00:57:16,710
在那里他们可能会指定哪种方法比另一种方法更好

1223
00:57:16,710 --> 00:57:18,930
因为他们只是想让每个人都做同样的事情 

1224
00:57:18,930 --> 00:57:22,080
即使通情达理的人可能不同意 

1225
00:57:22,080 --> 00:57:24,750
不过 最终 只要你拥有

1226
00:57:24,750 --> 00:57:28,710
支持一种或另一种方式的一个相当好的论点 比如最终 

1227
00:57:28,710 --> 00:57:29,820
这才是最重要的 

1228
00:57:29,820 --> 00:57:32,160
如果你只是因为你真的不知道哪一个更好而做事情 

1229
00:57:32,160 --> 00:57:33,180
这可不是什么好事 

1230
00:57:33,180 --> 00:57:35,460
但如果你开始收集意见

1231
00:57:35,460 --> 00:57:38,610
如果你的老板 你的老师 你的同事 你的朋友 

1232
00:57:38,610 --> 00:57:41,312
可以挑战你 说 等等 你为什么要这样做？

1233
00:57:41,312 --> 00:57:43,770
他们可能不同意你的观点 但至少有一个答案 

1234
00:57:43,770 --> 00:57:47,010
总的来说 这应该是足够有说服力的 

1235
00:57:47,010 --> 00:57:49,230
现在 字符串附带了一大堆其他方法

1236
00:57:49,230 --> 00:57:53,310
其中有一种叫做Split 顾名思义 它可以

1237
00:57:53,310 --> 00:57:57,030
可以这么说 将一个字符串拆分成多个更小的子字符串 

1238
00:57:57,030 --> 00:57:59,040
例如 如果这里的人有这样的习惯

1239
00:57:59,040 --> 00:58:02,130
输入他们的名字 然后是一个空格 然后是他们的姓氏 

1240
00:58:02,130 --> 00:58:05,070
你只想直接和他们打招呼 

1241
00:58:05,070 --> 00:58:07,140
我们实际上可以利用这个单一的空间

1242
00:58:07,140 --> 00:58:09,930
在名字和姓氏之间 并拆分该字符串

1243
00:58:09,930 --> 00:58:11,760
分成两个更小的子串 

1244
00:58:11,760 --> 00:58:12,820
我们怎么能做到这一点？

1245
00:58:12,820 --> 00:58:14,820
好吧 让我继续 在这些字里行间

1246
00:58:14,820 --> 00:58:18,210
主动评论我们即将拆分用户的

1247
00:58:18,210 --> 00:58:22,230
将名字转换为名字和姓氏 

1248
00:58:22,230 --> 00:58:25,920
然后让我们继续获取这个名称变量 它当前包含

1249
00:58:25,920 --> 00:58:28,590
大概是大卫 太空 马兰 

1250
00:58:28,590 --> 00:58:32,130
让我继续调用Split并作为参数传入

1251
00:58:32,130 --> 00:58:35,820
分隔单个空格 从而表明我确实

1252
00:58:35,820 --> 00:58:37,750
我想在那个角色上分道扬镳

1253
00:58:37,750 --> 00:58:41,363
现在 Split将返回一个值序列 理想情况下

1254
00:58:41,363 --> 00:58:42,780
先是名 然后是姓 

1255
00:58:42,780 --> 00:58:45,330
实际上 在Python中 我们可以为这两个值赋值

1256
00:58:45,330 --> 00:58:47,940
从这个序列一次转换到一些变量 

1257
00:58:47,940 --> 00:58:51,360
例如 第一个逗号最后一个等于 那就是

1258
00:58:51,360 --> 00:58:53,220
会产生从右到左的效果

1259
00:58:53,220 --> 00:58:56,760
将第一个这样的值放入第一个变量 第二个这样的值

1260
00:58:56,760 --> 00:58:57,880
在第二个变量中 

1261
00:58:57,880 --> 00:59:01,350
现在 在我的最后一行代码中 我可以进去打招呼了

1262
00:59:01,350 --> 00:59:03,900
不是全名 比如大卫·马兰 

1263
00:59:03,900 --> 00:59:06,540
我可以先打个招呼 

1264
00:59:06,540 --> 00:59:10,200
好的 让我们继续清除我的终端窗口 运行Hello.py的Python

1265
00:59:10,200 --> 00:59:10,807
然后按Enter键 

1266
00:59:10,807 --> 00:59:13,890
这一次我不会费心使用任何前导空格 但让我继续

1267
00:59:13,890 --> 00:59:19,290
然后输入David空格Malan 像往常一样交叉手指 你好 

1268
00:59:19,290 --> 00:59:21,720
大卫就是我们现在所看到的 

1269
00:59:21,720 --> 00:59:25,530
好的 到目前为止 我们已经看到了很多例子 其中包括

1270
00:59:25,530 --> 00:59:29,430
字符串 但程序和编程语言肯定可以

1271
00:59:29,430 --> 00:59:32,080
也可以操纵其他类型的数据 

1272
00:59:32,080 --> 00:59:36,000
让我们继续 然后转换到另一种非常常见的数据类型

1273
00:59:36,000 --> 00:59:38,610
在Python语言中 在更一般的编程中 即

1274
00:59:38,610 --> 00:59:41,160
整数 在Python语言中也称为int--

1275
00:59:41,160 --> 00:59:46,080
I-N-T因此 就像STR一样 S-T-R是字符串的缩写 在Python语言中也是int的缩写

1276
00:59:46,080 --> 00:59:47,210
整数的缩写 

1277
00:59:47,210 --> 00:59:48,210
那么 整数是什么？

1278
00:59:48,210 --> 00:59:51,390
就像在数学中一样 它是一个负2这样的数字 

1279
00:59:51,390 --> 00:59:55,605
负1 0 1 2 一直到负无穷大 全部

1280
00:59:55,605 --> 00:59:56,980
通向正无穷大的道路 

1281
00:59:56,980 --> 00:59:59,040
但是整数里没有小数点 

1282
00:59:59,040 --> 01:00:04,260
它只是一个数字 像负2 负1 0 1和2 

1283
01:00:04,260 --> 01:00:05,160
这是一个整型 

1284
01:00:05,160 --> 01:00:09,360
当然 在数学世界里 我们使用了很多符号 

1285
01:00:09,360 --> 01:00:12,300
我们以前见过+ 尽管我们把它用在了不同的目的上 

1286
01:00:12,300 --> 01:00:15,030
但Python支持这些符号以及更多符号 

1287
01:00:15,030 --> 01:00:18,090
而Python允许你把数字加在一起+ 

1288
01:00:18,090 --> 01:00:21,580
减数、乘数、除数 

1289
01:00:21,580 --> 01:00:25,380
这里唯一一个对人们来说可能有点陌生或陌生的

1290
01:00:25,380 --> 01:00:29,310
这是百分比符号 但在这种情况下 它并不意味着百分比 

1291
01:00:29,310 --> 01:00:32,400
如果您在Python程序中使用单个百分号 

1292
01:00:32,400 --> 01:00:34,680
这实际上就是所谓的模运算符 

1293
01:00:34,680 --> 01:00:38,400
允许您在除法后取余数的运算符

1294
01:00:38,400 --> 01:00:40,210
一个数字接一个数字 

1295
01:00:40,210 --> 01:00:43,230
我们很快就会看到这样的例子 但前四个例子

1296
01:00:43,230 --> 01:00:45,570
可能是非常非常熟悉的 

1297
01:00:45,570 --> 01:00:49,240
事实证明 在Python中 你不一定--

1298
01:00:49,240 --> 01:00:54,480
您不必一直在像Hello.py这样的文件中编写代码

1299
01:00:54,480 --> 01:00:56,700
然后在终端窗口中运行它 

1300
01:00:56,700 --> 01:00:59,610
许多人喜欢的关于Python的功能之一

1301
01:00:59,610 --> 01:01:02,250
就是它支持这种所谓的互动模式 

1302
01:01:02,250 --> 01:01:06,240
就像您可以开始编写Python代码并立即执行

1303
01:01:06,240 --> 01:01:08,965
其中的每一行都是交互的 尤其是

1304
01:01:08,965 --> 01:01:11,340
如果您不关心保存所有代码行的话 

1305
01:01:11,340 --> 01:01:14,590
您只想执行代码并返回一些答案 

1306
01:01:14,590 --> 01:01:18,400
例如 让我回到这里的VS代码 并关闭Hello.py

1307
01:01:18,400 --> 01:01:22,050
让我点击终端窗口中的小三角形

1308
01:01:22,050 --> 01:01:24,880
让它变得更大 只是暂时的 

1309
01:01:24,880 --> 01:01:30,450
因此 我现在不会创建任何.py文件 我只会单独运行Python

1310
01:01:30,450 --> 01:01:31,410
在我的提示下 

1311
01:01:31,410 --> 01:01:35,100
你们会看到 当我这样做的时候 我得到了一些看起来很神秘的输出

1312
01:01:35,100 --> 01:01:38,890
以及程序最后更新的日期和时间等 

1313
01:01:38,890 --> 01:01:43,710
但我最终得到了三个像这样的三重括号 

1314
01:01:43,710 --> 01:01:46,740
是Python的交互模式 

1315
01:01:46,740 --> 01:01:52,050
所以我运行的是Python解释器 任何时候我输入一行代码

1316
01:01:52,050 --> 01:01:54,570
在解释器中 它将立即执行它 

1317
01:01:54,570 --> 01:01:56,942
我不必一次又一次地运行Python 

1318
01:01:56,942 --> 01:01:58,650
这就好像在人类世界里 如果你

1319
01:01:58,650 --> 01:02:01,635
站在一个会说其他语言的人旁边 

1320
01:02:01,635 --> 01:02:04,260
而你只是在和他们来回交谈 

1321
01:02:04,260 --> 01:02:07,030
这一切都发生了--翻译过来--立刻 

1322
01:02:07,030 --> 01:02:08,940
那么 在交互模式下我可以做什么呢？

1323
01:02:08,940 --> 01:02:11,760
嗯 我可以做一些类似1+1的动作 进入 

1324
01:02:11,760 --> 01:02:13,380
那其实是暗号 好吗？

1325
01:02:13,380 --> 01:02:16,590
您可能不会认为它是代码 但如果有一点算术和您的

1326
01:02:16,590 --> 01:02:21,060
知道数字 你知道+ 这是有效的Python代码 

1327
01:02:21,060 --> 01:02:23,537
你可以把Python当做一个奇特的计算器来使用 

1328
01:02:23,537 --> 01:02:24,870
但我也可以做其他的事情 

1329
01:02:24,870 --> 01:02:28,020
如果我想打印给我自己你好 世界 

1330
01:02:28,020 --> 01:02:30,750
我也可以在那里打印出那一行代码--

1331
01:02:30,750 --> 01:02:31,530
你好 世界 

1332
01:02:31,530 --> 01:02:33,600
所以它是互动的 从这个意义上说 

1333
01:02:33,600 --> 01:02:36,960
你执行一行代码 砰的一声 你就会看到结果 

1334
01:02:36,960 --> 01:02:39,450
我们通常不会这样做 因为至少当

1335
01:02:39,450 --> 01:02:42,810
教授语言时 我们倾向于循序渐进地做事情

1336
01:02:42,810 --> 01:02:45,513
我们希望你们能够看到我们来自哪里 

1337
01:02:45,513 --> 01:02:48,180
我们希望能够一次又一次地尝试 特别是

1338
01:02:48,180 --> 01:02:49,140
如果我们犯了错误 

1339
01:02:49,140 --> 01:02:51,690
但要知道 这确实是Python的一个功能 

1340
01:02:51,690 --> 01:02:54,250
这种所谓的互动模式 

1341
01:02:54,250 --> 01:02:57,015
但现在让我们关注一下 不仅仅是这种互动 

1342
01:02:57,015 --> 01:02:58,890
但真正基于这样一个事实 Python显然

1343
01:02:58,890 --> 01:03:03,310
支持整数、数学和其中一些基本运算 

1344
01:03:03,310 --> 01:03:06,430
让我们看看我们是不是不能做我们自己的小计算器 

1345
01:03:06,430 --> 01:03:08,820
所以让我继续 再次打开VS代码 

1346
01:03:08,820 --> 01:03:11,440
我要缩小我的终端窗口 

1347
01:03:11,440 --> 01:03:14,610
我将创建一个名为Calculator.py的新文件 

1348
01:03:14,610 --> 01:03:17,950
因此 要进行回调 我可以在下面输入Code 

1349
01:03:17,950 --> 01:03:21,540
和我想要创建的文件的名称.py 输入 

1350
01:03:21,540 --> 01:03:23,550
这给了我一个新的顶端标签 

1351
01:03:23,550 --> 01:03:25,620
所以我已经关闭了Hello.py 

1352
01:03:25,620 --> 01:03:27,150
我现在在Calculator.py中 

1353
01:03:27,150 --> 01:03:30,900
让我们做一个简单的计算器 为我做一些加法 

1354
01:03:30,900 --> 01:03:33,690
但我将在一个文件中这样做 这样我们就可以对此进行迭代

1355
01:03:33,690 --> 01:03:36,607
并随着时间的推移做出改变 无论是好是坏 

1356
01:03:36,607 --> 01:03:38,940
让我继续 首先声明几个变量 

1357
01:03:38,940 --> 01:03:42,840
我要做一个数学运算 把我的第一个变量命名为x 

1358
01:03:42,840 --> 01:03:45,840
我的第二个变量y 然后我要给自己

1359
01:03:45,840 --> 01:03:48,720
第三个变量z=x+y 

1360
01:03:48,720 --> 01:03:50,970
然后我将继续打印z 

1361
01:03:50,970 --> 01:03:54,858
现在这个节目 诚然不是很令人兴奋或有趣 

1362
01:03:54,858 --> 01:03:57,900
事实上 它没有在屏幕上打印东西那么有趣

1363
01:03:57,900 --> 01:04:01,110
就像以前使用字符串一样 但我们将在此基础上进行构建

1364
01:04:01,110 --> 01:04:04,030
看看我们还可以利用在Python中的哪些其他特性 

1365
01:04:04,030 --> 01:04:07,410
所以希望 如果Python像我一样知道这是数学问题 

1366
01:04:07,410 --> 01:04:13,140
当我运行Calculator.py的Python时 我应该希望看到1+2

1367
01:04:13,140 --> 01:04:15,600
=确实是3 

1368
01:04:15,600 --> 01:04:18,510
好吧 所以并不令人惊讶 也不是那么有趣 

1369
01:04:18,510 --> 01:04:20,730
老实说 这不是最有用的程序

1370
01:04:20,730 --> 01:04:24,840
因为它总是要计算1+2=3 

1371
01:04:24,840 --> 01:04:28,170
让我们至少让这个节目 比如说 更具互动性 对吗？

1372
01:04:28,170 --> 01:04:31,590
我们已经从前面的例子中知道了如何从用户那里获得输入 

1373
01:04:31,590 --> 01:04:33,540
让我们恢复输入函数 

1374
01:04:33,540 --> 01:04:37,380
让我们这样做 让我现在继续 在我的代码的顶部 

1375
01:04:37,380 --> 01:04:40,650
让我们将x更改为不总是数字1 

1376
01:04:40,650 --> 01:04:42,510
让我们把它改成任何回报

1377
01:04:42,510 --> 01:04:45,690
价值在于向用户索要x 

1378
01:04:45,690 --> 01:04:48,730
我可以在这里使用任何我想要的英语或人类语言 

1379
01:04:48,730 --> 01:04:49,890
我要说 x是什么？

1380
01:04:49,890 --> 01:04:52,410
就像我之前问的 你叫什么名字？

1381
01:04:52,410 --> 01:04:54,180
我也会为y做同样的事情 

1382
01:04:54,180 --> 01:04:57,330
我将再次使用输入 但这一次将问题改为 

1383
01:04:57,330 --> 01:04:58,728
你是什么？

1384
01:04:58,728 --> 01:05:01,770
好了 在这一点上 我想我将把剩下的代码

1385
01:05:01,770 --> 01:05:02,730
一样的 

1386
01:05:02,730 --> 01:05:06,450
Z=x+y 然后打印z 但什么是好的

1387
01:05:06,450 --> 01:05:10,140
现在我想我有了一个很好的交互式计算器 

1388
01:05:10,140 --> 01:05:12,510
好的 现在它不会一直做1+2 

1389
01:05:12,510 --> 01:05:16,330
它将执行用户输入的任何内容+用户输入的任何内容 

1390
01:05:16,330 --> 01:05:17,530
那么让我们来试试这个 

1391
01:05:17,530 --> 01:05:19,080
让我继续运行这个程序 

1392
01:05:19,080 --> 01:05:20,110
好了 我们开始吧 

1393
01:05:20,110 --> 01:05:26,670
1将是x 2将是y 当然 所有同意的人 1

1394
01:05:26,670 --> 01:05:30,762
+2=Thr--

1395
01:05:30,762 --> 01:05:31,980
哈 

1396
01:05:31,980 --> 01:05:36,040
那是怎么回事？

1397
01:05:36,040 --> 01:05:40,720
不是你的数学课误导了你 就是我误导了你 

1398
01:05:40,720 --> 01:05:43,000
我们为什么不叫个人来看看你是否

1399
01:05:43,000 --> 01:05:46,900
不能帮助我们推断错误是什么 错误在哪里？

1400
01:05:46,900 --> 01:05:48,970
安加利 如果我没说错的话 

1401
01:05:48,970 --> 01:05:52,960
观众：我认为问题在于它连接了字符串 因为你

1402
01:05:52,960 --> 01:05:54,935
使用+运算符 而不是加法 

1403
01:05:54,935 --> 01:05:55,810
大卫·马兰：太好了 

1404
01:05:55,810 --> 01:05:57,040
如此完美的直觉 

1405
01:05:57,040 --> 01:06:01,060
我们已经看到+在字符串上下文中的用法略有不同

1406
01:06:01,060 --> 01:06:03,940
因为它连接 也就是连接两个字符串 

1407
01:06:03,940 --> 01:06:06,100
这似乎确实是这里正在发生的事情 

1408
01:06:06,100 --> 01:06:07,990
即使用户输入了数字 

1409
01:06:07,990 --> 01:06:09,910
但有趣的是 

1410
01:06:09,910 --> 01:06:13,660
你得到用户输入 因为他们在Mac上使用键盘

1411
01:06:13,660 --> 01:06:16,900
或者电脑或者手机 都是短信

1412
01:06:16,900 --> 01:06:19,030
它可能看起来像一个数字 但默认情况下 

1413
01:06:19,030 --> 01:06:21,850
从键盘上传来的字符串

1414
01:06:21,850 --> 01:06:23,560
即作为文本 

1415
01:06:23,560 --> 01:06:27,760
那么 如果我们最终

1416
01:06:27,760 --> 01:06:30,190
我不想把这些输入当作字符串 

1417
01:06:30,190 --> 01:06:32,110
我们要把它们当作真实的数字吗

1418
01:06:32,110 --> 01:06:35,050
我们需要另一个函数 在Python中

1419
01:06:35,050 --> 01:06:39,610
有时候你可以把一种数据转换成另一种数据 

1420
01:06:39,610 --> 01:06:43,880
例如 从字符串到INT 通过这样做 

1421
01:06:43,880 --> 01:06:46,690
让我回到我的代码 让我改变

1422
01:06:46,690 --> 01:06:51,730
在把它加到y之前 

1423
01:06:51,730 --> 01:06:56,030
是 +不管y的整数形式是什么 

1424
01:06:56,030 --> 01:06:59,950
因此 INT不仅是Python中的一种数据类型 

1425
01:06:59,950 --> 01:07:02,590
它也是一个函数 

1426
01:07:02,590 --> 01:07:05,410
如果你传入一个输入 比如一个字符串 

1427
01:07:05,410 --> 01:07:09,790
只要这个字符串看起来像1或2这样的数字 

1428
01:07:09,790 --> 01:07:13,450
它会把它转换成一个实际的数字 

1429
01:07:13,450 --> 01:07:14,510
而不是 

1430
01:07:14,510 --> 01:07:18,340
如果我现在回到终端窗口运行Python

1431
01:07:18,340 --> 01:07:19,870
我再给你看一个小把戏

1432
01:07:19,870 --> 01:07:21,580
“计算器”这个词有点长

1433
01:07:21,580 --> 01:07:22,930
打字有点乏味 

1434
01:07:22,930 --> 01:07:26,470
注意我可以在终端窗口的命令行中做什么

1435
01:07:26,470 --> 01:07:27,460
接口一般 

1436
01:07:27,460 --> 01:07:31,300
如果我开始输入C-A-L作为计算器 

1437
01:07:31,300 --> 01:07:33,700
按Tab完成我的想法 

1438
01:07:33,700 --> 01:07:36,550
所以在这样的终端窗口中自动完成是可能的 

1439
01:07:36,550 --> 01:07:39,663
输入第一个字母或几个字母 然后 砰 与标签 

1440
01:07:39,663 --> 01:07:41,080
它会帮你完成你的想法

1441
01:07:41,080 --> 01:07:44,770
或者你可以像我用上下箭头那样回到你的历史中 

1442
01:07:44,770 --> 01:07:46,570
让我继续执行这个 

1443
01:07:46,570 --> 01:07:47,270
什么是X？

1444
01:07:47,270 --> 01:07:47,770
1.

1445
01:07:47,770 --> 01:07:48,290
什么是X？

1446
01:07:48,290 --> 01:07:48,790
2.

1447
01:07:48,790 --> 01:07:49,880
好了

1448
01:07:49,880 --> 01:07:53,050
现在我们有了一个通用计算器 

1449
01:07:53,050 --> 01:07:57,280
不只是1和2的加法 而是任意两个

1450
01:07:57,280 --> 01:07:58,882
用户键入的整数 

1451
01:07:58,882 --> 01:08:00,340
现在让我来改进一下 好吗？

1452
01:08:00,340 --> 01:08:03,190
我们已经了解了如何改进代码

1453
01:08:03,190 --> 01:08:05,650
我不知道这是否一定会更好 

1454
01:08:05,650 --> 01:08:07,000
但让我们来试试这个 

1455
01:08:07,000 --> 01:08:09,730
我真的需要z变量吗？

1456
01:08:09,730 --> 01:08:13,630
值得注意的是 我正在创建一个名为z的变量 

1457
01:08:13,630 --> 01:08:16,720
然后我立即在下一行代码中使用它 

1458
01:08:16,720 --> 01:08:20,770
这并不是很有说服力 因为如果你要创建一个变量

1459
01:08:20,770 --> 01:08:23,470
然后立即使用它 但永远不会再使用它 

1460
01:08:23,470 --> 01:08:26,890
你真的需要花时间介绍另一个符号吗？

1461
01:08:26,890 --> 01:08:30,279
和另一个变量 只使用一次 只使用一次？

1462
01:08:30,279 --> 01:08:31,090
嗯 也许不是 

1463
01:08:31,090 --> 01:08:33,729
也许我们在这种情况下并不真正需要z 

1464
01:08:33,729 --> 01:08:38,319
也许我应该去做一些这样的事情 

1465
01:08:38,319 --> 01:08:41,140
也许我应该在这里除掉z 

1466
01:08:41,140 --> 01:08:45,729
也许我应该把这个改成INT 换掉

1467
01:08:45,729 --> 01:08:50,260
这是在这里 做了一些现在很有趣的事情 

1468
01:08:50,260 --> 01:08:53,680
尽管这是一种新的语法 但请注意

1469
01:08:53,680 --> 01:08:56,380
可以说 可以嵌套函数 

1470
01:08:56,380 --> 01:09:01,330
您可以将一个函数调用放入一个函数的使用

1471
01:09:01,330 --> 01:09:04,540
在内部使用另一个函数 以便返回

1472
01:09:04,540 --> 01:09:09,040
内部函数的值将成为

1473
01:09:09,040 --> 01:09:11,410
或外部函数的输入 

1474
01:09:11,410 --> 01:09:14,510
就像在数学中 如果你有圆括号 

1475
01:09:14,510 --> 01:09:16,218
你的老师可能教你要集中注意力

1476
01:09:16,218 --> 01:09:18,430
先看看最里面的圆括号里有什么

1477
01:09:18,430 --> 01:09:19,603
然后自己想办法脱身 

1478
01:09:19,603 --> 01:09:20,770
编程也是如此 

1479
01:09:20,770 --> 01:09:22,040
这就是Python要做的事情 

1480
01:09:22,040 --> 01:09:24,729
它将首先查看括号内的内容 

1481
01:09:24,729 --> 01:09:26,920
它会得到答案 然后它就会

1482
01:09:26,920 --> 01:09:30,710
将返回值传递给最外层的函数 

1483
01:09:30,710 --> 01:09:34,600
所以现在在第1行发生的事情是 输入函数首先被调用 

1484
01:09:34,600 --> 01:09:37,990
然后 结果是 引用不引用的一

1485
01:09:37,990 --> 01:09:42,670
成为int函数的输入 在第2行上也是如此 

1486
01:09:42,670 --> 01:09:47,300
Y的输出变成了这个int函数的输入 

1487
01:09:47,300 --> 01:09:49,479
现在没有z了 

1488
01:09:49,479 --> 01:09:52,210
我可以只打印x+y 

1489
01:09:52,210 --> 01:09:56,410
因为我花了时间把每一个字符串

1490
01:09:56,410 --> 01:09:58,720
到了一个整数 我想我们就可以了 

1491
01:09:58,720 --> 01:10:01,570
让我试一试 Calculator.py的Python 回车 

1492
01:10:01,570 --> 01:10:05,170
1和2 而我们仍然得到3 

1493
01:10:05,170 --> 01:10:09,130
不是12 或者不是12 1 2 我们确实得到了3 

1494
01:10:09,130 --> 01:10:11,350
我们还去掉了变量

1495
01:10:11,350 --> 01:10:13,900
因为我们似乎不一定需要它 

1496
01:10:13,900 --> 01:10:15,490
尤其是如果只用一次的话 

1497
01:10:15,490 --> 01:10:18,280
好吧 在这里也是 让我把每个人的手放下来一会儿

1498
01:10:18,280 --> 01:10:19,930
让我一如既往地问--

1499
01:10:19,930 --> 01:10:26,530
这个版本现在在输入的调用周围使用int 

1500
01:10:26,530 --> 01:10:30,640
并且没有使用z 这比以前的版本更好吗？

1501
01:10:30,640 --> 01:10:32,560
如果你想投赞成票 那就投赞成票 

1502
01:10:32,560 --> 01:10:35,270
或者 如果你更喜欢旧的方式 投反对票 

1503
01:10:35,270 --> 01:10:40,455
原来的方式是 我会在投票时取消这一切 而不是像这样 

1504
01:10:43,510 --> 01:10:45,850
好的 现在让我回到最新的版本 

1505
01:10:45,850 --> 01:10:48,040
让我们握住赞成者的手 这个人

1506
01:10:48,040 --> 01:10:51,430
认为这个最新版本更好 

1507
01:10:51,430 --> 01:10:57,130
观众：我认为这种方式更好 因为它可以让我们立即看到

1508
01:10:57,130 --> 01:11:01,840
对于整数 x和y变量是什么

1509
01:11:01,840 --> 01:11:04,660
因此 我们知道应该从他们那里得到什么 

1510
01:11:04,660 --> 01:11:09,250
而且 印刷品的论点也更直观 

1511
01:11:09,250 --> 01:11:12,330
我们避免了代码中的太多混乱 

1512
01:11:12,330 --> 01:11:14,330
大卫·马兰：我认为这些都是很好的理由 

1513
01:11:14,330 --> 01:11:15,370
它很好 也很简洁 

1514
01:11:15,370 --> 01:11:17,650
代码行不是很长 

1515
01:11:17,650 --> 01:11:20,530
我不需要知道z是什么 因为它不存在 

1516
01:11:20,530 --> 01:11:21,820
它只看到打印x+y 

1517
01:11:21,820 --> 01:11:22,390
我喜欢那样 

1518
01:11:22,390 --> 01:11:25,990
但有人更喜欢老式的方式 我们确实有z

1519
01:11:25,990 --> 01:11:30,970
并且我们更显式地将单个变量传递给int函数 

1520
01:11:30,970 --> 01:11:32,050
观众：是的 嗨 

1521
01:11:32,050 --> 01:11:36,100
我认为较早的版本更好 因为当--

1522
01:11:36,100 --> 01:11:39,370
我的意思是 如果用户输入的内容不是 

1523
01:11:39,370 --> 01:11:43,570
比方说 我是说 比方说 他们输入1和2 

1524
01:11:43,570 --> 01:11:46,780
因此 它将更容易调试 

1525
01:11:46,780 --> 01:11:49,807
大卫·马兰：这个版本还是--这里的这个版本还是旧的版本？

1526
01:11:49,807 --> 01:11:50,890
观众：老版本 

1527
01:11:50,890 --> 01:11:52,098
大卫·马兰：好的 这很公平 

1528
01:11:52,098 --> 01:11:57,190
事实上 我今天非常小心 尽我所能 不要搞砸了 

1529
01:11:57,190 --> 01:12:01,050
到目前为止 我只输入整数 当我期待整数 

1530
01:12:01,050 --> 01:12:02,800
拉乌尔实际上在指着什么东西

1531
01:12:02,800 --> 01:12:05,980
我们会在接下来的几周里继续讨论 我们实际上是如何处理错误的？

1532
01:12:05,980 --> 01:12:09,770
如果用户没有输入数字1或数字2 

1533
01:12:09,770 --> 01:12:10,270
一点都不吗

1534
01:12:10,270 --> 01:12:13,390
如果他们输入一个词 如猫 C-A-T？

1535
01:12:13,390 --> 01:12:16,150
这不是一个数字 我打赌我不能把它转换成整数 

1536
01:12:16,150 --> 01:12:18,110
但今天 我不会把重点放在这上面 

1537
01:12:18,110 --> 01:12:20,110
我只希望用户能合作 

1538
01:12:20,110 --> 01:12:21,740
但事实并非如此 

1539
01:12:21,740 --> 01:12:24,280
所以也许有一种方法可以让我们取得更大的成功

1540
01:12:24,280 --> 01:12:26,020
当涉及到处理这些错误 

1541
01:12:26,020 --> 01:12:28,495
就今天的目的而言 哪一个更好？

1542
01:12:28,495 --> 01:12:29,650
呃 我是说 我两个都喜欢 

1543
01:12:29,650 --> 01:12:32,440
我认为你们两个都提出了非常有效的论点 

1544
01:12:32,440 --> 01:12:36,250
只要你有合理的理由

1545
01:12:36,250 --> 01:12:37,930
我是说 这才是最重要的 

1546
01:12:37,930 --> 01:12:41,500
但是 再次获得一种权衡的感觉 

1547
01:12:41,500 --> 01:12:43,180
这样好点吗

1548
01:12:43,180 --> 01:12:44,885
如果是 原因是什么？

1549
01:12:44,885 --> 01:12:46,760
只是了解这些权衡是什么 

1550
01:12:46,760 --> 01:12:51,460
但总的来说 优先考虑可读性是一件非常好的事情 

1551
01:12:51,460 --> 01:12:54,740
让你的代码对其他人可读是一件非常好的事情

1552
01:12:54,740 --> 01:12:57,608
对你也有好处 所以当你第二天早上醒来时 

1553
01:12:57,608 --> 01:12:59,650
或者下周或者明年再来

1554
01:12:59,650 --> 01:13:02,290
你也可以读你自己的代码 而不必浪费

1555
01:13:02,290 --> 01:13:04,270
花时间回忆你做了什么

1556
01:13:04,270 --> 01:13:08,500
而且简单往往也是一件好事--保持代码简单 

1557
01:13:08,500 --> 01:13:10,960
所以当你对编程越来越熟悉的时候 

1558
01:13:10,960 --> 01:13:15,250
您可能会尝试将整个程序合并为一个长行 

1559
01:13:15,250 --> 01:13:17,740
例如 让我来做这个 

1560
01:13:17,740 --> 01:13:20,680
从技术上讲 我们并不需要变量中的x 

1561
01:13:20,680 --> 01:13:22,480
我们不需要变量中的y 

1562
01:13:22,480 --> 01:13:24,460
我们也可以这样做

1563
01:13:24,460 --> 01:13:27,820
我可以把x和y一起去掉 

1564
01:13:27,820 --> 01:13:32,080
然后 我现在可以去掉它 使其只有一行代码 

1565
01:13:32,080 --> 01:13:34,510
好的 所以在某种意义上 你可能会想 哇 

1566
01:13:34,510 --> 01:13:35,740
真是太好了 

1567
01:13:35,740 --> 01:13:38,410
你让它变成了一行简单的代码 

1568
01:13:38,410 --> 01:13:40,520
我会争辩说 这实际上并没有那么简单 

1569
01:13:40,520 --> 01:13:43,180
现在我想我开始筑巢太多东西了 

1570
01:13:43,180 --> 01:13:46,330
我必须考虑打印、int和输入 

1571
01:13:46,330 --> 01:13:49,150
然后我必须注意到 好的 我打开了两个括号 

1572
01:13:49,150 --> 01:13:50,300
我已经关闭了其中两家 

1573
01:13:50,300 --> 01:13:51,040
有一个+ 

1574
01:13:51,040 --> 01:13:53,680
你让我想得太多了 任何时候你让我想 

1575
01:13:53,680 --> 01:13:54,730
你在浪费时间 

1576
01:13:54,730 --> 01:13:58,360
任何时候 当你把代码的外观复杂化时 

1577
01:13:58,360 --> 01:14:01,300
你只会增加犯错的可能性

1578
01:14:01,300 --> 01:14:04,270
以及代码中的战术错误或逻辑错误 

1579
01:14:04,270 --> 01:14:07,810
因此 如果我们所做的所有事情 这是我唯一要争辩的 

1580
01:14:07,810 --> 01:14:10,870
是的 只有一条线路 又漂亮又紧凑 

1581
01:14:10,870 --> 01:14:12,340
它只是可读性不够 

1582
01:14:12,340 --> 01:14:15,850
我会避免这样做 特别是因为其中两个函数

1583
01:14:15,850 --> 01:14:18,040
呼叫正在从用户处获得输入 

1584
01:14:18,040 --> 01:14:20,410
但在那里 理性的人可能不会同意 

1585
01:14:20,410 --> 01:14:23,830
但这是一种你有时应该有的本能反应

1586
01:14:23,830 --> 01:14:28,300
代码开始变得有点太复杂 有点太聪明 

1587
01:14:28,300 --> 01:14:31,450
也许 这是为了它的利益 

1588
01:14:31,450 --> 01:14:34,270
好吧 我们不只是能接触到整数 

1589
01:14:34,270 --> 01:14:38,920
让我建议在这里将整数转换为另一种数据类型 

1590
01:14:38,920 --> 01:14:40,360
也就是浮点 

1591
01:14:40,360 --> 01:14:43,390
同样 字符串是一系列文本 

1592
01:14:43,390 --> 01:14:46,570
整数是像负1、0和1一样的整数 

1593
01:14:46,570 --> 01:14:50,860
浮点数是一个带有小数点的数字 恰当地称为浮点数

1594
01:14:50,860 --> 01:14:51,470
价值 

1595
01:14:51,470 --> 01:14:53,470
你可以把浮点数想象成

1596
01:14:53,470 --> 01:14:56,740
可能在这里或这里的小数位数

1597
01:14:56,740 --> 01:14:57,820
向左或向右 

1598
01:14:57,820 --> 01:15:02,000
从数学上讲 它是一个实数 一个有小数点的数字 

1599
01:15:02,000 --> 01:15:04,750
这是第三种类型的数据 也就是Python支持的数据 

1600
01:15:04,750 --> 01:15:07,270
现在我们的计算器有点幼稚

1601
01:15:07,270 --> 01:15:09,820
假设用户仅要键入整数 

1602
01:15:09,820 --> 01:15:12,970
但如果我也想支持浮点值 

1603
01:15:12,970 --> 01:15:15,070
我想我可以做几个小调整 

1604
01:15:15,070 --> 01:15:17,270
所以我要回到VS代码这一点 

1605
01:15:17,270 --> 01:15:20,890
并且不是仅仅将用户的输入x和y转换为

1606
01:15:20,890 --> 01:15:23,950
第一行和第二行的整数 让我们做一个简单的更改 

1607
01:15:23,950 --> 01:15:27,400
让我们将其实际转换为第一行的浮点数

1608
01:15:27,400 --> 01:15:30,640
在这里的第二行有一个花车 

1609
01:15:30,640 --> 01:15:35,410
现在我想 如果我下到我的终端窗口并运行Calculator.py的Python 

1610
01:15:35,410 --> 01:15:39,040
让我们输入一个带小数点的数字 比如1.2

1611
01:15:39,040 --> 01:15:42,100
加上一个小数点的3.4 我们就开始了 

1612
01:15:42,100 --> 01:15:44,510
我们的最终答案是4.6 

1613
01:15:44,510 --> 01:15:48,250
因此 如果我只期待整数 这在以前是行不通的

1614
01:15:48,250 --> 01:15:51,550
来自用户的值 但现在我需要浮点值

1615
01:15:51,550 --> 01:15:56,180
适应它 我现在实际上也可以做浮点算术了 

1616
01:15:56,180 --> 01:15:59,020
但假设我并不真正想要最终的答案

1617
01:15:59,020 --> 01:16:03,160
设置为浮点值 如4.6 

1618
01:16:03,160 --> 01:16:05,930
如果我们只舍入到最接近的整数 我会很高兴 

1619
01:16:05,930 --> 01:16:08,800
所以我想支持用户在浮点打字

1620
01:16:08,800 --> 01:16:11,120
带有小数点的值 但在一天结束时 

1621
01:16:11,120 --> 01:16:15,760
例如 我只想将结果四舍五入为最接近的整数 

1622
01:16:15,760 --> 01:16:20,830
事实证明 在这里 也有一些内置的功能 

1623
01:16:20,830 --> 01:16:23,620
事实上 如果我们返回到前面的URL

1624
01:16:23,620 --> 01:16:26,560
其中列出了所有的Python内置函数 

1625
01:16:26,560 --> 01:16:29,200
有一种叫“圆形”的词 它的意思是

1626
01:16:29,200 --> 01:16:31,510
正如我们所期望的那样 它接受一个数字作为输入

1627
01:16:31,510 --> 01:16:36,860
然后为我们将其舍入为最接近的整数 

1628
01:16:36,860 --> 01:16:40,390
但如果我们像这里一样更仔细地查看这些文档--

1629
01:16:40,390 --> 01:16:41,710
我将提供一段摘录--

1630
01:16:41,710 --> 01:16:45,400
文档中的函数如下所示 

1631
01:16:45,400 --> 01:16:48,550
回想一下 前面我们查看了打印的文档

1632
01:16:48,550 --> 01:16:51,550
这在精神上是相似的 这向我们展示的不仅仅是

1633
01:16:51,550 --> 01:16:54,880
函数的名称 但其可用参数 即 

1634
01:16:54,880 --> 01:16:57,850
使用此函数时我们可以提供的输入 

1635
01:16:57,850 --> 01:17:00,280
但这也有点神秘 就像印刷品一样 

1636
01:17:00,280 --> 01:17:01,640
它还添加了一些语法 

1637
01:17:01,640 --> 01:17:02,290
让我们来看看 

1638
01:17:02,290 --> 01:17:04,630
这里这个函数的名称当然是RUND

1639
01:17:04,630 --> 01:17:07,450
它的第一个参数是一个数字 

1640
01:17:07,450 --> 01:17:10,548
注意 这一次没有恒星 没有恒星物体

1641
01:17:10,548 --> 01:17:11,590
就像印刷品一样 

1642
01:17:11,590 --> 01:17:16,000
ROUND函数只接受一个数字作为其第一个参数Period 

1643
01:17:16,000 --> 01:17:18,820
这是它的位置参数 

1644
01:17:18,820 --> 01:17:20,420
但请注意此语法 

1645
01:17:20,420 --> 01:17:22,720
这是编程或技术上的惯例

1646
01:17:22,720 --> 01:17:26,260
更广泛地说 一般来说 当你看到方括号时

1647
01:17:26,260 --> 01:17:28,630
像这样的文件 这意味着你是

1648
01:17:28,630 --> 01:17:30,370
即将看到一些可选的内容 

1649
01:17:30,370 --> 01:17:32,350
这就意味着 如果你想

1650
01:17:32,350 --> 01:17:37,480
为了更准确地指定希望ROUND函数的位数

1651
01:17:37,480 --> 01:17:43,760
要四舍五入 您可以在此处指定 方法是添加逗号 然后添加该数字 

1652
01:17:43,760 --> 01:17:48,190
因此 如果我们阅读文档 如果您不指定位数 

1653
01:17:48,190 --> 01:17:52,000
您只需指定要舍入的数字 它就会舍入到最接近的整数 

1654
01:17:52,000 --> 01:17:55,990
但是 假设您想要位于第10位或第100位

1655
01:17:55,990 --> 01:17:58,330
这是小数点后的一位或两位数 

1656
01:17:58,330 --> 01:18:04,167
更准确地说 您还可以传入逗号1或逗号2 

1657
01:18:04,167 --> 01:18:06,250
这就是文件所说的 

1658
01:18:06,250 --> 01:18:10,460
让我们看看是否不能为我们将其转换为一些实际的代码 

1659
01:18:10,460 --> 01:18:13,630
所以如果我现在回到VS代码 我认为

1660
01:18:13,630 --> 01:18:18,350
我想要继续 对x和y进行循环 我可以用几种方法来做 

1661
01:18:18,350 --> 01:18:22,630
我可以做x+y轮 但你知道 我会

1662
01:18:22,630 --> 01:18:25,210
实际上 我更倾向于把这个问题分成两行 

1663
01:18:25,210 --> 01:18:28,300
我不需要 这里有理智的人可能不同意 

1664
01:18:28,300 --> 01:18:31,330
但我想回到打印z的场景中 

1665
01:18:31,330 --> 01:18:34,270
这样我就能更清楚地了解自己 了解他人 

1666
01:18:34,270 --> 01:18:38,890
假设z=x+y的四舍五入结果 

1667
01:18:38,890 --> 01:18:41,060
这并不一定是更好的方法 

1668
01:18:41,060 --> 01:18:44,690
但我更愿意一次说出我的一个想法 

1669
01:18:44,690 --> 01:18:47,882
尤其是如果我想要开始注释这些代码块中的每一个 

1670
01:18:47,882 --> 01:18:49,840
好的 让我去我的终端窗口

1671
01:18:49,840 --> 01:18:52,120
现在运行Calculator.py的Python 

1672
01:18:52,120 --> 01:18:52,840
X是什么？

1673
01:18:52,840 --> 01:18:54,490
让我们再做一次1.2 

1674
01:18:54,490 --> 01:18:56,260
那我们就做3.4吧 

1675
01:18:56,260 --> 01:18:59,980
现在之前是4.6 但现在是

1676
01:18:59,980 --> 01:19:04,540
向上舍入到最接近的整数 当然是5 

1677
01:19:04,540 --> 01:19:09,050
好吧 如果我想进一步改变这一点呢？

1678
01:19:09,050 --> 01:19:11,830
如果我想支持可能非常大的数字 

1679
01:19:11,830 --> 01:19:15,872
大数字 不管四舍五入 让我们做这样的事情 

1680
01:19:15,872 --> 01:19:17,830
让我继续运行Calculator.py的Python

1681
01:19:17,830 --> 01:19:22,270
让我再加一次999+1 

1682
01:19:22,270 --> 01:19:25,030
注意 我不需要输入小数点 

1683
01:19:25,030 --> 01:19:27,340
即使我要转换为浮点型 我的程序

1684
01:19:27,340 --> 01:19:30,840
只允许我输入小数点 但我不需要这样做 

1685
01:19:30,840 --> 01:19:34,110
当然 这里的答案应该是 实际上也是1000 

1686
01:19:34,110 --> 01:19:35,670
不管我们是不是绕过去 

1687
01:19:35,670 --> 01:19:38,470
所以这只是整数的算术 

1688
01:19:38,470 --> 01:19:44,640
但在美国 我们倾向于用逗号来格式化长数字

1689
01:19:44,640 --> 01:19:47,580
在每三位数之后或之前 

1690
01:19:47,580 --> 01:19:50,660
其他国家则改用句号和逗号 

1691
01:19:50,660 --> 01:19:51,660
这是一个系统设置 

1692
01:19:51,660 --> 01:19:53,700
您可以在自己的Mac或PC上进行更改

1693
01:19:53,700 --> 01:19:57,000
或任何语言的设备 但对我来说 我是

1694
01:19:57,000 --> 01:20:01,200
这里使用的是美国方法 即小数点的句号

1695
01:20:01,200 --> 01:20:02,940
和逗号作为分隔符 

1696
01:20:02,940 --> 01:20:07,890
如果我想将其输出为1,000 怎么办？

1697
01:20:07,890 --> 01:20:12,180
只是想更清楚一点 它是1000 而不是100左右 

1698
01:20:12,180 --> 01:20:14,580
当它达到100万的时候 这就更有用了--

1699
01:20:14,580 --> 01:20:18,060
一百万 

1700
01:20:18,060 --> 01:20:19,950
如果我们能自动地

1701
01:20:19,950 --> 01:20:21,540
也输出这些数字吗？

1702
01:20:21,540 --> 01:20:23,700
好吧 事实证明我们可以 

1703
01:20:23,700 --> 01:20:28,410
有一种使用Python的方法可以实际指定我们

1704
01:20:28,410 --> 01:20:30,540
我想包括这样的逗号 

1705
01:20:30,540 --> 01:20:34,800
现在我们有机会把我们的老朋友 F弦带回来 

1706
01:20:34,800 --> 01:20:37,440
首先 让我做一些不那么有成效的事情 

1707
01:20:37,440 --> 01:20:38,760
首先 让我来做这个 

1708
01:20:38,760 --> 01:20:41,610
让我打印出z的值 但请稍等 

1709
01:20:41,610 --> 01:20:44,850
我不能只说“z” 因为从字面上看 这会打印出z

1710
01:20:44,850 --> 01:20:45,820
在屏幕上 

1711
01:20:45,820 --> 01:20:49,050
所以让我像以前一样用花括号把它包起来 

1712
01:20:49,050 --> 01:20:50,550
但这也是不够的 

1713
01:20:50,550 --> 01:20:54,060
我确实需要在字符串的开头添加一个F

1714
01:20:54,060 --> 01:20:56,940
来告诉Python这是一个F字符串 一种格式字符串 

1715
01:20:56,940 --> 01:21:01,650
现在将打印出来 不是很有趣 只是z的值

1716
01:21:01,650 --> 01:21:02,320
它本身 

1717
01:21:02,320 --> 01:21:06,270
所以我会不遗余力地打印z 而实际上我本可以

1718
01:21:06,270 --> 01:21:07,890
把z作为唯一的论据 

1719
01:21:07,890 --> 01:21:11,820
但为了确保我没有弄坏它 让我们再来一次 

1720
01:21:11,820 --> 01:21:14,190
999+1 回车 

1721
01:21:14,190 --> 01:21:15,300
好的 还是1000美元 

1722
01:21:15,300 --> 01:21:16,950
所以我没有让事情变得更糟 

1723
01:21:16,950 --> 01:21:20,460
但请注意--不幸的是 这个语法有点神秘--

1724
01:21:20,460 --> 01:21:22,380
注意 我实际上可以做到这一点 

1725
01:21:22,380 --> 01:21:27,450
我可以在z后面加一个冒号 然后再加一个逗号 

1726
01:21:27,450 --> 01:21:29,763
诚然 这看起来非常神秘 甚至我

1727
01:21:29,763 --> 01:21:32,430
我必须不断地在文档中查找类似的内容

1728
01:21:32,430 --> 01:21:33,750
记住语法 

1729
01:21:33,750 --> 01:21:35,460
但在这里 让我再运行一次 

1730
01:21:35,460 --> 01:21:41,250
Python of Calculator.py 9991 现在请注意

1731
01:21:41,250 --> 01:21:43,928
号码是自动为我格式化的 

1732
01:21:43,928 --> 01:21:45,720
如果我在一个不同的国家或地区 

1733
01:21:45,720 --> 01:21:49,620
我完全可以用句点来代替逗号或反之亦然 

1734
01:21:49,620 --> 01:21:50,290
反过来说 

1735
01:21:50,290 --> 01:21:52,990
但在这种情况下 这对我来说是自动发生的 

1736
01:21:52,990 --> 01:21:56,310
因此 我们在这里也看到了对真正格式化字符串意味着什么的暗示 

1737
01:21:56,310 --> 01:21:57,720
甚至还有更大的力量--

1738
01:21:57,720 --> 01:22:00,633
其中内置了更强大的功能 

1739
01:22:00,633 --> 01:22:02,550
好的 让我在这里停一下 看看有没有

1740
01:22:02,550 --> 01:22:10,200
任何关于浮点数、四舍五入或F字符串用法的问题 

1741
01:22:10,200 --> 01:22:11,700
观众：是的 所以我有一个问题 

1742
01:22:11,700 --> 01:22:14,760
所以当使用花车时 有没有像帽子一样的东西

1743
01:22:14,760 --> 01:22:16,860
到它可以有多少个小数点？

1744
01:22:16,860 --> 01:22:18,360
大卫·马兰：这是一个非常好的问题 

1745
01:22:18,360 --> 01:22:21,150
所以漂浮 是的 这是一个我们不久将重新讨论的问题 

1746
01:22:21,150 --> 01:22:25,590
浮点数不能无限精确地表示数字 

1747
01:22:25,590 --> 01:22:28,112
一言以蔽之 因为计算机只有这么多的内存 

1748
01:22:28,112 --> 01:22:29,820
它们只有有限的内存 

1749
01:22:29,820 --> 01:22:34,200
你和我在电脑里只有有限数量的硬件 

1750
01:22:34,200 --> 01:22:36,540
因此 在某种程度上 他们将不得不绕过去 

1751
01:22:36,540 --> 01:22:38,190
现在我正在自动取整 

1752
01:22:38,190 --> 01:22:40,732
实际上 计算机最终将不得不为我们做到这一点 

1753
01:22:40,732 --> 01:22:44,010
但不久之后 我们将把这视为一个根本问题 

1754
01:22:44,010 --> 01:22:47,385
请允许我回到关于Float的最后几个例子

1755
01:22:47,385 --> 01:22:50,010
在我们介绍最后几个例子之前 这些例子不仅允许我们

1756
01:22:50,010 --> 01:22:52,290
使用函数 但创建我们自己的函数 

1757
01:22:52,290 --> 01:22:56,940
让我建议我们在这里也尝试一下点名表决 

1758
01:22:56,940 --> 01:22:59,250
让我提议我们现在修改这个计算器

1759
01:22:59,250 --> 01:23:01,740
仍然带着几个花车 但现在让我们做

1760
01:23:01,740 --> 01:23:04,050
比这更简单的东西--

1761
01:23:04,050 --> 01:23:07,085
和这个略有不同 就是x除以y 

1762
01:23:07,085 --> 01:23:09,210
让我继续 去掉我的格式字符串

1763
01:23:09,210 --> 01:23:12,383
现在只需保持简单 打印出z即可 

1764
01:23:12,383 --> 01:23:13,800
我们在这里会看到什么呢？

1765
01:23:13,800 --> 01:23:15,092
嗯 只是一些简单的除法 

1766
01:23:15,092 --> 01:23:19,920
因此 在Calculator.py中 让我们做一些类似于2除以3的操作 

1767
01:23:19,920 --> 01:23:21,960
当然 我能拿到0.66666 

1768
01:23:21,960 --> 01:23:25,600
对于伊森刚才的问题 它似乎确实是有限的 

1769
01:23:25,600 --> 01:23:30,180
它在这里不是以一种奇怪的方式舍入 但我似乎只看到这么多数字 

1770
01:23:30,180 --> 01:23:34,170
这是以这种方式使用浮点的必然性 

1771
01:23:34,170 --> 01:23:37,620
相比之下 正如您所知道的 现在在Python语言中使用整数

1772
01:23:37,620 --> 01:23:39,690
可以有多大就有多大 

1773
01:23:39,690 --> 01:23:41,910
与其他语言不同 它没有上限

1774
01:23:41,910 --> 01:23:44,550
关于整数现在在Python语言中可以有多大 但有

1775
01:23:44,550 --> 01:23:48,225
是浮点值的精确度的界限 

1776
01:23:48,225 --> 01:23:50,850
好的 现在我有了一个简单的部门 

1777
01:23:50,850 --> 01:23:52,380
让我们继续下去 把这个绕过去 

1778
01:23:52,380 --> 01:23:57,060
对这个很长的数字0.6666666进行舍入会很好 依此类推

1779
01:23:57,060 --> 01:23:59,190
可能只有两位小数点后 

1780
01:23:59,190 --> 01:24:02,460
不过 我们已经看到了如何使用ROUND做到这一点 至少在它的文档中是这样的 

1781
01:24:02,460 --> 01:24:04,980
让我们把它舍入到最接近的整数 

1782
01:24:04,980 --> 01:24:09,810
通过只传递x除以y 这是一个参数 一旦数学是

1783
01:24:09,810 --> 01:24:13,350
在括号内完成 我不想只传递一个参数 

1784
01:24:13,350 --> 01:24:17,100
我想传入两个数字 这样我就可以指定n位数字 

1785
01:24:17,100 --> 01:24:21,030
位数 您还记得它是舍入的第二个参数 

1786
01:24:21,030 --> 01:24:23,240
让我继续运行Calculator.py的Python 

1787
01:24:23,240 --> 01:24:24,240
我会做同样的事情--

1788
01:24:24,240 --> 01:24:27,300
2 然后是3 0.67 

1789
01:24:27,300 --> 01:24:31,130
所以我们现在也看到了一种取整的方法 不仅仅是舍入到最接近的整数 

1790
01:24:31,130 --> 01:24:34,160
而是最接近的数字 

1791
01:24:34,160 --> 01:24:36,300
但在这里 还有另一种方法可以做到这一点 

1792
01:24:36,300 --> 01:24:40,920
事实上 这再次唤起了我们的F字符串的例子 

1793
01:24:40,920 --> 01:24:42,270
让我继续更改这一点 

1794
01:24:42,270 --> 01:24:45,740
假设您不记得ROUND函数 或者 出于某种原因 

1795
01:24:45,740 --> 01:24:46,940
你不想用它 

1796
01:24:46,940 --> 01:24:49,340
相反 您只想使用格式字符串 

1797
01:24:49,340 --> 01:24:50,510
好吧 我们去那里吧 

1798
01:24:50,510 --> 01:24:55,280
让我做“z” 但让我用花括号把它括起来 

1799
01:24:55,280 --> 01:24:58,850
让我在开头加上F 再一次 这还不是很有趣 

1800
01:24:58,850 --> 01:25:02,300
这只会打印出z 但我会增加更多的复杂性

1801
01:25:02,300 --> 01:25:03,920
把它变成F弦 

1802
01:25:03,920 --> 01:25:08,940
但请注意 我可以在变量名之后、冒号之后执行其他操作 

1803
01:25:08,940 --> 01:25:11,300
如果这将是一个大整数 我

1804
01:25:11,300 --> 01:25:15,200
可能需要像以前一样使用逗号来分隔每三个数字

1805
01:25:15,200 --> 01:25:15,950
用逗号 

1806
01:25:15,950 --> 01:25:16,580
但我不知道 

1807
01:25:16,580 --> 01:25:20,120
我将使用不同的字符序列 

1808
01:25:20,120 --> 01:25:25,190
我要说的是0.2F 这也是我有一个非常神秘的东西

1809
01:25:25,190 --> 01:25:28,040
经常抬头 因为如果我不经常使用它 我会忘记 

1810
01:25:28,040 --> 01:25:32,030
所以 如果这看起来特别奇怪 不要害怕 但这是 

1811
01:25:32,030 --> 01:25:33,950
根据文件 你的方式

1812
01:25:33,950 --> 01:25:37,830
使用F字符串指定要打印的位数 

1813
01:25:37,830 --> 01:25:39,980
所以让我运行这个版本的计算器 

1814
01:25:39,980 --> 01:25:43,170
输入2 然后输入3 我们得到完全相同的结果 

1815
01:25:43,170 --> 01:25:45,350
但同样 这与我的主张是一致的

1816
01:25:45,350 --> 01:25:49,580
在编程中 我们经常可以解决相同的问题

1817
01:25:49,580 --> 01:25:51,030
以多种方式 

1818
01:25:51,030 --> 01:25:56,240
这就是现在解决同样问题的F弦方法 

1819
01:25:56,240 --> 01:25:57,630
好的 哪一个更好？

1820
01:25:57,630 --> 01:25:58,310
那得看情况 

1821
01:25:58,310 --> 01:26:00,200
在这种情况下 它们几乎是等价的 

1822
01:26:00,200 --> 01:26:03,260
不过 您可以想象 有时使用函数是很有用的

1823
01:26:03,260 --> 01:26:07,340
这样您就可以将n位之类参数作为第二个参数进行传递 

1824
01:26:07,340 --> 01:26:10,700
或者您可以想象一下 您只需提前决定您想要0.2

1825
01:26:10,700 --> 01:26:13,370
然后写成这样 

1826
01:26:13,370 --> 01:26:17,300
现在让我们从关注字符串和整数过渡到

1827
01:26:17,300 --> 01:26:19,880
现在重点放在函数本身上 

1828
01:26:19,880 --> 01:26:21,860
我们今天一开始就关注您如何

1829
01:26:21,860 --> 01:26:24,230
使用随Python提供的函数 

1830
01:26:24,230 --> 01:26:26,990
但如果你能发明你自己的功能不是很好吗 

1831
01:26:26,990 --> 01:26:29,330
特别是如果 正如我们前面所说的 你会发现

1832
01:26:29,330 --> 01:26:32,210
你自己一次又一次地解决同样的问题？

1833
01:26:32,210 --> 01:26:34,700
很好 Python附带了打印功能

1834
01:26:34,700 --> 01:26:37,130
因为能够在屏幕上打印东西真的很有用 

1835
01:26:37,130 --> 01:26:40,130
但如果你可以在屏幕上打印特定的东西 那不是很好吗

1836
01:26:40,130 --> 01:26:42,170
只需调用您自己的函数？

1837
01:26:42,170 --> 01:26:44,100
好吧 让我提议我们这样做 

1838
01:26:44,100 --> 01:26:49,760
让我回到这里的VS代码 让我建议我们回到Hello.py 

1839
01:26:49,760 --> 01:26:52,820
我要在之前离开的地方重新打开Hello.py

1840
01:26:52,820 --> 01:26:54,620
现在我要开始向大家提出

1841
01:26:54,620 --> 01:26:58,460
我们考虑如何才能开始进一步改善这一点

1842
01:26:58,460 --> 01:26:59,330
我们自己的功能 

1843
01:26:59,330 --> 01:27:03,380
我今天写了很多程序 只是打个招呼

1844
01:27:03,380 --> 01:27:05,360
每次我使用印刷品的时候 

1845
01:27:05,360 --> 01:27:08,090
但如果从今天开始 

1846
01:27:08,090 --> 01:27:12,620
我们可以只调用一个名为Hello的函数 该函数只为我们说Hello？

1847
01:27:12,620 --> 01:27:15,080
现在 多年前的Python的作者们并没有

1848
01:27:15,080 --> 01:27:18,020
我想我们需要一个特殊的功能来打招呼 

1849
01:27:18,020 --> 01:27:19,820
但我希望这种情况能够存在 

1850
01:27:19,820 --> 01:27:21,980
我打了很多次招呼 我只是想

1851
01:27:21,980 --> 01:27:23,600
为了能够调用函数Hello 

1852
01:27:23,600 --> 01:27:25,550
因此 我将在这里从头开始 

1853
01:27:25,550 --> 01:27:27,680
我将删除前面的所有代码

1854
01:27:27,680 --> 01:27:32,510
我暂时假设存在一个名为Hello的函数 

1855
01:27:32,510 --> 01:27:34,250
我要做的就是像以前一样 

1856
01:27:34,250 --> 01:27:36,740
我将使用输入函数获取用户名 

1857
01:27:36,740 --> 01:27:39,110
问你叫什么名字 问号 

1858
01:27:39,110 --> 01:27:42,230
现在我将调用函数Hello

1859
01:27:42,230 --> 01:27:45,260
然后我将打印出用户名 

1860
01:27:45,260 --> 01:27:50,190
现在我要承认 Hello并不存在 所以坏事就要发生了 

1861
01:27:50,190 --> 01:27:51,440
但让我们来看看会发生什么 

1862
01:27:51,440 --> 01:27:53,210
让我下到我的终端窗口 

1863
01:27:53,210 --> 01:27:55,700
让我运行Hello.py的Python 

1864
01:27:55,700 --> 01:27:59,030
我认为第一行会很好 因为这以前很管用 

1865
01:27:59,030 --> 01:28:01,280
事实上 这促使我选择了我的名字 

1866
01:28:01,280 --> 01:28:02,780
那么 让我输入David 

1867
01:28:02,780 --> 01:28:05,090
第二行代码显然是在调用

1868
01:28:05,090 --> 01:28:08,840
一个看起来像是Hello的函数 因为它为什么是一个函数？

1869
01:28:08,840 --> 01:28:11,820
它后面紧跟着一个括号和一个右括号 

1870
01:28:11,820 --> 01:28:14,300
这就是我们用过的每个函数的样子 

1871
01:28:14,300 --> 01:28:16,340
但是 Python不会识别这一点 

1872
01:28:16,340 --> 01:28:18,890
现在 当我按Enter键时 我得到一个名称错误 

1873
01:28:18,890 --> 01:28:21,950
未定义名称“Hello” 您的意思是帮助吗？

1874
01:28:21,950 --> 01:28:26,120
我没有 虽然这是个好时机我现在需要的是帮助 

1875
01:28:26,120 --> 01:28:29,540
但我遇到这个错误是因为什么呢？

1876
01:28:29,540 --> 01:28:31,440
这个功能根本不存在 

1877
01:28:31,440 --> 01:28:33,350
那么 我如何让这个函数存在呢？

1878
01:28:33,350 --> 01:28:39,440
嗯 我需要自己创建它 使用这个关键字 DEF 定义的DEF 

1879
01:28:39,440 --> 01:28:43,610
所以这里也是一样 就像STR是字符串的缩写 int是整数的缩写 

1880
01:28:43,610 --> 01:28:45,830
Def是定义的缩写 

1881
01:28:45,830 --> 01:28:50,330
如果您想要定义、创建、发明您自己的函数 

1882
01:28:50,330 --> 01:28:53,870
现在 您可以在Python中使用此关键字来完成此操作 

1883
01:28:53,870 --> 01:28:58,310
让我回到我这里的代码 让我建议我们定义这个

1884
01:28:58,310 --> 01:28:59,900
也许是以这种方式 

1885
01:28:59,900 --> 01:29:02,660
在我文件的最顶端 我将首先

1886
01:29:02,660 --> 01:29:05,150
片刻定义一个名为Hello的函数

1887
01:29:05,150 --> 01:29:10,430
使用DEF Hello 左括号 右括号 冒号 

1888
01:29:10,430 --> 01:29:15,110
现在的意思是 Python将处理每一行代码

1889
01:29:15,110 --> 01:29:20,240
我在这个下面缩进 作为这个新函数的含义 Hello 

1890
01:29:20,240 --> 01:29:23,030
所以DEF很重要 空间也很重要 

1891
01:29:23,030 --> 01:29:26,577
我可以选择函数的名称 我选择将其命名为Hello 

1892
01:29:26,577 --> 01:29:29,660
括号内没有任何内容 表示此函数此时

1893
01:29:29,660 --> 01:29:32,540
不会接受任何输入 也不会有任何论点 

1894
01:29:32,540 --> 01:29:35,810
冒号的意思是 请继续关注一些缩进 

1895
01:29:35,810 --> 01:29:38,750
这行代码下面缩进的所有内容

1896
01:29:38,750 --> 01:29:40,310
将成为这一功能的一部分 

1897
01:29:40,310 --> 01:29:42,920
这将是一个超短的函数--一行代码--

1898
01:29:42,920 --> 01:29:46,040
它只会打印出“你好 ”

1899
01:29:46,040 --> 01:29:51,830
但现在在第1行和第2行 我发明了我自己的函数Hello 

1900
01:29:51,830 --> 01:29:54,740
注意这些现在神奇地出现在这里的圆点 

1901
01:29:54,740 --> 01:29:56,660
这只是我的文本编辑器的一个设置 

1902
01:29:56,660 --> 01:30:00,470
VS代码在这种情况下 这对我来说是非常明确的 我已经

1903
01:30:00,470 --> 01:30:04,160
按空格键四次 或相当于按Tab键一次 

1904
01:30:04,160 --> 01:30:07,018
它被自动转换为四个空格 

1905
01:30:07,018 --> 01:30:10,310
一般来说 我需要确保我所有的缩进代码

1906
01:30:10,310 --> 01:30:14,150
现在排好队 这样Python就知道它们都是同一件事的一部分 

1907
01:30:14,150 --> 01:30:16,770
但在本例中很容易 因为它只有一行 

1908
01:30:16,770 --> 01:30:20,810
但是现在 由于有了第1行和第2行 函数Hello

1909
01:30:20,810 --> 01:30:24,920
当我准备好在第6行使用它时 它将绝对存在 

1910
01:30:24,920 --> 01:30:29,180
因此 让我转到我的终端窗口并运行Hello.py的Python 回车 

1911
01:30:29,180 --> 01:30:30,570
我的名字又来了 

1912
01:30:30,570 --> 01:30:35,120
现在 当我按回车键时 我现在看到的是Hello David 

1913
01:30:35,120 --> 01:30:37,190
好吧 我们有点退步了 对吧？

1914
01:30:37,190 --> 01:30:39,960
这远不像以前那么漂亮了 

1915
01:30:39,960 --> 01:30:44,840
我认为 通过进一步改进 我们可能会做得更好 

1916
01:30:44,840 --> 01:30:47,510
然而 我们为什么不考虑一下 我们可以如何

1917
01:30:47,510 --> 01:30:50,480
比如说 将这个相同的函数参数化？

1918
01:30:50,480 --> 01:30:55,010
也就是说 我们是否可以将Hello定制为可能将用户名作为输入

1919
01:30:55,010 --> 01:31:00,020
这样我们就可以说 不仅是你好 而且这个人的名字都在一行上 所有的

1920
01:31:00,020 --> 01:31:01,070
一口气？

1921
01:31:01,070 --> 01:31:02,450
我想我们可以做到的 

1922
01:31:02,450 --> 01:31:05,400
让我提议我们这样做 

1923
01:31:05,400 --> 01:31:10,100
让我在我的代码中继续前进 让我进入这些括号 

1924
01:31:10,100 --> 01:31:12,350
让我想出我自己的参数名称 

1925
01:31:12,350 --> 01:31:14,510
我在这里有完全的选择 我要去

1926
01:31:14,510 --> 01:31:17,780
要说我的参数的名称将是单词 

1927
01:31:17,780 --> 01:31:18,500
为什么？

1928
01:31:18,500 --> 01:31:22,970
因为我希望我的函数听起来像它所代表的动词--

1929
01:31:22,970 --> 01:31:23,690
你好 

1930
01:31:23,690 --> 01:31:25,610
但是你想跟谁打个招呼呢？

1931
01:31:25,610 --> 01:31:27,860
我将调用此函数的参数

1932
01:31:27,860 --> 01:31:30,860
To 就因为在英语里 它对我来说听起来很好听 

1933
01:31:30,860 --> 01:31:32,900
你好 你想跟谁打个招呼？

1934
01:31:32,900 --> 01:31:36,050
这就是为什么我调用这个参数而不是某个

1935
01:31:36,050 --> 01:31:38,360
更简单 如x、y或z 

1936
01:31:38,360 --> 01:31:40,798
好吧 那么我想用to这个词做什么呢？

1937
01:31:40,798 --> 01:31:42,590
嗯 我可以做几件不同的事情 

1938
01:31:42,590 --> 01:31:45,320
我们已经看到了很多不同的实现Hello的方法 

1939
01:31:45,320 --> 01:31:48,000
为了语法起见 让我在那里加一个逗号 

1940
01:31:48,000 --> 01:31:52,700
然后让我把后面的词作为第二个论点

1941
01:31:52,700 --> 01:31:53,715
转到函数Hello 

1942
01:31:53,715 --> 01:31:56,090
我们还有其他方法可以做到这一点 我们已经看到了很多种方法 

1943
01:31:56,090 --> 01:31:58,940
但我会说 这件事在我看来有点清楚 

1944
01:31:58,940 --> 01:32:00,380
接下来会发生什么？

1945
01:32:00,380 --> 01:32:03,470
我想我这里不需要这条额外的打印线 

1946
01:32:03,470 --> 01:32:07,040
我想我要做的是 我要在这里继续

1947
01:32:07,040 --> 01:32:12,740
而不是手动打印出这个人的名字 我会说 

1948
01:32:12,740 --> 01:32:15,410
你好 圆括号的名字 

1949
01:32:15,410 --> 01:32:16,880
那么我现在在做什么呢？

1950
01:32:16,880 --> 01:32:20,690
在第1行和第2行 我定义了我自己的函数 名为Hello 

1951
01:32:20,690 --> 01:32:23,240
但这一次 这个函数已经设计好了

1952
01:32:23,240 --> 01:32:26,750
接受一个参数 单个参数 作为输入 

1953
01:32:26,750 --> 01:32:29,810
我使用的是该参数的值 

1954
01:32:29,810 --> 01:32:33,470
我打电话去印刷 这样我不仅能看到

1955
01:32:33,470 --> 01:32:35,780
你好 还有那个人的名字 

1956
01:32:35,780 --> 01:32:37,070
我在5号线上做什么？

1957
01:32:37,070 --> 01:32:39,140
和往常一样 我只是得到了用户名 

1958
01:32:39,140 --> 01:32:42,140
6号线 我不仅要打给你 我要路过

1959
01:32:42,140 --> 01:32:46,500
作为作为参数的名称变量的输入

1960
01:32:46,500 --> 01:32:48,912
所以这就是传递给Hello的内容 

1961
01:32:48,912 --> 01:32:50,870
这里发生的事情本质上是这样的--

1962
01:32:50,870 --> 01:32:54,710
即使变量在这里称为NAME 当函数

1963
01:32:54,710 --> 01:33:00,920
自身被调用时 计算机假定现在调用了相同的值 

1964
01:33:00,920 --> 01:33:04,760
因此 名称实际上被复制到另一个名为

1965
01:33:04,760 --> 01:33:11,420
这样 在Hello的上下文中 我可以对该变量说Hello 

1966
01:33:11,420 --> 01:33:15,140
我们很快就会看到 如果我们不把这些放在一起会发生什么 

1967
01:33:15,140 --> 01:33:17,600
让我继续运行Hello.py的Python 回车 

1968
01:33:17,600 --> 01:33:18,540
你叫什么名字？

1969
01:33:18,540 --> 01:33:20,060
现在我要祈祷了 

1970
01:33:20,060 --> 01:33:20,840
进来吧 

1971
01:33:20,840 --> 01:33:21,750
我们走吧 

1972
01:33:21,750 --> 01:33:25,700
我们恢复了业务 但现在我有了自己的定制函数 名为Hello

1973
01:33:25,700 --> 01:33:28,550
这让我可以向特定的人打招呼 

1974
01:33:28,550 --> 01:33:30,980
这就是现在事情可以变得非常奇特的地方 

1975
01:33:30,980 --> 01:33:34,220
如果你想让你的Hello函数向某个特定的人问好 

1976
01:33:34,220 --> 01:33:37,070
但是 你知道吗 如果你不知道你想跟谁打招呼 

1977
01:33:37,070 --> 01:33:38,840
你想向全世界问好 

1978
01:33:38,840 --> 01:33:41,300
您可以为参数指定缺省值 

1979
01:33:41,300 --> 01:33:42,060
我们已经看到了这一点 

1980
01:33:42,060 --> 01:33:45,530
回想一下 对于Print SEP有一个缺省值 

1981
01:33:45,530 --> 01:33:46,550
作为分隔器 

1982
01:33:46,550 --> 01:33:49,700
End有一个缺省值 即行结束 

1983
01:33:49,700 --> 01:33:52,280
我们也可以这样做 下面是语法 

1984
01:33:52,280 --> 01:33:56,390
如果您想要此参数的默认值 

1985
01:33:56,390 --> 01:34:00,620
如果不是由程序员提供的 则等于“world” 

1986
01:34:00,620 --> 01:34:05,155
你可以在定义函数的同一行中做到这一点 

1987
01:34:05,155 --> 01:34:07,280
我承认 它开始看起来更神秘了 

1988
01:34:07,280 --> 01:34:10,580
但我仍在定义一个名为Hello的函数 它

1989
01:34:10,580 --> 01:34:13,820
接受一个名为的参数 但我将其赋值

1990
01:34:13,820 --> 01:34:19,340
用等号表示缺省值“world” 以防程序员

1991
01:34:19,340 --> 01:34:22,310
不使用参数调用Hello 

1992
01:34:22,310 --> 01:34:23,660
我们可以在这里看到这个 

1993
01:34:23,660 --> 01:34:26,750
让我更改代码 以两种方式使用Hello 

1994
01:34:26,750 --> 01:34:31,880
在第5行 我将非常简单地调用Hello no arguments 

1995
01:34:31,880 --> 01:34:33,710
然后在第6行 我将得到名字 

1996
01:34:33,710 --> 01:34:36,320
第7行 我将用一个参数调用Hello 

1997
01:34:36,320 --> 01:34:39,060
因此 您将看到Hello现在被以两种方式使用 

1998
01:34:39,060 --> 01:34:41,960
让我继续运行Hello.py的Python 

1999
01:34:41,960 --> 01:34:43,310
我要把我的名字打进去 

2000
01:34:43,310 --> 01:34:44,630
哦 有意思 

2001
01:34:44,630 --> 01:34:47,120
请注意 我已经看到了Hello World 但这是

2002
01:34:47,120 --> 01:34:52,070
因为第5行在第6行之前 所以是预期的 但是一旦我输入我的名字 

2003
01:34:52,070 --> 01:34:55,940
现在节目将会更有礼貌地跟我打招呼

2004
01:34:55,940 --> 01:34:57,180
就个人而言 

2005
01:34:57,180 --> 01:35:01,550
在那里 我们也可以看到相对简单但新的语法

2006
01:35:01,550 --> 01:35:05,990
如何实现与印刷品在本质上非常相似的功能

2007
01:35:05,990 --> 01:35:07,860
功能自动给了我们 

2008
01:35:07,860 --> 01:35:10,940
现在你可以控制自己做这件事了 

2009
01:35:10,940 --> 01:35:12,980
但现在让我也说明这一点 

2010
01:35:12,980 --> 01:35:15,530
定义您自己的函数的全部要点之一

2011
01:35:15,530 --> 01:35:18,680
是一种 只是为了避免一次又一次地重复自己 

2012
01:35:18,680 --> 01:35:21,890
你不需要一直重新发明轮子

2013
01:35:21,890 --> 01:35:24,480
并继续使用打印功能 一次又一次 

2014
01:35:24,480 --> 01:35:25,850
如果你只是想跟我打个招呼 

2015
01:35:25,850 --> 01:35:29,780
如果我现在可以移动这个代码不是很好吗

2016
01:35:29,780 --> 01:35:34,010
这是我为定义Hello函数而编写的 只是为了戏剧性地说 

2017
01:35:34,010 --> 01:35:37,760
我要多次按回车键 50行以下 

2018
01:35:37,760 --> 01:35:41,240
并将我对Hello way的定义进一步放在这个文件中 

2019
01:35:41,240 --> 01:35:41,840
为什么？

2020
01:35:41,840 --> 01:35:44,720
好吧 只是为了本着眼不见心不烦的精神 

2021
01:35:44,720 --> 01:35:48,800
因为如果我现在回放到我的节目的开头 现在

2022
01:35:48,800 --> 01:35:51,240
你可以想当然地认为 哦 Hello是一个函数 

2023
01:35:51,240 --> 01:35:51,740
为什么？

2024
01:35:51,740 --> 01:35:54,740
因为它在第一行 它有一个左括号和一个闭合括号

2025
01:35:54,740 --> 01:35:57,560
括号 到目前为止 它的意思是调用这个函数 

2026
01:35:57,560 --> 01:36:00,200
然后在第2行 我们从用户那里获得一个变量

2027
01:36:00,200 --> 01:36:04,620
然后我们调用Hello 传入这个值 

2028
01:36:04,620 --> 01:36:07,790
在这一点上 我可以理所当然地认为Hello存在 

2029
01:36:07,790 --> 01:36:11,360
即使它在文件中的位置更低 或者正如我们在未来几周看到的那样 

2030
01:36:11,360 --> 01:36:13,970
即使是在另一个文件里

2031
01:36:13,970 --> 01:36:15,500
但这里有个问题 

2032
01:36:15,500 --> 01:36:19,190
让我继续运行这个版本的Hello.py 

2033
01:36:19,190 --> 01:36:23,270
请注意 只要我运行解释器 Hello.py的Python 

2034
01:36:23,270 --> 01:36:26,360
我看到一个名称错误 名称Hello未定义 

2035
01:36:26,360 --> 01:36:28,280
再说一遍 你是说帮助吗？

2036
01:36:28,280 --> 01:36:29,480
好吧 再一次 合适 

2037
01:36:29,480 --> 01:36:33,500
我确实需要一些帮助 但我并不想调用Help函数 

2038
01:36:33,500 --> 01:36:36,650
然而 这里的问题是 Python只是从字面上理解我 

2039
01:36:36,650 --> 01:36:40,610
我已经定义了函数Hello一直到这里 

2040
01:36:40,610 --> 01:36:42,500
但我想把它用在这里

2041
01:36:42,500 --> 01:36:43,465
这是不允许的

2042
01:36:43,465 --> 01:36:45,590
Python的解释器将从字面上理解

2043
01:36:45,590 --> 01:36:47,810
如果你使用一个函数 它必须已经

2044
01:36:47,810 --> 01:36:50,390
在你打电话的时候就存在了 

2045
01:36:50,390 --> 01:36:51,600
我该怎么解决这个问题？

2046
01:36:51,600 --> 01:36:53,270
显然我不能这么做 

2047
01:36:53,270 --> 01:36:57,440
我必须在文件的最顶端定义任何函数 

2048
01:36:57,440 --> 01:36:59,720
但这也会给我带来麻烦

2049
01:36:59,720 --> 01:37:04,640
因为如果我总是要定义一个函数

2050
01:37:04,640 --> 01:37:07,010
要使用它 你需要反向编写代码 

2051
01:37:07,010 --> 01:37:09,218
你不断地在这里写函数 在这里 

2052
01:37:09,218 --> 01:37:12,450
在这里 相对于逻辑地写代码 从上到下 

2053
01:37:12,450 --> 01:37:16,190
让我用一种更标准的方法来解决这个问题 就是这样做 

2054
01:37:16,190 --> 01:37:20,990
一般来说 您确实希望将代码的主要部分

2055
01:37:20,990 --> 01:37:22,530
在你档案的顶部

2056
01:37:22,530 --> 01:37:27,110
实际上 我将定义一个函数 叫做Main 

2057
01:37:27,110 --> 01:37:29,540
这不是一个要求 但它是在数据公约 

2058
01:37:29,540 --> 01:37:31,910
这就向读者暗示了

2059
01:37:31,910 --> 01:37:33,620
是我的计划的主要部分 

2060
01:37:33,620 --> 01:37:38,030
我现在要去掉空的Hello调用 只传入一个版本

2061
01:37:38,030 --> 01:37:39,110
你好 名字 

2062
01:37:39,110 --> 01:37:42,260
再往下 再往下几行 

2063
01:37:42,260 --> 01:37:45,030
实际上 我将定义我的Hello函数 

2064
01:37:45,030 --> 01:37:47,870
不幸的是 现在我已经以这种方式重新排序了函数 

2065
01:37:47,870 --> 01:37:51,890
我把代码的主要部分放在顶部 Hello放在底部 

2066
01:37:51,890 --> 01:37:55,310
这样我的逻辑就可以从上到下 

2067
01:37:55,310 --> 01:37:57,680
Hello.py的Python 输入 

2068
01:37:57,680 --> 01:38:00,290
什么都没发生 

2069
01:38:00,290 --> 01:38:02,630
如果我再做一次 什么都不会发生 

2070
01:38:02,630 --> 01:38:04,520
这到底是为什么

2071
01:38:04,520 --> 01:38:06,740
我定义了一个函数

2072
01:38:06,740 --> 01:38:09,230
Main和我定义了一个叫Hello的函数

2073
01:38:09,230 --> 01:38:11,420
并不意味着我真的打过电话

2074
01:38:11,420 --> 01:38:13,340
这两种都是

2075
01:38:13,340 --> 01:38:16,970
是的 我在Main内部使用Hello 但没有人

2076
01:38:16,970 --> 01:38:20,210
告诉Python实际使用或调用Main 

2077
01:38:20,210 --> 01:38:24,770
为了整理好这个文件 我最后要做的就是 

2078
01:38:24,770 --> 01:38:28,100
实际上是调用我的main函数 

2079
01:38:28,100 --> 01:38:30,890
实际上 通过这样调用我的main函数 

2080
01:38:30,890 --> 01:38:33,890
它让我摆脱了麻烦 因为现在我先定义Main

2081
01:38:33,890 --> 01:38:35,450
但我还没打给你

2082
01:38:35,450 --> 01:38:38,760
我将定义Hello next 但我不会调用Hello next 

2083
01:38:38,760 --> 01:38:42,170
我只在这个文件的最后调用Main

2084
01:38:42,170 --> 01:38:45,090
它的作用是在这里运行这段代码 

2085
01:38:45,090 --> 01:38:47,690
它的作用是在这里运行这段代码 

2086
01:38:47,690 --> 01:38:50,870
因此我可以整理我的档案

2087
01:38:50,870 --> 01:38:55,520
并以任何我想要的方式排列我的函数 包括顶部的Main 

2088
01:38:55,520 --> 01:38:59,930
并最终解决Python不知道发生了什么的问题 

2089
01:38:59,930 --> 01:39:02,780
需要注意的是 我定义了函数

2090
01:39:02,780 --> 01:39:05,690
你好 作为一个论点 然后我

2091
01:39:05,690 --> 01:39:08,390
将变量的值传入该函数

2092
01:39:08,390 --> 01:39:11,570
我想跟它打个招呼 它就是名为Name的变量

2093
01:39:11,570 --> 01:39:14,420
因为假设我做了一些不同的事情 

2094
01:39:14,420 --> 01:39:17,670
假设我没有定义Hello是接受一个参数 

2095
01:39:17,670 --> 01:39:21,560
所以我只删除了对To及其默认值“world”提及 “

2096
01:39:21,560 --> 01:39:25,070
我回到我的主函数 

2097
01:39:25,070 --> 01:39:28,193
调用Hello本身而不传入任何参数 

2098
01:39:28,193 --> 01:39:30,360
现在让我继续做我的最后一件改变 

2099
01:39:30,360 --> 01:39:32,760
技术上还有一个错误 让我继续

2100
01:39:32,760 --> 01:39:37,720
并尝试简单地打印出Hello函数中的名称的值 

2101
01:39:37,720 --> 01:39:40,380
现在需要说明的是 在我第2行的主函数中 

2102
01:39:40,380 --> 01:39:43,740
我定义了名为name的变量 并将返回值赋给它

2103
01:39:43,740 --> 01:39:45,480
来自用户的输入功能 

2104
01:39:45,480 --> 01:39:47,010
然后我就给你打个电话 

2105
01:39:47,010 --> 01:39:50,700
在我的Hello函数中 它现在不再接受任何参数 

2106
01:39:50,700 --> 01:39:54,180
我正在调用Print 传入Hello逗号 

2107
01:39:54,180 --> 01:39:56,970
然后立即传入名称、变量

2108
01:39:56,970 --> 01:39:58,740
我得到了用户的输入 

2109
01:39:58,740 --> 01:40:02,232
但问题是 这个名字现在只存在于Main中 

2110
01:40:02,232 --> 01:40:05,190
所以 当我尝试运行这个版本的程序时 请注意会发生什么

2111
01:40:05,190 --> 01:40:07,170
使用Python Hello.py 

2112
01:40:07,170 --> 01:40:08,220
我按了Enter键 

2113
01:40:08,220 --> 01:40:10,500
我被提示输入我的名字 D-A-V-I-D 回车 

2114
01:40:10,500 --> 01:40:11,340
还有 啊！

2115
01:40:11,340 --> 01:40:12,450
名称错误 

2116
01:40:12,450 --> 01:40:15,400
未定义名称“name” 

2117
01:40:15,400 --> 01:40:19,050
因此 这实际上是一个所谓范围的问题 

2118
01:40:19,050 --> 01:40:23,970
作用域是指仅存在于定义该变量的上下文中的变量 

2119
01:40:23,970 --> 01:40:28,080
因此 只要我定义了这个变量 在我的Main函数中命名 

2120
01:40:28,080 --> 01:40:31,020
我只能在我的名字函数中使用该变量 

2121
01:40:31,020 --> 01:40:34,380
我不能像我在Hello函数中尝试的那样使用它 

2122
01:40:34,380 --> 01:40:36,930
它不存在于那个所谓的范围内 

2123
01:40:36,930 --> 01:40:42,010
这就是为什么现在 如果我倒回并撤销所有这些更改 

2124
01:40:42,010 --> 01:40:45,690
您将看到我故意从Main函数中传递Main

2125
01:40:45,690 --> 01:40:47,340
进入我的Hello函数 

2126
01:40:47,340 --> 01:40:50,260
现在在Hello函数中 从技术上讲 它有一个不同的名称 

2127
01:40:50,260 --> 01:40:52,380
在这种情况下 它被要求这样做 但这很好 

2128
01:40:52,380 --> 01:40:55,950
命名自己的变量完全由每个单独的函数决定

2129
01:40:55,950 --> 01:40:58,230
或者命名自己的论点 但这是现在的一种方式

2130
01:40:58,230 --> 01:41:01,630
我将该变量的值传递给Hello函数

2131
01:41:01,630 --> 01:41:04,530
所以它也可以由Hello打印 

2132
01:41:04,530 --> 01:41:07,410
我们还可以在这里添加最后一个华丽的元素 

2133
01:41:07,410 --> 01:41:10,590
现在我们已经实现了Hello 您会注意到Hello Only

2134
01:41:10,590 --> 01:41:12,120
有所谓的副作用 

2135
01:41:12,120 --> 01:41:14,580
它只将某些内容打印到屏幕上 

2136
01:41:14,580 --> 01:41:19,980
好吧 如果我也希望我的功能本身不会有副作用 

2137
01:41:19,980 --> 01:41:22,300
但真的给了我一个价值吗？

2138
01:41:22,300 --> 01:41:25,740
回想一下 输入函数返回一个值 

2139
01:41:25,740 --> 01:41:27,510
用户键入的字符串 

2140
01:41:27,510 --> 01:41:30,060
回想一下 int函数返回值 

2141
01:41:30,060 --> 01:41:33,960
FLOAT函数返回传递给它的值 

2142
01:41:33,960 --> 01:41:37,260
你可以在这里使用最后一个关键词 字面意思

2143
01:41:37,260 --> 01:41:40,890
返回可自己显式返回值 

2144
01:41:40,890 --> 01:41:43,890
事实上 让我回到这里的VS代码 我

2145
01:41:43,890 --> 01:41:47,820
我想我们会把注意力放在Calculator.py上

2146
01:41:47,820 --> 01:41:53,190
看看我们是否不能实现另一个版本的Calculator.py

2147
01:41:53,190 --> 01:41:56,410
有我们自己的函数 甚至返回值 

2148
01:41:56,410 --> 01:41:59,800
所以我将继续打开Calculator/Py

2149
01:41:59,800 --> 01:42:03,100
我想这一次我会像以前一样把一切都扔掉 

2150
01:42:03,100 --> 01:42:06,600
我要开始练习我们在这里所宣扬的东西 

2151
01:42:06,600 --> 01:42:09,120
定义一个名为Main的函数 该函数现在

2152
01:42:09,120 --> 01:42:11,070
成为我职能的主要部分 

2153
01:42:11,070 --> 01:42:13,980
我们继续 现在声明一个名为x的变量 

2154
01:42:13,980 --> 01:42:19,350
并在询问他们之后将其分配给用户输入的转换版本 

2155
01:42:19,350 --> 01:42:20,430
X是什么？

2156
01:42:20,430 --> 01:42:23,490
再说一遍 这一行代码和我们以前做过的一样 

2157
01:42:23,490 --> 01:42:27,023
现在假设我想要做的是对这个值进行平方 

2158
01:42:27,023 --> 01:42:29,190
我想取用户输入的号码

2159
01:42:29,190 --> 01:42:30,840
并将其乘以2的幂 

2160
01:42:30,840 --> 01:42:32,790
所以2的平方等于4 

2161
01:42:32,790 --> 01:42:34,410
3的平方等于9 

2162
01:42:34,410 --> 01:42:36,840
4的平方等于16 以此类推 

2163
01:42:36,840 --> 01:42:39,450
那么我该如何逐字实现一个函数呢

2164
01:42:39,450 --> 01:42:42,960
名为Square的应用程序实际上并没有内置Python？

2165
01:42:42,960 --> 01:42:45,660
好吧 让我暂时假设它确实存在 并让

2166
01:42:45,660 --> 01:42:47,530
我这样说--

2167
01:42:47,530 --> 01:42:50,670
让我继续说 印刷 如何

2168
01:42:50,670 --> 01:42:57,720
大约x的平方是x的逗号平方 

2169
01:42:57,720 --> 01:42:59,170
那么我做了什么呢？

2170
01:42:59,170 --> 01:43:02,710
我定义了一个名为main的函数 并实现了两行 

2171
01:43:02,710 --> 01:43:05,190
这些行中的第一行提示用户输入值

2172
01:43:05,190 --> 01:43:09,330
X并将其转换为int 并将其存储在一个名为x的变量中 

2173
01:43:09,330 --> 01:43:12,930
在第三行 我说x的平方是 然后

2174
01:43:12,930 --> 01:43:16,620
我将第二个参数传递给print函数 无论返回什么

2175
01:43:16,620 --> 01:43:18,780
Value是一个平方函数 

2176
01:43:18,780 --> 01:43:22,230
但是平方是不存在的 我会在这里展示给你们看 

2177
01:43:22,230 --> 01:43:30,090
如果我现在调用底部的Main 并运行Calculator.py的Python 

2178
01:43:30,090 --> 01:43:35,100
我会看到x是2 然后我会看到一大堆错误 一个名字错误 

2179
01:43:35,100 --> 01:43:37,090
未定义名称Square 

2180
01:43:37,090 --> 01:43:39,810
所以这不是一个打字错误 只是这个函数不存在 

2181
01:43:39,810 --> 01:43:41,790
但我想我可以让它在这里存在 

2182
01:43:41,790 --> 01:43:45,180
让我们继续定义另一个名为Square的函数 

2183
01:43:45,180 --> 01:43:47,400
这一张将会有一个数字 我是

2184
01:43:47,400 --> 01:43:50,370
就像许多程序员所说的那样 将其泛称为n 

2185
01:43:50,370 --> 01:43:52,260
只是为了代表任何旧数字 

2186
01:43:52,260 --> 01:43:56,010
然后我要怎么做才能求n的平方呢？

2187
01:43:56,010 --> 01:43:59,380
嗯 一个数字的平方实际上就是它自己的乘积 

2188
01:43:59,380 --> 01:44:00,720
所以我要这么做--

2189
01:44:00,720 --> 01:44:02,340
N乘以n 

2190
01:44:02,340 --> 01:44:06,180
但光靠自己算算是不够的 n乘以n 

2191
01:44:06,180 --> 01:44:09,990
您将必须返回实际值n乘以n

2192
01:44:09,990 --> 01:44:11,970
这就是我们的新关键词 

2193
01:44:11,970 --> 01:44:14,100
当我现在这样做的时候 看看会发生什么 

2194
01:44:14,100 --> 01:44:16,230
在Calculator.py的Python中 输入 

2195
01:44:16,230 --> 01:44:20,250
X说应该是2 x的平方是4 

2196
01:44:20,250 --> 01:44:24,020
现在让我继续 假设x现在是3 

2197
01:44:24,020 --> 01:44:26,010
X的平方现在是9 

2198
01:44:26,010 --> 01:44:30,060
所以我实现了我自己的函数 它返回值的平方

2199
01:44:30,060 --> 01:44:33,180
因为我使用的是返回关键字 所以

2200
01:44:33,180 --> 01:44:36,120
确保我可以传递此函数的返回值 只是

2201
01:44:36,120 --> 01:44:40,140
就像INPUT、INT或FLOAT的返回值一样 返回到另一个函数 

2202
01:44:40,140 --> 01:44:41,460
比如印刷品 

2203
01:44:41,460 --> 01:44:44,520
在这里 也会有很多方法来解决这个同样的问题 

2204
01:44:44,520 --> 01:44:47,490
我实际上可以把n的2次方 

2205
01:44:47,490 --> 01:44:49,620
我们以前没有见过这种语法 但如果您

2206
01:44:49,620 --> 01:44:54,220
用像这样的两个星号 两颗星 把左边的东西抬起来

2207
01:44:54,220 --> 01:44:55,590
右手边的电源 

2208
01:44:55,590 --> 01:44:58,290
或者 原来在Python中有一个名为

2209
01:44:58,290 --> 01:45:00,480
战俘将某事提升到某种力量

2210
01:45:00,480 --> 01:45:04,200
接受两个参数 第一个参数是数字 第二个参数是

2211
01:45:04,200 --> 01:45:05,140
是指数 

2212
01:45:05,140 --> 01:45:09,810
同样 也有很多方法可以真正解决同样的问题

2213
01:45:09,810 --> 01:45:11,290
也是 

2214
01:45:11,290 --> 01:45:13,020
那么 归根结底 我们在这里做了什么？

2215
01:45:13,020 --> 01:45:15,960
我们首先介绍了函数--这些动作或动词 其中许多

2216
01:45:15,960 --> 01:45:19,000
将其内置到只能在您自己的代码中使用的Python中 

2217
01:45:19,000 --> 01:45:22,290
然后我们引入了变量 您可以通过这些变量存储这些返回值

2218
01:45:22,290 --> 01:45:24,120
然后也许可以用它做更多的事情 

2219
01:45:24,120 --> 01:45:25,350
在一天结束时也是如此 

2220
01:45:25,350 --> 01:45:28,260
您现在有能力创建、发明自己的函数

2221
01:45:28,260 --> 01:45:30,750
解决像Hello这样的简单问题 或者在几周内

2222
01:45:30,750 --> 01:45:36,590
即将到来的--更复杂、更具挑战性、更有趣的问题 

