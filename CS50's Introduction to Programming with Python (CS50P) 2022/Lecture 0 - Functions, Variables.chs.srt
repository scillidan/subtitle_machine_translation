
1
00:00:00,000 --> 00:00:03,444
[轻柔的管弦乐演奏]
[GENTLE ORCHESTRAL MUSIC PLAYING]

2
00:00:24,110 --> 00:00:26,840
大卫·马兰：好了 这是CS50的S介绍
DAVID MALAN: All right, this is CS50's Introduction

3
00:00:26,840 --> 00:00:28,190
到使用Python语言编程 
to Programming with Python.

4
00:00:28,190 --> 00:00:32,009
我的名字是David Malan 这是我们关于函数和变量的一周 
My name is David Malan and this is our week on functions and variables.

5
00:00:32,009 --> 00:00:35,690
但很有可能的是 你们中的许多人 大多数人 以前从未真正编程过 
But odds are, many of you, most of you, have never actually programmed before.

6
00:00:35,690 --> 00:00:37,790
因此 让我们从这样做开始吧 
So let's start by doing just that.

7
00:00:37,790 --> 00:00:40,250
让我在这里继续 打开我的计算机
Let me go ahead here and open up my computer

8
00:00:40,250 --> 00:00:43,220
在它上面 有一个名为Visual Studio Code或VS的程序
and on it, a program called Visual Studio Code or VS

9
00:00:43,220 --> 00:00:45,650
代码 这是一个非常流行的程序
Code, which is just a very popular program nowadays

10
00:00:45,650 --> 00:00:47,220
用于实际编写代码 
for actually writing code.

11
00:00:47,220 --> 00:00:49,840
现在 您不必使用此特定工具编写代码 
Now, you don't have to write code using this particular tool.

12
00:00:49,840 --> 00:00:51,590
事实上 我们一天结束时所需要的
In fact, all we need at the end of the day

13
00:00:51,590 --> 00:00:54,742
是一种所谓的文本编辑器 一种编写文本的程序 
is a so-called text editor, a program for writing text.

14
00:00:54,742 --> 00:00:57,200
见鬼 如果你真的想 你甚至可以用
And, heck, if you really want, you could even use something

15
00:00:57,200 --> 00:00:59,180
比如Google Docs或Microsoft Word 
like Google Docs or Microsoft Word.

16
00:00:59,180 --> 00:01:00,952
你必须以正确的格式保存它 
You'd have to save it in the right format,

17
00:01:00,952 --> 00:01:04,160
但说到底 你所需要的只是一个写文本的程序
but really, at the end of the day, all you need is a program for writing text

18
00:01:04,160 --> 00:01:06,170
因为这就是代码--文本 
because that's what code is-- text.

19
00:01:06,170 --> 00:01:08,090
现在 在这个特别的项目中 我将
Now within this particular program, I'm going

20
00:01:08,090 --> 00:01:10,550
能够创建一个或多个文件
to have the ability to create one or more files

21
00:01:10,550 --> 00:01:12,500
通过屏幕的这个顶部 
via this top portion of the screen.

22
00:01:12,500 --> 00:01:14,810
我要做的就是潜入
And I'm going to do so by diving right in

23
00:01:14,810 --> 00:01:17,030
在我的屏幕底部做这件事 
and doing this at the bottom of my screen.

24
00:01:17,030 --> 00:01:20,060
在我的屏幕底部是一个所谓的终端窗口
At the bottom of my screen is a so-called terminal window

25
00:01:20,060 --> 00:01:25,310
这是底层的命令行界面或CLI界面
and this is a command line interface or CLI interface to the underlying

26
00:01:25,310 --> 00:01:29,340
电脑 无论是你的Mac还是你的PC 甚至是云中的某个服务器 
computer, be it your Mac or your PC or even some server in the cloud.

27
00:01:29,340 --> 00:01:32,240
我在这里要做的就是直接写“代码” 然后
And what I'm going to do here is literally write, "code" and then

28
00:01:32,240 --> 00:01:36,530
我要编码的文件的名称 例如 Hello.py 
the name of the file that I want to code, for instance, Hello.py.

29
00:01:36,530 --> 00:01:40,310
我们很快就会看到 您用Python编写的任何程序通常都有一个文件
As we'll soon see, any program that you write in Python generally has a file

30
00:01:40,310 --> 00:01:44,210
以.py结尾的名称 向计算机表明它确实是一个程序
name that ends in .py to indicate to the computer that it's indeed a program

31
00:01:44,210 --> 00:01:45,320
用Python语言编写的 
written in Python.

32
00:01:45,320 --> 00:01:48,440
现在你会看到在我屏幕的顶部 我有一个闪烁的光标 
Now you'll see here at the top of my screen, I have a blinking cursor,

33
00:01:48,440 --> 00:01:51,800
第一行--这是我的代码的第一行--
a line one-- which is where the very first line of my code is going to go--

34
00:01:51,800 --> 00:01:55,730
然后是一个选项卡 它让我想起这个文件的名称Hello.py 
and then just a tab that reminds me of the name of this file Hello.py.

35
00:01:55,730 --> 00:01:58,370
虽然我对Python了解不多 
And without even knowing much Python, I'm

36
00:01:58,370 --> 00:02:00,770
我的第一个程序如下
going to write my very first program here as follows--

37
00:02:00,770 --> 00:02:02,120
print（“hello world”） 
print("hello,world").

38
00:02:08,396 --> 00:02:10,729
你会看到 在我的键盘上 我的一些想法
And you'll see that, at my keyboard, some of my thoughts

39
00:02:10,729 --> 00:02:11,604
对我来说已经结束了 
were finished for me.

40
00:02:11,604 --> 00:02:14,870
我只需要输入一个括号 另一个就会自动出现 
I only had to type one parenthesis and the other one automatically appeared,

41
00:02:14,870 --> 00:02:18,590
这就是我们在这里看到的工具的特点 
and that's just the feature that we'll see of tools like this tool here.

42
00:02:18,590 --> 00:02:21,080
即使你以前从未编程过 
Now even if you've never programmed before,

43
00:02:21,080 --> 00:02:25,610
你可以猜测 推断出这个简单的程序要做什么 
odds are you can guess, infer what this simple program is going to do.

44
00:02:25,610 --> 00:02:28,250
只有一句台词 print（“hello world”） 
And it's only one line. print("hello,world").

45
00:02:32,030 --> 00:02:33,830
实际上 当我最终运行这个程序时 
Indeed, when I run this program ultimately,

46
00:02:33,830 --> 00:02:35,948
它只会说 你好 世界 
it's just going to say, Hello to the world.

47
00:02:35,948 --> 00:02:37,490
事实上 这是一个非常著名的--
And, in fact, this is a very famous--

48
00:02:37,490 --> 00:02:39,440
也许是最规范的程序 
perhaps the most canonical-- program that you

49
00:02:39,440 --> 00:02:42,530
可以用Python或任何其他语言编写你的第一个程序 
can write as your very first program in Python or any other language,

50
00:02:42,530 --> 00:02:44,280
这就是我在这里所做的
and so that's what I've done here.

51
00:02:44,280 --> 00:02:48,230
但在我的Mac电脑 我的PC 甚至我的手机上 我通常习惯 
But on my Mac, my PC, even my phone, I'm generally in the habit,

52
00:02:48,230 --> 00:02:51,170
就像你一样 双击图标就能运行程序
like you, of running programs by double clicking an icon

53
00:02:51,170 --> 00:02:52,760
或者只是点击屏幕 
or just tapping on the screen.

54
00:02:52,760 --> 00:02:54,920
但我在这里没有看到这样的图标 
But I see no such icons here.

55
00:02:54,920 --> 00:02:58,730
事实上 这是因为我现在的Mac电脑的界面
And in fact, that's because my interface to at least my current Mac

56
00:02:58,730 --> 00:03:02,180
或PC或云中的某个服务器 也只是一个CLI--
or PC or some server in the cloud, is again only a CLI--

57
00:03:02,180 --> 00:03:04,340
命令行接口--尽管它
command line interface-- which even though it

58
00:03:04,340 --> 00:03:07,820
我可能会觉得这是从菜单、按钮和图标中后退一步
might feel like it's a step back from the menus and buttons and icons

59
00:03:07,820 --> 00:03:10,730
你和我每天都认为是理所当然的 你会发现 我们认为 
that you and I take for granted every day, you'll find, we think,

60
00:03:10,730 --> 00:03:13,670
它最终会是一个更强大的界面 
that it's ultimately a much more powerful interface and incredibly

61
00:03:13,670 --> 00:03:16,920
在现实世界中的程序员中很流行 
popular to use among programmers in the real world.

62
00:03:16,920 --> 00:03:20,245
所以要运行这个程序 我必须使用一个命令
So to run this program, I'm going to have to use a command

63
00:03:20,245 --> 00:03:23,120
我将把光标移回屏幕底部
and I'm going to move my cursor back down to the bottom of the screen

64
00:03:23,120 --> 00:03:25,790
这里我之前已经运行了一个命令--
here where previously I already ran one command--

65
00:03:25,790 --> 00:03:30,410
在我的计算机中具有打开VS Code效果的命令Code 
the command Code which has the effect of opening VS Code in my computer,

66
00:03:30,410 --> 00:03:33,560
然后我传入了我想编码的文件名 
and then I passed in the name of the file that I wanted to code up.

67
00:03:33,560 --> 00:03:36,000
现在我有机会输入第二个命令 
Now I have a chance to type a second command,

68
00:03:36,000 --> 00:03:38,090
你会看到第二个美元符号 
and you'll see I see a second dollar sign.

69
00:03:38,090 --> 00:03:41,360
这里的美元符号并不表示任何一种货币或货币 
Now the dollar sign here doesn't indicate any kind of currency or money,

70
00:03:41,360 --> 00:03:43,340
这只是一个普遍使用的符号
it just is the symbol that's generally used

71
00:03:43,340 --> 00:03:46,610
以指示您的提示符--命令行界面需要的位置
to indicate your prompt-- where the command line interface wants

72
00:03:46,610 --> 00:03:47,990
你需要把这些命令 
you to put those commands.

73
00:03:47,990 --> 00:03:51,530
现在我可以在这里运行的命令是这样的--
Now the command I can run here is going to be this--

74
00:03:51,530 --> 00:03:55,310
我将运行Hello.py的Python 
I'm going to run Python of Hello.py.

75
00:03:55,310 --> 00:03:56,490
这是为什么呢？
Now why is that?

76
00:03:56,490 --> 00:04:00,380
事实证明 当我用像Python语言这样的语言编写代码时 
Well, it turns out that when I actually write code in a language like Python,

77
00:04:00,380 --> 00:04:02,120
它当然存储在那个文件中--
it's of course stored in that file--

78
00:04:02,120 --> 00:04:07,063
您好 但是我需要从上到下解释代码 
Hello.py, but I need to interpret the code top to bottom,

79
00:04:07,063 --> 00:04:09,230
从左到右 这样计算机就知道该怎么做了 
left to right so that the computer knows what to do.

80
00:04:09,230 --> 00:04:10,940
事实上 在一天结束的时候 即使你不是真的
Indeed, at the end of the day, even if you don't really

81
00:04:10,940 --> 00:04:12,920
对计算机了解很多 你可能已经
know much about computers, you've probably

82
00:04:12,920 --> 00:04:16,790
听说计算机只懂0和1 也就是所谓的二进制
heard the computers only understand zeros and ones, the so-called binary

83
00:04:16,790 --> 00:04:17,390
系统 
system.

84
00:04:17,390 --> 00:04:21,769
如果是这样的话 写着“打印”和圆括号的东西
Well if that's the case, then something that says "print" and parentheses

85
00:04:21,769 --> 00:04:25,430
引用引述的Hello world 不一定是0和1 
and quote unquote hello world, is not surely zeros and ones.

86
00:04:25,430 --> 00:04:27,750
我们必须以某种方式将其转化为0和1
We have to somehow translate it into the zeros and ones

87
00:04:27,750 --> 00:04:29,000
计算机能理解的信息 
that the computer understands.

88
00:04:29,000 --> 00:04:33,360
现在幸运的是 只要你提前安装了这样的程序 
Now fortunately, so long as you've installed such a program in advance,

89
00:04:33,360 --> 00:04:36,380
有一个程序和一种叫做Python的语言 
there's a program as well as a language called Python.

90
00:04:36,380 --> 00:04:39,390
因此 Python不仅是我们要用来编写代码的语言 
So Python is not only a language in which we're going to write code,

91
00:04:39,390 --> 00:04:42,590
它也是一个程序 也就是众所周知的解释器
it's also a program otherwise known as an interpreter

92
00:04:42,590 --> 00:04:46,490
您可以在自己的Mac或PC或云中的某个服务器上免费安装
that you install for free on your own Mac or PC or some server in the cloud

93
00:04:46,490 --> 00:04:50,990
然后您可以运行该程序、该解释器 并将其作为输入传递给它
and you can then run that program, that interpreter, passing to it as input

94
00:04:50,990 --> 00:04:53,870
您的文件的名称与我的类似 Hello.py 
the name of your file like mine here, Hello.py.

95
00:04:53,870 --> 00:04:56,000
然后那个程序 那个解释器 就会
And then that program, that interpreter, will

96
00:04:56,000 --> 00:04:59,210
掌握从上到下、从左到右阅读它的过程
handle the process of reading it top to bottom, left to right

97
00:04:59,210 --> 00:05:02,210
并有效地将其转换为那些0和1
and translating it effectively into those zeros and ones

98
00:05:02,210 --> 00:05:04,170
计算机可以理解的 
that the computer can understand.

99
00:05:04,170 --> 00:05:05,360
所以我们就这么做吧 
So let's do just that.

100
00:05:05,360 --> 00:05:07,190
让我回到这里的VS代码 
Let me go back to VS Code here.

101
00:05:07,190 --> 00:05:11,030
我已经输入了Hello.py的Python 但没有按回车键 
I already typed out Python of Hello.py but I didn't get hit Enter.

102
00:05:11,030 --> 00:05:13,430
这就是现在要开始的命令
And that's what's now going to kick off this command

103
00:05:13,430 --> 00:05:16,190
希望 如果我没有搞砸这一切 
and hopefully, if I didn't mess any of this up,

104
00:05:16,190 --> 00:05:20,370
I should see my very first program's output to the screen.
I should see my very first program's output to the screen.

105
00:05:20,370 --> 00:05:23,480
And voila, hello, world.
And voila, hello, world.

106
00:05:23,480 --> 00:05:25,970
So if you too have typed exactly that same code
So if you too have typed exactly that same code

107
00:05:25,970 --> 00:05:28,400
and have executed exactly that same command,
and have executed exactly that same command,

108
00:05:28,400 --> 00:05:32,840
you will have written your very first program in this case in Python.
you will have written your very first program in this case in Python.

109
00:05:32,840 --> 00:05:34,790
Well now let's take a step back and consider,
Well now let's take a step back and consider,

110
00:05:34,790 --> 00:05:37,190
what is it that we actually just did and what
what is it that we actually just did and what

111
00:05:37,190 --> 00:05:38,930
is it we're looking here on the screen?
is it we're looking here on the screen?

112
00:05:38,930 --> 00:05:41,450
Well first and foremost, in most any programming language,
Well first and foremost, in most any programming language,

113
00:05:41,450 --> 00:05:43,950
you tend to have access to what are called functions.
you tend to have access to what are called functions.

114
00:05:43,950 --> 00:05:46,460
A function is like an action or a verb that
A function is like an action or a verb that

115
00:05:46,460 --> 00:05:48,800
lets you do something in the program.
lets you do something in the program.

116
00:05:48,800 --> 00:05:52,730
And generally speaking, any language comes with some predetermined set
And generally speaking, any language comes with some predetermined set

117
00:05:52,730 --> 00:05:57,097
of functions-- some very basic actions or verbs that the computer will already
of functions-- some very basic actions or verbs that the computer will already

118
00:05:57,097 --> 00:05:59,180
know how to do for you, that the language, really,
know how to do for you, that the language, really,

119
00:05:59,180 --> 00:06:00,530
will know how to do for you.
will know how to do for you.

120
00:06:00,530 --> 00:06:04,640
And you, the programmer, the human, can use those functions at will
And you, the programmer, the human, can use those functions at will

121
00:06:04,640 --> 00:06:07,020
to get the computer to do those things.
to get the computer to do those things.

122
00:06:07,020 --> 00:06:11,835
Now the program in question here, Hello.py is using one function.
Now the program in question here, Hello.py is using one function.

123
00:06:11,835 --> 00:06:13,460
And you could perhaps guess what it is.
And you could perhaps guess what it is.

124
00:06:13,460 --> 00:06:16,760
That function is, of course, going to be this function print
That function is, of course, going to be this function print

125
00:06:16,760 --> 00:06:19,430
and that print function, of course, doesn't
and that print function, of course, doesn't

126
00:06:19,430 --> 00:06:22,340
print some preordained string of text.
print some preordained string of text.

127
00:06:22,340 --> 00:06:26,240
That is to say, it prints whatever it is you want it to print.
That is to say, it prints whatever it is you want it to print.

128
00:06:26,240 --> 00:06:29,600
And here too, do we have another piece of terminology in the world
And here too, do we have another piece of terminology in the world

129
00:06:29,600 --> 00:06:31,430
of programming, namely arguments.
of programming, namely arguments.

130
00:06:31,430 --> 00:06:36,830
An argument is an input to a function that somehow influences its behavior.
An argument is an input to a function that somehow influences its behavior.

131
00:06:36,830 --> 00:06:38,660
The people who invented Python, of course,
The people who invented Python, of course,

132
00:06:38,660 --> 00:06:40,790
didn't necessarily know what it is you and I
didn't necessarily know what it is you and I

133
00:06:40,790 --> 00:06:43,850
are going to want to print to the screen, so they designed this print
are going to want to print to the screen, so they designed this print

134
00:06:43,850 --> 00:06:46,580
function using these parentheses with the ability
function using these parentheses with the ability

135
00:06:46,580 --> 00:06:49,340
to take as input some string of text, be it
to take as input some string of text, be it

136
00:06:49,340 --> 00:06:52,250
in English or any other human language, that is
in English or any other human language, that is

137
00:06:52,250 --> 00:06:56,540
what you want this function ultimately to print onto the screen.
what you want this function ultimately to print onto the screen.

138
00:06:56,540 --> 00:06:59,640
那么这个节目最终会在屏幕上做什么呢？
And what is it that the program is ultimately doing on the screen?

139
00:06:59,640 --> 00:07:01,070
嗯 当然是印刷品 
Well, it's printing, of course.

140
00:07:01,070 --> 00:07:03,230
它在屏幕上向我们展示了你好 世界 
It's showing us hello, world on the screen.

141
00:07:03,230 --> 00:07:05,743
这在编程中通常被称为副作用 
And that's generally in programming known as a side effect.

142
00:07:05,743 --> 00:07:07,160
它可以是可视的 也可以是音频的 
It can be visual, it can be audio.

143
00:07:07,160 --> 00:07:09,470
在这种情况下 它是出现在屏幕上的东西
In this case, it's something that appears on the screen

144
00:07:09,470 --> 00:07:12,690
因此 功能确实会产生这些副作用 
and functions, therefore, can indeed have these side effects.

145
00:07:12,690 --> 00:07:15,650
作为这个动词或动作 他们可以做的一件事是
One of the things they can do as this verb or action is

146
00:07:15,650 --> 00:07:19,100
作为一个副作用显示在屏幕上 就像那些话
to display on the screen as a side effect, something like those words

147
00:07:19,100 --> 00:07:20,240
我们想要的--
that we wanted--

148
00:07:20,240 --> 00:07:21,870
你好 世界 
hello, world.

149
00:07:21,870 --> 00:07:25,080
这是我的第一个项目 你知道 我感觉很好 
So that's my first program and, you know, I'm feeling pretty good.

150
00:07:25,080 --> 00:07:26,570
一切都按计划进行 
Everything worked as planned.

151
00:07:26,570 --> 00:07:28,490
我没有犯任何错误 但是 说实话 
I didn't make any mistakes, but, honestly,

152
00:07:28,490 --> 00:07:30,560
当你在学习如何编程 甚至
when you're learning how to program and even

153
00:07:30,560 --> 00:07:34,250
几年后 一旦你学会了如何编程 你就会犯错 
once you've learned how to program years later, you're going to make mistakes.

154
00:07:34,250 --> 00:07:36,615
当然 这些错误是指
And those mistakes, of course, are referred

155
00:07:36,615 --> 00:07:38,990
一个你可能已经知道的术语 那就是臭虫 
to a term you might already know, which is that of a bug.

156
00:07:38,990 --> 00:07:42,230
Bug是程序中的错误 它们可以采取多种形式 
A bug is a mistake in a program and they can take so many forms.

157
00:07:42,230 --> 00:07:46,460
或许 让人欣慰的是 在接下来的几周里 
And take comfort, perhaps, in knowing that over the coming weeks,

158
00:07:46,460 --> 00:07:48,450
你会犯很多错误的 
you're going to make so many mistakes.

159
00:07:48,450 --> 00:07:51,320
你的代码中会有很多错误 就像我一样
You're going to have so many bugs in your code, just like I did

160
00:07:51,320 --> 00:07:53,490
就像我现在还在做的那样 
and just as I still do.

161
00:07:53,490 --> 00:07:55,610
而这些错误本身就是错误
And those bugs themselves are just mistakes

162
00:07:55,610 --> 00:07:57,230
这些都是你要解决的问题 
that are problems for you to solve.

163
00:07:57,230 --> 00:07:59,540
在接下来的几周里 我们将为您提供
And over the weeks to come, we're going to give you

164
00:07:59,540 --> 00:08:03,760
许多工具 包括智力和技术 你可以通过这些工具来解决这些问题 
a lot of tools both mental and technical via which you can solve those problems.

165
00:08:03,760 --> 00:08:07,010
但在第一次编写程序时 请不要气馁
But just don't get discouraged if when writing your program for the first time

166
00:08:07,010 --> 00:08:11,630
它甚至不是第一次起作用 随着时间的推移 通过练习 它会起作用的 
it doesn't even work that first time, it will with time, with practice,

167
00:08:11,630 --> 00:08:12,810
而且有经验 
and with experience.

168
00:08:12,810 --> 00:08:15,200
所以现在让我故意犯一个错误
So let me deliberately now make a mistake

169
00:08:15,200 --> 00:08:18,710
有一个非零的机会 我可能已经意外地做了 
that there was a non-zero chance I might have done accidentally already,

170
00:08:18,710 --> 00:08:19,760
但我很幸运 
but I got lucky.

171
00:08:19,760 --> 00:08:22,280
让我继续说下去 假设我忘了
Let me go ahead and just suppose I forgot

172
00:08:22,280 --> 00:08:24,950
包括诸如右括号之类的内容
to include something like the closing parenthesis

173
00:08:24,950 --> 00:08:26,570
在此行代码的末尾 
at the end of this line of code.

174
00:08:26,570 --> 00:08:30,451
代码几乎是正确的 大概有99%是正确的 
The code is almost correct, it's like 99% of the way there,

175
00:08:30,451 --> 00:08:32,659
但现在我已经指出了这一点 很明显
but now that I've pointed it out, it's pretty obvious

176
00:08:32,659 --> 00:08:34,820
它漏掉了那个右括号 
that it's missing that closed parenthesis.

177
00:08:34,820 --> 00:08:39,530
但即使是那些看似微不足道的小细节 你和我作为人类
But even little, seemingly minor details like that, that you and I as humans

178
00:08:39,530 --> 00:08:40,740
不会真的在乎 
wouldn't really care about.

179
00:08:40,740 --> 00:08:44,300
如果你正在发送一封电子邮件或一条短信 不管是什么 那只是一个打字错误 
And if you're sending an email or a text message, whatever, it's just a typo.

180
00:08:44,300 --> 00:08:45,605
这没什么大不了的 
It's not that big a deal.

181
00:08:45,605 --> 00:08:47,480
这对计算机来说将是一件大事 
It is going to be a big deal to the computer.

182
00:08:47,480 --> 00:08:49,230
一台计算机将会把你从字面上理解 
A computer is going to take you literally,

183
00:08:49,230 --> 00:08:53,210
如果你没有以语言所期望的方式结束你的思想 
and if you don't finish your thought in the way the language expects,

184
00:08:53,210 --> 00:08:55,380
它根本不一定会运行 
it's not going to necessarily run at all.

185
00:08:55,380 --> 00:08:56,112
那就让我们开始吧 
So let's do this.

186
00:08:56,112 --> 00:08:58,820
我将在这里继续 并清除底部的屏幕
I'm going to go ahead here and clear my screen down at the bottom

187
00:08:58,820 --> 00:09:01,340
这样我就可以重新开始了 我要继续前行
just so I can start fresh, and I'm going to go ahead and run

188
00:09:01,340 --> 00:09:05,420
我的程序的这个版本在进行了更改后删除了
this version of my program after having made that change by deleting

189
00:09:05,420 --> 00:09:06,410
插入语 
the parenthesis.

190
00:09:06,410 --> 00:09:10,490
我将继续在Hello.py中再次输入Python 这一次
I'm going to go ahead and type Python again of Hello.py and this time

191
00:09:10,490 --> 00:09:13,040
当我按回车键时 我希望我能看到你好 世界 
when I hit Enter, I'm hoping I'm going to see hello, world,

192
00:09:13,040 --> 00:09:16,850
但这里我们在屏幕上有一个错误 即所谓的语法
but here we have an error on the screen, a so-called syntax

193
00:09:16,850 --> 00:09:21,140
错误 指的是我在键盘上犯了一个错误 
error, which refers to my having made a mistake at my keyboard.

194
00:09:21,140 --> 00:09:24,030
幸运的是 这一点非常简单 
And this one, fortunately, is pretty straightforward.

195
00:09:24,030 --> 00:09:28,410
它确实说过这个左括号从来没有结束过 
It indeed says that this open parenthesis was never closed.

196
00:09:28,410 --> 00:09:30,945
因此 这可能是相当直观的 
And so that's probably pretty intuitive.

197
00:09:30,945 --> 00:09:33,320
现在我需要做的是 当然 我需要关闭它 
Now what I need to do, I need to, of course, to close it.

198
00:09:33,320 --> 00:09:36,530
不幸的是 有时我们会在接下来的几周里看到错误消息
Unfortunately, sometimes the error messages we'll see in the coming weeks

199
00:09:36,530 --> 00:09:38,840
将不会是那么用户友好的 
are not going to be nearly that user-friendly.

200
00:09:38,840 --> 00:09:41,720
但是 再一次 有经验 有实践 你会吗？
But there too again, with experience, with practice, will you

201
00:09:41,720 --> 00:09:44,360
在调试这类程序方面做得更好 
get better at debugging such programs.

202
00:09:44,360 --> 00:09:46,650
现在让我确保我确实正确地修复了它 
Let me now make sure that I indeed fixed it correctly.

203
00:09:46,650 --> 00:09:50,420
现在让我继续运行Hello.py并按Enter键 瞧 
Let me go ahead and run now Hello.py and hit Enter and, voila,

204
00:09:50,420 --> 00:09:51,890
我们又开始做生意了 
we're back in business.

205
00:09:51,890 --> 00:09:55,430
好吧 让我在这里暂停一下 看看我们现在是否有什么问题
Well let me pause here and see if we have any questions now

206
00:09:55,430 --> 00:10:02,480
关于Python本身、编写或运行这些最简单的程序 
about Python itself, writing, or running even the simplest of these programs.

207
00:10:02,480 --> 00:10:06,890
观众：我可以在Word或Microsoft Excel中编写代码吗？
AUDIENCE: Could I write code inside a word or, for example, Microsoft Excel?

208
00:10:06,890 --> 00:10:09,473
要做到这一点 障碍是什么？
And what's the barrier to doing that?

209
00:10:09,473 --> 00:10:11,390
大卫·马兰：一个非常好的问题 请允许
DAVID MALAN: A really good question, and allow

210
00:10:11,390 --> 00:10:14,630
我要非常明确地对整个互联网说
me to very explicitly say to the entire internet

211
00:10:14,630 --> 00:10:17,810
不应使用Microsoft Word编写代码 
that you should not write code with Microsoft Word.

212
00:10:17,810 --> 00:10:20,480
我提到这一点只是因为它是一种工具 通过它
I mentioned that only because it's a tool via which

213
00:10:20,480 --> 00:10:23,283
你可以写文本 而代码最终只是文本 
you can write text and code is, at the end of the day, just text.

214
00:10:23,283 --> 00:10:24,950
但它不是适合这项工作的工具 
But it's not the right tool for the job.

215
00:10:24,950 --> 00:10:27,890
我们不需要粗体、下划线、段落之类的东西 
We don't need bold facing, underlining, paragraphs and the like.

216
00:10:27,890 --> 00:10:31,580
我们通常想要比Microsoft Word或Google Docs简单得多的东西 
We generally want something much simpler than Microsoft Word or Google Docs.

217
00:10:31,580 --> 00:10:36,110
因此 VS Code只是一个更通用的文本编辑器的例子 
And so VS Code is an example of just a more general purpose text editor.

218
00:10:36,110 --> 00:10:39,110
它在生活中的目的是让你这个人类编辑文本 
Its purpose in life is to allow you, the human, to edit text.

219
00:10:39,110 --> 00:10:42,050
如今 这些文本编辑器提供了更多的功能 
Nowadays these text editors come with many more features.

220
00:10:42,050 --> 00:10:44,600
事实上 您会注意到 即使在我这里的代码中 
In fact, you'll notice that even in my code here,

221
00:10:44,600 --> 00:10:47,570
虽然只有一行字 但还是有一点色彩的 
even though it's just one line, there's a bit of color to it.

222
00:10:47,570 --> 00:10:49,910
对我来说 “打印”这个词是用蓝色显示的 
The word "print" for me is appearing in blue.

223
00:10:49,910 --> 00:10:51,050
括号是黑色的 
The parentheses are black.

224
00:10:51,050 --> 00:10:54,290
我们将看到 随着我们编写更多的代码行 越来越多的行
And we'll see as we write more lines of code, more and more of the lines

225
00:10:54,290 --> 00:10:56,630
将以不同的颜色呈现出来 
will come to life in various colors.

226
00:10:56,630 --> 00:10:58,993
这只是文本编辑器的一个功能 
Now that's just one feature of a text editor.

227
00:10:58,993 --> 00:11:01,910
我们还将看到它具有像这个内置的终端窗口这样的功能 
We'll see too that it has features like this built-in terminal window.

228
00:11:01,910 --> 00:11:05,120
它将有一个内置的工具来调试或发现问题
It's going to have a built-in tool for debugging or finding problems

229
00:11:05,120 --> 00:11:05,780
带着密码 
with code.

230
00:11:05,780 --> 00:11:07,760
而且它现在是一个非常流行的工具 
And it's just a very popular tool nowadays,

231
00:11:07,760 --> 00:11:09,560
但还有很多其他人在那里 
but there are many, many others out there.

232
00:11:09,560 --> 00:11:11,900
欢迎您在本课程及以后的课程中使用它们 
You're welcome to use them for this course and beyond.

233
00:11:11,900 --> 00:11:14,120
我们碰巧在很大程度上用到了这个
We just happen to use this one in large part

234
00:11:14,120 --> 00:11:18,980
这也是因为你现在也可以在云中免费使用VS Code 
too because you can also use VS Code nowadays for free in the cloud.

235
00:11:18,980 --> 00:11:22,190
下面是关于使用Python编程的另一个问题
How about one other question here on programming with Python

236
00:11:22,190 --> 00:11:24,950
或者 你好 更广泛地说 是世界还是语法？
or hello, world or syntax more generally?

237
00:11:24,950 --> 00:11:28,850
观众：是啊 我是想问是不是
AUDIENCE: Yeah I was trying to ask if it's not

238
00:11:28,850 --> 00:11:31,923
可以使用终端窗口运行计算机吗？
possible to run the computer using the terminal window?

239
00:11:31,923 --> 00:11:33,590
大卫·马兰：我想我听到了 是不是--
DAVID MALAN: I think I heard is it not--

240
00:11:33,590 --> 00:11:37,530
是否可以在没有终端窗口的情况下运行该程序？
if it's possible to run the program without the terminal window?

241
00:11:37,530 --> 00:11:38,030
你是不是
Are you--

242
00:11:38,030 --> 00:11:38,540
观众：是的 先生 
AUDIENCE: Yes, sir.

243
00:11:38,540 --> 00:11:39,870
大卫·马兰：好吧 你又为我僵住了 
DAVID MALAN: OK, you froze for me again.

244
00:11:39,870 --> 00:11:41,730
但让我来推断一下问题是什么 
But let me infer what the question is.

245
00:11:41,730 --> 00:11:44,660
所以在这个环境中 当我配置我的计算机时 
So in this environment, as I've configured my computer,

246
00:11:44,660 --> 00:11:48,320
我只能通过终端窗口运行这些Python程序 
I can only run these Python programs via the terminal window.

247
00:11:48,320 --> 00:11:51,140
这对我 程序员 或者
Now that's good for me, the programmer, or the person who's

248
00:11:51,140 --> 00:11:53,390
我想学习编程 但并不是很好
trying to learn how to program, but it's not very good

249
00:11:53,390 --> 00:11:57,050
如果你想发布这个软件并让其他人使用你的实际代码 
if you want to ship this software and have other people use your actual code.

250
00:11:57,050 --> 00:12:01,550
你完全可以编写程序 然后让其他人使用 
You can absolutely write programs and then allow other people to use,

251
00:12:01,550 --> 00:12:05,300
不是命令行界面 而是图形用户界面或GUI--
not a command line interface, but a graphical user interface or GUI--

252
00:12:05,300 --> 00:12:08,390
GU I这只是一种机制 我认为 
G-U-I. This is just one mechanism and perhaps, I think,

253
00:12:08,390 --> 00:12:10,700
最好的开始写代码的方法
the best one with which to start writing code

254
00:12:10,700 --> 00:12:14,045
因为最终它会给我们更多的控制权 
because eventually it's going to give us a lot more control.

255
00:12:14,045 --> 00:12:15,920
请允许我在这里继续前进 但请感受到
Allow me to forge ahead here, but please feel

256
00:12:15,920 --> 00:12:19,820
自由地继续提问 如果只是通过聊天的方式 
free to continue asking questions along the way if only via the chat.

257
00:12:19,820 --> 00:12:23,690
现在让我们考虑一下如何改进这个程序 
Let's consider now how we might go about improving this program.

258
00:12:23,690 --> 00:12:27,530
让我们来改进这个程序 使它更具互动性
Let's go about improving this program to make it a little more interactive

259
00:12:27,530 --> 00:12:30,740
而不是假设每个人都想被欢迎
and not just assume that everyone is going to want to be greeted

260
00:12:30,740 --> 00:12:32,120
更通用的名称是hello world 
more generically as hello, world.

261
00:12:32,120 --> 00:12:35,120
让我们看看我能不能让这个程序说一些像你好 大卫
Let's see if I can't get this program to say something like Hello, David

262
00:12:35,120 --> 00:12:40,280
或者你好 耶利米或者你好 霍雷肖或者其他用户的名字 
or Hello, Jeremiah or Hello, Horatio or whatever the actual user's name is.

263
00:12:40,280 --> 00:12:43,670
为了做到这一点 我将回到你好 pi
Well to do this I'm going to go back up to Hello to pi

264
00:12:43,670 --> 00:12:46,950
我会在最上面再加一行代码
and I'm going to add another line of code at the very top that simply says,

265
00:12:46,950 --> 00:12:52,490
比如 你叫什么名字 在末尾多加一个空格 
for instance, what's your name, quote unquote with an extra space at the end.

266
00:12:52,490 --> 00:12:55,530
所以我打印给用户一个问题 
So I'm printing to the user asking them a question for some input,

267
00:12:55,530 --> 00:12:58,940
但现在我需要另一个函数来获取用户的输入 
but now I need another function to actually get input from the user.

268
00:12:58,940 --> 00:13:02,550
而且 完美的是 足够的Python带有一个名为input的函数 
And, perfectly, enough Python comes with a function named input.

269
00:13:02,550 --> 00:13:06,470
所以这里我要继续调用一个函数input open paren 
So here I'm going to go ahead and call a function input, open paren,

270
00:13:06,470 --> 00:13:07,400
近亲 
close paren.

271
00:13:07,400 --> 00:13:11,000
这将提示用户 只是一个闪烁的光标等待
And that's going to prompt the user with just a blinking cursor waiting

272
00:13:11,000 --> 00:13:12,440
让他们输入一些东西
for them to type something in.

273
00:13:12,440 --> 00:13:15,860
如果我读了输入函数的文档 
Now it turns out, if I read the documentation for the input function,

274
00:13:15,860 --> 00:13:18,210
它本身也需要一个参数 
it actually takes an argument itself.

275
00:13:18,210 --> 00:13:21,740
我不需要单独使用“print” 然后提示用户输入 
I don't need to use "print" separately and then prompt the user for input.

276
00:13:21,740 --> 00:13:25,100
所以我可以在我们使用它之前简化这个代码 
So I can actually simplify this code before we even use it.

277
00:13:25,100 --> 00:13:28,430
我要继续从print中取出相同的字符串 
I'm going to go ahead here and take that same string from print,

278
00:13:28,430 --> 00:13:30,800
把它作为输入函数的参数 
put it as an argument to the input function,

279
00:13:30,800 --> 00:13:32,383
彻底摆脱“印刷” 
and get rid of the "print" altogether.

280
00:13:32,383 --> 00:13:34,967
而且 事实上 这个“打印”无论如何都会添加一个新的行 
And, in fact, that "print" would have added a new line anyway.

281
00:13:34,967 --> 00:13:37,340
现在我得到了一个提示 用户的光标在哪里
So now I've just got a prompt where the user's cursor is

282
00:13:37,340 --> 00:13:41,030
最后会在队伍的最后眨眨眼问他们 你叫什么名字？
going to end up blinking at the end of the line asking them, what's your name?

283
00:13:41,030 --> 00:13:46,580
在我的终端窗口中 我将运行Hello.py的Python 回车 
In my terminal window I'm going to run Python of Hello.py, Enter.

284
00:13:46,580 --> 00:13:47,150
好的.
OK.

285
00:13:47,150 --> 00:13:48,150
我们有进展了
We're making progress.

286
00:13:48,150 --> 00:13:51,280
看来这个新的功能输入确实在促使我这个人类 
It seems that this new function input is indeed prompting me, the human,

287
00:13:51,280 --> 00:13:51,780
for input输入.
for input.

288
00:13:51,780 --> 00:13:53,155
所以我要输入我的名字
So I'm going to type in my name--

289
00:13:53,155 --> 00:13:54,290
大卫--按回车键 
David-- and hit Enter.

290
00:13:54,290 --> 00:13:57,440
不幸的是 这和我的名字没什么关系
Unfortunately, it doesn't really do anything with my name,

291
00:13:57,440 --> 00:13:59,240
它会立即输出 
it just outputs it immediately.

292
00:13:59,240 --> 00:14:01,160
好吧 好吧 我可以解决的 对吧？
All right, well, I could fix this, right?

293
00:14:01,160 --> 00:14:05,480
我可以在第二行把“world”改成“David”
I could go up to line 2 and I could change "world" to "David,"

294
00:14:05,480 --> 00:14:10,310
然后回到我的终端窗口 我可以在Hello.py上输入Python 回车 
and then back in my terminal window here I can do Python of Hello.py, Enter.

295
00:14:10,310 --> 00:14:11,150
你叫什麽名字？
What's your name?

296
00:14:11,150 --> 00:14:12,410
大卫 进来 
David, Enter.

297
00:14:12,410 --> 00:14:13,105
好了
And there we go.

298
00:14:13,105 --> 00:14:14,480
好了 现在我开始行动了 
All right now I'm up and running.

299
00:14:14,480 --> 00:14:17,520
现在我的程序正在按预期工作 
Now my program is working as intended.

300
00:14:17,520 --> 00:14:21,410
当然 这并不是真正的工作 因为预期在这里 
Of course, this isn't really working as intended here.

301
00:14:21,410 --> 00:14:25,070
让我继续假装是我的同事卡特 
Let me go ahead and try pretending to be my colleague, Carter here.

302
00:14:25,070 --> 00:14:26,760
卡特的名字是这个 
Well Carter's name is this.

303
00:14:26,760 --> 00:14:29,927
我会按回车键 然后我会看到 你好 卡特--
I'm going to go ahead and hit Enter and I'll see, of course, Hello, Carter--

304
00:14:29,927 --> 00:14:32,520
显然不是 因为我硬编码了 可以这么说 
well, obviously not, because I've hardcoded, so to speak,

305
00:14:32,520 --> 00:14:35,010
我已经把我的名字写在字符串里了 
I've written literally my name inside of the string.

306
00:14:35,010 --> 00:14:40,040
所以我们现在需要一些方法来获取用户的输入
So we need some way now of actually getting back what the user's input is

307
00:14:40,040 --> 00:14:41,780
并最终用它做些什么 
and doing something with it ultimately.

308
00:14:41,780 --> 00:14:44,930
为此 我们将利用编程的另一个特性 
And for this we're going to leverage another feature of programming,

309
00:14:44,930 --> 00:14:47,510
特别是某些功能的一个特征 即它们
specifically a feature of some functions, which is that they

310
00:14:47,510 --> 00:14:49,850
也可以有返回值 
can have return values as well.

311
00:14:49,850 --> 00:14:52,700
如果你再一次把输入看作是这个动作 
If you think of input as being, again, this action,

312
00:14:52,700 --> 00:14:55,880
这个动词--你实际上可以把它拟人化成一个人 
this verb-- you can actually personify it as maybe a person,

313
00:14:55,880 --> 00:14:58,130
就像你的一个朋友 你问了一个问题
like a friend of yours that you've asked a question of

314
00:14:58,130 --> 00:15:00,797
你让你的朋友去征求别人的意见--
and you've asked your friend to go get input from someone else--

315
00:15:00,797 --> 00:15:02,210
去问问那个人他们的名字 
go ask that person their name.

316
00:15:02,210 --> 00:15:05,630
如果你的朋友回来时知道了那个人的名字 
And if your friend comes back knowing that person's name, well,

317
00:15:05,630 --> 00:15:08,357
如果他们把那个名字还给你不是很好吗？
wouldn't it be nice if they handed that name back to you?

318
00:15:08,357 --> 00:15:10,940
比喻地说 这就是我们需要的功能 
That's kind of what we need metaphorically the function to do,

319
00:15:10,940 --> 00:15:15,200
就是获得用户的输入 然后把它交回给我 这样我 作为程序员 
is get the user's input and then hand it back to me so that I, the programmer,

320
00:15:15,200 --> 00:15:16,610
可以用它做点什么 
can do something with it.

321
00:15:16,610 --> 00:15:19,280
但如果要还给我的话 
But if it's going to be handed back to me,

322
00:15:19,280 --> 00:15:23,060
我有点想把它放在某个地方 这样我就可以把它打印回来了
I kind of want to put it somewhere so that I can then print it back

323
00:15:23,060 --> 00:15:23,720
在屏幕上 
on the screen.

324
00:15:23,720 --> 00:15:26,970
我需要做的相当于拿出一张纸或便利贴 
I need to do the equivalent of take out like a piece of paper or Post-It note,

325
00:15:26,970 --> 00:15:31,040
在这张纸上写下人类说过的话 
write down on this piece of paper what it is the human has said,

326
00:15:31,040 --> 00:15:34,650
这样我就可以将其作为输入输入到打印功能中 
so that I can then feed it into as input that print function.

327
00:15:34,650 --> 00:15:38,120
要做到这一点 我们将需要编程的另一个功能 即
And to do that, we're going to need one more feature of programming, namely

328
00:15:38,120 --> 00:15:38,960
变量 
variables.

329
00:15:38,960 --> 00:15:42,410
可能性是 大多数人都熟悉数学课上的变量
And odds are, most everyone's familiar with variables from math class

330
00:15:42,410 --> 00:15:45,380
很久以前--x y z等等 
way back when-- x and y and z and the like.

331
00:15:45,380 --> 00:15:48,110
嗯 编程也有同样的能力 这种能力
Well, programming has that same capability, this ability

332
00:15:48,110 --> 00:15:51,560
要创建一个变量--在这个例子中 是在计算机的内存中--
to create a variable-- in this case, in the computer's memory--

333
00:15:51,560 --> 00:15:53,100
不仅仅是在一张纸上 
not just on a piece of paper.

334
00:15:53,100 --> 00:15:55,620
该变量可以存储一个值--
And that variable can store a value--

335
00:15:55,620 --> 00:15:58,910
一个数字 一些文本 甚至一个图像或视频或更多 
a number, some text, even an image or video or more.

336
00:15:58,910 --> 00:16:06,740
变量只是计算机内部某个值的容器
A variable is just a container for some value inside of a computer

337
00:16:06,740 --> 00:16:08,300
或者在你自己的程序中 
or inside of your own program.

338
00:16:08,300 --> 00:16:11,303
那么 我该如何用这种方式来表达自己呢？
So how do I go about expressing myself in this way?

339
00:16:11,303 --> 00:16:13,220
我想我要做的是介绍
Well I think what I'm going to do is introduce

340
00:16:13,220 --> 00:16:16,730
一个名称比x或y更有趣的变量 
a variable that's a little more interestingly named than x or y.

341
00:16:16,730 --> 00:16:19,970
我可以这么说--x=输入 
I could just say this-- x = input.

342
00:16:19,970 --> 00:16:23,780
但我将在这里使用一个比典型数学变量更好的名称
But I'm going to use a better name than a typical mathematical variable here

343
00:16:23,780 --> 00:16:26,240
我要把我的变量按字面意思命名为“名称” 为什么？
and I'm going to literally call my variable "name," why?

344
00:16:26,240 --> 00:16:29,073
在编程方面 因为我面前有一个完整的键盘 
Well in programming, because I have a whole keyboard in front of me,

345
00:16:29,073 --> 00:16:32,150
我可以用更具描述性的术语来描述我正在写的东西 
I can use more descriptive terms to describe what it is I'm writing.

346
00:16:32,150 --> 00:16:36,590
然而 现在有机会考虑一段特定的语法 
And now, though, there's an opportunity to consider a specific piece of syntax.

347
00:16:36,590 --> 00:16:39,470
我们看到了圆括号 我们看到了引号 所有这些
We've seen parentheses, we've seen quotes, all of which

348
00:16:39,470 --> 00:16:42,020
在将输入传递给函数时是必需的 
are necessary when passing inputs to a function,

349
00:16:42,020 --> 00:16:47,810
但是这个等号在右边的输入和名字之间
but this equal sign here that's in between input on the right and name

350
00:16:47,810 --> 00:16:49,820
左翼实际上很重要 
on the left is actually important.

351
00:16:49,820 --> 00:16:52,490
从技术上讲 它本身并不是等号 
And it's technically not an equal sign per se.

352
00:16:52,490 --> 00:16:56,060
与其说它意味着平等 不如说它意味着分配 
It doesn't mean equality as much as it means assignment.

353
00:16:56,060 --> 00:16:59,000
因此 在Python和许多编程语言中 
So in Python and many programming languages,

354
00:16:59,000 --> 00:17:01,610
单个等号是赋值运算符
a single equal sign is the assignment operator

355
00:17:01,610 --> 00:17:03,860
具体来说 这意味着 你
and what that means specifically is that, you

356
00:17:03,860 --> 00:17:08,839
我想从右到左分配用户输入的任何内容 
want to assign from right to left whatever the user's input is.

357
00:17:08,839 --> 00:17:14,540
所以等号从右到左复制 不管返回
So the equal sign copies from the right to the left whatever the return

358
00:17:14,540 --> 00:17:17,420
右侧函数的值为 
value of the function on the right is.

359
00:17:17,420 --> 00:17:20,670
因此 输入函数显然是从用户那里获得输入的 
So again, the input function clearly gets input from the user.

360
00:17:20,670 --> 00:17:24,140
这就是为什么我能够输入我的名字或卡特的名字 但它也
That's why I was able to type my name or Carter's, but it also

361
00:17:24,140 --> 00:17:29,390
有点像是在幕后把那个值 那个返回值 交给我
sort of behind the scenes hands that value, that return value, back to me

362
00:17:29,390 --> 00:17:30,230
程序员 
the programmer.

363
00:17:30,230 --> 00:17:33,680
如果我使用等号和变量 不管我怎么称呼它 
And if I use an equal sign and a variable, no matter what I call it,

364
00:17:33,680 --> 00:17:38,460
我可以将该输入存储在该变量中 以便以后重复使用 
I can store that input in that variable so as to reuse it later.

365
00:17:38,460 --> 00:17:40,670
所以现在 坐在计算机内存中的某个地方 
So now, sitting in the computer's memory somewhere,

366
00:17:40,670 --> 00:17:44,870
是包含“David”引号、非引号或“Carter”引号的容器 
is a container containing "David" quote, unquote or "Carter" quote,

367
00:17:44,870 --> 00:17:47,490
不引用 或人类输入的任何内容 
unquote, or whatever the human has typed in.

368
00:17:47,490 --> 00:17:49,280
但在这里 很容易犯错误 
But here it's easy to make a mistake.

369
00:17:49,280 --> 00:17:53,850
假设我决定打印这个名字 所以
Suppose I decide to try to print that name and so

370
00:17:53,850 --> 00:17:57,800
我有种预感 你好 名字 
I kind of on a hunch type in this, hello, name.

371
00:17:57,800 --> 00:18:00,440
只是输入变量的名称 
Just kind of plugging in the name of the variable.

372
00:18:00,440 --> 00:18:05,300
现在让我继续运行Hello.py的Python 然后按Enter键 
Well let me go ahead here and run Python of Hello.py and hit Enter.

373
00:18:05,300 --> 00:18:07,040
这会提示我输入我的名字 
That's going to prompt me for my name.

374
00:18:07,040 --> 00:18:08,207
让我输入我的名字--
And let me type in my name--

375
00:18:08,207 --> 00:18:10,440
D-A-V-I-D 但我还没有按回车键 
D-A-V-I-D. But I haven't hit Enter yet.

376
00:18:10,440 --> 00:18:15,350
也许通过聊天 当我现在按Enter键时 这里会发生什么？
And perhaps via the chat, what's going to happen here when I now hit Enter?

377
00:18:15,350 --> 00:18:17,840
我希望它能说 你好 大卫 
I'm hoping it says, Hello, David.

378
00:18:17,840 --> 00:18:22,580
如果它说Hello world 我会很好 但我不想让它说它实际上是什么
I'd be OK if it says Hello, world, but I don't want it to say what it's actually

379
00:18:22,580 --> 00:18:25,370
我们在聊天中看到的是 
going to say and, yep, what we're seeing in the chat is,

380
00:18:25,370 --> 00:18:28,640
它可能会直接说你好 名字.
well, it's probably going to say literally Hello, name.

381
00:18:28,640 --> 00:18:30,030
所以这并不完全正确 
So that's not quite right.

382
00:18:30,030 --> 00:18:34,250
所以我们需要另一种方法来打印变量的值
So we need another way of printing out the value inside of that variable

383
00:18:34,250 --> 00:18:36,785
而不仅仅是“名字”这个词“
rather than just this word "name."

384
00:18:36,785 --> 00:18:38,910
让我用几种不同的方式来尝试一下 
Well let me try this in a couple of different ways.

385
00:18:38,910 --> 00:18:40,890
让我试着这样做
Let me try this as follows--

386
00:18:40,890 --> 00:18:44,390
让我继续 也许撤销这一点 因为我已经得到了相当不错的
let me go ahead and maybe undo this because I've gotten pretty good already

387
00:18:44,390 --> 00:18:45,550
打招呼 
at saying Hello.

388
00:18:45,550 --> 00:18:48,050
所以我们划清界限 好吧 
So let's draw that line in the sand and just say, all right,

389
00:18:48,050 --> 00:18:50,360
我们至少把你好逗号赶出家门吧 
let's get at least get Hello comma out the door.

390
00:18:50,360 --> 00:18:53,790
现在让我们打印姓名 凭直觉 我将尝试这样做 
Let's now print name and just on a hunch, I'm going to try this.

391
00:18:53,790 --> 00:18:55,115
我将再次使用打印--
I'm going to use print again--

392
00:18:55,115 --> 00:18:57,740
因为你可以根据需要多次使用这些函数
because you can use these functions as many times as you need--

393
00:18:57,740 --> 00:19:02,660
我将把名为name的变量传递给print函数 
and I'm going to pass to the print function the variable called name.

394
00:19:02,660 --> 00:19:04,730
但请注意我现在有点聪明了 
But notice I'm being a little clever now.

395
00:19:04,730 --> 00:19:07,970
我没有把它放在双引号里 因为我们已经看到了双引号
I'm not putting it in double quotes because we've seen already that double

396
00:19:07,970 --> 00:19:10,610
引号的意思是打印出来
quotes means literally print out N-A-M-E.

397
00:19:10,610 --> 00:19:13,700
我这次去掉引号是希望 
I'm getting rid of the quotes this time in hopes that,

398
00:19:13,700 --> 00:19:19,440
现在通过将变量name传递给函数print 
now by passing the variable called name to the function called print it will,

399
00:19:19,440 --> 00:19:23,480
实际上 打印变量的内容 
in fact, go about printing the contents of that variable that is,

400
00:19:23,480 --> 00:19:24,808
所谓的价值 
its so-called value.

401
00:19:24,808 --> 00:19:26,600
好吧 我们就在这里开始吧 
All right, let's go ahead and do this here.

402
00:19:26,600 --> 00:19:29,030
Hello.py的Python 输入 
Python of Hello.py, Enter.

403
00:19:29,030 --> 00:19:30,020
你叫什麽名字？
What's your name?

404
00:19:30,020 --> 00:19:30,590
大卫
David.

405
00:19:30,590 --> 00:19:35,520
现在 我仍然交叉手指 我看到你好逗号大卫 
And now, crossing my fingers still, I see Hello comma David.

406
00:19:35,520 --> 00:19:36,020
好吧
All right.

407
00:19:36,020 --> 00:19:38,090
所以这不是最好的方案 
So it's not the best program.

408
00:19:38,090 --> 00:19:40,670
可以说 我是在偷工减料 
I'm kind of cutting some corners here, so to speak.

409
00:19:40,670 --> 00:19:44,128
我在两条线上说你好 大卫 
I'm saying Hello, David on two separate lines.

410
00:19:44,128 --> 00:19:45,920
所以它不那么优雅 不那么漂亮 
So it's not as elegant, it's not as pretty,

411
00:19:45,920 --> 00:19:48,950
在英语中 它不像直接说出来那样符合语法
it's not as grammatically appropriate in English as just saying it

412
00:19:48,950 --> 00:19:52,820
所有在一个呼吸在一行 但至少我已经解决了这个问题 只是没有
all in one breath on one line, but at least I've solved the problem, just not

413
00:19:52,820 --> 00:19:54,020
还很好 
very well yet.

414
00:19:54,020 --> 00:19:56,390
但现在让我退一步 
But let me take a step back now and perhaps introduce

415
00:19:56,390 --> 00:19:59,070
我们应该熟悉的其他几个概念 
a couple of other concepts with which we should be familiar,

416
00:19:59,070 --> 00:20:03,260
这是因为我们的程序变得更长 它们不再只有一两行
which is as our programs get longer and they're no longer just one line or two

417
00:20:03,260 --> 00:20:07,370
甚至三个 我们的节目最终会变成几十行 
or even three, eventually our programs are going to become dozens of lines,

418
00:20:07,370 --> 00:20:09,020
甚至可能有数百行之长 
maybe even hundreds of lines long.

419
00:20:09,020 --> 00:20:11,990
让我们为未来的成功铺平道路 
Let's set the stage for success moving forward.

420
00:20:11,990 --> 00:20:14,840
事实证明 Python和许多编程语言
It turns out that Python and a lot of programming languages

421
00:20:14,840 --> 00:20:17,120
也支持一种叫做评论的东西 
also support something called comments.

422
00:20:17,120 --> 00:20:21,200
注释是代码中对您自己的注释
Comments are notes to yourself in your code

423
00:20:21,200 --> 00:20:24,260
并且您可以通过特殊符号--在Python中--来包含注释
and you include comments by way of a special symbol-- in Python

424
00:20:24,260 --> 00:20:26,150
它将是散列符号 通常是--
it's going to be the hash symbol, typically--

425
00:20:26,150 --> 00:20:27,980
这样你就可以写出等价的
and that allows you to write the equivalent

426
00:20:27,980 --> 00:20:30,950
一张纸条给你自己 但不会破坏你的代码 
of a note to yourself but in a way that's not going to break your code.

427
00:20:30,950 --> 00:20:33,380
电脑实际上会忽略你的评论 
The computer actually ignores your comment.

428
00:20:33,380 --> 00:20:36,030
它就在你的身边 就在你的老师身边 
It's just there for you, it's just there for your teacher,

429
00:20:36,030 --> 00:20:38,030
它就在那里 只等着你的同事
it's just there for your colleague with whom

430
00:20:38,030 --> 00:20:40,020
你最终是在分享这段代码 
you're sharing ultimately that code.

431
00:20:40,020 --> 00:20:42,320
所以如果我回到这里的VS代码 我只是
So if I go back to VS Code here and I just

432
00:20:42,320 --> 00:20:46,040
我想给这个节目添加一些评论 向我的老师解释一下 
want to add some comments to this program to explain to my teacher,

433
00:20:46,040 --> 00:20:49,325
对我自己 对我的同事们 这个项目正在做的事情 
to myself, to my colleagues what this program is doing,

434
00:20:49,325 --> 00:20:50,700
好吧 那我们就这么做吧 
well, let's go ahead and do that.

435
00:20:50,700 --> 00:20:54,020
我将在我的程序的最顶端 在第一行
I'm going to go at the very top of my program and on line 1

436
00:20:54,020 --> 00:20:56,990
现在 我将把原来的代码行向下移动一点 
now I'm going to move that original line of code down a bit,

437
00:20:56,990 --> 00:21:00,530
我将添加一个散列 我将这样说 
I'm going to add a hash, and I'm going to say something like this,

438
00:21:00,530 --> 00:21:03,210
要求用户输入他们的姓名 
ask user for their name.

439
00:21:03,210 --> 00:21:05,040
现在 我不需要用那种语言 
Now, I don't have to use that language.

440
00:21:05,040 --> 00:21:06,950
我不需要用那条短信 
I don't have to use that text.

441
00:21:06,950 --> 00:21:08,910
我可以使用任何人类语言 
I could use any human language whatsoever.

442
00:21:08,910 --> 00:21:10,250
它不一定是英语 
It doesn't have to be English.

443
00:21:10,250 --> 00:21:14,120
但我现在要说的是 在那个下面 只说这样的话--
But I'm going to now, below that, just say something like this--

444
00:21:14,120 --> 00:21:16,012
向用户问好 
say Hello to user.

445
00:21:16,012 --> 00:21:17,720
您会注意到 默认情况下 VS代码
And you'll notice that VS Code by default

446
00:21:17,720 --> 00:21:19,302
让我的评论变灰了 
is kind of graying out my comments.

447
00:21:19,302 --> 00:21:22,010
它们不再是蓝色 不再是红色 也不再是颜色 
They're no longer blue, there's no red, there's no color in them.

448
00:21:22,010 --> 00:21:24,240
这只是因为它们是对我自己的笔记
And that's just because they're notes to myself

449
00:21:24,240 --> 00:21:26,730
而计算机最终会忽略它们 
and the computer ultimately is going to ignore them.

450
00:21:26,730 --> 00:21:29,350
但我们现在有两条评论--询问用户
But what we have now is two comments-- ask user

451
00:21:29,350 --> 00:21:32,380
对于他们的名字 然后是第二条评论 向用户问好 
for their name and then a second comment, say Hello to user.

452
00:21:32,380 --> 00:21:35,590
我刚刚注释了每一段代码 
And I've just kind of commented each chunk of code,

453
00:21:35,590 --> 00:21:40,180
就像每一行或多行复数代码一样 它们正在做一些值得注意的事情 
like each line or lines plural of code, that are doing something noteworthy.

454
00:21:40,180 --> 00:21:40,750
为什么？
Why?

455
00:21:40,750 --> 00:21:43,120
好吧 明天早上当我醒来的时候
Well, tomorrow morning when I wake up having

456
00:21:43,120 --> 00:21:47,740
睡了好一阵子 忘了前一天做了什么 
slept for quite some time, forgotten what it is I did the previous day,

457
00:21:47,740 --> 00:21:49,840
评论很方便 只需查看
it's convenient with comments to just see

458
00:21:49,840 --> 00:21:52,510
用英语或你自己的人类语言
in English or your own human language what

459
00:21:52,510 --> 00:21:55,810
这是一个程序 这样你就不需要阅读代码本身了
it is this program is doing so that you don't have to read the code itself

460
00:21:55,810 --> 00:21:59,200
而且 更好的是 如果未来可能出现错误 
and, better yet, if there's maybe a mistake down the road,

461
00:21:59,200 --> 00:22:02,740
您可以阅读您的意图 然后您可以查看代码
you can read what your intention was and then you can look at the code

462
00:22:02,740 --> 00:22:06,050
并确定您的代码现在是否正在执行您想要的操作 
and figure out if your code is now doing what you intended.

463
00:22:06,050 --> 00:22:08,920
因此 对于这么小的程序来说 这并不是真正必要的 
So this isn't really necessary for a program this small.

464
00:22:08,920 --> 00:22:11,287
很明显 只有一行、两行或三行
It's pretty obvious with just one or two or three lines

465
00:22:11,287 --> 00:22:12,370
程序在做什么 
what the program is doing.

466
00:22:12,370 --> 00:22:14,668
阅读代码的速度和阅读注释一样快 
It's just as fast to read the code than the comments,

467
00:22:14,668 --> 00:22:16,960
但养成这个习惯通常是一件好事--
but getting into this habit is generally a good thing--

468
00:22:16,960 --> 00:22:21,220
每隔一行或几行注释代码 以提醒自己
to comment your code every one or a few lines so as to remind yourself

469
00:22:21,220 --> 00:22:24,250
以及其他是您的意图和您的代码正在做什么 
and others what it is your intent and your code is doing.

470
00:22:24,250 --> 00:22:26,590
评论的好处也在于--
What's nice about comments too is this--

471
00:22:26,590 --> 00:22:30,940
评论也可以成为你自己的待办事项清单 
comments can also serve to be sort of a to-do list for yourself.

472
00:22:30,940 --> 00:22:33,850
在伪代码编程中有这样一个概念 
There's this notion in programming of pseudocode.

473
00:22:33,850 --> 00:22:35,350
伪码不是一种正式的东西 
Pseudocode isn't a formal thing.

474
00:22:35,350 --> 00:22:37,300
它不是一种特定的语言 
It's not one specific language.

475
00:22:37,300 --> 00:22:40,090
它只是使用英语或你自己的人类语言
It's just using English or your own human language

476
00:22:40,090 --> 00:22:44,590
简洁、有条不紊、有算法地表达你的想法 
to express your thoughts succinctly, methodically, algorithmically,

477
00:22:44,590 --> 00:22:45,460
可以这么说 
so to speak.

478
00:22:45,460 --> 00:22:48,070
但是伪代码 因此 因为它不是Python
But pseudocode, therefore, because it's not Python

479
00:22:48,070 --> 00:22:51,130
它不一定是英语 它只是一种允许
and it's not necessarily English, it just kind of allows

480
00:22:51,130 --> 00:22:53,520
你甚至需要提前概述你的计划.
you to outline your program even in advance.

481
00:22:53,520 --> 00:22:56,532
举个例子 如果我今天不确定如何
So for instance, if I wasn't sure today how

482
00:22:56,532 --> 00:22:58,240
我想着手写这个程序
I wanted to go about writing this program

483
00:22:58,240 --> 00:23:01,720
但我不知道我想做什么 我本可以从今天开始
but I didn't know what I wanted to do, I could have started today

484
00:23:01,720 --> 00:23:04,570
只需在Hello.py中编写这段代码 
by just writing this in Hello.py.

485
00:23:04,570 --> 00:23:07,870
没有代码 我可以只对自己写几条评论--
No code, I could have written just a couple of comments to myself--

486
00:23:07,870 --> 00:23:09,460
步骤1 询问用户姓名 
Step 1, ask user for their name.

487
00:23:09,460 --> 00:23:11,440
第二步 向用户问好 
Step 2, say Hello to user.

488
00:23:11,440 --> 00:23:15,520
然后 一旦我用伪代码概述了我的程序 然后我就可以进去了
Then once I've outlined my program in pseudocode, then I can go in there

489
00:23:15,520 --> 00:23:18,190
然后说 好吧 我怎么向用户询问他们的名字呢？
and say, all right, how do I ask the user for their name?

490
00:23:18,190 --> 00:23:21,910
好吧 我可以输入“你叫什么名字”的问题？
Well, I can do input "what's your name" question?

491
00:23:21,910 --> 00:23:26,080
然后在左边 我可以放一个变量 然后把它赋值给它 
And then on the left here, I can maybe put a variable and assign it to that.

492
00:23:26,080 --> 00:23:27,730
好的 我该如何向用户问好呢？
OK, how do I say Hello to the user?

493
00:23:27,730 --> 00:23:30,280
嗯 我知道我可以用印刷体在屏幕上说些什么 
Well, I know I can use print to say things on the screen.

494
00:23:30,280 --> 00:23:32,920
让我打个招呼 让我--
Let me say hello, and let me--

495
00:23:32,920 --> 00:23:35,210
好的 现在让我把这个人的名字打印出来 
OK, let me now print the person's name.

496
00:23:35,210 --> 00:23:38,960
因此 伪代码是构建待办事项列表的一种很好的方式 
So again, pseudocode is a nice way of structuring your to-do list,

497
00:23:38,960 --> 00:23:41,680
尤其是如果您不知道如何编写代码 
especially if you have no idea how to write the code,

498
00:23:41,680 --> 00:23:45,993
因为它将一个较大的程序分解成几个小任务 
because it breaks a bigger program down into small bite-sized tasks.

499
00:23:45,993 --> 00:23:48,160
好吧 让我在这里停一下 看看现在有没有
All right, let me pause here to see if there are now

500
00:23:48,160 --> 00:23:56,390
有关注释、伪代码、返回值或变量的任何问题 
any questions on comments, pseudocode, return values, or variables.

501
00:23:56,390 --> 00:23:59,170
有什么问题我们可以在这里说清楚吗？
Any questions we can clear up here?

502
00:23:59,170 --> 00:24:02,500
听众：是的 我的问题是功能输入
AUDIENCE: Yeah, my question is does the function input

503
00:24:02,500 --> 00:24:06,843
为任何类型的信息工作 还是只为文字工作？
work for any type of information, or only for words?

504
00:24:06,843 --> 00:24:08,510
大卫·马兰：是的 这个问题问得很好 
DAVID MALAN: Yeah, really good question.

505
00:24:08,510 --> 00:24:12,070
所以根据它的文档 我们将更多地查看正式文档
So according to its documentation, and we'll look more at formal documentation

506
00:24:12,070 --> 00:24:14,290
很快 输入将会期待所谓的
soon, input is going to expect what's called

507
00:24:14,290 --> 00:24:16,900
一个字符串 那是一个文本序列 不管它是什么
a string, that is a sequence of text, be it

508
00:24:16,900 --> 00:24:19,030
用英语或任何其他人类语言 
in English or any other human language.

509
00:24:19,030 --> 00:24:23,660
但它确实会期待用来提示用户的文本 
But it's indeed going to be expecting text with which to prompt the user.

510
00:24:23,660 --> 00:24:24,340
问得好 
A good question.

511
00:24:24,340 --> 00:24:26,632
如果可以的话 小组里的另一个问题怎么样？
How about another question from the group, if we could?

512
00:24:26,632 --> 00:24:30,520
观众：我想问的是 我该如何发表几行评论呢？
AUDIENCE: I wanted to ask how would I make a several line comment?

513
00:24:30,520 --> 00:24:32,770
大卫·马兰：哦 你是怎么做很多评论的 
DAVID MALAN: Oh, how do you do many lines of comments,

514
00:24:32,770 --> 00:24:34,000
如果我没听错的话？
if I'm hearing you correctly?

515
00:24:34,000 --> 00:24:34,330
观众：是的 
AUDIENCE: Yes.

516
00:24:34,330 --> 00:24:35,290
大卫·马兰：当然 
DAVID MALAN: Sure.

517
00:24:35,290 --> 00:24:38,380
你就会一直这样做下去 
You would just keep doing them like this.

518
00:24:38,380 --> 00:24:43,300
您只需为每行添加一个散列符号前缀 就像我在这里所做的那样 
You just prefix each of the lines with a hash symbol, like I'm doing here.

519
00:24:43,300 --> 00:24:46,990
还有另一种在Python中执行多行注释的技术 即
There is another technique for doing multi-line comments in Python that

520
00:24:46,990 --> 00:24:48,670
实际上往往有特殊的含义 
actually tend to have special meaning.

521
00:24:48,670 --> 00:24:53,650
你可以像这样做三个双引号 然后在这里做任何中间的事情
You can do three double quotes like this and then anything in between here

522
00:24:53,650 --> 00:24:54,910
是一种评论 
is a comment.

523
00:24:54,910 --> 00:24:55,960
这是另一种技术 
That's another technique.

524
00:24:55,960 --> 00:24:57,502
或者 您也可以使用单引号 
Or you can use single quotes as well.

525
00:24:57,502 --> 00:25:00,257
但我认为 下次会有更多关于这些的内容 
But more on those, I think, another time.

526
00:25:00,257 --> 00:25:02,590
好吧 好吧 你不会介意的 让我继续
All right, well, you don't mind, let me forge ahead here

527
00:25:02,590 --> 00:25:05,290
看看我们可以如何进一步改进这个项目
and see how we might improve this program further

528
00:25:05,290 --> 00:25:07,570
还介绍了一些其他功能 我们可能
and also introduce a few other features that we might

529
00:25:07,570 --> 00:25:10,100
想要考虑到随着时间的推移 
want to take into account over time.

530
00:25:10,100 --> 00:25:13,270
所以事实证明 我们肯定可以改进这个项目
So it turns out that we can certainly improve on this program

531
00:25:13,270 --> 00:25:17,020
因为我在这里偷工减料有点令人失望
because it's a little disappointing that I'm cutting this corner

532
00:25:17,020 --> 00:25:20,680
然后说你好 逗号 然后在新的一行打印出名字 
and saying Hello comma and then on a new line printing out name.

533
00:25:20,680 --> 00:25:21,700
好像我们能做得更好 
Like we can do better.

534
00:25:21,700 --> 00:25:24,760
当然 你在手机或笔记本上使用的大多数程序
And most programs you use on your phone or your laptop certainly

535
00:25:24,760 --> 00:25:26,810
当人们需要时 将文本放在一起 
keep text together when people want.

536
00:25:26,810 --> 00:25:28,243
那么 我们该如何着手做这件事呢？
So how can we go about doing that?

537
00:25:28,243 --> 00:25:29,660
嗯 有几种不同的方法 
Well there's a few different ways.

538
00:25:29,660 --> 00:25:32,890
事实上 这里的目标并不是要解决这个问题 
And in fact, the goal here is not so much to solve this one problem,

539
00:25:32,890 --> 00:25:35,290
但为了在编程中演示和强调这一点--
but to demonstrate and emphasize that in programming--

540
00:25:35,290 --> 00:25:38,080
Python和其他语言--有很多方法
Python and other languages-- there's so many ways

541
00:25:38,080 --> 00:25:40,690
有时是为了解决同样的问题 
sometimes to solve the same problem.

542
00:25:40,690 --> 00:25:42,830
这里有一个解决这个问题的方法 
And here's one way to solve this problem.

543
00:25:42,830 --> 00:25:48,100
让我进去 现在让我来打个招呼 
Let me go in here and let me go ahead now and say hello,

544
00:25:48,100 --> 00:25:52,450
让我在该用户名的末尾添加 
and let me just add to the end of that the user's name.

545
00:25:52,450 --> 00:25:54,980
所以我正在以一种有趣的方式使用+ 
So I'm using + in kind of an interesting way.

546
00:25:54,980 --> 00:25:56,560
本质上 这不是加法 
This is not addition, per se.

547
00:25:56,560 --> 00:25:59,290
很明显 我不是在加数字 但我确实加了
I'm not adding numbers, obviously, but I do

548
00:25:59,290 --> 00:26:04,840
我想把这个人的名字加到逗号字符串中 
kind of want to add the person's name to the string of text Hello comma.

549
00:26:04,840 --> 00:26:08,830
现在让我转到我的终端窗口并运行Hello.py的Python
Well let me go now down to my terminal window and run Python of Hello.py

550
00:26:08,830 --> 00:26:10,000
再次输入 
again, Enter.

551
00:26:10,000 --> 00:26:10,750
你叫什么名字？
What's your name?

552
00:26:10,750 --> 00:26:11,920
我要把大卫打进去 
I'm going to type in David.

553
00:26:11,920 --> 00:26:12,940
进来吧 
Enter.

554
00:26:12,940 --> 00:26:14,260
好了 好多了 
OK, it's better.

555
00:26:14,260 --> 00:26:18,160
这是更好的 但有一个小错误 尽管这里的美学 
It's better, but there's a minor bug, albeit aesthetic here.

556
00:26:18,160 --> 00:26:20,830
这里缺少空白处 但让我们在这里使用一些直觉 
There's missing space, but let's just use some intuition here.

557
00:26:20,830 --> 00:26:22,900
好吧 如果我漏掉了逗号后面的空格 
Well, if I'm missing the space after the comma,

558
00:26:22,900 --> 00:26:25,780
为什么我不在这里手动添加它呢？
why don't I go ahead and just add it manually here.

559
00:26:25,780 --> 00:26:30,670
现在让我重新运行程序Hello.py的Python Enter David Enter 
Let me now rerun the program Python of Hello.py, Enter, David, Enter.

560
00:26:30,670 --> 00:26:31,540
这就对了 
And there we go.

561
00:26:31,540 --> 00:26:33,400
现在我们有了一些看起来更漂亮的东西
Now we have something that looks a little prettier

562
00:26:33,400 --> 00:26:34,570
在英语语法方面 
in terms of English grammar.

563
00:26:34,570 --> 00:26:36,640
你好 逗号 空格 大卫 
Hello, comma, space, David.

564
00:26:36,640 --> 00:26:40,060
现在如果我们倒带 你可能已经注意到了
And now if we rewind, you might have noticed before

565
00:26:40,060 --> 00:26:45,100
或者想知道为什么我的问号后面有这个看似多余的空格 
or wondered why I had this seemingly extra space after my question mark,

566
00:26:45,100 --> 00:26:45,940
也就是这里 
namely here.

567
00:26:45,940 --> 00:26:48,790
问号后、双引号前有一个空格
There's a space after the question mark but before the double quote

568
00:26:48,790 --> 00:26:50,332
这也只是为了美观 
and that was just for aesthetics too.

569
00:26:50,332 --> 00:26:53,315
我想将用户的光标向右移动一个空间
I wanted to move the user's cursor one space to the right

570
00:26:53,315 --> 00:26:55,690
所以当我输入他们的名字或他们输入他们的名字时 
so that when I typed their name or they typed their name,

571
00:26:55,690 --> 00:26:59,650
它不是紧挨着那个问号的 
it's not immediately next to that same question mark there.

572
00:26:59,650 --> 00:27:01,790
但我们还有其他方法可以做到这一点 
But there's other ways we can do this.

573
00:27:01,790 --> 00:27:05,080
事实证明 一些函数 其中包括打印 
It turns out that some functions, print among them,

574
00:27:05,080 --> 00:27:07,570
实际上有多个论据 
actually take multiple arguments.

575
00:27:07,570 --> 00:27:11,200
事实证明 如果你把输入分离出来
And it turns out that if you separate the inputs

576
00:27:11,200 --> 00:27:14,620
函数--即函数的所谓参数--加上逗号 
to a function-- the so-called arguments to a function-- with a comma,

577
00:27:14,620 --> 00:27:19,250
你不能只传一次 还可以传两次 三次 四次 五次 往前 
you can pass in not just one, but two, three, four, five, onward.

578
00:27:19,250 --> 00:27:24,970
所以让我继续下去 不仅仅是你好 逗号 空格 还有随后的
So let me go ahead and pass in not just hello, comma, space, but that followed

579
00:27:24,970 --> 00:27:25,660
叫出名字 
by name.

580
00:27:25,660 --> 00:27:27,880
乍一看 这可能有点令人困惑
And this is a little confusing potentially at first glance

581
00:27:27,880 --> 00:27:30,297
因为现在我有两个逗号 但需要注意的是
because now I've got two commas but it's important to note

582
00:27:30,297 --> 00:27:35,800
第一个逗号在我的引号内 这只是
that the first comma is inside of my quotation marks, which is simply

583
00:27:35,800 --> 00:27:37,490
一种符合英语语法的东西 
an English grammatical thing.

584
00:27:37,490 --> 00:27:40,270
第二个逗号在引号之外 
The second comma here is outside of the quotes,

585
00:27:40,270 --> 00:27:44,170
但现在有两种不同的论据需要发表 
but between what are now two separate arguments to print.

586
00:27:44,170 --> 00:27:46,270
第一个参数是Hello、逗号、空格 
The first argument is hello, comma, space.

587
00:27:46,270 --> 00:27:49,490
第二个参数是名称变量本身 
The second argument is the name variable itself.

588
00:27:49,490 --> 00:27:51,640
所以让我们来看看这是什么样子 
So let's see how this looks.

589
00:27:51,640 --> 00:27:53,620
Python of Hello.py 回车 
Python of Hello.py, Enter.

590
00:27:53,620 --> 00:27:54,460
你叫什么名字？
What's your name?

591
00:27:54,460 --> 00:27:55,060
大卫 
David.

592
00:27:55,060 --> 00:27:56,050
进来吧 
Enter.

593
00:27:56,050 --> 00:27:57,910
好吧 我有点矫枉过正了 
OK, I've kind of over-corrected.

594
00:27:57,910 --> 00:28:00,040
出于某种原因 我现在有两个车位 
Now I've got two spaces for some reason.

595
00:28:00,040 --> 00:28:02,080
事实证明 这是微妙的 当
Well, it turns out, and this is subtle, when

596
00:28:02,080 --> 00:28:07,960
您将多个参数传递给print 它会自动为您插入一个空格 
you pass multiple arguments to print, it automatically inserts a space for you.

597
00:28:07,960 --> 00:28:10,270
这件事之前并不重要 因为我
This was not relevant earlier because I was

598
00:28:10,270 --> 00:28:16,510
通过使用+运算符 传入一个大参数以一次性打印所有内容 
passing in one big argument to print all at once by using that + operator.

599
00:28:16,510 --> 00:28:19,070
这一次 由于逗号的原因 我传入了两个 
This time I'm passing in two because of the comma.

600
00:28:19,070 --> 00:28:23,210
因此 如果我不想要额外的空间 我不需要自己传递一个空间 
So if I don't want that extra space, I don't need to pass in one myself,

601
00:28:23,210 --> 00:28:26,530
我可以这样做 现在注意到 如果我再次运行这个程序--
I can just do this and now notice, if I run this program again--

602
00:28:26,530 --> 00:28:29,560
Python of Hello.py 输入我的名字David 
Python of Hello.py, type in my name David,

603
00:28:29,560 --> 00:28:32,620
现在 从语法上看 它可能是我想要的 
now it looks grammatically like I might want.

604
00:28:32,620 --> 00:28:34,330
现在 这些方法中哪一种更好？
Now which of these approaches is better?

605
00:28:34,330 --> 00:28:37,840
这种方法使用带有两个参数的函数print--
This approach uses a function print with two arguments--

606
00:28:37,840 --> 00:28:40,810
你好 逗号和名称变量 
Hello, comma and the name variable.

607
00:28:40,810 --> 00:28:44,195
之前的版本 Recall 技术上使用了一个论点 
The previous version, recall, technically used one argument,

608
00:28:44,195 --> 00:28:45,820
尽管它看起来有点奇怪 
even though it looked a little curious.

609
00:28:45,820 --> 00:28:49,270
这是一种观点 计算机就像数学家一样 
It's one argument in the sense that the computer, just like mathematicians,

610
00:28:49,270 --> 00:28:51,950
我们首先要做的是括号内的内容 
are going to do what's inside of parentheses first.

611
00:28:51,950 --> 00:28:54,670
所以如果你在圆括号里有这串文字--
So if inside of parentheses you have this string of text--

612
00:28:54,670 --> 00:28:58,350
你好 逗号和空格 我需要添加回来 
hello, comma, and a space, which I need to add back.

613
00:28:58,350 --> 00:29:01,050
然后你有一个+ 这意味着本身不是加法 
Then you have a +, which means not addition, per se,

614
00:29:01,050 --> 00:29:05,400
而是串联--把左边的东西和右边的东西连接起来 
but concatenation-- to join the thing on the left and the thing on the right.

615
00:29:05,400 --> 00:29:08,400
这最终变成了英语短语--
This ultimately becomes the English phrase--

616
00:29:08,400 --> 00:29:10,890
你好 逗号 空格 大卫 
Hello, comma, space, David.

617
00:29:10,890 --> 00:29:14,400
然后最终传递给函数的是什么
And then what's being passed ultimately to the function

618
00:29:14,400 --> 00:29:18,870
从技术上讲是这样的 但它完全是动态的 
is technically something like this, but it's doing it all dynamically.

619
00:29:18,870 --> 00:29:23,860
这不是我像之前那样小心翼翼地输入大卫 
It's not me typing in David as I discreetly did earlier.

620
00:29:23,860 --> 00:29:27,930
它会动态计算出连接Hello后的值
It's figuring out dynamically what that value is after concatenating Hello

621
00:29:27,930 --> 00:29:30,900
使用名称的值 然后最终传递
with the value of name and then passing that ultimately

622
00:29:30,900 --> 00:29:33,750
作为唯一的论据发表 
to print as the sole argument.

623
00:29:33,750 --> 00:29:38,130
让我在这里暂停一下 看看是否有任何关于论点数量的问题
Let me pause here to see if there's any questions on numbers of arguments

624
00:29:38,130 --> 00:29:41,250
现在 让我们来谈谈功能 
now to functions.

625
00:29:41,250 --> 00:29:43,950
观众：我们可以多次使用一个函数吗
AUDIENCE: Can we use a function many times

626
00:29:43,950 --> 00:29:48,765
来解决我们在代码中可能多次遇到的某个问题？
to solve a certain problem which we can encounter many times in our code?

627
00:29:48,765 --> 00:29:49,640
大卫·马兰：你可以的 
DAVID MALAN: You can.

628
00:29:49,640 --> 00:29:52,700
您可以多次使用一个函数来解决某些问题 
You can use a function many different times to solve some problem.

629
00:29:52,700 --> 00:29:55,040
不过 我们很快就会看到 如果你发现自己
What we'll soon see, though, is if you find yourself

630
00:29:55,040 --> 00:29:58,620
当程序员再次以相同的方式解决问题时 
as the programmer solving a problem the same way again,

631
00:29:58,620 --> 00:30:00,560
再一次 一次又一次 事实证明你会
and again, and again, it turns out you'll

632
00:30:00,560 --> 00:30:02,450
能够做出自己的功能 这样你就可以
be able to make your own function so that you

633
00:30:02,450 --> 00:30:07,130
不必一直重复使用语言附带的基本功能 
don't have to keep reusing the basic ones that come with the language.

634
00:30:07,130 --> 00:30:10,890
观众：我对逗号和+号很好奇 
AUDIENCE: I was curious about the comma and the + sign.

635
00:30:10,890 --> 00:30:15,320
所以在+号之后 我们能不能只给出一个变量 在逗号之后再给我们
So after + sign, can we give just one variable and after comma again we

636
00:30:15,320 --> 00:30:17,180
是否提供多变量状态？
give multiple variable status?

637
00:30:17,180 --> 00:30:18,470
有什么关系？
What is the difference?

638
00:30:18,470 --> 00:30:19,678
大卫·马兰：问得好 
DAVID MALAN: A good question.

639
00:30:19,678 --> 00:30:21,320
因此 在弦的上下文中--
So in the context of strings--

640
00:30:21,320 --> 00:30:22,640
我一直在用这个词 
and I keep using that term.

641
00:30:22,640 --> 00:30:25,130
“字符串”是编程语言中的一个技术术语
"String" is a technical term in a programming language

642
00:30:25,130 --> 00:30:29,570
同样 它意味着一系列文本--一个字符 一个单词 整个段落 
and again, it means a sequence of text-- a character, a word, a whole paragraph,

643
00:30:29,570 --> 00:30:30,080
不相上下 
even.

644
00:30:30,080 --> 00:30:33,650
所以不只是使用+运算符 我们将
So the + operator is not just used, as we'll

645
00:30:33,650 --> 00:30:37,790
看 对于在Python中的数字加法 就像我们在纸铅笔上做的那样 
see, for addition of numbers in Python, like we do on paper pencil,

646
00:30:37,790 --> 00:30:41,760
但它也用于连接左侧和右侧的字符串 
but it also is used for concatenation of strings on the left and the right.

647
00:30:41,760 --> 00:30:44,180
如果你想组合的不只是两根弦--
If you did want to combine not just two strings--

648
00:30:44,180 --> 00:30:46,310
左和右--但第三和第四个 
left and right-- but a third and a fourth,

649
00:30:46,310 --> 00:30:51,380
您完全可以继续使用+、+ 并将它们链接在一起
you can absolutely keep using +, +, +, +, and chain them together

650
00:30:51,380 --> 00:30:52,460
就像在数学里一样 
just like in math.

651
00:30:52,460 --> 00:30:54,830
最终 这会开始看起来有点丑陋 
Eventually that's going to start to look a little ugly,

652
00:30:54,830 --> 00:30:57,080
我敢说 特别是当您的代码行变得很长的时候 
I dare say, especially if your line of code gets long.

653
00:30:57,080 --> 00:31:00,200
所以有更好的方法 我们很快就会看到 
So there's better ways that we'll actually soon see.

654
00:31:00,200 --> 00:31:01,670
也是一个很好的问题 
And a good question as well.

655
00:31:01,670 --> 00:31:04,190
好的 让我回到这里讨论的代码
Well let me come back to the code here in question

656
00:31:04,190 --> 00:31:06,800
看看我们能不能给你们展示几种其他的方式
and see if we can show you just a couple of other ways

657
00:31:06,800 --> 00:31:10,520
来解决同样的问题 同时强调我们在技术上
to solve the same problem, along the way emphasizing that what we're technically

658
00:31:10,520 --> 00:31:12,980
说到这里 是的 是弦 但甚至还有
talking about here, yes, are strings, but there's even

659
00:31:12,980 --> 00:31:15,170
在Python中表示这些字符串的技术术语 
a technical term for these strings in Python,

660
00:31:15,170 --> 00:31:19,700
这就是STR 可以说 S-T-R 简称为弦 
it's just STR, so to speak, S-T-R for short, for string.

661
00:31:19,700 --> 00:31:22,220
如果你用其他语言编程 你可能知道 
As you may know if you programmed in other languages,

662
00:31:22,220 --> 00:31:26,270
发明编程语言的人喜欢非常简洁 
people who invent programming languages like to be very succinct, to the point,

663
00:31:26,270 --> 00:31:29,780
所以我们倾向于用相当简短的短语来描述事物 
so we tend to use fairly short phrases to describe things,

664
00:31:29,780 --> 00:31:31,370
不一定是完整的单词 
not necessarily full words.

665
00:31:31,370 --> 00:31:33,920
所以 虽然你可能会说“弦” 从技术上讲
So while you might say "string," technically

666
00:31:33,920 --> 00:31:37,070
在Python语言中 我们真正谈论的是这些文本序列 
in Python what we're really talking about, these sequences of text,

667
00:31:37,070 --> 00:31:38,300
严格来说是STR 
are technically STRs.

668
00:31:38,300 --> 00:31:41,450
这是程序中的实际数据类型 
This is an actual type of data in a program.

669
00:31:41,450 --> 00:31:45,420
但我们很快就会发现 程序中还有其他类型的数据 
But we'll soon see that there's other types of data in programs as well.

670
00:31:45,420 --> 00:31:48,980
事实上 让我们看看我们是否不能用另一种方式来改善这一点 
In fact, let's see if we can't improve this in one other way.

671
00:31:48,980 --> 00:31:52,550
我喜欢我们通过让一切保持一致而取得的进展--
I like the progress we've made by keeping everything on the same line--

672
00:31:52,550 --> 00:31:55,490
你好 大卫在同一条线路上 
Hello, David all on the same line.

673
00:31:55,490 --> 00:31:59,070
然而 在解决这个问题方面 我们还能做些什么呢？
What more though could we do in terms of solving this problem?

674
00:31:59,070 --> 00:32:02,420
嗯 事实证明 我们并不需要完全放弃
Well, it turns out that we didn't have to give up entirely

675
00:32:02,420 --> 00:32:03,800
使用打印两次 
with using print twice.

676
00:32:03,800 --> 00:32:07,460
让我倒回一点 回到以前的版本
Let me rewind a little bit and go back to that earlier version

677
00:32:07,460 --> 00:32:11,660
我真的不确定如何解决这个问题 所以我使用了一次打印
where I wasn't really sure how to solve this problem so I was using print once

678
00:32:11,660 --> 00:32:14,090
只打印出Hello、空格和逗号 
to print out just the Hello and the space and the comma.

679
00:32:14,090 --> 00:32:17,750
然后我再次使用打印来打印姓名 
And then I used print again to print name.

680
00:32:17,750 --> 00:32:22,220
严格地说 这并不坏 但有一个视觉副作用
That's, strictly speaking, wasn't bad, but there was this visual side effect

681
00:32:22,220 --> 00:32:23,270
这是我不喜欢的 
that I didn't like.

682
00:32:23,270 --> 00:32:26,540
把这两行文字分开看起来很难看
It just looked ugly to have these two lines of text separate

683
00:32:26,540 --> 00:32:27,600
彼此之间的距离 
from one another.

684
00:32:27,600 --> 00:32:29,480
但还有另一种方法可以解决这个问题 
But there's another way to fix this.

685
00:32:29,480 --> 00:32:34,130
显然 打印功能似乎是自动
Clearly it seems to be the case that the print function is automatically

686
00:32:34,130 --> 00:32:36,110
输出一个空行 
outputting a blank line.

687
00:32:36,110 --> 00:32:39,380
它会自动将光标移动到下一行
It's moving the cursor automatically for me to the next line

688
00:32:39,380 --> 00:32:42,620
因为这就是为什么我在一条线路上看到Hello和David
because that's why I'm seeing Hello on one line and David

689
00:32:42,620 --> 00:32:44,150
在下一个问题上 然后是我的提示--
on the next and then my prompt--

690
00:32:44,150 --> 00:32:46,530
美元符号--在下面的那条线上 
the dollar sign-- on the line below that.

691
00:32:46,530 --> 00:32:48,800
因此 印刷品似乎在自动推定
So print seems to be presuming automatically

692
00:32:48,800 --> 00:32:51,230
您希望它将光标移动到下一行
that you want it to move the cursor to the next line

693
00:32:51,230 --> 00:32:53,040
在你给它传递一些参数之后 
after you pass it some argument.

694
00:32:53,040 --> 00:32:54,890
但您可以覆盖该行为 
But you can override that behavior.

695
00:32:54,890 --> 00:32:58,400
同样 函数接受影响其行为的参数 
Again, functions take arguments which influence their behavior,

696
00:32:58,400 --> 00:33:00,740
你只需要知道这些论点是什么 
you just have to know what those arguments are.

697
00:33:00,740 --> 00:33:06,560
事实证明 如果我们查看有关Python打印的文档
And it turns out that if we look at the documentation for Python's print

698
00:33:06,560 --> 00:33:09,980
函数 我们实际上可以在这里查看这个URL--
function, we can actually look up at this URL here--

699
00:33:09,980 --> 00:33:14,150
在docs.python.org上可以找到所有的Python官方文档 
docs.python.org is where all of Python's official documentation lies.

700
00:33:14,150 --> 00:33:17,870
如果我四处看看 我可以找到更具体的这个URL
If I poke around, I can find my way to more specifically this URL

701
00:33:17,870 --> 00:33:22,970
在这里 我可以找到所有可用的Python函数
here where I can find all of the available functions in Python

702
00:33:22,970 --> 00:33:24,630
以及那里的文档 
and the documentation there for.

703
00:33:24,630 --> 00:33:26,900
如果我走得更准确一点 我甚至可以
And if I go a little more precisely, I can even

704
00:33:26,900 --> 00:33:30,230
查找打印函数本身的特定文档 
find specific documentation for the print function itself.

705
00:33:30,230 --> 00:33:31,980
而不是在浏览器中打开它 
And rather than pull that up in a browser,

706
00:33:31,980 --> 00:33:36,050
接下来 我将突出显示同一URL中的一行 即
I'm going to go ahead and highlight just one line from that same URL, which

707
00:33:36,050 --> 00:33:39,890
这是我们所见过的最神秘的东西 
is this, and this is easily the most cryptic thing we've seen yet,

708
00:33:39,890 --> 00:33:42,717
但这是打印功能的官方文档 
but this is the official documentation for the print function.

709
00:33:42,717 --> 00:33:45,800
在学习编程语言时 你能做的最好的事情之一就是
And one of the best things you can do when learning a programming language

710
00:33:45,800 --> 00:33:48,110
老实说 就是学会阅读文档 
is, honestly, learn to read the documentation,

711
00:33:48,110 --> 00:33:51,920
因为真的 你所有问题的答案都会以某种方式
because truly, all of the answers to your questions will in some way

712
00:33:51,920 --> 00:33:55,430
尽管不可否认 这并不总是显而易见的 但一定要做到 
be there, even though, admittedly, it's not always obvious.

713
00:33:55,430 --> 00:33:57,290
我也会说 Python的文档
And I will say too, Python's documentation

714
00:33:57,290 --> 00:34:01,460
这不一定是最容易的事情 特别是对于第一次或新手来说
isn't necessarily the easiest thing, especially for a first time or novice

715
00:34:01,460 --> 00:34:02,072
程序员 
programmer.

716
00:34:02,072 --> 00:34:05,030
这也需要练习 所以如果你不是这样的话 试着不要感到不知所措
It too just takes practice, so try not to get overwhelmed if you're not

717
00:34:05,030 --> 00:34:06,292
当然你看到的是什么 
sure what you're looking at.

718
00:34:06,292 --> 00:34:08,000
但让我向您介绍一下这个例子 
But let me walk you through this example.

719
00:34:08,000 --> 00:34:11,360
这也是来自Python官方文档的一行文本
This again is a line of text from Python's official documentation

720
00:34:11,360 --> 00:34:12,690
用于打印功能 
for the print function.

721
00:34:12,690 --> 00:34:14,659
这表明这是这样的--
What this indicates as follows is this--

722
00:34:14,659 --> 00:34:17,000
这个函数的名称当然是print 
the name of this function is, of course print.

723
00:34:17,000 --> 00:34:20,570
然后这里有一个括号和另一种紧凑的括号方式
Then there's a parenthesis over here and another close parenthesis way

724
00:34:20,570 --> 00:34:21,230
在那边 
over there.

725
00:34:21,230 --> 00:34:23,570
这些括号中的所有内容都是
Everything inside of those parentheses are

726
00:34:23,570 --> 00:34:27,270
参数 潜在的参数 传递给函数 
the arguments, the potential arguments, to the function.

727
00:34:27,270 --> 00:34:30,830
然而 当我们看到这些论点时
However, when we're looking at these arguments

728
00:34:30,830 --> 00:34:34,400
在这样的文档中 从技术上讲 有一个不同的术语
in the documentation like this, there's technically a different term

729
00:34:34,400 --> 00:34:35,150
我们会用到的 
that we would use.

730
00:34:35,150 --> 00:34:37,920
从技术上讲 这些是该函数的参数 
These are technically the parameters to the function.

731
00:34:37,920 --> 00:34:41,900
因此 当您谈论可以传递给函数的内容时
So when you're talking about what you can pass to a function

732
00:34:41,900 --> 00:34:45,679
这些输入被称为什么 这些就是参数 
and what those inputs are called, those are parameters.

733
00:34:45,679 --> 00:34:48,080
当您实际使用该函数并传递
When you actually use the function and pass

734
00:34:48,080 --> 00:34:51,650
在这些圆括号内的值中 这些输入 
in values inside of those parentheses, those inputs,

735
00:34:51,650 --> 00:34:53,580
这些值是参数 
those values are arguments.

736
00:34:53,580 --> 00:34:56,719
所以我们谈论的是完全相同的事情--参数和自变量
So we're talking about the exact same thing-- parameters and arguments are

737
00:34:56,719 --> 00:34:58,850
实际上是一样的 但你的条款
effectively the same thing, but the terms you

738
00:34:58,850 --> 00:35:01,520
从不同的角度看问题的用处 
use from looking at the problem from different directions.

739
00:35:01,520 --> 00:35:04,220
当我们查看该函数可以采用的功能与
When we're looking at what the function can take versus what

740
00:35:04,220 --> 00:35:06,210
您实际上是在传递到函数中 
you're actually passing into the function.

741
00:35:06,210 --> 00:35:07,500
那么 这意味着什么呢？
So what does this imply?

742
00:35:07,500 --> 00:35:10,610
这个语法相当隐晦 但目前 
Well this syntax is pretty cryptic, but at the moment,

743
00:35:10,610 --> 00:35:14,360
只要知道一个星号 一个星星 然后是“物体”这个词
just know that an asterisk, a star, and then the word "objects"

744
00:35:14,360 --> 00:35:17,330
意味着打印函数可以接受任意数量的对象 
means that the print function can take any number of objects.

745
00:35:17,330 --> 00:35:20,540
您可以传入0个文本字符串 1个字符串
You can pass in 0 strings of text, one string

746
00:35:20,540 --> 00:35:23,900
就像我做的那样 两根弦 或者 从技术上讲 无限多根弦
like I did, two strings like I did, or, technically, infinitely many

747
00:35:23,900 --> 00:35:27,170
如果您真的想要 尽管代码看起来不会很好 
if you really want, though that code is not going to look very good.

748
00:35:27,170 --> 00:35:31,130
在那之后我们看到一个逗号 然后我们在这里看到另一个参数
After that we see a comma, then we see another parameter here

749
00:35:31,130 --> 00:35:34,400
被称为SEP 在英语中是分离器的缩写 
called SEP, short for separator in English.

750
00:35:34,400 --> 00:35:38,640
注意等号和单引号 空格 单引号 
And notice the equal sign and the single quote, space, single quote.

751
00:35:38,640 --> 00:35:42,350
所以“太空”我还不知道那是什么 
So 'space' I don't know what that is yet,

752
00:35:42,350 --> 00:35:44,570
但我认为我们已经看到了这方面的暗示 
but I think we've seen a hint about it.

753
00:35:44,570 --> 00:35:46,430
让我们暂时把注意力集中在这个--
Let's focus though for a moment on this--

754
00:35:46,430 --> 00:35:50,720
打印函数接受另一个名为end的参数和默认参数
the print function takes another parameter called end and the default

755
00:35:50,720 --> 00:35:54,560
该参数值显然是基于这个等号和这些
value of that parameter is apparently, based on this equal sign and these

756
00:35:54,560 --> 00:35:57,020
引号 /n 
quotes, /n.

757
00:35:57,020 --> 00:36:00,260
如果你想加入聊天 那/n是什么？
And what is /n, if you'd like to chime in in the chat?

758
00:36:00,260 --> 00:36:02,810
以前编程的人可能都看过这个 
Anyone who's program before has probably seen this,

759
00:36:02,810 --> 00:36:07,070
不过 如果您以前从未编写过程序 这看起来可能会非常神秘 
though if you've never programmed before, this might look quite cryptic.

760
00:36:07,070 --> 00:36:12,530
反斜杠n表示换行 这是一种文本方式
Backslash n means new line, and it's a way textually

761
00:36:12,530 --> 00:36:15,710
表明你是否以及何时有效地想要电脑
of indicating if and when you want the computer effectively

762
00:36:15,710 --> 00:36:19,490
要将光标移动到下一行 请创建新的文本行 
to move the cursor to the next line, create a new line of text.

763
00:36:19,490 --> 00:36:22,310
因此 从技术上讲 如果我们阅读文档 
And so technically, if we read into the documentation,

764
00:36:22,310 --> 00:36:23,960
我们将看到关于这一点的更多细节 
we'll see more detail on this.

765
00:36:23,960 --> 00:36:28,550
事实上 在打印文档中有一个名为end的参数
The fact that there's a parameter called end in the documentation for the print

766
00:36:28,550 --> 00:36:32,840
函数 这意味着默认情况下 此打印函数将结束
function, just means that by default this print function is going to end

767
00:36:32,840 --> 00:36:35,240
每一行都有/n 
every line with /n.

768
00:36:35,240 --> 00:36:37,670
你看到的不是字面上的/n 而是一个新的行 
You don't literally see /n, you see a new line.

769
00:36:37,670 --> 00:36:40,320
您会看到光标移动到下一行 
You see the cursor moving to the next line.

770
00:36:40,320 --> 00:36:42,500
现在按照这个逻辑 让我们后退一步 
Now by that logic, let's move backwards.

771
00:36:42,500 --> 00:36:46,790
SEP Four分隔符--分隔符的缺省值
SEP four separator-- the default value of separator

772
00:36:46,790 --> 00:36:49,460
显然是一个空格 
is apparently a single blank space.

773
00:36:49,460 --> 00:36:51,020
那么 我们在哪里看到的呢？
Well where have we seen that?

774
00:36:51,020 --> 00:36:55,190
回想一下前面的一个例子 我传入的不只是一个 而是两个
Well recall in an earlier example when I passed in not just one but two

775
00:36:55,190 --> 00:36:57,210
Print函数的参数 
arguments to the print function.

776
00:36:57,210 --> 00:37:00,300
回想一下 他们之间有一个神奇的空间 
Recall that they magically had a space between them.

777
00:37:00,300 --> 00:37:02,540
事实上 他们有那个空间+我自己的空间
In fact, they had that space + my own space

778
00:37:02,540 --> 00:37:05,720
这就是为什么我删除了我的空间 因为在这一点上它是额外的 
and that's why I deleted my space because at that point it was extra.

779
00:37:05,720 --> 00:37:09,620
因此 这只是意味着当您将多个参数传递给print时 默认情况下
So this just means that when you pass multiple arguments to print, by default

780
00:37:09,620 --> 00:37:11,750
它们将被一个空格隔开 
they're going to be separated by a single space.

781
00:37:11,750 --> 00:37:14,570
默认情况下 当您将参数传递给print时 
By default, when you pass arguments to print,

782
00:37:14,570 --> 00:37:17,880
整件事都将以一句新台词结束 
it's the whole thing is going to be ended with a new line.

783
00:37:17,880 --> 00:37:19,850
现在 只要知道这一点 让我从字面上
Now just by knowing this, and let me literally

784
00:37:19,850 --> 00:37:22,890
把我的手放在剩下的文件上 改天再说 
wave my hand at the rest of the documentation for another day,

785
00:37:22,890 --> 00:37:24,890
印刷品可以做的事情还有很多 但我们
there's more things that print can do, but we're

786
00:37:24,890 --> 00:37:29,360
我们将重点放在SEP上 让我们看看我们现在是否不能利用这一点
going to focus just on SEP and on END, let's see if we can't leverage this now

787
00:37:29,360 --> 00:37:31,010
来解决这个最初的问题 
to solve that original problem.

788
00:37:31,010 --> 00:37:34,250
最初的问题是这样的 我不喜欢你好 大卫
The original problem was this, I don't like how Hello, David

789
00:37:34,250 --> 00:37:35,750
在两条不同的线路上 
is on two different lines.

790
00:37:35,750 --> 00:37:38,420
好吧 这又发生了 因为指纹是自动的
Well that's happening again because print is automatically

791
00:37:38,420 --> 00:37:41,810
打印出一个新的行 所以让我们告诉它不要这样做 
printing out a new line, so let's tell it not to do that.

792
00:37:41,810 --> 00:37:47,150
让我们通过向第一次使用print传递第二个参数来说明这一点
Let's tell it by passing a second argument to the first use of PRINT

793
00:37:47,150 --> 00:37:51,110
说结束=引用 不引用--
to say END = quote, unquote--

794
00:37:51,110 --> 00:37:54,840
NOT/N 这是自动设置的默认值 
not /n, which is the default automatically.

795
00:37:54,840 --> 00:37:58,250
让我们引用它 不引用其他任何东西 
Let's make it quote, unquote nothing else.

796
00:37:58,250 --> 00:38:01,850
让我们覆盖缺省值 这样就不会有新行了 
Let's override the default value so there is no new line.

797
00:38:01,850 --> 00:38:03,560
从字面上看什么都没有 
There's literally nothing there.

798
00:38:03,560 --> 00:38:05,250
让我们看看会发生什么 
And let's see what happens.

799
00:38:05,250 --> 00:38:08,270
现在让我转到我的终端窗口并清除它 
Let me now go down to my terminal window and clear it.

800
00:38:08,270 --> 00:38:10,672
我将运行Hello.py的Python 回车 
And I'm going to run Python of Hello.py, Enter.

801
00:38:10,672 --> 00:38:12,380
我要输入我的名字 大卫和我
I'm going to type in my name, David and I

802
00:38:12,380 --> 00:38:16,280
我想现在一切都会保持一致 因为--
think now everything is going to stay on the same line because--

803
00:38:16,280 --> 00:38:22,460
它做到了--这一行 5 将打印出Hello 逗号 空格 
and it did-- this line here, 5, is going to print out Hello, comma, space,

804
00:38:22,460 --> 00:38:24,710
但最后什么都没有 因为我
but then nothing at the end of it because I

805
00:38:24,710 --> 00:38:26,450
改成了引用 不引用 
changed it to be quote, unquote.

806
00:38:26,450 --> 00:38:29,210
第二行将打印名字 大卫 
The second line is going to print the name, David,

807
00:38:29,210 --> 00:38:32,780
或者不管这个人的名字是什么 它会将光标移动到下一行
or whatever the human's name is, and it will move the cursor to the next line

808
00:38:32,780 --> 00:38:36,230
因为我没有覆盖End There的值 
because I didn't override the value of END there.

809
00:38:36,230 --> 00:38:39,710
为了更清楚地看到这一点 如果你做一些神秘的事情 
Just to see this more explicitly, if you do something cryptic like,

810
00:38:39,710 --> 00:38:41,420
我不知道发生了什么事 
well I have no idea what's going on.

811
00:38:41,420 --> 00:38:44,120
让我暂时在这里加三个问号 
Let me just put in temporarily three question marks here.

812
00:38:44,120 --> 00:38:46,040
我们也会看到这一结果的 
We'll see the results of this too.

813
00:38:46,040 --> 00:38:49,202
让我返回到我的终端窗口 运行问候的Python Py 
Let me go back down to my terminal window, run Python of hello. py,

814
00:38:49,202 --> 00:38:49,910
你叫什么名字？
what's your name?

815
00:38:49,910 --> 00:38:50,420
大卫 
David.

816
00:38:50,420 --> 00:38:54,207
现在你看到的是非常丑陋的输出 
And now you see literally really ugly output,

817
00:38:54,207 --> 00:38:55,790
但你可以从字面上看到发生了什么 
but you see literally what's going on.

818
00:38:55,790 --> 00:39:01,010
你好 逗号 空格 然后是三个问号 结束 打印语句 
Hello, comma, space, then three question marks, END, that print statement,

819
00:39:01,010 --> 00:39:05,570
然后你会看到D-A-V-I-D 所以这不是个好结果 
and then you see D-A-V-I-D. So not a good outcome,

820
00:39:05,570 --> 00:39:09,080
但它也表明了我们在这里也有多大的控制权 
but it demonstrates just how much control we have here too.

821
00:39:09,080 --> 00:39:10,490
让我倒得更远一些 
And let me rewind further.

822
00:39:10,490 --> 00:39:13,250
回想一下 在我们的另一个版本中 
Recall that in our other version of this,

823
00:39:13,250 --> 00:39:18,710
当我传入Hello、逗号和名字时 它们之间用一个空格隔开 
when I passed in Hello, comma and name, they were separated by a single space.

824
00:39:18,710 --> 00:39:22,340
所以 在Hello.py的Python中 D-A-V-I-D 回车 
So Python of Hello.py, D-A-V-I-D, Enter.

825
00:39:22,340 --> 00:39:23,690
这招真的奏效了 
That just worked.

826
00:39:23,690 --> 00:39:27,950
那么 如果我们覆盖分隔符的SEP值 会怎么样？
Well what if we override the value of SEP for separator?

827
00:39:27,950 --> 00:39:31,730
与其成为一个空间 我们可以说些什么
Instead of being one space, we could say something

828
00:39:31,730 --> 00:39:35,030
就像 问号只是为了包装
like, question mark, question mark, question mark just to wrap

829
00:39:35,030 --> 00:39:37,110
我们的脑子里想着那里正在发生的事情 
our minds around what's going on there.

830
00:39:37,110 --> 00:39:41,300
现在让我执行Hello.py的Python D-A-V-I-D 回车 
Let me now do Python of Hello.py, D-A-V-I-D, Enter.

831
00:39:41,300 --> 00:39:42,650
你会看到两个 
And you see two.

832
00:39:42,650 --> 00:39:43,850
这两个输入--
These two inputs--

833
00:39:43,850 --> 00:39:47,840
你好 逗号和名字现在以一种难看的方式分隔
Hello, comma and the name are now separated in an ugly way

834
00:39:47,840 --> 00:39:52,580
三个问号 因为我已经覆盖了SEP的默认行为 
by three question marks because I've overridden the default behavior of SEP.

835
00:39:52,580 --> 00:39:54,803
即使文档使用了单引号 
And even though the documentation uses single quotes,

836
00:39:54,803 --> 00:39:56,720
我一直有使用双引号的习惯 
I've been in the habit of using double quotes.

837
00:39:56,720 --> 00:39:58,580
在Python中 您可以使用其中任何一个 
In Python you can use either.

838
00:39:58,580 --> 00:40:01,620
严格地说 这并不重要 但你应该始终如一
Strictly speaking, it doesn't matter, but you should be consistent

839
00:40:01,620 --> 00:40:03,530
而且我通常都会用双引号 
and I generally always use double quotes.

840
00:40:03,530 --> 00:40:08,240
不过 Python的文档总是使用单引号 
Python's documentation, though, always uses single quotes.

841
00:40:08,240 --> 00:40:12,320
现在有关于这些参数类型的问题吗？
Questions now on these types of parameters?

842
00:40:12,320 --> 00:40:15,290
请允许我提议我们给这些人一个正式的名字 
And allow me to propose that we give these an official name.

843
00:40:15,290 --> 00:40:19,220
到目前为止 当我们将值传递给印刷品时 
Up until now, when we've been passing values to print,

844
00:40:19,220 --> 00:40:22,160
这些被称为位置参数--在某种意义上是位置参数
those are called positional parameters-- positional in the sense

845
00:40:22,160 --> 00:40:24,620
你传递给Print的第一件东西首先被打印出来 
that the first thing you pass to print gets printed first.

846
00:40:24,620 --> 00:40:27,830
在第二次打印逗号之后传递到打印的第二件事 
The second thing you pass to print after a comma gets printed second.

847
00:40:27,830 --> 00:40:28,710
以此类推 
And so forth.

848
00:40:28,710 --> 00:40:32,210
但我们现在看到的还有一些称为命名参数的东西 
But there's also these things we've now seen called named parameters.

849
00:40:32,210 --> 00:40:37,550
命名为SEP、分隔符或结束 E-N-D表示行结束 
Named SEP, separator, or END, E-N-D for the line ending.

850
00:40:37,550 --> 00:40:40,910
这些都是命名参数 因为第一 它们是可选的
Those are named parameters because one, they're optional

851
00:40:40,910 --> 00:40:44,450
您可以在打印语句的末尾传递它们 
and you can pass them in at the end of your print statement,

852
00:40:44,450 --> 00:40:48,290
但您也可以按名称使用它们 
but you can also use them by name.

853
00:40:48,290 --> 00:40:51,050
观众：这可能是一个奇怪的问题 但我想知道 
AUDIENCE: This may be a weird question, but I was wondering,

854
00:40:51,050 --> 00:40:57,350
如果有人想要在引语中添加实际的引号怎么办
what if someone wants to add actually quotation marks within the quotation

855
00:40:57,350 --> 00:40:57,920
马克？
marks?

856
00:40:57,920 --> 00:40:59,600
大卫·马兰：是的 我喜欢你的想法 
DAVID MALAN: Yeah, I like how you think.

857
00:40:59,600 --> 00:41:01,880
这就是我们所说的角落案例 对吗？
This is what we would call a corner case, right?

858
00:41:01,880 --> 00:41:03,860
就在我们做完--对 这就是全部
Just when we've made-- right, this is all

859
00:41:03,860 --> 00:41:06,823
听起来很棒 至少在编程方面是这样 但是 等一下 
sounding great, at least as programming goes, but, wait a minute,

860
00:41:06,823 --> 00:41:08,240
如果您想打印报价 该怎么办？
what if you want to print a quote?

861
00:41:08,240 --> 00:41:09,557
这是一个非常好的问题 
That's a really good question.

862
00:41:09,557 --> 00:41:11,390
好吧 让我们看看我们是不是不能解决这个问题 
Well, let's see if we can't figure this out.

863
00:41:11,390 --> 00:41:15,590
假设我想打印的不仅仅是用户名 
Suppose that I want to print out not just the user's name.

864
00:41:15,590 --> 00:41:16,940
让我进一步简化这一点 
Let me simplify this further.

865
00:41:16,940 --> 00:41:18,980
让我继续下去 把很多东西都处理掉 
Let me go ahead and get rid of a lot of this,

866
00:41:18,980 --> 00:41:21,510
让我说几句 你好--
and let me just say something like, Hello--

867
00:41:24,170 --> 00:41:26,240
也许我说的有点讽刺了 
maybe I'm being a little sarcastic here.

868
00:41:26,240 --> 00:41:28,310
你好 (讽刺地)“朋友” 
Hello, (sarcastically) "friend."

869
00:41:28,310 --> 00:41:30,022
你知道 用那种语气 
You know, in that kind of tone.

870
00:41:30,022 --> 00:41:31,730
实际上 这是行不通的 
Well this is not going to work, actually,

871
00:41:31,730 --> 00:41:36,260
因为你试图用引号在手指引号中表现出“朋友”的形象 
because you are trying to use quotes to be like "friend" in finger quotes,

872
00:41:36,260 --> 00:41:38,070
但你也在试图结束这一判决 
but you're also trying to end the sentence.

873
00:41:38,070 --> 00:41:39,778
如果我试着运行它 我们就这么做 
And if I try running this, let's do this.

874
00:41:39,778 --> 00:41:43,160
您将看到这只是无效的语法 
Python of Hello.py, you'll see that this is just invalid syntax.

875
00:41:43,160 --> 00:41:44,420
也许你忘了一个逗号 
Perhaps you forgot a comma.

876
00:41:44,420 --> 00:41:45,920
这实际上有点烦人 
And this is actually a bit annoying.

877
00:41:45,920 --> 00:41:48,822
有时 您看到的错误消息具有误导性 
Sometimes the error messages you see are misleading.

878
00:41:48,822 --> 00:41:50,780
就像电脑 语言 并不是真的
Like the computer, the language, doesn't really

879
00:41:50,780 --> 00:41:52,488
知道发生了什么 所以它会尽最大努力
know what's going on so it gives its best

880
00:41:52,488 --> 00:41:55,010
猜测 但这不一定是正确的 
guess, but it's not necessarily correct.

881
00:41:55,010 --> 00:41:57,870
但我可以用几种方法来解决这个问题 
But I can solve this problem in a couple of ways.

882
00:41:57,870 --> 00:41:59,160
我能做到的
I can do this--

883
00:41:59,160 --> 00:42:01,912
我可以将最外面的引号更改为单引号 
I can change my outermost quotes to single quotes.

884
00:42:01,912 --> 00:42:03,620
因为再次回想起那一刻 我说你
Because recall a moment again, I said you

885
00:42:03,620 --> 00:42:07,130
可以使用双引号或单引号 只要您是一致的 
could use double quotes or single quotes so long as you're consistent.

886
00:42:07,130 --> 00:42:08,000
所以这很好 
So that's fine.

887
00:42:08,000 --> 00:42:10,142
如果您在外部使用单引号 您将
If you use single quotes on the outside, you

888
00:42:10,142 --> 00:42:13,100
然后可以在内部使用双引号 您将从字面上看到它们 
can then use double quotes on the inside and you'll see them literally.

889
00:42:13,100 --> 00:42:17,000
例如 如果我运行Hello.py的Python 我们就可以开始了 
So for instance, if I run Python of Hello.py, there we go.

890
00:42:17,000 --> 00:42:18,590
你好 “朋友”
Hello, "friend."

891
00:42:18,590 --> 00:42:19,910
但还有另一种方法 
But there's another way.

892
00:42:19,910 --> 00:42:23,450
如果您坚持使用双引号 就像您想要的那样 
If you insist on using double quotes as you might want to,

893
00:42:23,450 --> 00:42:27,800
为了保持一致 您还可以再次使用该反斜杠字符 
just to be consistent, you can also use that backslash character again.

894
00:42:27,800 --> 00:42:30,080
我们刚才看到了那辆车 
We saw the /n a moment ago.

895
00:42:30,080 --> 00:42:33,380
这意味着我们不想让文字n出现在输出中 
And that meant we don't want a literal n to be in the output,

896
00:42:33,380 --> 00:42:34,640
我们想要一个新的产品线 
we wanted a new line.

897
00:42:34,640 --> 00:42:38,420
因此 反斜杠实际上代表了所谓的转义字符 
So the backslash actually represents what's called an escape character.

898
00:42:38,420 --> 00:42:40,430
转义字符是一个你不能仅仅
An escape character is one that you can't just

899
00:42:40,430 --> 00:42:43,130
一定要在键盘上打字一次 
type necessarily once on your keyboard.

900
00:42:43,130 --> 00:42:45,270
你需要用多个字符来表达它 
You need to express it with multiple characters.

901
00:42:45,270 --> 00:42:50,920
所以我可以在这些内部双引号前面加反斜杠
So I can actually put backslashes in front of these inner double quotes

902
00:42:50,920 --> 00:42:52,920
所以计算机意识到 哦 等一下 
so that the computer realizes, Oh wait a minute,

903
00:42:52,920 --> 00:42:57,560
这些不是结束或开始思想的引语 而是字面上的引语 
those aren't quotes that finish or start the thought, they're literal quotes.

904
00:42:57,560 --> 00:43:02,420
现在让我返回到我的终端窗口 运行Hello.py的Python 回车 
So now let me go back to my terminal window, run Python of Hello.py, Enter.

905
00:43:02,420 --> 00:43:04,800
现在 它也在发挥作用 
And now it's working as well.

906
00:43:04,800 --> 00:43:08,390
因此 逃脱是一种通用的技术 它也允许我们这样做 
So escaping is a general technique that allows us to do that too.

907
00:43:08,390 --> 00:43:12,230
如果可以的话 现在让我回顾一下这些例子
And if I may, let me rewind now on these examples

908
00:43:12,230 --> 00:43:14,810
然后回到我们停止的地方 用我的代码 
and go back to where we left off with my code,

909
00:43:14,810 --> 00:43:18,200
我只是想撤销这一切 因为我想回到正题
I'm just undoing all of that, because I want to get back to the point

910
00:43:18,200 --> 00:43:23,820
最终确定了解决这一问题的最终方法 
ultimately of specifying now a final way of solving this problem.

911
00:43:23,820 --> 00:43:26,300
好吧 事实证明我们还有另一种方法
Well, it turns out that we have yet another way

912
00:43:26,300 --> 00:43:30,680
我们可以解决这个问题 这可能是最常做的事情
we can solve this problem, which is perhaps the most frequently done

913
00:43:30,680 --> 00:43:35,030
现在 或者至少是在设置我们的时候最优雅的
now or at least the most elegant when it comes to setting us up

914
00:43:35,030 --> 00:43:38,840
字符串的使用时间越来越长 
for longer and longer uses of strings.

915
00:43:38,840 --> 00:43:43,620
您可以使用一个相对较新的Python特性来实现这一点 
You can use a relatively new feature of Python that allows you to do this.

916
00:43:43,620 --> 00:43:47,397
您可以直接在字符串中放入变量的名称 而不是这样
You can literally put, not the name of the variable like that in your string,

917
00:43:47,397 --> 00:43:49,230
因为我们已经看到这是错的 对吗？
because we already saw this is wrong, right?

918
00:43:49,230 --> 00:43:52,340
如果您这样做 您将看到您好 逗号 名字 
If you do this, you will literally see Hello, comma, name.

919
00:43:52,340 --> 00:43:53,580
但如果我这么做了呢？
But what if I do this?

920
00:43:53,580 --> 00:43:58,070
如果我用花括号或花括号将变量名括起来 会怎么样？
What if I put curly braces or curly brackets around the variable's name?

921
00:43:58,070 --> 00:44:00,830
注意VS Code实际上非常微妙地改变了它的颜色 
Notice VS Code is actually very subtly changing the color of it.

922
00:44:00,830 --> 00:44:03,590
所以VS Code知道这里发生了一些有趣的事情 
So VS Code knows something interesting is going on here.

923
00:44:03,590 --> 00:44:08,060
让我运行这个程序 但是我还没有运行完 
Let me run this program, but I'm not done yet Python of Hello.py, Enter.

924
00:44:08,060 --> 00:44:09,650
D-A-V-I-D 回车 
D-A-V-I-D, Enter.

925
00:44:09,650 --> 00:44:13,430
好吧 显然不是我想要的 但我需要告诉Python
OK, obviously not what I want, but I need to tell Python

926
00:44:13,430 --> 00:44:15,140
这是一根特殊的弦 
that this is a special string.

927
00:44:15,140 --> 00:44:18,470
这就是我们所说的格式字符串或F字符串 
This is what we're going to call a format string or an F string,

928
00:44:18,470 --> 00:44:21,660
在过去的几年中 一种相对较新的特性
a relatively new feature of Python in the past few years

929
00:44:21,660 --> 00:44:26,750
这告诉Python实际上以一种特殊的方式格式化字符串中的内容 
that tells Python to actually format stuff in the string in a special way.

930
00:44:26,750 --> 00:44:29,480
从你所做的事情来看 这个符号有点奇怪 
And the symbol via what you do this is a little weird,

931
00:44:29,480 --> 00:44:31,220
但这是世界的选择 
but this is what the world chose.

932
00:44:31,220 --> 00:44:35,390
如果你把F放在字符串的开头 
If you put an F at the beginning of the string,

933
00:44:35,390 --> 00:44:40,160
就在第一个引号之前 这是一个关于Python的线索 哦 
right before the first quote mark, that's a clue to Python that, ooh,

934
00:44:40,160 --> 00:44:41,210
这是一根特殊的线 
this is a special string.

935
00:44:41,210 --> 00:44:43,550
让我以一种特殊的方式为您格式化 
Let me format this in a special way for you.

936
00:44:43,550 --> 00:44:45,380
现在让我重新运行程序 
Let me now rerun the program.

937
00:44:45,380 --> 00:44:47,120
Python Hello.py 回车 
Python Hello.py, Enter.

938
00:44:47,120 --> 00:44:48,410
D-A-V-I-D 回车 
D-A-V-I-D, Enter.

939
00:44:48,410 --> 00:44:51,170
现在我们看到整个过程中的目标--
And now we see the goal this whole time--

940
00:44:51,170 --> 00:44:52,395
你好 大卫 
Hello, David.

941
00:44:52,395 --> 00:44:55,520
我们不是以这种方式开始的 因为我认为如果我们以第一种方式进行 
We don't start with this way, because I think if we did this the first way,

942
00:44:55,520 --> 00:44:57,330
你会想 我们为什么要这么做？
you'd be like, why are we doing this?

943
00:44:57,330 --> 00:44:58,850
这些神奇的符号是什么？
What are all these magical symbols?

944
00:44:58,850 --> 00:45:02,370
但这只是解决同样问题的另一种方式 
But this is just yet another way to solve the same problem.

945
00:45:02,370 --> 00:45:04,940
但让我提议我们现在就考虑
But let me propose that we consider now yet

946
00:45:04,940 --> 00:45:06,920
我们可以用弦做的其他事情 
other things we can do with strings.

947
00:45:06,920 --> 00:45:11,190
事实证明 即使我们一直在做一些相对简单的操作
And it turns out that even as we've been doing some relatively simple operations

948
00:45:11,190 --> 00:45:14,665
在这里 我们通常一直相信用户会合作
here, we've generally been trusting that the user is going to cooperate

949
00:45:14,665 --> 00:45:17,790
这就是说 他们实际上会输入我们想要的内容
and that is to say that they're going to actually type in what we want them

950
00:45:17,790 --> 00:45:18,450
打字 
to type.

951
00:45:18,450 --> 00:45:20,850
然而 仅仅因为他们输入一个字符串并不意味着
Now just because they type a string, though, doesn't mean

952
00:45:20,850 --> 00:45:22,410
它看起来会像我们想要的那样 
it's going to look the way we want.

953
00:45:22,410 --> 00:45:24,510
你和我 老实说 因为人类实际上
You and I, honestly, as humans are actually

954
00:45:24,510 --> 00:45:27,840
在网站和应用程序上 喜欢不小心点击
in the habit-- on websites and apps-- of like accidentally hitting

955
00:45:27,840 --> 00:45:30,300
空格键很多 无论是在我们输入的开始
the spacebar a lot, either at the beginning of our input

956
00:45:30,300 --> 00:45:33,460
或者在最后 可能是因为空格键往往太大了 
or at the end, maybe because the space bar tends to be so big.

957
00:45:33,460 --> 00:45:35,790
意外的车位是很常见的
It's pretty common to get accidental spaces

958
00:45:35,790 --> 00:45:37,950
在一些用户输入之前或之后 
before or after some users' input.

959
00:45:37,950 --> 00:45:41,675
你和我肯定有不一定要大写单词的习惯
You and I are definitely in the habit of not necessarily capitalizing words

960
00:45:41,675 --> 00:45:42,300
就像我们应该做的那样 
like we should.

961
00:45:42,300 --> 00:45:45,122
如果我们在发送短信 我们可能有点快
If we're sending text messages, we're probably being a little quick

962
00:45:45,122 --> 00:45:46,830
把所有东西都用小写字母写出来 
and just sending everything in lowercase,

963
00:45:46,830 --> 00:45:49,913
例如 如果这是你的风格 如果你的手机不能为你修复它 
for instance, if that's your style, if your phone's not fixing it for you.

964
00:45:49,913 --> 00:45:52,530
也许在一封正式的信中 你会适当地把东西大写 
Maybe in a formal letter you would capitalize things properly.

965
00:45:52,530 --> 00:45:56,400
但你和我作为人类 我们不能真的被信任以一种好的方式打字
But you and I as humans, we can't really be trusted to type things in a nice way

966
00:45:56,400 --> 00:45:58,870
在使用某个软件时 
necessarily when using some piece of software,

967
00:45:58,870 --> 00:46:00,940
无论是一款应用程序、一个网站还是其他什么 
be it an app or a website or something else.

968
00:46:00,940 --> 00:46:04,560
但事实证明 弦本身就是
But it turns out that strings themselves come

969
00:46:04,560 --> 00:46:06,450
具有很多内置功能 
with a lot of built-in functionality.

970
00:46:06,450 --> 00:46:09,300
您可以在这里的Python自己的文档中看到所有这些内容 
You can see all of that in Python's own documentation here.

971
00:46:09,300 --> 00:46:12,600
我们一直在讨论的字符串数据类型
The string data type that we've been talking about

972
00:46:12,600 --> 00:46:14,970
带有很多内置的功能
comes with a lot of functionality built in that

973
00:46:14,970 --> 00:46:18,360
意味着我们可以操作用户的输入来做更多的事情
means that we can manipulate the user's input to do more than just

974
00:46:18,360 --> 00:46:22,290
加入像Hello这样的东西 我们实际上可以清理它
join it with something else like Hello, we can actually clean it up

975
00:46:22,290 --> 00:46:26,380
或者重新格式化它 希望它看起来对我们更好一点 
or reformat it in a way that hopefully looks a little better for us.

976
00:46:26,380 --> 00:46:29,070
所以让我回到我的代码 让我
So let me go back to my code here and let me just

977
00:46:29,070 --> 00:46:32,100
演示如果用户不合作可能会发生的情况 
demonstrate what might happen if a user doesn't cooperate.

978
00:46:32,100 --> 00:46:35,490
如果我在这里运行Hello.py的Python 请输入 
If I go ahead here and run Python of Hello.py, Enter.

979
00:46:35,490 --> 00:46:38,890
让我草率地按几次空格键 
Let me just sloppily hit the spacebar a few too many times.

980
00:46:38,890 --> 00:46:39,390
为什么？
Why?

981
00:46:39,390 --> 00:46:40,890
我只是没有注意到 
I just wasn't paying attention.

982
00:46:40,890 --> 00:46:43,710
现在我要输入我的名字D-A-V-I-D 我不知道 
And now I'm going to type in my name D-A-V-I-D and, I don't know,

983
00:46:43,710 --> 00:46:45,510
我又按了几次空格键 
I hit the spacebar a couple more times.

984
00:46:45,510 --> 00:46:46,620
就像是一团糟 
Like it's kind of a mess.

985
00:46:46,620 --> 00:46:47,785
都是小写的 
It's all lowercase.

986
00:46:47,785 --> 00:46:50,160
这在语法上看起来不一定是正确的 
That's not going to necessarily look grammatically right.

987
00:46:50,160 --> 00:46:51,900
它在这里和这里都有空间 
It's got spaces here and here.

988
00:46:51,900 --> 00:46:54,030
程序将打印完全相同的内容
The program is going to print exactly that

989
00:46:54,030 --> 00:46:55,890
这看起来真的很糟糕 至少如果我们
and that looks really bad, at least if we're

990
00:46:55,890 --> 00:46:57,900
优先考虑美学和语法 
prioritizing aesthetics and grammar.

991
00:46:57,900 --> 00:47:00,330
比如 为什么逗号后面有这么多空格？
Like, why are there so many spaces after the comma?

992
00:47:00,330 --> 00:47:03,420
这不是一种很好的问候用户的方式 
This is not a very nice way to greet your users.

993
00:47:03,420 --> 00:47:05,130
但我们可以把这件事清理干净 
But we can clean this up.

994
00:47:05,130 --> 00:47:10,170
结果是内置到字符串中 同样是这种数据类型 所以
It turns out that built into strings, which, again, is this data type, so

995
00:47:10,170 --> 00:47:12,780
可以说 这种类型的数据在Python中--
to speak, this type of data in Python--

996
00:47:12,780 --> 00:47:15,730
是对该字符串进行实际操作的能力 
is the ability to actually do things to that string.

997
00:47:15,730 --> 00:47:20,280
所以让我这样做 我可以继续做这样的事情--
So let me do this, I can actually go ahead and do something like this--

998
00:47:20,280 --> 00:47:23,820
名称=名称.条带 
name = name.strip.

999
00:47:23,820 --> 00:47:25,240
这是做什么用的？
And what does this do?

1000
00:47:25,240 --> 00:47:30,460
从字符串中删除空格 
Remove white space from string.

1001
00:47:30,460 --> 00:47:32,060
我这么说是什么意思？
And what do I mean by this?

1002
00:47:32,060 --> 00:47:33,910
在右手边 请注意我已经
Well, on the right-hand side, notice I've

1003
00:47:33,910 --> 00:47:36,700
写入了名为NAME的变量名 
written the variable name called Name.

1004
00:47:36,700 --> 00:47:40,120
然后我使用句点或点 然后我
I've then used a period or a dot, and then I

1005
00:47:40,120 --> 00:47:42,520
似乎在做什么是一个函数 对吗？
seem to be doing what's a function, right?

1006
00:47:42,520 --> 00:47:46,300
到目前为止 每当我们看到一个函数时 我们都会看到该函数的名称--print
Any time we've seen a function thus far, we see the function's name-- print

1007
00:47:46,300 --> 00:47:49,030
或输入 然后我们看到一个括号 然后是另一个括号 
or input, then we see a parenthesis, then another parenthesis,

1008
00:47:49,030 --> 00:47:50,678
这正是我在这里看到的 
and that's exactly what I see here.

1009
00:47:50,678 --> 00:47:52,720
但我使用这个函数的方式略有不同 
But I'm using this function a little differently.

1010
00:47:52,720 --> 00:47:55,990
从技术上讲 这个函数在本文中称为方法 
Technically, this function is-- in this context-- called a method.

1011
00:47:55,990 --> 00:47:57,620
我这么说是什么意思？
And what do I mean by that?

1012
00:47:57,620 --> 00:48:00,250
嗯 如果名字是一个字符串 又名 
Well, if Name is a string, a.k.a.

1013
00:48:00,250 --> 00:48:03,130
Str 根据文件 事实证明 
STR, well it turns out, according to the documentation,

1014
00:48:03,130 --> 00:48:07,630
在Python中有很多与字符串一起提供的函数 
there's a lot of functions that come with strings in Python.

1015
00:48:07,630 --> 00:48:10,150
您可以通过使用以下命令访问该功能
And you can access that functionality by using

1016
00:48:10,150 --> 00:48:14,860
字符串的名称 就像这里的字面意思名称 然后是句点 然后是名称
the name of a string like literally name here, then a period, then the name

1017
00:48:14,860 --> 00:48:18,220
函数 然后是一个左括号和一个右括号 
of the, function and then an open parenthesis and a closed parenthesis.

1018
00:48:18,220 --> 00:48:21,320
可能是圆括号里的一些论点 但在这种情况下 
Maybe some arguments inside of those parentheses, but in this case,

1019
00:48:21,320 --> 00:48:22,900
它不需要任何争论 
it doesn't need any arguments.

1020
00:48:22,900 --> 00:48:26,320
我只想剥离左边的空间和空间
I just want to strip the space from the left and the space

1021
00:48:26,320 --> 00:48:28,000
从用户输入的右侧 
from the right of the user's input.

1022
00:48:28,000 --> 00:48:29,210
但这还不够 
But that's not enough.

1023
00:48:29,210 --> 00:48:31,120
我想要记住 我已经脱下了
I want to remember that I've stripped off

1024
00:48:31,120 --> 00:48:32,920
左边和右边的空白处 
that white space on the left and the right,

1025
00:48:32,920 --> 00:48:35,470
所以我将在这里再次使用等号 
so I'm going to use the equal sign again here.

1026
00:48:35,470 --> 00:48:38,590
请注意 就像以前一样 这并不意味着平等 
And notice that just as before, this doesn't mean equality,

1027
00:48:38,590 --> 00:48:40,940
这意味着从右到左进行分配 
this means assignment from right to left.

1028
00:48:40,940 --> 00:48:43,900
所以当这里的这行代码--名称.条带--
So when this line of code here-- name.strip--

1029
00:48:43,900 --> 00:48:46,600
回到我身边 也就是 
returns to me, a.k.a.

1030
00:48:46,600 --> 00:48:49,123
一个返回值 它将返回相同的东西
a return value, it will return the same thing

1031
00:48:49,123 --> 00:48:51,790
用户键入 但左侧不再有空格
that the user typed in, but with no more white space to the left

1032
00:48:51,790 --> 00:48:54,370
或者是白色的[咯咯地笑]在右边 
or to the white [CHUCKLES] to the right.

1033
00:48:54,370 --> 00:48:56,860
所以等号赋值是这样的
So then the equal sign assignment is going

1034
00:48:56,860 --> 00:49:00,190
要将该值从右侧复制到左侧 
to copy that value from the right to the left,

1035
00:49:00,190 --> 00:49:04,820
从而更新My Name变量中的值 
thereby updating the value inside of my name variable.

1036
00:49:04,820 --> 00:49:07,240
所以你不仅可以给变量赋值 
So you can not only assign values to variables,

1037
00:49:07,240 --> 00:49:10,300
你完全可以改变变量的值
you can absolutely change the value of variables

1038
00:49:10,300 --> 00:49:12,817
通过使用赋值运算符 再次使用等号 
by just using the assignment operator, the equal sign again,

1039
00:49:12,817 --> 00:49:15,400
一次又一次 它会一直从右边复制
and again, and again, and it will just keep copying from right

1040
00:49:15,400 --> 00:49:17,810
不管新值应该是多少 
to left whatever the new value should be.

1041
00:49:17,810 --> 00:49:23,740
所以现在如果我运行这个程序 Hello.py的Python 回车 
So now if I rerun this program, Python of Hello.py, Enter.

1042
00:49:23,740 --> 00:49:25,930
我有D-A-V-I--噢 我们再来一次 
I have D-A-V-I-- oop, let's do it again.

1043
00:49:25,930 --> 00:49:29,170
空间 空间 d-a-v-i-d在所有的空间中 
Space, space, space, space, space. d-a-v-i-d in all lowercase, space,

1044
00:49:29,170 --> 00:49:30,760
空格 回车 
space, Enter.

1045
00:49:30,760 --> 00:49:32,060
好多了
It's better.

1046
00:49:32,060 --> 00:49:34,300
它还没有固定我的资本化 所以我仍然
It hasn't fixed my capitalization, so I'm still

1047
00:49:34,300 --> 00:49:38,050
第一个D有点马虎 但它已经剥离了
being a little sloppy with the first D, But it has stripped off

1048
00:49:38,050 --> 00:49:39,430
所有这些额外的空间 
all of that extra space.

1049
00:49:39,430 --> 00:49:41,170
很小的细节 对吧？
Super minor detail, right?

1050
00:49:41,170 --> 00:49:44,050
好像这并不那么令人兴奋 但是
Like this isn't all that exciting, but it just

1051
00:49:44,050 --> 00:49:47,440
这说明了你只用一行代码就能做什么 
speaks to the power of what you can do with just a single line of code.

1052
00:49:47,440 --> 00:49:49,160
我还能做什么
Now what else can I do here?

1053
00:49:49,160 --> 00:49:51,610
我可以把用户输入的信息大写 
Well I could capitalize the user's input.

1054
00:49:51,610 --> 00:49:53,390
我来试试这个 
Let me go ahead and try this.

1055
00:49:53,390 --> 00:49:59,810
我也可以这样做--name. capitalize 
It turns out that I could also do this-- name.capitalize.

1056
00:49:59,810 --> 00:50:03,420
所以让我把用户名大写 
So let me go ahead and capitalize user's name.

1057
00:50:03,420 --> 00:50:05,170
再一次 我发表评论 
And again, I'm making comments and there's

1058
00:50:05,170 --> 00:50:06,820
没有一个正确的方式来写评论 
no one right way to write the comments.

1059
00:50:06,820 --> 00:50:08,770
我只是在这里用一些简短的英语短语
I'm just using some short English phrases here

1060
00:50:08,770 --> 00:50:10,510
提醒自己我在做什么
to remind myself of what I'm doing.

1061
00:50:10,510 --> 00:50:12,190
这是怎么回事
What's now going on here?

1062
00:50:12,190 --> 00:50:15,310
让我继续运行Hello.py的Python 回车 
Well let me go ahead and run Python of Hello.py, Enter.

1063
00:50:15,310 --> 00:50:19,240
空间 d-a-v-i-d 空间 空间 输入 
Space, space, space, space, space, d-a-v-i-d, space, space, Enter.

1064
00:50:19,240 --> 00:50:19,960
好的.
OK.

1065
00:50:19,960 --> 00:50:21,580
现在看起来更漂亮了 对吧？
Now it's looking prettier, right?

1066
00:50:21,580 --> 00:50:24,640
无论用户如何输入他们的名字 即使有点草率 
No matter how the user typed in their name, even a little sloppily,

1067
00:50:24,640 --> 00:50:25,720
我正在修正 
I'm now fixing that.

1068
00:50:25,720 --> 00:50:27,313
但让我们试试别的 
But let's try something.

1069
00:50:27,313 --> 00:50:28,730
我有点好奇了 
I'm getting a little curious here.

1070
00:50:28,730 --> 00:50:29,830
这个怎么样？
How about this?

1071
00:50:29,830 --> 00:50:33,910
空间 d-a-v-i-d空间m-a-l-a-n--
Space, space, space, space, space, d-a-v-i-d space m-a-l-a-n--

1072
00:50:33,910 --> 00:50:35,530
我现在用我的姓
I'll use my last name now--

1073
00:50:35,530 --> 00:50:36,640
输入.
Enter.

1074
00:50:36,640 --> 00:50:42,100
好吧 讽刺的是 “资本化”并不是真正的资本化我们想要的一切 
OK, so ironically, "capitalize" is not really capitalizing everything we want.

1075
00:50:42,100 --> 00:50:43,870
很明显资本化了什么？
It's clearly capitalizing what?

1076
00:50:43,870 --> 00:50:45,580
只有第一封信 
Just the very first letter.

1077
00:50:45,580 --> 00:50:48,940
结果是 Python中还有其他函数
So it turns out that, again, there's other functions in Python

1078
00:50:48,940 --> 00:50:49,960
有附带条件的
that come with strings.

1079
00:50:49,960 --> 00:50:54,670
如果我们浏览文档 滚动浏览这样的URL 
And if we poke around the documentation, scrolling through a URL like that,

1080
00:50:54,670 --> 00:50:58,540
我打赌我们会找到另一个解决方案 其中一个实际上就是这个 
I bet we'll find another solution, one of which is actually this.

1081
00:50:58,540 --> 00:51:01,180
让我们将其实际更改为标题 
Let's actually change this to title.

1082
00:51:01,180 --> 00:51:03,550
还有另一个函数与字符串一起提供
There's yet another function that comes with strings

1083
00:51:03,550 --> 00:51:07,120
被称为基于标题大写的标题 只是
called Title that do title-based capitalization, just

1084
00:51:07,120 --> 00:51:09,310
像一本书或一个人的名字 大写
like a book or a person's name, capitalizing

1085
00:51:09,310 --> 00:51:12,010
每个单词的第一个字母 
the first letter of each word.

1086
00:51:12,010 --> 00:51:14,450
这将为我们做更多的工作 
And this is just going to do a little more work for us.

1087
00:51:14,450 --> 00:51:15,880
所以让我们继续运行这个 
So let's go ahead and run this.

1088
00:51:15,880 --> 00:51:18,700
顺便说一句 我现在有点累了
And as an aside, I'm kind of tired now at this point

1089
00:51:18,700 --> 00:51:22,130
一直在打字 一直在打字 
of typing Python, Python, Python all the time.

1090
00:51:22,130 --> 00:51:25,570
事实证明 当使用这样的命令行界面时 
It turns out that when using a command line interface like this,

1091
00:51:25,570 --> 00:51:28,000
实际上 您可以重新执行所有旧命令 
you can actually go back through all of your old commands.

1092
00:51:28,000 --> 00:51:30,280
我刚才所做的就是我点击了向上箭头 
What I just did a moment ago was I hit the up arrow.

1093
00:51:30,280 --> 00:51:33,820
这会立即回顾我所有命令的历史记录
That immediately goes back through my history of all of the commands

1094
00:51:33,820 --> 00:51:34,720
我打字最多的一次 
I've ever typed.

1095
00:51:34,720 --> 00:51:37,960
所以这是一种更快的方式让我再重复一遍
So this is just a faster way now for me to repeat myself

1096
00:51:37,960 --> 00:51:39,700
而不是手动输入所有内容 
than typing everything manually.

1097
00:51:39,700 --> 00:51:42,850
让我继续按Enter 空格键 空格键 
Let me go ahead and hit Enter, space, space, space, space, space,

1098
00:51:42,850 --> 00:51:47,110
D-a-v-i-d m-a-L-a-n空格 空格 全部小写 回车 
d-a-v-i-d m-a-l-a-n space, space, all lowercase, Enter.

1099
00:51:47,110 --> 00:51:49,690
现在它看起来好多了 
Now it's looking better.

1100
00:51:49,690 --> 00:51:52,030
现在我把东西都大写了 把东西都清理干净了 
Now I've capitalized things and cleaned things up.

1101
00:51:52,030 --> 00:51:53,200
但是我的代码呢？
But what about my code?

1102
00:51:53,200 --> 00:51:55,930
我现在有八行代码 其中四行
I've got like eight lines of code now, four of which

1103
00:51:55,930 --> 00:51:58,030
是注释 其中四个是实际代码 
are comments, four of which are actual code.

1104
00:51:58,030 --> 00:51:59,710
我真的需要这么多吗？
Do I really need this much?

1105
00:51:59,710 --> 00:52:00,910
嗯 不一定 
Well, not necessarily.

1106
00:52:00,910 --> 00:52:03,520
看看我还能用Python语言做什么 
Watch what I can also do in Python.

1107
00:52:03,520 --> 00:52:07,100
让我不必费心将用户名单独大写 
Let me not bother capitalizing the user's name separately.

1108
00:52:07,100 --> 00:52:08,170
让我这么说吧--
Let me say this--

1109
00:52:08,170 --> 00:52:12,970
并将用户名大写 
and capitalize user's name.

1110
00:52:12,970 --> 00:52:15,370
我可以将这些功能链接在一起 
I can chain these functions together.

1111
00:52:15,370 --> 00:52:18,130
我可以在这篇文章的末尾加上标题 
I can add Title to the end of this.

1112
00:52:18,130 --> 00:52:19,600
现在又是怎么回事？
And now what's happening?

1113
00:52:19,600 --> 00:52:21,440
再说一次 有这样一行代码 
Well again, with a line of code like this,

1114
00:52:21,440 --> 00:52:24,490
你首先把注意力放在等号的右边 
you first focus on what's to the right of the equal sign,

1115
00:52:24,490 --> 00:52:26,470
然后我们就到等号的左边 
then we'll get to the left of the equal sign.

1116
00:52:26,470 --> 00:52:28,095
等号的右边是什么？
What's on the right of the equals sign?

1117
00:52:28,095 --> 00:52:29,240
这条线在这里 
This line here.

1118
00:52:29,240 --> 00:52:30,390
这是什么意思？
Well what does this mean?

1119
00:52:30,390 --> 00:52:35,610
获取名称变量的值 如D-A-V-I-D空格M-A-L-A-N 
Get the value of the name variable, like D-A-V-I-D space, M-A-L-A-N.

1120
00:52:35,610 --> 00:52:38,700
然后去掉左右两边的空白处 
Then strip off the white space on the left and the right.

1121
00:52:38,700 --> 00:52:40,920
这将返回一个值 
That is going to return a value.

1122
00:52:40,920 --> 00:52:44,790
它将返回D-A-V-I-D空间M-A-L-A-N 不带任何空格
It's going to return D-A-V-I-D space M-A-L-A-N without any white space

1123
00:52:44,790 --> 00:52:45,720
向左或向右 
to the left or right.

1124
00:52:45,720 --> 00:52:47,940
您希望如何处理该返回值？
What do you want to do with that return value?

1125
00:52:47,940 --> 00:52:50,850
你想让它的标题大小写 也就是
You want Python to title case it, that is

1126
00:52:50,850 --> 00:52:54,330
检查结果字符串中的每个单词
go through every word in that resulting string

1127
00:52:54,330 --> 00:52:57,000
并固定第一个单词的第一个字母 第一个字母
and fix the first letter of the first word, the first letter

1128
00:52:57,000 --> 00:52:58,390
第二个词 以此类推 
of the second word, and so forth.

1129
00:52:58,390 --> 00:53:00,330
然后--现在我们可以结束我们的想法了--
And then-- now we can finish our thought--

1130
00:53:00,330 --> 00:53:05,580
将整个代码从右向左复制到相同名称的变量中 
copy the whole thing from right to left into that same name variable.

1131
00:53:05,580 --> 00:53:06,330
你知道吗？
And you know what?

1132
00:53:06,330 --> 00:53:08,340
我可以把这件事做得更进一步 
I can take this even one step further.

1133
00:53:08,340 --> 00:53:11,400
如果我们想的话 我们为什么不继续这样做呢？
Why don't we go ahead and do this if we want.

1134
00:53:11,400 --> 00:53:16,890
让我摆脱所有这些 让我只做脱衣舞和标题
Let me get rid of all of that, and let me just do strip and title

1135
00:53:16,890 --> 00:53:18,270
都在第一条线上 
all on that first line.

1136
00:53:18,270 --> 00:53:21,380
现在我们已经从8行代码变成了4行代码 
And now we've gone from like eight lines of code to four.

1137
00:53:21,380 --> 00:53:22,740
它要紧得多 
It's a lot tighter.

1138
00:53:22,740 --> 00:53:23,880
这样整洁多了 
It's a lot neater.

1139
00:53:23,880 --> 00:53:26,250
即使理性的人可能不同意 
And even though reasonable people might disagree,

1140
00:53:26,250 --> 00:53:30,090
可以说 它更好 因为它更容易阅读 
it's arguably better because it's just easier to read.

1141
00:53:30,090 --> 00:53:32,670
更少的代码行 更少的出错机会 
Fewer lines of code, fewer opportunities for mistakes,

1142
00:53:32,670 --> 00:53:37,350
它只会让我继续处理我要解决的下一个问题 
it just allows me to move on with my next problem to solve.

1143
00:53:37,350 --> 00:53:41,730
好了 让我在这里暂停一下 看看是否有关于这些方法的问题 
All right, let me pause here and see if there's any questions on these methods.

1144
00:53:41,730 --> 00:53:45,540
方法是内置在一种值类型中的函数 
A method is a function that's built in to a type of value,

1145
00:53:45,540 --> 00:53:47,820
就像这些函数一样 
like these functions are.

1146
00:53:47,820 --> 00:53:50,640
或者在我们刚才看到的F弦上 
Or on F strings which we saw a moment ago.

1147
00:53:50,640 --> 00:53:51,390
观众：是的 嗨 
AUDIENCE: Yes, hi.

1148
00:53:51,390 --> 00:53:52,410
谢谢你 大卫 
Thanks, David.

1149
00:53:52,410 --> 00:53:56,190
那么有没有办法去掉空格之间的空格呢？
So is there a way to remove the spaces between the spaces

1150
00:53:56,190 --> 00:53:57,430
我可能会加进去的？
that I might have added?

1151
00:53:57,430 --> 00:53:58,680
大卫·马兰：简单地说 没有 
DAVID MALAN: Short answer, no.

1152
00:53:58,680 --> 00:54:01,060
如果您之前阅读了同一URL上的文档 
If you read the documentation at that same URL earlier,

1153
00:54:01,060 --> 00:54:05,090
您将看到该条带从左侧和右侧移除 但不会从两者之间移除 
you'll see that strip removes from the left and the right, but not in between.

1154
00:54:05,090 --> 00:54:07,590
事实上 还有另外两个带有字符串的函数 
In fact, there's two other functions that come with strings.

1155
00:54:07,590 --> 00:54:10,560
一条叫L条 一条叫R条 
One is called L strip, the other is called R strip,

1156
00:54:10,560 --> 00:54:12,378
这让你可以选择其中之一 
that allow you to do one or the other.

1157
00:54:12,378 --> 00:54:14,670
如果我们想要开始去除中间的空间 
If we want to start getting rid of space in the middle,

1158
00:54:14,670 --> 00:54:17,760
我们将不得不玩一个完全不同的把戏 
we're going to have to do a different trick altogether.

1159
00:54:17,760 --> 00:54:22,380
观众：有多少函数可以像这样组合在一起 
AUDIENCE: How many functions can be combine like this dot strip, dot title,

1160
00:54:22,380 --> 00:54:23,160
加在一起 
all combined.

1161
00:54:23,160 --> 00:54:24,930
那么我们可以合并多少个呢？
So how many we can combine?

1162
00:54:24,930 --> 00:54:26,970
大卫·马兰：是的 这是一个非常好的问题 
DAVID MALAN: Yeah, a really good question.

1163
00:54:26,970 --> 00:54:30,177
从技术上讲 你想要多少就有多少 但到了某个时候
Technically, as many as you want, but at some point

1164
00:54:30,177 --> 00:54:32,760
你的代码会开始看起来非常非常糟糕 对吗？
your code is going to start to look really, really bad, right?

1165
00:54:32,760 --> 00:54:35,302
因为代码行会变得非常非常长 
Because the line of code is going to get really, really long.

1166
00:54:35,302 --> 00:54:38,130
它最终可能会一次又一次地缠绕在一起 
It's eventually going to maybe wrap around again and again.

1167
00:54:38,130 --> 00:54:41,220
所以在某种程度上 你只是说 嗯-嗯 太多了 
So at some point, you just kind of say like, uh-uh, that's too many.

1168
00:54:41,220 --> 00:54:44,340
然后你开始像我一样把它分成多行 
And you start breaking it up into multiple lines like I did.

1169
00:54:44,340 --> 00:54:47,518
可能会根据需要将值重新赋值给变量 
Maybe reassigning the value to the variable as needed.

1170
00:54:47,518 --> 00:54:49,060
这实际上是一个很好的问题 
And this is actually a good question.

1171
00:54:49,060 --> 00:54:52,830
如果我可以绕过你的问题 我是说 人们是怎么想的？
If I can pivot, [INAUDIBLE] off your question, I mean, what do people think?

1172
00:54:52,830 --> 00:54:55,770
如果我们能继续把大家的手放下来一会儿 
If we could go ahead and put everyone's hands down for a moment.

1173
00:54:55,770 --> 00:54:57,690
让我问一下--
Let me ask this--

1174
00:54:57,690 --> 00:55:03,450
就是我现在做这件事的方式 用条幅、标题和输入
is the way I've done this now, with strip and title and input

1175
00:55:03,450 --> 00:55:04,800
都在同一条线上--
all in the same line--

1176
00:55:04,800 --> 00:55:07,290
比我以前的方法更好吗？
better than my previous approach?

1177
00:55:07,290 --> 00:55:10,830
在缩放中 您可以使用是图标或否图标 
In Zoom you can use the Yes icon or the No icon.

1178
00:55:10,830 --> 00:55:14,370
如果你认为这个版本更好 那就说是 
If you think this version is better, say Yes.

1179
00:55:14,370 --> 00:55:19,060
例如 如果你认为以前的版本更好 
If you think this previous version was better, for instance,

1180
00:55:19,060 --> 00:55:23,310
在这里 我们所有的事情都爆发了 说不 
this one here where we had everything broken out, say No.

1181
00:55:23,310 --> 00:55:26,610
稍后我们再来看看原因 
And then we'll see why in just a moment.

1182
00:55:26,610 --> 00:55:30,000
我早些时候提出 理性的人可以持不同意见
I proposed earlier that reasonable people can disagree

1183
00:55:30,000 --> 00:55:32,730
这绝对是事实 
and that's absolutely the case.

1184
00:55:32,730 --> 00:55:35,520
这样或那样做并不一定是最好的 
Doing it one way or the other isn't necessarily best,

1185
00:55:35,520 --> 00:55:37,800
至少如果你能证明这一点的话 
at least if you can justify it.

1186
00:55:37,800 --> 00:55:41,280
让我回到这里的最新版本 
Let me go back to the most recent version here.

1187
00:55:41,280 --> 00:55:45,360
好的 我们看到了很多赞成者和反对者 
All right so we're seeing a lot of Yeses and a lot of Nos.

1188
00:55:45,360 --> 00:55:48,900
如果可以的话 我们何不去拜访其中一位赞成者呢？
Why don't we go ahead and call on one of the Yeses, if we could.

1189
00:55:48,900 --> 00:55:52,710
投赞成票的人 为什么你认为这段代码的当前版本
Someone who's voting Yes, why do you think the current version of this code

1190
00:55:52,710 --> 00:55:57,330
真的比之前更长的代码版本更好吗？
is indeed better than the previous longer version of the code?

1191
00:55:57,330 --> 00:55:59,110
观众：我觉得它的可读性更强 
AUDIENCE: I think it's more readable.

1192
00:55:59,110 --> 00:56:03,030
所以我可以说 这就是名称变量 
So I can say, this is the name variable.

1193
00:56:03,030 --> 00:56:07,360
它得到一些输入 然后删除空格并给它一个标题 
It gets some input and then remove the space and give it a title.

1194
00:56:07,360 --> 00:56:08,320
这就对了 
And there you go.

1195
00:56:08,320 --> 00:56:09,600
你有一个你好 名字 
You have a hello, name.

1196
00:56:09,600 --> 00:56:10,860
大卫·马兰：是的 我认为这很合理 
DAVID MALAN: Yeah, I think that's pretty reasonable.

1197
00:56:10,860 --> 00:56:12,660
它的可读性非常好 至少如果你有这个习惯的话 
It's very readable, at least if you're in the habit,

1198
00:56:12,660 --> 00:56:14,660
就像你在英语里一样 从左到右阅读 
as you are in English, of reading left to right.

1199
00:56:14,660 --> 00:56:16,990
结果 它就像是一种非常自然的流动 
It just kind of flows very naturally as a result.

1200
00:56:16,990 --> 00:56:18,943
队伍并不是真的那么长 
The lines is not really that long.

1201
00:56:18,943 --> 00:56:20,860
当然 它非常适合屏幕 
It's certainly fitting nicely onto the screen.

1202
00:56:20,860 --> 00:56:21,870
所以我认为这是一个很好的论点 
So I think that's a good argument.

1203
00:56:21,870 --> 00:56:23,310
不过 找个对立面怎么样？
How about a counterpoint, though?

1204
00:56:23,310 --> 00:56:27,810
投反对票的人 如果我们可以呼吁一个认为情况更糟的人 
Someone who voted No, if we could call on someone who thinks this is worse.

1205
00:56:27,810 --> 00:56:31,410
观众：因为它根本读不懂 
AUDIENCE: Because it's not readable at all.

1206
00:56:31,410 --> 00:56:37,300
好像排了很长的队 
It seems like it's a very long line.

1207
00:56:37,300 --> 00:56:39,170
所以我觉得还是分开比较好 
So I think it's better to separate.

1208
00:56:39,170 --> 00:56:39,920
大卫·马兰：是的 
DAVID MALAN: Yeah.

1209
00:56:39,920 --> 00:56:41,580
我觉得这也很有说服力 对吧？
I think that's persuasive too, right?

1210
00:56:41,580 --> 00:56:43,050
它变得更长了一点 
It's getting a little longer.

1211
00:56:43,050 --> 00:56:46,890
尽管我在这里的句子--你的名字--相对较短 
And even though my sentence here-- what's your name-- is relatively short,

1212
00:56:46,890 --> 00:56:49,530
你可以想象 这可能会很快变得更加丑陋
you could imagine that this could get even uglier quickly

1213
00:56:49,530 --> 00:56:52,350
如果我问用户一个更长的问题 那就是
if I were asking a longer question of the user, that's

1214
00:56:52,350 --> 00:56:56,070
这会使这行代码更长 因此可读性更差 
going to make this line of code even longer and therefore less readable.

1215
00:56:56,070 --> 00:56:59,970
对于我或我的同事来说 我可能不太清楚我正在打电话给Stand
It might be less obvious to me or my colleagues that I am calling strip

1216
00:56:59,970 --> 00:57:01,530
也不知道我在叫什么头衔 
or that I am calling title.

1217
00:57:01,530 --> 00:57:03,870
这可能是一种意想不到的惊喜 
It might be kind of an unexpected surprise.

1218
00:57:03,870 --> 00:57:05,460
所以我认为这也是合理的 
So I think that's reasonable too.

1219
00:57:05,460 --> 00:57:07,570
简而言之 这里没有正确的答案 
In short, there is no right answer here.

1220
00:57:07,570 --> 00:57:10,680
事实上 提高编程水平的过程的一部分
And in fact, part of the process of getting better at programming

1221
00:57:10,680 --> 00:57:14,168
是获得自己的风格 还是为一家公司工作
is getting your own sense of style or working for a company

1222
00:57:14,168 --> 00:57:16,710
在那里他们可能会指定哪种方法比另一种方法更好
where they might prescribe which way is better than the other

1223
00:57:16,710 --> 00:57:18,930
因为他们只是想让每个人都做同样的事情 
because they just want everyone doing the same thing,

1224
00:57:18,930 --> 00:57:22,080
即使通情达理的人可能不同意 
even though reasonable people might disagree.

1225
00:57:22,080 --> 00:57:24,750
不过 最终 只要你拥有
Ultimately though, so long as you have what's

1226
00:57:24,750 --> 00:57:28,710
支持一种或另一种方式的一个相当好的论点 比如最终 
a pretty good argument in favor of one way or the other, like ultimately,

1227
00:57:28,710 --> 00:57:29,820
这才是最重要的 
that's what's important.

1228
00:57:29,820 --> 00:57:32,160
如果你只是因为你真的不知道哪一个更好而做事情 
If you're just doing things because you don't really know which one is better,

1229
00:57:32,160 --> 00:57:33,180
这可不是什么好事 
that's not great.

1230
00:57:33,180 --> 00:57:35,460
但如果你开始收集意见
But if and when you start to acquire opinions

1231
00:57:35,460 --> 00:57:38,610
如果你的老板 你的老师 你的同事 你的朋友 
and if your boss, if your teacher, if your colleague, your friend,

1232
00:57:38,610 --> 00:57:41,312
可以挑战你 说 等等 你为什么要这样做？
can challenge you and say, wait, why did you do it like this?

1233
00:57:41,312 --> 00:57:43,770
他们可能不同意你的观点 但至少有一个答案 
They might not agree with you, but at least have an answer,

1234
00:57:43,770 --> 00:57:47,010
总的来说 这应该是足够有说服力的 
and that should be sufficiently persuasive in general.

1235
00:57:47,010 --> 00:57:49,230
现在 字符串附带了一大堆其他方法
Now, strings come with a whole bunch of other methods

1236
00:57:49,230 --> 00:57:53,310
其中有一种叫做Split 顾名思义 它可以
as well, among which is one called split, which can, as the name suggests,

1237
00:57:53,310 --> 00:57:57,030
可以这么说 将一个字符串拆分成多个更小的子字符串 
split a string into multiple smaller substrings, so to speak.

1238
00:57:57,030 --> 00:57:59,040
例如 如果这里的人有这样的习惯
For instance, if the human here is in the habit

1239
00:57:59,040 --> 00:58:02,130
输入他们的名字 然后是一个空格 然后是他们的姓氏 
of typing in their first name, then a space, and then their last name,

1240
00:58:02,130 --> 00:58:05,070
你只想直接和他们打招呼 
and you want to go ahead and greet them only by first name,

1241
00:58:05,070 --> 00:58:07,140
我们实际上可以利用这个单一的空间
well we could actually leverage that single space

1242
00:58:07,140 --> 00:58:09,930
在名字和姓氏之间 并拆分该字符串
between the first name and last name and split that string

1243
00:58:09,930 --> 00:58:11,760
分成两个更小的子串 
into two smaller substrings.

1244
00:58:11,760 --> 00:58:12,820
我们怎么能做到这一点？
How can we do this?

1245
00:58:12,820 --> 00:58:14,820
好吧 让我继续 在这些字里行间
Well, let me go ahead and in between these lines

1246
00:58:14,820 --> 00:58:18,210
主动评论我们即将拆分用户的
proactively comment that we're about to split user's

1247
00:58:18,210 --> 00:58:22,230
将名字转换为名字和姓氏 
name into first name and last name.

1248
00:58:22,230 --> 00:58:25,920
然后让我们继续获取这个名称变量 它当前包含
And then let's go ahead and take that name variable, which currently contains

1249
00:58:25,920 --> 00:58:28,590
大概是大卫 太空 马兰 
something like, presumably, David, space, Malan,

1250
00:58:28,590 --> 00:58:32,130
让我继续调用Split并作为参数传入
and let me go ahead and call split and pass in as the argument

1251
00:58:32,130 --> 00:58:35,820
分隔单个空格 从而表明我确实
to split a single white space, thereby indicating that I indeed

1252
00:58:35,820 --> 00:58:37,750
我想在那个角色上分道扬镳
want to split on that character

1253
00:58:37,750 --> 00:58:41,363
现在 Split将返回一个值序列 理想情况下
Now it turns out split is going to return a sequence of values, ideally

1254
00:58:41,363 --> 00:58:42,780
先是名 然后是姓 
a first name and then a last name.

1255
00:58:42,780 --> 00:58:45,330
实际上 在Python中 我们可以为这两个值赋值
And we can actually, in Python, assign both of those values

1256
00:58:45,330 --> 00:58:47,940
从这个序列一次转换到一些变量 
from that sequence at once to some variables.

1257
00:58:47,940 --> 00:58:51,360
例如 第一个逗号最后一个等于 那就是
For instance, first comma last equals, and that's

1258
00:58:51,360 --> 00:58:53,220
会产生从右到左的效果
going to have the effect from right to left

1259
00:58:53,220 --> 00:58:56,760
将第一个这样的值放入第一个变量 第二个这样的值
of putting the first such value in the first variable, the second such value

1260
00:58:56,760 --> 00:58:57,880
在第二个变量中 
in the second variable.

1261
00:58:57,880 --> 00:59:01,350
现在 在我的最后一行代码中 我可以进去打招呼了
So now on my last line of code, I can go in and say hello

1262
00:59:01,350 --> 00:59:03,900
不是全名 比如大卫·马兰 
not to the full name, something like David Malan,

1263
00:59:03,900 --> 00:59:06,540
我可以先打个招呼 
I can just say Hello, first.

1264
00:59:06,540 --> 00:59:10,200
好的 让我们继续清除我的终端窗口 运行Hello.py的Python
All right, let's go ahead and clear my terminal window, run Python of Hello.py

1265
00:59:10,200 --> 00:59:10,807
然后按Enter键 
and hit Enter.

1266
00:59:10,807 --> 00:59:13,890
这一次我不会费心使用任何前导空格 但让我继续
I won't bother with any leading white space this time, but let me go ahead

1267
00:59:13,890 --> 00:59:19,290
然后输入David空格Malan 像往常一样交叉手指 你好 
and type in David space Malan, and crossing my fingers as usual, Hello,

1268
00:59:19,290 --> 00:59:21,720
大卫就是我们现在所看到的 
David is what we now see.

1269
00:59:21,720 --> 00:59:25,530
好的 到目前为止 我们已经看到了很多例子 其中包括
All right, so we've seen so much, so many examples thus far involving

1270
00:59:25,530 --> 00:59:29,430
字符串 但程序和编程语言肯定可以
strings, but certainly programs and programming languages can

1271
00:59:29,430 --> 00:59:32,080
也可以操纵其他类型的数据 
manipulate other types of data as well.

1272
00:59:32,080 --> 00:59:36,000
让我们继续 然后转换到另一种非常常见的数据类型
Let's go ahead and transition then to another very common type of data

1273
00:59:36,000 --> 00:59:38,610
在Python语言中 在更一般的编程中 即
in Python, in programming more generally, namely

1274
00:59:38,610 --> 00:59:41,160
整数 在Python语言中也称为int--
integers, otherwise known in Python as INT--

1275
00:59:41,160 --> 00:59:46,080
I-N-T因此 就像STR一样 S-T-R是字符串的缩写 在Python语言中也是int的缩写
I-N-T. So just as STR, S-T-R is short for string, so is INT in Python

1276
00:59:46,080 --> 00:59:47,210
整数的缩写 
short for integer.

1277
00:59:47,210 --> 00:59:48,210
那么 整数是什么？
Well, what's an integer?

1278
00:59:48,210 --> 00:59:51,390
就像在数学中一样 它是一个负2这样的数字 
Well just like in math it's a number like negative 2,

1279
00:59:51,390 --> 00:59:55,605
负1 0 1 2 一直到负无穷大 全部
negative 1, 0, 1, 2, and all the way toward negative infinity, all

1280
00:59:55,605 --> 00:59:56,980
通向正无穷大的道路 
the way toward positive infinity.

1281
00:59:56,980 --> 00:59:59,040
但是整数里没有小数点 
But there's no decimal point in an integer.

1282
00:59:59,040 --> 01:00:04,260
它只是一个数字 像负2 负1 0 1和2 
It's just a number like negative 2, negative 1, 0, 1, and 2 onward.

1283
01:00:04,260 --> 01:00:05,160
这是一个整型 
That's an INT.

1284
01:00:05,160 --> 01:00:09,360
当然 在数学世界里 我们使用了很多符号 
Of course, in the world of mathematics, there's lots of symbols that we use.

1285
01:00:09,360 --> 01:00:12,300
我们以前见过+ 尽管我们把它用在了不同的目的上 
And we've seen + before, although we used it for a different purpose.

1286
01:00:12,300 --> 01:00:15,030
但Python支持这些符号以及更多符号 
But Python supports these symbols and more.

1287
01:00:15,030 --> 01:00:18,090
而Python允许你把数字加在一起+ 
And Python allows you to add numbers together +,

1288
01:00:18,090 --> 01:00:21,580
减数、乘数、除数 
subtract numbers, multiply numbers, divide numbers.

1289
01:00:21,580 --> 01:00:25,380
这里唯一一个对人们来说可能有点陌生或陌生的
And the only one here that might look a little strange to people or unfamiliar

1290
01:00:25,380 --> 01:00:29,310
这是百分比符号 但在这种情况下 它并不意味着百分比 
is this percent sign, but it doesn't mean percent in this context.

1291
01:00:29,310 --> 01:00:32,400
如果您在Python程序中使用单个百分号 
If you use a single percent sign in a Python program,

1292
01:00:32,400 --> 01:00:34,680
这实际上就是所谓的模运算符 
that's actually the so-called modulo operator,

1293
01:00:34,680 --> 01:00:38,400
允许您在除法后取余数的运算符
the operator that allows you to take the remainder after dividing

1294
01:00:38,400 --> 01:00:40,210
一个数字接一个数字 
one number by another.

1295
01:00:40,210 --> 01:00:43,230
我们很快就会看到这样的例子 但前四个例子
So we'll see examples of that before long, but the first four of these

1296
01:00:43,230 --> 01:00:45,570
可能是非常非常熟悉的 
are perhaps quite, quite familiar.

1297
01:00:45,570 --> 01:00:49,240
事实证明 在Python中 你不一定--
Well it turns out that in Python you cannot necessarily--

1298
01:00:49,240 --> 01:00:54,480
您不必一直在像Hello.py这样的文件中编写代码
you don't necessarily have to keep writing code in a file like Hello.py

1299
01:00:54,480 --> 01:00:56,700
然后在终端窗口中运行它 
and then running it in a terminal window.

1300
01:00:56,700 --> 01:00:59,610
许多人喜欢的关于Python的功能之一
One of the features that many people like about Python

1301
01:00:59,610 --> 01:01:02,250
就是它支持这种所谓的互动模式 
is that it supports this so-called interactive mode.

1302
01:01:02,250 --> 01:01:06,240
就像您可以开始编写Python代码并立即执行
Like you can start writing Python code and immediately execute

1303
01:01:06,240 --> 01:01:08,965
其中的每一行都是交互的 尤其是
each of those lines interactively, especially

1304
01:01:08,965 --> 01:01:11,340
如果您不关心保存所有代码行的话 
if you don't care about saving all of your lines of code.

1305
01:01:11,340 --> 01:01:14,590
您只想执行代码并返回一些答案 
You just want to execute code and get back some answers.

1306
01:01:14,590 --> 01:01:18,400
例如 让我回到这里的VS代码 并关闭Hello.py
So for instance, let me go back to VS Code here and let me close Hello.py

1307
01:01:18,400 --> 01:01:22,050
让我点击终端窗口中的小三角形
and let me click on the little triangle over here in my terminal window just

1308
01:01:22,050 --> 01:01:24,880
让它变得更大 只是暂时的 
to make it much bigger just temporarily for a moment.

1309
01:01:24,880 --> 01:01:30,450
因此 我现在不会创建任何.py文件 我只会单独运行Python
So I'm not creating any .py file now, I'm just going to run Python by itself

1310
01:01:30,450 --> 01:01:31,410
在我的提示下 
at my prompt.

1311
01:01:31,410 --> 01:01:35,100
你们会看到 当我这样做的时候 我得到了一些看起来很神秘的输出
And you'll see when I do this, I get some cryptic looking output

1312
01:01:35,100 --> 01:01:38,890
以及程序最后更新的日期和时间等 
and the date and time at which the program was last updated, and so forth.

1313
01:01:38,890 --> 01:01:43,710
但我最终得到了三个像这样的三重括号 
But I ultimately get three triple brackets like this.

1314
01:01:43,710 --> 01:01:46,740
是Python的交互模式 
Is the interactive mode for Python.

1315
01:01:46,740 --> 01:01:52,050
所以我运行的是Python解释器 任何时候我输入一行代码
So I'm running the Python interpreter and any time I type a line of code

1316
01:01:52,050 --> 01:01:54,570
在解释器中 它将立即执行它 
in the interpreter, it's going to execute it immediately.

1317
01:01:54,570 --> 01:01:56,942
我不必一次又一次地运行Python 
I don't have to keep running Python again and again.

1318
01:01:56,942 --> 01:01:58,650
这就好像在人类世界里 如果你
It's as though in the human world, if you

1319
01:01:58,650 --> 01:02:01,635
站在一个会说其他语言的人旁边 
were standing next to a human who speaks some other language,

1320
01:02:01,635 --> 01:02:04,260
而你只是在和他们来回交谈 
and you're just having a conversation with them back and forth,

1321
01:02:04,260 --> 01:02:07,030
这一切都发生了--翻译过来--立刻 
it's all happening-- the translation-- immediately.

1322
01:02:07,030 --> 01:02:08,940
那么 在交互模式下我可以做什么呢？
So what might I do in interactive mode?

1323
01:02:08,940 --> 01:02:11,760
嗯 我可以做一些类似1+1的动作 进入 
Well I could do something like 1 + 1, Enter.

1324
01:02:11,760 --> 01:02:13,380
那其实是暗号 好吗？
That's actually code, all right?

1325
01:02:13,380 --> 01:02:16,590
您可能不会认为它是代码 但如果有一点算术和您的
You might not think of it as code, but if a bit of arithmetic and you

1326
01:02:16,590 --> 01:02:21,060
知道数字 你知道+ 这是有效的Python代码 
know numbers, and you know +, that's valid Python code.

1327
01:02:21,060 --> 01:02:23,537
你可以把Python当做一个奇特的计算器来使用 
And you can use Python really as a fancy calculator.

1328
01:02:23,537 --> 01:02:24,870
但我也可以做其他的事情 
But I could do other things too.

1329
01:02:24,870 --> 01:02:28,020
如果我想打印给我自己你好 世界 
If I want to print to myself Hello, world,

1330
01:02:28,020 --> 01:02:30,750
我也可以在那里打印出那一行代码--
I can also print out that line of code there too--

1331
01:02:30,750 --> 01:02:31,530
你好 世界 
Hello, world.

1332
01:02:31,530 --> 01:02:33,600
所以它是互动的 从这个意义上说 
So it's interactive in the sense that the moment

1333
01:02:33,600 --> 01:02:36,960
你执行一行代码 砰的一声 你就会看到结果 
you execute a line of code, boom, you see the result.

1334
01:02:36,960 --> 01:02:39,450
我们通常不会这样做 因为至少当
We're generally not going to do that because at least when

1335
01:02:39,450 --> 01:02:42,810
教授语言时 我们倾向于循序渐进地做事情
teaching the language, we tend to want to do things incrementally

1336
01:02:42,810 --> 01:02:45,513
我们希望你们能够看到我们来自哪里 
and we want you to be able to see where it is we came from.

1337
01:02:45,513 --> 01:02:48,180
我们希望能够一次又一次地尝试 特别是
And we want to be able to try things again and again, especially

1338
01:02:48,180 --> 01:02:49,140
如果我们犯了错误 
if we make mistakes.

1339
01:02:49,140 --> 01:02:51,690
但要知道 这确实是Python的一个功能 
But know that this is indeed a feature of Python,

1340
01:02:51,690 --> 01:02:54,250
这种所谓的互动模式 
this so-called interactive mode.

1341
01:02:54,250 --> 01:02:57,015
但现在让我们关注一下 不仅仅是这种互动 
But let's focus for a moment now, not just on that interactivity,

1342
01:02:57,015 --> 01:02:58,890
但真正基于这样一个事实 Python显然
but really on the fact that Python apparently

1343
01:02:58,890 --> 01:03:03,310
支持整数、数学和其中一些基本运算 
supports integers and mathematics and some of those basic operations.

1344
01:03:03,310 --> 01:03:06,430
让我们看看我们是不是不能做我们自己的小计算器 
And let's see if we can't make maybe our own little calculator.

1345
01:03:06,430 --> 01:03:08,820
所以让我继续 再次打开VS代码 
So let me go ahead and open up VS Code again,

1346
01:03:08,820 --> 01:03:11,440
我要缩小我的终端窗口 
and I'm going to shrink down my terminal window,

1347
01:03:11,440 --> 01:03:14,610
我将创建一个名为Calculator.py的新文件 
and I'm going to create a new file called Calculator.py.

1348
01:03:14,610 --> 01:03:17,950
因此 要进行回调 我可以在下面输入Code 
So to do that recall, I can type Code down here,

1349
01:03:17,950 --> 01:03:21,540
和我想要创建的文件的名称.py 输入 
and the name of the file I want to create, .py, Enter.

1350
01:03:21,540 --> 01:03:23,550
这给了我一个新的顶端标签 
That gives me a new tab up top.

1351
01:03:23,550 --> 01:03:25,620
所以我已经关闭了Hello.py 
So I have already closed Hello.py.

1352
01:03:25,620 --> 01:03:27,150
我现在在Calculator.py中 
I'm now in Calculator.py.

1353
01:03:27,150 --> 01:03:30,900
让我们做一个简单的计算器 为我做一些加法 
And let's just make a simple calculator that does some addition for me.

1354
01:03:30,900 --> 01:03:33,690
但我将在一个文件中这样做 这样我们就可以对此进行迭代
But I'm going to do it in a file so that we can iterate on this

1355
01:03:33,690 --> 01:03:36,607
并随着时间的推移做出改变 无论是好是坏 
and make changes for better or for worse over time.

1356
01:03:36,607 --> 01:03:38,940
让我继续 首先声明几个变量 
Let me go ahead and first declare a couple of variables.

1357
01:03:38,940 --> 01:03:42,840
我要做一个数学运算 把我的第一个变量命名为x 
I'm going to do the mathematical thing of calling my first variable x,

1358
01:03:42,840 --> 01:03:45,840
我的第二个变量y 然后我要给自己
my second variable y, and then I'm going to give myself

1359
01:03:45,840 --> 01:03:48,720
第三个变量z=x+y 
a third variable z = x + y.

1360
01:03:48,720 --> 01:03:50,970
然后我将继续打印z 
And then I'm going to go ahead and print out z.

1361
01:03:50,970 --> 01:03:54,858
现在这个节目 诚然不是很令人兴奋或有趣 
Now this program, admittedly not very exciting or interesting,

1362
01:03:54,858 --> 01:03:57,900
事实上 它没有在屏幕上打印东西那么有趣
in fact, it's a little less interesting than printing stuff on the screen

1363
01:03:57,900 --> 01:04:01,110
就像以前使用字符串一样 但我们将在此基础上进行构建
like before with strings, but we'll build on this

1364
01:04:01,110 --> 01:04:04,030
看看我们还可以利用在Python中的哪些其他特性 
and see what other features exist in Python that we can leverage.

1365
01:04:04,030 --> 01:04:07,410
所以希望 如果Python像我一样知道这是数学问题 
So hopefully, if Python knows it's math as well as I do,

1366
01:04:07,410 --> 01:04:13,140
当我运行Calculator.py的Python时 我应该希望看到1+2
when I run Python of Calculator.py, I should see hopefully that 1 + 2

1367
01:04:13,140 --> 01:04:15,600
=确实是3 
= indeed 3.

1368
01:04:15,600 --> 01:04:18,510
好吧 所以并不令人惊讶 也不是那么有趣 
All right, so not that surprising and not that interesting.

1369
01:04:18,510 --> 01:04:20,730
老实说 这不是最有用的程序
And honestly this isn't the most useful program

1370
01:04:20,730 --> 01:04:24,840
因为它总是要计算1+2=3 
because it's always going to calculate 1 + 2 = 3.

1371
01:04:24,840 --> 01:04:28,170
让我们至少让这个节目 比如说 更具互动性 对吗？
Let's at least make this program, say, a little more interactive, right?

1372
01:04:28,170 --> 01:04:31,590
我们已经从前面的例子中知道了如何从用户那里获得输入 
We already know from previous examples how we can get input from the user.

1373
01:04:31,590 --> 01:04:33,540
让我们恢复输入函数 
Let's bring back that input function.

1374
01:04:33,540 --> 01:04:37,380
让我们这样做 让我现在继续 在我的代码的顶部 
And let's do this, let me go ahead now and at the top of my code,

1375
01:04:37,380 --> 01:04:40,650
让我们将x更改为不总是数字1 
let's change x to not be the number 1 always,

1376
01:04:40,650 --> 01:04:42,510
让我们把它改成任何回报
let's change it to be whatever the return

1377
01:04:42,510 --> 01:04:45,690
价值在于向用户索要x 
value is of asking the user for x.

1378
01:04:45,690 --> 01:04:48,730
我可以在这里使用任何我想要的英语或人类语言 
And I can use any English or human language I want here.

1379
01:04:48,730 --> 01:04:49,890
我要说 x是什么？
I'm going to say, what's x?

1380
01:04:49,890 --> 01:04:52,410
就像我之前问的 你叫什么名字？
Just like I asked before, what's your name?

1381
01:04:52,410 --> 01:04:54,180
我也会为y做同样的事情 
And I'm going to do the same thing for y.

1382
01:04:54,180 --> 01:04:57,330
我将再次使用输入 但这一次将问题改为 
I'm going to use Input again, but this time change the question to be,

1383
01:04:57,330 --> 01:04:58,728
你是什么？
what's y?

1384
01:04:58,728 --> 01:05:01,770
好了 在这一点上 我想我将把剩下的代码
All right, at this point, I think I'm going to leave the rest of the code

1385
01:05:01,770 --> 01:05:02,730
一样的 
the same.

1386
01:05:02,730 --> 01:05:06,450
Z=x+y 然后打印z 但什么是好的
Z = x + y And then print z but what's nice

1387
01:05:06,450 --> 01:05:10,140
现在我想我有了一个很好的交互式计算器 
now is that I think I have a nice interactive calculator.

1388
01:05:10,140 --> 01:05:12,510
好的 现在它不会一直做1+2 
Right, now it's not going to do 1 + 2 all the time.

1389
01:05:12,510 --> 01:05:16,330
它将执行用户输入的任何内容+用户输入的任何内容 
It's going to do whatever the user types + whatever the user types.

1390
01:05:16,330 --> 01:05:17,530
那么让我们来试试这个 
So let's try this.

1391
01:05:17,530 --> 01:05:19,080
让我继续运行这个程序 
Let me go ahead and run that program.

1392
01:05:19,080 --> 01:05:20,110
好了 我们开始吧 
All right, let's do it.

1393
01:05:20,110 --> 01:05:26,670
1将是x 2将是y 当然 所有同意的人 1
1 is going to be x, 2 is going to be y, and of course, everyone in agreement, 1

1394
01:05:26,670 --> 01:05:30,762
+2=Thr--
+ 2 = thr--

1395
01:05:30,762 --> 01:05:31,980
哈 
huh.

1396
01:05:31,980 --> 01:05:36,040
那是怎么回事？
What's going on there?

1397
01:05:36,040 --> 01:05:40,720
不是你的数学课误导了你 就是我误导了你 
Either your math class misled you or I have misled you.

1398
01:05:40,720 --> 01:05:43,000
我们为什么不叫个人来看看你是否
Why don't we call on someone here to see if you

1399
01:05:43,000 --> 01:05:46,900
不能帮助我们推断错误是什么 错误在哪里？
can't help us reason through what the bug is, what's the mistake?

1400
01:05:46,900 --> 01:05:48,970
安加利 如果我没说错的话 
Anjali, if I'm saying it right.

1401
01:05:48,970 --> 01:05:52,960
观众：我认为问题在于它连接了字符串 因为你
AUDIENCE: I think the issue is that it's concatenating strings because you

1402
01:05:52,960 --> 01:05:54,935
使用+运算符 而不是加法 
use the + operator instead of adding.

1403
01:05:54,935 --> 01:05:55,810
大卫·马兰：太好了 
DAVID MALAN: Perfect.

1404
01:05:55,810 --> 01:05:57,040
如此完美的直觉 
So perfect intuition.

1405
01:05:57,040 --> 01:06:01,060
我们已经看到+在字符串上下文中的用法略有不同
We've seen that + is used a little differently in the context of strings

1406
01:06:01,060 --> 01:06:03,940
因为它连接 也就是连接两个字符串 
because it concatenates, that is, it joins the two strings,

1407
01:06:03,940 --> 01:06:06,100
这似乎确实是这里正在发生的事情 
and that seems to Indeed be what's happening here,

1408
01:06:06,100 --> 01:06:07,990
即使用户输入了数字 
even though the user typed a number.

1409
01:06:07,990 --> 01:06:09,910
但有趣的是 
But the interesting thing here is that, when

1410
01:06:09,910 --> 01:06:13,660
你得到用户输入 因为他们在Mac上使用键盘
you get user input, because they're using a keyboard on their Mac

1411
01:06:13,660 --> 01:06:16,900
或者电脑或者手机 都是短信
or PC or their phone, it is always going to be text.

1412
01:06:16,900 --> 01:06:19,030
它可能看起来像一个数字 但默认情况下 
It might look like a number, but by default,

1413
01:06:19,030 --> 01:06:21,850
从键盘上传来的字符串
it's coming from the keyboard as a string--

1414
01:06:21,850 --> 01:06:23,560
即作为文本 
that is, as text.

1415
01:06:23,560 --> 01:06:27,760
那么 如果我们最终
And so, how do we go about resolving this if ultimately we

1416
01:06:27,760 --> 01:06:30,190
我不想把这些输入当作字符串 
don't want to treat those inputs as strings,

1417
01:06:30,190 --> 01:06:32,110
我们要把它们当作真实的数字吗
we want to treat them as actual numbers?

1418
01:06:32,110 --> 01:06:35,050
我们需要另一个函数 在Python中
Well we need another function and it turns out in Python

1419
01:06:35,050 --> 01:06:39,610
有时候你可以把一种数据转换成另一种数据 
that you can convert sometimes from one type of data to another type of data,

1420
01:06:39,610 --> 01:06:43,880
例如 从字符串到INT 通过这样做 
for instance, from string to INT by doing something like this.

1421
01:06:43,880 --> 01:06:46,690
让我回到我的代码 让我改变
Let me go back into my code and let me change

1422
01:06:46,690 --> 01:06:51,730
在把它加到y之前 
x before adding it to y to be whatever the integer version of x

1423
01:06:51,730 --> 01:06:56,030
是 +不管y的整数形式是什么 
is, + whatever the integer version of y is.

1424
01:06:56,030 --> 01:06:59,950
因此 INT不仅是Python中的一种数据类型 
So it turns out that INT is not only a type of data in Python,

1425
01:06:59,950 --> 01:07:02,590
它也是一个函数 
it's also a function, and it's a function

1426
01:07:02,590 --> 01:07:05,410
如果你传入一个输入 比如一个字符串 
that if you pass in an input, like a string,

1427
01:07:05,410 --> 01:07:09,790
只要这个字符串看起来像1或2这样的数字 
so long as that string looks like a number like 1 or like 2,

1428
01:07:09,790 --> 01:07:13,450
它会把它转换成一个实际的数字 
it will convert it to an actual number that you can perform mathematics

1429
01:07:13,450 --> 01:07:14,510
而不是 
on instead.

1430
01:07:14,510 --> 01:07:18,340
如果我现在回到终端窗口运行Python
So if I now go back to my terminal window and run Python--

1431
01:07:18,340 --> 01:07:19,870
我再给你看一个小把戏
and let me show you another trick.

1432
01:07:19,870 --> 01:07:21,580
“计算器”这个词有点长
"Calculator" is kind of a long word.

1433
01:07:21,580 --> 01:07:22,930
打字有点乏味 
It's a little tedious to type.

1434
01:07:22,930 --> 01:07:26,470
注意我可以在终端窗口的命令行中做什么
Notice what I can do in my terminal window, in a command line

1435
01:07:26,470 --> 01:07:27,460
接口一般 
interface in general.

1436
01:07:27,460 --> 01:07:31,300
如果我开始输入C-A-L作为计算器 
If I start typing C-A-L for calculator, I can actually

1437
01:07:31,300 --> 01:07:33,700
按Tab完成我的想法 
hit Tab to finish my thought.

1438
01:07:33,700 --> 01:07:36,550
所以在这样的终端窗口中自动完成是可能的 
So auto-complete is possible in a terminal window like this.

1439
01:07:36,550 --> 01:07:39,663
输入第一个字母或几个字母 然后 砰 与标签 
Type the first letter or few letters and then, boom, with Tab,

1440
01:07:39,663 --> 01:07:41,080
它会帮你完成你的想法
it'll finish your thought for you.

1441
01:07:41,080 --> 01:07:44,770
或者你可以像我用上下箭头那样回到你的历史中 
Or you can go back in your history like I did with the Up and Down Arrows.

1442
01:07:44,770 --> 01:07:46,570
让我继续执行这个 
Let me go ahead and execute this.

1443
01:07:46,570 --> 01:07:47,270
什么是X？
What's x?

1444
01:07:47,270 --> 01:07:47,770
1.
1.

1445
01:07:47,770 --> 01:07:48,290
什么是X？
What's x?

1446
01:07:48,290 --> 01:07:48,790
2.
2.

1447
01:07:48,790 --> 01:07:49,880
好了
And there we go.

1448
01:07:49,880 --> 01:07:53,050
现在我们有了一个通用计算器 
Now we have a general purpose calculator that's going to support

1449
01:07:53,050 --> 01:07:57,280
不只是1和2的加法 而是任意两个
not just the addition of 1 and 2, but now any two

1450
01:07:57,280 --> 01:07:58,882
用户键入的整数 
integers that the user types.

1451
01:07:58,882 --> 01:08:00,340
现在让我来改进一下 好吗？
And let me now improve this, right?

1452
01:08:00,340 --> 01:08:03,190
我们已经了解了如何改进代码
We've seen how we can make improvements to code

1453
01:08:03,190 --> 01:08:05,650
我不知道这是否一定会更好 
and I don't know if it's going to necessarily be better,

1454
01:08:05,650 --> 01:08:07,000
但让我们来试试这个 
but let's try this.

1455
01:08:07,000 --> 01:08:09,730
我真的需要z变量吗？
Do I really need the z variable?

1456
01:08:09,730 --> 01:08:13,630
值得注意的是 我正在创建一个名为z的变量 
It's worth noting that I'm creating a variable called z,

1457
01:08:13,630 --> 01:08:16,720
然后我立即在下一行代码中使用它 
and then I'm immediately using it on the next line of code.

1458
01:08:16,720 --> 01:08:20,770
这并不是很有说服力 因为如果你要创建一个变量
Now that's not that compelling, because if you're creating a variable

1459
01:08:20,770 --> 01:08:23,470
然后立即使用它 但永远不会再使用它 
and then immediately using it, but never again using it,

1460
01:08:23,470 --> 01:08:26,890
你真的需要花时间介绍另一个符号吗？
did you really need to take the time to introduce another symbol

1461
01:08:26,890 --> 01:08:30,279
和另一个变量 只使用一次 只使用一次？
and another variable just to use it once and only once?

1462
01:08:30,279 --> 01:08:31,090
嗯 也许不是 
Well, maybe not.

1463
01:08:31,090 --> 01:08:33,729
也许我们在这种情况下并不真正需要z 
Maybe we don't really need z in this way.

1464
01:08:33,729 --> 01:08:38,319
也许我应该去做一些这样的事情 
Maybe I should go and do something like this.

1465
01:08:38,319 --> 01:08:41,140
也许我应该在这里除掉z 
Maybe I should get rid of z here.

1466
01:08:41,140 --> 01:08:45,729
也许我应该把这个改成INT 换掉
Maybe I should change this to be INT up here, change

1467
01:08:45,729 --> 01:08:50,260
这是在这里 做了一些现在很有趣的事情 
this to be INT up here, doing something that's pretty interesting now.

1468
01:08:50,260 --> 01:08:53,680
尽管这是一种新的语法 但请注意
Even though it's a bit of new syntax, notice that you

1469
01:08:53,680 --> 01:08:56,380
可以说 可以嵌套函数 
can nest functions, so to speak.

1470
01:08:56,380 --> 01:09:01,330
您可以将一个函数调用放入一个函数的使用
You can put one function call that is the use of a function

1471
01:09:01,330 --> 01:09:04,540
在内部使用另一个函数 以便返回
inside of the use of another function so that the return

1472
01:09:04,540 --> 01:09:09,040
内部函数的值将成为
value of the inner function becomes the argument to

1473
01:09:09,040 --> 01:09:11,410
或外部函数的输入 
or the input to the outer function.

1474
01:09:11,410 --> 01:09:14,510
就像在数学中 如果你有圆括号 
Just like in math, if you have parentheses, parentheses, parentheses,

1475
01:09:14,510 --> 01:09:16,218
你的老师可能教你要集中注意力
your teacher probably taught you to focus

1476
01:09:16,218 --> 01:09:18,430
先看看最里面的圆括号里有什么
on what's inside the innermost parentheses first

1477
01:09:18,430 --> 01:09:19,603
然后自己想办法脱身 
and then work your way out.

1478
01:09:19,603 --> 01:09:20,770
编程也是如此 
Same thing with programming.

1479
01:09:20,770 --> 01:09:22,040
这就是Python要做的事情 
That's what's Python is going to do.

1480
01:09:22,040 --> 01:09:24,729
它将首先查看括号内的内容 
It's going to look at what's inside of the parentheses first,

1481
01:09:24,729 --> 01:09:26,920
它会得到答案 然后它就会
it's going to get the answer, and then it's

1482
01:09:26,920 --> 01:09:30,710
将返回值传递给最外层的函数 
going to pass the return value to the outermost function.

1483
01:09:30,710 --> 01:09:34,600
所以现在在第1行发生的事情是 输入函数首先被调用 
So what happens on line 1 now is that the input function gets called first,

1484
01:09:34,600 --> 01:09:37,990
然后 结果是 引用不引用的一
then the result of that, quote unquote one

1485
01:09:37,990 --> 01:09:42,670
成为int函数的输入 在第2行上也是如此 
becomes the input to the INT function, and same on line 2.

1486
01:09:42,670 --> 01:09:47,300
Y的输出变成了这个int函数的输入 
The output of what's y becomes the input to this INT function.

1487
01:09:47,300 --> 01:09:49,479
现在没有z了 
And now there is no z.

1488
01:09:49,479 --> 01:09:52,210
我可以只打印x+y 
I could just do print x + y.

1489
01:09:52,210 --> 01:09:56,410
因为我花了时间把每一个字符串
And because I've taken the time to convert each of those strings

1490
01:09:56,410 --> 01:09:58,720
到了一个整数 我想我们就可以了 
to an integer, I think we're OK.

1491
01:09:58,720 --> 01:10:01,570
让我试一试 Calculator.py的Python 回车 
So let me try this, Python of Calculator.py, Enter.

1492
01:10:01,570 --> 01:10:05,170
1和2 而我们仍然得到3 
1 and 2, and we're still getting 3.

1493
01:10:05,170 --> 01:10:09,130
不是12 或者不是12 1 2 我们确实得到了3 
Not 12, or not 12, 1,2, we're indeed getting 3.

1494
01:10:09,130 --> 01:10:11,350
我们还去掉了变量
And we've additionally gotten rid of the variable

1495
01:10:11,350 --> 01:10:13,900
因为我们似乎不一定需要它 
because we didn't necessarily need it, it seems,

1496
01:10:13,900 --> 01:10:15,490
尤其是如果只用一次的话 
especially if only using it once.

1497
01:10:15,490 --> 01:10:18,280
好吧 在这里也是 让我把每个人的手放下来一会儿
Well here too, let me put everyone's hands down for just a moment

1498
01:10:18,280 --> 01:10:19,930
让我一如既往地问--
and let me ask as before--

1499
01:10:19,930 --> 01:10:26,530
这个版本现在在输入的调用周围使用int 
this version now which uses INT around the invocations of input,

1500
01:10:26,530 --> 01:10:30,640
并且没有使用z 这比以前的版本更好吗？
and does not use z, is this better than the previous version?

1501
01:10:30,640 --> 01:10:32,560
如果你想投赞成票 那就投赞成票 
If you want to vote Yes, go ahead.

1502
01:10:32,560 --> 01:10:35,270
或者 如果你更喜欢旧的方式 投反对票 
Or if you prefer the old way, vote No.

1503
01:10:35,270 --> 01:10:40,455
原来的方式是 我会在投票时取消这一切 而不是像这样 
The old way, I'll undo all of this as we vote, instead looked like this.

1504
01:10:43,510 --> 01:10:45,850
好的 现在让我回到最新的版本 
All right, and let me go back to now the newest version.

1505
01:10:45,850 --> 01:10:48,040
让我们握住赞成者的手 这个人
Let's take a hand of the Yeses, someone who

1506
01:10:48,040 --> 01:10:51,430
认为这个最新版本更好 
thinks this latest version is better.

1507
01:10:51,430 --> 01:10:57,130
观众：我认为这种方式更好 因为它可以让我们立即看到
AUDIENCE: I think this way is better because it allows us to immediately see

1508
01:10:57,130 --> 01:11:01,840
对于整数 x和y变量是什么
what the x and y variables are with integers

1509
01:11:01,840 --> 01:11:04,660
因此 我们知道应该从他们那里得到什么 
and so we know what to expect from them.

1510
01:11:04,660 --> 01:11:09,250
而且 印刷品的论点也更直观 
And also the print argument is more intuitive.

1511
01:11:09,250 --> 01:11:12,330
我们避免了代码中的太多混乱 
We avoid too much clutter in the code.

1512
01:11:12,330 --> 01:11:14,330
大卫·马兰：我认为这些都是很好的理由 
DAVID MALAN: I think those are all good reasons.

1513
01:11:14,330 --> 01:11:15,370
它很好 也很简洁 
It's nice and succinct.

1514
01:11:15,370 --> 01:11:17,650
代码行不是很长 
The lines of code are not very long.

1515
01:11:17,650 --> 01:11:20,530
我不需要知道z是什么 因为它不存在 
I don't need to know what z is because it doesn't exist.

1516
01:11:20,530 --> 01:11:21,820
它只看到打印x+y 
It just sees print x + y.

1517
01:11:21,820 --> 01:11:22,390
我喜欢那样 
I like that.

1518
01:11:22,390 --> 01:11:25,990
但有人更喜欢老式的方式 我们确实有z
But someone who prefers the older way where we did have z

1519
01:11:25,990 --> 01:11:30,970
并且我们更显式地将单个变量传递给int函数 
and we more explicitly passed individual variables to the INT function.

1520
01:11:30,970 --> 01:11:32,050
观众：是的 嗨 
AUDIENCE: Yeah, hi.

1521
01:11:32,050 --> 01:11:36,100
我认为较早的版本更好 因为当--
I think that the earlier version is better because when--

1522
01:11:36,100 --> 01:11:39,370
我的意思是 如果用户输入的内容不是 
I mean, if user input something else other than,

1523
01:11:39,370 --> 01:11:43,570
比方说 我是说 比方说 他们输入1和2 
let's say, I mean, let's say, they type 1 and 2, like,

1524
01:11:43,570 --> 01:11:46,780
因此 它将更容易调试 
so it will be easier to debug.

1525
01:11:46,780 --> 01:11:49,807
大卫·马兰：这个版本还是--这里的这个版本还是旧的版本？
DAVID MALAN: This version or-- this version here or the old version?

1526
01:11:49,807 --> 01:11:50,890
观众：老版本 
AUDIENCE: The old version.

1527
01:11:50,890 --> 01:11:52,098
大卫·马兰：好的 这很公平 
DAVID MALAN: OK, that's fair.

1528
01:11:52,098 --> 01:11:57,190
事实上 我今天非常小心 尽我所能 不要搞砸了 
And in fact, I'm being very careful today, as best I can, not to mess up.

1529
01:11:57,190 --> 01:12:01,050
到目前为止 我只输入整数 当我期待整数 
I have thus far only inputted integers when I'm expecting integers.

1530
01:12:01,050 --> 01:12:02,800
拉乌尔实际上在指着什么东西
And Raoul's actually pointing to something

1531
01:12:02,800 --> 01:12:05,980
我们会在接下来的几周里继续讨论 我们实际上是如何处理错误的？
we'll come back to in the coming weeks, how do we actually handle errors?

1532
01:12:05,980 --> 01:12:09,770
如果用户没有输入数字1或数字2 
What if the user doesn't type in the number 1 or the number 2, or a number

1533
01:12:09,770 --> 01:12:10,270
一点都不吗
at all?

1534
01:12:10,270 --> 01:12:13,390
如果他们输入一个词 如猫 C-A-T？
What if they type in a word like cat, C-A-T?

1535
01:12:13,390 --> 01:12:16,150
这不是一个数字 我打赌我不能把它转换成整数 
That's not a number, and I bet I can't convert it to an integer.

1536
01:12:16,150 --> 01:12:18,110
但今天 我不会把重点放在这上面 
But for today, I'm not going to focus on that.

1537
01:12:18,110 --> 01:12:20,110
我只希望用户能合作 
I'm just going to hope that the user cooperates.

1538
01:12:20,110 --> 01:12:21,740
但事实并非如此 
But that's not going to be the case.

1539
01:12:21,740 --> 01:12:24,280
所以也许有一种方法可以让我们取得更大的成功
And so perhaps one way would set us up for more success

1540
01:12:24,280 --> 01:12:26,020
当涉及到处理这些错误 
when it comes to handling those errors.

1541
01:12:26,020 --> 01:12:28,495
就今天的目的而言 哪一个更好？
Now for today's purposes, which is better?

1542
01:12:28,495 --> 01:12:29,650
呃 我是说 我两个都喜欢 
Eh, I mean, I like both.

1543
01:12:29,650 --> 01:12:32,440
我认为你们两个都提出了非常有效的论点 
And I think both of you made very valid arguments in there too,

1544
01:12:32,440 --> 01:12:36,250
只要你有合理的理由
so long as you have a justification that feels pretty reasonable.

1545
01:12:36,250 --> 01:12:37,930
我是说 这才是最重要的 
I mean, that's what ultimately matters.

1546
01:12:37,930 --> 01:12:41,500
但是 再次获得一种权衡的感觉 
But acquiring, again, a sense of the trade-offs here.

1547
01:12:41,500 --> 01:12:43,180
这样好点吗
Well, is this way better?

1548
01:12:43,180 --> 01:12:44,885
如果是 原因是什么？
If so, why or why not?

1549
01:12:44,885 --> 01:12:46,760
只是了解这些权衡是什么 
Just understanding what those trade-offs are.

1550
01:12:46,760 --> 01:12:51,460
但总的来说 优先考虑可读性是一件非常好的事情 
But generally speaking, prioritizing readability is a very good thing.

1551
01:12:51,460 --> 01:12:54,740
让你的代码对其他人可读是一件非常好的事情
Making your code readable for someone else is a very good thing

1552
01:12:54,740 --> 01:12:57,608
对你也有好处 所以当你第二天早上醒来时 
and very good for you too so that when you wake up the next morning,

1553
01:12:57,608 --> 01:12:59,650
或者下周或者明年再来
or you come back the next week, or the next year,

1554
01:12:59,650 --> 01:13:02,290
你也可以读你自己的代码 而不必浪费
you too can read your own code without having to waste

1555
01:13:02,290 --> 01:13:04,270
花时间回忆你做了什么
time trying to remember what you did.

1556
01:13:04,270 --> 01:13:08,500
而且简单往往也是一件好事--保持代码简单 
And simplicity tends to be a good thing too-- keeping your code simple.

1557
01:13:08,500 --> 01:13:10,960
所以当你对编程越来越熟悉的时候 
So as you get more comfortable with programming,

1558
01:13:10,960 --> 01:13:15,250
您可能会尝试将整个程序合并为一个长行 
you might be tempted to try to combine an entire program into one long line.

1559
01:13:15,250 --> 01:13:17,740
例如 让我来做这个 
For instance, let me do just that.

1560
01:13:17,740 --> 01:13:20,680
从技术上讲 我们并不需要变量中的x 
Technically speaking, we don't really need x in a variable.

1561
01:13:20,680 --> 01:13:22,480
我们不需要变量中的y 
We don't really need y in a variable.

1562
01:13:22,480 --> 01:13:24,460
我们也可以这样做
We could also do this--

1563
01:13:24,460 --> 01:13:27,820
我可以把x和y一起去掉 
I could just get rid of x and y altogether.

1564
01:13:27,820 --> 01:13:32,080
然后 我现在可以去掉它 使其只有一行代码 
I could then now eliminate that and make it just one line of code.

1565
01:13:32,080 --> 01:13:34,510
好的 所以在某种意义上 你可能会想 哇 
OK, so on some sense, you might be inclined to think, wow,

1566
01:13:34,510 --> 01:13:35,740
真是太好了 
that's really nice.

1567
01:13:35,740 --> 01:13:38,410
你让它变成了一行简单的代码 
You made it one simple line of code.

1568
01:13:38,410 --> 01:13:40,520
我会争辩说 这实际上并没有那么简单 
I would argue this actually isn't that simple.

1569
01:13:40,520 --> 01:13:43,180
现在我想我开始筑巢太多东西了 
Now I think I'm starting to nest too many things.

1570
01:13:43,180 --> 01:13:46,330
我必须考虑打印、int和输入 
I have to think about print and INT and input.

1571
01:13:46,330 --> 01:13:49,150
然后我必须注意到 好的 我打开了两个括号 
I then have to notice that, OK, I've opened two parentheses,

1572
01:13:49,150 --> 01:13:50,300
我已经关闭了其中两家 
I've closed two of them.

1573
01:13:50,300 --> 01:13:51,040
有一个+ 
There's a +.

1574
01:13:51,040 --> 01:13:53,680
你让我想得太多了 任何时候你让我想 
You're making me think too much and any time you make me think,

1575
01:13:53,680 --> 01:13:54,730
你在浪费时间 
you're wasting time.

1576
01:13:54,730 --> 01:13:58,360
任何时候 当你把代码的外观复杂化时 
And any time you complicate the look of the code like this,

1577
01:13:58,360 --> 01:14:01,300
你只会增加犯错的可能性
you're just going to increase the probability of mistakes

1578
01:14:01,300 --> 01:14:04,270
以及代码中的战术错误或逻辑错误 
and tactical mistakes or logical errors in your code.

1579
01:14:04,270 --> 01:14:07,810
因此 如果我们所做的所有事情 这是我唯一要争辩的 
So if all the things we've done, this is the only one that I would argue,

1580
01:14:07,810 --> 01:14:10,870
是的 只有一条线路 又漂亮又紧凑 
yes, it's one line and it's nice and compact.

1581
01:14:10,870 --> 01:14:12,340
它只是可读性不够 
It's just not readable enough.

1582
01:14:12,340 --> 01:14:15,850
我会避免这样做 特别是因为其中两个函数
I would shy away from doing this, especially since two of those function

1583
01:14:15,850 --> 01:14:18,040
呼叫正在从用户处获得输入 
calls are getting input from the user.

1584
01:14:18,040 --> 01:14:20,410
但在那里 理性的人可能不会同意 
But there too, reasonable people might disagree,

1585
01:14:20,410 --> 01:14:23,830
但这是一种你有时应该有的本能反应
but that's the kind of visceral reaction you should have sometimes when

1586
01:14:23,830 --> 01:14:28,300
代码开始变得有点太复杂 有点太聪明 
code starts getting a little too complicated, a little too clever,

1587
01:14:28,300 --> 01:14:31,450
也许 这是为了它的利益 
perhaps, for its own good.

1588
01:14:31,450 --> 01:14:34,270
好吧 我们不只是能接触到整数 
All right, well it's not just integers we have access to.

1589
01:14:34,270 --> 01:14:38,920
让我建议在这里将整数转换为另一种数据类型 
Let me propose that we transition from integers to one more data type here,

1590
01:14:38,920 --> 01:14:40,360
也就是浮点 
namely a float.

1591
01:14:40,360 --> 01:14:43,390
同样 字符串是一系列文本 
So again, a string is a sequence of text.

1592
01:14:43,390 --> 01:14:46,570
整数是像负1、0和1一样的整数 
An INT is an integer like negative 1, 0 and 1.

1593
01:14:46,570 --> 01:14:50,860
浮点数是一个带有小数点的数字 恰当地称为浮点数
A float is a number with a decimal point, properly called a floating point

1594
01:14:50,860 --> 01:14:51,470
价值 
value.

1595
01:14:51,470 --> 01:14:53,470
你可以把浮点数想象成
And you can think of the floating point as being

1596
01:14:53,470 --> 01:14:56,740
可能在这里或这里的小数位数
the decimal that might be over here or over here with some number of digits

1597
01:14:56,740 --> 01:14:57,820
向左或向右 
to the left or the right.

1598
01:14:57,820 --> 01:15:02,000
从数学上讲 它是一个实数 一个有小数点的数字 
Mathematically, it's a real number, a number that has a decimal point in it.

1599
01:15:02,000 --> 01:15:04,750
这是第三种类型的数据 也就是Python支持的数据 
So that's a third type of data that Python supports.

1600
01:15:04,750 --> 01:15:07,270
现在我们的计算器有点幼稚
Right now our calculator is somewhat naively

1601
01:15:07,270 --> 01:15:09,820
假设用户仅要键入整数 
assuming that the user is only going to type in integers,

1602
01:15:09,820 --> 01:15:12,970
但如果我也想支持浮点值 
but if I want to support floating point values too,

1603
01:15:12,970 --> 01:15:15,070
我想我可以做几个小调整 
I think I can just make a couple of tweaks.

1604
01:15:15,070 --> 01:15:17,270
所以我要回到VS代码这一点 
So I'm going to go back to VS Code here.

1605
01:15:17,270 --> 01:15:20,890
并且不是仅仅将用户的输入x和y转换为
And instead of just converting the user's input x and y to

1606
01:15:20,890 --> 01:15:23,950
第一行和第二行的整数 让我们做一个简单的更改 
integers on line 1 and 2, let's just make a simple change.

1607
01:15:23,950 --> 01:15:27,400
让我们将其实际转换为第一行的浮点数
Let's actually convert it to a float on the first line

1608
01:15:27,400 --> 01:15:30,640
在这里的第二行有一个花车 
and a float on the second line here.

1609
01:15:30,640 --> 01:15:35,410
现在我想 如果我下到我的终端窗口并运行Calculator.py的Python 
Now I think, if I go down to my terminal window and run Python of Calculator.py,

1610
01:15:35,410 --> 01:15:39,040
让我们输入一个带小数点的数字 比如1.2
let's type in a number like 1.2 with a decimal point

1611
01:15:39,040 --> 01:15:42,100
加上一个小数点的3.4 我们就开始了 
and 3.4 with a decimal point, and there we go.

1612
01:15:42,100 --> 01:15:44,510
我们的最终答案是4.6 
We have 4.6 as the final answer.

1613
01:15:44,510 --> 01:15:48,250
因此 如果我只期待整数 这在以前是行不通的
So that wouldn't have worked before if I was only expecting integers

1614
01:15:48,250 --> 01:15:51,550
来自用户的值 但现在我需要浮点值
from the user, but now that I'm expecting floating point values

1615
01:15:51,550 --> 01:15:56,180
适应它 我现在实际上也可以做浮点算术了 
and accommodating it, I can actually now do floating point arithmetic as well.

1616
01:15:56,180 --> 01:15:59,020
但假设我并不真正想要最终的答案
But suppose that I don't really want the final answer

1617
01:15:59,020 --> 01:16:03,160
设置为浮点值 如4.6 
to be a floating point value like 4.6.

1618
01:16:03,160 --> 01:16:05,930
如果我们只舍入到最接近的整数 我会很高兴 
I would be happy if we just round to the nearest integer.

1619
01:16:05,930 --> 01:16:08,800
所以我想支持用户在浮点打字
So I want to support the user typing in floating point

1620
01:16:08,800 --> 01:16:11,120
带有小数点的值 但在一天结束时 
values with decimal points, but at the end of the day,

1621
01:16:11,120 --> 01:16:15,760
例如 我只想将结果四舍五入为最接近的整数 
I just want to round the result to the nearest possible integer, for instance.

1622
01:16:15,760 --> 01:16:20,830
事实证明 在这里 也有一些内置的功能 
Well it turns out that here too Python comes with some functionality built in.

1623
01:16:20,830 --> 01:16:23,620
事实上 如果我们返回到前面的URL
And in fact, if we return to this URL from earlier

1624
01:16:23,620 --> 01:16:26,560
其中列出了所有的Python内置函数 
wherein all of the Python built-in functions are listed,

1625
01:16:26,560 --> 01:16:29,200
有一种叫“圆形”的词 它的意思是
there's one called "round" which does exactly

1626
01:16:29,200 --> 01:16:31,510
正如我们所期望的那样 它接受一个数字作为输入
as we would expect, it takes as input a number

1627
01:16:31,510 --> 01:16:36,860
然后为我们将其舍入为最接近的整数 
and then rounds it for us, for instance, to the nearest integer.

1628
01:16:36,860 --> 01:16:40,390
但如果我们像这里一样更仔细地查看这些文档--
But if we look a little closer at that documentation as we can here--

1629
01:16:40,390 --> 01:16:41,710
我将提供一段摘录--
I'll provide an excerpt--

1630
01:16:41,710 --> 01:16:45,400
文档中的函数如下所示 
this is what the function looks like in the documentation.

1631
01:16:45,400 --> 01:16:48,550
回想一下 前面我们查看了打印的文档
And recall that earlier we looked at the documentation for print

1632
01:16:48,550 --> 01:16:51,550
这在精神上是相似的 这向我们展示的不仅仅是
and this is similar in spirit that this shows us not just

1633
01:16:51,550 --> 01:16:54,880
函数的名称 但其可用参数 即 
the name of the function but its available parameters, that is,

1634
01:16:54,880 --> 01:16:57,850
使用此函数时我们可以提供的输入 
inputs that we can provide when using this function.

1635
01:16:57,850 --> 01:17:00,280
但这也有点神秘 就像印刷品一样 
But this is a little cryptic too, just like Print was,

1636
01:17:00,280 --> 01:17:01,640
它还添加了一些语法 
and it adds some syntax.

1637
01:17:01,640 --> 01:17:02,290
让我们来看看 
So let's see.

1638
01:17:02,290 --> 01:17:04,630
这里这个函数的名称当然是RUND
The name of this function here is of course Round

1639
01:17:04,630 --> 01:17:07,450
它的第一个参数是一个数字 
and its first argument is a number.

1640
01:17:07,450 --> 01:17:10,548
注意 这一次没有恒星 没有恒星物体
Notice this time there's no star, there's no star objects

1641
01:17:10,548 --> 01:17:11,590
就像印刷品一样 
like there was for print.

1642
01:17:11,590 --> 01:17:16,000
ROUND函数只接受一个数字作为其第一个参数Period 
The Round function takes just one number as its first argument, period.

1643
01:17:16,000 --> 01:17:18,820
这是它的位置参数 
That's its positional parameter.

1644
01:17:18,820 --> 01:17:20,420
但请注意此语法 
But notice this syntax.

1645
01:17:20,420 --> 01:17:22,720
这是编程或技术上的惯例
And this is a convention in programming or technology

1646
01:17:22,720 --> 01:17:26,260
更广泛地说 一般来说 当你看到方括号时
more generally, generally speaking, when you see square brackets

1647
01:17:26,260 --> 01:17:28,630
像这样的文件 这意味着你是
and documentation like this, this means that you're

1648
01:17:28,630 --> 01:17:30,370
即将看到一些可选的内容 
about to see something optional.

1649
01:17:30,370 --> 01:17:32,350
这就意味着 如果你想
And so what this means is that if you want

1650
01:17:32,350 --> 01:17:37,480
为了更准确地指定希望ROUND函数的位数
to specify more precisely the number of digits that you want the round function

1651
01:17:37,480 --> 01:17:43,760
要四舍五入 您可以在此处指定 方法是添加逗号 然后添加该数字 
to round to, you can specify it here by adding a comma and then that number.

1652
01:17:43,760 --> 01:17:48,190
因此 如果我们阅读文档 如果您不指定位数 
So if we read the documentation, if you don't specify a number of digits,

1653
01:17:48,190 --> 01:17:52,000
您只需指定要舍入的数字 它就会舍入到最接近的整数 
you just specify the number to round, it rounds to the nearest integer.

1654
01:17:52,000 --> 01:17:55,990
但是 假设您想要位于第10位或第100位
But suppose you want around to the tenths place, or the hundredths place

1655
01:17:55,990 --> 01:17:58,330
这是小数点后的一位或两位数 
that is one or two digits after the decimal point,

1656
01:17:58,330 --> 01:18:04,167
更准确地说 您还可以传入逗号1或逗号2 
you could additionally pass in comma 1 or comma 2 to be more precise.

1657
01:18:04,167 --> 01:18:06,250
这就是文件所说的 
So that's what the documentation, there is saying.

1658
01:18:06,250 --> 01:18:10,460
让我们看看是否不能为我们将其转换为一些实际的代码 
Let's see if we can't then translate this to some actual code for us.

1659
01:18:10,460 --> 01:18:13,630
所以如果我现在回到VS代码 我认为
So if I go back now to VS Code and I consider

1660
01:18:13,630 --> 01:18:18,350
我想要继续 对x和y进行循环 我可以用几种方法来做 
that I want to go ahead and round x and y, I can do this in a couple of ways.

1661
01:18:18,350 --> 01:18:22,630
我可以做x+y轮 但你知道 我会
I could do round x + y, but you know, I'd

1662
01:18:22,630 --> 01:18:25,210
实际上 我更倾向于把这个问题分成两行 
actually kind of prefer to break this now out into two lines.

1663
01:18:25,210 --> 01:18:28,300
我不需要 这里有理智的人可能不同意 
I don't have to, and reasonable people here might disagree,

1664
01:18:28,300 --> 01:18:31,330
但我想回到打印z的场景中 
but I'd like to revert to a scenario where I'm printing z,

1665
01:18:31,330 --> 01:18:34,270
这样我就能更清楚地了解自己 了解他人 
so that I can just a little more clearly to myself, to others,

1666
01:18:34,270 --> 01:18:38,890
假设z=x+y的四舍五入结果 
say z = the rounded result of x + y.

1667
01:18:38,890 --> 01:18:41,060
这并不一定是更好的方法 
It's not necessarily the better way to do it,

1668
01:18:41,060 --> 01:18:44,690
但我更愿意一次说出我的一个想法 
but I'm a little more comfortable with breaking out my thoughts one at a time,

1669
01:18:44,690 --> 01:18:47,882
尤其是如果我想要开始注释这些代码块中的每一个 
especially if I want to start commenting each of these chunks of code.

1670
01:18:47,882 --> 01:18:49,840
好的 让我去我的终端窗口
All right, let me go down to my terminal window

1671
01:18:49,840 --> 01:18:52,120
现在运行Calculator.py的Python 
now and run Python of Calculator.py.

1672
01:18:52,120 --> 01:18:52,840
X是什么？
What's x?

1673
01:18:52,840 --> 01:18:54,490
让我们再做一次1.2 
Let's do 1.2 again.

1674
01:18:54,490 --> 01:18:56,260
那我们就做3.4吧 
Then let's do 3.4.

1675
01:18:56,260 --> 01:18:59,980
现在之前是4.6 但现在是
And now it was previously 4.6, but now it's

1676
01:18:59,980 --> 01:19:04,540
向上舍入到最接近的整数 当然是5 
been rounded up to the nearest integer, which of course is going to be 5.

1677
01:19:04,540 --> 01:19:09,050
好吧 如果我想进一步改变这一点呢？
All right, what if I wanted to change this a little further?

1678
01:19:09,050 --> 01:19:11,830
如果我想支持可能非常大的数字 
What if I wanted to support maybe really big numbers,

1679
01:19:11,830 --> 01:19:15,872
大数字 不管四舍五入 让我们做这样的事情 
big numbers, irrespective of rounding, let's just do something like this.

1680
01:19:15,872 --> 01:19:17,830
让我继续运行Calculator.py的Python
Let me go ahead and run Python of Calculator.py

1681
01:19:17,830 --> 01:19:22,270
让我再加一次999+1 
again and let me just add 999 + 1.

1682
01:19:22,270 --> 01:19:25,030
注意 我不需要输入小数点 
And notice, I don't have to type decimal points,

1683
01:19:25,030 --> 01:19:27,340
即使我要转换为浮点型 我的程序
even though I'm converting to float, my program

1684
01:19:27,340 --> 01:19:30,840
只允许我输入小数点 但我不需要这样做 
will just allow me to type decimal points, but I don't need to oblige.

1685
01:19:30,840 --> 01:19:34,110
当然 这里的答案应该是 实际上也是1000 
The answer of course here should be, and is in fact, 1,000,

1686
01:19:34,110 --> 01:19:35,670
不管我们是不是绕过去 
whether or not we round.

1687
01:19:35,670 --> 01:19:38,470
所以这只是整数的算术 
So that's just arithmetic with integers here.

1688
01:19:38,470 --> 01:19:44,640
但在美国 我们倾向于用逗号来格式化长数字
But in the US, we tend to format long numbers by putting commas

1689
01:19:44,640 --> 01:19:47,580
在每三位数之后或之前 
after or before every triple of digits.

1690
01:19:47,580 --> 01:19:50,660
其他国家则改用句号和逗号 
Other countries flip it and they use periods and commas instead.

1691
01:19:50,660 --> 01:19:51,660
这是一个系统设置 
That's a system setting.

1692
01:19:51,660 --> 01:19:53,700
您可以在自己的Mac或PC上进行更改
You can change that on your own Mac or PC

1693
01:19:53,700 --> 01:19:57,000
或任何语言的设备 但对我来说 我是
or device for Python or any language, but for me, I'm

1694
01:19:57,000 --> 01:20:01,200
这里使用的是美国方法 即小数点的句号
using the US approach here, which is periods for decimal points

1695
01:20:01,200 --> 01:20:02,940
和逗号作为分隔符 
and commas for separators.

1696
01:20:02,940 --> 01:20:07,890
如果我想将其输出为1,000 怎么办？
What if I wanted this to be outputted as 1,000?

1697
01:20:07,890 --> 01:20:12,180
只是想更清楚一点 它是1000 而不是100左右 
Just to make it a little more clear that it's 1,000 and not something like 100.

1698
01:20:12,180 --> 01:20:14,580
当它达到100万的时候 这就更有用了--
That's even more useful when it's like one million--

1699
01:20:14,580 --> 01:20:18,060
一百万 
1,000,000.

1700
01:20:18,060 --> 01:20:19,950
如果我们能自动地
Wouldn't it be nice if we could automatically

1701
01:20:19,950 --> 01:20:21,540
也输出这些数字吗？
output those numbers as well?

1702
01:20:21,540 --> 01:20:23,700
好吧 事实证明我们可以 
Well, it turns out that we can.

1703
01:20:23,700 --> 01:20:28,410
有一种使用Python的方法可以实际指定我们
There is a way using Python to actually specify that we

1704
01:20:28,410 --> 01:20:30,540
我想包括这样的逗号 
want to include commas like this.

1705
01:20:30,540 --> 01:20:34,800
现在我们有机会把我们的老朋友 F弦带回来 
And here we have an opportunity to bring back our old friend, the F string.

1706
01:20:34,800 --> 01:20:37,440
首先 让我做一些不那么有成效的事情 
First, let me do something that's not that productive.

1707
01:20:37,440 --> 01:20:38,760
首先 让我来做这个 
First let me do this.

1708
01:20:38,760 --> 01:20:41,610
让我打印出z的值 但请稍等 
Let me print out the value of z, but wait a minute.

1709
01:20:41,610 --> 01:20:44,850
我不能只说“z” 因为从字面上看 这会打印出z
I can't just say "z" because that's literally going to print z

1710
01:20:44,850 --> 01:20:45,820
在屏幕上 
on the screen.

1711
01:20:45,820 --> 01:20:49,050
所以让我像以前一样用花括号把它包起来 
So let me wrap it with those curly braces like I did before,

1712
01:20:49,050 --> 01:20:50,550
但这也是不够的 
but that too was not enough.

1713
01:20:50,550 --> 01:20:54,060
我确实需要在字符串的开头添加一个F
I literally needed to add an F at the beginning of my string

1714
01:20:54,060 --> 01:20:56,940
来告诉Python这是一个F字符串 一种格式字符串 
to tell Python that this is an F string, a format string.

1715
01:20:56,940 --> 01:21:01,650
现在将打印出来 不是很有趣 只是z的值
That now is going to print out, not very interestingly, just the value of z

1716
01:21:01,650 --> 01:21:02,320
它本身 
itself.

1717
01:21:02,320 --> 01:21:06,270
所以我会不遗余力地打印z 而实际上我本可以
So I'm going to great lengths just to print z when really I could have just

1718
01:21:06,270 --> 01:21:07,890
把z作为唯一的论据 
passed z as the sole argument.

1719
01:21:07,890 --> 01:21:11,820
但为了确保我没有弄坏它 让我们再来一次 
But just to ensure that I haven't broken it, let's do this again.

1720
01:21:11,820 --> 01:21:14,190
999+1 回车 
999 + 1, Enter.

1721
01:21:14,190 --> 01:21:15,300
好的 还是1000美元 
OK, it's still 1,000.

1722
01:21:15,300 --> 01:21:16,950
所以我没有让事情变得更糟 
So I didn't make anything worse.

1723
01:21:16,950 --> 01:21:20,460
但请注意--不幸的是 这个语法有点神秘--
But notice-- and this syntax is unfortunately a bit cryptic--

1724
01:21:20,460 --> 01:21:22,380
注意 我实际上可以做到这一点 
notice that I can actually do this.

1725
01:21:22,380 --> 01:21:27,450
我可以在z后面加一个冒号 然后再加一个逗号 
I can put a colon after the z and I can put a comma thereafter.

1726
01:21:27,450 --> 01:21:29,763
诚然 这看起来非常神秘 甚至我
This looks very cryptic, admittedly, and even I

1727
01:21:29,763 --> 01:21:32,430
我必须不断地在文档中查找类似的内容
have to constantly look things like this up in the documentation

1728
01:21:32,430 --> 01:21:33,750
记住语法 
to remember the syntax.

1729
01:21:33,750 --> 01:21:35,460
但在这里 让我再运行一次 
But here, let me run it again.

1730
01:21:35,460 --> 01:21:41,250
Python of Calculator.py 9991 现在请注意
Python of Calculator.py, 999 1 and now notice

1731
01:21:41,250 --> 01:21:43,928
号码是自动为我格式化的 
that the number has been automatically formatted for me.

1732
01:21:43,928 --> 01:21:45,720
如果我在一个不同的国家或地区 
If I were in a different country or locale,

1733
01:21:45,720 --> 01:21:49,620
我完全可以用句点来代替逗号或反之亦然 
I could absolutely override this to use periods instead of commas or vise

1734
01:21:49,620 --> 01:21:50,290
反过来说 
versa.

1735
01:21:50,290 --> 01:21:52,990
但在这种情况下 这对我来说是自动发生的 
But in this case here, it's just happening for me automatically.

1736
01:21:52,990 --> 01:21:56,310
因此 我们在这里也看到了对真正格式化字符串意味着什么的暗示 
So there too we see a hint of what it means to really format a string.

1737
01:21:56,310 --> 01:21:57,720
甚至还有更大的力量--
There's even more power--

1738
01:21:57,720 --> 01:22:00,633
其中内置了更强大的功能 
more powerful capabilities built into that.

1739
01:22:00,633 --> 01:22:02,550
好的 让我在这里停一下 看看有没有
All right, let me pause here to see if there's

1740
01:22:02,550 --> 01:22:10,200
任何关于浮点数、四舍五入或F字符串用法的问题 
any questions now on floats, on rounding, or on this use of F strings.

1741
01:22:10,200 --> 01:22:11,700
观众：是的 所以我有一个问题 
AUDIENCE: Yes, so I have a question.

1742
01:22:11,700 --> 01:22:14,760
所以当使用花车时 有没有像帽子一样的东西
So when using floats, is there like a cap

1743
01:22:14,760 --> 01:22:16,860
到它可以有多少个小数点？
to how many decimal points it can have?

1744
01:22:16,860 --> 01:22:18,360
大卫·马兰：这是一个非常好的问题 
DAVID MALAN: A really good question.

1745
01:22:18,360 --> 01:22:21,150
所以漂浮 是的 这是一个我们不久将重新讨论的问题 
So floats, yes, and this is a problem we'll revisit before long.

1746
01:22:21,150 --> 01:22:25,590
浮点数不能无限精确地表示数字 
Floats cannot represent numbers infinitely precisely.

1747
01:22:25,590 --> 01:22:28,112
一言以蔽之 因为计算机只有这么多的内存 
In a nutshell, because computers only have so much memory.

1748
01:22:28,112 --> 01:22:29,820
它们只有有限的内存 
They only have a finite amount of memory.

1749
01:22:29,820 --> 01:22:34,200
你和我在电脑里只有有限数量的硬件 
You and I only have a finite amount of hardware inside of the computer,

1750
01:22:34,200 --> 01:22:36,540
因此 在某种程度上 他们将不得不绕过去 
so at some point, they're going to have to round.

1751
01:22:36,540 --> 01:22:38,190
现在我正在自动取整 
Right now I'm rounding automatically.

1752
01:22:38,190 --> 01:22:40,732
实际上 计算机最终将不得不为我们做到这一点 
Effectively computers will eventually have to do that for us,

1753
01:22:40,732 --> 01:22:44,010
但不久之后 我们将把这视为一个根本问题 
but we'll see that as a fundamental problem before long.

1754
01:22:44,010 --> 01:22:47,385
请允许我回到关于Float的最后几个例子
Allow me to turn back just for a few final examples on float

1755
01:22:47,385 --> 01:22:50,010
在我们介绍最后几个例子之前 这些例子不仅允许我们
before we introduce a few final examples that allow us not just

1756
01:22:50,010 --> 01:22:52,290
使用函数 但创建我们自己的函数 
to use functions, but to make our own.

1757
01:22:52,290 --> 01:22:56,940
让我建议我们在这里也尝试一下点名表决 
Let me propose that we also try our hands at a bit of division here.

1758
01:22:56,940 --> 01:22:59,250
让我提议我们现在修改这个计算器
Let me propose that we modify this calculator now

1759
01:22:59,250 --> 01:23:01,740
仍然带着几个花车 但现在让我们做
to still take a couple of floats, but let's now just do

1760
01:23:01,740 --> 01:23:04,050
比这更简单的东西--
something a little simpler than--

1761
01:23:04,050 --> 01:23:07,085
和这个略有不同 就是x除以y 
a little different from this, just doing x divided by y.

1762
01:23:07,085 --> 01:23:09,210
让我继续 去掉我的格式字符串
And let me go ahead and get rid of my format string

1763
01:23:09,210 --> 01:23:12,383
现在只需保持简单 打印出z即可 
and just keep it simple for now, printing out z instead.

1764
01:23:12,383 --> 01:23:13,800
我们在这里会看到什么呢？
And what are we going to see here?

1765
01:23:13,800 --> 01:23:15,092
嗯 只是一些简单的除法 
Well just some simple division.

1766
01:23:15,092 --> 01:23:19,920
因此 在Calculator.py中 让我们做一些类似于2除以3的操作 
So Python of Calculator.py, let's do something like 2 divided by 3,

1767
01:23:19,920 --> 01:23:21,960
当然 我能拿到0.66666 
and of course I get 0.66666.

1768
01:23:21,960 --> 01:23:25,600
对于伊森刚才的问题 它似乎确实是有限的 
And to Ethan's question a moment ago, it does seem to be finite.

1769
01:23:25,600 --> 01:23:30,180
它在这里不是以一种奇怪的方式舍入 但我似乎只看到这么多数字 
It's not rounding in a weird way here, but I only seem to see so many digits.

1770
01:23:30,180 --> 01:23:34,170
这是以这种方式使用浮点的必然性 
That's an inevitability of using a float in this way.

1771
01:23:34,170 --> 01:23:37,620
相比之下 正如您所知道的 现在在Python语言中使用整数
By contrast, just so you know, integers nowadays in Python

1772
01:23:37,620 --> 01:23:39,690
可以有多大就有多大 
can be as big as you want them to be.

1773
01:23:39,690 --> 01:23:41,910
与其他语言不同 它没有上限
Unlike other languages, there is no upper bound

1774
01:23:41,910 --> 01:23:44,550
关于整数现在在Python语言中可以有多大 但有
on how big an INT can be now in Python, but there

1775
01:23:44,550 --> 01:23:48,225
是浮点值的精确度的界限 
is a bound on just how precise a floating point value can be.

1776
01:23:48,225 --> 01:23:50,850
好的 现在我有了一个简单的部门 
All right, now that I've got some simple division working here,

1777
01:23:50,850 --> 01:23:52,380
让我们继续下去 把这个绕过去 
let's go ahead and round this.

1778
01:23:52,380 --> 01:23:57,060
对这个很长的数字0.6666666进行舍入会很好 依此类推
It would be nice to round this really long number 0.6666666 and so forth

1779
01:23:57,060 --> 01:23:59,190
可能只有两位小数点后 
to maybe just two decimal places.

1780
01:23:59,190 --> 01:24:02,460
不过 我们已经看到了如何使用ROUND做到这一点 至少在它的文档中是这样的 
We've seen how to do this with round, though, at least in its documentation.

1781
01:24:02,460 --> 01:24:04,980
让我们把它舍入到最接近的整数 
Let's just round this not to the nearest INT,

1782
01:24:04,980 --> 01:24:09,810
通过只传递x除以y 这是一个参数 一旦数学是
by passing in just x divided by y, which is one argument, once the math is

1783
01:24:09,810 --> 01:24:13,350
在括号内完成 我不想只传递一个参数 
done inside of the parentheses, I don't want to pass in just one argument.

1784
01:24:13,350 --> 01:24:17,100
我想传入两个数字 这样我就可以指定n位数字 
I want to pass in two so that I can specify n digits,

1785
01:24:17,100 --> 01:24:21,030
位数 您还记得它是舍入的第二个参数 
number of digits, which you'll recall was the second parameter for round.

1786
01:24:21,030 --> 01:24:23,240
让我继续运行Calculator.py的Python 
Let me go ahead and run Python of Calculator.py.

1787
01:24:23,240 --> 01:24:24,240
我会做同样的事情--
I'll do the same thing--

1788
01:24:24,240 --> 01:24:27,300
2 然后是3 0.67 
2 and then 3, 0.67.

1789
01:24:27,300 --> 01:24:31,130
所以我们现在也看到了一种取整的方法 不仅仅是舍入到最接近的整数 
So here too we see a way of rounding now, not just to a nearest integer,

1790
01:24:31,130 --> 01:24:34,160
而是最接近的数字 
but to a nearest number of digits.

1791
01:24:34,160 --> 01:24:36,300
但在这里 还有另一种方法可以做到这一点 
But there's another way to do this here.

1792
01:24:36,300 --> 01:24:40,920
事实上 这再次唤起了我们的F字符串的例子 
And in fact, this evokes our F string example again.

1793
01:24:40,920 --> 01:24:42,270
让我继续更改这一点 
Let me go ahead and change this.

1794
01:24:42,270 --> 01:24:45,740
假设您不记得ROUND函数 或者 出于某种原因 
Suppose that you didn't remember the round function or, for some reason,

1795
01:24:45,740 --> 01:24:46,940
你不想用它 
you didn't want to use it.

1796
01:24:46,940 --> 01:24:49,340
相反 您只想使用格式字符串 
You instead want to just use a format string.

1797
01:24:49,340 --> 01:24:50,510
好吧 我们去那里吧 
Well, let's go there.

1798
01:24:50,510 --> 01:24:55,280
让我做“z” 但让我用花括号把它括起来 
Let me do "z" but let me surround it with those curly braces.

1799
01:24:55,280 --> 01:24:58,850
让我在开头加上F 再一次 这还不是很有趣 
Let me add the F at the beginning, and again, this is not interesting yet.

1800
01:24:58,850 --> 01:25:02,300
这只会打印出z 但我会增加更多的复杂性
This is just going to print out z, but I'm adding a lot more complexity

1801
01:25:02,300 --> 01:25:03,920
把它变成F弦 
to turn it into an F string.

1802
01:25:03,920 --> 01:25:08,940
但请注意 我可以在变量名之后、冒号之后执行其他操作 
But notice I can do something else after my variable name, after the colon.

1803
01:25:08,940 --> 01:25:11,300
如果这将是一个大整数 我
If this were going to be a big integer, I

1804
01:25:11,300 --> 01:25:15,200
可能需要像以前一样使用逗号来分隔每三个数字
might want to use a comma like before to separate each triple of numbers

1805
01:25:15,200 --> 01:25:15,950
用逗号 
with commas.

1806
01:25:15,950 --> 01:25:16,580
但我不知道 
But I don't.

1807
01:25:16,580 --> 01:25:20,120
我将使用不同的字符序列 
I'm going to use a different sequence of characters.

1808
01:25:20,120 --> 01:25:25,190
我要说的是0.2F 这也是我有一个非常神秘的东西
I'm going to say 0.2F and this too is one of these very cryptic things I have

1809
01:25:25,190 --> 01:25:28,040
经常抬头 因为如果我不经常使用它 我会忘记 
to constantly look up because I forget if I don't use it that often.

1810
01:25:28,040 --> 01:25:32,030
所以 如果这看起来特别奇怪 不要害怕 但这是 
So don't be intimidated if this looks especially weird, but this is,

1811
01:25:32,030 --> 01:25:33,950
根据文件 你的方式
according to the documentation, the way you

1812
01:25:33,950 --> 01:25:37,830
使用F字符串指定要打印的位数 
specify using an F string how many digits you want to print.

1813
01:25:37,830 --> 01:25:39,980
所以让我运行这个版本的计算器 
So let me run this version of the calculator.

1814
01:25:39,980 --> 01:25:43,170
输入2 然后输入3 我们得到完全相同的结果 
Type in 2 and then 3, we get the exact same thing.

1815
01:25:43,170 --> 01:25:45,350
但同样 这与我的主张是一致的
But again, this is just consistent with my claim

1816
01:25:45,350 --> 01:25:49,580
在编程中 我们经常可以解决相同的问题
that in programming we can so very often solve the same problem

1817
01:25:49,580 --> 01:25:51,030
以多种方式 
in multiple ways.

1818
01:25:51,030 --> 01:25:56,240
这就是现在解决同样问题的F弦方法 
This is just now the F string approach to that very same problem.

1819
01:25:56,240 --> 01:25:57,630
好的 哪一个更好？
All right, which one is better?

1820
01:25:57,630 --> 01:25:58,310
那得看情况 
It depends.

1821
01:25:58,310 --> 01:26:00,200
在这种情况下 它们几乎是等价的 
In this case, they're pretty equivalent.

1822
01:26:00,200 --> 01:26:03,260
不过 您可以想象 有时使用函数是很有用的
You can imagine, though, it being useful to use a function sometimes

1823
01:26:03,260 --> 01:26:07,340
这样您就可以将n位之类参数作为第二个参数进行传递 
so that you can pass in an argument like n digits as that second argument,

1824
01:26:07,340 --> 01:26:10,700
或者您可以想象一下 您只需提前决定您想要0.2
or you can imagine just deciding in advance that you want 0.2

1825
01:26:10,700 --> 01:26:13,370
然后写成这样 
and then writing it like this.

1826
01:26:13,370 --> 01:26:17,300
现在让我们从关注字符串和整数过渡到
Let's transition now from focusing on strings and on integers and on

1827
01:26:17,300 --> 01:26:19,880
现在重点放在函数本身上 
floats to focusing now on functions themselves.

1828
01:26:19,880 --> 01:26:21,860
我们今天一开始就关注您如何
We began today by focusing on how you can

1829
01:26:21,860 --> 01:26:24,230
使用随Python提供的函数 
use functions that come with Python.

1830
01:26:24,230 --> 01:26:26,990
但如果你能发明你自己的功能不是很好吗 
But wouldn't it be nice if you could invent your own functions,

1831
01:26:26,990 --> 01:26:29,330
特别是如果 正如我们前面所说的 你会发现
especially if, to our point earlier, you find

1832
01:26:29,330 --> 01:26:32,210
你自己一次又一次地解决同样的问题？
yourself solving the same kind of problem again and again?

1833
01:26:32,210 --> 01:26:34,700
很好 Python附带了打印功能
It's nice that Python comes with the print function

1834
01:26:34,700 --> 01:26:37,130
因为能够在屏幕上打印东西真的很有用 
because it's really useful to be able to print things on the screen,

1835
01:26:37,130 --> 01:26:40,130
但如果你可以在屏幕上打印特定的东西 那不是很好吗
but wouldn't it be nice if you could print specific things on the screen

1836
01:26:40,130 --> 01:26:42,170
只需调用您自己的函数？
by just calling your own function?

1837
01:26:42,170 --> 01:26:44,100
好吧 让我提议我们这样做 
Well let me propose that we do this.

1838
01:26:44,100 --> 01:26:49,760
让我回到这里的VS代码 让我建议我们回到Hello.py 
Let me go back to VS Code here and let me propose that we go back to Hello.py.

1839
01:26:49,760 --> 01:26:52,820
我要在之前离开的地方重新打开Hello.py
I'm going to reopen Hello.py where we left it before

1840
01:26:52,820 --> 01:26:54,620
现在我要开始向大家提出
and I'm going to go ahead now and propose

1841
01:26:54,620 --> 01:26:58,460
我们考虑如何才能开始进一步改善这一点
that we consider how we can start improving this further by making

1842
01:26:58,460 --> 01:26:59,330
我们自己的功能 
our own function.

1843
01:26:59,330 --> 01:27:03,380
我今天写了很多程序 只是打个招呼
I have written so many programs today that just say Hello

1844
01:27:03,380 --> 01:27:05,360
每次我使用印刷品的时候 
and each time I'm using print.

1845
01:27:05,360 --> 01:27:08,090
但如果从今天开始 
But wouldn't it have been nice if, from the beginning of today,

1846
01:27:08,090 --> 01:27:12,620
我们可以只调用一个名为Hello的函数 该函数只为我们说Hello？
we could just call a function called Hello that just says Hello for us?

1847
01:27:12,620 --> 01:27:15,080
现在 多年前的Python的作者们并没有
Now the authors of Python years ago didn't

1848
01:27:15,080 --> 01:27:18,020
我想我们需要一个特殊的功能来打招呼 
think that we need a special function just to say Hello,

1849
01:27:18,020 --> 01:27:19,820
但我希望这种情况能够存在 
but I would like that to exist.

1850
01:27:19,820 --> 01:27:21,980
我打了很多次招呼 我只是想
I'm saying Hello so many times, I just want

1851
01:27:21,980 --> 01:27:23,600
为了能够调用函数Hello 
to be able to call a function Hello.

1852
01:27:23,600 --> 01:27:25,550
因此 我将在这里从头开始 
So I'm going to start from scratch here.

1853
01:27:25,550 --> 01:27:27,680
我将删除前面的所有代码
I'm going to delete all of my code from earlier

1854
01:27:27,680 --> 01:27:32,510
我暂时假设存在一个名为Hello的函数 
and I'm going to pretend for the moment that a function called Hello exists.

1855
01:27:32,510 --> 01:27:34,250
我要做的就是像以前一样 
And I'm going to do just as I did before.

1856
01:27:34,250 --> 01:27:36,740
我将使用输入函数获取用户名 
I'm going to get the user's name with the input function,

1857
01:27:36,740 --> 01:27:39,110
问你叫什么名字 问号 
asking what's your name, question mark.

1858
01:27:39,110 --> 01:27:42,230
现在我将调用函数Hello
And now I'm going to call a function Hello

1859
01:27:42,230 --> 01:27:45,260
然后我将打印出用户名 
and then I'm going to print out the user's name.

1860
01:27:45,260 --> 01:27:50,190
现在我要承认 Hello并不存在 所以坏事就要发生了 
Now I will admit, Hello doesn't exist, so bad things are about to happen,

1861
01:27:50,190 --> 01:27:51,440
但让我们来看看会发生什么 
but let's see what.

1862
01:27:51,440 --> 01:27:53,210
让我下到我的终端窗口 
Let me go down to my terminal window.

1863
01:27:53,210 --> 01:27:55,700
让我运行Hello.py的Python 
Let me run Python of Hello.py.

1864
01:27:55,700 --> 01:27:59,030
我认为第一行会很好 因为这以前很管用 
I think the first line is going to be OK because that worked before.

1865
01:27:59,030 --> 01:28:01,280
事实上 这促使我选择了我的名字 
And indeed, it's prompting me for my name.

1866
01:28:01,280 --> 01:28:02,780
那么 让我输入David 
So let me type in David.

1867
01:28:02,780 --> 01:28:05,090
第二行代码显然是在调用
The second line of code is apparently calling

1868
01:28:05,090 --> 01:28:08,840
一个看起来像是Hello的函数 因为它为什么是一个函数？
a function that looks like it's called Hello, because why is it a function?

1869
01:28:08,840 --> 01:28:11,820
它后面紧跟着一个括号和一个右括号 
It has a parenthesis and a closed parenthesis immediately after it.

1870
01:28:11,820 --> 01:28:14,300
这就是我们用过的每个函数的样子 
And that's what every function we've used has looked like.

1871
01:28:14,300 --> 01:28:16,340
但是 Python不会识别这一点 
But Python is not going to recognize this one.

1872
01:28:16,340 --> 01:28:18,890
现在 当我按Enter键时 我得到一个名称错误 
When I hit Enter now, I get a name error.

1873
01:28:18,890 --> 01:28:21,950
未定义名称“Hello” 您的意思是帮助吗？
Name "Hello" is not defined, did you mean Help?

1874
01:28:21,950 --> 01:28:26,120
我没有 虽然这是个好时机我现在需要的是帮助 
I didn't, although it's opportune that's what I need at this point is some help,

1875
01:28:26,120 --> 01:28:29,540
但我遇到这个错误是因为什么呢？
but I am encountering this error because why?

1876
01:28:29,540 --> 01:28:31,440
这个功能根本不存在 
The function just doesn't exist.

1877
01:28:31,440 --> 01:28:33,350
那么 我如何让这个函数存在呢？
So how do I make this function exist?

1878
01:28:33,350 --> 01:28:39,440
嗯 我需要自己创建它 使用这个关键字 DEF 定义的DEF 
Well I need to create it myself using this key word, DEF, DEF for define.

1879
01:28:39,440 --> 01:28:43,610
所以这里也是一样 就像STR是字符串的缩写 int是整数的缩写 
So here too, just as STR is short for string and INT is short for integer,

1880
01:28:43,610 --> 01:28:45,830
Def是定义的缩写 
DEF is short for define.

1881
01:28:45,830 --> 01:28:50,330
如果您想要定义、创建、发明您自己的函数 
If and when you want to define, create, invent your own functions,

1882
01:28:50,330 --> 01:28:53,870
现在 您可以在Python中使用此关键字来完成此操作 
you can do so using now this keyword in Python.

1883
01:28:53,870 --> 01:28:58,310
让我回到我这里的代码 让我建议我们定义这个
So let me go back to my code here and let me propose that we define this

1884
01:28:58,310 --> 01:28:59,900
也许是以这种方式 
perhaps in this way.

1885
01:28:59,900 --> 01:29:02,660
在我文件的最顶端 我将首先
At the very top of my file, I'm going to first take

1886
01:29:02,660 --> 01:29:05,150
片刻定义一个名为Hello的函数
a moment to define a function called Hello

1887
01:29:05,150 --> 01:29:10,430
使用DEF Hello 左括号 右括号 冒号 
using DEF Hello, open parenthesis, close parenthesis, colon.

1888
01:29:10,430 --> 01:29:15,110
现在的意思是 Python将处理每一行代码
What this means now is that Python is going to treat every line of code

1889
01:29:15,110 --> 01:29:20,240
我在这个下面缩进 作为这个新函数的含义 Hello 
that I indent underneath this one as the meaning of this new function, Hello.

1890
01:29:20,240 --> 01:29:23,030
所以DEF很重要 空间也很重要 
So DEF is important as is the space.

1891
01:29:23,030 --> 01:29:26,577
我可以选择函数的名称 我选择将其命名为Hello 
I get to choose the name of the function and I'm choosing to call it Hello.

1892
01:29:26,577 --> 01:29:29,660
括号内没有任何内容 表示此函数此时
The parentheses with nothing inside means that this function at the moment

1893
01:29:29,660 --> 01:29:32,540
不会接受任何输入 也不会有任何论点 
is not going to take any inputs, no arguments there too.

1894
01:29:32,540 --> 01:29:35,810
冒号的意思是 请继续关注一些缩进 
The colon means, stay tuned for some indentation.

1895
01:29:35,810 --> 01:29:38,750
这行代码下面缩进的所有内容
Everything that's indented beneath this line of code

1896
01:29:38,750 --> 01:29:40,310
将成为这一功能的一部分 
is going to be part of this function.

1897
01:29:40,310 --> 01:29:42,920
这将是一个超短的函数--一行代码--
It's going to be a super short function-- one line of code--

1898
01:29:42,920 --> 01:29:46,040
它只会打印出“你好 ”
it's just going to print out "Hello."

1899
01:29:46,040 --> 01:29:51,830
但现在在第1行和第2行 我发明了我自己的函数Hello 
But now on lines 1 and 2, I have invented my own function Hello.

1900
01:29:51,830 --> 01:29:54,740
注意这些现在神奇地出现在这里的圆点 
Notice these dots that have now magically appeared here.

1901
01:29:54,740 --> 01:29:56,660
这只是我的文本编辑器的一个设置 
This is just a setting of my text editor,

1902
01:29:56,660 --> 01:30:00,470
VS代码在这种情况下 这对我来说是非常明确的 我已经
VS Code in this case, that's just making super explicit to me that I've

1903
01:30:00,470 --> 01:30:04,160
按空格键四次 或相当于按Tab键一次 
hit the space bar four times, or equivalently the Tab key once,

1904
01:30:04,160 --> 01:30:07,018
它被自动转换为四个空格 
which is converted automatically to four spaces.

1905
01:30:07,018 --> 01:30:10,310
一般来说 我需要确保我所有的缩进代码
Generally speaking, I'm going to need to make sure that all of my indented code

1906
01:30:10,310 --> 01:30:14,150
现在排好队 这样Python就知道它们都是同一件事的一部分 
lines up now so that Python knows that it's all part of the same thing.

1907
01:30:14,150 --> 01:30:16,770
但在本例中很容易 因为它只有一行 
But it's easy in this case because it's just a single line.

1908
01:30:16,770 --> 01:30:20,810
但是现在 由于有了第1行和第2行 函数Hello
But now, thanks to lines 1 and 2, the function Hello

1909
01:30:20,810 --> 01:30:24,920
当我准备好在第6行使用它时 它将绝对存在 
will absolutely exist when I'm ready to use it on line 6.

1910
01:30:24,920 --> 01:30:29,180
因此 让我转到我的终端窗口并运行Hello.py的Python 回车 
So let me go down to my terminal window and run Python of Hello.py, Enter.

1911
01:30:29,180 --> 01:30:30,570
我的名字又来了 
Here comes my name again.

1912
01:30:30,570 --> 01:30:35,120
现在 当我按回车键时 我现在看到的是Hello David 
And now when I hit Enter, I now see Hello, David.

1913
01:30:35,120 --> 01:30:37,190
好吧 我们有点退步了 对吧？
All right, we've kind of regressed though, right?

1914
01:30:37,190 --> 01:30:39,960
这远不像以前那么漂亮了 
This is not nearly as pretty as it once was.

1915
01:30:39,960 --> 01:30:44,840
我认为 通过进一步改进 我们可能会做得更好 
I think we can probably do better than this by improving things further.

1916
01:30:44,840 --> 01:30:47,510
然而 我们为什么不考虑一下 我们可以如何
Why don't we consider, though, how we might

1917
01:30:47,510 --> 01:30:50,480
比如说 将这个相同的函数参数化？
say parameterize this same function?

1918
01:30:50,480 --> 01:30:55,010
也就是说 我们是否可以将Hello定制为可能将用户名作为输入
That is to say, can we customize Hello to maybe take the user's name as input

1919
01:30:55,010 --> 01:31:00,020
这样我们就可以说 不仅是你好 而且这个人的名字都在一行上 所有的
so that we can say, not only Hello, but the person's name all on one line, all

1920
01:31:00,020 --> 01:31:01,070
一口气？
in one breath?

1921
01:31:01,070 --> 01:31:02,450
我想我们可以做到的 
Well I think we can do this.

1922
01:31:02,450 --> 01:31:05,400
让我提议我们这样做 
Let me propose that we do this as follows.

1923
01:31:05,400 --> 01:31:10,100
让我在我的代码中继续前进 让我进入这些括号 
Let me go ahead and up in my code, let me inside of these parentheses,

1924
01:31:10,100 --> 01:31:12,350
让我想出我自己的参数名称 
let me come up with my own parameter name.

1925
01:31:12,350 --> 01:31:14,510
我在这里有完全的选择 我要去
I have complete choice here and I'm going

1926
01:31:14,510 --> 01:31:17,780
要说我的参数的名称将是单词 
to say that the name of my parameter will be the word To.

1927
01:31:17,780 --> 01:31:18,500
为什么？
Why?

1928
01:31:18,500 --> 01:31:22,970
因为我希望我的函数听起来像它所代表的动词--
Because I want my function to sound like the verb it represents--

1929
01:31:22,970 --> 01:31:23,690
你好 
Hello.

1930
01:31:23,690 --> 01:31:25,610
但是你想跟谁打个招呼呢？
But who do you want to say Hello to?

1931
01:31:25,610 --> 01:31:27,860
我将调用此函数的参数
Well I'm going to call my parameter for this function

1932
01:31:27,860 --> 01:31:30,860
To 就因为在英语里 它对我来说听起来很好听 
To, just because in English, it kind of sounds nice to me.

1933
01:31:30,860 --> 01:31:32,900
你好 你想跟谁打个招呼？
Hello To, who do you want to say Hello to?

1934
01:31:32,900 --> 01:31:36,050
这就是为什么我调用这个参数而不是某个
That's why I'm calling this parameter To instead of something

1935
01:31:36,050 --> 01:31:38,360
更简单 如x、y或z 
simpler like x or y or z.

1936
01:31:38,360 --> 01:31:40,798
好吧 那么我想用to这个词做什么呢？
All right, well what do I want to do with the word To?

1937
01:31:40,798 --> 01:31:42,590
嗯 我可以做几件不同的事情 
Well I can do a couple of different things.

1938
01:31:42,590 --> 01:31:45,320
我们已经看到了很多不同的实现Hello的方法 
We've seen like so many different ways to implement Hello.

1939
01:31:45,320 --> 01:31:48,000
为了语法起见 让我在那里加一个逗号 
Let me just add a comma there for grammar's sake.

1940
01:31:48,000 --> 01:31:52,700
然后让我把后面的词作为第二个论点
And then let me put the word To after that as the second argument

1941
01:31:52,700 --> 01:31:53,715
转到函数Hello 
to the function Hello.

1942
01:31:53,715 --> 01:31:56,090
我们还有其他方法可以做到这一点 我们已经看到了很多种方法 
There's other ways we can do this and we've seen so many,

1943
01:31:56,090 --> 01:31:58,940
但我会说 这件事在我看来有点清楚 
but this one looks a little clear to me, I'll say.

1944
01:31:58,940 --> 01:32:00,380
接下来会发生什么？
What's going to happen next?

1945
01:32:00,380 --> 01:32:03,470
我想我这里不需要这条额外的打印线 
Well I don't think I need this extra print line here.

1946
01:32:03,470 --> 01:32:07,040
我想我要做的是 我要在这里继续
I think what I'm going to do is this, I'm going to go ahead here

1947
01:32:07,040 --> 01:32:12,740
而不是手动打印出这个人的名字 我会说 
and print out not the person's name manually, I'm going to instead say,

1948
01:32:12,740 --> 01:32:15,410
你好 圆括号的名字 
Hello parentheses name.

1949
01:32:15,410 --> 01:32:16,880
那么我现在在做什么呢？
So what am I now doing?

1950
01:32:16,880 --> 01:32:20,690
在第1行和第2行 我定义了我自己的函数 名为Hello 
On lines 1 and 2 I'm defining my very own function called Hello,

1951
01:32:20,690 --> 01:32:23,240
但这一次 这个函数已经设计好了
but this time that function has been designed

1952
01:32:23,240 --> 01:32:26,750
接受一个参数 单个参数 作为输入 
to take a parameter, a single parameter, as input.

1953
01:32:26,750 --> 01:32:29,810
我使用的是该参数的值 
And I'm using the value of that parameter which

1954
01:32:29,810 --> 01:32:33,470
我打电话去印刷 这样我不仅能看到
I called To to plug into print so that I see not only

1955
01:32:33,470 --> 01:32:35,780
你好 还有那个人的名字 
Hello but also that person's name.

1956
01:32:35,780 --> 01:32:37,070
我在5号线上做什么？
What am I doing on line 5?

1957
01:32:37,070 --> 01:32:39,140
和往常一样 我只是得到了用户名 
Same as always, I'm just getting the user's name.

1958
01:32:39,140 --> 01:32:42,140
6号线 我不仅要打给你 我要路过
Line 6, I'm not only calling Hello, I'm passing

1959
01:32:42,140 --> 01:32:46,500
作为作为参数的名称变量的输入
as input the name variable as an argument

1960
01:32:46,500 --> 01:32:48,912
所以这就是传递给Hello的内容 
so that that's what gets passed into Hello.

1961
01:32:48,912 --> 01:32:50,870
这里发生的事情本质上是这样的--
And what's happening here is essentially this--

1962
01:32:50,870 --> 01:32:54,710
即使变量在这里称为NAME 当函数
even though the variable is called Name here, when the function

1963
01:32:54,710 --> 01:33:00,920
自身被调用时 计算机假定现在调用了相同的值 
itself is called, the computer assumes that same value is now called To.

1964
01:33:00,920 --> 01:33:04,760
因此 名称实际上被复制到另一个名为
So Name is essentially copied to another variable called

1965
01:33:04,760 --> 01:33:11,420
这样 在Hello的上下文中 我可以对该变量说Hello 
To so that in the context of Hello, I can say Hello to that variable instead.

1966
01:33:11,420 --> 01:33:15,140
我们很快就会看到 如果我们不把这些放在一起会发生什么 
And we'll see in a moment what happens if we don't keep those straight.

1967
01:33:15,140 --> 01:33:17,600
让我继续运行Hello.py的Python 回车 
Let me go ahead and run Python of Hello.py, Enter.

1968
01:33:17,600 --> 01:33:18,540
你叫什么名字？
What's your name?

1969
01:33:18,540 --> 01:33:20,060
现在我要祈祷了 
And now I'm crossing my fingers.

1970
01:33:20,060 --> 01:33:20,840
进来吧 
Enter.

1971
01:33:20,840 --> 01:33:21,750
我们走吧 
There we go.

1972
01:33:21,750 --> 01:33:25,700
我们恢复了业务 但现在我有了自己的定制函数 名为Hello
We're back in business, but now I have my own custom function called Hello

1973
01:33:25,700 --> 01:33:28,550
这让我可以向特定的人打招呼 
that's allowing me to say Hello to a specific person.

1974
01:33:28,550 --> 01:33:30,980
这就是现在事情可以变得非常奇特的地方 
And here's where now things can get really fancy.

1975
01:33:30,980 --> 01:33:34,220
如果你想让你的Hello函数向某个特定的人问好 
What if you wanted your Hello function to say Hello to someone specific,

1976
01:33:34,220 --> 01:33:37,070
但是 你知道吗 如果你不知道你想跟谁打招呼 
but, you know what, if you don't know who you want to say Hello to,

1977
01:33:37,070 --> 01:33:38,840
你想向全世界问好 
you want to say Hello to the whole world,

1978
01:33:38,840 --> 01:33:41,300
您可以为参数指定缺省值 
you can give parameters default values.

1979
01:33:41,300 --> 01:33:42,060
我们已经看到了这一点 
We've seen that.

1980
01:33:42,060 --> 01:33:45,530
回想一下 对于Print SEP有一个缺省值 
Recall that with print there was a default value for SEP,

1981
01:33:45,530 --> 01:33:46,550
作为分隔器 
for the separator.

1982
01:33:46,550 --> 01:33:49,700
End有一个缺省值 即行结束 
There was a default value for END, the line ending.

1983
01:33:49,700 --> 01:33:52,280
我们也可以这样做 下面是语法 
We can do that too, and here's the syntax.

1984
01:33:52,280 --> 01:33:56,390
如果您想要此参数的默认值 
If you want the value of this parameter by default,

1985
01:33:56,390 --> 01:34:00,620
如果不是由程序员提供的 则等于“world” 
if not provided by the programmer, to be equal to "world,"

1986
01:34:00,620 --> 01:34:05,155
你可以在定义函数的同一行中做到这一点 
you literally do that in the same line you're defining the function.

1987
01:34:05,155 --> 01:34:07,280
我承认 它开始看起来更神秘了 
And I'll admit, it's starting to look more cryptic,

1988
01:34:07,280 --> 01:34:10,580
但我仍在定义一个名为Hello的函数 它
but I'm still just defining a function called Hello, it

1989
01:34:10,580 --> 01:34:13,820
接受一个名为的参数 但我将其赋值
takes a parameter called To, but I'm assigning it

1990
01:34:13,820 --> 01:34:19,340
用等号表示缺省值“world” 以防程序员
with the equal sign a default value of "world," just in case the programmer

1991
01:34:19,340 --> 01:34:22,310
不使用参数调用Hello 
doesn't call Hello with an argument.

1992
01:34:22,310 --> 01:34:23,660
我们可以在这里看到这个 
And we can see this here.

1993
01:34:23,660 --> 01:34:26,750
让我更改代码 以两种方式使用Hello 
Let me change my code to use Hello in two ways.

1994
01:34:26,750 --> 01:34:31,880
在第5行 我将非常简单地调用Hello no arguments 
On line 5, I'm going to very simply call Hello, no arguments.

1995
01:34:31,880 --> 01:34:33,710
然后在第6行 我将得到名字 
Then on line 6, I'm going to get the name.

1996
01:34:33,710 --> 01:34:36,320
第7行 我将用一个参数调用Hello 
Line 7, I'm going to call Hello with an argument.

1997
01:34:36,320 --> 01:34:39,060
因此 您将看到Hello现在被以两种方式使用 
So you'll see Hello now being used in two ways.

1998
01:34:39,060 --> 01:34:41,960
让我继续运行Hello.py的Python 
Let me go ahead and run Python of Hello.py.

1999
01:34:41,960 --> 01:34:43,310
我要把我的名字打进去 
I'll type in my name.

2000
01:34:43,310 --> 01:34:44,630
哦 有意思 
Oh, interesting.

2001
01:34:44,630 --> 01:34:47,120
请注意 我已经看到了Hello World 但这是
Notice I already see Hello, world, but that's

2002
01:34:47,120 --> 01:34:52,070
因为第5行在第6行之前 所以是预期的 但是一旦我输入我的名字 
expected because line 5 happens before line 6, but once I type my name,

2003
01:34:52,070 --> 01:34:55,940
现在节目将会更有礼貌地跟我打招呼
now the program is going to be a little more polite and say hello to me

2004
01:34:55,940 --> 01:34:57,180
就个人而言 
personally.

2005
01:34:57,180 --> 01:35:01,550
在那里 我们也可以看到相对简单但新的语法
So there too, we see with relatively simple but new syntax

2006
01:35:01,550 --> 01:35:05,990
如何实现与印刷品在本质上非常相似的功能
how you can implement functionality very similar in spirit to what the print

2007
01:35:05,990 --> 01:35:07,860
功能自动给了我们 
function gave us automatically.

2008
01:35:07,860 --> 01:35:10,940
现在你可以控制自己做这件事了 
Now you have control over doing that yourself.

2009
01:35:10,940 --> 01:35:12,980
但现在让我也说明这一点 
But let me now make this point too.

2010
01:35:12,980 --> 01:35:15,530
定义您自己的函数的全部要点之一
One of the whole points of defining your own functions

2011
01:35:15,530 --> 01:35:18,680
是一种 只是为了避免一次又一次地重复自己 
is one, just to avoid having to repeat yourself again and again.

2012
01:35:18,680 --> 01:35:21,890
你不需要一直重新发明轮子
You don't have to actually keep reinventing the wheel

2013
01:35:21,890 --> 01:35:24,480
并继续使用打印功能 一次又一次 
and keep using the print function again, and again, and again,

2014
01:35:24,480 --> 01:35:25,850
如果你只是想跟我打个招呼 
if you just want to say Hello.

2015
01:35:25,850 --> 01:35:29,780
如果我现在可以移动这个代码不是很好吗
Wouldn't it be nice now if I could move this code

2016
01:35:29,780 --> 01:35:34,010
这是我为定义Hello函数而编写的 只是为了戏剧性地说 
that I wrote for defining the Hello function, and just to be dramatic,

2017
01:35:34,010 --> 01:35:37,760
我要多次按回车键 50行以下 
I'm going to hit Enter a whole lot of times, 50 lines down,

2018
01:35:37,760 --> 01:35:41,240
并将我对Hello way的定义进一步放在这个文件中 
and put my definition of Hello way further down in this file.

2019
01:35:41,240 --> 01:35:41,840
为什么？
Why?

2020
01:35:41,840 --> 01:35:44,720
好吧 只是为了本着眼不见心不烦的精神 
Well, just for in the spirit of out of sight, out of mind,

2021
01:35:44,720 --> 01:35:48,800
因为如果我现在回放到我的节目的开头 现在
because if I now rewind to the start of my program, now

2022
01:35:48,800 --> 01:35:51,240
你可以想当然地认为 哦 Hello是一个函数 
you can take for granted that, oh, Hello is a function.

2023
01:35:51,240 --> 01:35:51,740
为什么？
Why?

2024
01:35:51,740 --> 01:35:54,740
因为它在第一行 它有一个左括号和一个闭合括号
Because it's there on line 1 and it has an open parenthesis and a closed

2025
01:35:54,740 --> 01:35:57,560
括号 到目前为止 它的意思是调用这个函数 
parenthesis, which, up until now has meant, call this function.

2026
01:35:57,560 --> 01:36:00,200
然后在第2行 我们从用户那里获得一个变量
And then on line 2 we're getting a variable from the user

2027
01:36:00,200 --> 01:36:04,620
然后我们调用Hello 传入这个值 
by typing in their name and then we're calling Hello, passing in that value.

2028
01:36:04,620 --> 01:36:07,790
在这一点上 我可以理所当然地认为Hello存在 
Well at this point, I can just take for granted that Hello exists,

2029
01:36:07,790 --> 01:36:11,360
即使它在文件中的位置更低 或者正如我们在未来几周看到的那样 
even if it's way down further in the file or, as we'll see in future weeks,

2030
01:36:11,360 --> 01:36:13,970
即使是在另一个文件里
even if it's in a different file altogether.

2031
01:36:13,970 --> 01:36:15,500
但这里有个问题 
But there's a problem here.

2032
01:36:15,500 --> 01:36:19,190
让我继续运行这个版本的Hello.py 
And let me go ahead and run this version of Hello.py.

2033
01:36:19,190 --> 01:36:23,270
请注意 只要我运行解释器 Hello.py的Python 
Notice that as soon as I run the interpreter, Python of Hello.py,

2034
01:36:23,270 --> 01:36:26,360
我看到一个名称错误 名称Hello未定义 
I see a name error, name Hello is not defined.

2035
01:36:26,360 --> 01:36:28,280
再说一遍 你是说帮助吗？
Again, did you mean Help?

2036
01:36:28,280 --> 01:36:29,480
好吧 再一次 合适 
Well, again, fitting.

2037
01:36:29,480 --> 01:36:33,500
我确实需要一些帮助 但我并不想调用Help函数 
I do need some help here, but I didn't mean to call the function Help.

2038
01:36:33,500 --> 01:36:36,650
然而 这里的问题是 Python只是从字面上理解我 
The problem here, though, is that Python is just taking me literally.

2039
01:36:36,650 --> 01:36:40,610
我已经定义了函数Hello一直到这里 
I have defined my function Hello all the way down here,

2040
01:36:40,610 --> 01:36:42,500
但我想把它用在这里
but I'm trying to use it way up here.

2041
01:36:42,500 --> 01:36:43,465
这是不允许的
And that's not allowed.

2042
01:36:43,465 --> 01:36:45,590
Python的解释器将从字面上理解
Python's interpreter is going to take you literally

2043
01:36:45,590 --> 01:36:47,810
如果你使用一个函数 它必须已经
and if you use a function, it must already

2044
01:36:47,810 --> 01:36:50,390
在你打电话的时候就存在了 
exist by the time you are calling it.

2045
01:36:50,390 --> 01:36:51,600
我该怎么解决这个问题？
So how do I fix this?

2046
01:36:51,600 --> 01:36:53,270
显然我不能这么做 
Well, apparently I can't do that.

2047
01:36:53,270 --> 01:36:57,440
我必须在文件的最顶端定义任何函数 
I have to define any functions I want at the very top of my file,

2048
01:36:57,440 --> 01:36:59,720
但这也会给我带来麻烦
but that too could get me into a bit of trouble

2049
01:36:59,720 --> 01:37:04,640
因为如果我总是要定义一个函数
eventually because if I constantly have to define a function above where I want

2050
01:37:04,640 --> 01:37:07,010
要使用它 你需要反向编写代码 
to use it, you're kind of writing code in reverse,

2051
01:37:07,010 --> 01:37:09,218
你不断地在这里写函数 在这里 
you're constantly writing functions up here, up here,

2052
01:37:09,218 --> 01:37:12,450
在这里 相对于逻辑地写代码 从上到下 
up here, as opposed to writing your code logically, top to bottom.

2053
01:37:12,450 --> 01:37:16,190
让我用一种更标准的方法来解决这个问题 就是这样做 
So let me fix this in a more standard way, which is to do this.

2054
01:37:16,190 --> 01:37:20,990
一般来说 您确实希望将代码的主要部分
Generally speaking, you do want to put the main part of your code

2055
01:37:20,990 --> 01:37:22,530
在你档案的顶部
at the top of your file.

2056
01:37:22,530 --> 01:37:27,110
实际上 我将定义一个函数 叫做Main 
And in fact, I'm going to go so far as to define my function, called Main.

2057
01:37:27,110 --> 01:37:29,540
这不是一个要求 但它是在数据公约 
It's not a requirement, but it's in data convention,

2058
01:37:29,540 --> 01:37:31,910
这就向读者暗示了
and this just connotes to the reader that this

2059
01:37:31,910 --> 01:37:33,620
是我的计划的主要部分 
is the main part of my program.

2060
01:37:33,620 --> 01:37:38,030
我现在要去掉空的Hello调用 只传入一个版本
I'm going to get rid of my empty Hello call now and only pass in one version

2061
01:37:38,030 --> 01:37:39,110
你好 名字 
with Hello, name.

2062
01:37:39,110 --> 01:37:42,260
再往下 再往下几行 
And then down here, a couple of lines further down,

2063
01:37:42,260 --> 01:37:45,030
实际上 我将定义我的Hello函数 
I'll actually define my Hello function.

2064
01:37:45,030 --> 01:37:47,870
不幸的是 现在我已经以这种方式重新排序了函数 
Unfortunately, now that I've reordered the functions in this way,

2065
01:37:47,870 --> 01:37:51,890
我把代码的主要部分放在顶部 Hello放在底部 
by putting the main part of my code at the top and Hello at the bottom

2066
01:37:51,890 --> 01:37:55,310
这样我的逻辑就可以从上到下 
so that my logic kind of flows top to bottom, if I go ahead and run

2067
01:37:55,310 --> 01:37:57,680
Hello.py的Python 输入 
Python of Hello.py, Enter.

2068
01:37:57,680 --> 01:38:00,290
什么都没发生 
Nothing whatsoever happens.

2069
01:38:00,290 --> 01:38:02,630
如果我再做一次 什么都不会发生 
If I do it again, nothing whatsoever happens.

2070
01:38:02,630 --> 01:38:04,520
这到底是为什么
Well, why in the world is this?

2071
01:38:04,520 --> 01:38:06,740
我定义了一个函数
Well, just because I've defined a function called

2072
01:38:06,740 --> 01:38:09,230
Main和我定义了一个叫Hello的函数
Main and I've defined a function called Hello,

2073
01:38:09,230 --> 01:38:11,420
并不意味着我真的打过电话
doesn't mean that I've actually called--

2074
01:38:11,420 --> 01:38:13,340
这两种都是
that is used-- either of them.

2075
01:38:13,340 --> 01:38:16,970
是的 我在Main内部使用Hello 但没有人
Yes, I'm using Hello inside of Main, but no one

2076
01:38:16,970 --> 01:38:20,210
告诉Python实际使用或调用Main 
is telling Python to actually use or call Main.

2077
01:38:20,210 --> 01:38:24,770
为了整理好这个文件 我最后要做的就是 
So in order to tidy this up, the last thing I need to do in this file,

2078
01:38:24,770 --> 01:38:28,100
实际上是调用我的main函数 
it seems, is actually call my main function.

2079
01:38:28,100 --> 01:38:30,890
实际上 通过这样调用我的main函数 
And, in fact, by calling my main function in this way,

2080
01:38:30,890 --> 01:38:33,890
它让我摆脱了麻烦 因为现在我先定义Main
it gets me out of trouble because now I'm defining Main first

2081
01:38:33,890 --> 01:38:35,450
但我还没打给你
but I'm not calling Hello yet.

2082
01:38:35,450 --> 01:38:38,760
我将定义Hello next 但我不会调用Hello next 
I'm defining Hello next, but I'm not calling Hello next.

2083
01:38:38,760 --> 01:38:42,170
我只在这个文件的最后调用Main
I only at the very end of this file call Main

2084
01:38:42,170 --> 01:38:45,090
它的作用是在这里运行这段代码 
which has the effect of running this code up here,

2085
01:38:45,090 --> 01:38:47,690
它的作用是在这里运行这段代码 
which has the effect of running this code down here,

2086
01:38:47,690 --> 01:38:50,870
因此我可以整理我的档案
and it allows me therefore to organize my file

2087
01:38:50,870 --> 01:38:55,520
并以任何我想要的方式排列我的函数 包括顶部的Main 
and order my functions in any way I want, including Main at the very top,

2088
01:38:55,520 --> 01:38:59,930
并最终解决Python不知道发生了什么的问题 
and solving ultimately that problem of Python not knowing what's going on.

2089
01:38:59,930 --> 01:39:02,780
需要注意的是 我定义了函数
Now it's important to note that I defined my function

2090
01:39:02,780 --> 01:39:05,690
你好 作为一个论点 然后我
Hello as taking an argument To and then I

2091
01:39:05,690 --> 01:39:08,390
将变量的值传入该函数
passed into that function the value of the variable

2092
01:39:08,390 --> 01:39:11,570
我想跟它打个招呼 它就是名为Name的变量
that I wanted to say Hello to, that is the variable called Name.

2093
01:39:11,570 --> 01:39:14,420
因为假设我做了一些不同的事情 
Because suppose I had done something a little bit differently.

2094
01:39:14,420 --> 01:39:17,670
假设我没有定义Hello是接受一个参数 
Suppose that I hadn't defined Hello is taking an argument,

2095
01:39:17,670 --> 01:39:21,560
所以我只删除了对To及其默认值“world”提及 “
so I just remove mention of To and its default value "world."

2096
01:39:21,560 --> 01:39:25,070
我回到我的主函数 
And I go back up to my main function and I just

2097
01:39:25,070 --> 01:39:28,193
调用Hello本身而不传入任何参数 
call Hello itself without passing in any arguments.

2098
01:39:28,193 --> 01:39:30,360
现在让我继续做我的最后一件改变 
And now let me go ahead and make my one more change,

2099
01:39:30,360 --> 01:39:32,760
技术上还有一个错误 让我继续
one more mistake technically, let me go ahead

2100
01:39:32,760 --> 01:39:37,720
并尝试简单地打印出Hello函数中的名称的值 
and just try to naively print out the value of Name in the Hello function.

2101
01:39:37,720 --> 01:39:40,380
现在需要说明的是 在我第2行的主函数中 
So now to be clear, in my main function on line 2,

2102
01:39:40,380 --> 01:39:43,740
我定义了名为name的变量 并将返回值赋给它
I'm defining my variable called Name and assigning it the return value

2103
01:39:43,740 --> 01:39:45,480
来自用户的输入功能 
of the input function from the user.

2104
01:39:45,480 --> 01:39:47,010
然后我就给你打个电话 
I'm then just calling Hello.

2105
01:39:47,010 --> 01:39:50,700
在我的Hello函数中 它现在不再接受任何参数 
In my Hello function, which now no longer takes any arguments,

2106
01:39:50,700 --> 01:39:54,180
我正在调用Print 传入Hello逗号 
I am calling print, passing in Hello comma,

2107
01:39:54,180 --> 01:39:56,970
然后立即传入名称、变量
and then immediately passing in Name, the variable

2108
01:39:56,970 --> 01:39:58,740
我得到了用户的输入 
into which I got the user's input.

2109
01:39:58,740 --> 01:40:02,232
但问题是 这个名字现在只存在于Main中 
But the catch is that name exists now only in Main.

2110
01:40:02,232 --> 01:40:05,190
所以 当我尝试运行这个版本的程序时 请注意会发生什么
And so watch what happens when I try to run this version of the program

2111
01:40:05,190 --> 01:40:07,170
使用Python Hello.py 
with Python Hello.py.

2112
01:40:07,170 --> 01:40:08,220
我按了Enter键 
I hit Enter.

2113
01:40:08,220 --> 01:40:10,500
我被提示输入我的名字 D-A-V-I-D 回车 
I'm prompted for my name, D-A-V-I-D, Enter.

2114
01:40:10,500 --> 01:40:11,340
还有 啊！
And, argh!

2115
01:40:11,340 --> 01:40:12,450
名称错误 
A name error.

2116
01:40:12,450 --> 01:40:15,400
未定义名称“name” 
Name "Name" is not defined.

2117
01:40:15,400 --> 01:40:19,050
因此 这实际上是一个所谓范围的问题 
So it turns out that this is actually an issue of what's called scope.

2118
01:40:19,050 --> 01:40:23,970
作用域是指仅存在于定义该变量的上下文中的变量 
Scope refers to a variable only existing in the context in which you defined it.

2119
01:40:23,970 --> 01:40:28,080
因此 只要我定义了这个变量 在我的Main函数中命名 
So insofar as I define this variable, Name in my main function,

2120
01:40:28,080 --> 01:40:31,020
我只能在我的名字函数中使用该变量 
I can only use that variable in my name function.

2121
01:40:31,020 --> 01:40:34,380
我不能像我在Hello函数中尝试的那样使用它 
I can't use it as I've tried to here in my Hello function.

2122
01:40:34,380 --> 01:40:36,930
它不存在于那个所谓的范围内 
It doesn't exist in that so-called scope.

2123
01:40:36,930 --> 01:40:42,010
这就是为什么现在 如果我倒回并撤销所有这些更改 
And so this is why now, if I rewind and undo all of those changes,

2124
01:40:42,010 --> 01:40:45,690
您将看到我故意从Main函数中传递Main
you'll see that I'm deliberately passing Main from my main function

2125
01:40:45,690 --> 01:40:47,340
进入我的Hello函数 
into my Hello function.

2126
01:40:47,340 --> 01:40:50,260
现在在Hello函数中 从技术上讲 它有一个不同的名称 
And now in the Hello function, it technically has a different name.

2127
01:40:50,260 --> 01:40:52,380
在这种情况下 它被要求这样做 但这很好 
It's called To in that context, but that's fine.

2128
01:40:52,380 --> 01:40:55,950
命名自己的变量完全由每个单独的函数决定
It's completely up to each individual function to name its own variables

2129
01:40:55,950 --> 01:40:58,230
或者命名自己的论点 但这是现在的一种方式
or name its own arguments, but this is a way now

2130
01:40:58,230 --> 01:41:01,630
我将该变量的值传递给Hello函数
that I'm handing to the Hello function the value of that variable

2131
01:41:01,630 --> 01:41:04,530
所以它也可以由Hello打印 
so it can be printed by Hello as well.

2132
01:41:04,530 --> 01:41:07,410
我们还可以在这里添加最后一个华丽的元素 
And there's one final flourish we can add here.

2133
01:41:07,410 --> 01:41:10,590
现在我们已经实现了Hello 您会注意到Hello Only
Now that we've implemented Hello, you'll notice that Hello only

2134
01:41:10,590 --> 01:41:12,120
有所谓的副作用 
has a so-called side effect.

2135
01:41:12,120 --> 01:41:14,580
它只将某些内容打印到屏幕上 
It only prints out something to the screen.

2136
01:41:14,580 --> 01:41:19,980
好吧 如果我也希望我的功能本身不会有副作用 
Well, what if I also want my function to not have a side effect, per se,

2137
01:41:19,980 --> 01:41:22,300
但真的给了我一个价值吗？
but actually hand me back a value?

2138
01:41:22,300 --> 01:41:25,740
回想一下 输入函数返回一个值 
Recall that the input function returns a value,

2139
01:41:25,740 --> 01:41:27,510
用户键入的字符串 
the string that the user typed in.

2140
01:41:27,510 --> 01:41:30,060
回想一下 int函数返回值 
Recall that the INT function returns a value.

2141
01:41:30,060 --> 01:41:33,960
FLOAT函数返回传递给它的值 
The float function returns a value that was passed into it.

2142
01:41:33,960 --> 01:41:37,260
你可以在这里使用最后一个关键词 字面意思
Well you can use one final keyword here, literally

2143
01:41:37,260 --> 01:41:40,890
返回可自己显式返回值 
Return to return a value explicitly yourself.

2144
01:41:40,890 --> 01:41:43,890
事实上 让我回到这里的VS代码 我
In fact, let me go back to VS Code here, and I

2145
01:41:43,890 --> 01:41:47,820
我想我们会把注意力放在Calculator.py上
think we'll return our attention to Calculator.py

2146
01:41:47,820 --> 01:41:53,190
看看我们是否不能实现另一个版本的Calculator.py
and see if we can't implement one other version of Calculator.py that actually

2147
01:41:53,190 --> 01:41:56,410
有我们自己的函数 甚至返回值 
has our own function that even returns a value.

2148
01:41:56,410 --> 01:41:59,800
所以我将继续打开Calculator/Py
So I'm going to go ahead and open up calculator/py

2149
01:41:59,800 --> 01:42:03,100
我想这一次我会像以前一样把一切都扔掉 
and I think this time I'm going to throw everything away as before,

2150
01:42:03,100 --> 01:42:06,600
我要开始练习我们在这里所宣扬的东西 
and I'm just going to start practicing what we're preaching here.

2151
01:42:06,600 --> 01:42:09,120
定义一个名为Main的函数 该函数现在
Define a function called Main which is now going

2152
01:42:09,120 --> 01:42:11,070
成为我职能的主要部分 
to be the main part of my function.

2153
01:42:11,070 --> 01:42:13,980
我们继续 现在声明一个名为x的变量 
Let's go ahead and now declare a variable called x,

2154
01:42:13,980 --> 01:42:19,350
并在询问他们之后将其分配给用户输入的转换版本 
and assign it to the converted version of the user's input after asking them,

2155
01:42:19,350 --> 01:42:20,430
X是什么？
what's x?

2156
01:42:20,430 --> 01:42:23,490
再说一遍 这一行代码和我们以前做过的一样 
So again, a line of code quite like we've done before.

2157
01:42:23,490 --> 01:42:27,023
现在假设我想要做的是对这个值进行平方 
And suppose now that what I want to do is square this value.

2158
01:42:27,023 --> 01:42:29,190
我想取用户输入的号码
I want to take the number that the user has typed in

2159
01:42:29,190 --> 01:42:30,840
并将其乘以2的幂 
and raise it to the power of 2.

2160
01:42:30,840 --> 01:42:32,790
所以2的平方等于4 
So 2 squared would be 4.

2161
01:42:32,790 --> 01:42:34,410
3的平方等于9 
3 squared would be 9.

2162
01:42:34,410 --> 01:42:36,840
4的平方等于16 以此类推 
4 squared would be 16, and so forth.

2163
01:42:36,840 --> 01:42:39,450
那么我该如何逐字实现一个函数呢
Well how do I go about implementing a function literally

2164
01:42:39,450 --> 01:42:42,960
名为Square的应用程序实际上并没有内置Python？
called Square which actually doesn't come with Python built-in?

2165
01:42:42,960 --> 01:42:45,660
好吧 让我暂时假设它确实存在 并让
Well, let me assume for the moment that it does exist, and let

2166
01:42:45,660 --> 01:42:47,530
我这样说--
me say something like this--

2167
01:42:47,530 --> 01:42:50,670
让我继续说 印刷 如何
let me go ahead and say that printing, how

2168
01:42:50,670 --> 01:42:57,720
大约x的平方是x的逗号平方 
about x squared is comma square of x.

2169
01:42:57,720 --> 01:42:59,170
那么我做了什么呢？
So what have I done?

2170
01:42:59,170 --> 01:43:02,710
我定义了一个名为main的函数 并实现了两行 
I've defined a function called Main and I've implemented two lines.

2171
01:43:02,710 --> 01:43:05,190
这些行中的第一行提示用户输入值
The first of these lines prompts the user for a value

2172
01:43:05,190 --> 01:43:09,330
X并将其转换为int 并将其存储在一个名为x的变量中 
x and converts it to an INT and stores it in a variable called x.

2173
01:43:09,330 --> 01:43:12,930
在第三行 我说x的平方是 然后
On line 3, I then say x squared is and then

2174
01:43:12,930 --> 01:43:16,620
我将第二个参数传递给print函数 无论返回什么
I pass a second argument to the print function, whatever the return

2175
01:43:16,620 --> 01:43:18,780
Value是一个平方函数 
value is of a square function.

2176
01:43:18,780 --> 01:43:22,230
但是平方是不存在的 我会在这里展示给你们看 
But squared doesn't exist and I'll show you this here,

2177
01:43:22,230 --> 01:43:30,090
如果我现在调用底部的Main 并运行Calculator.py的Python 
if I now call Main at the bottom and I run Python of Calculator.py,

2178
01:43:30,090 --> 01:43:35,100
我会看到x是2 然后我会看到一大堆错误 一个名字错误 
I'll see that x is 2 and then I see a whole bunch of errors, a name error,

2179
01:43:35,100 --> 01:43:37,090
未定义名称Square 
name Square is not defined.

2180
01:43:37,090 --> 01:43:39,810
所以这不是一个打字错误 只是这个函数不存在 
So this isn't a typo here, it's just the function doesn't exist.

2181
01:43:39,810 --> 01:43:41,790
但我想我可以让它在这里存在 
But I think I can make it exist here.

2182
01:43:41,790 --> 01:43:45,180
让我们继续定义另一个名为Square的函数 
Let me go ahead and define another function called Square.

2183
01:43:45,180 --> 01:43:47,400
这一张将会有一个数字 我是
This one's going to take in a number and I'm

2184
01:43:47,400 --> 01:43:50,370
就像许多程序员所说的那样 将其泛称为n 
going to call it generically n, as many a programmer would,

2185
01:43:50,370 --> 01:43:52,260
只是为了代表任何旧数字 
just to represent any old number.

2186
01:43:52,260 --> 01:43:56,010
然后我要怎么做才能求n的平方呢？
And then what do I want to do in order to square n?

2187
01:43:56,010 --> 01:43:59,380
嗯 一个数字的平方实际上就是它自己的乘积 
Well a number squared is really just itself times itself,

2188
01:43:59,380 --> 01:44:00,720
所以我要这么做--
so I'm going to do this--

2189
01:44:00,720 --> 01:44:02,340
N乘以n 
n times n.

2190
01:44:02,340 --> 01:44:06,180
但光靠自己算算是不够的 n乘以n 
But it's not enough just to do the math yourself, n times n.

2191
01:44:06,180 --> 01:44:09,990
您将必须返回实际值n乘以n
You're going to have to return the actual value n times n

2192
01:44:09,990 --> 01:44:11,970
这就是我们的新关键词 
and that's our new keyword here.

2193
01:44:11,970 --> 01:44:14,100
当我现在这样做的时候 看看会发生什么 
When I now do this, watch what happens.

2194
01:44:14,100 --> 01:44:16,230
在Calculator.py的Python中 输入 
Python of Calculator.py, Enter.

2195
01:44:16,230 --> 01:44:20,250
X说应该是2 x的平方是4 
X say shall be 2, x squared is 4.

2196
01:44:20,250 --> 01:44:24,020
现在让我继续 假设x现在是3 
Let me go ahead now and say x is now 3.

2197
01:44:24,020 --> 01:44:26,010
X的平方现在是9 
X squared is now 9.

2198
01:44:26,010 --> 01:44:30,060
所以我实现了我自己的函数 它返回值的平方
So I've implemented my very own function that returns the square of a value

2199
01:44:30,060 --> 01:44:33,180
因为我使用的是返回关键字 所以
and because I'm using the return keyword, that

2200
01:44:33,180 --> 01:44:36,120
确保我可以传递此函数的返回值 只是
ensures that I can pass the return value of this, just

2201
01:44:36,120 --> 01:44:40,140
就像INPUT、INT或FLOAT的返回值一样 返回到另一个函数 
like the return value of input or INT or float, to another function,

2202
01:44:40,140 --> 01:44:41,460
比如印刷品 
like print instead.

2203
01:44:41,460 --> 01:44:44,520
在这里 也会有很多方法来解决这个同样的问题 
And here too there's going to be so many ways to solve this same problem.

2204
01:44:44,520 --> 01:44:47,490
我实际上可以把n的2次方 
I can actually raise n to the power of 2.

2205
01:44:47,490 --> 01:44:49,620
我们以前没有见过这种语法 但如果您
We've not seen this syntax before, but if you

2206
01:44:49,620 --> 01:44:54,220
用像这样的两个星号 两颗星 把左边的东西抬起来
use two asterisks like this, two stars, that raises the thing on the left

2207
01:44:54,220 --> 01:44:55,590
右手边的电源 
to the power on the right.

2208
01:44:55,590 --> 01:44:58,290
或者 原来在Python中有一个名为
Or it turns out there is in Python a function called

2209
01:44:58,290 --> 01:45:00,480
战俘将某事提升到某种力量
POW for raising something to the power that

2210
01:45:00,480 --> 01:45:04,200
接受两个参数 第一个参数是数字 第二个参数是
takes two arguments, the first of which is the number, the second of which

2211
01:45:04,200 --> 01:45:05,140
是指数 
is the exponent.

2212
01:45:05,140 --> 01:45:09,810
同样 也有很多方法可以真正解决同样的问题
So there too, there's just so many ways to actually solve that same problem

2213
01:45:09,810 --> 01:45:11,290
也是 
as well.

2214
01:45:11,290 --> 01:45:13,020
那么 归根结底 我们在这里做了什么？
So ultimately, what have we done here?

2215
01:45:13,020 --> 01:45:15,960
我们首先介绍了函数--这些动作或动词 其中许多
We first introduced functions-- these actions or verbs, many of which

2216
01:45:15,960 --> 01:45:19,000
将其内置到只能在您自己的代码中使用的Python中 
come built into Python that you can just use in your own code.

2217
01:45:19,000 --> 01:45:22,290
然后我们引入了变量 您可以通过这些变量存储这些返回值
We then introduced variables via which you could store those return values

2218
01:45:22,290 --> 01:45:24,120
然后也许可以用它做更多的事情 
and then maybe do something more with it.

2219
01:45:24,120 --> 01:45:25,350
在一天结束时也是如此 
At the end of the day too.

2220
01:45:25,350 --> 01:45:28,260
您现在有能力创建、发明自己的函数
You now have the ability to create, to invent your own functions

2221
01:45:28,260 --> 01:45:30,750
解决像Hello这样的简单问题 或者在几周内
to solve simple problems like Hello, or in the weeks

2222
01:45:30,750 --> 01:45:36,590
即将到来的--更复杂、更具挑战性、更有趣的问题 
to come-- much more sophisticated, more challenging, more fun problems as well.

