1
00:00:00,000 --> 00:00:02,946
[音乐播放]

2
00:00:25,020 --> 00:00:28,560
David Malan：这是CS50的S介绍使用Python语言编程 

3
00:00:28,560 --> 00:00:32,100
我的名字是大卫·马兰 本周我们关注的是条件句 

4
00:00:32,100 --> 00:00:36,120
条件句 或条件语句 在Python和其他语言中 

5
00:00:36,120 --> 00:00:40,620
问问题和回答问题的能力是按顺序的吗？

6
00:00:40,620 --> 00:00:43,260
来决定是否要执行此行代码？

7
00:00:43,260 --> 00:00:44,220
还是这行代码？

8
00:00:44,220 --> 00:00:46,020
还是这一行代码呢？

9
00:00:46,020 --> 00:00:48,780
他们允许你在路上走谚语中的分叉口 

10
00:00:48,780 --> 00:00:50,730
在您自己的代码中 逻辑上 

11
00:00:50,730 --> 00:00:54,210
那么 我们该如何着手做出其中一些决定呢？

12
00:00:54,210 --> 00:00:57,592
好的 事实证明 Python附带了很多内置语法 

13
00:00:57,592 --> 00:00:59,550
例如 这里只是其中的一些符号

14
00:00:59,550 --> 00:01:01,770
您可以在Python中使用来提出问题 

15
00:01:01,770 --> 00:01:04,860
诚然 数学问题 但我们将从那里开始 如果

16
00:01:04,860 --> 00:01:07,470
为了在早期保持示例的简单性 

17
00:01:07,470 --> 00:01:11,160
第一个符号 正如你可能从数学中知道的 代表大于 

18
00:01:11,160 --> 00:01:14,640
第二个符号可能看起来不太眼熟 因为我们通常写它

19
00:01:14,640 --> 00:01:16,800
这一切都像一张纸上的一件事 

20
00:01:16,800 --> 00:01:19,830
但在键盘上 如果你想说大于或等于 

21
00:01:19,830 --> 00:01:21,300
你可以用这个符号来代替 

22
00:01:21,300 --> 00:01:22,920
当然 这意味着不到 

23
00:01:22,920 --> 00:01:25,590
这意味着小于或等于 

24
00:01:25,590 --> 00:01:27,720
这是一件有点好奇的事 

25
00:01:27,720 --> 00:01:30,240
我们已经看到 在我们研究函数和变量时 

26
00:01:30,240 --> 00:01:35,650
我们是如何用一个等号给变量赋值的 

27
00:01:35,650 --> 00:01:38,010
但这个等号并不代表平等 

28
00:01:38,010 --> 00:01:40,230
它代表从右到左的任务 

29
00:01:40,230 --> 00:01:42,390
这太好了 因为它解决了这个问题 

30
00:01:42,390 --> 00:01:45,030
但它给我们留下了一点束缚 因为我们现在如何

31
00:01:45,030 --> 00:01:47,190
比较两个东西 左边和右边？

32
00:01:47,190 --> 00:01:51,390
在Python语言中 以及在许多语言中 您实际上使用了两个相等的边 

33
00:01:51,390 --> 00:01:55,200
因此 两个等号代表平等 比较事物

34
00:01:55,200 --> 00:01:56,310
在左边和右边 

35
00:01:56,310 --> 00:01:59,250
一个等号 一如既往地代表赋值 

36
00:01:59,250 --> 00:02:01,650
把东西从右边复制到左边 

37
00:02:01,650 --> 00:02:04,650
最后 最后一个符号表示不等于 

38
00:02:04,650 --> 00:02:08,699
所以感叹号 或bang 后面跟着一个等号 

39
00:02:08,699 --> 00:02:12,180
表示不等于它旁边的某个值 

40
00:02:12,180 --> 00:02:15,900
好的 用这些符号或其他任何符号来提问 

41
00:02:15,900 --> 00:02:18,240
我们将需要在Python中使用另一个关键字 

42
00:02:18,240 --> 00:02:21,120
这个关键字很简单 就像在英语中一样 就是if 

43
00:02:21,120 --> 00:02:24,420
您可以在Python代码中提出如下问题：

44
00:02:24,420 --> 00:02:28,890
如果这个问题的答案是真的 那就说吧

45
00:02:28,890 --> 00:02:30,760
帮我执行这段代码 

46
00:02:30,760 --> 00:02:33,240
所以让我们继续在这里写一些这样的例子 

47
00:02:33,240 --> 00:02:35,073
我将转到VS代码 

48
00:02:35,073 --> 00:02:36,990
让我们先来创建一个程序 

49
00:02:36,990 --> 00:02:39,900
它的目标是简单地

50
00:02:39,900 --> 00:02:44,980
编写比较值并根据这些值做出决策的代码 

51
00:02:44,980 --> 00:02:47,400
让我们继续输入comare.py代码 

52
00:02:47,400 --> 00:02:49,980
为了创建一个名为Compare的全新文件 

53
00:02:49,980 --> 00:02:52,415
我们将开始表达其中的一些逻辑 

54
00:02:52,415 --> 00:02:53,790
那么 我们想要比较什么呢？

55
00:02:53,790 --> 00:02:56,130
为了便于讨论 假设我们想要比较 

56
00:02:56,130 --> 00:02:57,540
只有几个整数 

57
00:02:57,540 --> 00:03:00,210
但我们希望这些整数来自用户 

58
00:03:00,210 --> 00:03:03,810
这样我们就可以根据数字做出决定

59
00:03:03,810 --> 00:03:05,915
我们不知道预付款的价值 

60
00:03:05,915 --> 00:03:07,290
好吧 让我们继续做这件事 

61
00:03:07,290 --> 00:03:10,350
正如我们在过去所做的那样 让我们将其声明为一个变量 如x 

62
00:03:10,350 --> 00:03:15,330
让我们将其赋值为int函数的返回值 

63
00:03:15,330 --> 00:03:19,320
并将输入函数的返回值传递给INT函数 

64
00:03:19,320 --> 00:03:22,680
问用户一个问题 比如 什么是x 问题

65
00:03:22,680 --> 00:03:24,210
马克 就像我们过去做的那样 

66
00:03:24,210 --> 00:03:29,490
让我们对y再做一次 询问用户y的值 

67
00:03:29,490 --> 00:03:33,790
再一次 最终将其转换为int 

68
00:03:33,790 --> 00:03:37,200
有了这个故事的数量 我们有两个变量 x和y 

69
00:03:37,200 --> 00:03:38,622
其中每一个都有其价值 

70
00:03:38,622 --> 00:03:41,080
理想情况下 我们现在应该能够比较这些值 

71
00:03:41,080 --> 00:03:45,510
假设我想要根据这些变量的值做出决定 

72
00:03:45,510 --> 00:03:46,848
我将使用关键字if 

73
00:03:46,848 --> 00:03:49,140
我将使用其中一些数学符号

74
00:03:49,140 --> 00:03:51,100
才能真正问出问题本身 

75
00:03:51,100 --> 00:03:55,860
这样如何 如果x小于y 那么让我们继续

76
00:03:55,860 --> 00:03:56,940
打印出尽可能多的内容 

77
00:03:56,940 --> 00:03:59,700
引用 无引号的x小于y 

78
00:03:59,700 --> 00:04:02,250
所以这还不是一个很有趣的项目 

79
00:04:02,250 --> 00:04:05,580
从字面上讲 我只是在根据数学原理陈述显而易见的事情 

80
00:04:05,580 --> 00:04:08,160
但它允许我现在引入一些新的语法 

81
00:04:08,160 --> 00:04:10,020
具体的语法是什么？

82
00:04:10,020 --> 00:04:12,990
嗯 它是这样的--不仅仅是关键字if 哪

83
00:04:12,990 --> 00:04:15,180
我已经在第四行的开头添加了 

84
00:04:15,180 --> 00:04:18,450
然后我在这里问了我的问题 x小于y 

85
00:04:18,450 --> 00:04:21,450
X是左边的一个变量 y是右边的一个变量 

86
00:04:21,450 --> 00:04:24,570
当然 小于号表示数学问题

87
00:04:24,570 --> 00:04:25,200
我有过 

88
00:04:25,200 --> 00:04:26,970
我在这里强调的是从技术上讲

89
00:04:26,970 --> 00:04:29,400
称为布尔表达式 

90
00:04:29,400 --> 00:04:32,550
一个布尔表达式 以数学家布尔来命名 

91
00:04:32,550 --> 00:04:36,870
仅仅是一个有是或否答案的问题 或者从技术上讲 

92
00:04:36,870 --> 00:04:38,760
正确或错误的答案 

93
00:04:38,760 --> 00:04:41,670
这很好 因为如果只有两个可能的答案

94
00:04:41,670 --> 00:04:44,760
对我和电脑来说 做决定非常容易--

95
00:04:44,760 --> 00:04:47,100
做这件事 否则别做这件事 

96
00:04:47,100 --> 00:04:49,800
现在注意 如果你来自其他语言 

97
00:04:49,800 --> 00:04:53,100
您可能注意到 我没有键入任何括号 

98
00:04:53,100 --> 00:04:56,190
事实上 它们不是必需的 至少在这种情况下 在Python中是不必要的 

99
00:04:56,190 --> 00:04:58,980
但我在行尾打了一个冒号 

100
00:04:58,980 --> 00:05:01,920
更重要的是 在下一行

101
00:05:01,920 --> 00:05:04,350
我的生产线一开始就有一些缩进 

102
00:05:04,350 --> 00:05:07,380
按空格键四次 或者只按一次Tab键 

103
00:05:07,380 --> 00:05:09,660
它将自动转换为相同的 

104
00:05:09,660 --> 00:05:13,980
这种缩进告诉Python 第五行应该只

105
00:05:13,980 --> 00:05:20,260
如果第四行问题的答案事实上是真的 则执行 

106
00:05:20,260 --> 00:05:24,022
因此 如果x小于y 则该短语将在之后打印 

107
00:05:24,022 --> 00:05:25,730
那么 让我们再添加几行代码 

108
00:05:25,730 --> 00:05:26,855
再问一个问题怎么样？

109
00:05:26,855 --> 00:05:30,550
如果x大于y 那么我们继续打印它 

110
00:05:30,550 --> 00:05:33,010
X大于y 

111
00:05:33,010 --> 00:05:38,560
让我们做最后一个问题 如果x等于y 那么--等一下 

112
00:05:38,560 --> 00:05:41,360
我在这里做错了什么？

113
00:05:41,360 --> 00:05:42,250
这里有一只好眼睛 

114
00:05:42,250 --> 00:05:44,080
我不想把y赋给x 

115
00:05:44,080 --> 00:05:48,430
如果x等于y是我表达平等的方式 那么让我们继续

116
00:05:48,430 --> 00:05:52,420
打印输出x等于y 

117
00:05:52,420 --> 00:05:56,470
所以我现在有三个条件 如果你愿意的话 

118
00:05:56,470 --> 00:05:59,935
一个问题问x小于y 另一个问题问x大于y 

119
00:05:59,935 --> 00:06:02,860
一次求x等于y 

120
00:06:02,860 --> 00:06:03,912
让我们运行代码 

121
00:06:03,912 --> 00:06:05,620
嗯 在我的终端窗口里 我

122
00:06:05,620 --> 00:06:08,320
运行Compare.py的Python并按Enter键 

123
00:06:08,320 --> 00:06:09,190
X是什么？

124
00:06:09,190 --> 00:06:10,390
那我们就选一个吧 

125
00:06:10,390 --> 00:06:11,140
你是什么？

126
00:06:11,140 --> 00:06:12,370
我们选两个吧 

127
00:06:12,370 --> 00:06:15,940
当然 这应该执行第一行代码

128
00:06:15,940 --> 00:06:18,970
告诉我 实际上 x小于y 

129
00:06:18,970 --> 00:06:21,670
正如我在那里所期望的那样 

130
00:06:21,670 --> 00:06:24,400
好吧 刚才发生了什么 不过 用代码？

131
00:06:24,400 --> 00:06:28,090
好吧 让我们来看看 也许 从视觉上看同样的代码 

132
00:06:28,090 --> 00:06:31,210
尤其是如果你是一个更直观的学习者 我敢说 

133
00:06:31,210 --> 00:06:32,500
就是刚刚发生的事情 

134
00:06:32,500 --> 00:06:34,840
所以我们现在看到的是一个流程图 

135
00:06:34,840 --> 00:06:37,900
这是这个程序的逻辑示意图 

136
00:06:37,900 --> 00:06:41,470
从技术上讲 它显示了程序的控制流 

137
00:06:41,470 --> 00:06:43,510
也就是说 您在代码中控制

138
00:06:43,510 --> 00:06:46,210
程序的流动 通常是从上到下 

139
00:06:46,210 --> 00:06:49,300
事实上 让我继续放大这个流程图的顶部 

140
00:06:49,300 --> 00:06:52,510
你会在最上面看到一个椭圆形 字面上写着 开始 

141
00:06:52,510 --> 00:06:55,450
也就是说 无论是什么形状或布局

142
00:06:55,450 --> 00:06:58,180
这张图是 你自己的思维和逻辑

143
00:06:58,180 --> 00:07:01,460
当你试图将你的注意力集中在这个程序上时 应该开始 

144
00:07:01,460 --> 00:07:04,480
请注意 从Start到这个钻石形状有一个箭头 

145
00:07:04,480 --> 00:07:07,450
在那个钻石的内部是一个问题 一个布尔表达式 

146
00:07:07,450 --> 00:07:08,800
X小于y 

147
00:07:08,800 --> 00:07:12,190
这个形状意味着 根据这个问题的答案 

148
00:07:12,190 --> 00:07:14,140
往左走还是往右走 

149
00:07:14,140 --> 00:07:16,690
具体来说 如果答案是真的 就向左转 

150
00:07:16,690 --> 00:07:19,240
或者 如果答案为假 则选择正确的答案 

151
00:07:19,240 --> 00:07:24,460
我输入的是1和2 分别代表x和y 

152
00:07:24,460 --> 00:07:26,980
当然 一比二小 

153
00:07:26,980 --> 00:07:32,530
这就是为什么我的程序会打印出来 引用引号 x小于y 

154
00:07:32,530 --> 00:07:34,120
但记住密码 

155
00:07:34,120 --> 00:07:37,270
代码接着又问了两个问题 

156
00:07:37,270 --> 00:07:38,800
x大于y？

157
00:07:38,800 --> 00:07:40,570
x等于y吗？

158
00:07:40,570 --> 00:07:43,570
流程图也描述了这些问题 

159
00:07:43,570 --> 00:07:46,090
请注意 无论问题是否

160
00:07:46,090 --> 00:07:50,530
当我得到一个正确或错误的答案时 两个箭头都会聚下来 

161
00:07:50,530 --> 00:07:52,990
到第二个菱形

162
00:07:52,990 --> 00:07:57,070
第二个菱形问第二个问题 x大于y 

163
00:07:57,070 --> 00:07:58,840
这也有一个正确或错误的答案 

164
00:07:58,840 --> 00:08:00,560
所以我们只能选择一条路 

165
00:08:00,560 --> 00:08:04,600
但如果x是1 y是2 那么答案是否定的 

166
00:08:04,600 --> 00:08:06,190
1不大于y 

167
00:08:06,190 --> 00:08:09,430
所以从逻辑上讲 在流程图中 这次你沿着错误的箭头走 

168
00:08:09,430 --> 00:08:13,750
注意 沿着那个假箭头 这次您没有打印任何内容 

169
00:08:13,750 --> 00:08:16,067
所以我们在屏幕上只看到一个人 

170
00:08:16,067 --> 00:08:17,650
现在 还有第三个问题 

171
00:08:17,650 --> 00:08:19,442
这个流程图也体现了这一点 

172
00:08:19,442 --> 00:08:22,480
第三个菱形问x等于y 

173
00:08:22,480 --> 00:08:25,720
在这个例子中 也有一个错误的答案 因为 当然 

174
00:08:25,720 --> 00:08:27,250
不等于y 

175
00:08:27,250 --> 00:08:30,830
因此 我们再次遵循第三个错误分支 

176
00:08:30,830 --> 00:08:32,890
这导致我们 当然 停下来 

177
00:08:32,890 --> 00:08:35,659
停止只是表示程序到此为止 

178
00:08:35,659 --> 00:08:38,020
所以我认为这是正确的 

179
00:08:38,020 --> 00:08:40,780
这个流程图确实

180
00:08:40,780 --> 00:08:44,140
来表示我写的代码

181
00:08:44,140 --> 00:08:45,220
所以是正确的 

182
00:08:45,220 --> 00:08:46,690
它做了它应该做的 

183
00:08:46,690 --> 00:08:50,290
它通过在屏幕上打印x小于y正确地回答了这个问题 

184
00:08:50,290 --> 00:08:53,803
但是 也许是什么设计不好呢？

185
00:08:53,803 --> 00:08:55,220
让我们做第一个区分 

186
00:08:55,220 --> 00:08:56,770
但这并不足以

187
00:08:56,770 --> 00:08:58,937
你写的是正确的 做你想做的 

188
00:08:58,937 --> 00:09:02,270
从长远来看 特别是随着我们的项目变得越来越长 越来越复杂 

189
00:09:02,270 --> 00:09:06,910
更复杂 我们也希望它们设计得很好 

190
00:09:06,910 --> 00:09:12,610
关于这个项目在哪些方面设计得不好的想法 

191
00:09:12,610 --> 00:09:15,230
即使它是正确的

192
00:09:15,230 --> 00:09:16,300
我看看

193
00:09:16,300 --> 00:09:18,880
卡里德 如果我说的没错 你的想法是什么？

194
00:09:18,880 --> 00:09:21,730
哈立德：太多的如果 我认为 变得重复 

195
00:09:21,730 --> 00:09:23,930
也许我们可以让代码更简洁 

196
00:09:23,930 --> 00:09:25,930
大卫·马兰：是的 这似乎有点重复 

197
00:09:25,930 --> 00:09:28,692
我是问如果这个 如果这个 如果这个 

198
00:09:28,692 --> 00:09:31,900
然而 从逻辑上讲 我应该知道后面那些问题的答案

199
00:09:31,900 --> 00:09:33,040
一旦我想出一个 

200
00:09:33,040 --> 00:09:35,350
简而言之 如果你看这张图 

201
00:09:35,350 --> 00:09:38,650
请注意 无论我是向左还是向右 

202
00:09:38,650 --> 00:09:41,110
我总是问三个问题 

203
00:09:41,110 --> 00:09:45,230
不管怎样 所有的箭头都指向第一个 第二个 

204
00:09:45,230 --> 00:09:46,480
第三颗钻石 

205
00:09:46,480 --> 00:09:49,810
所以我要问三个问题 不管这些答案中的任何一个

206
00:09:49,810 --> 00:09:50,862
是真是假

207
00:09:50,862 --> 00:09:52,570
我该如何改进呢？

208
00:09:52,570 --> 00:09:55,240
好吧 让我提议我们引入另一个关键词

209
00:09:55,240 --> 00:09:57,760
我们的Python词汇表 即elif 

210
00:09:57,760 --> 00:09:59,830
这也是一个简洁的例子 

211
00:09:59,830 --> 00:10:02,770
在英语中 它是else if的连词 

212
00:10:02,770 --> 00:10:07,960
这让我们可以提出一个问题 

213
00:10:07,960 --> 00:10:10,840
前一个问题有一个正确或错误的答案 

214
00:10:10,840 --> 00:10:12,110
我这么说是什么意思

215
00:10:12,110 --> 00:10:13,810
好吧 让我回到我的代码 

216
00:10:13,810 --> 00:10:17,830
让我提议我们现在改进这个 在这里 

217
00:10:17,830 --> 00:10:22,360
通过问我们自己 最终 我们怎么能少问些问题？

218
00:10:22,360 --> 00:10:24,460
让我在这里提出 

219
00:10:24,460 --> 00:10:30,700
而不是问如果 让我们使这些条件潜在地相互

220
00:10:30,700 --> 00:10:31,700
独家新闻

221
00:10:31,700 --> 00:10:35,920
也就是说 回去以后不要再回答问题了

222
00:10:35,920 --> 00:10:37,220
一个真实的答案

223
00:10:37,220 --> 00:10:39,440
所以我将修改代码如下 

224
00:10:39,440 --> 00:10:45,160
而不是问如果 我会说 如果x小于y 

225
00:10:45,160 --> 00:10:50,140
大于y 如果x等于y 

226
00:10:50,140 --> 00:10:52,780
所以我要含蓄地 就像英国人一样 

227
00:10:52,780 --> 00:10:57,520
考虑到我只会不断地问自己这些问题

228
00:10:57,520 --> 00:11:00,340
如果我还没有得到一个真实的回应 

229
00:11:00,340 --> 00:11:02,080
想想这里的逻辑 英国人 

230
00:11:02,080 --> 00:11:07,660
如果x小于y 则在第四行 打印输出x小于y 

231
00:11:07,660 --> 00:11:10,300
好吧 如果是这样的话 从逻辑上讲 你就完了 

232
00:11:10,300 --> 00:11:15,670
因为如果英国人说如果x小于y 否则如果x大于y 

233
00:11:15,670 --> 00:11:19,030
如果第一个问题的答案是相互排斥的

234
00:11:19,030 --> 00:11:19,625
是真的 

235
00:11:19,625 --> 00:11:22,750
你不必一直问你在逻辑上已经知道的问题

236
00:11:22,750 --> 00:11:23,570
答案就是 

237
00:11:23,570 --> 00:11:25,418
现在让我继续运行这个程序 

238
00:11:25,418 --> 00:11:27,460
我认为他们的行为会是一样的 

239
00:11:27,460 --> 00:11:29,710
Py的蟒蛇 x是什么？

240
00:11:29,710 --> 00:11:30,550
让我们来做一个吧 

241
00:11:30,550 --> 00:11:31,210
你是什么？

242
00:11:31,210 --> 00:11:32,400
让我们来做两个 

243
00:11:32,400 --> 00:11:33,910
X小于y 

244
00:11:33,910 --> 00:11:37,330
现在 老实说 当我运行这个程序时 我并没有真正注意到什么不同 

245
00:11:37,330 --> 00:11:41,020
老实说 我的Mac 我的PC 我的手机 

246
00:11:41,020 --> 00:11:44,020
是如此之快 以至于这些改进

247
00:11:44,020 --> 00:11:47,110
不一定会感觉更快 直到我们

248
00:11:47,110 --> 00:11:49,300
编写更大、更快的程序 

249
00:11:49,300 --> 00:11:52,640
但从长远来看 它正在为编写更好的代码奠定基础 

250
00:11:52,640 --> 00:11:54,640
现在 我刚刚取得的进步是什么？

251
00:11:54,640 --> 00:11:57,650
嗯 如果之前我的图表是这样的 

252
00:11:57,650 --> 00:12:02,740
这是有问题的 因为我问了三个问题

253
00:12:02,740 --> 00:12:06,280
什么 即使我已经想好了要在屏幕上打印什么 

254
00:12:06,280 --> 00:12:10,720
这个新版本的程序说 如果 埃利夫 埃利夫 可能看起来

255
00:12:10,720 --> 00:12:12,460
而是像这样的小东西 

256
00:12:12,460 --> 00:12:13,630
现在 它变得更宽了一点 

257
00:12:13,630 --> 00:12:16,390
这只是因为我们把这里的箭头画得更宽了一点 

258
00:12:16,390 --> 00:12:19,030
但让我们关注一下有多少问题被问到了 

259
00:12:19,030 --> 00:12:20,950
像以前一样 让我放大顶部 

260
00:12:20,950 --> 00:12:25,030
让我提议 我们注意到 开始椭圆形在最上面 

261
00:12:25,030 --> 00:12:27,400
它要求我们先问一个问题 

262
00:12:27,400 --> 00:12:29,980
X比y小 一比二小吗？

263
00:12:29,980 --> 00:12:33,400
但请注意 让我放大 如果确实是这样的话

264
00:12:33,400 --> 00:12:39,550
超过两个 我们沿着这个更长的箭头向下 标记为真 

265
00:12:39,550 --> 00:12:42,580
我们打印出报价 不引用的x小于y 

266
00:12:42,580 --> 00:12:48,160
然后 我们立即沿着下一个箭头向下 找到一个图标 上面写着停止 

267
00:12:48,160 --> 00:12:51,670
所以这就是做If Elif Elif所暗示的 

268
00:12:51,670 --> 00:12:55,210
如果我们马上得到第一个假设的真实答案 

269
00:12:55,210 --> 00:12:57,700
我们要打印出x小于y 然后停止 

270
00:12:57,700 --> 00:12:59,870
从逻辑上讲 我们已经到了节目的末尾 

271
00:12:59,870 --> 00:13:03,190
因此 这张图片只是以图形的形式呈现 

272
00:13:03,190 --> 00:13:05,650
代码实际在做什么 

273
00:13:05,650 --> 00:13:07,330
但假设我输入了其他内容 

274
00:13:07,330 --> 00:13:13,450
假设我的代码真的运行了 我为x输入了两个 为y输入了一个 

275
00:13:13,450 --> 00:13:16,430
也就是说 第一个问题的答案现在是假的 

276
00:13:16,430 --> 00:13:19,000
但第二个问题的答案现在是正确的 

277
00:13:19,000 --> 00:13:23,340
因为 当然 二比一大 

278
00:13:23,340 --> 00:13:25,240
好了 让我们回到图表上 

279
00:13:25,240 --> 00:13:28,570
和以前一样 我们从最上面写着开始的地方开始 

280
00:13:28,570 --> 00:13:33,520
这里的第一个问题 现在 x小于y 是一个假的答案 

281
00:13:33,520 --> 00:13:35,950
因为不 两个不少于一个 

282
00:13:35,950 --> 00:13:39,190
所以我们顺着这个箭头到下一个问题 这颗钻石 

283
00:13:39,190 --> 00:13:40,840
X比y大吗？

284
00:13:40,840 --> 00:13:43,660
是的 两个人总比一个人强 

285
00:13:43,660 --> 00:13:47,510
现在我们沿着这个向左的箭头走 这是真的 

286
00:13:47,510 --> 00:13:52,250
我们打印出引号 不引号x大于y 然后停止 

287
00:13:52,250 --> 00:13:53,530
那么 有什么改进呢？

288
00:13:53,530 --> 00:13:55,810
在第一个案例中 我们很幸运 我们只

289
00:13:55,810 --> 00:13:58,090
只要问一个问题 砰 我们就完了 

290
00:13:58,090 --> 00:14:01,420
这一次 我们不得不问两个问题 但然后砰的一声 我们就完了 

291
00:14:01,420 --> 00:14:07,390
只有当x恰好等于y时 我们才能真正发现自己 在逻辑上 

292
00:14:07,390 --> 00:14:11,620
在我的代码中一直到最后的elif 

293
00:14:11,620 --> 00:14:14,830
在图画上 只有当x等于y时才会这样做

294
00:14:14,830 --> 00:14:17,980
我们发现我们一直走到了第三个钻石 

295
00:14:17,980 --> 00:14:23,020
第三个问题 问它是否等于y？

296
00:14:23,020 --> 00:14:25,850
现在 希望在这一点上 答案不是错误的 

297
00:14:25,850 --> 00:14:28,953
我们包含了一个错误的箭头 这样程序本身

298
00:14:28,953 --> 00:14:29,620
是定义明确的 

299
00:14:29,620 --> 00:14:33,520
但是 从逻辑上讲 我们无论如何都不应该真正做到这一点 

300
00:14:33,520 --> 00:14:37,242
因为在这种情况下 它必须小于、大于或等于 

301
00:14:37,242 --> 00:14:38,950
好吧 让我在这里停一下 看看有没有

302
00:14:38,950 --> 00:14:42,340
任何问题 现在 无论是关于这里的代码版本 

303
00:14:42,340 --> 00:14:47,090
或者在这个同样的逻辑的图表上 

304
00:14:47,090 --> 00:14:52,130
关于这个控制流有什么问题吗？

305
00:14:52,130 --> 00:14:55,872
演讲者1：我们不是应该在末尾再加一个吗？

306
00:14:55,872 --> 00:14:57,080
大卫·马兰：问得好 

307
00:14:57,080 --> 00:15:00,103
是的 这将是我的第三个也是最后一个方法 

308
00:15:00,103 --> 00:15:02,270
如果你不介意的话 我们现在就转到那里去 

309
00:15:02,270 --> 00:15:04,820
确定第三个确实存在的关键字

310
00:15:04,820 --> 00:15:09,020
在Python中 这使我们能够更好地表达这一逻辑

311
00:15:09,020 --> 00:15:10,950
把这个程序设计得更好 

312
00:15:10,950 --> 00:15:13,560
这将解决一个特殊的问题 

313
00:15:13,560 --> 00:15:16,820
所以如果我把我们带回这里的代码 请注意

314
00:15:16,820 --> 00:15:20,750
这就是我前面强调的 elif x等于y 

315
00:15:20,750 --> 00:15:23,180
问那个问题并没有错 

316
00:15:23,180 --> 00:15:25,730
事实上 如果你想要特别彻底 

317
00:15:25,730 --> 00:15:29,660
检查x是否小于y 是否大于y是非常有意义的 

318
00:15:29,660 --> 00:15:31,010
或等于y 

319
00:15:31,010 --> 00:15:37,280
但为什么我不需要问第三个也是最后一个问题呢？

320
00:15:37,280 --> 00:15:42,080
演讲者2：我们不需要再问x是否等于y了 因为从逻辑上讲 

321
00:15:42,080 --> 00:15:45,320
如果这两个条件语句的计算结果为假 

322
00:15:45,320 --> 00:15:50,250
只有一个条件的计算结果为真 

323
00:15:50,250 --> 00:15:51,885
也就是说 x等于y 

324
00:15:51,885 --> 00:15:52,760
大卫·马兰：没错 

325
00:15:52,760 --> 00:15:55,250
如果我们都对数学和比较很满意

326
00:15:55,250 --> 00:15:58,820
这里 当然 x要么小于y 要么大于y 

327
00:15:58,820 --> 00:15:59,750
或等于y 

328
00:15:59,750 --> 00:16:02,150
但一旦你排除了前两种情况 

329
00:16:02,150 --> 00:16:05,270
从逻辑上讲 它必须是x等于y的情况 

330
00:16:05,270 --> 00:16:08,060
如果不是这样 那么它就是小于或大于 

331
00:16:08,060 --> 00:16:11,220
所以霍普建议我们使用另一个关键字 Else 

332
00:16:11,220 --> 00:16:12,210
我们如何利用这一点呢？

333
00:16:12,210 --> 00:16:13,752
嗯 跟我们用英语说的一模一样 

334
00:16:13,752 --> 00:16:15,110
让我在这里回到我的代码 

335
00:16:15,110 --> 00:16:18,830
而不是费心去问第三个也是最后一个问题 

336
00:16:18,830 --> 00:16:20,330
我们什么都别问了 

337
00:16:20,330 --> 00:16:24,630
就让我们来个包罗万象的吧 可以这么说 最后一行代码说 

338
00:16:24,630 --> 00:16:27,830
否则就假设x等于y 

339
00:16:27,830 --> 00:16:29,682
因此 也要把它打印出来 

340
00:16:29,682 --> 00:16:30,890
那么 这有什么好处呢？

341
00:16:30,890 --> 00:16:33,570
我的代码仍将以完全相同的方式工作 

342
00:16:33,570 --> 00:16:35,690
再说一次 我的电脑太快了 我

343
00:16:35,690 --> 00:16:39,480
甚至没有注意到它的工作速度比以前更快 

344
00:16:39,480 --> 00:16:41,210
但我们会注意到这类事情

345
00:16:41,210 --> 00:16:44,210
如果我们在这里做更多的工作 更大的项目 

346
00:16:44,210 --> 00:16:46,400
但让我运行Compare.py的Python 

347
00:16:46,400 --> 00:16:49,670
让我们来做 例如 一和二 

348
00:16:49,670 --> 00:16:50,720
对这一点仍然有效 

349
00:16:50,720 --> 00:16:52,460
让我们做二和一 

350
00:16:52,460 --> 00:16:53,630
对这一点仍然有效 

351
00:16:53,630 --> 00:16:55,340
让我们做一次和一次 

352
00:16:55,340 --> 00:16:57,540
事实上 它现在对此起到了作用 

353
00:16:57,540 --> 00:17:01,370
但在这些情况下 让我们考虑一下我们刚刚走过的道路 

354
00:17:01,370 --> 00:17:05,900
之前 我们的图表 当我们有If Elif Elif到位时 

355
00:17:05,900 --> 00:17:07,920
看起来有点像这样 

356
00:17:07,920 --> 00:17:11,990
注意 他们开始说 我们可能问了一两个问题 

357
00:17:11,990 --> 00:17:13,910
或者最坏的情况 三个完整的问题 

358
00:17:13,910 --> 00:17:17,329
但我们可以做得更好 就像霍普建议的那样 使用其他方法 

359
00:17:17,329 --> 00:17:19,582
现在 我们可以把这张图削成这样 

360
00:17:19,582 --> 00:17:22,040
尽管这张图看起来越来越大 

361
00:17:22,040 --> 00:17:25,730
请注意 它内部的构建块更少了 

362
00:17:25,730 --> 00:17:29,240
这张图中的箭头和节点都比较少 

363
00:17:29,240 --> 00:17:30,620
现在让我们从顶层开始 

364
00:17:30,620 --> 00:17:34,160
尽管如此 START仍然将我们引向第一个问题 X比Y小？

365
00:17:34,160 --> 00:17:35,600
如果答案是真的 那就太好了 

366
00:17:35,600 --> 00:17:38,420
我们可以说 x小于y 我们可以停止 

367
00:17:38,420 --> 00:17:41,450
如果不是真的 如果是假的 我们可以问下一个问题 

368
00:17:41,450 --> 00:17:43,820
X大于y 对还是错？

369
00:17:43,820 --> 00:17:44,840
如果是的话 那就太好了 

370
00:17:44,840 --> 00:17:47,270
我们可以打印x大于y 然后停止 

371
00:17:47,270 --> 00:17:51,510
否则 如果不是x大于y的情况 答案是假的 

372
00:17:51,510 --> 00:17:56,060
我们可以立即 从逻辑上说 x等于y 

373
00:17:56,060 --> 00:17:58,610
我们根本不需要添加第三个问题 

374
00:17:58,610 --> 00:18:00,740
我们可以立即在那里得出结论 

375
00:18:00,740 --> 00:18:02,150
那么 这意味着什么呢？

376
00:18:02,150 --> 00:18:05,180
从这些图片中你可以看到 

377
00:18:05,180 --> 00:18:07,140
一个程序的复杂性 

378
00:18:07,140 --> 00:18:10,670
第一个很长很长 有很多很多问题 

379
00:18:10,670 --> 00:18:12,283
不必要的 最终 

380
00:18:12,283 --> 00:18:13,700
下一个更短了 

381
00:18:13,700 --> 00:18:15,560
这个更短

382
00:18:15,560 --> 00:18:19,280
同样 代码行越少 

383
00:18:19,280 --> 00:18:21,400
你可以说会犯任何错误

384
00:18:21,400 --> 00:18:23,150
别人就越容易读懂 

385
00:18:23,150 --> 00:18:26,930
所以 一般来说 这种可读性 这种简化 

386
00:18:26,930 --> 00:18:28,760
的确是件好事

387
00:18:28,760 --> 00:18:33,200
好吧 让我们继续为Python添加另一项功能 

388
00:18:33,200 --> 00:18:34,400
就是这个

389
00:18:34,400 --> 00:18:37,730
就像在英语中 你可以问这个或那个问题 

390
00:18:37,730 --> 00:18:41,540
你可以在Python中用这个词或来表达同样的意思 

391
00:18:41,540 --> 00:18:44,540
让我们回到我的Python代码 

392
00:18:44,540 --> 00:18:47,150
让我们提出几个问题

393
00:18:47,150 --> 00:18:51,860
这一次 也许这一次考虑如何我们可能会问不

394
00:18:51,860 --> 00:18:54,050
无论它是否大于或等于

395
00:18:54,050 --> 00:18:56,070
关心准确的答案

396
00:18:56,070 --> 00:18:58,190
让我们在这里采取一个粗略的方法 

397
00:18:58,190 --> 00:19:04,730
让我们来确定x是否等于y？

398
00:19:04,730 --> 00:19:06,980
好吧 让我删除一些代码

399
00:19:06,980 --> 00:19:08,540
改变我们的问题

400
00:19:08,540 --> 00:19:12,290
让我这么做吧 如果我关心它是否相等 

401
00:19:12,290 --> 00:19:14,060
让我们看看可能的情况 

402
00:19:14,060 --> 00:19:19,850
如果x小于y或者x大于y 我们继续

403
00:19:19,850 --> 00:19:23,840
打印出来的x不等于y

404
00:19:23,840 --> 00:19:26,240
为什么 不是双关语？

405
00:19:26,240 --> 00:19:29,240
如果x小于y 那么 它显然不相等 

406
00:19:29,240 --> 00:19:31,730
如果x大于y 显然不相等 

407
00:19:31,730 --> 00:19:35,840
所以我们可以得出结论x不等于y 

408
00:19:35,840 --> 00:19:41,180
所以如果我们想确保它等于 

409
00:19:41,180 --> 00:19:47,940
我们可以用霍普的else 用引号 x等于y 

410
00:19:47,940 --> 00:19:49,410
这是为什么呢？

411
00:19:49,410 --> 00:19:52,470
如果x小于y 或者x大于y 

412
00:19:52,470 --> 00:19:53,820
它们显然是不相等的

413
00:19:53,820 --> 00:19:56,580
否则 从逻辑上讲 它们实际上必须相等 

414
00:19:56,580 --> 00:19:57,390
我们来运行这个 

415
00:19:57,390 --> 00:19:59,565
让我们继续运行Compare.py的Python 

416
00:19:59,565 --> 00:20:00,240
X是什么？

417
00:20:00,240 --> 00:20:00,930
一 

418
00:20:00,930 --> 00:20:01,560
你是什么？

419
00:20:01,560 --> 00:20:02,250
二 

420
00:20:02,250 --> 00:20:03,960
好的 x不等于y 

421
00:20:03,960 --> 00:20:08,550
让我们再来一次 x等于x y等于y x不等于y 

422
00:20:08,550 --> 00:20:12,450
第三次 x是一 y是一 

423
00:20:12,450 --> 00:20:14,760
X现在等于y 

424
00:20:14,760 --> 00:20:17,610
现在 如果我们也想进行视觉上的比较 

425
00:20:17,610 --> 00:20:20,980
让我建议这张图片看起来有点像这样 

426
00:20:20,980 --> 00:20:23,340
再一次 这在逻辑上是完全相同的 

427
00:20:23,340 --> 00:20:25,197
但这只是它的图画表现 

428
00:20:25,197 --> 00:20:26,280
第一个问题是什么？

429
00:20:26,280 --> 00:20:30,900
好的 如果x小于y 那么我们就沿着真箭头走 

430
00:20:30,900 --> 00:20:33,840
我们说引用 不引用的x不等于y 

431
00:20:33,840 --> 00:20:35,280
然后我们停下来 

432
00:20:35,280 --> 00:20:37,623
但如果x不小于y呢？

433
00:20:37,623 --> 00:20:38,790
如果它大于y呢？

434
00:20:38,790 --> 00:20:40,800
如果分别是二和一呢？

435
00:20:40,800 --> 00:20:44,590
那么 第一个问题 x小于y的答案是假的 

436
00:20:44,590 --> 00:20:45,480
所以我们就来这里 

437
00:20:45,480 --> 00:20:48,720
我们问第二个问题 因为OR 

438
00:20:48,720 --> 00:20:51,060
那就是问x是不是大于y？

439
00:20:51,060 --> 00:20:55,830
如果是这样的话 注意这一点 我们可以重复使用这张图片的一些相同部分 

440
00:20:55,830 --> 00:20:58,260
就说x不等于y 

441
00:20:58,260 --> 00:21:01,020
我们不需要不必要地增加箭头和广告框 

442
00:21:01,020 --> 00:21:06,480
我们可以重复使用代码行 图片的一部分 就像我们拥有代码行一样 

443
00:21:06,480 --> 00:21:07,620
然后我们停下来 

444
00:21:07,620 --> 00:21:09,780
最后 我们有以下几点 

445
00:21:09,780 --> 00:21:12,300
如果我们知道x不小于y 我们就知道

446
00:21:12,300 --> 00:21:16,080
即x不大于y 则一定是x等于y的情况 

447
00:21:16,080 --> 00:21:18,900
我们不需要问第三个问题 另一个钻石 

448
00:21:18,900 --> 00:21:24,000
我们可以立即打印同样多的内容 然后也可以说停止 

449
00:21:24,000 --> 00:21:25,710
那么 我在这里能做什么呢？

450
00:21:25,710 --> 00:21:28,560
我打赌我可以稍微改进一下这段代码 

451
00:21:28,560 --> 00:21:31,440
如果我们真的想挑剔 我会

452
00:21:31,440 --> 00:21:34,800
辩称这现在真的只是一个微小的改进 

453
00:21:34,800 --> 00:21:37,410
但这是一个值得深思的好习惯 

454
00:21:37,410 --> 00:21:38,760
我的代码还能更好吗？

455
00:21:38,760 --> 00:21:41,100
我的代码可以更简单吗？

456
00:21:41,100 --> 00:21:43,740
我可以进一步改进这个代码吗？

457
00:21:43,740 --> 00:21:47,160
这很微妙 但我能改进一下设计吗？

458
00:21:47,160 --> 00:21:48,960
我能少问几个问题吗？

459
00:21:48,960 --> 00:21:52,460
可以这么说 我可以把它拧紧吗？

460
00:21:52,460 --> 00:21:54,280
人们是怎么想的？

461
00:21:54,280 --> 00:21:58,060
演讲者3：你可以问x等于y吗？

462
00:21:58,060 --> 00:22:03,625
如果你打印的x等于y 否则x不等于y 

463
00:22:03,625 --> 00:22:04,500
大卫·马兰：太好了 

464
00:22:04,500 --> 00:22:07,560
回想一下我们之前在可用列表中看到的另一个符号 

465
00:22:07,560 --> 00:22:10,680
我们不仅可以检查小于、大于或等于 

466
00:22:10,680 --> 00:22:13,410
我们可以从字面上问这个问题 它不等于吗？

467
00:22:13,410 --> 00:22:17,400
为什么我们要浪费时间去问它是小于还是大于？

468
00:22:17,400 --> 00:22:21,100
嗯 如果你关心的是它是不是不平等 我认为我们可以做到这一点 

469
00:22:21,100 --> 00:22:24,610
让我们只问一个我们真正关心的简单问题 

470
00:22:24,610 --> 00:22:25,950
所以让我回到这里 

471
00:22:25,950 --> 00:22:29,580
我只想说 不是这两个问题 让我们把OR去掉 

472
00:22:29,580 --> 00:22:33,840
这么说吧 如果x不等于y 那么

473
00:22:33,840 --> 00:22:36,510
并且打印x不等于y 

474
00:22:36,510 --> 00:22:39,190
而且 我认为这也会起到完全相同的作用 

475
00:22:39,190 --> 00:22:41,980
但现在的情况看起来有点不同 

476
00:22:41,980 --> 00:22:44,190
请注意 这是我们之前的流程图 

477
00:22:44,190 --> 00:22:45,947
这代表了同样的逻辑 

478
00:22:45,947 --> 00:22:47,280
这其中有一点复杂 

479
00:22:47,280 --> 00:22:48,690
你必须左转 你必须右转 

480
00:22:48,690 --> 00:22:50,732
基于对这两个问题的回答 

481
00:22:50,732 --> 00:22:53,820
如果我们现在考虑到这个版本的程序是什么样子的 

482
00:22:53,820 --> 00:22:56,820
它甚至更简单 也许是我们见过的最简单的一个 

483
00:22:56,820 --> 00:23:00,330
当我们开始节目时 我们只问一个 而且只有一个问题 

484
00:23:00,330 --> 00:23:02,040
X不等于y吗？

485
00:23:02,040 --> 00:23:06,930
如果是这样的话 我们继续打印x不等于y 

486
00:23:06,930 --> 00:23:10,350
如果答案为假 那么 当然 它必须等于y 

487
00:23:10,350 --> 00:23:12,040
因此 我们转而这么说 

488
00:23:12,040 --> 00:23:14,070
如果我们真的想要的话 我们可以把它颠倒过来 

489
00:23:14,070 --> 00:23:17,080
如果我回到我的代码 如果 无论出于什么原因 

490
00:23:17,080 --> 00:23:20,730
你只是更喜欢从平等或不平等的角度来思考 

491
00:23:20,730 --> 00:23:25,270
与不平等或不平等相反 这真的取决于你 

492
00:23:25,270 --> 00:23:27,900
我们可以把它改成相等 

493
00:23:27,900 --> 00:23:32,020
但我将不得不将我的打印语句更改为相反的顺序 

494
00:23:32,020 --> 00:23:34,890
所以现在让我继续 把这两个颠倒过来 

495
00:23:34,890 --> 00:23:38,950
先移动第二个 然后再移动第一个 

496
00:23:38,950 --> 00:23:42,240
所以现在 当我执行这段代码时 我仍然只问了一个问题 

497
00:23:42,240 --> 00:23:44,550
所以它仍然一样好 一样简洁 

498
00:23:44,550 --> 00:23:47,070
但现在这张图不是这样的 

499
00:23:47,070 --> 00:23:50,310
会把不等变成相等 

500
00:23:50,310 --> 00:23:54,400
我们只需要确保相应地打印出正确的内容 

501
00:23:54,400 --> 00:23:57,990
在这里也是如此 就像代码变得更紧凑一样 

502
00:23:57,990 --> 00:24:00,330
更紧凑 字符越来越少 

503
00:24:00,330 --> 00:24:05,460
这些图表也是如此 这些流程图捕捉到了相对简化的

504
00:24:05,460 --> 00:24:08,040
这些节目中的每一个也是如此 

505
00:24:08,040 --> 00:24:11,610
让我继续下去 在这里停下来看看是否有任何问题 现在 关于

506
00:24:11,610 --> 00:24:13,140
这些版本的代码 

507
00:24:16,530 --> 00:24:19,150
演讲者4：是的 我有几个问题 

508
00:24:19,150 --> 00:24:22,380
如果不使用缩进怎么办？

509
00:24:22,380 --> 00:24:25,600
David Malan：如果不使用缩进 您的程序将无法运行 

510
00:24:25,600 --> 00:24:28,080
所以 与很多不同的是 

511
00:24:28,080 --> 00:24:32,100
语言的一部分 因为它强制缩进要求 

512
00:24:32,100 --> 00:24:34,080
你们中一些已经编程多年的人

513
00:24:34,080 --> 00:24:37,800
可能不一定是正确缩进代码的最佳习惯 

514
00:24:37,800 --> 00:24:40,170
可以说 Python的一个特性是

515
00:24:40,170 --> 00:24:44,850
它会让你缩进你的代码 否则它就不会正常工作 

516
00:24:44,850 --> 00:24:47,460
我想 你还有其他问题吗？

517
00:24:47,460 --> 00:24:50,820
演讲者4：是的 有必要做结肠吗？

518
00:24:50,820 --> 00:24:52,530
大卫·马兰：结肠是必要的吗？

519
00:24:52,530 --> 00:24:55,150
是的 冒号也是必要的 

520
00:24:55,150 --> 00:24:57,960
因此 使用Python时 您所看到的就是您在这里获得的内容 

521
00:24:57,960 --> 00:25:01,020
事实上 它需要缩进 冒号是必要的 

522
00:25:01,020 --> 00:25:05,670
按照约定 Python不像C、C++和Java那样使用

523
00:25:05,670 --> 00:25:07,410
花括号表示块的含义 

524
00:25:07,410 --> 00:25:10,680
相反 它确实依赖于这种缩进 

525
00:25:10,680 --> 00:25:14,490
好吧 让我建议我们在这里引入另一个关键字 

526
00:25:14,490 --> 00:25:17,310
看看我们如何结合更多的想法 

527
00:25:17,310 --> 00:25:20,490
这将是字面上的单词 和 一个连词 

528
00:25:20,490 --> 00:25:24,690
或者两个 或者更多的问题

529
00:25:24,690 --> 00:25:28,650
让我在这里提议 我们来探索这种逻辑

530
00:25:28,650 --> 00:25:32,400
通过另一个程序 在VS代码中 我现在将继续

531
00:25:32,400 --> 00:25:35,760
创建一个新的程序 比如说 叫grade.py 

532
00:25:35,760 --> 00:25:38,160
让我们考虑一下学生应该得到什么分数 

533
00:25:38,160 --> 00:25:40,950
根据他们在考试中的分数 或者测试 或者测验 

534
00:25:40,950 --> 00:25:42,900
或者其他类似的任务

535
00:25:42,900 --> 00:25:46,513
我将继续运行grade.py的代码 给自己一个新文件 

536
00:25:46,513 --> 00:25:49,680
我将继续 从用户的分数开始 

537
00:25:49,680 --> 00:25:51,700
做作业或考试之类的

538
00:25:51,700 --> 00:25:55,200
我会把它存储在一个变量score中 等于收益

539
00:25:55,200 --> 00:25:58,320
int函数的值 该函数将转换用户的

540
00:25:58,320 --> 00:26:00,610
输入是在提示输入该分数时 

541
00:26:00,610 --> 00:26:04,650
所以 用户应该给我一个数字 比如0 或者1 

542
00:26:04,650 --> 00:26:09,090
或者两个 或者更高 比如97 98 99 100 

543
00:26:09,090 --> 00:26:13,330
假设测试或评估满分为100个百分点 

544
00:26:13,330 --> 00:26:17,220
那么 我该如何给学生的分数打分呢？

545
00:26:17,220 --> 00:26:19,710
在美国 

546
00:26:19,710 --> 00:26:22,500
如果你得了90到100分 那就是A

547
00:26:22,500 --> 00:26:29,160
如果在80到89之间 就是B 如果是70和79 就是C 

548
00:26:29,160 --> 00:26:32,558
以此类推 一直到F 应该是E 

549
00:26:32,558 --> 00:26:34,350
但我们会看到有一点跳跃 

550
00:26:34,350 --> 00:26:35,572
我该怎么表达呢？

551
00:26:35,572 --> 00:26:36,780
我可以用条件句 

552
00:26:36,780 --> 00:26:39,750
我可以问几个问题然后打印出学生的成绩

553
00:26:39,750 --> 00:26:40,600
相应地

554
00:26:40,600 --> 00:26:44,040
让我这样表达 如果学生的分数是

555
00:26:44,040 --> 00:26:47,820
大于或等于90 学生的分数是

556
00:26:47,820 --> 00:26:51,750
小于或等于100 所以它在这个范围内 我们继续

557
00:26:51,750 --> 00:26:55,980
并打印出他们的成绩是A因为他们是90年代的 

558
00:26:55,980 --> 00:26:58,080
以上等级范围 

559
00:26:58,080 --> 00:27:02,580
如果分数大于或等于80 

560
00:27:02,580 --> 00:27:07,980
比方说 分数小于或等于89 但这里我有一些选择 

561
00:27:07,980 --> 00:27:11,050
从逻辑上讲 我实际上可以用许多方式来表达自己 

562
00:27:11,050 --> 00:27:12,800
也许只是为了更干净一点 我是

563
00:27:12,800 --> 00:27:15,060
可以说一个分数低于90分 

564
00:27:15,060 --> 00:27:18,300
所以我使用小于 而不是小于或等于 

565
00:27:18,300 --> 00:27:21,690
所以我要确保他们在这些年级之间的界限是正确的 

566
00:27:21,690 --> 00:27:26,460
然后 如果是80度 我会给学生打个B 

567
00:27:26,460 --> 00:27:31,770
如果ELIF分数大于或等于70 且分数小于80 

568
00:27:31,770 --> 00:27:34,851
我要给他们打个C 

569
00:27:34,851 --> 00:27:40,380
如果得分大于或等于60 且得分小于70 

570
00:27:40,380 --> 00:27:43,080
我要给他打个D 这是

571
00:27:43,080 --> 00:27:46,380
这是有点反常的 至少在这里的一些学校 其他

572
00:27:46,380 --> 00:27:51,060
我要继续 给他们F 所以我们完全跳过E 

573
00:27:51,060 --> 00:27:53,760
我们要给这个分数打个F 

574
00:27:53,760 --> 00:27:55,080
这就是最重要的问题 

575
00:27:55,080 --> 00:27:58,020
我认为 从逻辑上讲 我的理解是正确的 

576
00:27:58,020 --> 00:28:00,360
至少从我在哪里长大的学校来看 

577
00:28:00,360 --> 00:28:03,950
这样它就会给出A、B、C或D 

578
00:28:03,950 --> 00:28:06,512
否则 它会假设你得了F 

579
00:28:06,512 --> 00:28:08,220
好的 让我们在这里只试几个 

580
00:28:08,220 --> 00:28:10,260
让我们运行grade.py的Python 

581
00:28:10,260 --> 00:28:13,650
我的分数是 让我们开始强势 100分 

582
00:28:13,650 --> 00:28:17,040
我得了A 下一次没考好 可能是95分--

583
00:28:17,040 --> 00:28:21,270
仍然是A 开始进一步下滑 所以我下一次得了89分 

584
00:28:21,270 --> 00:28:25,320
现在 比方说 A B 假设我这一周真的很糟糕 

585
00:28:25,320 --> 00:28:27,030
现在它是71 

586
00:28:27,030 --> 00:28:31,830
现在是C 或者我根本没有提交 那就是F 

587
00:28:31,830 --> 00:28:32,940
因此 它似乎奏效了 

588
00:28:32,940 --> 00:28:35,070
这并不是一个真正详尽的测试 但至少

589
00:28:35,070 --> 00:28:38,810
根据那里的一些样本 我的代码似乎可以像我预期的那样工作 

590
00:28:38,810 --> 00:28:40,560
但让我们看看我们是否能收紧这一点 

591
00:28:40,560 --> 00:28:41,220
这不是错的 

592
00:28:41,220 --> 00:28:42,070
这是正确的 

593
00:28:42,070 --> 00:28:44,070
事实上 根据我自己的说明书 

594
00:28:44,070 --> 00:28:45,510
我敢说这个代码是正确的 

595
00:28:45,510 --> 00:28:46,710
但我们能收紧它吗？

596
00:28:46,710 --> 00:28:50,500
无论是现在还是将来 我们都能降低错误发生的可能性吗？

597
00:28:50,500 --> 00:28:52,230
我们能增加它的可读性吗？

598
00:28:52,230 --> 00:28:54,030
我们能提高它的效率吗？

599
00:28:54,030 --> 00:28:57,690
我们能让计算机回答更少的问题吗？

600
00:28:57,690 --> 00:28:59,375
还能得到同样的结果吗？

601
00:28:59,375 --> 00:29:00,750
好吧 让我们看看我们能做些什么 

602
00:29:00,750 --> 00:29:03,690
让我来改变一下 即使只是为了证明我们可以

603
00:29:03,690 --> 00:29:05,760
以不同的方式使用这些符号 

604
00:29:05,760 --> 00:29:10,200
我可以说 就像我做过的那样 如果分数大于或等于90 

605
00:29:10,200 --> 00:29:12,570
但我实际上可以做到这一点 我可以把它翻过来 

606
00:29:12,570 --> 00:29:14,800
不是说大于或等于 

607
00:29:14,800 --> 00:29:19,060
让我们假设90是小于或等于分数 

608
00:29:19,060 --> 00:29:23,980
在这里 假设80小于或等于分数 

609
00:29:23,980 --> 00:29:28,180
而在这里 70是小于或等于分数 

610
00:29:28,180 --> 00:29:31,390
最后 60是小于或等于分数 

611
00:29:31,390 --> 00:29:33,370
所以从逻辑上讲 这是一回事 

612
00:29:33,370 --> 00:29:36,460
我只是在交换东西 就像你在纸铅笔上做的那样

613
00:29:36,460 --> 00:29:37,670
如果你真的想的话 

614
00:29:37,670 --> 00:29:39,200
但现在请注意这个把戏 

615
00:29:39,200 --> 00:29:42,460
这是不可能的 对于那些用C或C++编程的人来说 

616
00:29:42,460 --> 00:29:44,320
或Java或其他语言 

617
00:29:44,320 --> 00:29:48,760
请注意 我在这里可以做的实际上是合并这些范围 

618
00:29:48,760 --> 00:29:52,000
注意 我在问两个问题 两个布尔表达式 

619
00:29:52,000 --> 00:29:57,250
90是小于或等于分数 而分数是小于或等于100？

620
00:29:57,250 --> 00:30:01,150
嗯 Python允许您像这样嵌套这些东西 

621
00:30:01,150 --> 00:30:02,680
用链子把它们锁在一起 

622
00:30:02,680 --> 00:30:06,070
就像你在现实世界里用纸笔写的一样 

623
00:30:06,070 --> 00:30:09,732
你可以用Python语言进行编码 这样做会更干净一些 

624
00:30:09,732 --> 00:30:11,440
它正在收紧代码 

625
00:30:11,440 --> 00:30:12,550
击键次数更少 

626
00:30:12,550 --> 00:30:13,660
打字更快 

627
00:30:13,660 --> 00:30:15,530
向前看 它更容易阅读 

628
00:30:15,530 --> 00:30:18,140
因此 这也可以说是更好的 

629
00:30:18,140 --> 00:30:19,450
这是一个进步 

630
00:30:19,450 --> 00:30:21,422
在这种情况下 它在很大程度上是美学的 

631
00:30:21,422 --> 00:30:23,380
它仍然在问同样数量的问题 

632
00:30:23,380 --> 00:30:26,950
但它更简洁地做到了这一点 

633
00:30:26,950 --> 00:30:29,500
那接下来我还能在这里做些什么呢？

634
00:30:29,500 --> 00:30:30,730
好吧 你知道吗？

635
00:30:30,730 --> 00:30:32,920
每次我决定成绩的时候 我都不会

636
00:30:32,920 --> 00:30:34,940
我想我得问两个问题 

637
00:30:34,940 --> 00:30:38,290
我不需要问 它是大于90 小于100吗？

638
00:30:38,290 --> 00:30:40,840
是大于80 小于90吗？

639
00:30:40,840 --> 00:30:45,070
如果我重新思考我的逻辑 我可能会做得更好 

640
00:30:45,070 --> 00:30:48,920
让我建议我们进一步简化这一点 然后就这样做 

641
00:30:48,920 --> 00:30:53,260
如果我们知道 目前的输入值将在0到100之间 

642
00:30:53,260 --> 00:30:54,730
我们可以做一些假设 

643
00:30:54,730 --> 00:30:58,870
我们可以这样说 如果分数大于或等于90 

644
00:30:58,870 --> 00:31:04,150
嗯 学生得了A 如果分数大于或等于80 

645
00:31:04,150 --> 00:31:08,110
学生得到B 如果分数大于或等于70 

646
00:31:08,110 --> 00:31:13,930
他们得到一个C 如果分数大于或等于60 

647
00:31:13,930 --> 00:31:19,940
他们得了D 否则他们得了F 我都干了些什么？

648
00:31:19,940 --> 00:31:23,200
好吧 与其每次都问两个问题 

649
00:31:23,200 --> 00:31:26,320
检查该范围的下界和上界 

650
00:31:26,320 --> 00:31:31,030
我在这里问分数是否大于90是更聪明一点的 

651
00:31:31,030 --> 00:31:33,430
嗯 他们显然得到了A或更好的成绩 

652
00:31:33,430 --> 00:31:36,070
如果你的分数大于80 那么 你要么

653
00:31:36,070 --> 00:31:40,750
如果它真的很强劲 就应该得到A 如果它略高于80 就应该得到B 

654
00:31:40,750 --> 00:31:44,680
但根据埃利夫的逻辑 我们已经检查过

655
00:31:44,680 --> 00:31:46,450
学生的分数是否大于90分？

656
00:31:46,450 --> 00:31:50,020
如果不是 那么我们要问的问题是 它是不是大于80？

657
00:31:50,020 --> 00:31:54,220
所以你隐含地知道它在80到89之间 

658
00:31:54,220 --> 00:31:58,780
否则你知道它在70到79的范围内 否则它在下一个范围内

659
00:31:58,780 --> 00:31:59,350
放下 

660
00:31:59,350 --> 00:32:02,950
所以这是一个很小的优化 允许我们问更少的问题 

661
00:32:02,950 --> 00:32:05,980
但同样 它使代码更具可读性 可以说 

662
00:32:05,980 --> 00:32:09,580
当然 更简洁 然后 希望 更容易维护

663
00:32:09,580 --> 00:32:10,600
从长远来看 

664
00:32:10,600 --> 00:32:15,890
那么 关于这些类型的变化 有任何问题吗 

665
00:32:15,890 --> 00:32:20,200
我们代码中的这种类型的逻辑呢？

666
00:32:20,200 --> 00:32:22,120
演讲者4：如果我们根本不用埃利夫怎么办？

667
00:32:22,120 --> 00:32:25,345
如果我们把代码写在If里呢？

668
00:32:25,345 --> 00:32:27,220
大卫·马兰：是的 这是个好问题 

669
00:32:27,220 --> 00:32:31,360
因为它实际上会在这里产生意想不到的影响 

670
00:32:31,360 --> 00:32:33,340
让我暂时去掉F 然后

671
00:32:33,340 --> 00:32:36,460
把重点放在A到D 如果我们回到哪里

672
00:32:36,460 --> 00:32:39,190
我们今天的故事从条件句开始 说如果 

673
00:32:39,190 --> 00:32:45,070
如果 现在我们在这里巧妙地使用更宽泛的笔画

674
00:32:45,070 --> 00:32:47,680
并且不使用上限和下限范围

675
00:32:47,680 --> 00:32:51,010
将会带来不利的影响 

676
00:32:51,010 --> 00:32:53,320
让我继续运行grade.py的Python 

677
00:32:53,320 --> 00:32:56,560
假设我的分数是95分 

678
00:32:56,560 --> 00:32:58,120
我太激动了 

679
00:32:58,120 --> 00:33:00,520
我想要A 但不是 

680
00:33:00,520 --> 00:33:06,040
我只得到了一个A 一个B 一个C和一个D 所以从逻辑上讲 这是坏的东西 

681
00:33:06,040 --> 00:33:09,220
因为如果你不让这些条件相互排斥 

682
00:33:09,220 --> 00:33:13,540
这些问题中的每一个都会被问到 并因此得到回答 

683
00:33:13,540 --> 00:33:16,720
即使你的分数在90分以上 它也是

684
00:33:16,720 --> 00:33:20,140
还有 从逻辑上讲 80以上 70以上 60以上 

685
00:33:20,140 --> 00:33:23,580
如果我把它留在那里 我也会以F的成绩不及格 

686
00:33:23,580 --> 00:33:24,920
真是个好问题 

687
00:33:24,920 --> 00:33:28,690
这里还有其他关于这种逻辑形式的问题吗？

688
00:33:28,690 --> 00:33:30,940
演讲者5：还有没有更好的清理方法

689
00:33:30,940 --> 00:33:33,130
即使只是这句简单的话 就像我们以前说的那样 

690
00:33:33,130 --> 00:33:36,280
你之前和埃利夫那辆车的那辆？

691
00:33:36,280 --> 00:33:40,270
大卫·马兰：我喜欢你对进一步简化事情的热情 

692
00:33:40,270 --> 00:33:45,010
我要冒险一试 说这已经是最好的了 

693
00:33:45,010 --> 00:33:48,070
至少只使用条件语句 

694
00:33:48,070 --> 00:33:52,390
如果我走神了 我可以想出一个稍微聪明一点的方法

695
00:33:52,390 --> 00:33:54,490
要做到这一点 也许可以用一种叫做循环的东西 

696
00:33:54,490 --> 00:33:55,902
或另一个编程构造 

697
00:33:55,902 --> 00:33:57,610
我们的词汇表中还没有这个词 

698
00:33:57,610 --> 00:33:59,610
但是的 绝对有其他方法可以做到这一点 

699
00:33:59,610 --> 00:34:01,780
但我认为 如果我们想限制自己 还不能

700
00:34:01,780 --> 00:34:07,120
就像If and or Else Elif and and 诸如此类的词 

701
00:34:07,120 --> 00:34:10,810
好吧 让我建议我们现在开始使用另一种方法

702
00:34:10,810 --> 00:34:12,800
它使用了另一个符号 到目前为止 

703
00:34:12,800 --> 00:34:14,409
我们还没有真正有机会使用 

704
00:34:14,409 --> 00:34:18,580
让我提议我们实施一项我们称之为平价的计划 

705
00:34:18,580 --> 00:34:22,460
在数学中 奇偶性可以指一个数字是偶数还是奇数 

706
00:34:22,460 --> 00:34:24,530
这是一个很有趣的问题 

707
00:34:24,530 --> 00:34:26,863
事实证明 它在其他应用中也很有用 

708
00:34:26,863 --> 00:34:29,770
同样 只要问一个给定的数字是偶数还是奇数 

709
00:34:29,770 --> 00:34:31,300
也许是用户输入的？

710
00:34:31,300 --> 00:34:33,670
让我继续写一个新的程序

711
00:34:33,670 --> 00:34:38,800
在我的终端中 通过代码parity.py称为parity.py 

712
00:34:38,800 --> 00:34:41,560
让我提议我们利用这次机会

713
00:34:41,560 --> 00:34:45,190
为了介绍最后一个算术符号 

714
00:34:45,190 --> 00:34:48,800
至少大部分我们熟悉的 加法 减法 

715
00:34:48,800 --> 00:34:49,900
乘法 除法 

716
00:34:49,900 --> 00:34:53,317
但这张名单以前也有过 这是最后一张 百分号 

717
00:34:53,317 --> 00:34:55,150
在这种情况下 这并不意味着百分比 

718
00:34:55,150 --> 00:34:57,850
在使用Python语言编程时用作运算符 

719
00:34:57,850 --> 00:35:01,000
相反 它代表了所谓的模运算符 

720
00:35:01,000 --> 00:35:02,260
用于模算术 

721
00:35:02,260 --> 00:35:05,710
或者 至少在我们的例子中 我们将使用它来计算余数 当

722
00:35:05,710 --> 00:35:07,930
用一个数字除以另一个数字 

723
00:35:07,930 --> 00:35:09,140
我这么说是什么意思？

724
00:35:09,140 --> 00:35:12,070
嗯 如果你取一个1除以3的数字 

725
00:35:12,070 --> 00:35:14,840
三不能干净利落地合为一 

726
00:35:14,840 --> 00:35:16,690
所以你还有剩余的一个 

727
00:35:16,690 --> 00:35:20,140
二除以三得余数为二 

728
00:35:20,140 --> 00:35:24,550
三除以三的余数为零 因为它整除 

729
00:35:24,550 --> 00:35:30,088
四除以三的余数是一 因为你可以把它除以一 

730
00:35:30,088 --> 00:35:32,380
但这就只剩下一个了 所以它还有一个余数 

731
00:35:32,380 --> 00:35:35,692
最后 大概是5除以3

732
00:35:35,692 --> 00:35:37,150
当然 余数是两个 

733
00:35:37,150 --> 00:35:39,700
所以这就是我们所说的剩余部分 还有多少剩余

734
00:35:39,700 --> 00:35:41,830
在用一个数字除以另一个数字之后 

735
00:35:41,830 --> 00:35:46,180
那么 如果我现在回到我的代码 并考虑如何实现

736
00:35:46,180 --> 00:35:49,150
问题是这个数字是偶数还是奇数？

737
00:35:49,150 --> 00:35:51,520
让我们考虑一下如何实现这一点 

738
00:35:51,520 --> 00:35:53,885
因为可能不一定很明显我们是如何

739
00:35:53,885 --> 00:35:55,510
可以使用这个额外的构建块 

740
00:35:55,510 --> 00:35:58,460
但从长远来看 这将是非常有用的 

741
00:35:58,460 --> 00:36:01,630
首先 让我们从用户那里获取一个名为x的变量中的数字 

742
00:36:01,630 --> 00:36:04,570
我要将其设置为等于到int的转换

743
00:36:04,570 --> 00:36:08,890
无论用户输入什么 在询问他们x是什么之后 用问号 

744
00:36:08,890 --> 00:36:10,840
我们以前已经做过很多次了 

745
00:36:10,840 --> 00:36:14,750
现在如何确定x是偶数还是奇数？

746
00:36:14,750 --> 00:36:19,270
好吧 结果是 如果我能接触到一个程序化操作员 告诉我

747
00:36:19,270 --> 00:36:21,742
剩下的 我想我能做到 

748
00:36:21,742 --> 00:36:23,200
事实上 让我问问这群人 

749
00:36:23,200 --> 00:36:25,480
这可能只是小学数学中的一部分 

750
00:36:25,480 --> 00:36:28,750
一个数字是偶数意味着什么？

751
00:36:28,750 --> 00:36:36,235
明确地说 像0 2 4 6 8 10 12 14 16 

752
00:36:36,235 --> 00:36:37,360
这些都是偶数 

753
00:36:37,360 --> 00:36:38,652
但这到底是什么意思呢？

754
00:36:38,652 --> 00:36:40,960
埃琳娜 如果我说的对的话？

755
00:36:40,960 --> 00:36:43,990
埃琳娜：能把它完全除以2的偶数 

756
00:36:43,990 --> 00:36:48,275
例如 2、4、6、8和10 以及--

757
00:36:48,275 --> 00:36:49,150
大卫·马兰：太好了 

758
00:36:49,150 --> 00:36:51,040
我们可以一整天 真的 

759
00:36:51,040 --> 00:36:53,332
因为这些偶数是无穷多的 

760
00:36:53,332 --> 00:36:56,260
但你用一个问题的形式来表达它很好

761
00:36:56,260 --> 00:36:58,240
这一点我们可以问得很清楚 

762
00:36:58,240 --> 00:37:01,360
这个数字会被2整除吗？

763
00:37:01,360 --> 00:37:05,460
也就是说 我们能不能把它除以2 没有余数 零的余数？

764
00:37:05,460 --> 00:37:09,430
这很好 因为如果我们有这个运算符 这个百分号 

765
00:37:09,430 --> 00:37:13,300
使我们能够回答 剩余的是什么 我们大概可以检查

766
00:37:13,300 --> 00:37:15,790
剩下的是零还是一？

767
00:37:15,790 --> 00:37:19,120
我们是什么都没有剩下 还是我们还有一件？

768
00:37:19,120 --> 00:37:20,080
好吧 让我们来问问这个问题 

769
00:37:20,080 --> 00:37:28,568
如果像埃琳娜建议的那样 x除以2的余数为零 那么让我们继续

770
00:37:28,568 --> 00:37:30,610
然后打印出一些类似引用的东西 甚至不引用 

771
00:37:30,610 --> 00:37:32,410
并对用户说出同样多的话 

772
00:37:32,410 --> 00:37:35,380
另外 我认为我们可以假设 如果一个数字不是偶数 

773
00:37:35,380 --> 00:37:38,660
这将是奇数 如果它确实是一个整数的话 

774
00:37:38,660 --> 00:37:41,590
所以我将继续打印引文 不引用奇数 

775
00:37:41,590 --> 00:37:45,100
接下来 让我们在我的提示符中运行parity.py的Python 

776
00:37:45,100 --> 00:37:45,760
X是什么？

777
00:37:45,760 --> 00:37:46,840
让我们从两个开始 

778
00:37:46,840 --> 00:37:48,220
事实上 两个人是偶数 

779
00:37:48,220 --> 00:37:49,390
让我们从四个开始 

780
00:37:49,390 --> 00:37:50,560
事实上 四个是偶数 

781
00:37:50,560 --> 00:37:53,750
让我们来看三个有趣的节目 

782
00:37:53,750 --> 00:37:54,838
三个现在是奇怪的了 

783
00:37:54,838 --> 00:37:57,880
我认为我们可以整天这样做 并希望能回来 真的 

784
00:37:57,880 --> 00:37:59,770
答案就是这样 

785
00:37:59,770 --> 00:38:02,180
但我们在这里还能做些什么呢？

786
00:38:02,180 --> 00:38:03,910
我们如何才能改进这一点呢？

787
00:38:03,910 --> 00:38:08,050
好吧 回想一下 我们有能力发明自己的功能 

788
00:38:08,050 --> 00:38:10,270
为了便于讨论 请允许我提议 

789
00:38:10,270 --> 00:38:12,145
我们最终会发现它是

790
00:38:12,145 --> 00:38:14,600
能够确定一个数字是偶数还是奇数很有用 

791
00:38:14,600 --> 00:38:17,080
因此 我们希望将该功能内置 

792
00:38:17,080 --> 00:38:20,230
我不认为Python有告诉我这一点的功能 

793
00:38:20,230 --> 00:38:23,240
但我可以用这样的代码来发明它 

794
00:38:23,240 --> 00:38:26,770
因此 让我在这里进入我的早期版本 

795
00:38:26,770 --> 00:38:29,810
让我提议我们这样做 

796
00:38:29,810 --> 00:38:32,680
让我继续编写一个main函数 

797
00:38:32,680 --> 00:38:36,130
我将重新养成定义一个主函数来表示

798
00:38:36,130 --> 00:38:37,457
我节目的主要部分 

799
00:38:37,457 --> 00:38:39,040
我要做我以前做过的事 

800
00:38:39,040 --> 00:38:41,710
我将从用户的输入中获取一个整数 

801
00:38:41,710 --> 00:38:44,680
问他们什么是x 问号 

802
00:38:44,680 --> 00:38:46,420
然后我要问这个问题 

803
00:38:46,420 --> 00:38:48,667
目前 我将天真地假设

804
00:38:48,667 --> 00:38:50,500
该函数已经存在 但这是

805
00:38:50,500 --> 00:38:52,390
一个有用的解决问题的技巧 

806
00:38:52,390 --> 00:38:55,270
即使我还不知道我要做什么 

807
00:38:55,270 --> 00:38:58,750
我将如何发明一个函数来确定一个数字是否为偶数 

808
00:38:58,750 --> 00:39:01,780
我只是假设有一个函数叫“偶数”

809
00:39:01,780 --> 00:39:04,240
我要把它叫做 盲目地 像这样 

810
00:39:04,240 --> 00:39:11,470
如果是偶数 则传入x 然后打印引号 取消引号 

811
00:39:11,470 --> 00:39:17,650
因此 如果这个名为“is Even”的神奇函数返回TRUE 作为其返回值

812
00:39:17,650 --> 00:39:19,960
我要把它打印出来 它是平的 

813
00:39:19,960 --> 00:39:23,710
否则 我会认为 当然 这很奇怪 

814
00:39:23,710 --> 00:39:27,625
这个程序的一个问题是 即使我在这里调用Main 

815
00:39:27,625 --> 00:39:30,010
那就是甚至根本不存在 

816
00:39:30,010 --> 00:39:32,620
如果我现在运行这个程序 它就会崩溃 

817
00:39:32,620 --> 00:39:33,530
但那也没关系 

818
00:39:33,530 --> 00:39:35,990
回想一下 我有能力发明我自己的功能 

819
00:39:35,990 --> 00:39:39,970
让我用def定义一个名为“is Even”的函数 

820
00:39:39,970 --> 00:39:42,760
我想让这个函数接受一个参数 

821
00:39:42,760 --> 00:39:45,550
我称它为n 一般而言 只是一个数字 

822
00:39:45,550 --> 00:39:46,690
我可以称之为x 

823
00:39:46,690 --> 00:39:49,640
但我再说一次 我不想把自己搞糊涂 哪个x是哪个 

824
00:39:49,640 --> 00:39:52,100
所以我会给它一个不同的名字 这很好 

825
00:39:52,100 --> 00:39:54,700
我就叫它 更一般地说 n代表数字 

826
00:39:54,700 --> 00:39:56,590
然后我要做这个 

827
00:39:56,590 --> 00:40:03,490
我要说 如果N%2等于0 就像以前一样 那么 

828
00:40:03,490 --> 00:40:06,520
这就是魔力 你 程序员 

829
00:40:06,520 --> 00:40:10,660
实际上可以返回所谓的布尔值 

830
00:40:10,660 --> 00:40:16,430
我们已经在Python中看到 它有搅拌器或字符串、整数或整数 

831
00:40:16,430 --> 00:40:19,000
浮点数或浮点值 所有这些

832
00:40:19,000 --> 00:40:21,520
在Python中是不同类型的数据 

833
00:40:21,520 --> 00:40:26,210
对于布尔值 Python还有第四种数据类型 称为bool 

834
00:40:26,210 --> 00:40:29,470
尽管这只是我们清单上的补充 但关于布尔斯的好事情是

835
00:40:29,470 --> 00:40:32,890
它们只能是真的或假的 

836
00:40:32,890 --> 00:40:36,280
整型可以是任意数量的无限个可能值 

837
00:40:36,280 --> 00:40:39,040
布尔值只能为真或假 

838
00:40:39,040 --> 00:40:43,460
如果你自己写 它必须是大写的T和大写的F 

839
00:40:43,460 --> 00:40:46,030
所以如果我现在回到我的代码 我认为

840
00:40:46,030 --> 00:40:49,480
这正是我想要在这里归还的 

841
00:40:49,480 --> 00:40:53,560
那么 如果n%2等于零 也就是说 

842
00:40:53,560 --> 00:40:58,270
如果n除以2的余数为0 那么 我认为它是偶数 

843
00:40:58,270 --> 00:40:59,750
致埃琳娜你的定义 

844
00:40:59,750 --> 00:41:05,380
所以让我们返回真 大写T 否则 如果它没有零的余数 

845
00:41:05,380 --> 00:41:08,440
我非常确定 从数学上讲 它的余数一定是1 

846
00:41:08,440 --> 00:41:09,400
但这无关紧要 

847
00:41:09,400 --> 00:41:13,210
我知道这不是平均的 所以我将返回FALSE 

848
00:41:13,210 --> 00:41:18,610
我们返回FALSE 而不是大写F 现在我们已经定义了两个main

849
00:41:18,610 --> 00:41:23,350
而且是平分的 我在底部调用Main 我想我得到了正确的结果 

850
00:41:23,350 --> 00:41:25,960
Parity.py的Python 回车 

851
00:41:25,960 --> 00:41:26,650
X是什么？

852
00:41:26,650 --> 00:41:28,780
让我们尝试一些简单的东西 比如两个 

853
00:41:28,780 --> 00:41:29,890
而且扯平了 

854
00:41:29,890 --> 00:41:30,850
我们再来一次吧 

855
00:41:30,850 --> 00:41:31,420
X是什么？

856
00:41:31,420 --> 00:41:32,560
四个怎么样？

857
00:41:32,560 --> 00:41:33,100
不相上下 

858
00:41:33,100 --> 00:41:34,480
再问一次 x是什么？

859
00:41:34,480 --> 00:41:35,740
三个怎么样？

860
00:41:35,740 --> 00:41:36,910
这很奇怪 

861
00:41:36,910 --> 00:41:38,140
现在 我在这里做了什么？

862
00:41:38,140 --> 00:41:42,700
我刚刚指出 如果我想创建我自己的名为“is”的函数

863
00:41:42,700 --> 00:41:44,410
甚至 “这为我回答了这个问题 

864
00:41:44,410 --> 00:41:47,350
我现在可以在这个程序中使用 也许将来的程序中也可以使用

865
00:41:47,350 --> 00:41:51,190
我写的 我现在有了一个没有人给我的功能 

866
00:41:51,190 --> 00:41:53,290
我给了我自己 我可以使用和再利用 

867
00:41:53,290 --> 00:41:55,580
我甚至可以 也许 与其他人分享它 

868
00:41:55,580 --> 00:41:59,560
我现在在第三行使用这个函数 只是为了做个决定 

869
00:41:59,560 --> 00:42:01,360
我在上面用的是条件句 

870
00:42:01,360 --> 00:42:05,140
我的布尔表达式 对或错 

871
00:42:05,140 --> 00:42:08,800
不会是明确的东西 比如x小于y 

872
00:42:08,800 --> 00:42:11,020
或者y大于x 或类似的 

873
00:42:11,020 --> 00:42:13,180
这将是一个函数调用 

874
00:42:13,180 --> 00:42:15,790
我使用一个函数作为我的布尔表达式 

875
00:42:15,790 --> 00:42:18,160
但没关系 因为我知道 因为这是我写的 

876
00:42:18,160 --> 00:42:23,580
函数“is Even”返回TRUE或返回FALSE 

877
00:42:23,580 --> 00:42:26,750
这就是我在有条件的情况下做出决定所需要的

878
00:42:26,750 --> 00:42:29,810
印刷偶数印刷或奇数印刷

879
00:42:29,810 --> 00:42:33,110
所以让我在这里暂停一下 看看现在是否有什么问题是关于我是如何

880
00:42:33,110 --> 00:42:36,875
Implemented“is Even” 使用这个bool 

881
00:42:36,875 --> 00:42:38,000
演讲者6：你好 大卫 

882
00:42:38,000 --> 00:42:41,120
首先 感谢你们今天这堂精彩的课

883
00:42:41,120 --> 00:42:43,340
在昨天和今天之前 先生 

884
00:42:43,340 --> 00:42:47,720
我只有一个问题 基于Java的背景 

885
00:42:47,720 --> 00:42:50,810
在那里 当我们用来传递论点的时候 

886
00:42:50,810 --> 00:42:53,940
我们还可以传递变量的地址 

887
00:42:53,940 --> 00:42:57,120
那么 在Python中有没有类似的概念呢？

888
00:42:57,120 --> 00:42:58,370
大卫·马兰：简单地说 没有 

889
00:42:58,370 --> 00:43:02,300
那些不熟悉Java或其他语言、C或C++的人 

890
00:43:02,300 --> 00:43:06,230
通常有几种方法可以通过不同的机制来传递值 

891
00:43:06,230 --> 00:43:07,700
或不允许您更改它们 

892
00:43:07,700 --> 00:43:08,897
在Python中 答案是否定的 

893
00:43:08,897 --> 00:43:11,480
事实上 我们将要看到的一切都是一个物体 

894
00:43:11,480 --> 00:43:13,890
但更多的是在这条线上 

895
00:43:13,890 --> 00:43:17,960
让我们再来问一个关于这些无厘头和这些的问题 怎么样

896
00:43:17,960 --> 00:43:19,700
“是平分 ”

897
00:43:19,700 --> 00:43:23,720
演讲者7：我有一个关于定义函数的问题 

898
00:43:23,720 --> 00:43:24,680
如果可以的话 

899
00:43:24,680 --> 00:43:25,430
大卫·马兰：当然 

900
00:43:25,430 --> 00:43:29,030
演讲者7：所以如果你在你的代码中定义了一个 就像你编造的那样 

901
00:43:29,030 --> 00:43:33,230
你可以像我们命名点条那样使用点运算符吗 

902
00:43:33,230 --> 00:43:34,295
然后像那样使用它？

903
00:43:34,295 --> 00:43:35,420
大卫·马兰：问得好 

904
00:43:35,420 --> 00:43:37,880
如果你已经创建了你自己的函数 你能

905
00:43:37,880 --> 00:43:42,350
使用其他函数 如点条、点标题或点大写 

906
00:43:42,350 --> 00:43:44,210
我们过去见过的吗？

907
00:43:44,210 --> 00:43:46,580
你可以把它们用在弦上 

908
00:43:46,580 --> 00:43:49,110
这些函数带有字符串 

909
00:43:49,110 --> 00:43:51,980
你不一定要在你自己的函数中使用它们 

910
00:43:51,980 --> 00:43:56,030
除非您的函数为您给出的例子返回一个字符串 

911
00:43:56,030 --> 00:43:57,350
我要退回一笔钱 

912
00:43:57,350 --> 00:44:00,140
布尔人对左边或右边没有空白的概念 

913
00:44:00,140 --> 00:44:02,207
你不能调用条带 你不能调用大写 

914
00:44:02,207 --> 00:44:04,040
但是如果您要编写一个不同的函数

915
00:44:04,040 --> 00:44:06,020
这绝对会返回一个字符串 

916
00:44:06,020 --> 00:44:08,015
您也可以使用这些函数 

917
00:44:08,015 --> 00:44:10,640
好吧 如果可以的话 让我把我们的注意力转向这个例子

918
00:44:10,640 --> 00:44:13,220
这里 考虑一下 就像我们现在经常做的那样 

919
00:44:13,220 --> 00:44:15,920
我们能改进这段代码的设计吗？

920
00:44:15,920 --> 00:44:18,290
我能把这个特别的节目做得更好吗？

921
00:44:18,290 --> 00:44:19,340
我也能做到 

922
00:44:19,340 --> 00:44:20,630
这里有几种方法 

923
00:44:20,630 --> 00:44:24,320
我将向你们展示一些东西 现在通常被称为毕达德式的东西 

924
00:44:24,320 --> 00:44:26,840
在巨蟒的世界里 实际上有一个艺术术语 

925
00:44:26,840 --> 00:44:31,468
如果只是你在Python语言中做事情的方式 那么它就是Python式的 

926
00:44:31,468 --> 00:44:33,260
也就是说 我们已经看到了

927
00:44:33,260 --> 00:44:35,480
有这么多不同的方法来解决某些问题 

928
00:44:35,480 --> 00:44:38,000
而在Python程序员社区中 

929
00:44:38,000 --> 00:44:41,990
有一些方式往往比其他方式更能让人微笑 

930
00:44:41,990 --> 00:44:45,560
它们往往与可能只有巨蟒才有的功能有关 

931
00:44:45,560 --> 00:44:46,785
但不是其他语言 

932
00:44:46,785 --> 00:44:49,910
这里有一些你可能在Java等语言中看不到的语法 

933
00:44:49,910 --> 00:44:52,470
或者C 或者C++ 如果你以前编程过的话 

934
00:44:52,470 --> 00:44:55,700
如果你以前从来没有编程过 这也将是新的 

935
00:44:55,700 --> 00:45:02,420
不是问这样的问题 如果不是用四行 在Python语言中 

936
00:45:02,420 --> 00:45:07,520
如果你愿意 你实际上可以把它压缩成一条更优雅的线条 

937
00:45:07,520 --> 00:45:12,320
不是询问n除以2是否有零的余数 

938
00:45:12,320 --> 00:45:15,390
返回True 否则返回False 

939
00:45:15,390 --> 00:45:23,150
让我删除所有这些内容 如果n除以2 则返回TRUE

940
00:45:23,150 --> 00:45:27,660
的余数为零 否则返回FALSE 

941
00:45:27,660 --> 00:45:30,140
现在 那些有过编程经验的人

942
00:45:30,140 --> 00:45:31,940
可能真的觉得这很酷 

943
00:45:31,940 --> 00:45:35,960
你可以将四行浓缩为一行 这是完全相同的想法 

944
00:45:35,960 --> 00:45:39,260
而之所以如此受欢迎 其中一个原因就是它确实

945
00:45:39,260 --> 00:45:41,270
读起来很像英语 

946
00:45:41,270 --> 00:45:44,660
它不像大多数英语或大多数人类语言那样用户友好 

947
00:45:44,660 --> 00:45:48,470
但请注意 现在 这句话确实说出了你的意思 

948
00:45:48,470 --> 00:45:55,190
如果n除以2的余数为零 则返回TRUE 否则返回FALSE 

949
00:45:55,190 --> 00:45:58,820
从逻辑上讲 这与你可能用英语说的话非常接近 

950
00:45:58,820 --> 00:46:02,060
无论是关于偶数和奇数 还是其他任何东西 

951
00:46:02,060 --> 00:46:04,280
因此 该程序将以完全相同的方式工作 

952
00:46:04,280 --> 00:46:06,650
Parity.py的Python 让我输入两个 

953
00:46:06,650 --> 00:46:07,520
还是扯平了 

954
00:46:07,520 --> 00:46:08,600
让我输入三个字 

955
00:46:08,600 --> 00:46:09,830
这仍然很奇怪 

956
00:46:09,830 --> 00:46:12,180
但我可以进一步完善这一点 

957
00:46:12,180 --> 00:46:15,260
再说一次 这与不仅仅是编写正确代码的想法一致 

958
00:46:15,260 --> 00:46:19,820
但是编写越来越好的代码 但仍然保持它的可读性 

959
00:46:19,820 --> 00:46:22,730
我可以做得比这更好 

960
00:46:22,730 --> 00:46:25,760
请注意 这里的值是我的布尔表达式 

961
00:46:25,760 --> 00:46:28,640
它的计算结果为真或假 

962
00:46:28,640 --> 00:46:33,800
N除以余数为零的2吗？

963
00:46:33,800 --> 00:46:35,940
也就是说 根据定义 这是一个布尔表达式 

964
00:46:35,940 --> 00:46:39,600
它有一个是/否的答案 一个正确/错误的答案 

965
00:46:39,600 --> 00:46:45,290
如果你的布尔表达式本身有一个正确或错误的答案 

966
00:46:45,290 --> 00:46:48,740
你一开始为什么要问这个问题？

967
00:46:48,740 --> 00:46:50,270
为什么要问如果呢？

968
00:46:50,270 --> 00:46:51,770
为什么要说别的呢？

969
00:46:51,770 --> 00:46:57,140
只需返回您自己的布尔表达式的值 

970
00:46:57,140 --> 00:47:01,670
也许是最紧凑、最简洁、最易读的版本 

971
00:47:01,670 --> 00:47:05,450
这段代码的版本将删除这一整行 Pythonic

972
00:47:05,450 --> 00:47:12,530
虽然它是 只要返回n模2等于0 

973
00:47:12,530 --> 00:47:15,530
如果有帮助的话 让我暂时加上括号 

974
00:47:15,530 --> 00:47:18,910
因为括号中将要发生的事情将首先发生 

975
00:47:18,910 --> 00:47:24,160
N除以2的余数不是零就是零 

976
00:47:24,160 --> 00:47:25,990
如果是这样的话 答案是真的 

977
00:47:25,990 --> 00:47:28,130
如果不是这样 答案就是错误的 

978
00:47:28,130 --> 00:47:31,310
所以 如果你愿意的话 只要回答这个问题就行了 

979
00:47:31,310 --> 00:47:35,020
您不需要显式地使用if和Else对其进行包装 

980
00:47:35,020 --> 00:47:37,780
事实上 由于操作的顺序 

981
00:47:37,780 --> 00:47:39,620
你甚至不需要括号 

982
00:47:39,620 --> 00:47:45,370
因此 现在这可能是实现同样想法的最优雅的方式 

983
00:47:45,370 --> 00:47:46,540
现在 哪个更好？

984
00:47:46,540 --> 00:47:47,870
这真是太棒了 

985
00:47:47,870 --> 00:47:51,010
很难对此负责 因为它非常简洁 

986
00:47:51,010 --> 00:47:54,250
但这是完全正确的 而且同样正确 

987
00:47:54,250 --> 00:47:56,500
有一个如果 然后是另一个 

988
00:47:56,500 --> 00:47:59,260
即使它可能总共有四行 如果这有帮助的话

989
00:47:59,260 --> 00:48:01,480
您可以更清楚地考虑您的代码 这会有所帮助

990
00:48:01,480 --> 00:48:04,100
其他人也会对此进行推理 

991
00:48:04,100 --> 00:48:06,490
所以事实证明 您可以使用另一种语法

992
00:48:06,490 --> 00:48:08,920
可以用来实现条件的相同概念 

993
00:48:08,920 --> 00:48:12,910
根据某个布尔值的答案 您可以任选地做一些事情

994
00:48:12,910 --> 00:48:13,720
表情 

995
00:48:13,720 --> 00:48:17,020
在最新版本的Python中 您现在可以使用的关键字是

996
00:48:17,020 --> 00:48:18,610
被称为这个--匹配 

997
00:48:18,610 --> 00:48:21,850
Match是一种机制 如果你以前编程过 它在精神上是相似的

998
00:48:21,850 --> 00:48:24,340
在其他语言中称为Switch的东西 

999
00:48:24,340 --> 00:48:28,450
例如 让我在这里关闭parity.py 然后让我继续

1000
00:48:28,450 --> 00:48:31,750
并创建一个名为house.py的新文件 

1001
00:48:31,750 --> 00:48:33,700
在house.py中 我认为我们要做的是

1002
00:48:33,700 --> 00:48:37,243
要做的是尝试实现一个提示用户输入他们的名字的程序 

1003
00:48:37,243 --> 00:48:39,160
然后只输出他们所知道的房子

1004
00:48:39,160 --> 00:48:41,110
置身于哈利波特的世界 

1005
00:48:41,110 --> 00:48:43,040
举个例子 让我继续这样做 

1006
00:48:43,040 --> 00:48:46,450
让我给自己一个名为name的变量 将其设置为等于返回

1007
00:48:46,450 --> 00:48:47,860
输入函数的值 

1008
00:48:47,860 --> 00:48:50,890
我会说 你叫什么名字 问号 

1009
00:48:50,890 --> 00:48:52,750
然后 在那之后 我会用

1010
00:48:52,750 --> 00:48:58,210
一个传统的if Elif Else结构 用来决定此人所在的房子 

1011
00:48:58,210 --> 00:49:03,100
所以让我说 如果名字等于等于 比如说哈利 就像在哈利波特中一样 

1012
00:49:03,100 --> 00:49:06,280
让我们继续打印出哈利的房子 也就是格兰芬多

1013
00:49:06,280 --> 00:49:08,060
在哈利波特的世界里 

1014
00:49:08,060 --> 00:49:11,890
艾莉 如果名字是赫敏 那么

1015
00:49:11,890 --> 00:49:15,280
继续打印 也引用格兰芬多的话 

1016
00:49:15,280 --> 00:49:16,750
因为她也在同一栋房子里 

1017
00:49:16,750 --> 00:49:19,900
如果名字等于罗恩 我们开始吧

1018
00:49:19,900 --> 00:49:23,487
同样地 打印出格兰芬多的引语 不引用 

1019
00:49:23,487 --> 00:49:25,570
现在让我们把这个变得更有趣一些 

1020
00:49:25,570 --> 00:49:29,230
如果名字等于引号 那么德拉科呢？

1021
00:49:29,230 --> 00:49:32,110
德拉科·马尔福 在书中--让我们继续打印引文 

1022
00:49:32,110 --> 00:49:33,760
引用斯莱特林的话 

1023
00:49:33,760 --> 00:49:36,640
以防其他人的名字被输入 

1024
00:49:36,640 --> 00:49:39,550
现在 让我们假设我们不认识他们 

1025
00:49:39,550 --> 00:49:41,890
然后说 默认情况下 Else打印出引号 

1026
00:49:41,890 --> 00:49:44,530
引述谁 问号 只是为了传达

1027
00:49:44,530 --> 00:49:48,130
我们实际上对这个特定的名字没有硬编码的反应 

1028
00:49:48,130 --> 00:49:52,635
现在 让我继续运行它 将其作为house.py的Python运行 输入 

1029
00:49:52,635 --> 00:49:54,760
然后我会继续输入类似哈里的内容 

1030
00:49:54,760 --> 00:49:57,250
瞧 我们看到哈利确实在格兰芬多 

1031
00:49:57,250 --> 00:50:00,040
让我们再运行一次 在house.py中运行一次 

1032
00:50:00,040 --> 00:50:01,690
这次让我们输入Draco 

1033
00:50:01,690 --> 00:50:02,500
斯莱特林 

1034
00:50:02,500 --> 00:50:05,140
现在 让我们输入一个无法识别的名字 

1035
00:50:05,140 --> 00:50:07,540
让我们继续并重新运行house.py的Python 

1036
00:50:07,540 --> 00:50:10,000
让我们继续输入Padma 回车 

1037
00:50:10,000 --> 00:50:10,570
那是谁呢？

1038
00:50:10,570 --> 00:50:14,800
因为在这种情况下 我们实际上还没有硬编码ELIF条件 

1039
00:50:14,800 --> 00:50:17,290
帕德玛应该住在什么房子里 

1040
00:50:17,290 --> 00:50:19,750
事实证明 还有其他方法可以实现这一点 

1041
00:50:19,750 --> 00:50:22,030
的确 这里有一些冗余 那里有一些冗余

1042
00:50:22,030 --> 00:50:25,837
我们正在检查哈利、赫敏或罗恩是否都在格兰芬多 

1043
00:50:25,837 --> 00:50:28,420
我觉得我们至少可以把这段代码收紧一点 

1044
00:50:28,420 --> 00:50:30,260
使用我们已经见过的技术 

1045
00:50:30,260 --> 00:50:31,640
所以让我继续做这件事 

1046
00:50:31,640 --> 00:50:34,370
让我到这里来 做一些这样的事情 

1047
00:50:34,370 --> 00:50:37,120
让我们去掉这两块升降器 

1048
00:50:37,120 --> 00:50:38,890
暂时只留下哈里一家 

1049
00:50:38,890 --> 00:50:41,980
让我们再次使用“or”关键字 然后说或命名

1050
00:50:41,980 --> 00:50:47,080
等于引用 不引用赫敏 或名称等于引用 不引用罗恩 

1051
00:50:47,080 --> 00:50:51,370
因此 如果您愿意 将所有三个案例合并为一个案例

1052
00:50:51,370 --> 00:50:52,360
IF语句 

1053
00:50:52,360 --> 00:50:55,270
我们还有一个单独的埃利夫给德拉科 因为他不是 

1054
00:50:55,270 --> 00:50:56,230
事实上 在格兰芬多 

1055
00:50:56,230 --> 00:50:59,260
然后是最后一场要抓住其他人的比赛 

1056
00:50:59,260 --> 00:51:03,280
现在让我继续运行该程序的这个版本 即house.py的Python 

1057
00:51:03,280 --> 00:51:05,470
这次我要输入赫敏的名字 

1058
00:51:05,470 --> 00:51:07,030
她也仍然住在格兰芬多 

1059
00:51:07,030 --> 00:51:08,170
让我和罗恩试一试 

1060
00:51:08,170 --> 00:51:10,582
而且 这似乎仍然是正确的 

1061
00:51:10,582 --> 00:51:13,540
好吧 事实证明还有另一种完全可以

1062
00:51:13,540 --> 00:51:16,000
让您的代码少一点冗长 

1063
00:51:16,000 --> 00:51:18,790
您可以想象这段代码可能有多复杂

1064
00:51:18,790 --> 00:51:21,940
如果我们不只是哈利、赫敏和罗恩 而是一大群人

1065
00:51:21,940 --> 00:51:25,030
还有其他名字 为了格兰芬多 为了斯莱特林 为了所有人

1066
00:51:25,030 --> 00:51:26,650
霍格沃茨的其他房子 

1067
00:51:26,650 --> 00:51:29,737
所以你可以想象代码变得非常笨拙 很快就会变得非常笨拙 

1068
00:51:29,737 --> 00:51:31,570
好吧 事实证明另一种技术你可以

1069
00:51:31,570 --> 00:51:34,940
实际上 使用的是这个在精神上非常相似的关键字Match 

1070
00:51:34,940 --> 00:51:36,130
但语法是不同的 

1071
00:51:36,130 --> 00:51:39,580
它可以让你更紧凑地表达同样的想法 

1072
00:51:39,580 --> 00:51:41,620
因此 让我回到house.py 

1073
00:51:41,620 --> 00:51:45,700
让我提议我放弃目前的如果 埃利夫 否则的方法 

1074
00:51:45,700 --> 00:51:47,080
而是做这件事 

1075
00:51:47,080 --> 00:51:51,070
按字面意思使用关键字Match 然后键入变量的名称 

1076
00:51:51,070 --> 00:51:53,055
或价值 我们想要匹配 

1077
00:51:53,055 --> 00:51:55,180
然后我将继续 包括一个冒号 

1078
00:51:55,180 --> 00:51:58,240
然后在下面 我将包括 字面上的 

1079
00:51:58,240 --> 00:51:59,740
一个名为case的关键字 

1080
00:51:59,740 --> 00:52:02,290
我想要考虑的第一个案例是哈里 

1081
00:52:02,290 --> 00:52:05,690
我要把哈利放在引号里 因为它是一串或一串搅动 

1082
00:52:05,690 --> 00:52:08,350
我要在这行的末尾再加一个冒号 

1083
00:52:08,350 --> 00:52:11,020
在那个下面缩进 我要继续 现在 

1084
00:52:11,020 --> 00:52:13,990
打印出格兰芬多 当然 那是哈利的房子 

1085
00:52:13,990 --> 00:52:17,590
否则 我将有另一个引用的案例 引用赫敏 

1086
00:52:17,590 --> 00:52:20,350
同样地 我将在那个缩进的下面 

1087
00:52:20,350 --> 00:52:23,560
打印报价 取消引用格兰芬多 结束引用 

1088
00:52:23,560 --> 00:52:27,740
现在 我将为Ron提供另一个案例 同样用引号括起来 带有冒号 

1089
00:52:27,740 --> 00:52:29,950
现在打印引用 取消引用格兰芬多的话 

1090
00:52:29,950 --> 00:52:33,122
现在 我将有另一个案例 比如说 德拉科 

1091
00:52:33,122 --> 00:52:35,830
这一次变得更有趣了 因为德拉科 当然 

1092
00:52:35,830 --> 00:52:37,750
现在在斯莱特林 

1093
00:52:37,750 --> 00:52:40,830
然后 我将继续下去 暂时不谈这件事 

1094
00:52:40,830 --> 00:52:44,080
因此 让我继续保存此文件 然后返回到我的终端窗口 

1095
00:52:44,080 --> 00:52:46,930
运行house.py的Python 输入 

1096
00:52:46,930 --> 00:52:48,485
让我们来试试哈利吧 

1097
00:52:48,485 --> 00:52:50,110
他似乎还在格兰芬多 

1098
00:52:50,110 --> 00:52:52,810
让我们为Hermione再运行一次 进入 

1099
00:52:52,810 --> 00:52:53,560
格兰芬多 

1100
00:52:53,560 --> 00:52:56,653
让我们跳到Draco 然后输入Draco的名字 

1101
00:52:56,653 --> 00:52:57,820
他确实在斯莱特林 

1102
00:52:57,820 --> 00:53:00,790
现在让我们尝试另一个我们没有处理过的名字

1103
00:53:00,790 --> 00:53:03,310
一个案例 就像帕德玛一样 进入 

1104
00:53:03,310 --> 00:53:04,540
而我们只是被忽视了 

1105
00:53:04,540 --> 00:53:07,660
没有任何产出 因为没有对帕德玛的理由 

1106
00:53:07,660 --> 00:53:11,440
当然 现在我们可以返回并明确地为Padma添加一个 

1107
00:53:11,440 --> 00:53:14,440
但是 如果我们 类似于Else结构 

1108
00:53:14,440 --> 00:53:18,700
只是想要一个包罗万象的东西来处理任何名字没有明确指定的人？

1109
00:53:18,700 --> 00:53:22,150
那么 使用这个新的Match语句 就可以得出这样的语法：

1110
00:53:22,150 --> 00:53:24,730
是仍然有另一个案例 但然后使用

1111
00:53:24,730 --> 00:53:28,480
此单下划线字符 在Python中的其他上下文中使用 

1112
00:53:28,480 --> 00:53:32,440
但在这里 它的意思是说 无论什么案件还没有处理 

1113
00:53:32,440 --> 00:53:35,410
继续打印出来 就像我们以前做的那样 例如 

1114
00:53:35,410 --> 00:53:38,900
引用 不引用谁 在末尾加一个问号 

1115
00:53:38,900 --> 00:53:42,310
现在 让我们继续并重新运行house.py的这条巨蟒 

1116
00:53:42,310 --> 00:53:43,668
我再打一遍帕德玛的名字 

1117
00:53:43,668 --> 00:53:45,460
这一次 我想我们至少要

1118
00:53:45,460 --> 00:53:48,250
为了得到明确的回应 表明是谁 

1119
00:53:48,250 --> 00:53:50,920
而在此之前 我们没有类似的服务 

1120
00:53:50,920 --> 00:53:53,440
现在 我认为我们已经倒退了一点 

1121
00:53:53,440 --> 00:53:56,590
我们把哈里和赫敏从收紧到收紧 

1122
00:53:56,590 --> 00:53:59,650
和Ron都在同一个IF语句中的同一行 

1123
00:53:59,650 --> 00:54:02,780
但在这里 我们现在有三个案例语句 同样是针对这三个案例

1124
00:54:02,780 --> 00:54:03,280
这些都是 

1125
00:54:03,280 --> 00:54:05,950
好吧 我们也可以收紧这段代码 

1126
00:54:05,950 --> 00:54:08,240
但语法会有一点不同 

1127
00:54:08,240 --> 00:54:12,160
我将继续删除Hermione和Ron的这两个中间案例 

1128
00:54:12,160 --> 00:54:15,320
然后在这里 哈利的名字旁边 冒号之前 

1129
00:54:15,320 --> 00:54:18,070
我将继续使用单个竖线 然后

1130
00:54:18,070 --> 00:54:19,810
引用赫敏的原话 

1131
00:54:19,810 --> 00:54:23,110
然后再来一节 引用 取消引用罗恩的话 

1132
00:54:23,110 --> 00:54:26,140
这就是如何使用这个相对较新的匹配语句 

1133
00:54:26,140 --> 00:54:30,220
你可以说相当于哈利、赫敏或罗恩 

1134
00:54:30,220 --> 00:54:33,640
但是比使用if语句更简洁 

1135
00:54:33,640 --> 00:54:35,870
单独 就像我们之前实现的那样 

1136
00:54:35,870 --> 00:54:40,210
现在 使用house.py的Python运行该程序的最后一次运行 

1137
00:54:40,210 --> 00:54:42,490
让我们确保哈里还在格兰芬多 

1138
00:54:42,490 --> 00:54:44,920
我们要确保赫敏还在格兰芬多 

1139
00:54:44,920 --> 00:54:46,990
我们要确保罗恩还在格兰芬多 

1140
00:54:46,990 --> 00:54:48,880
事实上 这三个人都是 

1141
00:54:48,880 --> 00:54:51,553
现在 一如既往地使用Python和更一般的编程 

1142
00:54:51,553 --> 00:54:54,220
你会有不同的方法来解决这些问题 

1143
00:54:54,220 --> 00:54:56,290
这只是您工具箱中的另一个工具 

1144
00:54:56,290 --> 00:54:58,240
可以说 它已经收紧了关系 

1145
00:54:58,240 --> 00:55:00,190
可以说 它可能更具可读性

1146
00:55:00,190 --> 00:55:02,500
因为现在的句法比较少 

1147
00:55:02,500 --> 00:55:05,710
少一些等号和埃利夫的重复 

1148
00:55:05,710 --> 00:55:07,390
还有埃利夫 到处都是埃利夫 

1149
00:55:07,390 --> 00:55:11,740
但归根结底 这将是解决同样问题的同样正确的方法 

1150
00:55:11,740 --> 00:55:13,600
但事实证明 使用Match语句可以

1151
00:55:13,600 --> 00:55:16,360
也可以进行更强大的匹配形式 

1152
00:55:16,360 --> 00:55:20,500
在这里 我们只是用它来实现相同的想法 如果 埃利夫 

1153
00:55:20,500 --> 00:55:21,460
Else构造 

1154
00:55:21,460 --> 00:55:24,700
值得注意的是 如果你用其他语言编程 

1155
00:55:24,700 --> 00:55:26,200
这里的语法确实是正确的 

1156
00:55:26,200 --> 00:55:28,600
例如 您不需要BREAK语句 

1157
00:55:28,600 --> 00:55:29,950
就像从头到尾都在胡椒一样 

1158
00:55:29,950 --> 00:55:32,665
而且你不需要像默认这样的东西 或者一些明确的东西 

1159
00:55:32,665 --> 00:55:37,700
事实上 你只需在比赛结束时使用这条下划线作为你的总结点 

1160
00:55:37,700 --> 00:55:40,900
因此 只要添加一些新的关键字

1161
00:55:40,900 --> 00:55:45,340
在这里 就像If和Elif 还有其他 我们现在有能力

1162
00:55:45,340 --> 00:55:47,320
问一些关于价值观的问题 

1163
00:55:47,320 --> 00:55:50,140
我们有能力分析来自用户的输入 

1164
00:55:50,140 --> 00:55:52,090
并最终对此做出决定 

1165
00:55:52,090 --> 00:55:54,730
这些 那么 我们的条件句在哪里 

1166
00:55:54,730 --> 00:55:58,180
摆在我们面前的不仅是我们使用功能的能力 

1167
00:55:58,180 --> 00:56:00,380
和变量 还有这些条件句 

1168
00:56:00,380 --> 00:56:06,330
接下来 还有循环--现在、一次又一次做某事的能力 

