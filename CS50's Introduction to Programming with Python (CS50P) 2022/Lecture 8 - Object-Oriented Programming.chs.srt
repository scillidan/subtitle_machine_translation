1
00:00:00,000 --> 00:00:03,458
[古典音乐]

2
00:00:23,875 --> 00:00:26,583
大卫·J·马兰：好的 这是CS50的S介绍

3
00:00:26,583 --> 00:00:27,916
到使用Python语言编程 

4
00:00:27,916 --> 00:00:31,541
我的名字是David Malan 这是我们的面向对象编程周 

5
00:00:31,541 --> 00:00:32,791
或者OOP 

6
00:00:32,791 --> 00:00:34,750
事实证明 在编程的世界里 

7
00:00:34,750 --> 00:00:37,583
编程语言有不同的范例 

8
00:00:37,583 --> 00:00:40,208
有不同的方法来解决代码问题 

9
00:00:40,208 --> 00:00:42,000
一开始很难看到这一点

10
00:00:42,000 --> 00:00:43,916
如果你只学过一门语言 

11
00:00:43,916 --> 00:00:47,416
但随着时间的推移 如果你学习了除Python之外的其他语言 

12
00:00:47,416 --> 00:00:50,083
您将开始注意到某些模式和某些功能

13
00:00:50,083 --> 00:00:52,000
一些语言 而不是另一种语言 

14
00:00:52,000 --> 00:00:54,791
到目前为止 在Python的世界里 你和我

15
00:00:54,791 --> 00:00:58,541
在很大程度上是在编写本质上是程序性的代码 因此我们

16
00:00:58,541 --> 00:01:00,708
编写过程；我们正在编写函数；

17
00:01:00,708 --> 00:01:03,166
我们从头到尾都在做事情 

18
00:01:03,166 --> 00:01:05,458
一切都是循序渐进的 就像你会做的那样

19
00:01:05,458 --> 00:01:07,208
一般说来 对算法的期望 

20
00:01:07,208 --> 00:01:09,250
但在这一过程中 我们实际上涉足了

21
00:01:09,250 --> 00:01:14,083
在另一种称为使用Python的函数式编程的范例中 我们已经

22
00:01:14,083 --> 00:01:15,875
能够传递函数 

23
00:01:15,875 --> 00:01:18,666
几周前我们甚至有一个匿名功能 

24
00:01:18,666 --> 00:01:22,500
这是函数式编程语言特点的证据 

25
00:01:22,500 --> 00:01:24,708
尽管我们只是触及了它的皮毛 

26
00:01:24,708 --> 00:01:28,083
今天我们关注的是另一种模式 这个模式更加详细--

27
00:01:28,083 --> 00:01:30,166
即面向对象编程 

28
00:01:30,166 --> 00:01:32,958
现在 虽然你们中的一些人可能有过编程经验

29
00:01:32,958 --> 00:01:36,500
并且已经学习了像Java这样的语言 根据设计 这些语言基本上

30
00:01:36,500 --> 00:01:40,291
面向对象的 Python确实允许您具有一定的灵活性

31
00:01:40,291 --> 00:01:43,250
当谈到如何用代码解决问题时 

32
00:01:43,250 --> 00:01:46,458
但事实证明 面向对象编程

33
00:01:46,458 --> 00:01:49,000
是一个非常令人信服的问题解决方案

34
00:01:49,000 --> 00:01:52,666
当你的程序变得更长 更大 

35
00:01:52,666 --> 00:01:54,375
而且更复杂 

36
00:01:54,375 --> 00:01:56,333
因此 事实上 对于我们的目的 OOP将

37
00:01:56,333 --> 00:02:00,791
成为一个建立在过去许多教训基础上的问题的解决方案 

38
00:02:00,791 --> 00:02:02,458
所以让我们继续做这件事 

39
00:02:02,458 --> 00:02:05,833
让我们从非常程序化地编写程序开始

40
00:02:05,833 --> 00:02:07,625
在这里打开VS代码 

41
00:02:07,625 --> 00:02:10,875
我将继续创建一个名为Student.py的程序 

42
00:02:10,875 --> 00:02:14,083
在这个节目中 我想做一些相对简单的事情

43
00:02:14,083 --> 00:02:18,375
最初 就像我们几周前可能做的那样 我只是

44
00:02:18,375 --> 00:02:22,166
向用户询问他们的名字 也许是在《哈利波特》的上下文中

45
00:02:22,166 --> 00:02:26,291
宇宙 他们的房子 然后打印出那个学生来自哪里 

46
00:02:26,291 --> 00:02:30,166
让我们通过向它添加越来越多的功能来逐步增强这个程序

47
00:02:30,166 --> 00:02:33,875
看看我们是否会偶然发现一些问题 到目前为止 

48
00:02:33,875 --> 00:02:36,958
我们可能没有非常优雅、精心设计的解决方案来解决 

49
00:02:36,958 --> 00:02:40,250
但是如果我们明确地引入面向对象编程

50
00:02:40,250 --> 00:02:43,250
作为一种编程技术 我打赌我们可以清理我们的代码

51
00:02:43,250 --> 00:02:47,208
并为编写更复杂、更长的程序奠定了基础

52
00:02:47,208 --> 00:02:48,083
顺着路线走下去 

53
00:02:48,083 --> 00:02:51,791
因此 在Student.py中 让我继续做一个名称变量 

54
00:02:51,791 --> 00:02:54,250
将其设置为等于输入的返回值 

55
00:02:54,250 --> 00:02:57,041
只需提示用户输入他们的名字 如下所示 

56
00:02:57,041 --> 00:02:59,791
然后让我们继续对house变量执行相同的操作

57
00:02:59,791 --> 00:03:03,041
并提示用户输入他们的房子 如下所示 

58
00:03:03,041 --> 00:03:05,208
现在让我们做一些非常简单的事情 

59
00:03:05,208 --> 00:03:07,875
让我们继续打印一个f字符串

60
00:03:07,875 --> 00:03:11,291
上面写着房子里的名字 

61
00:03:11,291 --> 00:03:13,958
这样我就可以确认这些变量的内容

62
00:03:13,958 --> 00:03:15,000
确实如我所料 

63
00:03:15,000 --> 00:03:17,083
我不会执行任何错误检查或修剪

64
00:03:17,083 --> 00:03:18,333
或任何类似的东西 目前 

65
00:03:18,333 --> 00:03:21,416
我真的要把用户刚输入的内容吐出来 

66
00:03:21,416 --> 00:03:24,375
好的 让我继续运行PYTHON of Student.py 

67
00:03:24,375 --> 00:03:29,083
让我们使用我们的首选 就像《哈利·波特》中的《格兰芬多》 

68
00:03:29,083 --> 00:03:32,958
当我按回车键时 现在让我们看看我是否看到来自格兰芬多的哈里

69
00:03:32,958 --> 00:03:34,041
确实是这样 

70
00:03:34,041 --> 00:03:37,375
好的 我想我们现在有一个工作计划 但让我们

71
00:03:37,375 --> 00:03:40,541
现在介绍一下从零周开始学到的一些经验教训

72
00:03:40,541 --> 00:03:42,583
在那里我们开始编写自己的函数 

73
00:03:42,583 --> 00:03:46,250
不一定是因为它更正确地解决了问题--

74
00:03:46,250 --> 00:03:47,916
我敢说这是正确的 

75
00:03:47,916 --> 00:03:52,041
但它开始为我们提供我们可以扩展的构建块

76
00:03:52,041 --> 00:03:54,125
至于解决更复杂的程序 

77
00:03:54,125 --> 00:03:58,375
所以让我回到Student.py 让我们现在继续做这件事 

78
00:03:58,375 --> 00:04:01,875
让我们将我刚刚编写的整个逻辑放在我们的典型方法中

79
00:04:01,875 --> 00:04:05,458
名为main 让我缩进这三行 这样至少它们是

80
00:04:05,458 --> 00:04:07,333
现在结合成一个主要的方法 

81
00:04:07,333 --> 00:04:12,208
但是不是使用线路2上的输入与线路3上的输入 

82
00:04:12,208 --> 00:04:14,083
我们现在是不是应该假设 

83
00:04:14,083 --> 00:04:17,000
我们在世界上有一个名为get_name的函数 

84
00:04:17,000 --> 00:04:19,958
让我们继续并假设我们有另一个类似Get_house的函数

85
00:04:19,958 --> 00:04:21,708
世界上不需要参数的人 

86
00:04:21,708 --> 00:04:24,166
但他们的生活目标 在他们的名字里 

87
00:04:24,166 --> 00:04:28,458
将分别获得用户的名称和他们的用户的房子 

88
00:04:28,458 --> 00:04:32,083
然后我将打印出和之前完全相同的f字符串 

89
00:04:32,083 --> 00:04:34,333
当然 我现在需要实现这些功能 

90
00:04:34,333 --> 00:04:38,291
因此 让我在文件的下面定义一个名为GET_NAME的函数 

91
00:04:38,291 --> 00:04:41,375
这些括号里什么都没有 因为它不会接受参数 

92
00:04:41,375 --> 00:04:44,083
我将继续做一些类似于名称等于输入的操作

93
00:04:44,083 --> 00:04:48,750
(“name”) 就像以前一样 然后我将继续并返回name 

94
00:04:48,750 --> 00:04:52,000
所以这是一个超级简单的函数 但它是一个抽象的 

95
00:04:52,000 --> 00:04:55,458
我现在有一个名为get_name的函数 它的实现细节

96
00:04:55,458 --> 00:04:56,916
我再也不需要关心了 

97
00:04:56,916 --> 00:04:58,458
我只知道这个功能是存在的 

98
00:04:58,458 --> 00:05:00,250
事实上 我可以加强这一点 

99
00:05:00,250 --> 00:05:02,875
在第8行中并不真正需要名称变量

100
00:05:02,875 --> 00:05:05,875
如果我要立即在第9行返回相同名称的变量 

101
00:05:05,875 --> 00:05:07,833
所以让我把这个绷紧一点

102
00:05:07,833 --> 00:05:09,791
即使它不会改变功能

103
00:05:09,791 --> 00:05:15,750
并且只需立即返回此处INPUTS函数调用的返回值 

104
00:05:15,750 --> 00:05:18,916
现在让我们为Get_house做一些非常类似的事情 

105
00:05:18,916 --> 00:05:20,750
同样 这也不会有任何争论 

106
00:05:20,750 --> 00:05:22,666
我要继续并退回退款

107
00:05:22,666 --> 00:05:25,541
输入值 这一次提示用户选择他们的房子 

108
00:05:25,541 --> 00:05:27,250
我还需要最后一个细节 

109
00:05:27,250 --> 00:05:32,208
在最下面 让我们继续我们的习惯 如果此文件的名称

110
00:05:32,208 --> 00:05:35,750
等于 等于 引号 不引号 主键 然后让我们继续

111
00:05:35,750 --> 00:05:38,875
然后实际呼叫Main并回想一下我们已经准备好了

112
00:05:38,875 --> 00:05:42,458
所以 如果这最终成为一个模块的一部分 一个各种各样的库 

113
00:05:42,458 --> 00:05:44,791
我不会不小心盲目地给Main打电话 

114
00:05:44,791 --> 00:05:50,250
只有当我打算从该文件的命令行运行main时 我才会这样做 

115
00:05:50,250 --> 00:05:53,458
好的 如果我没有犯任何错误 让我继续

116
00:05:53,458 --> 00:05:57,416
然后 在我的终端窗口中 再次运行Student.py的Python 输入 

117
00:05:57,416 --> 00:05:59,250
让我们输入哈里 回车 

118
00:05:59,250 --> 00:06:01,541
让我们输入格兰芬多 回车 

119
00:06:01,541 --> 00:06:02,875
我们已经准备好了 

120
00:06:02,875 --> 00:06:05,583
来自格兰芬多的哈里似乎还在工作 

121
00:06:05,583 --> 00:06:09,416
所以我们并没有真正正确地解决这个问题 

122
00:06:09,416 --> 00:06:11,875
但我已经奠定了基础 也许现在就可以

123
00:06:11,875 --> 00:06:13,583
一些更有趣的事情 因为我已经

124
00:06:13,583 --> 00:06:16,875
把这些积木放在适当的位置 

125
00:06:16,875 --> 00:06:21,083
但让我提议 我们可以用一点不同的方式来做这件事 

126
00:06:21,083 --> 00:06:23,000
GET_NAME GET_HOUSE很好 

127
00:06:23,000 --> 00:06:26,416
但归根结底 我真的是想从用户那里得到一个学生 

128
00:06:26,416 --> 00:06:30,083
我要他们的名字和他们的房子 而不只是其中之一 

129
00:06:30,083 --> 00:06:32,833
所以也许它会更干净一点

130
00:06:32,833 --> 00:06:36,083
定义一个名为Get_Student的函数并让

131
00:06:36,083 --> 00:06:38,291
Get_Student为我们做所有这些工作 

132
00:06:38,291 --> 00:06:43,000
现在 理论上 get学生可以调用get_name 也可以调用get_house 

133
00:06:43,000 --> 00:06:44,750
但由于这些函数太短了 

134
00:06:44,750 --> 00:06:48,875
我想我可以只定义一个名为Get_Student的函数 

135
00:06:48,875 --> 00:06:50,666
同样 这也不需要任何论据 

136
00:06:50,666 --> 00:06:52,250
但它会做两件事 

137
00:06:52,250 --> 00:06:55,875
它将通过像以前一样提示他们输入 来获得学生的名字 

138
00:06:55,875 --> 00:06:57,625
它会夺走学生的房子 

139
00:06:57,625 --> 00:07:01,125
通过也像以前一样提示他们 

140
00:07:01,125 --> 00:07:02,416
现在 嗯 

141
00:07:02,416 --> 00:07:04,833
我想把学生还回去 但我觉得

142
00:07:04,833 --> 00:07:06,875
我可能把自己逼到了墙角

143
00:07:06,875 --> 00:07:10,125
因为我现在有两个变量--name和house 

144
00:07:10,125 --> 00:07:13,250
然而 到目前为止 我们基本上只退还了其中的一种 

145
00:07:13,250 --> 00:07:15,000
我们返回了一个值 

146
00:07:15,000 --> 00:07:17,500
所以有没有什么建议可以让我们

147
00:07:17,500 --> 00:07:22,375
解决我刚刚为自己创造的这个问题 借此我想返回 

148
00:07:22,375 --> 00:07:28,083
真的 我是个学生 但我现在有一个名字变量和一个房子变量 

149
00:07:28,083 --> 00:07:30,541
我至少想把这两件都退货 

150
00:07:30,541 --> 00:07:33,208
听众：我相信 我们可以归还一本词典 

151
00:07:33,208 --> 00:07:35,000
包括名字和房子 

152
00:07:35,000 --> 00:07:36,833
大卫·J·马兰：是的 所以我们绝对可以

153
00:07:36,833 --> 00:07:41,000
返回一个字典--Python中的Dict对象 其中可能有一个键是name；

154
00:07:41,000 --> 00:07:43,666
一把钥匙是房子 它的价值恰好是

155
00:07:43,666 --> 00:07:44,916
这些变量的值 

156
00:07:44,916 --> 00:07:46,791
所以我们完全可以这么做 

157
00:07:46,791 --> 00:07:49,375
我担心这可能会变得有点复杂 

158
00:07:49,375 --> 00:07:51,916
我想知道有没有更简单的方法来代替 

159
00:07:51,916 --> 00:07:55,000
还有其他本能吗--即使你不确定它会奏效吗？

160
00:07:55,000 --> 00:07:56,541
观众：名字和房子都要还吗？

161
00:07:56,541 --> 00:07:58,333
大卫·J·马兰：把名字和房子都还回来 

162
00:07:58,333 --> 00:07:59,416
我喜欢听你这么说 

163
00:07:59,416 --> 00:08:00,250
这听起来很简单 

164
00:08:00,250 --> 00:08:03,041
我不需要考虑字典会是什么样子的 

165
00:08:03,041 --> 00:08:05,750
事实上 这也是一种有效的方法 

166
00:08:05,750 --> 00:08:07,250
即使你以前没见过这个 

167
00:08:07,250 --> 00:08:11,625
事实证明 在Python中 您可以返回多个值 

168
00:08:11,625 --> 00:08:12,958
但这是一个善意的谎言 

169
00:08:12,958 --> 00:08:16,333
或者我们可以采用穆罕默德的方法 实际上归还一本词典

170
00:08:16,333 --> 00:08:17,833
并在其中放置多个钥匙 

171
00:08:17,833 --> 00:08:19,833
所以在这里 我们又有了另一个例子

172
00:08:19,833 --> 00:08:22,375
你如何至少用两种方式解决同样的问题 

173
00:08:22,375 --> 00:08:24,708
我敢说 我们即将看到更多 

174
00:08:24,708 --> 00:08:27,916
因此 解决这个问题的一种方法是

175
00:08:27,916 --> 00:08:32,916
如果想要返回多个值 可以这样做 

176
00:08:32,916 --> 00:08:37,666
我可以按字面意思返回 不只是名字 还可以加一个逗号

177
00:08:37,666 --> 00:08:39,250
也要把房子还回去 

178
00:08:39,250 --> 00:08:41,958
这不一定是您可以在其他语言中完成的操作

179
00:08:41,958 --> 00:08:44,166
如果您以前用过其他语言编程 

180
00:08:44,166 --> 00:08:45,416
这取决于语言 

181
00:08:45,416 --> 00:08:49,291
但看起来 多亏了这个逗号 也许我可以 实际上 

182
00:08:49,291 --> 00:08:51,916
返回[INAUDIBLE]建议的两个值 

183
00:08:51,916 --> 00:08:55,375
好 如果我用这种方式返回第10行的值 

184
00:08:55,375 --> 00:08:57,916
如何同时获得这两个值？

185
00:08:57,916 --> 00:08:59,208
好吧 有几种方法 

186
00:08:59,208 --> 00:09:01,833
让我继续我的主要任务 

187
00:09:01,833 --> 00:09:04,416
我知道 至少 我将不得不更改get_name

188
00:09:04,416 --> 00:09:05,958
找一间房子去找一名学生 

189
00:09:05,958 --> 00:09:09,041
但是我要把返回值存储在什么地方呢？

190
00:09:09,041 --> 00:09:11,500
我想我真的能做到 

191
00:09:11,500 --> 00:09:14,916
我们以前见过这种技术 你可以打开行李 

192
00:09:14,916 --> 00:09:17,541
可以说 一系列的价值正在回归 

193
00:09:17,541 --> 00:09:21,083
事实上 你可以认为这就是事实 名字,

194
00:09:21,083 --> 00:09:25,000
房子是我要返回的某种值序列--名字 房子 

195
00:09:25,000 --> 00:09:27,291
因此 如果我想打开这些文件并存储退货

196
00:09:27,291 --> 00:09:30,000
在两个独立变量中的值 我可以 事实上 

197
00:09:30,000 --> 00:09:34,208
使用赋值运算符左侧的逗号、等号、

198
00:09:34,208 --> 00:09:35,416
正是为了做到这一点 

199
00:09:35,416 --> 00:09:40,000
现在 为了清楚起见 我不需要在这里将这些变量称为name和house 

200
00:09:40,000 --> 00:09:43,500
我可以简化这个 在这里只用n 在这里用h 

201
00:09:43,500 --> 00:09:46,583
然后我可以只返回n和h 

202
00:09:46,583 --> 00:09:51,208
但我认为这对读者来说并不是很清楚到底发生了什么 

203
00:09:51,208 --> 00:09:52,958
所以我认为 在这种情况下 即使它是

204
00:09:52,958 --> 00:09:56,000
巧合的是 我在Get_Student中使用了相同的变量名

205
00:09:56,000 --> 00:09:59,875
和get_name 在Main中 对于像我这样的人来说 它更具可读性 

206
00:09:59,875 --> 00:10:01,541
所以我会让它保持原样 

207
00:10:01,541 --> 00:10:04,041
好吧 让我们来看看 现在 这个方法是否奏效 

208
00:10:04,041 --> 00:10:07,166
让我清空下面的屏幕 然后运行Student.py的Python 回车 

209
00:10:07,166 --> 00:10:08,375
让我们再输入一次哈里 

210
00:10:08,375 --> 00:10:11,041
让我们再次输入Gryffindor 回车 

211
00:10:11,041 --> 00:10:14,791
瞧 我们仍然看到哈里来自格兰芬多 

212
00:10:14,791 --> 00:10:16,958
但我们到底在这里做什么呢？

213
00:10:16,958 --> 00:10:19,666
我们返回这个值实际上是在做什么？

214
00:10:19,666 --> 00:10:24,333
事实证明 我们刚才所做的是使用元组 

215
00:10:24,333 --> 00:10:29,791
元组是Python中的另一种数据类型 它是值的集合--

216
00:10:29,791 --> 00:10:32,291
X y或x y z 

217
00:10:32,291 --> 00:10:36,750
从这个意义上说 它在精神上类似于列表 但它是一成不变的 

218
00:10:36,750 --> 00:10:37,666
它不是可变的 

219
00:10:37,666 --> 00:10:38,708
那么 这意味着什么呢？

220
00:10:38,708 --> 00:10:41,708
正如我们以前看到的 列表是Python中的一种数据结构

221
00:10:41,708 --> 00:10:43,458
您可以更改的值 

222
00:10:43,458 --> 00:10:47,250
您可以进入第一个位置的括号0 并在那里更改值 

223
00:10:47,250 --> 00:10:50,208
您可以转到括号1、括号2、括号3 然后实际更改

224
00:10:50,208 --> 00:10:51,458
列表中的值 

225
00:10:51,458 --> 00:10:54,791
但如果您不想更改变量的值

226
00:10:54,791 --> 00:10:57,750
你想要有效地返回多个值 

227
00:10:57,750 --> 00:10:59,541
您甚至不需要将其作为列表返回 

228
00:10:59,541 --> 00:11:03,416
您可以将其作为元组返回 只需使用逗号 

229
00:11:03,416 --> 00:11:07,000
事实证明 我们可以清楚地表明--这是一个善意的谎言 

230
00:11:07,000 --> 00:11:10,500
实际上 我并不是要回到价值观本身 

231
00:11:10,500 --> 00:11:13,416
每当您在第9行使用逗号时 

232
00:11:13,416 --> 00:11:17,500
您实际上返回了一个值 这是一个元组 

233
00:11:17,500 --> 00:11:20,291
现在 该元组内部有两个值 

234
00:11:20,291 --> 00:11:23,791
所以这在本质上类似于在这里返回一个列表和两个东西

235
00:11:23,791 --> 00:11:26,291
我要返回一个包含两个元素的元组 

236
00:11:26,291 --> 00:11:28,958
事实是我只用了逗号 没有用其他

237
00:11:28,958 --> 00:11:31,375
告诉Python我确实想返回一个元组 

238
00:11:31,375 --> 00:11:34,083
但是 我们可以使用更显式的语法 

239
00:11:34,083 --> 00:11:39,291
我实际上可以--更详细地--用显式的圆括号将值括起来

240
00:11:39,291 --> 00:11:42,458
为了让我和读者更清楚地了解这个元组

241
00:11:42,458 --> 00:11:44,083
这本身并不是两种价值 

242
00:11:44,083 --> 00:11:46,500
这是一个价值 里面有两个东西 

243
00:11:46,500 --> 00:11:48,458
而我实际上能做的也是--

244
00:11:48,458 --> 00:11:51,000
可以这么说 我不需要在这里解开这些东西 

245
00:11:51,000 --> 00:11:54,833
我可以在这里取个更贴切的名字 比如学生 

246
00:11:54,833 --> 00:11:58,375
我可以给值命名 或者说给变量命名

247
00:11:58,375 --> 00:12:01,333
其中我将get_student的返回值存储为 

248
00:12:01,333 --> 00:12:02,791
“学生 “

249
00:12:02,791 --> 00:12:05,166
所以也许这是一个更好的设计

250
00:12:05,166 --> 00:12:08,625
因为我在抽象学生是什么 

251
00:12:08,625 --> 00:12:11,666
它目前被实现为具有两个值的元组 

252
00:12:11,666 --> 00:12:15,875
但至少 现在我有了一个变量 叫做学生 

253
00:12:15,875 --> 00:12:17,375
但会有一个陷阱 

254
00:12:17,375 --> 00:12:21,583
在第3行 我仍然想打印出那个学生的名字和他们的房子 

255
00:12:21,583 --> 00:12:24,541
但是我没有名字变量了 我也没有房子了 

256
00:12:24,541 --> 00:12:28,625
我也没有字典 就像之前说的 所以我甚至不能

257
00:12:28,625 --> 00:12:31,833
按名字去拿钥匙

258
00:12:31,833 --> 00:12:35,166
但元组是什么--它在本质上与列表非常相似 

259
00:12:35,166 --> 00:12:37,000
但它确实是不可变的 

260
00:12:37,000 --> 00:12:39,791
我的意思是我仍然可以索引到它

261
00:12:39,791 --> 00:12:45,041
用数字表示学生[0]

262
00:12:45,041 --> 00:12:47,000
在元组的第一个位置 

263
00:12:47,000 --> 00:12:50,416
然后在这里 我可以说学生 而不是房子 

264
00:12:50,416 --> 00:12:54,291
student [1]将给出元组中的第二个位置 

265
00:12:54,291 --> 00:12:56,166
我先去清空终端窗口 

266
00:12:56,166 --> 00:12:58,083
再次运行student.py的Python 

267
00:12:58,083 --> 00:12:59,250
让我们输入哈里 

268
00:12:59,250 --> 00:13:04,500
让我们输入格兰芬多 回车 我们还有一些工作代码 

269
00:13:04,500 --> 00:13:07,208
让我在这里暂停一下 看看是否有

270
00:13:07,208 --> 00:13:11,500
关于返回元组的技术 

271
00:13:11,500 --> 00:13:14,750
并以这种方式索引它 

272
00:13:14,750 --> 00:13:17,125
观众：我想 什么是一个实际的用例 

273
00:13:17,125 --> 00:13:21,333
你会使用元组还是列表或者其他类似的东西？

274
00:13:21,333 --> 00:13:23,166
大卫·J·马兰：这是一个很好的问题 

275
00:13:23,166 --> 00:13:25,291
什么时候使用元组而不是列表？

276
00:13:25,291 --> 00:13:28,208
当你想进行防御性编程时 或者 一般来说 

277
00:13:28,208 --> 00:13:31,375
当你知道这个变量中的值不应该改变时 

278
00:13:31,375 --> 00:13:34,333
那么 为什么要使用允许它们被更改的数据类型呢？

279
00:13:34,333 --> 00:13:37,791
它只会招致错误 臭虫 要么

280
00:13:37,791 --> 00:13:40,666
由您或与您的代码交互的同事创建 

281
00:13:40,666 --> 00:13:44,083
因此 元组只是另一种您可以增加

282
00:13:44,083 --> 00:13:47,708
不让任何人 包括你自己 

283
00:13:47,708 --> 00:13:49,750
更改其中的内容 

284
00:13:49,750 --> 00:13:52,250
所以它只是您工具箱中的另一个工具 

285
00:13:52,250 --> 00:13:55,333
但是 让我们明确一下我所说的“不变”是什么意思 

286
00:13:55,333 --> 00:13:58,833
同样 我声称“不可变”意味着您不能更改该值 

287
00:13:58,833 --> 00:14:01,000
好吧 让我们继续试着这样做 

288
00:14:01,000 --> 00:14:03,750
让我继续按原样运行这个程序--

289
00:14:03,750 --> 00:14:05,291
Student.py的蟒蛇 

290
00:14:05,291 --> 00:14:09,416
例如 让我继续输入--

291
00:14:09,416 --> 00:14:11,375
帕德玛的名字呢？

292
00:14:11,375 --> 00:14:13,208
我要说的是 帕德玛

293
00:14:13,208 --> 00:14:14,916
是在格兰芬多 就像电影里一样 

294
00:14:14,916 --> 00:14:16,958
我们看到了--格兰芬多的帕德玛 

295
00:14:16,958 --> 00:14:20,791
但严格来说 我走进这个兔子洞是为了看哈利波特

296
00:14:20,791 --> 00:14:21,541
离得更近 

297
00:14:21,541 --> 00:14:25,000
严格来说 在书中 我相信帕德玛来自拉文克劳 

298
00:14:25,000 --> 00:14:27,083
因此 这实际上是一个错误或不一致

299
00:14:27,083 --> 00:14:28,750
在电影和书之间 

300
00:14:28,750 --> 00:14:31,625
让我们看看我们是否不能修复代码中的这种不一致 

301
00:14:31,625 --> 00:14:33,208
那我们来做这个怎么样？

302
00:14:33,208 --> 00:14:36,333
如果输入的学生姓名等于帕德玛 

303
00:14:36,333 --> 00:14:40,208
我们为什么不不管这房子是什么

304
00:14:40,208 --> 00:14:42,875
把它改成真正的格兰芬多 

305
00:14:42,875 --> 00:14:46,083
让我继续做 如果学生--

306
00:14:46,083 --> 00:14:49,708
现在 如果我想得到帕德玛的名字 我将不得不做学生[0] 

307
00:14:49,708 --> 00:14:52,625
我必须知道这个名字在这个元组中的位置 

308
00:14:52,625 --> 00:14:57,750
但是 如果该值等于Padma 那么让我们继续执行这条if语句

309
00:14:57,750 --> 00:14:58,666
并做出改变 

310
00:14:58,666 --> 00:15:02,208
让我们更改学生的[1]值 

311
00:15:02,208 --> 00:15:04,625
所以第二个值 如果我们是零索引--

312
00:15:04,625 --> 00:15:07,375
让我们把它变成哈利波特世界里的另一座房子

313
00:15:07,375 --> 00:15:08,916
叫拉文克劳 

314
00:15:08,916 --> 00:15:11,750
所以我只是在修复可能是用户的输入 

315
00:15:11,750 --> 00:15:14,166
他们看了这部电影 然后输入帕德玛·格兰芬多 

316
00:15:14,166 --> 00:15:17,333
但是 嗯 在书里 是拉文克劳的帕德玛 

317
00:15:17,333 --> 00:15:20,250
好了 让我继续下去 到我的终端窗口 

318
00:15:20,250 --> 00:15:24,041
清除我的终端 然后执行Student.py的Python 回车 

319
00:15:24,041 --> 00:15:27,000
我会像格兰芬多一样模仿哈里 只是为了证明

320
00:15:27,000 --> 00:15:29,750
这一点仍在发挥预期的作用 

321
00:15:29,750 --> 00:15:33,958
不过 让我再次清除屏幕 并在Padma上运行PYSTONT.PY 

322
00:15:33,958 --> 00:15:37,500
我也会把她放进格兰芬多 就像电影里的那样 然后按Enter键 

323
00:15:37,500 --> 00:15:40,916
现在我只在屏幕上看到一大堆错误 

324
00:15:40,916 --> 00:15:42,708
已经抛出了某种例外 

325
00:15:42,708 --> 00:15:45,166
事实上 确实发生了一个类型错误 

326
00:15:45,166 --> 00:15:48,750
我使用的数据类型中存在错误 错误是什么？

327
00:15:48,750 --> 00:15:53,041
嗯 “tuple”对象不支持项赋值 

328
00:15:53,041 --> 00:15:57,375
它有点神秘莫测--也就是说 它对用户并不是很友好 

329
00:15:57,375 --> 00:15:59,250
但如果你想一想这些话的意思 

330
00:15:59,250 --> 00:16:01,458
“tuple”对象不支持项分配 

331
00:16:01,458 --> 00:16:03,458
所以作业是从右到左复制的 

332
00:16:03,458 --> 00:16:05,208
因此 不知何故 这是无效的 

333
00:16:05,208 --> 00:16:10,250
这是元组的不变性的一个表现 

334
00:16:10,250 --> 00:16:14,208
您不能更改位置0或1或内部的任何内容 

335
00:16:14,208 --> 00:16:15,250
这是一个特点 

336
00:16:15,250 --> 00:16:17,250
这就是元组的设计 

337
00:16:17,250 --> 00:16:20,000
所以如果我想推翻这一点 我想我是

338
00:16:20,000 --> 00:16:23,125
我们将不得不使用我们以前使用过的不同类型的数据--

339
00:16:23,125 --> 00:16:24,750
也就是一份清单 这很好 

340
00:16:24,750 --> 00:16:28,416
如果您想让您自己和同事能够使用您的代码

341
00:16:28,416 --> 00:16:31,083
要更改该容器中的内容物 

342
00:16:31,083 --> 00:16:34,375
好的 我们可以继续使用返回不是元组

343
00:16:34,375 --> 00:16:37,541
明确的圆括号或没有圆括号 只有逗号 

344
00:16:37,541 --> 00:16:39,250
但我可以使用方括号 

345
00:16:39,250 --> 00:16:41,916
如果我在左边和右边用方括号 

346
00:16:41,916 --> 00:16:44,458
这确实是一份明确的清单 

347
00:16:44,458 --> 00:16:47,041
想法相同 但它是可变的 

348
00:16:47,041 --> 00:16:50,000
也就是说 您可以更改列表的内容 

349
00:16:50,000 --> 00:16:53,125
所以不做其他更改 只返回一个列表

350
00:16:53,125 --> 00:16:57,833
使用方括号 而不是使用圆括号或仅使用逗号的元组 

351
00:16:57,833 --> 00:17:01,041
现在让我继续运行PYTHON of Student.py Enter 

352
00:17:01,041 --> 00:17:04,000
让我再输入一次哈利和格兰芬多 

353
00:17:04,000 --> 00:17:05,458
这还在起作用 

354
00:17:05,458 --> 00:17:06,416
很高兴见到你 

355
00:17:06,416 --> 00:17:11,416
让我再运行一次 输入帕德玛和格兰芬多 就像电影里那样 

356
00:17:11,416 --> 00:17:15,333
但现在我们更正为拉文克劳的帕德玛

357
00:17:15,333 --> 00:17:17,958
就像书上写的那样

358
00:17:17,958 --> 00:17:22,541
关于元组和列表或者这个想法还有什么问题吗

359
00:17:22,541 --> 00:17:26,541
不变性与可变性的对比

360
00:17:26,541 --> 00:17:31,833
观众：我们可以在Python中使用嵌套元组吗 比如嵌套列表？

361
00:17:31,833 --> 00:17:32,958
大卫·J·马兰：当然 

362
00:17:32,958 --> 00:17:35,250
Python中不仅可以有嵌套列表 

363
00:17:35,250 --> 00:17:38,291
其中一个列表中的元素可以是另一个列表 

364
00:17:38,291 --> 00:17:41,500
这里有一些方括号 你可能会有一些其他的方括号

365
00:17:41,500 --> 00:17:42,041
里面

366
00:17:42,041 --> 00:17:44,833
你完全可以用一个元组做同样的事情 

367
00:17:44,833 --> 00:17:47,833
对于可以放入的值的类型没有限制 

368
00:17:47,833 --> 00:17:50,125
我们在这件事上还没有这样做的机会 

369
00:17:50,125 --> 00:17:54,041
我只是返回一个包含两个元素的简单元组 

370
00:17:54,041 --> 00:17:56,291
但是 是的 你绝对可以这样做 太 

371
00:17:56,291 --> 00:17:59,416
关于元组和列表的其他问题？

372
00:17:59,416 --> 00:18:03,208
观众：好的 举个例子 当我看到方括号时 

373
00:18:03,208 --> 00:18:05,250
主要用于名单？

374
00:18:05,250 --> 00:18:07,041
大卫·J·马兰：哦 一个很好的问题 

375
00:18:07,041 --> 00:18:07,875
算是吧

376
00:18:07,875 --> 00:18:12,250
所以当你创建一个像列表这样的值时 你要用方括号 

377
00:18:12,250 --> 00:18:14,041
这确实是一个视觉指示器

378
00:18:14,041 --> 00:18:16,458
这绝对是一份名单

379
00:18:16,458 --> 00:18:19,041
如果你看到的是圆括号 那是一个视觉指示器 

380
00:18:19,041 --> 00:18:21,708
当创建一个值时 它肯定是一个元组 

381
00:18:21,708 --> 00:18:26,416
然而 有点令人困惑的是 列表和元组都

382
00:18:26,416 --> 00:18:30,375
在访问它们的内容时使用方括号 

383
00:18:30,375 --> 00:18:34,000
当你在位置0或位置1索引它们时

384
00:18:34,000 --> 00:18:36,083
你总是用方括号 

385
00:18:36,083 --> 00:18:37,500
这就是区别 

386
00:18:37,500 --> 00:18:38,875
问得好

387
00:18:38,875 --> 00:18:42,916
如果可以的话 请允许我提议 我们用另一种方式解决这个问题 

388
00:18:42,916 --> 00:18:46,250
看看我们是在让事情变得更好还是更糟

389
00:18:46,250 --> 00:18:49,916
回想一下 字典或dict对象也存在于Python中 

390
00:18:49,916 --> 00:18:53,250
字典就是键和值的集合 

391
00:18:53,250 --> 00:18:55,458
尤其是字典的好处是

392
00:18:55,458 --> 00:18:57,083
就是它们有更好的语义 

393
00:18:57,083 --> 00:18:59,625
你不需要假设一个名字总是

394
00:18:59,625 --> 00:19:03,291
将位于位置0；房屋将始终位于位置1 

395
00:19:03,291 --> 00:19:06,916
这就是那种事情 特别是如果你有三个、四个或更多的价值观--

396
00:19:06,916 --> 00:19:10,000
最终 你或某人将会迷惑并忘记

397
00:19:10,000 --> 00:19:12,958
命令是什么 您将编写有错误的代码 

398
00:19:12,958 --> 00:19:15,333
所以词典的功能更强大一点

399
00:19:15,333 --> 00:19:19,000
因为您可以在语义上关联关键字、小描述

400
00:19:19,000 --> 00:19:20,041
有了这些价值观--

401
00:19:20,041 --> 00:19:22,541
分别是那些键和那些值 

402
00:19:22,541 --> 00:19:25,666
所以让我继续这样做 我们可以用几种不同的方式来做这件事 

403
00:19:25,666 --> 00:19:28,958
但让我建议我们在这里重点关注Get_Student 

404
00:19:28,958 --> 00:19:30,583
让我们继续做这件事 

405
00:19:30,583 --> 00:19:35,875
让我们继续 按原样删除Get_Student的实现 

406
00:19:35,875 --> 00:19:40,083
让我创建一个学生变量 并将其初始化为空词典 

407
00:19:40,083 --> 00:19:43,083
我只需要两个花括号就可以做到这一点 

408
00:19:43,083 --> 00:19:46,958
然后让我继续 在词典中设置两个键 

409
00:19:46,958 --> 00:19:49,708
在学生体内 将会有一个“名字” 

410
00:19:49,708 --> 00:19:53,625
键 它的值将是输入的返回值

411
00:19:53,625 --> 00:19:55,625
是当我提示用户输入他们的名字时 

412
00:19:55,625 --> 00:19:59,708
然后是同一本学生词典里的“房子”钥匙 

413
00:19:59,708 --> 00:20:02,750
将是用户键入的任何内容的返回值

414
00:20:02,750 --> 00:20:07,000
为他们的房子买单  最后 我要继续下去 把学生送回来 

415
00:20:07,000 --> 00:20:11,000
所以现在我还是要退回一样东西 

416
00:20:11,000 --> 00:20:15,291
但这一次 它是一个词典而不是一个元组 而不是一个列表 

417
00:20:15,291 --> 00:20:18,041
但这里面还是有两样东西 严格来说有四样东西

418
00:20:18,041 --> 00:20:19,708
如果你计算一下键和值 

419
00:20:19,708 --> 00:20:22,083
但是有两个键值对 

420
00:20:22,083 --> 00:20:24,625
现在 我这里的代码将不得不稍作更改 

421
00:20:24,625 --> 00:20:27,375
让我们简化这一点 例如 现在删除

422
00:20:27,375 --> 00:20:31,458
Padma IF声明只是为了关注手头正在发生的变化 

423
00:20:31,458 --> 00:20:34,000
现在让我继续 让2号线单独运行 

424
00:20:34,000 --> 00:20:37,708
我仍然会有一个学生变量 该变量被赋值为返回

425
00:20:37,708 --> 00:20:39,166
Get_Student的值 

426
00:20:39,166 --> 00:20:45,375
但我现在想要做的是实际访问其中的密钥

427
00:20:45,375 --> 00:20:49,083
字典--不是按元组和列表的数字索引--

428
00:20:49,083 --> 00:20:52,541
0和1 但通过密钥的方式 

429
00:20:52,541 --> 00:20:55,291
现在 正常情况下 我可能有这个习惯 因为我个人

430
00:20:55,291 --> 00:20:58,916
AM 使用双引号--引号 不引号 “名字”在里面

431
00:20:58,916 --> 00:21:02,166
引用 引述 “房子”在里面 

432
00:21:02,166 --> 00:21:05,833
但在我运行这段代码并向你们展示一个错误之前--

433
00:21:05,833 --> 00:21:08,750
看到屏幕上的错误 有谁想喊出来吗

434
00:21:08,750 --> 00:21:10,666
我在这里做错了什么？

435
00:21:10,666 --> 00:21:12,375
这只是一根f弦 

436
00:21:12,375 --> 00:21:16,708
我只想打印出名字键的值 房子的价值

437
00:21:16,708 --> 00:21:18,666
输入这本词典 

438
00:21:18,666 --> 00:21:21,083
观众：[听不见]

439
00:21:21,333 --> 00:21:23,625
大卫·J·马兰：你的音频对我们来说有点乱码 

440
00:21:23,625 --> 00:21:26,250
但我想我听到了双引号和单引号 

441
00:21:26,250 --> 00:21:29,708
所以我假设 确实 你已经准确地确定了问题所在 

442
00:21:29,708 --> 00:21:31,541
我现在只是要混淆一下Python 

443
00:21:31,541 --> 00:21:35,833
即使这是双引号内的f字符串 以f为前缀 

444
00:21:35,833 --> 00:21:39,000
我不能在我的双引号中使用双引号

445
00:21:39,000 --> 00:21:41,125
因为这可能会让Python感到困惑 

446
00:21:41,125 --> 00:21:44,375
如果我现在运行这个程序 那么Student.py的Python和点击

447
00:21:44,375 --> 00:21:46,166
回车 我得到一个语法错误 

448
00:21:46,166 --> 00:21:48,000
因此 该程序甚至没有完全运行 

449
00:21:48,000 --> 00:21:51,958
它只是无法理解 因为它被那些双引号搞糊涂了 

450
00:21:51,958 --> 00:21:54,041
所以这里最简单的解决办法就是

451
00:21:54,041 --> 00:21:58,250
不是用双引号而是用单引号将键引起来 

452
00:21:58,250 --> 00:22:02,041
或者相反 将外部的双引号改为单引号 

453
00:22:02,041 --> 00:22:03,583
然后在内部使用双引号 

454
00:22:03,583 --> 00:22:05,125
你只想保持一致 

455
00:22:05,125 --> 00:22:09,041
这是一个微妙的细节 但同样 这是特定于词典语法的 

456
00:22:09,041 --> 00:22:14,666
这并不是我们如何解决当前问题的根本 

457
00:22:14,666 --> 00:22:16,083
好吧 让我们来试试这个 

458
00:22:16,083 --> 00:22:18,416
现在让我继续运行Student.py的Python 

459
00:22:18,416 --> 00:22:19,833
让我们继续输入哈里 

460
00:22:19,833 --> 00:22:20,916
让我们输入格兰芬多 

461
00:22:20,916 --> 00:22:24,083
希望哈里能从格兰芬多回来 

462
00:22:24,083 --> 00:22:25,375
没有语法错误 

463
00:22:25,375 --> 00:22:26,250
没有其他错误 

464
00:22:26,250 --> 00:22:28,000
我想我又回来做生意了 

465
00:22:28,000 --> 00:22:31,125
关于使用词典 我想明确的是

466
00:22:31,125 --> 00:22:34,000
它让我获得了更好的语义 

467
00:22:34,000 --> 00:22:38,958
再说一次 我不需要记住 记住 文件 0是名字；

468
00:22:38,958 --> 00:22:40,166
1是House 

469
00:22:40,166 --> 00:22:43,291
相反 “name”是名字 “house”是house 

470
00:22:43,291 --> 00:22:45,500
它只是更清晰一点 更有表现力一点 

471
00:22:45,500 --> 00:22:49,250
因此 这通常是一件好事 特别是如果我们存储了更多关于

472
00:22:49,250 --> 00:22:53,000
学生不仅仅是他们的名字和他们的房子--如果你有三个领域 四个 

473
00:22:53,000 --> 00:22:54,625
五到十个不同的领域--

474
00:22:54,625 --> 00:22:58,875
没有人会想要记住或能够永远记住这是零

475
00:22:58,875 --> 00:23:00,625
这是1 这是2 以此类推 

476
00:23:00,625 --> 00:23:04,958
最好引入名字 比如本例中的“name”和“house” 

477
00:23:04,958 --> 00:23:07,125
但让我进一步收紧这一点 

478
00:23:07,125 --> 00:23:10,541
我通常习惯于不引入不必要的变量 

479
00:23:10,541 --> 00:23:12,250
除非它们使代码更具可读性 

480
00:23:12,250 --> 00:23:15,958
格式化相同代码的另一种方法是这样 

481
00:23:15,958 --> 00:23:19,333
严格地说 我不需要创建一本空词典 

482
00:23:19,333 --> 00:23:23,375
然后给它添加一个密钥 然后给它添加第二个密钥 

483
00:23:23,375 --> 00:23:25,375
然后把那本词典还给我 

484
00:23:25,375 --> 00:23:29,458
如果你愿意的话 我可以把这一切归结为一份声明 

485
00:23:29,458 --> 00:23:30,958
让我继续做这件事 

486
00:23:30,958 --> 00:23:35,458
让我继续说 名称等于输入返回值 

487
00:23:35,458 --> 00:23:38,583
House等于输入返回值 然后 

488
00:23:38,583 --> 00:23:41,666
而不是返回任何变量名学生 这是我要建议的

489
00:23:41,666 --> 00:23:44,208
不需要再存在了 让我来创造

490
00:23:44,208 --> 00:23:46,416
然后一次把词典全部归还 

491
00:23:46,416 --> 00:23:50,458
让我这样做 引用 不引用 这里用小写的“name” 然后是变量 

492
00:23:50,458 --> 00:23:52,041
它存储用户的姓名 

493
00:23:52,041 --> 00:23:55,208
然后 引用 不引用 “house”作为我的第二个密钥 它的价值

494
00:23:55,208 --> 00:23:57,083
将会是House 这个变量 

495
00:23:57,083 --> 00:23:58,166
现在 这是不是更好了？

496
00:23:58,166 --> 00:23:59,000
可能会 也可能不会 

497
00:23:59,000 --> 00:24:00,958
也许第一种方法更具可读性 

498
00:24:00,958 --> 00:24:03,416
这完全可以用来制造变量

499
00:24:03,416 --> 00:24:05,833
如果它们提高了代码的可读性 

500
00:24:05,833 --> 00:24:09,833
但要知道 您还可以即时创建和返回词典

501
00:24:09,833 --> 00:24:12,208
像这样 可以说 都在一行里 而我

502
00:24:12,208 --> 00:24:14,333
我认为在这种情况下 这是相当合理的 

503
00:24:14,333 --> 00:24:14,875
为什么？

504
00:24:14,875 --> 00:24:16,083
就是太短了 

505
00:24:16,083 --> 00:24:18,875
如果它变得越来越长 我可能不会这么做 

506
00:24:18,875 --> 00:24:22,583
然后 我至少可以开始将我的键值对移动到不同的行 

507
00:24:22,583 --> 00:24:27,458
但这也只是一种稍微更紧凑的方式 

508
00:24:27,458 --> 00:24:29,375
但让我提议我们再做一次改变 

509
00:24:29,375 --> 00:24:32,958
让我们继续介绍Padma相同特殊外壳

510
00:24:32,958 --> 00:24:36,458
例如 为了修缮她从格兰芬多到拉文克劳的房子 

511
00:24:36,458 --> 00:24:38,250
我们如何用词典做到这一点呢？

512
00:24:38,250 --> 00:24:41,625
词典和列表一样 都是可变的 

513
00:24:41,625 --> 00:24:45,416
您可以更改它们中的内容 就像您可以列出列表一样 

514
00:24:45,416 --> 00:24:46,250
你怎么做到的？

515
00:24:46,250 --> 00:24:48,041
只是在句法上有一点不同 

516
00:24:48,041 --> 00:24:50,291
因此 让我们返回到Main并进行此修复 

517
00:24:50,291 --> 00:24:57,708
如果学生变量有一个等于Padma的名称键 那么 

518
00:24:57,708 --> 00:25:04,375
缩进 继续并更改该学生体内的房屋钥匙的值

519
00:25:04,375 --> 00:25:08,666
词典改为 引用 不引用 取而代之的是“RavenClaw” 

520
00:25:08,666 --> 00:25:11,416
在精神上与我们用清单做的事情非常相似 

521
00:25:11,416 --> 00:25:16,250
但我们没有使用位置0和1 而是更清楚、更明确地说 

522
00:25:16,250 --> 00:25:19,375
语义上使用 引号 不引号 “名字”和 引号 不引号 

523
00:25:19,375 --> 00:25:24,250
“house” 因为您使用数字来索引列表和元组 但您是在索引

524
00:25:24,250 --> 00:25:27,916
变成使用字符串的词典 就像我在这里所做的那样 

525
00:25:27,916 --> 00:25:31,250
好的 让我继续运行PYTHON of Student.py 

526
00:25:31,250 --> 00:25:33,208
我们再来一次《格兰芬多》中的哈利 

527
00:25:33,208 --> 00:25:35,125
我认为一切都很好 

528
00:25:35,125 --> 00:25:38,708
让我再说一次 这一次是帕德玛 在电影中 

529
00:25:38,708 --> 00:25:43,375
来自格兰芬多 但实际上应该来自拉文克劳 

530
00:25:43,375 --> 00:25:49,250
那么 在从元组到列表再到词典的过程中 还有什么问题吗？

531
00:25:49,250 --> 00:25:53,458
除了这些元组之外 我们没有必要引入任何新的东西 

532
00:25:53,458 --> 00:25:56,250
在这段时间里 我们一直都能得到 

533
00:25:56,250 --> 00:26:00,000
但目前的目标只是为了证明这一区别

534
00:26:00,000 --> 00:26:02,250
在这些不同的数据类型中以及它们如何

535
00:26:02,250 --> 00:26:04,333
每种方法的工作原理都略有不同 

536
00:26:04,333 --> 00:26:10,416
观众：如果我们的元组中有列表的组合呢？

537
00:26:10,416 --> 00:26:16,125
我们可以改变列表 因为列表是不变的 但是列表是可变的？

538
00:26:16,125 --> 00:26:17,125
大卫·J·马兰：正确 

539
00:26:17,125 --> 00:26:19,291
您可以更改列表的内容 并且您可以

540
00:26:19,291 --> 00:26:23,125
几乎可以放任何你想要的东西--其他的列表或字符串 就像我做的那样 

541
00:26:23,125 --> 00:26:24,583
整数或其他任何值 

542
00:26:24,583 --> 00:26:27,916
元组您可以执行完全相同的操作 但不能一次更改它们

543
00:26:27,916 --> 00:26:29,083
是你创造了它们 

544
00:26:29,083 --> 00:26:33,041
字典更像是一个列表 因为它是可变的 

545
00:26:33,041 --> 00:26:34,208
你可以改变的 

546
00:26:34,208 --> 00:26:37,583
但是你索引词典的方式是

547
00:26:37,583 --> 00:26:40,541
通过这些钥匙 这些弦 就像我们一直说的 

548
00:26:40,541 --> 00:26:42,250
而不是通过数字--

549
00:26:42,250 --> 00:26:45,083
那些数字索引 

550
00:26:45,083 --> 00:26:47,875
好吧 好吧 让我来提议一下

551
00:26:47,875 --> 00:26:50,458
解决这个问题的另一种方法 

552
00:26:50,458 --> 00:26:53,875
我会争辩说 现在有一个机会近在眼前 

553
00:26:53,875 --> 00:26:56,750
尽管这个程序并不是特别复杂--

554
00:26:56,750 --> 00:27:01,208
我所要做的就是从用户和房子中收集一个名字

555
00:27:01,208 --> 00:27:03,166
从用户那里--你可以想象想要 

556
00:27:03,166 --> 00:27:05,291
从长远来看 为了收集更多的信息 

557
00:27:05,291 --> 00:27:07,791
就像学生的守护神或魔咒

558
00:27:07,791 --> 00:27:10,666
或者一大堆其他可能属于学生的信息 

559
00:27:10,666 --> 00:27:15,291
现在 我们只是使用这些非常通用的数据

560
00:27:15,291 --> 00:27:16,458
Python中的类型--

561
00:27:16,458 --> 00:27:20,083
用于将一些值组合在一起的元组；用于执行相同操作的列表 

562
00:27:20,083 --> 00:27:23,625
但让我们以后再改吧；字典 它更强大

563
00:27:23,625 --> 00:27:25,250
因为它更有条理一些 

564
00:27:25,250 --> 00:27:28,708
它确实有钥匙 而且它有价值 而不仅仅是价值 

565
00:27:28,708 --> 00:27:30,250
但是你知道吗？

566
00:27:30,250 --> 00:27:33,500
如果Python的作者 我们就不必进行这次对话

567
00:27:33,500 --> 00:27:37,125
刚刚给我们提供了一个名为Student的数据类型 

568
00:27:37,125 --> 00:27:39,000
如果能有一个

569
00:27:39,000 --> 00:27:42,166
我可以在代码中创建一种变量 叫做student？

570
00:27:42,166 --> 00:27:43,916
那我们就不用搞清楚

571
00:27:43,916 --> 00:27:46,416
我们是用元组 列表还是字典

572
00:27:46,416 --> 00:27:48,333
但这也很合理 

573
00:27:48,333 --> 00:27:52,166
你可以想象这是一个多么滑的斜坡 可以这么说 

574
00:27:52,166 --> 00:27:55,166
如果一种语言的创造者必须预见到

575
00:27:55,166 --> 00:27:58,250
所有可能的数据类型 

576
00:27:58,250 --> 00:28:00,375
我想把它存储在你的程序里

577
00:28:00,375 --> 00:28:02,875
所以他们只是给了我们这些通用工具 

578
00:28:02,875 --> 00:28:05,750
但他们给了我们另一个通用工具

579
00:28:05,750 --> 00:28:09,375
这也将允许我们创建自己的数据类型

580
00:28:09,375 --> 00:28:14,291
并给它们起名字 这个术语就是一个类 

581
00:28:14,291 --> 00:28:20,125
类就像是数据对象片段的蓝图 

582
00:28:20,125 --> 00:28:24,166
类是一个你可以定义和命名的模型 

583
00:28:24,166 --> 00:28:26,875
当你用那个模型或者蓝图的时候 

584
00:28:26,875 --> 00:28:31,000
你得到的数据类型完全是你想要的 

585
00:28:31,000 --> 00:28:36,208
所以简而言之 类允许您在Python中发明自己的数据类型

586
00:28:36,208 --> 00:28:37,375
给他们起个名字

587
00:28:37,375 --> 00:28:41,291
这是面向对象编程的主要特征 

588
00:28:41,291 --> 00:28:44,041
能够以这种方式创建自己的对象

589
00:28:44,041 --> 00:28:48,291
而且 对于Python中的类 甚至可以给它们一些自定义的名称 

590
00:28:48,291 --> 00:28:50,333
那么 这在实际意义上意味着什么呢？

591
00:28:50,333 --> 00:28:52,375
好吧 让我继续 

592
00:28:52,375 --> 00:28:56,500
这里 让我建议我们引入一点新的语法 

593
00:28:56,500 --> 00:28:58,916
我要先清空我的终端窗口 

594
00:28:58,916 --> 00:29:02,791
我要翻到我的档案的最上面 我只是要开始一个想法 

595
00:29:02,791 --> 00:29:03,916
但还没完成

596
00:29:03,916 --> 00:29:09,083
我将使用这个新的关键字来表示类 字面上叫做class 

597
00:29:09,083 --> 00:29:11,708
所以我们要用新的关键词

598
00:29:11,708 --> 00:29:13,916
如果我回到我们的幻灯片 

599
00:29:13,916 --> 00:29:16,083
将是官方网址 你可以阅读更多

600
00:29:16,083 --> 00:29:18,000
Python的这个特性 

601
00:29:18,000 --> 00:29:22,083
在官方教程中 class是我们可以使用的新关键字 

602
00:29:22,083 --> 00:29:25,500
现在 巧合的是 这与学生有关 因为学生上课 

603
00:29:25,500 --> 00:29:28,500
但这与我们正在与学生打交道的事实无关 

604
00:29:28,500 --> 00:29:31,791
类在许多语言中是一个通用术语--

605
00:29:31,791 --> 00:29:35,500
其中就有Python 它允许您定义这些定制容器

606
00:29:35,500 --> 00:29:38,625
具有数据片段的自定义名称 

607
00:29:38,625 --> 00:29:39,875
因此 让我们回到VS代码 

608
00:29:39,875 --> 00:29:41,333
让我们使用这个新的关键字 

609
00:29:41,333 --> 00:29:44,500
让我提议创建一个名为“学生”的类 

610
00:29:44,500 --> 00:29:47,000
按照惯例 我将在这里使用大写的S 

611
00:29:47,000 --> 00:29:49,583
接下来 我将使用冒号 

612
00:29:49,583 --> 00:29:52,500
稍后 我们将介绍这个类的实现 

613
00:29:52,500 --> 00:29:55,625
所以我将使用. 这是目前有效的占位符 

614
00:29:55,625 --> 00:29:57,833
这对我来说只是预示着我会回来

615
00:29:57,833 --> 00:29:59,000
到以后实施这一点 

616
00:29:59,000 --> 00:30:02,125
但到目前为止 它确实存在 

617
00:30:02,125 --> 00:30:08,458
我现在已经为我定义了一个学生类 现在我可以在这里的代码中使用它 

618
00:30:08,458 --> 00:30:09,875
我要怎么用它呢？

619
00:30:09,875 --> 00:30:13,250
好的 首先 让我下楼去找学生 

620
00:30:13,250 --> 00:30:18,625
让我将这段代码更改为不再使用字典 而是使用这个类 

621
00:30:18,625 --> 00:30:19,666
我要做这件事 

622
00:30:19,666 --> 00:30:22,791
我将给自己一个名为Student的变量 就像我以前做过的那样 

623
00:30:22,791 --> 00:30:26,166
但我会将其设置为等于大写学生() 

624
00:30:28,916 --> 00:30:32,208
所以我要做的似乎是调用一个函数

625
00:30:32,208 --> 00:30:35,583
和那个函数 大写的学生S 通知 

626
00:30:35,583 --> 00:30:39,500
匹配我在文件顶部为这个类指定的名称 

627
00:30:39,500 --> 00:30:41,166
好了 我下一步想做什么？

628
00:30:41,166 --> 00:30:43,333
我要继续 给这个学生起个名字 

629
00:30:43,333 --> 00:30:46,041
现在 如果我还在用字典 我

630
00:30:46,041 --> 00:30:50,541
会用方括号写出学生 引用 不引用 “名字” 

631
00:30:50,541 --> 00:30:52,125
但这不是一本词典 

632
00:30:52,125 --> 00:30:54,500
事实证明 目前 我们将在课堂上

633
00:30:54,500 --> 00:30:58,916
调用属性 这是一种允许在

634
00:30:58,916 --> 00:30:59,416
他们中的一员 

635
00:30:59,416 --> 00:31:01,708
而它的语法恰好是一个点 

636
00:31:01,708 --> 00:31:03,166
我们以前见过圆点 

637
00:31:03,166 --> 00:31:06,333
我们已经在模块和库的上下文中更普遍地使用了它 

638
00:31:06,333 --> 00:31:08,875
这是另一个类似的精神使用点

639
00:31:08,875 --> 00:31:12,125
它能让你从别的东西里得到别的东西 

640
00:31:12,125 --> 00:31:15,208
所以student.name将是语法

641
00:31:15,208 --> 00:31:18,083
我给这个学生取了个名字 

642
00:31:18,083 --> 00:31:21,666
这个名字将是“Name”的返回值 

643
00:31:21,666 --> 00:31:24,958
然后我继续说student.house 

644
00:31:24,958 --> 00:31:29,291
另一个名为“House”的属性 并给出输入的返回值

645
00:31:29,291 --> 00:31:30,750
在这里 提示用户进行房屋 

646
00:31:30,750 --> 00:31:33,625
然后 像以前一样 我只是要返回学生 

647
00:31:33,625 --> 00:31:37,166
但现在关于阶级真正强大的是 

648
00:31:37,166 --> 00:31:39,791
和面向对象的编程更普遍地说 

649
00:31:39,791 --> 00:31:43,375
我创建了一种自定义数据类型 

650
00:31:43,375 --> 00:31:47,333
学生 大写S 我在变量中存储了一个这样的学生

651
00:31:47,333 --> 00:31:50,833
就像我在变量student中做的那样 

652
00:31:50,833 --> 00:31:52,333
但我想怎么叫都行 

653
00:31:52,333 --> 00:31:56,166
称之为学生也是有道理的 但为了清楚起见 我还是要说清楚 

654
00:31:56,166 --> 00:31:58,291
然后我返回这个变量 

655
00:31:58,291 --> 00:32:01,666
因为我在第14和15行的语法 

656
00:32:01,666 --> 00:32:05,083
结果就是把这个类

657
00:32:05,083 --> 00:32:09,291
name属性和house属性 

658
00:32:09,291 --> 00:32:11,625
我只需要在这里再做一个改变 

659
00:32:11,625 --> 00:32:13,416
我要把帕德玛

660
00:32:13,416 --> 00:32:15,500
代码 这样我们就可以只关注新的东西 

661
00:32:15,500 --> 00:32:17,416
而不是修房子

662
00:32:17,416 --> 00:32:20,208
我要在这里修改语法

663
00:32:20,208 --> 00:32:21,916
以前是字典 

664
00:32:21,916 --> 00:32:26,958
同样 字典使用方括号 然后在引号中使用字符串 

665
00:32:26,958 --> 00:32:29,958
单引号或双引号 取决于上下文 

666
00:32:29,958 --> 00:32:33,208
在这里 我将把它改为student.name 

667
00:32:33,208 --> 00:32:37,458
在这里 我将把它改为student.house 

668
00:32:37,458 --> 00:32:40,791
这就是我的新语法 

669
00:32:40,791 --> 00:32:43,250
似乎是一个叫做学生的类 

670
00:32:43,250 --> 00:32:47,458
让我继续搜索student.py的Python 回车 

671
00:32:47,458 --> 00:32:49,333
让我们像以前一样输入哈利的名字 

672
00:32:49,333 --> 00:32:52,500
我们把他送进格兰芬多监狱 像往常一样祈祷 

673
00:32:52,500 --> 00:32:56,500
哈里确实来自格兰芬多 

674
00:32:56,500 --> 00:32:58,166
不过 我都做了些什么？

675
00:32:58,166 --> 00:33:01,000
让我们在这里介绍另一个术语

676
00:33:01,000 --> 00:33:05,583
事实证明 我可以使用那个CLASS关键字创建一个类 

677
00:33:05,583 --> 00:33:09,958
但无论何时使用类 都是在创建所谓的对象 

678
00:33:09,958 --> 00:33:14,666
这里是单词对象 作为一种面向对象的编程 或OOP 

679
00:33:14,666 --> 00:33:16,250
让我在这里回到我的代码 

680
00:33:16,250 --> 00:33:18,916
尽管我还没有真正实现它的大部分--

681
00:33:18,916 --> 00:33:20,958
我真的只留下了一个点 点 点--

682
00:33:20,958 --> 00:33:25,416
这是足够的代码 第1行和第2行 仅仅发明了一个新的数据类型

683
00:33:25,416 --> 00:33:29,708
学生 首都S 这可能会也可能不会有一些未来的功能 

684
00:33:29,708 --> 00:33:31,375
这足以创建一个类 

685
00:33:31,375 --> 00:33:34,166
然而 我在11号线上做了什么？

686
00:33:34,166 --> 00:33:40,083
在第11行 从技术上讲 我要做的是创建该类的对象 

687
00:33:40,083 --> 00:33:42,000
因此 这也是另一个艺术术语 

688
00:33:42,000 --> 00:33:44,791
您可以从类创建对象 

689
00:33:44,791 --> 00:33:47,000
因此 如果我们回到那个比喻 这个类是

690
00:33:47,000 --> 00:33:50,916
就像房子或班级的蓝图就像一个模具 

691
00:33:50,916 --> 00:33:54,750
对象是指当你使用该蓝图建造特定的房屋时

692
00:33:54,750 --> 00:33:58,458
或者是从石膏 模具里出来的东西 当你实际

693
00:33:58,458 --> 00:34:01,250
使用该模具来创建这样的对象 

694
00:34:01,250 --> 00:34:04,916
因此 类又是一种新数据类型的定义 

695
00:34:04,916 --> 00:34:10,125
对象是的化身 或技术上的实例化 

696
00:34:10,125 --> 00:34:13,583
对象的另一个术语实际上是实例 

697
00:34:13,583 --> 00:34:16,208
您也有类的实例 

698
00:34:16,208 --> 00:34:17,458
所以这是大量的词汇量 

699
00:34:17,458 --> 00:34:19,708
但归根结底 它只是归结为这一点 

700
00:34:19,708 --> 00:34:22,750
您可以定义自己的类 这实际上是您自己的数据类型 

701
00:34:22,750 --> 00:34:26,791
然后 您可以在其中存储属性 在这里使用这个点符号 

702
00:34:26,791 --> 00:34:31,041
然后 您可以使用下面这样的代码访问这些相同的属性 

703
00:34:31,041 --> 00:34:33,958
现在 我有了一个合适的“学生”数据类型 

704
00:34:33,958 --> 00:34:36,625
我不需要把一些东西拼凑在一起

705
00:34:36,625 --> 00:34:39,000
使用元组或列表 甚至使用字典 

706
00:34:39,000 --> 00:34:43,500
我现在有了一个名为“Student”的适当数据类型 该数据类型是Python的作者

707
00:34:43,500 --> 00:34:46,041
没有给我 我给了我自己 

708
00:34:46,041 --> 00:34:50,791
现在有没有关于CLASS、这个新关键字、CLASS或这个概念的问题

709
00:34:50,791 --> 00:34:53,625
这些物体或其实例？

710
00:34:53,625 --> 00:34:58,333
观众：类对象是可变的还是不可变的？

711
00:34:58,333 --> 00:34:59,666
大卫·J·马兰：问得好 

712
00:34:59,666 --> 00:35:02,208
我们显然已经为进行这种对话奠定了基础

713
00:35:02,208 --> 00:35:03,541
关于现在的每种数据类型 

714
00:35:03,541 --> 00:35:07,958
我们将看到它们是可变的 但您可以使它们不可变 

715
00:35:07,958 --> 00:35:10,083
这样你就可以两全其美了 

716
00:35:10,083 --> 00:35:13,416
现在 通过编写一些实际的代码--我们将编写比圆点更多的代码 

717
00:35:13,416 --> 00:35:18,208
点 点进一点 关于类或其对象的其他问题？

718
00:35:18,208 --> 00:35:21,625
观众：那么这些职业有什么特点呢？

719
00:35:21,625 --> 00:35:24,750
大卫·J·马兰：所以现在 这些属性--或者属性 

720
00:35:24,750 --> 00:35:28,250
到目前为止 我一直这样称呼它们--就是“名字”和“房子” 

721
00:35:28,250 --> 00:35:32,333
事实证明 类中很可能还内置了其他属性

722
00:35:32,333 --> 00:35:33,541
我们可能很快就会看到 

723
00:35:33,541 --> 00:35:36,166
但现在 我唯一关心的两个属性

724
00:35:36,166 --> 00:35:38,333
是我自己创造的--

725
00:35:38,333 --> 00:35:42,208
即“名字”和“房子” 或者 再一次 我称之为属性 

726
00:35:42,208 --> 00:35:43,916
稍后 我们将开始

727
00:35:43,916 --> 00:35:47,541
将这些相同的属性称为实例变量 更专业地说是实例变量 

728
00:35:47,541 --> 00:35:50,708
“名字”和“房子” 就像我在VS代码中展示的那样

729
00:35:50,708 --> 00:35:55,750
实际上只是在内部称为“name”和“house”的变量

730
00:35:55,750 --> 00:36:00,125
类型为学生的对象的 

731
00:36:00,125 --> 00:36:02,583
好的 那么我们还能用这些课程做些什么呢？

732
00:36:02,583 --> 00:36:06,208
再次说明 第11行是我们要实例化的地方

733
00:36:06,208 --> 00:36:11,000
学生类的对象 并将其赋给学生变量 

734
00:36:11,000 --> 00:36:12,416
然后我们添加属性--

735
00:36:12,416 --> 00:36:16,000
“名字”和“房子”--目前分别在第12行和第13行 

736
00:36:16,000 --> 00:36:17,958
从技术上讲 这两者的价值都是

737
00:36:17,958 --> 00:36:21,208
字符串或STR 因为这就是输入的返回值 

738
00:36:21,208 --> 00:36:24,000
但这些属性值实际上可以是任何数据类型 

739
00:36:24,000 --> 00:36:27,000
我们只是让事情变得简单 专注于定义学生

740
00:36:27,000 --> 00:36:28,333
就两根弦而言--

741
00:36:28,333 --> 00:36:29,375
“名字”和“房子”

742
00:36:29,375 --> 00:36:32,125
然后 在第14行 我们返回该变量 

743
00:36:32,125 --> 00:36:35,333
我们将该对象返回给Main 这样我们就可以实际

744
00:36:35,333 --> 00:36:37,708
打印出谁是哪个房子的人 

745
00:36:37,708 --> 00:36:40,958
好吧 让我们继续在这里添加一些功能 因为 现在 

746
00:36:40,958 --> 00:36:44,166
在第12行和第13行 这是一个小手册 

747
00:36:44,166 --> 00:36:47,333
我太鲁莽了 把所有的东西

748
00:36:47,333 --> 00:36:50,333
我想要进入这个学生物体的内部 

749
00:36:50,333 --> 00:36:53,041
事实证明 与字典不同 课堂上的情况不同 

750
00:36:53,041 --> 00:36:57,625
我们实际上可以更多地标准化这些属性

751
00:36:57,625 --> 00:37:00,291
以及您可以将它们设置为什么样的值 

752
00:37:00,291 --> 00:37:02,375
所以让我继续做这件事 

753
00:37:02,375 --> 00:37:04,375
让我提议 它实际上将是真正的

754
00:37:04,375 --> 00:37:08,875
如果让我继续下去 而不是在这里做这个 那真是太好了

755
00:37:08,875 --> 00:37:10,833
并按如下方式简化我的代码 

756
00:37:10,833 --> 00:37:13,708
接下来 让我为自己指定一个名为name的局部变量

757
00:37:13,708 --> 00:37:17,208
并将其设置为等于输入的返回值 就像我们现在多次做的那样

758
00:37:17,208 --> 00:37:17,791
已经有了 

759
00:37:17,791 --> 00:37:20,333
现在让我给自己另一个变量 叫做house 

760
00:37:20,333 --> 00:37:23,333
并将其设置为等于输入的返回值

761
00:37:23,333 --> 00:37:25,291
以及提示用户选择他们的房子 

762
00:37:25,291 --> 00:37:30,416
现在 不是从我的学生类创建一个学生对象

763
00:37:30,416 --> 00:37:34,500
然后手动将名称属性放入其中

764
00:37:34,500 --> 00:37:37,166
和它里面的房子属性 让

765
00:37:37,166 --> 00:37:39,458
我实际上做了一些更有力量的事情 

766
00:37:39,458 --> 00:37:40,583
让我来做吧 

767
00:37:40,583 --> 00:37:45,333
让我调用学生函数 它与类名相同--

768
00:37:45,333 --> 00:37:48,125
只需定义一个类 就可以获得一个函数

769
00:37:48,125 --> 00:37:52,583
其名称与类名相同 包含大写字母 

770
00:37:52,583 --> 00:37:54,625
但是 不是只做开括号 

771
00:37:54,625 --> 00:37:58,166
右括号 让我把我的名字传进去

772
00:37:58,166 --> 00:38:02,791
我想用这个物体和我想放进那个物体的房子来填充

773
00:38:02,791 --> 00:38:03,375
也是 

774
00:38:03,375 --> 00:38:09,375
现在让我像以前一样设置返回值为学生等于 就像这样 

775
00:38:09,375 --> 00:38:11,083
那么 我做了什么不同的事情呢？

776
00:38:11,083 --> 00:38:13,583
从根本上说 我仍然以同样的方式获得用户输入 

777
00:38:13,583 --> 00:38:16,750
我在第11行使用输入 在第12行使用输入 

778
00:38:16,750 --> 00:38:21,125
我只是碰巧将这些返回值存储在局部变量中 

779
00:38:21,125 --> 00:38:24,875
现在 我们正在为类的更强大的功能做准备

780
00:38:24,875 --> 00:38:27,208
以及更一般的面向对象编程 

781
00:38:27,208 --> 00:38:31,500
注意 我是故意传递给这个首都S的学生

782
00:38:31,500 --> 00:38:33,875
功能 名字 房子--

783
00:38:33,875 --> 00:38:36,291
我正在向该函数传递参数 

784
00:38:36,291 --> 00:38:39,750
现在 学生们还不知道该怎么处理这些东西 

785
00:38:39,750 --> 00:38:44,791
但现在 我正在标准化如何将数据传递到这个学生班级 

786
00:38:44,791 --> 00:38:47,833
最终 这将给我一个犯错的机会

787
00:38:47,833 --> 00:38:51,166
检查这些输入 以确保名称有效 并且具有值

788
00:38:51,166 --> 00:38:52,875
而且 不仅仅是用户按了Enter键 

789
00:38:52,875 --> 00:38:56,041
这将使我能够确保它是一所有效的房子 它是

790
00:38:56,041 --> 00:38:59,208
格兰芬多、赫奇帕奇、拉文克劳或斯莱特林

791
00:38:59,208 --> 00:39:02,916
或者不只是按回车键或用户输入的某个随机值 

792
00:39:02,916 --> 00:39:05,916
因为我要把“名字”和“房子”传给学生

793
00:39:05,916 --> 00:39:08,791
类 这个特殊的函数 我要

794
00:39:08,791 --> 00:39:11,416
以便更好地控制我的数据的正确性 

795
00:39:11,416 --> 00:39:14,541
现在让我们来看看学生班 到目前为止 

796
00:39:14,541 --> 00:39:16,125
我离开时只是点点 点点 点点 

797
00:39:16,125 --> 00:39:19,625
事实证明 在课程的背景下 

798
00:39:19,625 --> 00:39:23,916
有许多不只是属性或实例

799
00:39:23,916 --> 00:39:27,041
可以放在里面的变量 也可以放入方法 

800
00:39:27,041 --> 00:39:32,083
类带有某些方法 或其中的函数 

801
00:39:32,083 --> 00:39:35,708
你可以定义 他们只是以一种特殊的方式行事 

802
00:39:35,708 --> 00:39:37,875
从本质上讲 它是如何工作的 

803
00:39:37,875 --> 00:39:42,625
这些函数允许您以标准方式确定行为 

804
00:39:42,625 --> 00:39:45,083
从这个意义上说 它们是特殊的方法 

805
00:39:45,083 --> 00:39:46,333
现在 我这么说是什么意思 

806
00:39:46,333 --> 00:39:48,083
好吧 让我回到VS代码这里 

807
00:39:48,083 --> 00:39:53,000
让我提议我开始定义一个标准函数

808
00:39:53,000 --> 00:39:56,916
被称为下划线 或下划线 因为它是

809
00:39:56,916 --> 00:39:59,916
缩写、缩写、下划线、下划线

810
00:39:59,916 --> 00:40:02,916
然后我要继续做开括号 

811
00:40:02,916 --> 00:40:06,875
然后我要在这里加上 字面上的 自我这个词 

812
00:40:06,875 --> 00:40:08,416
稍后将详细介绍这一点 

813
00:40:08,416 --> 00:40:11,791
但现在 在这个函数中 我将有机会

814
00:40:11,791 --> 00:40:16,791
若要自定义此类的对象 请执行以下操作 

815
00:40:16,791 --> 00:40:20,333
也就是说 这个下划线 下划线init方法 

816
00:40:20,333 --> 00:40:25,208
或者DUnder Init方法具体称为实例方法 

817
00:40:25,208 --> 00:40:26,708
它的名字就是这个 

818
00:40:26,708 --> 00:40:28,875
这是由Python的作者设计的 

819
00:40:28,875 --> 00:40:34,291
如果您想从类中初始化对象的内容 

820
00:40:34,291 --> 00:40:37,875
您定义了这个方法 我们将在这里看到它将要做什么 

821
00:40:37,875 --> 00:40:41,250
让我回到VS代码 让我来做一些类似的事情 

822
00:40:41,250 --> 00:40:47,750
Self.name=name self.house=house 

823
00:40:47,750 --> 00:40:51,250
但我不想只是泛泛地初始化这个对象 

824
00:40:51,250 --> 00:40:56,166
我希望这种名为init的方法不仅接受自己 还接受名字 

825
00:40:56,166 --> 00:40:58,375
豪斯也是 

826
00:40:58,375 --> 00:40:59,916
现在 世界上到底发生了什么？

827
00:40:59,916 --> 00:41:01,708
因为这里有很多奇怪的语法 

828
00:41:01,708 --> 00:41:03,375
有一种DUnder Init方法--

829
00:41:03,375 --> 00:41:05,791
双下划线 初始化 双下划线 

830
00:41:05,791 --> 00:41:08,750
突然间 这个参数被称为SELF 

831
00:41:08,750 --> 00:41:12,458
然后是这个新的语法--self.name和self.house 

832
00:41:12,458 --> 00:41:16,541
现在 您真正看到了面向对象编程的一种表现 

833
00:41:16,541 --> 00:41:18,250
从根本上说 这并没有什么不同

834
00:41:18,250 --> 00:41:20,541
从我们几周来对词典所做的工作来看 

835
00:41:20,541 --> 00:41:23,125
通过向词典添加关键字 

836
00:41:23,125 --> 00:41:28,333
但在这种情况下 我们向对象添加变量 也就是 

837
00:41:28,333 --> 00:41:30,500
将实例变量转换为对象 

838
00:41:30,500 --> 00:41:31,458
现在 这是怎么回事？

839
00:41:31,458 --> 00:41:32,541
让我们反过来来做这件事 

840
00:41:32,541 --> 00:41:34,750
让我们回到前面编写的代码行 

841
00:41:34,750 --> 00:41:38,708
在第15行 我把这个班级的名字

842
00:41:38,708 --> 00:41:41,916
学生用大写S--作为函数 

843
00:41:41,916 --> 00:41:44,583
我要传递两个值--

844
00:41:44,583 --> 00:41:45,916
“名字”和“房子”

845
00:41:45,916 --> 00:41:48,708
我在屏幕上第15行突出显示的是 

846
00:41:48,708 --> 00:41:51,250
通常称为构造函数调用 

847
00:41:51,250 --> 00:41:56,875
这行代码将为我构造一个学生对象 

848
00:41:56,875 --> 00:42:02,791
使用同义词 它将为我实例化一个学生对象 

849
00:42:02,791 --> 00:42:05,583
再说一次 它将如何创建那个对象？

850
00:42:05,583 --> 00:42:09,458
它将使用学生类作为模板 作为某种模型

851
00:42:09,458 --> 00:42:12,291
所以每个学生的结构都是一样的 

852
00:42:12,291 --> 00:42:13,875
每个学生都会有一个名字 

853
00:42:13,875 --> 00:42:15,458
每个学生都会有一所房子 

854
00:42:15,458 --> 00:42:20,916
但是因为我可以把参数传递给这个学生函数 大写的S 

855
00:42:20,916 --> 00:42:26,666
我将能够定制该对象的内容 

856
00:42:26,666 --> 00:42:29,666
所以如果你想一想现实世界--如果你曾经走在街上

857
00:42:29,666 --> 00:42:34,666
或者是一个社区 所有的房子看起来都一样 但他们可能

858
00:42:34,666 --> 00:42:37,541
油漆不同；它们的装饰可能会略有不同

859
00:42:37,541 --> 00:42:40,958
在外面 所有这些房子都可能是用完全相同的

860
00:42:40,958 --> 00:42:42,541
同样的蓝图--

861
00:42:42,541 --> 00:42:43,875
一个模子 如果你愿意的话 

862
00:42:43,875 --> 00:42:48,083
但然后你就可以专门研究那些房子的细微之处了 

863
00:42:48,083 --> 00:42:51,000
通过给外面涂上不同的颜色或种植不同的树 

864
00:42:51,000 --> 00:42:52,500
您可以设置不同的样式 

865
00:42:52,500 --> 00:42:57,750
在精神上与这里相似 我们有一个学生蓝图

866
00:42:57,750 --> 00:43:01,583
它现在总会有名字和房子 但这取决于你和我

867
00:43:01,583 --> 00:43:04,166
传递我们想要的任何名字和任何房子 

868
00:43:04,166 --> 00:43:06,041
现在 这个函数在哪里？

869
00:43:06,041 --> 00:43:09,125
我叫学生 大写 S 然后是一个括号

870
00:43:09,125 --> 00:43:11,250
和一个内含参数的右括号

871
00:43:11,250 --> 00:43:12,958
暗示在某个地方有一个函数

872
00:43:12,958 --> 00:43:17,500
在已经定义的世界中 使用def 这将被称为 

873
00:43:17,500 --> 00:43:20,416
嗯 正如您现在可能已经猜到的那样 函数

874
00:43:20,416 --> 00:43:25,500
通过定义Python类的工作方式 它将始终被调用 

875
00:43:25,500 --> 00:43:30,000
是一个名为双下划线、初始化、双下划线的函数 

876
00:43:30,000 --> 00:43:30,500
为什么？

877
00:43:30,500 --> 00:43:33,333
这是一个疯狂的名字 但它是Python的作者

878
00:43:33,333 --> 00:43:38,750
选择只在Python中实现对象的初始化 

879
00:43:38,750 --> 00:43:40,916
现在 唯一奇怪的是--

880
00:43:40,916 --> 00:43:43,125
我承认 特别奇怪的是 这一点 

881
00:43:43,125 --> 00:43:49,125
对我来说 如果初始化的唯一两个参数是

882
00:43:49,125 --> 00:43:50,666
只是名字 豪斯 

883
00:43:50,666 --> 00:43:53,541
到目前为止 我们就是这样定义类中的每个函数的 

884
00:43:53,541 --> 00:43:57,291
您只需指定希望函数接受的参数 

885
00:43:57,291 --> 00:44:00,333
这与我在第15行所做的是一致的 

886
00:44:00,333 --> 00:44:04,541
我只向学生函数传递了两件事 

887
00:44:04,541 --> 00:44:07,833
但事实证明 Python的作者

888
00:44:07,833 --> 00:44:09,541
需要在这里给我们一点帮助

889
00:44:09,541 --> 00:44:14,458
因为假设您将“name”和“house”传递给这个init方法 

890
00:44:14,458 --> 00:44:17,833
而方法只是类中的一个函数 

891
00:44:17,833 --> 00:44:20,291
你打算怎么处理这个名字和房子？

892
00:44:20,291 --> 00:44:22,333
从字面上看 你打算把它们放在哪里？

893
00:44:22,333 --> 00:44:26,500
如果你想记住这个学生的名字和房子 

894
00:44:26,500 --> 00:44:29,166
你必须能够将这些值存储在某个地方 

895
00:44:29,166 --> 00:44:32,416
以及如何将它们存储在当前对象中

896
00:44:32,416 --> 00:44:34,833
刚刚被“实例化”了吗？

897
00:44:34,833 --> 00:44:37,625
好吧 Python语言的作者们决定

898
00:44:37,625 --> 00:44:41,958
这个初始化方法也会半秘密地

899
00:44:41,958 --> 00:44:44,625
第三个论点 那必须放在第一位 

900
00:44:44,625 --> 00:44:46,666
按照惯例 它被称为SELF 但你可以

901
00:44:46,666 --> 00:44:48,250
严格来说 你可以叫它任何你想要的东西 

902
00:44:48,250 --> 00:44:50,208
但惯例是 它总是自称是自己 

903
00:44:50,208 --> 00:44:53,500
而SELF 顾名思义 给了你访问

904
00:44:53,500 --> 00:44:56,791
添加到刚刚创建的当前对象 

905
00:44:56,791 --> 00:44:58,000
那是什么意思？

906
00:44:58,000 --> 00:45:02,166
再一次 现在 在第14行 现在它向下移动了一点 

907
00:45:02,166 --> 00:45:04,083
这里的这行是一个构造函数 

908
00:45:04,083 --> 00:45:06,166
它构造了一个学生对象 

909
00:45:06,166 --> 00:45:08,291
但最初那个物体里什么都没有 

910
00:45:08,291 --> 00:45:09,750
没有名字 没有房子 

911
00:45:09,750 --> 00:45:12,791
但该对象存在于计算机的内存中 

912
00:45:12,791 --> 00:45:16,541
现在 您需要将姓名和房子存储在该对象中 

913
00:45:16,541 --> 00:45:17,500
你怎么做到的？

914
00:45:17,500 --> 00:45:21,500
嗯 Python会自动为您调用这个init方法 

915
00:45:21,500 --> 00:45:27,500
它将自动传递对一个参数的引用 该参数

916
00:45:27,500 --> 00:45:32,375
表示它刚刚在内存中为您构造的当前对象 

917
00:45:32,375 --> 00:45:34,708
而这取决于你用价值观来填充它 

918
00:45:34,708 --> 00:45:37,666
这意味着 在您的init方法中 

919
00:45:37,666 --> 00:45:42,875
从字面上看 您可以使用self.name来创建一个新的属性 也就是 

920
00:45:42,875 --> 00:45:46,166
一个实例变量 位于该变量内部 否则为空

921
00:45:46,166 --> 00:45:48,416
对象 并将此名称放入其中 

922
00:45:48,416 --> 00:45:51,875
它允许你自己做房子 并储存房子的价值 

923
00:45:51,875 --> 00:45:54,000
现在 你可以给这些东西取任何你想要的名字 

924
00:45:54,000 --> 00:45:54,750
它们可能是n 

925
00:45:54,750 --> 00:45:56,416
它们可能是h 就像以前一样 

926
00:45:56,416 --> 00:46:00,250
但这真的不是很清楚 

927
00:46:00,250 --> 00:46:04,250
做这样的大会要好得多 Self.name等于name 

928
00:46:04,250 --> 00:46:06,333
自个儿 房子等于房子 

929
00:46:06,333 --> 00:46:11,708
这就像是将值名称安装到其他空的对象中

930
00:46:11,708 --> 00:46:16,083
并将它们存放和存储在名称完全相同的实例中

931
00:46:16,083 --> 00:46:17,708
对象中的变量 

932
00:46:17,708 --> 00:46:20,833
同样 对象只是类的一个实例 

933
00:46:20,833 --> 00:46:23,208
现在 我知道那是很多词汇量 

934
00:46:23,208 --> 00:46:24,875
这是很多奇怪的语法 

935
00:46:24,875 --> 00:46:28,625
所以任何关于这个初始化方法的问题 它在生活中的目的 

936
00:46:28,625 --> 00:46:33,541
还是要在第一次创建一个空对象时对其进行初始化？

937
00:46:33,541 --> 00:46:36,791
受众：那么init方法和默认方法有什么不同呢

938
00:46:36,791 --> 00:46:37,500
构造者？

939
00:46:37,500 --> 00:46:38,833
大卫·J·马兰：问得好 

940
00:46:38,833 --> 00:46:41,583
所以在其他语言中--如果你以前编程过 

941
00:46:41,583 --> 00:46:45,166
例如 Java--有一些函数被显式调用

942
00:46:45,166 --> 00:46:47,916
构造对象的构造函数 

943
00:46:47,916 --> 00:46:49,416
它们使用值对其进行初始化 

944
00:46:49,416 --> 00:46:53,291
从技术上讲 Python将这个init方法称为初始化方法 

945
00:46:53,291 --> 00:46:54,958
它初始化值 

946
00:46:54,958 --> 00:47:00,875
现在我的代码在第15行 如果我向下滚动 从技术上讲 我是

947
00:47:00,875 --> 00:47:02,416
构建对象 

948
00:47:02,416 --> 00:47:05,333
原来 在Python中还有另一种特殊的方法 

949
00:47:05,333 --> 00:47:07,291
今天我们不会详细讨论 

950
00:47:07,291 --> 00:47:11,125
调用下划线下划线、新下划线、下划线

951
00:47:11,125 --> 00:47:13,375
它实际上处理了创建

952
00:47:13,375 --> 00:47:15,458
在我们的记忆中有一个空的物体 

953
00:47:15,458 --> 00:47:17,833
但是 总的来说 你这个程序员 

954
00:47:17,833 --> 00:47:19,916
不需要操控新函数 

955
00:47:19,916 --> 00:47:20,916
它只对你有效 

956
00:47:20,916 --> 00:47:23,750
相反 您可以在这里定义您自己的init方法

957
00:47:23,750 --> 00:47:27,041
和init函数在您的类中 该方法

958
00:47:27,041 --> 00:47:29,916
初始化对象的内容 

959
00:47:29,916 --> 00:47:32,750
所以从技术上讲 构造对象与构建对象之间存在区别

960
00:47:32,750 --> 00:47:35,250
使用new并使用init对其进行初始化 

961
00:47:35,250 --> 00:47:39,250
但在Python的世界中 您几乎只担心init方法 

962
00:47:39,250 --> 00:47:42,250
Python通常会为您完成另一部分工作 

963
00:47:42,250 --> 00:47:43,000
问得好 

964
00:47:43,000 --> 00:47:44,333
其他?

965
00:47:44,333 --> 00:47:48,166
观众：如果你想存储多个名字怎么办？

966
00:47:48,166 --> 00:47:49,083
不只是一栋房子？

967
00:47:49,083 --> 00:47:49,750
大卫·J·马兰：问得好 

968
00:47:49,750 --> 00:47:52,666
如果要存储多个名称或多个房屋 

969
00:47:52,666 --> 00:47:54,083
你可以用不同的方式来做这件事 

970
00:47:54,083 --> 00:47:57,916
您可以创建其他属性--技术上称为实例变量--

971
00:47:57,916 --> 00:48:01,708
如self.name1、self.name2 

972
00:48:01,708 --> 00:48:03,708
但我们在过去已经看到 这并不是

973
00:48:03,708 --> 00:48:06,291
一个非常好的设计 仅仅是有多个变量来存储

974
00:48:06,291 --> 00:48:07,250
多件事 

975
00:48:07,250 --> 00:48:12,625
也许 相反 您有一个名为self.name、复数

976
00:48:12,625 --> 00:48:15,958
你把它设置成一个名字列表或一个房屋列表 

977
00:48:15,958 --> 00:48:19,000
现在 在这种情况下 我不认为这真的解决了问题 因为我

978
00:48:19,000 --> 00:48:22,958
试图实现一个学生 单数 所以它没有真正的意义

979
00:48:22,958 --> 00:48:24,250
有多个名字 

980
00:48:24,250 --> 00:48:27,166
可能是昵称 也可能是姓氏 所以我们也可以加上这些 

981
00:48:27,166 --> 00:48:29,375
但我不认为我们本身需要多个名字

982
00:48:29,375 --> 00:48:31,333
在这种情况下 还有多栋房子 

983
00:48:31,333 --> 00:48:34,500
但绝对可以使用我们熟悉的一些构建块来实现这一点

984
00:48:34,500 --> 00:48:35,916
就像清单一样 

985
00:48:35,916 --> 00:48:37,541
还有其他问题吗？

986
00:48:37,541 --> 00:48:40,291
观众：类或对象在内存中是如何表示的？

987
00:48:40,291 --> 00:48:43,041
David J.Malan：类和对象在内存中是如何表示的？

988
00:48:43,041 --> 00:48:44,958
所以从技术上讲 这个类只是代码 

989
00:48:44,958 --> 00:48:48,333
这是我文件顶部的代码--第1行到第4行--

990
00:48:48,333 --> 00:48:52,250
它定义了蓝图 模板 如果你愿意的话 

991
00:48:52,250 --> 00:48:54,833
对象存储在计算机的内存中

992
00:48:54,833 --> 00:48:56,333
通过占用一定数量的字节 

993
00:48:56,333 --> 00:48:59,125
所以您可能对字节、千字节或兆字节很熟悉 

994
00:48:59,125 --> 00:49:01,750
有一些字节块 可能都是

995
00:49:01,750 --> 00:49:03,708
在计算机内存中的相同位置

996
00:49:03,708 --> 00:49:07,916
或RAM 其中存储这些对象 

997
00:49:07,916 --> 00:49:11,500
但这就是程序Python为您处理的 

998
00:49:11,500 --> 00:49:14,958
解释程序会找出将其放在计算机内存中的位置 

999
00:49:14,958 --> 00:49:18,041
你和我 作为程序员 在这个层面上思考和解决问题 

1000
00:49:18,041 --> 00:49:21,916
作为解释器的Python将为您处理这些较低级别的细节 

1001
00:49:21,916 --> 00:49:25,166
最后一个关于类和对象的问题怎么样？

1002
00:49:25,166 --> 00:49:28,125
听众：所以我的问题是 我们是否也能这样做

1003
00:49:28,125 --> 00:49:31,625
字典也是如此 那么为什么要使用类呢？

1004
00:49:31,625 --> 00:49:32,875
大卫·J·马兰：问得好 

1005
00:49:32,875 --> 00:49:34,750
如果你能用字典做同样的事情 

1006
00:49:34,750 --> 00:49:35,958
为什么要使用类？

1007
00:49:35,958 --> 00:49:38,416
因为我们现在只是触及了什么的皮毛

1008
00:49:38,416 --> 00:49:39,833
你可以用课程来应付 

1009
00:49:39,833 --> 00:49:42,666
现在 请允许我回到我的键盘上 向你们展示

1010
00:49:42,666 --> 00:49:44,375
更多关于您可以使用类所做的事情 

1011
00:49:44,375 --> 00:49:47,750
但简而言之 您可以使用类做更多的事情 

1012
00:49:47,750 --> 00:49:51,791
使用类可以更好地确保数据的正确性 

1013
00:49:51,791 --> 00:49:53,166
你可以错误地检查一些东西 

1014
00:49:53,166 --> 00:49:57,375
通常 您可以更有效地设计更复杂的软件 

1015
00:49:57,375 --> 00:49:59,458
今天我们将继续看到一些特色

1016
00:49:59,458 --> 00:50:02,416
更广泛地说 是关于Python和面向对象编程的

1017
00:50:02,416 --> 00:50:04,875
这使我们能够做到这一点 

1018
00:50:04,875 --> 00:50:09,333
所以让我提议 事实上 首先 让我们收紧这股电流

1019
00:50:09,333 --> 00:50:13,916
实现 这也为我们提供了一个init方法 它只声明了两个

1020
00:50:13,916 --> 00:50:16,875
实例变量--self.name和self.house house 同样 

1021
00:50:16,875 --> 00:50:21,416
只是在原本为空的对象内创建这些变量 并将

1022
00:50:21,416 --> 00:50:22,125
他们的价值观--

1023
00:50:22,125 --> 00:50:23,708
分别是名字和房子 

1024
00:50:23,708 --> 00:50:26,000
让我继续在这里做一件小事 

1025
00:50:26,000 --> 00:50:27,791
我真的不需要这个学生变量 

1026
00:50:27,791 --> 00:50:31,750
让我来加强一下 这样每次我们改进或更改代码时 

1027
00:50:31,750 --> 00:50:35,000
我们真的只关注最小的变化 

1028
00:50:35,000 --> 00:50:37,250
所以我从根本上没有做任何不同的事情 

1029
00:50:37,250 --> 00:50:39,291
我刚刚去掉了变量名 我只是

1030
00:50:39,291 --> 00:50:43,125
返回此学生函数的返回值

1031
00:50:43,125 --> 00:50:45,125
这是在为我构建我的新对象 

1032
00:50:45,125 --> 00:50:48,833
因此 我只是像过去多次做的那样 收紧措施 

1033
00:50:48,833 --> 00:50:53,291
那么 如果在创造这个学生的过程中出了什么问题呢？

1034
00:50:53,291 --> 00:50:56,791
例如 如果用户没有给我们提供姓名 他们只是点击

1035
00:50:56,791 --> 00:50:58,791
系统提示输入名称时 请输入 

1036
00:50:58,791 --> 00:51:01,250
我不想把我的电脑的内存

1037
00:51:01,250 --> 00:51:04,375
一个没有名字的假学生对象 

1038
00:51:04,375 --> 00:51:07,833
理想情况下 我甚至希望在创建它之前检查错误

1039
00:51:07,833 --> 00:51:09,583
所以我不会创造一个无名的学生 

1040
00:51:09,583 --> 00:51:13,791
拥有一个没有名称的对象会很奇怪 而且可能是一个错误 

1041
00:51:13,791 --> 00:51:16,208
同样 我不希望用户能够输入

1042
00:51:16,208 --> 00:51:18,708
在随机的地方 比如他们的房子 

1043
00:51:18,708 --> 00:51:21,375
至少在哈利波特的世界里 真的有

1044
00:51:21,375 --> 00:51:23,791
只有四栋房子 至少在霍格沃茨 

1045
00:51:23,791 --> 00:51:25,666
又是格兰芬多和赫奇帕奇

1046
00:51:25,666 --> 00:51:29,625
以及拉文克劳和斯莱特林--四所有效房屋的名单 

1047
00:51:29,625 --> 00:51:34,291
如果我以某种方式验证用户的输入确实是

1048
00:51:34,291 --> 00:51:35,541
在那张单子上 

1049
00:51:35,541 --> 00:51:39,916
现在 我可以在我的Get_Student函数中执行所有的验证 

1050
00:51:39,916 --> 00:51:41,750
我可以查一下 名字是空的吗？

1051
00:51:41,750 --> 00:51:44,416
如果是这样的话 不要创建学生对象 

1052
00:51:44,416 --> 00:51:46,666
这栋房子是那四栋房子中的一栋吗？

1053
00:51:46,666 --> 00:51:49,083
如果不是 请不要创建学生对象 

1054
00:51:49,083 --> 00:51:52,750
但这将与学生本身脱钩 

1055
00:51:52,750 --> 00:51:57,625
Get_Student目前仅作为我自己的函数存在于我的Student.py文件中 

1056
00:51:57,625 --> 00:52:01,125
但是类--以及真正的面向对象编程--更多

1057
00:52:01,125 --> 00:52:05,291
通常会鼓励您在内部封装

1058
00:52:05,291 --> 00:52:09,750
类的所有功能 所有与该类相关的功能 

1059
00:52:09,750 --> 00:52:12,375
因此 如果你想验证一个名字是否存在--

1060
00:52:12,375 --> 00:52:14,750
如果你想验证房子是正确 

1061
00:52:14,750 --> 00:52:20,041
从根本上说属于学生这个阶层 

1062
00:52:20,041 --> 00:52:22,583
而不是你在别处写的随机函数

1063
00:52:22,583 --> 00:52:24,875
这只是一种方法 因为 

1064
00:52:24,875 --> 00:52:28,541
如果我们考虑写越来越长的代码 

1065
00:52:28,541 --> 00:52:31,250
很复杂 它应该只是直观的感觉 

1066
00:52:31,250 --> 00:52:34,250
如果你保留所有的房子

1067
00:52:34,250 --> 00:52:37,208
所有的名字和所有与房子相关的代码 

1068
00:52:37,208 --> 00:52:38,708
只是更好的组织 

1069
00:52:38,708 --> 00:52:41,583
把所有相关的代码放在一起 

1070
00:52:41,583 --> 00:52:43,125
会让你更成功

1071
00:52:43,125 --> 00:52:45,166
实际上 这是我们方法论的一部分

1072
00:52:45,166 --> 00:52:47,125
面向对象的编程 

1073
00:52:47,125 --> 00:52:51,916
现在让我来给我的学生换个班

1074
00:52:51,916 --> 00:52:53,875
init方法来实现 

1075
00:52:53,875 --> 00:52:56,375
如果名字是空的--

1076
00:52:56,375 --> 00:52:59,333
所以如果不是name--我们以前见过这种语法 

1077
00:52:59,333 --> 00:53:02,666
如果你在Python中说 如果不是name 

1078
00:53:02,666 --> 00:53:04,500
做这种事的人

1079
00:53:04,500 --> 00:53:07,291
如果name等于 等于 引号 不引号

1080
00:53:07,291 --> 00:53:09,041
但我可以做得更优雅一点

1081
00:53:09,041 --> 00:53:11,958
只是说 如果没有名字 将是更多的Pythonic 

1082
00:53:11,958 --> 00:53:15,583
我想返回一个错误 

1083
00:53:15,583 --> 00:53:17,208
我可能想做这样的事 

1084
00:53:17,208 --> 00:53:18,916
打印缺少的姓名 

1085
00:53:18,916 --> 00:53:20,541
但这还不够 

1086
00:53:20,541 --> 00:53:24,000
仅仅打印缺少的姓名是不够的

1087
00:53:24,000 --> 00:53:26,083
然后让剩下的代码通过 

1088
00:53:26,083 --> 00:53:27,791
好吧 好吧 那我能做什么呢？

1089
00:53:27,791 --> 00:53:30,791
在过去 我们已经看到了另一种技术 我可以做系统退出 

1090
00:53:30,791 --> 00:53:33,583
我可以说一些像缺少名字的东西 我可以在这里

1091
00:53:33,583 --> 00:53:34,750
我可以导入系统 

1092
00:53:34,750 --> 00:53:37,958
但这是一个非常令人讨厌的解决问题的方法 

1093
00:53:37,958 --> 00:53:41,250
只是因为你或者某个同事搞砸了

1094
00:53:41,250 --> 00:53:43,750
并调用了一个具有无效名称的函数 

1095
00:53:43,750 --> 00:53:45,666
你要退出我的整个项目吗

1096
00:53:45,666 --> 00:53:49,750
这反应真的很极端

1097
00:53:49,750 --> 00:53:52,125
如果你的程序

1098
00:53:52,125 --> 00:53:53,041
在跑步的中途 

1099
00:53:53,041 --> 00:53:54,625
你可能想清理一下 

1100
00:53:54,625 --> 00:53:57,958
您可能想要保存有时不想退出程序的文件

1101
00:53:57,958 --> 00:54:01,208
在某些任意行中 只是因为输入无效 

1102
00:54:01,208 --> 00:54:03,333
因此 我认为我们也不想这么做 

1103
00:54:03,333 --> 00:54:07,375
但我们现在确实有一种发出错误信号的机制 

1104
00:54:07,375 --> 00:54:09,500
不幸的是 我不能做这样的事 

1105
00:54:09,500 --> 00:54:13,625
我可以试着一个都不回 然后说 嗯-嗯 这个学生不存在 

1106
00:54:13,625 --> 00:54:15,666
我要一分钱都不还给你 

1107
00:54:15,666 --> 00:54:16,916
但为时已晚 

1108
00:54:16,916 --> 00:54:21,416
如果我们向下滚动到我创建学生的位置 它在第17行

1109
00:54:21,416 --> 00:54:23,083
现在我突出显示了这段代码 

1110
00:54:23,083 --> 00:54:25,541
已经创建了该学生 

1111
00:54:25,541 --> 00:54:28,750
在计算机内存中的某个地方有一个对象

1112
00:54:28,750 --> 00:54:30,375
作为一名学生 这是一种结构 

1113
00:54:30,375 --> 00:54:32,708
只是它里面没有任何价值 

1114
00:54:32,708 --> 00:54:35,541
但因此 现在什么都不回已经太晚了 

1115
00:54:35,541 --> 00:54:36,666
那艘船已经启航了 

1116
00:54:36,666 --> 00:54:37,958
该对象存在 

1117
00:54:37,958 --> 00:54:40,458
你不能突然说 不 不 没有物体 

1118
00:54:40,458 --> 00:54:41,625
有一件物品 

1119
00:54:41,625 --> 00:54:43,583
这取决于你是否发出错误信号 

1120
00:54:43,583 --> 00:54:45,333
如何发出错误信号？

1121
00:54:45,333 --> 00:54:48,083
实际上 我们以前见过这种情况 但我们还没有机会

1122
00:54:48,083 --> 00:54:49,583
制造我们自己的错误 

1123
00:54:49,583 --> 00:54:54,750
原来 在Python中 还有另一个与异常相关的关键字

1124
00:54:54,750 --> 00:54:58,583
它本身用来引发我们的所有异常

1125
00:54:58,583 --> 00:54:59,750
在过去曾被谈论过 

1126
00:54:59,750 --> 00:55:04,500
当您发现值错误或其他类似的异常时 

1127
00:55:04,500 --> 00:55:09,083
和Python一起来 好吧 原来你 程序员可以提出--

1128
00:55:09,083 --> 00:55:12,875
那就是当某些事情真的出了问题时 创建自己的例外--

1129
00:55:12,875 --> 00:55:15,750
还没有错到你想退出并退出整个计划 

1130
00:55:15,750 --> 00:55:18,958
但足以让您以某种方式提醒程序员

1131
00:55:18,958 --> 00:55:20,583
这是一个错误 

1132
00:55:20,583 --> 00:55:23,583
一些不同寻常的东西 以一种非常糟糕的方式--一些东西

1133
00:55:23,583 --> 00:55:29,250
异常已经发生 让他们在需要时尝试捕获该异常 

1134
00:55:29,250 --> 00:55:32,250
因此 让我回到VS代码 并提出建议

1135
00:55:32,250 --> 00:55:36,500
如果用户传入了无效的名称--它只是空的 

1136
00:55:36,500 --> 00:55:37,833
所以没有名字 

1137
00:55:37,833 --> 00:55:39,875
我真正想做的是这件事 

1138
00:55:39,875 --> 00:55:43,041
我想引发一个值错误 

1139
00:55:43,041 --> 00:55:45,208
我们以前也见过数值错误 

1140
00:55:45,208 --> 00:55:47,833
我们以前曾意外地制造了价值错误 

1141
00:55:47,833 --> 00:55:51,416
一般来说 如果他们发生了 你和我都会试图抓住他们 

1142
00:55:51,416 --> 00:55:55,375
嗯 在像Python这样的语言中 这种异常特性的另一面

1143
00:55:55,375 --> 00:55:58,125
作为程序员 您也可以引发异常

1144
00:55:58,125 --> 00:56:00,000
当一些不寻常的事情发生时 

1145
00:56:00,000 --> 00:56:01,791
你甚至可以说得更准确 

1146
00:56:01,791 --> 00:56:05,250
您不必引发泛型值错误并让程序员找出

1147
00:56:05,250 --> 00:56:06,083
哪里出了问题 

1148
00:56:06,083 --> 00:56:10,291
您可以将值错误和Python中的所有异常视为类似的函数

1149
00:56:10,291 --> 00:56:14,583
并向他们传递一条解释性信息 比如 引用 不引用 

1150
00:56:14,583 --> 00:56:17,875
“缺少名字” 至少让程序员在遇到

1151
00:56:17,875 --> 00:56:19,458
这个错误 知道 哦 我搞砸了 

1152
00:56:19,458 --> 00:56:22,833
我不确定该用户是否有名字 

1153
00:56:22,833 --> 00:56:25,125
现在 你想做什么呢？

1154
00:56:25,125 --> 00:56:28,708
现在 如果你是程序员 你可以做这样的事情 

1155
00:56:28,708 --> 00:56:34,708
您可以尝试创建一个学生 除非存在值错误 

1156
00:56:34,708 --> 00:56:37,208
然后你就可以用某种方式来处理它 

1157
00:56:37,208 --> 00:56:39,500
我要用一个圆点 

1158
00:56:39,500 --> 00:56:40,791
你会如何处理这件事 

1159
00:56:40,791 --> 00:56:44,666
但您将使用尝试和接受来处理它 就像我们过去所做的那样 

1160
00:56:44,666 --> 00:56:46,666
这将允许你 作为程序员 

1161
00:56:46,666 --> 00:56:48,166
试图创造出这个学生 

1162
00:56:48,166 --> 00:56:52,291
但如果出了问题 好吧 我还是会处理的 

1163
00:56:52,291 --> 00:56:54,958
所以 这里的新内容是 再一次 这个提升关键字 

1164
00:56:54,958 --> 00:56:59,250
这只是让你和我实际上提出了我们自己的例外

1165
00:56:59,250 --> 00:57:00,458
发出这些错误的信号 

1166
00:57:00,458 --> 00:57:03,000
好吧 让我回到我的代码 我只是

1167
00:57:03,000 --> 00:57:06,208
我要继续下去 不费心尝试或捕捉这个错误 

1168
00:57:06,208 --> 00:57:09,083
现在 我们只专注于提高它 并假设

1169
00:57:09,083 --> 00:57:12,375
从我们的侦察例外中 您可以添加尝试和接受

1170
00:57:12,375 --> 00:57:13,833
在一些地方需要的时候 

1171
00:57:13,833 --> 00:57:16,916
让我回到这里的代码 并建议其他东西可以

1172
00:57:16,916 --> 00:57:18,416
豪斯出事了 

1173
00:57:18,416 --> 00:57:19,791
如果有名字的话 我们就没问题了 

1174
00:57:19,791 --> 00:57:22,083
但如果我们得到了一所房子 但它是无效的 

1175
00:57:22,083 --> 00:57:24,958
我们也应该破例一次

1176
00:57:24,958 --> 00:57:26,208
如果我们这么做呢？

1177
00:57:26,208 --> 00:57:32,208
如果豪斯不在格兰芬多的名单上 

1178
00:57:32,208 --> 00:57:34,708
“赫奇帕奇” 原话是

1179
00:57:34,708 --> 00:57:38,875
我想想 “拉文克劳 ”引用 不引用 或者“斯莱特林 ”

1180
00:57:38,875 --> 00:57:41,833
引用 引用 然后 用我的冒号 让我们

1181
00:57:41,833 --> 00:57:43,416
引发另一种类型的值错误 

1182
00:57:43,416 --> 00:57:45,458
但是 与其引发一般值错误 

1183
00:57:45,458 --> 00:57:49,750
让我们传递一个参数 引用 不引用 “无效的房子 “

1184
00:57:49,750 --> 00:57:52,708
所以我们现在看到了一种能力 

1185
00:57:52,708 --> 00:57:55,916
可以用字典做不到的类 

1186
00:57:55,916 --> 00:58:00,541
如果你给字典添加一个属性 一个键 

1187
00:58:00,541 --> 00:58:02,083
无论如何都要进去

1188
00:58:02,083 --> 00:58:06,000
即使名字是空的 即使房子是完全随机的字符串

1189
00:58:06,000 --> 00:58:07,833
不属于这四所房子的文字

1190
00:58:07,833 --> 00:58:09,333
就会被收入字典里

1191
00:58:09,333 --> 00:58:12,708
但是对于类 通过这个init方法 

1192
00:58:12,708 --> 00:58:17,750
你和我现在可以精确地控制将要安装的东西 如果你愿意的话 

1193
00:58:17,750 --> 00:58:19,041
在这个物体里面 

1194
00:58:19,041 --> 00:58:22,458
你现在对正确性有了更多的控制 

1195
00:58:22,458 --> 00:58:26,583
现在让我继续向下滚动到终端窗口

1196
00:58:26,583 --> 00:58:27,291
并清除它 

1197
00:58:27,291 --> 00:58:29,500
让我运行student.py的Python 

1198
00:58:29,500 --> 00:58:31,250
让我输入一些像哈里 

1199
00:58:31,250 --> 00:58:33,958
让我输入Gryffindor Enter 然后我们看到

1200
00:58:33,958 --> 00:58:35,666
哈利确实是格兰芬多的

1201
00:58:35,666 --> 00:58:37,666
如果我犯了个错误呢？

1202
00:58:37,666 --> 00:58:40,750
如果我运行student.py的Python并输入Harry作为名字 

1203
00:58:40,750 --> 00:58:44,416
但这次输入的是女贞路四号 

1204
00:58:44,416 --> 00:58:47,500
是他长大的地方而不是他真正的霍格沃茨

1205
00:58:47,500 --> 00:58:51,333
现在按下Enter键 您将看到一个值错误 

1206
00:58:51,333 --> 00:58:54,458
但本质上 这不是Python为我们生成的 

1207
00:58:54,458 --> 00:58:56,166
我提出了这个错误 

1208
00:58:56,166 --> 00:58:59,666
因此 如果我在get_student函数中编写更多的代码 

1209
00:58:59,666 --> 00:59:04,666
我也可以用我们常用的try except语法来捕获这个错误 

1210
00:59:04,666 --> 00:59:09,250
所以我们现在所拥有的不仅仅是工具箱中的类 还有更多的功能

1211
00:59:09,250 --> 00:59:12,583
而不仅仅是我们自己去捕捉它们

1212
00:59:12,583 --> 00:59:15,333
但我们自己也要抚养他们

1213
00:59:15,333 --> 00:59:21,708
关于类和init的用法还有这个能力

1214
00:59:21,708 --> 00:59:26,000
在初始化过程中出错时引发异常

1215
00:59:26,000 --> 00:59:29,416
观众：那么如果用户有一个中间名呢？

1216
00:59:29,416 --> 00:59:31,291
名字中间名和姓氏

1217
00:59:31,291 --> 00:59:32,750
你要怎么解决？

1218
00:59:32,750 --> 00:59:35,250
大卫·J·马兰：问得好 

1219
00:59:35,250 --> 00:59:38,916
如果你想让学生有名字、中间名和姓氏 

1220
00:59:38,916 --> 00:59:41,041
我们可以用很多不同的方法来做 

1221
00:59:41,041 --> 00:59:44,458
最简单的 如果--让我清空屏幕 

1222
00:59:44,458 --> 00:59:46,041
我只是暂时这么做 

1223
00:59:46,041 --> 00:59:51,333
让我建议init方法接受第一个参数 一个中间参数 

1224
00:59:51,333 --> 00:59:53,000
最后一个论点 

1225
00:59:53,000 --> 00:59:57,833
然后我想我会在这里做的是最终有第一=第一 

1226
00:59:57,833 --> 01:00:00,916
然后我会对中间和最后做同样的事情 

1227
01:00:00,916 --> 01:00:05,541
中间和中间 最后和最后 

1228
01:00:05,541 --> 01:00:08,583
接下来我要做的是 

1229
01:00:08,583 --> 01:00:11,208
当我问用户他们的名字时 

1230
01:00:11,208 --> 01:00:12,750
我可能真的需要全力以赴 

1231
01:00:12,750 --> 01:00:15,166
我可能要先问他们的名字

1232
01:00:15,166 --> 01:00:18,916
并将其存储在一个名为first的变量中 因此首先传入 

1233
01:00:18,916 --> 01:00:21,833
我可能同样需要问他们的中间名

1234
01:00:21,833 --> 01:00:25,500
并将其存储在一个变量中 然后传入第二个参数 middle 

1235
01:00:25,500 --> 01:00:28,375
最后 如果你愿意 让我继续创造

1236
01:00:28,375 --> 01:00:31,916
第三个变量last 输入他们的姓氏 

1237
01:00:31,916 --> 01:00:34,041
把它也传进去 

1238
01:00:34,041 --> 01:00:38,125
我可以只使用一个输入 只要求他们输入全名 

1239
01:00:38,125 --> 01:00:42,583
所以输入大卫·马兰 回车 或者大卫·J·马兰--三个都是 

1240
01:00:42,583 --> 01:00:45,666
也许我可以用Python的split函数

1241
01:00:45,666 --> 01:00:47,583
也许是一个正则表达式来区分它 

1242
01:00:47,583 --> 01:00:49,625
这可能会很麻烦 因为

1243
01:00:49,625 --> 01:00:52,083
他们的名字不会只有两三个 

1244
01:00:52,083 --> 01:00:53,458
他们可能有四个或五个 

1245
01:00:53,458 --> 01:00:55,958
因此 有时使用多个提示可能更好 

1246
01:00:55,958 --> 01:00:58,291
但这不是问题 因为 在上课的时候 

1247
01:00:58,291 --> 01:01:02,291
如果我们想要 我们有表现力接受更多的论点 

1248
01:01:02,291 --> 01:01:04,041
如果我们愿意 我们甚至可以列一张单子 

1249
01:01:04,041 --> 01:01:06,916
但我认为我们可能会想要进行更多的错误检查 

1250
01:01:06,916 --> 01:01:11,458
不仅是名字 而且是第一次 然后可能是中间 然后是

1251
01:01:11,458 --> 01:01:12,208
也许是最后一次 

1252
01:01:12,208 --> 01:01:14,541
所以它只是越来越多的代码 尽管会有

1253
01:01:14,541 --> 01:01:17,041
或许也有巩固这一点的方法 

1254
01:01:17,041 --> 01:01:22,500
让我把所有这些都撤销 看看现在课堂上是否还有其他问题 

1255
01:01:22,500 --> 01:01:24,291
观众：我想上课是我

1256
01:01:24,291 --> 01:01:25,916
在项目开始时可能会做的事情 

1257
01:01:25,916 --> 01:01:28,583
我可以将它们放在不同的文件中并导入它们吗

1258
01:01:28,583 --> 01:01:32,083
根据需要添加到我的项目中 还是我的主代码中？

1259
01:01:32,083 --> 01:01:33,208
大卫·J·马兰：当然 

1260
01:01:33,208 --> 01:01:34,208
这是一个非常好的问题 

1261
01:01:34,208 --> 01:01:36,083
你可以想象想要利用这个学生

1262
01:01:36,083 --> 01:01:40,666
类 不仅在Student.py中 而且在您的其他文件或其他项目中 

1263
01:01:40,666 --> 01:01:44,458
当然 您可以创建自己的类库

1264
01:01:44,458 --> 01:01:48,000
通过将学生类放入您自己的模块或包中 

1265
01:01:48,000 --> 01:01:50,583
根据我们过去对图书馆更一般的讨论 

1266
01:01:50,583 --> 01:01:52,250
当然 你可以做到的 

1267
01:01:52,250 --> 01:01:54,833
今天晚些时候 我们看到的是我们实际上

1268
01:01:54,833 --> 01:01:58,166
我以前一直在第三方库中使用类--你和我 

1269
01:01:58,166 --> 01:02:00,416
所以你也完全可以做同样的事情 

1270
01:02:00,416 --> 01:02:03,666
再问一个关于课上的问题如何？

1271
01:02:03,666 --> 01:02:06,541
听众：你可以在类中有可选变量吗？

1272
01:02:06,541 --> 01:02:09,666
第二 你能有自己的错误名称吗 比如--

1273
01:02:09,666 --> 01:02:13,250
让我们以自我为中心 说我想提出Eric Error？

1274
01:02:13,250 --> 01:02:16,166
大卫·J·马兰：简而言之 是的 

1275
01:02:16,166 --> 01:02:18,750
这些初始化函数更像是Python函数

1276
01:02:18,750 --> 01:02:21,000
一般说来 尽管它们很特别 但它们

1277
01:02:21,000 --> 01:02:23,666
它将自动由Python为您调用 

1278
01:02:23,666 --> 01:02:25,375
但如果你想让房子变成可选的 

1279
01:02:25,375 --> 01:02:26,750
你可以做这样的事情 

1280
01:02:26,750 --> 01:02:31,791
您可以在init函数的签名中给它一个缺省值

1281
01:02:31,791 --> 01:02:34,250
可以这么说--在第二行第一行代码中 

1282
01:02:34,250 --> 01:02:36,875
这样我就不用进屋了 

1283
01:02:36,875 --> 01:02:39,750
在这种情况下 我将继续传递姓名和住所 

1284
01:02:39,750 --> 01:02:41,500
但你可以把这些设置为可选的 

1285
01:02:41,500 --> 01:02:45,458
是的 关于你的第二个问题 如果你想有你自己的错误信息 

1286
01:02:45,458 --> 01:02:50,791
就像Eric错误一样 您实际上可以创建自己的Eric错误异常 

1287
01:02:50,791 --> 01:02:53,000
稍后我们会看到 实际上

1288
01:02:53,000 --> 01:02:58,041
一整套存在的例外 你也可以发明这些例外 

1289
01:02:58,041 --> 01:03:01,375
不过 让我提议 我们现在介绍

1290
01:03:01,375 --> 01:03:06,250
另一个方面是 我们尝试打印出学生的样子 

1291
01:03:06,250 --> 01:03:08,916
目前 如果我向下滚动到我的主要功能 

1292
01:03:08,916 --> 01:03:11,791
我还在非常手动地打印这名学生的姓名和住处 

1293
01:03:11,791 --> 01:03:14,833
我要进入物体的内部 做学生 名字 

1294
01:03:14,833 --> 01:03:17,708
我要再次进入这个物体 让学生 房子 

1295
01:03:17,708 --> 01:03:20,750
只是想看看这名学生来自哪里 

1296
01:03:20,750 --> 01:03:23,666
但如果我能把学生的指纹印出来 

1297
01:03:23,666 --> 01:03:25,583
就像我已经打印了几个星期--

1298
01:03:25,583 --> 01:03:29,458
ANY、INT或FLOAT、STR或任何其他数据类型？

1299
01:03:29,458 --> 01:03:32,500
好吧 让我们看看如果我试着打印学生会发生什么 

1300
01:03:32,500 --> 01:03:36,166
而不是手动进入并试图自己创建这句话 

1301
01:03:36,166 --> 01:03:39,250
好的 在我的终端窗口中--让我继续运行PYTHON of Student.py

1302
01:03:39,250 --> 01:03:40,166
再来一次 

1303
01:03:40,166 --> 01:03:41,250
让我输入哈里 

1304
01:03:41,250 --> 01:03:42,541
让我输入格兰芬多 

1305
01:03:42,541 --> 01:03:50,333
看 哈利--哇 好的 主要学生对象在0x102733e80 

1306
01:03:50,333 --> 01:03:51,916
好吧 这是怎么回事？

1307
01:03:51,916 --> 01:03:53,708
如果你要运行相同的代码 你

1308
01:03:53,708 --> 01:03:56,000
可能会在您的计算机上看到一些不同的内容

1309
01:03:56,000 --> 01:03:57,208
就这个数字而言 

1310
01:03:57,208 --> 01:04:01,958
但你真正看到的是潜在的表示 作为一个字符串 

1311
01:04:01,958 --> 01:04:03,625
这一特定物体的 

1312
01:04:03,625 --> 01:04:06,875
特别是 您可以看到它在计算机内存中的什么位置 

1313
01:04:06,875 --> 01:04:12,750
这个数字30x102733e80实质上指的是一个特定的位置

1314
01:04:12,750 --> 01:04:14,541
在计算机的内存或RAM中 

1315
01:04:14,541 --> 01:04:19,166
这对我或你来说都不是很有趣 或者 总的来说 

1316
01:04:19,166 --> 01:04:22,250
程序员 但这只是默认的描述方式 

1317
01:04:22,250 --> 01:04:25,791
通过印刷品 这是什么东西 

1318
01:04:25,791 --> 01:04:28,250
但我也可以推翻这一点 

1319
01:04:28,250 --> 01:04:31,791
原来 在Python中还有其他特殊的方法

1320
01:04:31,791 --> 01:04:32,958
当涉及到课程时--

1321
01:04:32,958 --> 01:04:36,375
不只是下划线 初始化 下划线 

1322
01:04:36,375 --> 01:04:40,541
但是 继续使用相同模式 在下划线、字符串

1323
01:04:40,541 --> 01:04:42,041
下划线 

1324
01:04:42,041 --> 01:04:47,000
因此 这也是一个特殊的方法 如果您在类中定义它 

1325
01:04:47,000 --> 01:04:50,541
Python将自动调用此函数

1326
01:04:50,541 --> 01:04:56,541
任何时候 某个其他函数想要将您的对象视为字符串 

1327
01:04:56,541 --> 01:04:59,750
Print希望将您的对象显示为字符串 

1328
01:04:59,750 --> 01:05:02,958
但默认情况下 如果您的类中没有定义此方法 

1329
01:05:02,958 --> 01:05:06,416
它将打印出非常难看的深奥的化身 

1330
01:05:06,416 --> 01:05:10,416
其中写着Main__ 学生对象在0x 点 

1331
01:05:10,416 --> 01:05:13,250
那么 我该如何定义自己的str函数呢？

1332
01:05:13,250 --> 01:05:17,041
好了 回到VS Code 让我提议我进入

1333
01:05:17,041 --> 01:05:23,416
不仅定义__init 还让我在这个类中定义第二个函数

1334
01:05:23,416 --> 01:05:25,041
这里 如下所示--

1335
01:05:25,041 --> 01:05:28,416
定义__字符串__ 

1336
01:05:28,416 --> 01:05:29,333
有两个 

1337
01:05:29,333 --> 01:05:32,541
尽管VS代码中的字体将这两个下划线放得如此之近 

1338
01:05:32,541 --> 01:05:34,375
它看起来就像是一个更长的下划线 

1339
01:05:34,375 --> 01:05:37,583
确实有两个 在左边和右边 就像init一样 

1340
01:05:37,583 --> 01:05:42,791
这一论点只有一个论点 按照惯例 总是被称为自我

1341
01:05:42,791 --> 01:05:44,500
这样你就可以访问它了 

1342
01:05:44,500 --> 01:05:47,708
然后 在冒号后面缩进 

1343
01:05:47,708 --> 01:05:51,125
我将继续创建格式字符串并返回它 

1344
01:05:51,125 --> 01:05:53,500
所以让我继续下去 回到--

1345
01:05:53,500 --> 01:05:56,375
不如先说个普通的词 比如“一个学生” 

1346
01:05:56,375 --> 01:05:58,916
所以我甚至不会费心去找出

1347
01:05:58,916 --> 01:06:00,625
这个学生的名字或住处是什么 

1348
01:06:00,625 --> 01:06:02,875
我只会一直返回“一个学生” 

1349
01:06:02,875 --> 01:06:08,666
现在让我回到我之前的代码 它在第16行有print(Student) 

1350
01:06:08,666 --> 01:06:13,041
让我清除我的终端窗口 并重新运行Student.py的Python 回车 

1351
01:06:13,041 --> 01:06:14,958
输入哈里 输入格兰芬多 

1352
01:06:14,958 --> 01:06:17,333
上一次 我看到了非常神秘的输出 

1353
01:06:17,333 --> 01:06:20,958
这一次 我看到 更笼统地说 “一个学生” 

1354
01:06:20,958 --> 01:06:23,375
更具可读性 但不太有启发性 

1355
01:06:23,375 --> 01:06:24,541
这是哪个学生？

1356
01:06:24,541 --> 01:06:31,791
注意 双下划线字符串方法在这个self参数中接受

1357
01:06:31,791 --> 01:06:36,708
默认情况下 这正是Python作者设计此方法的方式 

1358
01:06:36,708 --> 01:06:41,833
它将始终被传递一个对当前学生对象的引用 

1359
01:06:41,833 --> 01:06:43,000
我这么说是什么意思？

1360
01:06:43,000 --> 01:06:45,916
当调用第6行上的这行代码时 

1361
01:06:45,916 --> 01:06:48,666
打印 因为它希望它会得到一个字符串 

1362
01:06:48,666 --> 01:06:52,750
将触发下划线、字符串、下划线

1363
01:06:52,750 --> 01:06:54,458
给要调用的方法加下划线 

1364
01:06:54,458 --> 01:06:58,416
对于您来说 Python将自动传递到该方法中

1365
01:06:58,416 --> 01:07:01,208
引用正在尝试成为的对象

1366
01:07:01,208 --> 01:07:05,291
打印出来 这样作为程序员 您就可以做这样的事情 

1367
01:07:05,291 --> 01:07:08,000
和往常一样 这里有一个带有双引号的f字符串 

1368
01:07:08,000 --> 01:07:10,458
我要用一些花括号 然后说打印出来

1369
01:07:10,458 --> 01:07:14,250
来自self.house的self.name 

1370
01:07:14,250 --> 01:07:17,458
所以我刚才所做的并没有什么新意 

1371
01:07:17,458 --> 01:07:19,958
这只是一个f弦--开头是f 

1372
01:07:19,958 --> 01:07:22,708
两个双引号 几对花括号 

1373
01:07:22,708 --> 01:07:28,750
但这是因为 可以说 这个字符串方法会自动传递给自己 

1374
01:07:28,750 --> 01:07:32,333
对当前对象的引用 我可以进入该对象的内部

1375
01:07:32,333 --> 01:07:33,083
然后取下名字 

1376
01:07:33,083 --> 01:07:36,000
我可以再一次进入那个物体里面 然后拿到房子 

1377
01:07:36,000 --> 01:07:38,791
所以现在 当我回到我的终端窗口--

1378
01:07:38,791 --> 01:07:41,041
此前 它只是打印出了一个学生 

1379
01:07:41,041 --> 01:07:44,416
但现在 如果我运行Student.py的Python 输入--

1380
01:07:44,416 --> 01:07:48,083
输入Harry 输入Gryffindor 然后再按一次Enter 

1381
01:07:48,083 --> 01:07:50,750
哈利又是从格兰芬多来的 

1382
01:07:50,750 --> 01:07:52,500
但如果我再运行一次--

1383
01:07:52,500 --> 01:07:57,125
比方说 德拉科来自斯莱特林 回车 

1384
01:07:57,125 --> 01:07:58,625
德拉科来自斯莱特林 

1385
01:07:58,625 --> 01:08:04,291
现在 它针对我们试图打印的特定对象进行了定制 

1386
01:08:04,291 --> 01:08:08,250
关于这个功能的问题--

1387
01:08:08,250 --> 01:08:11,666
此DUnder字符串方法 

1388
01:08:11,666 --> 01:08:14,541
观众：下划线还有什么要强调的吗？

1389
01:08:14,541 --> 01:08:16,666
字符串方法能做什么？

1390
01:08:16,666 --> 01:08:19,416
另一个问题是 str和epr之间有什么不同 

1391
01:08:19,416 --> 01:08:20,750
大卫·J·马兰：问得好 

1392
01:08:20,750 --> 01:08:24,458
因此 还有许多其他方法随Python类一起提供

1393
01:08:24,458 --> 01:08:26,041
这是以下划线开始的 

1394
01:08:26,041 --> 01:08:27,958
我们只是触及了皮毛 我们几乎会

1395
01:08:27,958 --> 01:08:29,083
主要集中在这些方面 

1396
01:08:29,083 --> 01:08:30,833
但是 是的 还有很多其他的 我们会

1397
01:08:30,833 --> 01:08:33,666
至少在一小段时间内能看到另一个 

1398
01:08:33,666 --> 01:08:37,375
其中有一个名为REPR的软件 它是

1399
01:08:37,375 --> 01:08:39,583
Python对象的表示形式 

1400
01:08:39,583 --> 01:08:43,000
一般而言 下划线、REPR、

1401
01:08:43,000 --> 01:08:45,791
下划线方法是给开发人员看的 

1402
01:08:45,791 --> 01:08:49,166
它通常比《格兰芬多来的哈利》有更多的信息 

1403
01:08:49,166 --> 01:08:53,083
它还会说明它是什么类型的对象 比如学生、首都

1404
01:08:53,083 --> 01:08:56,583
S 而下划线、字符串、下划线通常是

1405
01:08:56,583 --> 01:08:58,125
面向用户--

1406
01:08:58,125 --> 01:09:01,500
该程序的用户 它的目的是更友好的用户 

1407
01:09:01,500 --> 01:09:04,208
但这两个都可以在你认为合适的情况下被推翻 

1408
01:09:04,208 --> 01:09:08,041
好吧 现在让我提议 我们继续我们停止的学生

1409
01:09:08,041 --> 01:09:11,958
添加更多的功能 但不仅仅是这些特殊的方法

1410
01:09:11,958 --> 01:09:15,166
如双下划线init和双下划线str 

1411
01:09:15,166 --> 01:09:18,750
让我们创建我们自己的方法 因为这是真正的力量所在

1412
01:09:18,750 --> 01:09:21,875
以及类的灵活性 如果你和我都是程序员

1413
01:09:21,875 --> 01:09:25,291
可以发明专门针对学生的新功能 

1414
01:09:25,291 --> 01:09:29,125
例如 霍格沃茨的学生 在校期间 

1415
01:09:29,125 --> 01:09:31,500
学习如何施展某种类型的咒语 

1416
01:09:31,500 --> 01:09:34,083
所以当他们说 Expeto Patronum时 

1417
01:09:34,083 --> 01:09:36,083
从他们的魔杖里出来的东西通常类似于

1418
01:09:36,083 --> 01:09:37,458
一种动物之类的东西 

1419
01:09:37,458 --> 01:09:40,000
这是一种特殊的咒语 他们必须练习和练习 

1420
01:09:40,000 --> 01:09:44,041
所以让我们看看我们是否不能存储 不仅仅是学生的名字和他们的房子 

1421
01:09:44,041 --> 01:09:47,041
还有他们的“守护神” 实际上 他们

1422
01:09:47,041 --> 01:09:48,625
在使用这个咒语时召唤 

1423
01:09:48,625 --> 01:09:50,750
好吧 让我继续清理我的终端窗口 

1424
01:09:50,750 --> 01:09:56,583
在我代码的顶部 在学生的init方法中 让我继续

1425
01:09:56,583 --> 01:10:00,875
并开始期待除了self之外的第三个参数 这会自动

1426
01:10:00,875 --> 01:10:02,833
被传递进来 被称为守护神 

1427
01:10:02,833 --> 01:10:06,125
现在 我不会担心 关于验证

1428
01:10:06,125 --> 01:10:10,041
官方有效赞助人名单中的赞助人或赞助人 

1429
01:10:10,041 --> 01:10:13,041
相反 我将继续并盲目地分配

1430
01:10:13,041 --> 01:10:16,458
它属于自己 守护神=守护神 而我们

1431
01:10:16,458 --> 01:10:19,083
现在将允许用户输入他们想要的任何内容 

1432
01:10:19,083 --> 01:10:21,333
但是我当然可以添加更多的错误检查

1433
01:10:21,333 --> 01:10:25,583
如果我想把赞助人限制在这里的特定名单上 

1434
01:10:25,583 --> 01:10:29,000
现在让我继续并提示用户输入此守护神 

1435
01:10:29,000 --> 01:10:33,666
在我的Get_Student函数中 通过定义一个变量

1436
01:10:33,666 --> 01:10:36,375
被称为守护神或其他任何东西 提示用户

1437
01:10:36,375 --> 01:10:38,333
为他们的守护神提供意见 

1438
01:10:38,333 --> 01:10:42,708
现在我要继续 传递第三个变量 

1439
01:10:42,708 --> 01:10:46,041
因此 在精神上类似于只是添加越来越多的属性

1440
01:10:46,041 --> 01:10:47,875
对全班同学来说 我要把三门课都通过

1441
01:10:47,875 --> 01:10:49,791
而不是只有两个 

1442
01:10:49,791 --> 01:10:52,333
我还不打算用这个值做任何有趣的事情 

1443
01:10:52,333 --> 01:10:55,583
但为了确保我不会因为破坏密码而让事情更糟 

1444
01:10:55,583 --> 01:10:57,875
让我运行Student.py的Python 

1445
01:10:57,875 --> 01:10:59,083
我来打哈里 

1446
01:10:59,083 --> 01:11:00,416
我会打进格兰芬多 

1447
01:11:00,416 --> 01:11:02,500
结果发现他的守护神是一只雄鹿 

1448
01:11:02,500 --> 01:11:06,125
然后按回车键我还没有看到他的庇护在我的输出中是什么

1449
01:11:06,125 --> 01:11:08,708
因为我还没有更改我的str方法 

1450
01:11:08,708 --> 01:11:10,625
但至少我没有任何语法错误 

1451
01:11:10,625 --> 01:11:12,958
所以至少我没有让事情变得更糟 

1452
01:11:12,958 --> 01:11:16,416
但是假设 现在 我想要有功能 而不仅仅是

1453
01:11:16,416 --> 01:11:19,708
用于初始化学生并打印出学生 

1454
01:11:19,708 --> 01:11:23,666
如果我的班级真的是一名学生 我能做的是

1455
01:11:23,666 --> 01:11:27,416
不仅仅是记住有关学生数据的信息 

1456
01:11:27,416 --> 01:11:31,291
与字典不同 课堂的强大之处在于 

1457
01:11:31,291 --> 01:11:36,708
is that classes can have, not just variables or instance variables--

1458
01:11:36,708 --> 01:11:38,625
those attributes we keep creating.

1459
01:11:38,625 --> 01:11:42,458
They can also have functions built in, a.k.a.

1460
01:11:42,458 --> 01:11:43,083
methods.

1461
01:11:43,083 --> 01:11:45,958
When a function is inside of a class, it's called a "method,"

1462
01:11:45,958 --> 01:11:47,666
but it's still just a function.

1463
01:11:47,666 --> 01:11:51,000
At this point, we've seen two functions already-- two methods--

1464
01:11:51,000 --> 01:11:54,958
called a double underscore init and double underscore str,

1465
01:11:54,958 --> 01:11:57,958
but those are special methods in that they just work.

1466
01:11:57,958 --> 01:12:01,416
If you define them, Python calls them automatically for you.

1467
01:12:01,416 --> 01:12:04,958
But what if you wanted to create more functionality for a student

1468
01:12:04,958 --> 01:12:09,000
so that your class really represents this real world, or maybe "fantasy"

1469
01:12:09,000 --> 01:12:13,375
world notion of a student, where students not only have names and houses

1470
01:12:13,375 --> 01:12:16,375
and patronuses; they also have functionality.

1471
01:12:16,375 --> 01:12:22,541
They have actions they can perform like casting a charm, a spell, magically.

1472
01:12:22,541 --> 01:12:26,333
Could we implement, therefore, a function called charm, that

1473
01:12:26,333 --> 01:12:30,291
actually uses their magical knowledge?

1474
01:12:30,291 --> 01:12:33,791
Well, let's go ahead and define our very own function as follows.

1475
01:12:33,791 --> 01:12:37,583
Let me clear my terminal window, scroll back up to my student class.

1476
01:12:37,583 --> 01:12:40,916
And instead of creating yet another function that's special,

1477
01:12:40,916 --> 01:12:45,416
with double underscores, I'm going to invent my own function, or method,

1478
01:12:45,416 --> 01:12:46,916
inside of this class.

1479
01:12:46,916 --> 01:12:51,500
I want to give Harry and Hermione and all of the other students

1480
01:12:51,500 --> 01:12:55,000
the ability to cast charms, so I'm going to define a function that I

1481
01:12:55,000 --> 01:12:57,291
can completely, on my own, call charm.

1482
01:12:57,291 --> 01:12:59,125
I could call this function anything I want.

1483
01:12:59,125 --> 01:13:01,708
But because it's a method inside of a class,

1484
01:13:01,708 --> 01:13:06,083
the convention is that it's always going to take at least one argument, called

1485
01:13:06,083 --> 01:13:11,000
self, by convention so that you have access to the current object,

1486
01:13:11,000 --> 01:13:13,083
even if you don't plan to use it, per se.

1487
01:13:13,083 --> 01:13:16,708
All right, let me go ahead and propose that we implement charm in such a way

1488
01:13:16,708 --> 01:13:21,750
that the method returns an emoji that's appropriate for each student's

1489
01:13:21,750 --> 01:13:23,125
patronus.

1490
01:13:23,125 --> 01:13:25,750
如何实现这一点--嗯 在Charm方法内部 

1491
01:13:25,750 --> 01:13:29,041
让我们继续比赛吧 帕特诺斯 

1492
01:13:29,041 --> 01:13:31,416
它是包含一个字符串的实例变量 该字符串

1493
01:13:31,416 --> 01:13:33,458
代表每个学生的资助人 

1494
01:13:33,458 --> 01:13:38,208
如果它与一只雄鹿匹配 例如 对于哈里 让我们继续

1495
01:13:38,208 --> 01:13:40,333
并返回最接近的表情符号--

1496
01:13:40,333 --> 01:13:41,750
这匹马在这里 

1497
01:13:41,750 --> 01:13:44,625
以水獭为例呢？

1498
01:13:44,625 --> 01:13:49,708
好吧 那样的话 让我们继续回去吧 哦 也许是最接近的匹配

1499
01:13:49,708 --> 01:13:52,583
这可能就是这个表情符号 

1500
01:13:52,583 --> 01:13:57,000
让我们看看 在a的情况下 对于罗恩 而不是赫敏

1501
01:13:57,000 --> 01:14:02,791
一只杰克·罗素梗犬 让我们继续前进并返回--

1502
01:14:02,791 --> 01:14:04,625
在这里没有那么多的选择 

1503
01:14:04,625 --> 01:14:08,750
如果是那样的话 我们为什么不把最可爱的狗还回去呢？

1504
01:14:08,750 --> 01:14:14,250
在不承认赞助人的情况下 

1505
01:14:14,250 --> 01:14:16,375
就像覆盖像德拉科这样的人一样 我们继续

1506
01:14:16,375 --> 01:14:19,750
并像过去一样使用使用下划线的默认大小写 

1507
01:14:19,750 --> 01:14:22,791
让我们继续下去 回到这个--哦 会发生什么

1508
01:14:22,791 --> 01:14:24,250
如果有人没有守护神呢？

1509
01:14:24,250 --> 01:14:26,541
为什么我们不直接看看魔杖呢？

1510
01:14:26,541 --> 01:14:28,958
似乎失败了 就像这件事一样？

1511
01:14:28,958 --> 01:14:31,333
好的 现在 与其只打印学生的照片 

1512
01:14:31,333 --> 01:14:33,375
让我们开始打印他们的实际赞助人吧 

1513
01:14:33,375 --> 01:14:36,000
因此 我将在这里介绍我的主要功能 

1514
01:14:36,000 --> 01:14:39,250
使用Get_Student函数 我仍将获得一名学生 

1515
01:14:39,250 --> 01:14:44,208
但是 与其打印学生 不如让我们宣布“Exspecto Patronum！”

1516
01:14:44,208 --> 01:14:46,791
仅将其作为纯文本打印出来 

1517
01:14:46,791 --> 01:14:50,750
现在让我们继续打印出来 不是学生 而是 

1518
01:14:50,750 --> 01:14:54,416
返回值属于自己的魅力方法 

1519
01:14:54,416 --> 01:14:58,583
因此 让我返回到我的终端窗口并运行Student.py的Python

1520
01:14:58,583 --> 01:14:59,708
然后进入 

1521
01:14:59,708 --> 01:15:01,250
名字--让我们从哈里开始 

1522
01:15:01,250 --> 01:15:03,500
他住在格兰芬多 

1523
01:15:03,500 --> 01:15:05,083
守护神是只雄鹿 

1524
01:15:05,083 --> 01:15:06,291
让我们来看看--

1525
01:15:06,291 --> 01:15:08,125
期待守护神！

1526
01:15:08,125 --> 01:15:10,708
当然 我们还会看到雄鹿表情符号 

1527
01:15:10,708 --> 01:15:13,333
像德拉科这样的人呢 至少在书上是这样的 

1528
01:15:13,333 --> 01:15:15,333
没有已知的守护神？

1529
01:15:15,333 --> 01:15:17,416
好吧 让我们继续清理我的终端窗口 

1530
01:15:17,416 --> 01:15:22,625
重新运行Student.py的Python 这一次 让我们键入Draco作为名称 

1531
01:15:22,625 --> 01:15:25,750
斯莱特林为豪斯 守护神未知 

1532
01:15:25,750 --> 01:15:27,583
所以我要继续按Enter键 

1533
01:15:27,583 --> 01:15:29,666
现在 Expeto Patronum！

1534
01:15:29,666 --> 01:15:32,916
取而代之的是 它只发出了嘶嘶声 

1535
01:15:32,916 --> 01:15:38,208
好吧 让我提议 现在 我们删除这个守护神代码

1536
01:15:38,208 --> 01:15:41,833
简化我们的世界 专注于其他一些核心

1537
01:15:41,833 --> 01:15:43,208
类的能力 

1538
01:15:43,208 --> 01:15:44,958
所以冒着让人失望的风险 我要去

1539
01:15:44,958 --> 01:15:47,916
为了摆脱所有这些美丽的表情符号和魅力 

1540
01:15:47,916 --> 01:15:51,875
我要继续下去 现在停止向用户索要他们的守护神 

1541
01:15:51,875 --> 01:15:54,708
我不会再把它传递给init了 

1542
01:15:54,708 --> 01:15:57,541
我在这里不会再这么做了 

1543
01:15:57,541 --> 01:16:03,333
我要继续 恢复我们对印刷品的使用 学生

1544
01:16:03,333 --> 01:16:06,541
在这里 我要继续下去 摆脱这里的守护神 

1545
01:16:06,541 --> 01:16:10,541
所以 从根本上说 只要取消我们刚刚创造的所有有趣的魅力 

1546
01:16:10,541 --> 01:16:16,291
所以我们现在回到故事的这一点 我们有一个学生班 

1547
01:16:16,291 --> 01:16:18,041
只有两种方法--

1548
01:16:18,041 --> 01:16:19,416
Init和str.

1549
01:16:19,416 --> 01:16:21,375
当然 第一个镜头是赛尔夫

1550
01:16:21,375 --> 01:16:25,125
像往常一样 第一个论点 加上另外两个--名字和房子 

1551
01:16:25,125 --> 01:16:26,208
不再有守护神了 

1552
01:16:26,208 --> 01:16:28,041
我们正在验证上面的名字 

1553
01:16:28,041 --> 01:16:29,833
我们在这下面验证豪斯 

1554
01:16:29,833 --> 01:16:32,375
然后我们会分别指定名字和房子 

1555
01:16:32,375 --> 01:16:35,625
也称为name和house的两个实例变量 

1556
01:16:35,625 --> 01:16:38,875
但我们使用SELF来访问当前对象 

1557
01:16:38,875 --> 01:16:40,750
将这些值存储在其中 

1558
01:16:40,750 --> 01:16:44,583
然后我们在这里仍然有我们的str方法 它接受一个参数--

1559
01:16:44,583 --> 01:16:46,208
默认情况下是Self 仅此而已 

1560
01:16:46,208 --> 01:16:49,750
该函数将在任何时候被自动调用

1561
01:16:49,750 --> 01:16:52,625
您想要将学生对象转换为字符串 

1562
01:16:52,625 --> 01:16:55,125
就像印刷品在这里可能想要做的那样 

1563
01:16:55,125 --> 01:16:57,791
所以让我继续下去 只是确保我没有打碎任何东西 

1564
01:16:57,791 --> 01:16:59,750
让我运行Student.py的Python 

1565
01:16:59,750 --> 01:17:00,916
我来打哈里 

1566
01:17:00,916 --> 01:17:03,041
我会输入格兰芬多 回车 

1567
01:17:03,041 --> 01:17:04,416
好了 我们又开始营业了 

1568
01:17:04,416 --> 01:17:08,166
魅力和守护神消失了 但至少我又回到了一个

1569
01:17:08,166 --> 01:17:10,250
我有名字和房子的地方 

1570
01:17:10,250 --> 01:17:14,416
但事实证明 目前 我们对类的使用

1571
01:17:14,416 --> 01:17:20,083
并不是很强健 尽管我们有这个机制 非常聪明 

1572
01:17:20,083 --> 01:17:23,041
如果可以的话 在我们的初始方法中

1573
01:17:23,041 --> 01:17:27,125
我们正在验证名字和房子 确保名字不是空的 

1574
01:17:27,125 --> 01:17:32,625
并确保这所房子是霍格沃茨四所房子中的一所有效的房子 

1575
01:17:32,625 --> 01:17:35,208
事实证明 课程仍然会让我

1576
01:17:35,208 --> 01:17:38,541
获取那些属性 那些所谓的实例变量 

1577
01:17:38,541 --> 01:17:40,750
无论如何都要用点符号 

1578
01:17:40,750 --> 01:17:44,500
那么让我向下滚动 试着以一种相反的方式来做这件事 

1579
01:17:44,500 --> 01:17:48,500
假设在线16我继续调用Get_Student 

1580
01:17:48,500 --> 01:17:52,541
和以前一样存在 然后我将返回值存储在一个学生

1581
01:17:52,541 --> 01:17:54,791
变量--同样在第16行 

1582
01:17:54,791 --> 01:18:00,291
这将确保Get_Student被调用 它调用输入和输入 

1583
01:18:00,291 --> 01:18:02,916
然后它调用学生构造函数 

1584
01:18:02,916 --> 01:18:05,541
它自动调用该init方法 

1585
01:18:05,541 --> 01:18:08,458
因此 通过我们如何布局我的代码 我们

1586
01:18:08,458 --> 01:18:11,750
要确保名字不是空的 房子肯定是

1587
01:18:11,750 --> 01:18:12,916
这四个值之一 

1588
01:18:12,916 --> 01:18:16,541
我的纠错--或者说错误检查已经到位 

1589
01:18:16,541 --> 01:18:20,708
但如果我有一点敌意 我仍然可以绕过它 

1590
01:18:20,708 --> 01:18:25,541
假设--好吧 需要我输入哈利和格兰芬多吗？

1591
01:18:25,541 --> 01:18:28,083
我要继续输入Student.house 

1592
01:18:28,083 --> 01:18:31,541
等于 引号 引号 “女贞路四号 ”

1593
01:18:31,541 --> 01:18:33,333
你阻止不了我的 

1594
01:18:33,333 --> 01:18:34,083
为什么？

1595
01:18:34,083 --> 01:18:36,708
嗯 事实证明 使用类和对象

1596
01:18:36,708 --> 01:18:40,375
因此 您和我仍然可以访问这些实例变量

1597
01:18:40,375 --> 01:18:42,083
使用这个熟悉的点符号 

1598
01:18:42,083 --> 01:18:45,125
这就是我们如何开始类的故事--只需设置这些属性

1599
01:18:45,125 --> 01:18:45,875
我们自己 

1600
01:18:45,875 --> 01:18:48,541
但您也可以读取这些属性本身

1601
01:18:48,541 --> 01:18:50,750
如果你想的话以后再换 

1602
01:18:50,750 --> 01:18:55,833
这将有效地绕过IF条件和另一个IF条件

1603
01:18:55,833 --> 01:19:00,000
在我们的init方法中 因为只有当你第一次

1604
01:19:00,000 --> 01:19:02,125
创建学生对象 

1605
01:19:02,125 --> 01:19:04,541
现在没有什么能阻止我

1606
01:19:04,541 --> 01:19:08,291
从只是改变房子或名字后 

1607
01:19:08,291 --> 01:19:12,541
所以如果我现在清除终端窗口并运行student.py的Python 

1608
01:19:12,541 --> 01:19:16,208
我还是会输入哈利和格兰芬多来满足我的要求

1609
01:19:16,208 --> 01:19:17,916
这房子是这四个之一 

1610
01:19:17,916 --> 01:19:21,375
但是当它被打印出来的时候 注意 我还是覆盖了它 

1611
01:19:21,375 --> 01:19:26,083
因此 虽然类确实允许我们对数据进行更多的控制 

1612
01:19:26,083 --> 01:19:30,250
我们储存的信息 并不一定能阻止用户--

1613
01:19:30,250 --> 01:19:33,625
或者更确切地说是程序员--可能是我自己 也可能是同事 

1614
01:19:33,625 --> 01:19:35,791
把事情搞砸

1615
01:19:35,791 --> 01:19:39,083
在这里 同样 本着编程的精神 

1616
01:19:39,083 --> 01:19:43,916
为了防御 请允许我介绍Python的另一个特性--

1617
01:19:43,916 --> 01:19:46,208
即财产 

1618
01:19:46,208 --> 01:19:49,375
所以属性实际上只是一个属性

1619
01:19:49,375 --> 01:19:52,750
有更多的防御机制 

1620
01:19:52,750 --> 01:19:58,208
多一点的功能 防止像我这样的程序员 

1621
01:19:58,208 --> 01:20:01,083
还有你 把这些属性搞砸了

1622
01:20:01,083 --> 01:20:04,375
同样 属性是一个属性 你和我只是

1623
01:20:04,375 --> 01:20:06,083
有更多的控制权 

1624
01:20:06,083 --> 01:20:06,750
怎么做？

1625
01:20:06,750 --> 01:20:09,791
我们只是使用一些Python约定编写了更多的代码 

1626
01:20:09,791 --> 01:20:14,333
我们要做的是 马上 使用一个功能--

1627
01:20:14,333 --> 01:20:18,083
一个名为@property的关键字 从技术上讲 它是一个函数 

1628
01:20:18,083 --> 01:20:19,916
属性是Python中的一个函数 

1629
01:20:19,916 --> 01:20:24,791
但是我们即将看到一些新的@语法 它允许你装饰函数 

1630
01:20:24,791 --> 01:20:26,125
这也是一种艺术术语 

1631
01:20:26,125 --> 01:20:28,916
在Python的世界里 你可以有装饰器 

1632
01:20:28,916 --> 01:20:33,166
它们是修改其他函数的行为的函数 

1633
01:20:33,166 --> 01:20:36,708
如果你愿意的话 我们就不谈这个了 不谈太多的杂草 

1634
01:20:36,708 --> 01:20:39,291
我们将通过例子来了解如何使用这些装饰器 

1635
01:20:39,291 --> 01:20:41,541
特别是定义属性 

1636
01:20:41,541 --> 01:20:43,708
让我们回到VS Code 

1637
01:20:43,708 --> 01:20:46,791
我建议我来做 

1638
01:20:46,791 --> 01:20:49,375
我要继续下去 创造--

1639
01:20:49,375 --> 01:20:54,291
一个叫房子的房产怎么样 如下所示 

1640
01:20:54,291 --> 01:21:00,833
在我的学生课堂上 我将继续--在我的init方法下面

1641
01:21:00,833 --> 01:21:03,958
在我str方法下面 我将继续定义

1642
01:21:03,958 --> 01:21:09,000
一个名为house的函数 它总是至少接受一个参数 

1643
01:21:09,000 --> 01:21:10,041
叫赛尔夫 

1644
01:21:10,041 --> 01:21:15,458
我现在要做的就是把自己送回去 

1645
01:21:15,458 --> 01:21:17,625
所以我只需要定义一个名为

1646
01:21:17,625 --> 01:21:23,375
房子 其生活的唯一目的是返还房子的价值 

1647
01:21:23,375 --> 01:21:27,375
但我将定义另一种方法 奇怪的是 它也被称为House 

1648
01:21:27,375 --> 01:21:31,375
但作为论据 这将涉及到两个价值观--

1649
01:21:31,375 --> 01:21:35,625
一如既往的自我 也有一种叫房子的价值 

1650
01:21:35,625 --> 01:21:37,291
现在我要这样做了 

1651
01:21:40,375 --> 01:21:43,958
我要自己动手 

1652
01:21:43,958 --> 01:21:45,250
现在 我做了什么？

1653
01:21:45,250 --> 01:21:47,625
那么 让我暂时在这里补充一些评论 

1654
01:21:47,625 --> 01:21:50,166
稍后 我们将开始泛泛地提到这一点

1655
01:21:50,166 --> 01:21:51,083
作为一名吸毒者 

1656
01:21:51,083 --> 01:21:54,083
在这里 我将把这称为二传手 

1657
01:21:54,083 --> 01:21:56,875
这是在Java世界中经常看到的术语 

1658
01:21:56,875 --> 01:21:58,791
你们中的一些人以前用Java编程过 

1659
01:21:58,791 --> 01:22:01,875
但是顾名思义 getter是一个函数

1660
01:22:01,875 --> 01:22:05,333
对于获得某些属性的类 

1661
01:22:05,333 --> 01:22:10,291
Setter是某个类中设置某些值的函数 

1662
01:22:10,291 --> 01:22:14,125
现在 尽管我们还没有完成 代码中有一点错误

1663
01:22:14,125 --> 01:22:17,916
直觉上 我已经写过了 我们要做的是 

1664
01:22:17,916 --> 01:22:21,000
我们正在努力防止程序员 包括我自己 

1665
01:22:21,000 --> 01:22:23,541
避免我的错误检查 即我

1666
01:22:23,541 --> 01:22:25,666
把名字和房子放在适当的位置 

1667
01:22:25,666 --> 01:22:26,958
我怎么能做到这一点？

1668
01:22:26,958 --> 01:22:29,500
嗯 我们在编程方面没有那么多的积木 

1669
01:22:29,500 --> 01:22:33,541
我们有数据的变量 我们有行动的函数 

1670
01:22:33,541 --> 01:22:35,000
好吧 为什么我们不这样做呢？

1671
01:22:35,000 --> 01:22:39,958
为什么我们不以某种方式要求 为了访问属性 

1672
01:22:39,958 --> 01:22:41,375
你要经历一些功能 

1673
01:22:41,375 --> 01:22:44,583
让我们要求 为了设置一些属性 

1674
01:22:44,583 --> 01:22:46,291
你要经历一些功能 

1675
01:22:46,291 --> 01:22:51,958
通常 这些函数称为getter函数和setter函数

1676
01:22:51,958 --> 01:22:52,708
功能 

1677
01:22:52,708 --> 01:22:56,541
为什么我们要在类中使用函数或方法呢？

1678
01:22:56,541 --> 01:23:00,000
嗯 一旦你有了功能 这些就只是动作或动词

1679
01:23:00,000 --> 01:23:01,583
你和我可以创造我们自己 

1680
01:23:01,583 --> 01:23:05,208
我们可以在这些函数中添加我想要的任何纠错

1681
01:23:05,208 --> 01:23:08,416
因为这是要从上到下执行的代码 

1682
01:23:08,416 --> 01:23:15,541
那么 我现在如何防止用户将房屋设置为无效值呢？

1683
01:23:15,541 --> 01:23:20,500
让我借用前面的一些逻辑 而不是盲目地这样做--只需设置

1684
01:23:20,500 --> 01:23:25,291
Self.house等于传入的房屋价值--让我们加上我们的错误

1685
01:23:25,291 --> 01:23:26,166
在那里检查 

1686
01:23:26,166 --> 01:23:34,791
因此 如果豪斯不在格兰芬多或赫奇帕奇的以下名单中

1687
01:23:34,791 --> 01:23:40,708
或者拉文克劳或斯莱特林 就像以前一样 

1688
01:23:40,708 --> 01:23:44,541
让我们继续引发一个值错误 只是为了表示 嗯-嗯 某件事

1689
01:23:44,541 --> 01:23:45,291
出了问题 

1690
01:23:45,291 --> 01:23:46,333
我会说得更清楚些 

1691
01:23:46,333 --> 01:23:50,541
我会加上一条消息 比如 “无效的房子 ”引用 不引用 

1692
01:23:50,541 --> 01:23:56,166
否则 我将继续 现在 第21行 设置自己 挨家挨户 

1693
01:23:56,166 --> 01:24:00,416
所以我只是复制了 或者重新输入了我的错误检查

1694
01:24:00,416 --> 01:24:02,333
这个所谓的setter函数 

1695
01:24:02,333 --> 01:24:03,666
现在 我为什么要这么做？

1696
01:24:03,666 --> 01:24:07,458
明确地说 每当用户或程序员

1697
01:24:07,458 --> 01:24:12,375
像这样写代码 Student.house等于 什么是

1698
01:24:12,375 --> 01:24:16,166
即将神奇地发生的是 Python将不仅仅是

1699
01:24:16,166 --> 01:24:19,916
让程序员直接访问学生宿舍--该属性 

1700
01:24:19,916 --> 01:24:21,750
那个实例变量 也就是 

1701
01:24:21,750 --> 01:24:22,875
自己的房子 

1702
01:24:22,875 --> 01:24:26,833
取而代之的是它会神奇地自动调用

1703
01:24:26,833 --> 01:24:28,791
这个定时器对我来说很有作用 

1704
01:24:28,791 --> 01:24:30,708
Python是如何知道要这样做的？

1705
01:24:30,708 --> 01:24:35,666
嗯 如果是这样的话 在左手边 有自己的房子 

1706
01:24:35,666 --> 01:24:42,125
其中house是获取者或二传者的名字 然后它看到一个等号 

1707
01:24:42,125 --> 01:24:45,625
指示任务 这只是一个足够的视觉线索说 

1708
01:24:45,625 --> 01:24:46,208
等一下 

1709
01:24:46,208 --> 01:24:49,250
我不会让您直接访问该属性 

1710
01:24:49,250 --> 01:24:51,791
我将改用定位器 

1711
01:24:51,791 --> 01:24:52,291
为什么？

1712
01:24:52,291 --> 01:24:54,291
因为等号表示我在试着设置 

1713
01:24:54,291 --> 01:24:58,250
我正在尝试将一个从右到左的值赋给该属性 

1714
01:24:58,250 --> 01:25:00,500
因此 Python将自动执行的操作

1715
01:25:00,500 --> 01:25:02,083
就是为我调用这个函数 

1716
01:25:02,083 --> 01:25:06,708
这很令人惊讶 因为现在我可以执行代码--一个用于检查的算法 

1717
01:25:06,708 --> 01:25:08,625
我想让用户--

1718
01:25:08,625 --> 01:25:12,041
程序员是否将该属性设置为该值？

1719
01:25:12,041 --> 01:25:13,916
如果不是 我将引发一个值错误 

1720
01:25:13,916 --> 01:25:15,833
你就是做不到 

1721
01:25:15,833 --> 01:25:17,500
如果真是这样的话 

1722
01:25:17,500 --> 01:25:19,416
我去给您安排一下 

1723
01:25:19,416 --> 01:25:21,958
但为了做到这一点 我们需要更多的语法 

1724
01:25:21,958 --> 01:25:25,375
我要去掉我的评论 我要用那个装饰物 

1725
01:25:25,375 --> 01:25:29,583
我需要告诉Python将此方法作为一个getter来处理 

1726
01:25:29,583 --> 01:25:32,083
然后 setter的语法略有不同 

1727
01:25:32,083 --> 01:25:34,500
你现在说的是house.setter 

1728
01:25:34,500 --> 01:25:37,500
我希望一个是得到者 另一个是塞特人 

1729
01:25:37,500 --> 01:25:39,458
这不是他们设计的方式 

1730
01:25:39,458 --> 01:25:44,291
当您想定义一个getter时 只需在函数上方加上@Property即可 

1731
01:25:44,291 --> 01:25:48,833
并且您可以完全按照您希望的属性来命名函数

1732
01:25:48,833 --> 01:25:51,000
被称为--引用 引用 “房子 ”

1733
01:25:51,000 --> 01:25:54,416
这样做之后 您现在就可以使用新的装饰器了

1734
01:25:54,416 --> 01:25:57,625
它是自动为您创建的 名为@House 

1735
01:25:57,625 --> 01:25:58,750
因为我叫它房子 

1736
01:25:58,750 --> 01:26:01,416
然后你字面上说 @house.setter 

1737
01:26:01,416 --> 01:26:05,333
而这一整行 在第17行 是关于Python的线索

1738
01:26:05,333 --> 01:26:08,750
这就是一个名称完全相同的函数--

1739
01:26:08,750 --> 01:26:12,541
但请注意 它需要两个参数--都是self 所以您可以访问

1740
01:26:12,541 --> 01:26:15,208
对象的内容 和房子 这是公正的

1741
01:26:15,208 --> 01:26:20,041
将是来自程序员的字符串 来自人工输入返回

1742
01:26:20,041 --> 01:26:23,958
值 以便您也可以设置该值 

1743
01:26:23,958 --> 01:26:27,375
但我现在有一个问题需要解决 就是这里 

1744
01:26:27,375 --> 01:26:29,625
我认为 其他一切都还不错 

1745
01:26:29,625 --> 01:26:31,250
然而 看看这个 

1746
01:26:31,250 --> 01:26:34,500
我在这里不再需要这个错误检查 

1747
01:26:34,500 --> 01:26:35,333
为什么？

1748
01:26:35,333 --> 01:26:39,375
因为 如果我向下滚动到我的代码 

1749
01:26:39,375 --> 01:26:46,250
我刚才声称 像这样的代码 带有Student.house等于 

1750
01:26:46,250 --> 01:26:49,666
会自动让Python为我调用我的setter 

1751
01:26:49,666 --> 01:26:50,666
你猜怎么着？

1752
01:26:50,666 --> 01:26:55,875
即使在这里 在我的init方法中 调用self.house也等于

1753
01:26:55,875 --> 01:27:00,208
还将调用我的setter方法 这很令人惊讶

1754
01:27:00,208 --> 01:27:06,083
因为现在我可以将所有错误检查保存在setter中的一个位置 

1755
01:27:06,083 --> 01:27:10,833
当我第一次创建对象时 它现在将被调用 

1756
01:27:10,833 --> 01:27:14,541
因为init 或者即使程序员

1757
01:27:14,541 --> 01:27:19,375
尝试绕过init方法并更改该属性值 

1758
01:27:19,375 --> 01:27:21,041
我的二传手也会被叫来 

1759
01:27:21,041 --> 01:27:26,000
每当我访问.house时 我的setter都会被调用 

1760
01:27:26,000 --> 01:27:28,458
但有一件事我需要解决 

1761
01:27:28,458 --> 01:27:32,958
不幸的是 我的名字有冲突 

1762
01:27:32,958 --> 01:27:38,458
现在 如果我们往上走 在第5行 这是一个实例变量 

1763
01:27:38,458 --> 01:27:42,333
它是我自己内部的一个字符串 在当前的学生对象内部 

1764
01:27:42,333 --> 01:27:43,083
骂人的名字 

1765
01:27:43,083 --> 01:27:46,958
这是另一个名为house的实例变量 

1766
01:27:46,958 --> 01:27:51,291
不幸的是 如果我有一个名为name and house的实例变量 

1767
01:27:51,291 --> 01:27:54,750
我不能同时拥有称为House的功能 

1768
01:27:54,750 --> 01:27:55,916
它们将会相撞 

1769
01:27:55,916 --> 01:27:57,041
你必须做出决定 

1770
01:27:57,041 --> 01:27:59,250
是否要将该变量命名为house？

1771
01:27:59,250 --> 01:28:01,708
或者 您希望将该功能命名为House？

1772
01:28:01,708 --> 01:28:04,208
不幸的是 你不能两者兼得 因为现在

1773
01:28:04,208 --> 01:28:06,041
会把其中一个混淆为另一个 

1774
01:28:06,041 --> 01:28:09,291
因此 传统的解决办法是这样做--

1775
01:28:09,291 --> 01:28:15,250
为了让setter不存储在self.house中传递的值 

1776
01:28:15,250 --> 01:28:19,125
但使用一个几乎相同的名字 但使用一个小指示器

1777
01:28:19,125 --> 01:28:21,208
意味着你知道这样做是正确的 

1778
01:28:21,208 --> 01:28:23,666
按照惯例 您通常会加下划线

1779
01:28:23,666 --> 01:28:27,041
在实例变量的名称前面 

1780
01:28:27,041 --> 01:28:31,208
当你在这里返回它的时候 你同样会加一个下划线 

1781
01:28:31,208 --> 01:28:36,541
所以现在 从技术上讲 我的实例变量名为_house 

1782
01:28:36,541 --> 01:28:41,791
但我的财产 这是一个更华丽的属性 如果你愿意的话 

1783
01:28:41,791 --> 01:28:44,916
叫孤家寡人 

1784
01:28:44,916 --> 01:28:48,666
我知道语法量很大 但它是一个非常强大的功能 

1785
01:28:48,666 --> 01:28:52,708
这也是为什么你可以从字典中毕业 

1786
01:28:52,708 --> 01:28:55,500
更多功能任您使用 

1787
01:28:55,500 --> 01:28:58,916
让我继续清理我的终端窗口 运行student.py的Python 

1788
01:28:58,916 --> 01:29:00,458
输入姓名

1789
01:29:00,458 --> 01:29:02,708
好吧 让我们继续输入哈里 

1790
01:29:02,708 --> 01:29:04,625
让我们继续输入格兰芬多 

1791
01:29:04,625 --> 01:29:06,416
像往常一样交叉手指 

1792
01:29:06,416 --> 01:29:09,083
而现在 看 "病人的房子.“

1793
01:29:09,083 --> 01:29:10,250
这是好事

1794
01:29:10,250 --> 01:29:10,750
为什么要这样？

1795
01:29:10,750 --> 01:29:13,958
因为 注意 在我的主函数中 

1796
01:29:13,958 --> 01:29:19,125
仍然试图 恶意地 如果你愿意 改变哈利的房子

1797
01:29:19,125 --> 01:29:21,000
不属于四个有效之一

1798
01:29:21,000 --> 01:29:24,833
我想把它改成他童年的家女贞路四号

1799
01:29:24,833 --> 01:29:29,208
但是因为Python知道 等一下 你要分配--

1800
01:29:29,208 --> 01:29:30,708
也就是说 设定一个值--

1801
01:29:30,708 --> 01:29:34,208
这个值也就是房屋 现在被定义为

1802
01:29:34,208 --> 01:29:38,333
作为一个属性 你将不得不通过setter函数 

1803
01:29:38,333 --> 01:29:40,958
让你改变这个值 

1804
01:29:40,958 --> 01:29:44,208
因为我有这个加薪ValueError 

1805
01:29:44,208 --> 01:29:46,916
如果房子不像预期的那样 

1806
01:29:46,916 --> 01:29:49,458
将被允许将其更改为无效值 

1807
01:29:49,458 --> 01:29:52,458
所以我通过init方法在进入的过程中保护数据 

1808
01:29:52,458 --> 01:29:56,708
如果你试图在那里覆盖它 我甚至会为数据辩护 

1809
01:29:56,708 --> 01:29:59,208
所以我认为对我这个程序员来说 

1810
01:29:59,208 --> 01:30:01,250
别试图破解我的密码

1811
01:30:01,250 --> 01:30:04,083
让我把这句话去掉 因为它不起作用 

1812
01:30:04,083 --> 01:30:07,250
让我运行student.py的Python 再次输入Harry;

1813
01:30:07,250 --> 01:30:10,916
输入格兰芬多 回车 哈利确实是格兰芬多的 

1814
01:30:10,916 --> 01:30:15,708
如果我做错了什么 就像《四号》里的哈利 

1815
01:30:15,708 --> 01:30:20,541
女贞路 回车 我们再次看到值错误

1816
01:30:20,541 --> 01:30:25,083
因为我的代码不允许手动输入这个值

1817
01:30:25,083 --> 01:30:28,541
或者通过这种对抗性的变化 

1818
01:30:28,541 --> 01:30:29,958
好吧 这是很多 

1819
01:30:29,958 --> 01:30:35,208
关于财产有什么问题吗？

1820
01:30:35,208 --> 01:30:37,125
问：为什么我们使用getter 然后使用setter？

1821
01:30:37,125 --> 01:30:41,541
只是为了让我们能找到

1822
01:30:41,541 --> 01:30:43,791
那个方法 我们代码中的函数 

1823
01:30:43,791 --> 01:30:46,833
大卫·J·马兰：我之所以要费力去定义

1824
01:30:46,833 --> 01:30:52,375
这个getter或setter是因为我想确保程序员不能

1825
01:30:52,375 --> 01:30:53,250
诸如此类的事情 

1826
01:30:53,250 --> 01:30:55,500
如果我正在经历验证的麻烦

1827
01:30:55,500 --> 01:30:58,708
这些学生对象的属性 

1828
01:30:58,708 --> 01:31:02,041
我不希望你能进去 随意更改它们 

1829
01:31:02,041 --> 01:31:04,625
我想要对那个物体有一定的控制权

1830
01:31:04,625 --> 01:31:07,708
这样你就可以相信它会像设计的那样正确 

1831
01:31:07,708 --> 01:31:11,041
所以使用getter和setter实际上只是启用了

1832
01:31:11,041 --> 01:31:15,416
当您尝试手动设置值时 可以自动检测到这一点 

1833
01:31:15,416 --> 01:31:18,333
等号和圆点 就像我在这里强调的 

1834
01:31:18,333 --> 01:31:20,666
足以让我们意识到 等一下 

1835
01:31:20,666 --> 01:31:21,916
你在试着设定一个价值 

1836
01:31:21,916 --> 01:31:24,750
让我看看这个类是否定义了setter 

1837
01:31:24,750 --> 01:31:26,875
如果是这样的话 我会把它称为 我不仅仅是

1838
01:31:26,875 --> 01:31:30,125
从右到左盲目赋值 

1839
01:31:30,125 --> 01:31:32,541
所以它只是给了我更多的控制权 

1840
01:31:32,541 --> 01:31:35,041
关于属性的其他问题 

1841
01:31:35,041 --> 01:31:39,458
听众：当我们使用getter时 我们只有一个参数 

1842
01:31:39,458 --> 01:31:43,291
如果我们使用setter 它总是会有两个参数？

1843
01:31:43,291 --> 01:31:44,291
这正常吗？

1844
01:31:44,291 --> 01:31:45,291
大卫·J·马兰：正确 

1845
01:31:45,291 --> 01:31:47,833
永远只有一个争论--自我

1846
01:31:47,833 --> 01:31:52,625
对于getter setter有两个参数--self和其他东西 

1847
01:31:52,625 --> 01:31:55,375
直觉是 如果你得到了一个价值 

1848
01:31:55,375 --> 01:31:58,875
您不需要传入任何其他内容 因为您已经知道该对象 

1849
01:31:58,875 --> 01:32:00,291
在这种情况下 它被称为学生 

1850
01:32:00,291 --> 01:32:02,791
所以你只需要得到这处房产的价值 

1851
01:32:02,791 --> 01:32:05,458
但如果要将该属性设置为其他值 

1852
01:32:05,458 --> 01:32:07,125
你必须把这一论点传递出去 

1853
01:32:07,125 --> 01:32:09,625
您必须传入要为其设置的值 

1854
01:32:09,625 --> 01:32:11,291
所以它总是0或1 

1855
01:32:11,291 --> 01:32:17,541
但是 您可以将其视为1或2 因为同样 类中的任何函数 

1856
01:32:17,541 --> 01:32:18,041
也就是 

1857
01:32:18,041 --> 01:32:22,291
一个方法 将自动传递给您自己 这样您就可以访问

1858
01:32:22,291 --> 01:32:25,208
到内存中的当前对象 

1859
01:32:25,208 --> 01:32:27,708
另一个关于房产的问题怎么样？

1860
01:32:27,708 --> 01:32:31,791
观众：为什么我们没有使用相同的下划线房屋初始化方法？

1861
01:32:31,791 --> 01:32:33,125
大卫·J·马兰：问得好 

1862
01:32:33,125 --> 01:32:36,750
所以即使我在我的二传手里用的是下划线的房子 

1863
01:32:36,750 --> 01:32:39,125
下划线的房子在我的吸尘器里 

1864
01:32:39,125 --> 01:32:41,958
我故意不在这里用它 

1865
01:32:41,958 --> 01:32:47,333
原因是 通过使用self.house和这个等号 

1866
01:32:47,333 --> 01:32:50,375
这与我希望Python识别的模式是相同的 

1867
01:32:50,375 --> 01:32:53,208
我希望Python自动调用setter 

1868
01:32:53,208 --> 01:32:56,791
即使当我通过init方法进入房子时也是如此 

1869
01:32:56,791 --> 01:33:01,458
如果我改变这一点来做这件事 那就绕过了二传手 

1870
01:33:01,458 --> 01:33:05,041
现在 无论如何 在init中都没有错误签入 

1871
01:33:05,041 --> 01:33:06,333
因此 这是一条如此微妙的界线 

1872
01:33:06,333 --> 01:33:10,041
唯一阻碍我们进行错误检查或不进行错误检查的事情

1873
01:33:10,041 --> 01:33:12,750
是有没有这个下划线 

1874
01:33:12,750 --> 01:33:14,625
但这是通常的惯例 

1875
01:33:14,625 --> 01:33:17,375
通过不使用那里的下划线 确保

1876
01:33:17,375 --> 01:33:19,708
即使是这项任务也要经过设定者

1877
01:33:19,708 --> 01:33:22,416
所以 老实说 我 不必复制粘贴同样的错误

1878
01:33:22,416 --> 01:33:23,583
入住两个地方 

1879
01:33:23,583 --> 01:33:25,375
我可以把它放在二传手里 

1880
01:33:25,375 --> 01:33:28,791
所以这是一个更好的设计 这就是为什么我一开始手动重新打字的原因 

1881
01:33:28,791 --> 01:33:31,166
但后来我把它从init中删除了 

1882
01:33:31,166 --> 01:33:34,625
好吧 请允许我提议我们对这份文件做另一项修改 

1883
01:33:34,625 --> 01:33:38,708
不妨继续为名称定义一个属性 

1884
01:33:38,708 --> 01:33:41,458
让我继续做这件事--也许是在房产上方

1885
01:33:41,458 --> 01:33:45,041
只是为了让事情保持在我之前定义的相同顺序 

1886
01:33:45,041 --> 01:33:47,375
让我给自己另一处房产吧 

1887
01:33:47,375 --> 01:33:49,125
这一次将被称为名字 

1888
01:33:49,125 --> 01:33:51,583
它将一如既往地采用一个叫做自我的论点 

1889
01:33:51,583 --> 01:33:55,625
与此非常相似的是 这个函数将返回self._name 

1890
01:33:55,625 --> 01:33:57,333
所以我会预料到我会去

1891
01:33:57,333 --> 01:34:01,166
还必须重命名名称 这样我就不会发生与

1892
01:34:01,166 --> 01:34:01,875
在此之前 

1893
01:34:01,875 --> 01:34:05,541
但现在让我继续定义另一个二传手--

1894
01:34:05,541 --> 01:34:06,750
这是名字的名字 

1895
01:34:06,750 --> 01:34:09,416
因此 约定为@name.setter 

1896
01:34:09,416 --> 01:34:10,375
为什么要取这个名字？

1897
01:34:10,375 --> 01:34:13,916
因为我刚刚创建的属性名为Name 

1898
01:34:13,916 --> 01:34:18,833
因此 如果您愿意的话 getter和setter以这种方式协同工作 

1899
01:34:18,833 --> 01:34:22,291
让我们使用名称setter来定义另一个函数 

1900
01:34:22,291 --> 01:34:23,375
也叫名字 

1901
01:34:23,375 --> 01:34:25,791
但这里的关键是 它们并不完全相同 

1902
01:34:25,791 --> 01:34:30,000
它不是完全相同的函数名称和完全相同的参数数量 

1903
01:34:30,000 --> 01:34:32,500
同样 setter接受第二个参数 

1904
01:34:32,500 --> 01:34:34,250
我可以随心所欲地叫它 但我

1905
01:34:34,250 --> 01:34:36,750
我要给它起个名字 因为这就是传入的东西 

1906
01:34:36,750 --> 01:34:39,041
我要把我的错误检查放在这里 

1907
01:34:39,041 --> 01:34:43,541
如果不是名称 就像我们以前所做的那样 让我们继续并引发一个值错误 

1908
01:34:43,541 --> 01:34:48,750
让我们加上一条解释性的信息 比如“缺少名字” 引用 不引用 

1909
01:34:48,750 --> 01:34:55,250
否则 让我们继续并将self._name更新为等名 

1910
01:34:55,250 --> 01:34:58,500
而且我不需要改变它的名字 只是为了摆脱它

1911
01:34:58,500 --> 01:35:02,333
重复错误检查 因为 再一次 

1912
01:35:02,333 --> 01:35:07,166
如果我使用self.name等于这里 使用self.house等于这里

1913
01:35:07,166 --> 01:35:09,916
没有下划线 这两个作业

1914
01:35:09,916 --> 01:35:13,375
现在我们来看看我的两个setter函数 

1915
01:35:13,375 --> 01:35:15,416
在我们开始之前 让我继续删除

1916
01:35:15,416 --> 01:35:18,791
这个敌对的代码 我们知道它不会起作用 因为我们正在捕获它 

1917
01:35:18,791 --> 01:35:22,375
让我返回到我的终端窗口并运行Student.py的Python 

1918
01:35:22,375 --> 01:35:22,916
进来吧 

1919
01:35:22,916 --> 01:35:23,958
让我们输入哈里 

1920
01:35:23,958 --> 01:35:25,125
让我们输入格兰芬多 

1921
01:35:25,125 --> 01:35:26,708
这似乎奏效了 

1922
01:35:26,708 --> 01:35:29,458
不过 让我们再次尝试运行Student.py的Python

1923
01:35:29,458 --> 01:35:32,708
和来自女贞路四号的哈里 

1924
01:35:32,708 --> 01:35:34,416
这是行不通的 

1925
01:35:34,416 --> 01:35:37,291
无效房屋的值错误 因为这不是

1926
01:35:37,291 --> 01:35:38,791
霍格沃茨的四所房子中的一所 

1927
01:35:38,791 --> 01:35:41,041
现在 为了更好地衡量 让我们再运行一次 

1928
01:35:41,041 --> 01:35:42,583
我们甚至都不给它起个名字 

1929
01:35:42,583 --> 01:35:44,375
出现提示时 我们只需按Enter键即可 

1930
01:35:44,375 --> 01:35:45,875
我可以为房子打任何东西 

1931
01:35:45,875 --> 01:35:47,958
我继续 格兰芬多 请进 

1932
01:35:47,958 --> 01:35:52,958
现在我们得到另一个值错误 但这个错误是因为缺少名称 

1933
01:35:52,958 --> 01:35:56,500
所以我们现在似乎有了更多的防御机制

1934
01:35:56,500 --> 01:35:58,833
确保这个名字符合我们的预期

1935
01:35:58,833 --> 01:36:01,000
它必须有非空的值 

1936
01:36:01,000 --> 01:36:02,500
房子也如我们所料 

1937
01:36:02,500 --> 01:36:05,000
它必须有这四个值之一 

1938
01:36:05,000 --> 01:36:08,000
但冒着戳破每个人的泡沫的风险

1939
01:36:08,000 --> 01:36:11,958
让你想知道 为什么我们要经历这一切 

1940
01:36:11,958 --> 01:36:18,875
不幸的是 Python真正关注的是约定 而不是硬约束 

1941
01:36:18,875 --> 01:36:20,291
我说的是这个 

1942
01:36:20,291 --> 01:36:25,208
如果我在第30行找到一个学生后 

1943
01:36:25,208 --> 01:36:30,375
我试着用相反的方式做一些事情--student.house等于

1944
01:36:30,375 --> 01:36:33,625
“女贞路四号”我们知道

1945
01:36:33,625 --> 01:36:37,416
因为我的家犬会被传染的 

1946
01:36:37,416 --> 01:36:38,333
再看一遍 

1947
01:36:38,333 --> 01:36:40,833
Python的student.py 

1948
01:36:40,833 --> 01:36:42,041
让我们输入哈里 

1949
01:36:42,041 --> 01:36:44,541
让我们输入格兰芬多 这至少会通过

1950
01:36:44,541 --> 01:36:46,958
我们的检查由init引发 

1951
01:36:46,958 --> 01:36:52,041
但是第31行将触发调用同一个setter 

1952
01:36:52,041 --> 01:36:55,583
我们会抛出一个值错误 说“无效的房子 “

1953
01:36:55,583 --> 01:36:58,250
不幸的是 如果你们中的一些人已经

1954
01:36:58,250 --> 01:37:02,375
想想你能做什么

1955
01:37:02,375 --> 01:37:05,500
你可以改变.房子是._房子

1956
01:37:05,500 --> 01:37:06,041
为什么要这样？

1957
01:37:06,041 --> 01:37:10,416
实例变量现在被称为_house 

1958
01:37:10,416 --> 01:37:13,125
房子的名字是house 没有下划线 

1959
01:37:13,125 --> 01:37:19,041
但是作为实例变量实现的基础属性仍然被调用

1960
01:37:19,041 --> 01:37:19,791
_房子 

1961
01:37:19,791 --> 01:37:23,541
可悲的是 学生的Python 

1962
01:37:23,541 --> 01:37:25,000
让我们输入哈里 

1963
01:37:25,000 --> 01:37:27,375
我们输入格兰芬多 这是正确的 

1964
01:37:27,375 --> 01:37:28,958
但看看现在发生了什么 

1965
01:37:28,958 --> 01:37:30,333
天啊

1966
01:37:30,333 --> 01:37:32,000
我们溜过去 

1967
01:37:32,000 --> 01:37:35,708
那么我强调的重点是什么呢

1968
01:37:35,708 --> 01:37:39,541
用“正确的方式”来做事情 Python的快速方式是让这个getter

1969
01:37:39,541 --> 01:37:40,291
setter？

1970
01:37:40,291 --> 01:37:43,208
与Java等语言不同 

1971
01:37:43,208 --> 01:37:46,208
防止你做这样的事情 Python

1972
01:37:46,208 --> 01:37:49,041
它本身允许您指定某些实例变量可以

1973
01:37:49,041 --> 01:37:52,666
是公开的 任何人的代码都可以访问 或者是受保护的 

1974
01:37:52,666 --> 01:37:56,791
或私有 这意味着其他任何人都不能更改这些值 

1975
01:37:56,791 --> 01:38:00,125
在Python的世界里 这只是一个荣誉系统 

1976
01:38:00,125 --> 01:38:02,416
它并没有融入到语言本身中 

1977
01:38:02,416 --> 01:38:05,500
可见性的概念 公共的或私人的 甚至介于两者之间的某个地方

1978
01:38:05,500 --> 01:38:06,250
受到保护 

1979
01:38:06,250 --> 01:38:08,208
取而代之的是 你在荣誉体系中 

1980
01:38:08,208 --> 01:38:11,666
通常的惯例是 如果一个实例

1981
01:38:11,666 --> 01:38:15,750
变量以下划线开头 请不要碰它 

1982
01:38:15,750 --> 01:38:16,708
就是不要 

1983
01:38:16,708 --> 01:38:19,750
如果你碰了那个变量 弄坏了东西 那就怪你了 

1984
01:38:19,750 --> 01:38:22,000
下划线表示约定

1985
01:38:22,000 --> 01:38:24,583
这本应是“私人的” 但它真的只是

1986
01:38:24,583 --> 01:38:25,875
意思是 请不要碰这个 

1987
01:38:25,875 --> 01:38:27,958
有时 如果有两个下划线 你可以使用 

1988
01:38:27,958 --> 01:38:30,541
同样 这也是程序员们更大的努力 他们说 

1989
01:38:30,541 --> 01:38:32,000
真的不要碰这个 

1990
01:38:32,000 --> 01:38:35,166
但从技术上讲 没有什么能阻止你或我

1991
01:38:35,166 --> 01:38:38,875
绕过所有这些机制 这些特性 

1992
01:38:38,875 --> 01:38:40,125
这些获得者和二传者 

1993
01:38:40,125 --> 01:38:42,250
我们最终只是在荣誉系统上

1994
01:38:42,250 --> 01:38:46,291
当我们看到实例变量以1为前缀时 不要这样做 

1995
01:38:46,291 --> 01:38:48,041
或者甚至是两个下划线 

1996
01:38:48,041 --> 01:38:50,583
好了 这是一下子做了很多事--

1997
01:38:50,583 --> 01:38:52,875
这是面向对象编程的入门 

1998
01:38:52,875 --> 01:38:56,166
但这可能会让人相当惊讶 即使我们

1999
01:38:56,166 --> 01:39:00,458
在过去的几周里可能已经认出了OOP的名字 

2000
01:39:00,458 --> 01:39:05,458
在这堂课上 我们已经使用类和对象好几个星期了 

2001
01:39:05,458 --> 01:39:08,791
事实上 如果你回想一下我们在这堂课上做的第一件事 

2002
01:39:08,791 --> 01:39:12,083
我们使用了整数 只是从用户那里获得了整数 

2003
01:39:12,083 --> 01:39:13,791
但如果你还没有--

2004
01:39:13,791 --> 01:39:17,500
如果您深入研究有关整数的文档 

2005
01:39:17,500 --> 01:39:19,916
同样 它位于这个URL上 您

2006
01:39:19,916 --> 01:39:26,166
会发现INT本身就是一门课 几周来一直是这样 

2007
01:39:26,166 --> 01:39:30,541
事实上 这是对int的构造函数调用的签名 

2008
01:39:30,541 --> 01:39:35,125
借此传入x 如数字、引号、不引号、“50”或引号 

2009
01:39:35,125 --> 01:39:38,458
引用一句话 还有一些东西--你可以选择性地传递基数--

2010
01:39:38,458 --> 01:39:41,750
10表示十进制 2表示二进制或其他任何值 

2011
01:39:41,750 --> 01:39:46,208
这个整型函数会一直返回给你 

2012
01:39:46,208 --> 01:39:49,625
类型为int的对象 

2013
01:39:49,625 --> 01:39:52,083
也就是说 int是一个类 

2014
01:39:52,083 --> 01:39:55,250
它是一个模板 一个在内存中创建整数的蓝图 

2015
01:39:55,250 --> 01:39:59,125
任何时候 只要你和我把一个字符串转换成一个整型 

2016
01:39:59,125 --> 01:40:03,958
您和我一直在创建一个int类型的对象 该对象调用

2017
01:40:03,958 --> 01:40:07,875
显然 下划线 init 下划线下划线方法 

2018
01:40:07,875 --> 01:40:09,666
其他人--《巨蟒》的作者--

2019
01:40:09,666 --> 01:40:12,500
写给我们的是正确的整数 

2020
01:40:12,500 --> 01:40:16,541
除此之外 如果你相信的话 STR、Python中的字符串

2021
01:40:16,541 --> 01:40:20,000
从这节课的第一周就开始上课了 

2022
01:40:20,000 --> 01:40:22,000
如果您在文档中查找字符串 

2023
01:40:22,000 --> 01:40:26,541
它位于一个类似的URL中 您会发现 当您实例化

2024
01:40:26,541 --> 01:40:28,083
也就是说 创建一个字符串--

2025
01:40:28,083 --> 01:40:32,166
它可选地接受一个在这里称为Object的参数 

2026
01:40:32,166 --> 01:40:34,666
其缺省值为JUST、QUOTE、UNQUOTE、

2027
01:40:34,666 --> 01:40:38,000
这实际上允许您创建一个空字符串、一个空字符串、

2028
01:40:38,000 --> 01:40:38,500
如果你愿意的话 

2029
01:40:38,500 --> 01:40:42,541
但任何时候你和我创建了STR或甚至明确使用

2030
01:40:42,541 --> 01:40:47,333
Str函数 您将返回一个str类型对象 

2031
01:40:47,333 --> 01:40:52,375
任何时候您和我根据文档将字符串强制为小写时 

2032
01:40:52,375 --> 01:40:58,041
使用这样的语法 您和我已经获取了一个类型为str的对象

2033
01:40:58,041 --> 01:41:03,125
并通过调用名为Low的方法将其全部强制为小写 

2034
01:41:03,125 --> 01:41:07,958
一种由Python的作者构建到str类中的方法 

2035
01:41:07,958 --> 01:41:11,041
但它从一开始就存在 所以这个方法的概念不是

2036
01:41:11,041 --> 01:41:11,833
即使是今天的新鲜事 

2037
01:41:11,833 --> 01:41:13,750
你不会这么做这么久的 

2038
01:41:13,750 --> 01:41:17,416
如果您曾经调用strain来删除前导空格和尾随空格

2039
01:41:17,416 --> 01:41:22,166
从Python中的一个字符串中 您将调用另一个随Python提供的方法--

2040
01:41:22,166 --> 01:41:23,750
由Python的作者编写 

2041
01:41:23,750 --> 01:41:26,000
尽管我们当时并没有把它叫做课程 

2042
01:41:26,000 --> 01:41:29,708
一直以来 字符串都是一门课 

2043
01:41:29,708 --> 01:41:33,541
字符串的实例本身就是对象 

2044
01:41:33,541 --> 01:41:36,291
因此 这些对象具有以下功能

2045
01:41:36,291 --> 01:41:39,458
内置--也就是 允许我们做像武力这样的事情的方法

2046
01:41:39,458 --> 01:41:42,791
从开头和结尾开始小写并去掉空格 

2047
01:41:42,791 --> 01:41:43,958
让我们再来一次 

2048
01:41:43,958 --> 01:41:49,541
List--任何时候您创建了一个列表 无论是语法上的Square

2049
01:41:49,541 --> 01:41:53,541
括号或字面意思是L-I-S-T 左括号 右括号 

2050
01:41:53,541 --> 01:41:56,375
这也是可能的 你一直在使用一个类 

2051
01:41:56,375 --> 01:41:59,833
如果您转到列表的文档 请访问类似的URL

2052
01:41:59,833 --> 01:42:04,083
在这里 或者更具体地说 关于在Python中的列表的教程 

2053
01:42:04,083 --> 01:42:07,208
你会看到一份清单现在和过去都是 

2054
01:42:07,208 --> 01:42:10,958
从这节课的前几周开始 一节课就开始了 

2055
01:42:10,958 --> 01:42:16,166
作为其初始化的一部分 该List类

2056
01:42:16,166 --> 01:42:21,000
可选的可迭代的 可以迭代的东西--比如1 2 3 

2057
01:42:21,000 --> 01:42:24,125
或某个值列表 然后您可以返回

2058
01:42:24,125 --> 01:42:27,416
包含这些相同可迭代值的列表 

2059
01:42:27,416 --> 01:42:30,666
如果你曾经在这节课的列表上添加过什么 

2060
01:42:30,666 --> 01:42:32,583
就像我过去做的那样 你一直

2061
01:42:32,583 --> 01:42:37,416
使用List类附带的名为append的方法 根据x

2062
01:42:37,416 --> 01:42:40,541
在这里 接受一个允许您追加某些内容的参数

2063
01:42:40,541 --> 01:42:42,833
添加到当前名单中 也就是 

2064
01:42:42,833 --> 01:42:45,125
在这种方法的背景下 自我 

2065
01:42:45,125 --> 01:42:46,416
我们可以一整天都这样做 

2066
01:42:46,416 --> 01:42:49,625
如果你用过Python中的词典或词典--

2067
01:42:49,625 --> 01:42:53,125
实际上 一直以来 我都把它们叫做词典对象 

2068
01:42:53,125 --> 01:42:54,500
这是有原因的 

2069
01:42:54,500 --> 01:42:57,250
DICT本身就是一个用Python编写的类 如果你把它拉上来

2070
01:42:57,250 --> 01:42:59,166
它的官方文件在这里 

2071
01:42:59,166 --> 01:43:03,375
您将看到它确实被定义为一个类 

2072
01:43:03,375 --> 01:43:05,333
而且这个类也附带了方法 

2073
01:43:05,333 --> 01:43:07,291
所以 每当我们操纵词典时 

2074
01:43:07,291 --> 01:43:11,916
我们已经在引擎盖下 使用了所有这些相同的方法 

2075
01:43:11,916 --> 01:43:14,208
事实上 如果我们真的很好奇 我们就能看到这一点 

2076
01:43:14,208 --> 01:43:17,375
让我回到这里来VS Code 

2077
01:43:17,375 --> 01:43:20,250
让我们继续创建一个新文件 该文件非常简单

2078
01:43:20,250 --> 01:43:22,500
与数据类型有关的东西 

2079
01:43:22,500 --> 01:43:24,833
让我继续创建一个新文件 例如 

2080
01:43:24,833 --> 01:43:30,666
名为type.py 这样我就可以查看一些值了 

2081
01:43:30,666 --> 01:43:34,333
在type.py中 我将继续执行此操作 

2082
01:43:34,333 --> 01:43:38,375
我要打印出任何类型的东西 比如说数字50 

2083
01:43:38,375 --> 01:43:41,500
这是一个你们还没有见过我用过的函数 

2084
01:43:41,500 --> 01:43:44,500
而且您不会在自己的代码中频繁使用它 

2085
01:43:44,500 --> 01:43:46,958
如果需要的话 还有其他方法可以检测到 

2086
01:43:46,958 --> 01:43:48,625
变量的类型是什么 

2087
01:43:48,625 --> 01:43:53,791
但在这种情况下 50的类型只会告诉我 然后打印出来

2088
01:43:53,791 --> 01:43:55,833
该值的数据类型是什么 

2089
01:43:55,833 --> 01:43:58,416
现在 希望我们所有人都能猜到 50确实是

2090
01:43:58,416 --> 01:43:59,458
将会是一个整数--

2091
01:43:59,458 --> 01:44:01,666
这是一个int 但我们可以这样看它 

2092
01:44:01,666 --> 01:44:04,541
这也是懂一点编程的强大之处 

2093
01:44:04,541 --> 01:44:06,416
如果你想知道问题的答案 

2094
01:44:06,416 --> 01:44:08,208
试一试 就像我在这里一样 

2095
01:44:08,208 --> 01:44:11,125
因此 让我继续运行type.py的Python 回车 

2096
01:44:11,125 --> 01:44:12,208
事实就是如此 

2097
01:44:12,208 --> 01:44:17,458
当你打印出数字50的类型时 你会在屏幕上看到 

2098
01:44:17,458 --> 01:44:20,625
在这个神秘的语法中 类为“int” 

2099
01:44:20,625 --> 01:44:23,541
这可能不是您想要向用户展示的东西 

2100
01:44:23,541 --> 01:44:26,625
但如果你自己只是想四处走走看看发生了什么

2101
01:44:26,625 --> 01:44:29,166
或者以某种方式利用这些信息 这是

2102
01:44:29,166 --> 01:44:32,833
当然 您可以使用此类型的函数来实现这一点 

2103
01:44:32,833 --> 01:44:34,583
让我们稍微改变一下 

2104
01:44:34,583 --> 01:44:38,375
不是作为参数传递给类型50 而是作为整型传递 

2105
01:44:38,375 --> 01:44:41,291
让我们输入一些熟悉的东西 比如“Hello world ”

2106
01:44:41,291 --> 01:44:43,166
在双引号或单引号中 

2107
01:44:43,166 --> 01:44:45,541
让我回到我的终端窗口 清除屏幕 

2108
01:44:45,541 --> 01:44:47,208
并再次运行type.py的Python 

2109
01:44:47,208 --> 01:44:49,333
现在 瞧 就是这样 

2110
01:44:49,333 --> 01:44:52,750
一直以来 字符串也是一个类 

2111
01:44:52,750 --> 01:44:54,333
我们可以再这样做几次 因为 

2112
01:44:54,333 --> 01:44:54,833
实例 

2113
01:44:54,833 --> 01:44:58,875
让我们继续 把“你好 世界”变成一个空的清单--

2114
01:44:58,875 --> 01:45:01,291
开方括号和闭方括号 

2115
01:45:01,291 --> 01:45:03,375
这看起来有点神秘 

2116
01:45:03,375 --> 01:45:04,791
但是 再说一次 注意我在做什么 

2117
01:45:04,791 --> 01:45:06,708
方括号中是一个空列表 

2118
01:45:06,708 --> 01:45:08,083
我们以前也这么做过 

2119
01:45:08,083 --> 01:45:11,583
这是这个新类型函数的唯一参数 

2120
01:45:11,583 --> 01:45:14,666
它只是被传递给打印函数

2121
01:45:14,666 --> 01:45:18,458
这样 type的返回值就是要打印的参数 

2122
01:45:18,458 --> 01:45:22,541
因此 如果我现在运行这段代码 即type.py的Python 它就在那里 

2123
01:45:22,541 --> 01:45:24,458
清单也是一个类 

2124
01:45:24,458 --> 01:45:28,000
您可能还记得我说过 您还可以创建一个空列表

2125
01:45:28,000 --> 01:45:31,541
按字面意思做list() 

2126
01:45:31,541 --> 01:45:34,375
这有点不一致 就像我们现在可以做的那样

2127
01:45:34,375 --> 01:45:39,958
标识int和字符串 现在列出--从技术上讲 它们都是小写 

2128
01:45:39,958 --> 01:45:44,708
我不遗余力地创建了我的学生班级 以拥有这样的资本

2129
01:45:44,708 --> 01:45:46,583
这是一次会议 

2130
01:45:46,583 --> 01:45:51,250
因为int、stir、list和其他代码都是随Python一起提供的 

2131
01:45:51,250 --> 01:45:55,416
他们决定让他们的内置数据类型--尽管它们是类--

2132
01:45:55,416 --> 01:45:56,375
全是小写字母 

2133
01:45:56,375 --> 01:45:59,750
但是约定 在创建时在Python社区中的推荐

2134
01:45:59,750 --> 01:46:03,541
你们的课程是大写第一个字母 就像我做的那样 

2135
01:46:03,541 --> 01:46:10,541
在像学生这样的地方 大写S 但是list()等同于

2136
01:46:10,541 --> 01:46:12,041
两个空的方括号 

2137
01:46:12,041 --> 01:46:16,416
如果我清空屏幕并再次运行type.py 您将看到完全相同的结果 

2138
01:46:16,416 --> 01:46:17,750
这个类被称为List 

2139
01:46:17,750 --> 01:46:19,041
让我们再来一次 

2140
01:46:19,041 --> 01:46:23,041
让我将列表更改为不是方括号 而是花括号 

2141
01:46:23,041 --> 01:46:24,125
我们以前也这么做过 

2142
01:46:24,125 --> 01:46:27,916
每当我做了两个中间没有花括号的花括号时 当然 

2143
01:46:27,916 --> 01:46:31,458
是空词典 或者是Python中的Dict对象 

2144
01:46:31,458 --> 01:46:32,750
嗯 我们现在可以看到了 

2145
01:46:32,750 --> 01:46:35,500
让我清空我的屏幕 运行type.py的Python 回车 

2146
01:46:35,500 --> 01:46:37,666
这就是--班级的口头禅 “

2147
01:46:37,666 --> 01:46:39,458
它一直都在那里 

2148
01:46:39,458 --> 01:46:42,333
我们只是直到今天才把它称为一门课 

2149
01:46:42,333 --> 01:46:44,625
我同样可以明确地做这一件事 

2150
01:46:44,625 --> 01:46:48,500
我们不用两个大括号 而是用两个圆括号写出dict 

2151
01:46:48,500 --> 01:46:51,541
现在我们又有了很多圆括号 就像List一样 

2152
01:46:51,541 --> 01:46:55,250
但这只是更加清楚地表明 DICT对象的类型

2153
01:46:55,250 --> 01:46:58,333
确实是班级 DICT 本身 

2154
01:46:58,333 --> 01:47:02,375
这就是说 尽管今天的许多概念和语法都很新 

2155
01:47:02,375 --> 01:47:05,708
可能你真的在用它 也许你不知道 

2156
01:47:05,708 --> 01:47:06,750
已经好几个星期了 

2157
01:47:06,750 --> 01:47:09,416
我们现在只有一些术语来描述

2158
01:47:09,416 --> 01:47:10,958
这是我们一直在做的事情 

2159
01:47:10,958 --> 01:47:14,166
现在你有了表现力 通过一些练习 

2160
01:47:14,166 --> 01:47:18,791
要创建您自己的类 其中包含您自己的实例变量 

2161
01:47:18,791 --> 01:47:23,708
可能包装了这些属性和您自己的实例方法 

2162
01:47:23,708 --> 01:47:27,125
但事实证明 世界上还有其他类型的方法 

2163
01:47:27,125 --> 01:47:29,375
到目前为止 我一直在慎重地打电话给

2164
01:47:29,375 --> 01:47:34,375
我们的所有变量、实例变量和所有方法实例

2165
01:47:34,375 --> 01:47:35,125
方法：研究方法 

2166
01:47:35,125 --> 01:47:40,333
结果发现还有其他类型的变量和方法 

2167
01:47:40,333 --> 01:47:42,875
其中之一被称为类方法 

2168
01:47:42,875 --> 01:47:48,333
事实证明 有时这并不是真正必要或明智的

2169
01:47:48,333 --> 01:47:52,333
要将函数与类的对象相关联 

2170
01:47:52,333 --> 01:47:55,000
而是与班级本身有关 

2171
01:47:55,000 --> 01:47:59,833
实例或类的对象是其非常特定的化身 

2172
01:47:59,833 --> 01:48:03,333
再说一次 在那个有许多外观相同的建筑的社区 

2173
01:48:03,333 --> 01:48:06,458
但它们都有一点不同 因为油漆不同 

2174
01:48:06,458 --> 01:48:09,666
有时 您可能有相关的功能

2175
01:48:09,666 --> 01:48:13,541
对每一栋房子来说都不是独一无二的

2176
01:48:13,541 --> 01:48:14,333
所有的房子 

2177
01:48:14,333 --> 01:48:17,375
它的功能将是完全相同的 不是

2178
01:48:17,375 --> 01:48:19,208
让问题中的房子变得更重要 

2179
01:48:19,208 --> 01:48:21,541
面向对象编程领域也是如此 

2180
01:48:21,541 --> 01:48:24,375
有时你想要一些功能 一些动作

2181
01:48:24,375 --> 01:48:29,500
与类本身相关联 而不管特定对象的

2182
01:48:29,500 --> 01:48:32,333
自己的值或实例变量是 

2183
01:48:32,333 --> 01:48:36,125
为此 我们有一个名为@类方法的关键字 

2184
01:48:36,125 --> 01:48:38,458
这是另一个装饰者--真的 另一个

2185
01:48:38,458 --> 01:48:43,416
函数--你可以用它来指定这个方法不是 

2186
01:48:43,416 --> 01:48:46,208
默认情况下 隐式地提供一个实例方法 

2187
01:48:46,208 --> 01:48:48,791
可以访问self 对象本身 

2188
01:48:48,791 --> 01:48:51,750
这是一个不能访问self的类方法 

2189
01:48:51,750 --> 01:48:54,166
但它知道自己所在的类

2190
01:48:54,166 --> 01:48:55,625
那么我这样说是什么意思呢？

2191
01:48:55,625 --> 01:48:57,416
让我们回到VS Code 

2192
01:48:57,416 --> 01:49:01,291
我建议我们创建一个新文件 

2193
01:49:01,291 --> 01:49:04,958
分院帽的概念 也来自哈利波特的世界 

2194
01:49:04,958 --> 01:49:06,041
保持主题 

2195
01:49:06,041 --> 01:49:08,666
我将继续运行hat.py的代码 

2196
01:49:08,666 --> 01:49:12,041
在hat.py中 让我们实现排序帽的概念 

2197
01:49:12,041 --> 01:49:14,583
如果在书中和电影中不熟悉

2198
01:49:14,583 --> 01:49:17,333
有一顶尖尖的帽子

2199
01:49:17,333 --> 01:49:20,916
一个学生把它戴在头上 可以说 

2200
01:49:20,916 --> 01:49:23,708
决定学生住哪间房子--不管是

2201
01:49:23,708 --> 01:49:25,416
格兰芬多或者别的什么 

2202
01:49:25,416 --> 01:49:29,500
让我们用代码实现这个排序帽的概念 

2203
01:49:29,500 --> 01:49:33,250
当我们把一个学生的名字传递给排序帽时 

2204
01:49:33,250 --> 01:49:36,083
“哈利”这个排序帽 用代码实现 

2205
01:49:36,083 --> 01:49:40,041
会告诉我们那个学生应该在哪个房子里

2206
01:49:40,041 --> 01:49:41,750
好吧 让我们开始吧 

2207
01:49:41,750 --> 01:49:46,708
在hat.py中 首先 让我们继续定义一个名为hat的类 

2208
01:49:46,708 --> 01:49:49,333
然后让我们回到实现它本身 

2209
01:49:49,333 --> 01:49:52,041
我发现这是一个有用的技巧 不仅仅是教学

2210
01:49:52,041 --> 01:49:53,375
而是写代码的时候

2211
01:49:53,375 --> 01:49:55,291
我知道我想上帽子课 

2212
01:49:55,291 --> 01:49:57,541
我还不知道我想让它做什么

2213
01:49:57,541 --> 01:50:00,083
所以我要创建这个占位符 点 

2214
01:50:00,083 --> 01:50:01,791
所以我会回到这个话题 

2215
01:50:01,791 --> 01:50:05,000
现在让我们试着使用这个类 就好像它存在一样 

2216
01:50:05,000 --> 01:50:08,250
从那里 我也许能意识到

2217
01:50:08,250 --> 01:50:11,625
类需要具备的功能来支持我的用例 

2218
01:50:11,625 --> 01:50:14,708
让我们继续 在所有的数组中创建一个名为hat的变量

2219
01:50:14,708 --> 01:50:17,500
并实例化一个帽子对象 

2220
01:50:17,500 --> 01:50:21,041
所以不管帽子班最后是什么样子 

2221
01:50:21,041 --> 01:50:24,125
这是实例化的常用语法

2222
01:50:24,125 --> 01:50:25,916
某一类的物体 

2223
01:50:25,916 --> 01:50:28,958
在过去 我们看到学生都是小写的 

2224
01:50:28,958 --> 01:50:32,708
等于大写的学生 左括号 右括号 

2225
01:50:32,708 --> 01:50:35,375
最后 我们加上了名字和房子之类的东西 

2226
01:50:35,375 --> 01:50:39,375
现在 让我们假设这顶帽子比一个学生简单得多 

2227
01:50:39,375 --> 01:50:41,500
而且它只有分类能力 

2228
01:50:41,500 --> 01:50:44,791
因此 我甚至不会在这里传递任何论点 

2229
01:50:44,791 --> 01:50:50,708
让我假设分类帽有一个函数--其中有一个方法

2230
01:50:50,708 --> 01:50:51,583
叫 Sort 

2231
01:50:51,583 --> 01:50:59,666
因此 如果我要HAT.Sort(“Harry”) 让我们建议打印出什么房子

2232
01:50:59,666 --> 01:51:01,458
那个学生应该在里面 

2233
01:51:01,458 --> 01:51:02,541
就是这样了 

2234
01:51:02,541 --> 01:51:04,541
我要概括一下--

2235
01:51:04,541 --> 01:51:06,916
它被藏在一个帽子班里--

2236
01:51:06,916 --> 01:51:11,250
所有这些必需的功能 我将打印到屏幕上

2237
01:51:11,250 --> 01:51:12,458
什么帽子--

2238
01:51:12,458 --> 01:51:15,208
哈利属于哪所房子 

2239
01:51:15,208 --> 01:51:20,166
现在我想我需要开始实际初始化这个类了 

2240
01:51:20,166 --> 01:51:22,041
好吧 让我继续做这件事 

2241
01:51:22,041 --> 01:51:24,791
如果我不介意将帽子参数化--

2242
01:51:24,791 --> 01:51:29,083
例如 我只想对值进行排序 

2243
01:51:29,083 --> 01:51:31,916
让我们继续定义这个函数 首先是排序 

2244
01:51:31,916 --> 01:51:35,291
所以让我们定义Sort 作为第一个参数 

2245
01:51:35,291 --> 01:51:39,125
在将实例方法定义为

2246
01:51:39,125 --> 01:51:39,750
在此之前 

2247
01:51:39,750 --> 01:51:43,750
但Sort方法显然接受了程序员我的一个参数--

2248
01:51:43,750 --> 01:51:45,583
即学生的名字 

2249
01:51:45,583 --> 01:51:47,708
再说一次 我们以前见过这种二分法 

2250
01:51:47,708 --> 01:51:52,083
即使我试图传递一个参数 当我定义该方法时 

2251
01:51:52,083 --> 01:51:55,166
它需要这么多的争论 再加上一个--

2252
01:51:55,166 --> 01:51:58,208
自身 它始终将由Python自动传入

2253
01:51:58,208 --> 01:51:59,583
第一 

2254
01:51:59,583 --> 01:52:01,291
我想要做什么？

2255
01:52:01,291 --> 01:52:03,291
好吧 让我们继续做这样的事情 

2256
01:52:06,166 --> 01:52:12,375
Print 这个名字--比如“is in” “Some House” 

2257
01:52:12,375 --> 01:52:14,291
我将再次使用一些占位符代码

2258
01:52:14,291 --> 01:52:18,000
对于我自己来说 因为我不太确定如何完成这个排序

2259
01:52:18,000 --> 01:52:18,583
帽子 

2260
01:52:18,583 --> 01:52:21,708
但我认为这足以测试我的代码现在在哪里 

2261
01:52:21,708 --> 01:52:25,625
让我继续运行hat.py的Python 然后按Enter键 

2262
01:52:25,625 --> 01:52:28,250
而且看起来 哈里确实在某个房子里 

2263
01:52:28,250 --> 01:52:31,958
我们还没有完成 因为它显然没有做任何有趣的事情 

2264
01:52:31,958 --> 01:52:35,791
但它至少运行正常 没有任何错误 

2265
01:52:35,791 --> 01:52:40,125
好吧 让我们现在继续 决定在哪里--

2266
01:52:40,125 --> 01:52:43,541
通过引入一点随机性 哈里到底应该是什么样的人

2267
01:52:43,541 --> 01:52:45,625
并随机选择一所房子 

2268
01:52:45,625 --> 01:52:47,500
虽然我可以用几种方法来做到这一点 但让我们 

2269
01:52:47,500 --> 01:52:48,875
我继续做这件事 

2270
01:52:48,875 --> 01:52:51,541
我需要一份某处的房屋清单 

2271
01:52:51,541 --> 01:52:52,833
我该把它放在哪里呢？

2272
01:52:52,833 --> 01:52:54,708
我可以用不同的方法解决这个问题 

2273
01:52:54,708 --> 01:52:56,000
让我提议我做这件事 

2274
01:52:56,000 --> 01:52:58,833
让我定义一个名为init的方法 就像我以前所做的那样 

2275
01:52:58,833 --> 01:53:01,250
这是针对自己的 但没有其他论点 

2276
01:53:01,250 --> 01:53:04,583
无论何时实例化分类帽子 我们都要这样做 

2277
01:53:04,583 --> 01:53:09,958
让我们创建一个House实例变量 复数 等于这个列表--

2278
01:53:09,958 --> 01:53:16,958
格兰芬多 赫奇帕奇 拉文克劳 斯莱特林 

2279
01:53:16,958 --> 01:53:19,416
所以我们之前用过的一模一样的名单 

2280
01:53:19,416 --> 01:53:23,333
我将它存储在这个类的一个实例变量中 

2281
01:53:23,333 --> 01:53:26,708
我不会拿自己以外的任何论点来灌输 

2282
01:53:26,708 --> 01:53:30,625
但我只是需要这个值列表的某个地方 例如 

2283
01:53:30,625 --> 01:53:32,250
那么我能在这里做些什么呢？

2284
01:53:32,250 --> 01:53:36,416
好吧 让我继续把一些房子换成真正的房子 

2285
01:53:36,416 --> 01:53:37,541
那么 我在这里能做什么呢？

2286
01:53:37,541 --> 01:53:39,583
嗯 我想在那里建一栋房子 

2287
01:53:39,583 --> 01:53:42,083
好 让我们继续创建一个名为house的变量 

2288
01:53:42,083 --> 01:53:46,291
如果你回想一下我们在随机模块中对库的讨论 

2289
01:53:46,291 --> 01:53:51,791
有一个名为Choose的函数 如果您传入一个选项列表 

2290
01:53:51,791 --> 01:53:56,333
就像自己的房子一样 它会从这四个房子中随机挑选一座房子 

2291
01:53:56,333 --> 01:53:58,750
然后在第7行 我可以把它传进去 

2292
01:53:58,750 --> 01:54:01,916
如果我想加强这一点 让我继续并突出显示该代码 

2293
01:54:01,916 --> 01:54:03,125
去掉变量 

2294
01:54:03,125 --> 01:54:04,541
从技术上讲 这是不必要的 

2295
01:54:04,541 --> 01:54:06,666
而且由于代码行仍然很短 

2296
01:54:06,666 --> 01:54:09,458
我可以把所有的事情都放在一句话里 

2297
01:54:09,458 --> 01:54:13,000
但我肯定可以像刚才一样使用这个变量 

2298
01:54:13,000 --> 01:54:14,041
那么我做了什么呢？

2299
01:54:14,041 --> 01:54:20,708
在我的init函数中 我定义了对象的初始化

2300
01:54:20,708 --> 01:54:23,875
储存在自己的房子里 有四栋房子 

2301
01:54:23,875 --> 01:54:26,583
然后 在某种程度上 我访问了同样的列表 

2302
01:54:26,583 --> 01:54:30,041
但我随机选择了那里的一套房子 

2303
01:54:30,041 --> 01:54:31,791
现在 我为什么要这样做呢？

2304
01:54:31,791 --> 01:54:33,750
这也是普遍的惯例 

2305
01:54:33,750 --> 01:54:35,916
任何时候你有一张清单--谁知道呢？

2306
01:54:35,916 --> 01:54:38,000
也许会随着时间的推移而改变 

2307
01:54:38,000 --> 01:54:41,541
像哈佛这样的地方多年来一直在建造新房子 

2308
01:54:41,541 --> 01:54:43,958
因此 您可能需要更改可用房屋的列表 

2309
01:54:43,958 --> 01:54:47,083
这并没有出现在哈利波特的七本书或八部电影中 

2310
01:54:47,083 --> 01:54:49,208
但你可以想象也许霍格沃茨最终

2311
01:54:49,208 --> 01:54:54,291
有第五宫 所以把常量列表放在

2312
01:54:54,291 --> 01:54:57,333
在你的文件顶部 在类的顶部 所以它只是

2313
01:54:57,333 --> 01:54:59,875
很明显 值的列表是什么 

2314
01:54:59,875 --> 01:55:02,750
你不一定想把它藏在某些功能中 

2315
01:55:02,750 --> 01:55:06,375
就像排序一样 特别是当你想使用这个函数的时候--

2316
01:55:06,375 --> 01:55:10,166
抱歉 特别是如果您想在多个功能中使用该列表 而不是

2317
01:55:10,166 --> 01:55:10,708
只是整理一下 

2318
01:55:10,708 --> 01:55:12,583
但如果我继续增加这门课 你可能会

2319
01:55:12,583 --> 01:55:15,083
想要在多个功能中使用相同的房屋列表 

2320
01:55:15,083 --> 01:55:20,541
因此 让我们通过将其存储在self.house中来将其保存在对象本身中 

2321
01:55:20,541 --> 01:55:23,625
好吧 好吧 我们可能要改变历史进程了 

2322
01:55:23,625 --> 01:55:27,666
让我来做一个HAT.PY的蟒蛇 我想我们即将把Harry

2323
01:55:27,666 --> 01:55:30,833
去那四所房子中的一所 

2324
01:55:30,833 --> 01:55:33,041
嗯 名字错误 

2325
01:55:33,041 --> 01:55:35,041
未定义名称‘RANDOM’ 

2326
01:55:35,041 --> 01:55:38,416
嗯 等一下 我哪里出错了？

2327
01:55:38,416 --> 01:55:43,541
回想一下我们关于图书馆的课程 为什么我的代码崩溃了 而没有告诉我

2328
01:55:43,541 --> 01:55:45,625
哈里要去哪里？

2329
01:55:45,625 --> 01:55:48,708
观众：您没有导入随机库 

2330
01:55:48,708 --> 01:55:49,708
大卫·J·马兰：没错 

2331
01:55:49,708 --> 01:55:52,541
如果我想使用随机库或模块 

2332
01:55:52,541 --> 01:55:55,583
我需要在我的文件顶部告诉Python这一点 

2333
01:55:55,583 --> 01:55:58,958
所以让我在这里做随机导入 

2334
01:55:58,958 --> 01:56:01,708
然后 在这下面 让我继续清除我的终端窗口

2335
01:56:01,708 --> 01:56:02,416
再试一次 

2336
01:56:02,416 --> 01:56:08,041
在我的手指上祈祷 看看哈里将会在哪里结束 

2337
01:56:08,041 --> 01:56:12,041
好了 哈里现在正式加入赫奇帕奇了 

2338
01:56:12,041 --> 01:56:14,500
不管你读过或看到过什么 

2339
01:56:14,500 --> 01:56:15,875
好吧 让我们再来一次 

2340
01:56:15,875 --> 01:56:19,833
让我清理我的窗口并运行Python中的hat.py 现在他在RavenClaw 

2341
01:56:19,833 --> 01:56:21,541
这与使用随机数是一致的 

2342
01:56:21,541 --> 01:56:23,375
我们清除它 然后再运行一次 

2343
01:56:23,375 --> 01:56:25,458
他还在拉文克劳 但这是有可能的

2344
01:56:25,458 --> 01:56:26,833
尽管有四个选择 

2345
01:56:26,833 --> 01:56:27,625
我们再来一次吧 

2346
01:56:27,625 --> 01:56:29,250
赫奇帕奇--回到赫奇帕奇 

2347
01:56:29,250 --> 01:56:31,666
我们似乎得不到正确的答案 

2348
01:56:31,666 --> 01:56:34,375
现在他在格兰芬多 尽管是随机的 

2349
01:56:34,375 --> 01:56:37,208
因此 我们似乎有一个项目 基于这些有限的测试 

2350
01:56:37,208 --> 01:56:41,166
似乎是在随机给哈里分配一所房子 

2351
01:56:41,166 --> 01:56:45,416
现在 我有点懒得让SORT打印出这个值 

2352
01:56:45,416 --> 01:56:50,375
我可以做其他的事情 比如返回一个字符串 然后让我在第13行 

2353
01:56:50,375 --> 01:56:51,916
帮我打印一下 

2354
01:56:51,916 --> 01:56:57,000
但就目前而言 我认为我们有一个名为Hat的班级的例子 

2355
01:56:57,000 --> 01:57:00,125
尽管如此 今天还是应用了我们到目前为止学到的一些经验教训 

2356
01:57:00,125 --> 01:57:03,333
在那里我创建了一个类--因为坦率地说 分院帽是--

2357
01:57:03,333 --> 01:57:06,250
好吧 我正要说真实世界的实体 但真的

2358
01:57:06,250 --> 01:57:07,875
一个虚幻的世界实体 

2359
01:57:07,875 --> 01:57:11,791
事实上 这可能是一种常见的启发式或心智模式 

2360
01:57:11,791 --> 01:57:16,041
应该在什么时候使用类来表示代码中的某些内容？

2361
01:57:16,041 --> 01:57:20,625
通常 当你试图代表一些真实世界的实体时

2362
01:57:20,625 --> 01:57:25,791
或者是幻想世界的实体 比如学生 这是现实世界中的东西 

2363
01:57:25,791 --> 01:57:28,625
就像一顶分院帽 好吧 根本不存在 

2364
01:57:28,625 --> 01:57:32,166
但它确实是这样的 所以有一个关于HAT的类是很合理的 

2365
01:57:32,166 --> 01:57:36,500
类代表真实世界实体的情况并不总是这样 

2366
01:57:36,500 --> 01:57:42,291
但到目前为止 我们已经看到int、stir、list和dict--这些

2367
01:57:42,291 --> 01:57:44,666
都是你在现实世界中可能会有的结构 

2368
01:57:44,666 --> 01:57:47,416
我们有整数和文本字符串以及其他东西 

2369
01:57:47,416 --> 01:57:50,833
因此 更严格地说 甚至代表这些东西也是有意义的 

2370
01:57:50,833 --> 01:57:52,625
也使用类 

2371
01:57:52,625 --> 01:57:56,291
你可以只用一本词典来代表一个学生或一顶帽子 

2372
01:57:56,291 --> 01:58:00,875
但同样 类带来了所有这些 甚至更多的功能 

2373
01:58:00,875 --> 01:58:06,791
但老实说 我在这里并没有以“正确的方式”使用类 

2374
01:58:06,791 --> 01:58:07,416
为什么？

2375
01:58:07,416 --> 01:58:10,625
好吧 在哈利波特的世界里 真的只有 

2376
01:58:10,625 --> 01:58:12,791
据我所知 一顶分院帽 

2377
01:58:12,791 --> 01:58:17,000
然而 在这里 我实现了一个名为Hat的类 

2378
01:58:17,000 --> 01:58:20,333
同样 类就像一张蓝图 一个模板 

2379
01:58:20,333 --> 01:58:24,625
允许您在其中创建一个或多个对象的模具 

2380
01:58:24,625 --> 01:58:27,041
到目前为止 我的大多数程序都很简单 

2381
01:58:27,041 --> 01:58:28,750
我刚刚创造了一个学生 

2382
01:58:28,750 --> 01:58:31,208
但可以肯定的是 如果我花更多的时间和编写更多的代码 

2383
01:58:31,208 --> 01:58:33,583
您可以想象编写一个程序 

2384
01:58:33,583 --> 01:58:36,208
有一份学生名单--更多的学生

2385
01:58:36,208 --> 01:58:38,708
而不仅仅是我们一直在演示的那个 

2386
01:58:38,708 --> 01:58:40,625
然而 这会有点奇怪--

2387
01:58:40,625 --> 01:58:43,291
这与现实或幻想有点不一致

2388
01:58:43,291 --> 01:58:48,041
哈利波特世界实例化一个、两个、三个或更多的分类帽子 

2389
01:58:48,041 --> 01:58:49,708
真的只有一个 

2390
01:58:49,708 --> 01:58:51,875
真的只有一个人 如果你愿意的话 那就是

2391
01:58:51,875 --> 01:58:54,458
在许多编程环境中 这是一种艺术术语 

2392
01:58:54,458 --> 01:58:58,125
所以让我建议我们实际上改进分拣帽的设计

2393
01:58:58,125 --> 01:59:03,083
这样我们就不必实例化分类帽了 因为现在

2394
01:59:03,083 --> 01:59:08,791
允许我做一些像帽子1=帽子 帽子2=帽子 帽子3= 

2395
01:59:08,791 --> 01:59:09,458
以此类推 

2396
01:59:09,458 --> 01:59:11,291
我并不真的需要这种能力 

2397
01:59:11,291 --> 01:59:15,250
我真的只需要用一个类来表示分拣帽 

2398
01:59:15,250 --> 01:59:17,125
但我真的不需要实例化它 

2399
01:59:17,125 --> 01:59:17,625
为什么？

2400
01:59:17,625 --> 01:59:18,708
因为它已经存在了 

2401
01:59:18,708 --> 01:59:19,625
我只需要一个 

2402
01:59:19,625 --> 01:59:23,041
所以事实证明 在Python中 到目前为止 

2403
01:59:23,041 --> 01:59:25,833
我们一直在使用 就像我一直叫它们的 实例方法--

2404
01:59:25,833 --> 01:59:30,416
在自动传递引用的类中编写函数

2405
01:59:30,416 --> 01:59:32,375
设置为自身 即当前对象 

2406
01:59:32,375 --> 01:59:34,375
但有时你就是不需要这样 

2407
01:59:34,375 --> 01:59:37,083
有时候 仅仅知道这个类是什么就足够了

2408
01:59:37,083 --> 01:59:40,875
并假设甚至可能没有该类的任何对象 

2409
01:59:40,875 --> 01:59:45,666
因此 从这个意义上说 您可以将类真正用作数据的容器

2410
01:59:45,666 --> 01:59:50,291
和/或在概念上有某种关联的功能--

2411
01:59:50,291 --> 01:59:52,791
和分院帽有关的东西 

2412
01:59:52,791 --> 01:59:56,083
还有另一个称为@类方法的装饰符或函数

2413
01:59:56,083 --> 01:59:57,750
使我们能够做到这一点 

2414
01:59:57,750 --> 01:59:59,375
现在让我回到我的代码 

2415
01:59:59,375 --> 02:00:05,041
让我提议 如果我不打算实例化多个房屋 

2416
02:00:05,041 --> 02:00:07,916
我真的不需要这个init方法 因为它真的

2417
02:00:07,916 --> 02:00:12,250
旨在从该蓝图、该模板、

2418
02:00:12,250 --> 02:00:13,083
那个霉菌 

2419
02:00:13,083 --> 02:00:14,708
所以让我把这个处理掉 

2420
02:00:14,708 --> 02:00:17,791
但如果我摆脱了这一切 我就再也无法接触到自我了 

2421
02:00:17,791 --> 02:00:22,750
但这没问题 因为事实证明 除了他们现有的班级

2422
02:00:22,750 --> 02:00:26,416
方法 还有我们所说的类变量 

2423
02:00:26,416 --> 02:00:30,791
并且类变量存在于类本身中 

2424
02:00:30,791 --> 02:00:33,833
而这个变量只有一个副本

2425
02:00:33,833 --> 02:00:35,958
对于它的所有目的 

2426
02:00:35,958 --> 02:00:40,291
如果您愿意的话 它们都共享同一个变量--可以是int还是str

2427
02:00:40,291 --> 02:00:41,750
或者 在这种情况下 是一份名单 

2428
02:00:41,750 --> 02:00:49,041
所以我在这里所做的就是在我的HAT类中 在一个类变量中定义

2429
02:00:49,041 --> 02:00:50,208
所谓的房子--

2430
02:00:50,208 --> 02:00:53,083
我不说自我 是因为自我不再相关 

2431
02:00:53,083 --> 02:00:54,791
自我是指特定的对象 

2432
02:00:54,791 --> 02:00:58,166
我希望这个类中有一个变量 也就是 

2433
02:00:58,166 --> 02:01:00,791
与该列表相等的类变量 

2434
02:01:00,791 --> 02:01:03,708
因为它在这顶帽子里 现在 同学们 

2435
02:01:03,708 --> 02:01:07,208
我可以在我的任何函数中使用该列表 

2436
02:01:07,208 --> 02:01:08,958
我现在只有一个 叫Sort 

2437
02:01:08,958 --> 02:01:11,791
但如果我有更多 所有这些方法都可以访问它

2438
02:01:11,791 --> 02:01:12,666
也是 

2439
02:01:12,666 --> 02:01:15,791
而对于排序 这也没有真正意义上的意义

2440
02:01:15,791 --> 02:01:19,250
在特定的分类帽子中进行排序 因为我再次

2441
02:01:19,250 --> 02:01:20,500
我只想有一个 

2442
02:01:20,500 --> 02:01:25,875
所以我实际上可以通过说@类方法来指定这是类方法 

2443
02:01:25,875 --> 02:01:28,083
我再也不会通过赛尔夫了 

2444
02:01:28,083 --> 02:01:33,250
实际上 按照惯例 我传入了对类本身的引用 

2445
02:01:33,250 --> 02:01:35,250
它通常被写成CLS 

2446
02:01:35,250 --> 02:01:35,791
为什么？

2447
02:01:35,791 --> 02:01:40,916
那么 如果你写的是C-L-A-S-S 那实际上就和这个关键词有冲突

2448
02:01:40,916 --> 02:01:42,791
我们在这里一直用的“类”这个词 

2449
02:01:42,791 --> 02:01:47,125
所以世界意识到 哦 我们不能在这里重复使用同样的短语 

2450
02:01:47,125 --> 02:01:48,833
所以我们就把这门课叫作 

2451
02:01:48,833 --> 02:01:51,541
这在某些情况下很有用 包括这一点 

2452
02:01:51,541 --> 02:01:52,041
为什么？

2453
02:01:52,041 --> 02:01:54,125
好了 注意我现在能做什么 

2454
02:01:54,125 --> 02:01:56,916
我现在可以把自己变成一个普通的人了 

2455
02:01:56,916 --> 02:01:57,541
为什么？

2456
02:01:57,541 --> 02:02:02,708
因为house现在--不是一个实例变量 可以通过self.house访问 

2457
02:02:02,708 --> 02:02:07,041
它现在是一个类变量 可以通过类.house访问 

2458
02:02:07,041 --> 02:02:10,375
或者从技术上讲 在这起案件中是Cls.House 

2459
02:02:10,375 --> 02:02:12,666
但现在 最后的繁荣是这样的 

2460
02:02:12,666 --> 02:02:19,208
现在 我不必像以前在这里第13行那样实例化任何HAT对象 

2461
02:02:19,208 --> 02:02:22,833
我可以只使用这个类附带的功能 

2462
02:02:22,833 --> 02:02:24,791
所以我要把这一行全部删除 

2463
02:02:24,791 --> 02:02:32,416
我将在这条新的13行上大写帽子 然后只说Hat 排序 

2464
02:02:32,416 --> 02:02:33,333
(“哈利”) 

2465
02:02:33,333 --> 02:02:34,750
那么我做了什么呢？

2466
02:02:34,750 --> 02:02:38,541
我没有费心实例化一个类型为Hat的对象 

2467
02:02:38,541 --> 02:02:42,791
我只是在访问HAT类内部的一个类方法

2468
02:02:42,791 --> 02:02:43,666
那--你知道吗？

2469
02:02:43,666 --> 02:02:45,208
都会奏效的 

2470
02:02:45,208 --> 02:02:46,708
这就是类方法的工作方式 

2471
02:02:46,708 --> 02:02:51,041
您使用类名、大写字母和全部、点方法名、

2472
02:02:51,041 --> 02:02:53,041
传递您想要的任何参数 

2473
02:02:53,041 --> 02:02:57,000
Python将自动传入某个变量 通过该变量

2474
02:02:57,000 --> 02:03:00,625
您可以在该函数中引用该类

2475
02:03:00,625 --> 02:03:02,458
您在该类中实现的

2476
02:03:02,458 --> 02:03:04,125
这样我才能做这样的事 

2477
02:03:04,125 --> 02:03:07,833
这并不是说我希望在这个函数中有一个名为house的本地变量 

2478
02:03:07,833 --> 02:03:12,541
我想要与当前类关联的名为house的变量

2479
02:03:12,541 --> 02:03:17,166
因此 我仍然可以访问我在第6行定义的相同列表 

2480
02:03:17,166 --> 02:03:21,500
现在 如果我返回到我的终端并运行Hot.py的Python 

2481
02:03:21,500 --> 02:03:24,875
进来吧 哈里还在赫奇帕奇 

2482
02:03:24,875 --> 02:03:27,041
哈利又一次加入了赫奇帕奇乐队 

2483
02:03:27,041 --> 02:03:31,250
哈利回到了格兰芬多 至少是随机的 

2484
02:03:31,250 --> 02:03:36,333
现在 关于这些类变量或类方法的问题 

2485
02:03:36,333 --> 02:03:41,416
它们与实例变量和实例方法形成对比 

2486
02:03:41,416 --> 02:03:43,875
至少有一件事 那是有点奇怪的

2487
02:03:43,875 --> 02:03:47,666
这就是 尽管有一个叫做“类方法”的装饰者 

2488
02:03:47,666 --> 02:03:51,291
没有一种方法叫@instancemthod 

2489
02:03:51,291 --> 02:03:55,666
在以下情况下 一个方法就自动成为所谓的“即时方法”

2490
02:03:55,666 --> 02:03:57,541
你不需要任何装饰者来定义它 

2491
02:03:57,541 --> 02:04:00,291
观众：你能在另一个班级里有一个班级吗？

2492
02:04:00,291 --> 02:04:01,291
大卫·J·马兰：你可以的 

2493
02:04:01,291 --> 02:04:03,666
您可以在另一个类中定义一个类 

2494
02:04:03,666 --> 02:04:06,041
一般来说 这并没有完成 但在那里

2495
02:04:06,041 --> 02:04:08,416
在某些情况下 它可能会有所帮助 尤其是

2496
02:04:08,416 --> 02:04:10,625
用于更大、更复杂的程序 

2497
02:04:10,625 --> 02:04:13,541
所以 是的 这是可能的 

2498
02:04:13,541 --> 02:04:14,750
其他问题 

2499
02:04:14,750 --> 02:04:17,958
观众：问题是关于房子本身的 

2500
02:04:17,958 --> 02:04:25,083
当我们删除它并传递数据时 变量本身就会被创建 

2501
02:04:25,083 --> 02:04:27,458
S 我们为什么要去除自我？

2502
02:04:27,458 --> 02:04:29,625
大卫·J·马兰：在前面的例子中--

2503
02:04:29,625 --> 02:04:32,625
无论是帽子演示还是所有学生

2504
02:04:32,625 --> 02:04:36,708
演示--我们创造了一个学生

2505
02:04:36,708 --> 02:04:40,625
对象 大写S 左括号 右括号 

2506
02:04:40,625 --> 02:04:43,125
最后 带着名字和一栋房子进来了 

2507
02:04:43,125 --> 02:04:46,833
然后我们使用了双下划线初始化方法

2508
02:04:46,833 --> 02:04:52,708
初始化self.name和self.house实例变量

2509
02:04:52,708 --> 02:04:55,333
与这些相应的值对应 

2510
02:04:55,333 --> 02:04:57,750
在这个最新版本的分院帽中 

2511
02:04:57,750 --> 02:05:02,166
我在任何地方都没有为自己操心 只是因为 从概念上讲 我

2512
02:05:02,166 --> 02:05:05,708
不需要也不希望世界上有多顶帽子 

2513
02:05:05,708 --> 02:05:11,041
我只是将这个类作为一个容器来打包这个房屋列表 

2514
02:05:11,041 --> 02:05:12,500
这种排序功能 

2515
02:05:12,500 --> 02:05:14,875
也许最终都会给它增加更多的功能 

2516
02:05:14,875 --> 02:05:15,875
但仅此而已 

2517
02:05:15,875 --> 02:05:18,833
因此 有时您可以使用面向对象的编程

2518
02:05:18,833 --> 02:05:22,458
以这种稍微不同的方式 当您想要有功能时

2519
02:05:22,458 --> 02:05:25,333
但它并不特定于任何一顶特定的帽子 

2520
02:05:25,333 --> 02:05:29,416
它是专门针对分拣帽本身的 

2521
02:05:29,416 --> 02:05:33,958
现在再来看另一个问题 关于这些类变量或方法--只是

2522
02:05:33,958 --> 02:05:37,000
使用面向对象编程的另一种方法 但要解决

2523
02:05:37,000 --> 02:05:38,541
一个有点不同的问题？

2524
02:05:38,541 --> 02:05:40,916
观众：嗯 这两门课有什么不同

2525
02:05:40,916 --> 02:05:44,833
帽子和帽子的作用？

2526
02:05:44,833 --> 02:05:46,166
大卫·J·马兰：问得好 

2527
02:05:46,166 --> 02:05:48,500
那么 我们为什么要使用一个类 而不仅仅是

2528
02:05:48,500 --> 02:05:51,916
有一个名为hat.py的文件 其中包含一个名为

2529
02:05:51,916 --> 02:05:54,500
房屋和一个名为Sort的函数？

2530
02:05:54,500 --> 02:05:56,166
为什么我们要增加这种复杂性？

2531
02:05:56,166 --> 02:05:58,958
在这种特殊情况下 我们不一定需要这样做 

2532
02:05:58,958 --> 02:06:01,166
我完全可以走进这里 

2533
02:06:01,166 --> 02:06:02,833
我可以把这门课赶走 

2534
02:06:02,833 --> 02:06:05,625
我可以解开这个凹痕 

2535
02:06:05,625 --> 02:06:07,666
我可以除掉这个装饰师 

2536
02:06:07,666 --> 02:06:09,541
这样我就可以摆脱帽点了 

2537
02:06:09,541 --> 02:06:12,291
我可以这样做 另外

2538
02:06:12,291 --> 02:06:14,208
让我们说 让我们摆脱这里的类 

2539
02:06:14,208 --> 02:06:15,833
让我们把这里的课去掉吧 

2540
02:06:15,833 --> 02:06:19,833
现在运行hat.py的Python 回车 它仍然可以工作 

2541
02:06:19,833 --> 02:06:22,125
把哈利放错了房间 但这就是我们所拥有的--

2542
02:06:22,125 --> 02:06:23,208
随机发生的事情 

2543
02:06:23,208 --> 02:06:24,500
这也很好 

2544
02:06:24,500 --> 02:06:27,750
我们今天要介绍的是 通过面向对象编程 

2545
02:06:27,750 --> 02:06:30,208
是一种不同的建模世界的方式 

2546
02:06:30,208 --> 02:06:32,916
像这样的例子并不能令人信服 

2547
02:06:32,916 --> 02:06:35,125
坦率地说 这是相对简单的 

2548
02:06:35,125 --> 02:06:36,125
这并不是很复杂 

2549
02:06:36,125 --> 02:06:37,416
没有太多的功能 

2550
02:06:37,416 --> 02:06:40,875
老实说 我们刚刚输入的版本--这10行--这很好 

2551
02:06:40,875 --> 02:06:42,208
这就解决了这个问题 

2552
02:06:42,208 --> 02:06:45,708
但随着我们的代码变得更长 随着我们开始与其他人合作 

2553
02:06:45,708 --> 02:06:48,666
随着我们试图用代码解决的问题变得越来越复杂 

2554
02:06:48,666 --> 02:06:52,125
您会发现您的代码很快就会变得杂乱无章 

2555
02:06:52,125 --> 02:06:55,458
你会发现你有大量的功能 例如 

2556
02:06:55,458 --> 02:06:56,500
在一个文件中 

2557
02:06:56,500 --> 02:06:59,958
它们中的一些是相互关联的 而另一些是不相关的 

2558
02:06:59,958 --> 02:07:02,625
嗯 在这一点上 组织他们不是很好吗？

2559
02:07:02,625 --> 02:07:03,500
有点不同吗？

2560
02:07:03,500 --> 02:07:06,500
在哈利波特的世界里 让我们为学生开设一个班级；

2561
02:07:06,500 --> 02:07:09,916
让我们为教授上课；让我们为分院帽上课；

2562
02:07:09,916 --> 02:07:11,708
我们来上一堂其他的课吧 

2563
02:07:11,708 --> 02:07:14,625
因此 一旦你的世界变得比一些

2564
02:07:14,625 --> 02:07:17,791
当我们想要集中注意力时 我们在课堂上做的演示

2565
02:07:17,791 --> 02:07:21,500
就个人观点而言 面向对象编程只是一种方式

2566
02:07:21,500 --> 02:07:24,083
封装相关数据--

2567
02:07:24,083 --> 02:07:27,291
也就是说 变量相关的功能--也就是方法--

2568
02:07:27,291 --> 02:07:29,583
在有名字的东西里面 

2569
02:07:29,583 --> 02:07:31,625
这些东西被称为类 

2570
02:07:31,625 --> 02:07:33,750
所以这只是解决问题的另一种方式 

2571
02:07:33,750 --> 02:07:36,125
几周前 当我们关注图书馆时 

2572
02:07:36,125 --> 02:07:38,791
这也是同样问题的另一种解决方案 

2573
02:07:38,791 --> 02:07:42,291
你可以定义你自己的模块或包 把你的一些数据

2574
02:07:42,291 --> 02:07:44,708
和/或功能 这也是很好的 

2575
02:07:44,708 --> 02:07:48,000
有时你应该使用哪一个是重叠的 

2576
02:07:48,000 --> 02:07:51,333
如果你熟悉维恩图 重叠区域

2577
02:07:51,333 --> 02:07:54,791
可能意味着您可以使用类；您可以使用模块或包；

2578
02:07:54,791 --> 02:07:57,500
您可以只使用单个本地文件 

2579
02:07:57,500 --> 02:07:59,916
随着时间的推移 你会发展出一种本能 甚至

2580
02:07:59,916 --> 02:08:04,291
个人对要使用的工具的偏好 

2581
02:08:04,291 --> 02:08:08,416
好的 现在让我提议 我们应用类方法的相同概念

2582
02:08:08,416 --> 02:08:10,583
来清理另一件事 

2583
02:08:10,583 --> 02:08:16,041
让我关闭Hot.py并重新打开之前离开的Student.py 

2584
02:08:16,041 --> 02:08:19,500
让我继续下去 把它简化一点 

2585
02:08:19,500 --> 02:08:22,750
我要继续下去 处理掉这些房产 

2586
02:08:22,750 --> 02:08:24,666
不是因为他们有什么不对劲 

2587
02:08:24,666 --> 02:08:27,416
但仅仅因为我想让我们把注意力集中在一些关键的想法上

2588
02:08:27,416 --> 02:08:29,333
当我们开始这个节目的时候 

2589
02:08:29,333 --> 02:08:31,750
因此 我将继续并保持Main 

2590
02:08:31,750 --> 02:08:35,583
我不会反驳地试图更改亨利在那里的地址 

2591
02:08:35,583 --> 02:08:38,666
不过 我打算继续 只打印学生 

2592
02:08:38,666 --> 02:08:41,750
但这是我在这里想要重点关注的事情 

2593
02:08:41,750 --> 02:08:46,541
在我们前面的学生示例中 这是一个错失的机会

2594
02:08:46,541 --> 02:08:48,125
来清理我的代码 

2595
02:08:48,125 --> 02:08:49,708
我这么说是什么意思？

2596
02:08:49,708 --> 02:08:51,750
好的 在这个文件的顶部--甚至

2597
02:08:51,750 --> 02:08:53,958
虽然我简化了它 但去掉了属性

2598
02:08:53,958 --> 02:08:55,708
以及所有的错误检查--因为我

2599
02:08:55,708 --> 02:08:58,708
现在我想把重点放在这门课的本质上--只讲学生的名字

2600
02:08:58,708 --> 02:09:00,875
以及房子和它的印刷品 

2601
02:09:00,875 --> 02:09:05,000
这是面向对象编程中类的本质 

2602
02:09:05,000 --> 02:09:09,666
理论上讲 我所有针对学生的功能 

2603
02:09:09,666 --> 02:09:14,083
也就是说 如果我有一个学生的功能和数据 你 

2604
02:09:14,083 --> 02:09:16,583
程序员 我的同事 会认为

2605
02:09:16,583 --> 02:09:18,875
它们都被捆绑在一起 被封装起来 所以

2606
02:09:18,875 --> 02:09:20,791
要说 在学生班里 

2607
02:09:20,791 --> 02:09:24,208
然而 如果你进一步向下滚动 这是什么？

2608
02:09:24,208 --> 02:09:27,458
有一个名为Get_Student的函数 它只存在于其他地方

2609
02:09:27,458 --> 02:09:31,166
在该文件中 提示用户输入名称 提示用户输入房屋 

2610
02:09:31,166 --> 02:09:34,083
创建学生对象 然后返回 

2611
02:09:34,083 --> 02:09:35,500
这没有错 

2612
02:09:35,500 --> 02:09:36,208
它起作用了 

2613
02:09:36,208 --> 02:09:39,041
我们看到了很多很多次 它一直在工作 

2614
02:09:39,041 --> 02:09:42,208
但这有点奇怪 因为如果这

2615
02:09:42,208 --> 02:09:45,208
是一个帮助你获得一个学生的函数 

2616
02:09:45,208 --> 02:09:48,916
帮你查到一个学生的名字和住处 为什么不

2617
02:09:48,916 --> 02:09:51,125
类本身中的功能吗？

2618
02:09:51,125 --> 02:09:54,291
毕竟 随着我的代码变得越来越复杂 做的事情越来越多 

2619
02:09:54,291 --> 02:09:56,125
我要看的是学生们的课

2620
02:09:56,125 --> 02:09:57,750
用于所有与学生相关的功能 

2621
02:09:57,750 --> 02:10:00,625
我不会向下滚动 期待着 哦 也许有

2622
02:10:00,625 --> 02:10:04,708
其他一些学生功能只是随机出现在这个文件的后面 

2623
02:10:04,708 --> 02:10:05,958
所以这不是错的 

2624
02:10:05,958 --> 02:10:09,625
但这再次证明了可能是糟糕的设计--

2625
02:10:09,625 --> 02:10:11,541
对于这个小程序 就不是那么多了 

2626
02:10:11,541 --> 02:10:14,458
但这又是一个代码气味的例子 

2627
02:10:14,458 --> 02:10:16,000
这里有股不对劲的味道 

2628
02:10:16,000 --> 02:10:17,791
这可能会给我们带来麻烦

2629
02:10:17,791 --> 02:10:20,791
通过分离相关功能 

2630
02:10:20,791 --> 02:10:24,541
因此 这再一次是设计原则 而不是正确性问题 

2631
02:10:24,541 --> 02:10:27,958
但是类方法也允许我们解决这个问题 

2632
02:10:27,958 --> 02:10:29,791
让我继续做这件事 

2633
02:10:29,791 --> 02:10:32,666
我要一起删除Get_Student 离开

2634
02:10:32,666 --> 02:10:35,458
这里只有main作为我的另一个函数 

2635
02:10:35,458 --> 02:10:38,541
在我的学生课堂上 我要这么做 

2636
02:10:38,541 --> 02:10:42,375
我将定义一个函数 更简单地称为GET 

2637
02:10:42,375 --> 02:10:45,291
从类方法的工作方式来看 它是

2638
02:10:45,291 --> 02:10:47,625
将采用类本身的名称

2639
02:10:47,625 --> 02:10:49,833
或将其作为论据引用 

2640
02:10:49,833 --> 02:10:53,083
我将把功能从Get_Student移到学生中

2641
02:10:53,083 --> 02:10:53,583
班级 

2642
02:10:53,583 --> 02:10:58,750
我将这样做--名字等于输入、引号、不引号、名字、房子

2643
02:10:58,750 --> 02:11:01,708
等于输入、引用、不引用、房子 

2644
02:11:01,708 --> 02:11:04,291
然后这个函数要做的是

2645
02:11:04,291 --> 02:11:11,333
是通过调用类返回一个新学生对象 同样 这也只是

2646
02:11:11,333 --> 02:11:14,250
自动传入的对类的引用

2647
02:11:14,250 --> 02:11:17,666
本身 传递名字和房子 

2648
02:11:17,666 --> 02:11:22,916
我承认这个语法看起来有点奇怪 现在我调用CLS

2649
02:11:22,916 --> 02:11:24,375
我把这些论点传递给大家 

2650
02:11:24,375 --> 02:11:26,125
但让我在这里做最后一次修正 

2651
02:11:26,125 --> 02:11:28,041
让我转到此函数的顶部 然后执行更多操作

2652
02:11:28,041 --> 02:11:31,125
显式地说这是一个类方法 

2653
02:11:31,125 --> 02:11:34,541
这解决了一个潜在的鸡和蛋的问题 可以说 

2654
02:11:34,541 --> 02:11:37,291
因此 潜在地 一个需要先于另一个 

2655
02:11:37,291 --> 02:11:39,250
那我在这里做什么？

2656
02:11:39,250 --> 02:11:43,916
在我的学生类中 我现在有一个名为Get的函数 

2657
02:11:43,916 --> 02:11:47,333
我要说 它是一个类方法 这意味着什么 

2658
02:11:47,333 --> 02:11:53,000
它只是意味着我可以调用此方法 而无需实例化学生

2659
02:11:53,000 --> 02:11:54,125
对象优先 

2660
02:11:54,125 --> 02:11:57,333
这就是潜在的鸡和蛋的问题 

2661
02:11:57,333 --> 02:12:00,375
如果不熟悉 这是一种表达 意思是 很好 并做了世界

2662
02:12:00,375 --> 02:12:03,291
先有下蛋的鸡 还是有蛋？

2663
02:12:03,291 --> 02:12:06,958
然后生下了鸡 但鸡蛋是如何到达那里的呢？

2664
02:12:06,958 --> 02:12:08,791
这是一个奇怪的循环问题 

2665
02:12:08,791 --> 02:12:10,208
这就是我们现在面临的问题 

2666
02:12:10,208 --> 02:12:16,375
如果您必须创建一个学生对象才能调用Get 

2667
02:12:16,375 --> 02:12:19,791
为了得到另一个学生对象 

2668
02:12:19,791 --> 02:12:20,875
这听起来很乱 

2669
02:12:20,875 --> 02:12:24,833
让我们通过类方法来获取一个学生

2670
02:12:24,833 --> 02:12:29,125
根据定义 这不需要您首先创建一个学生对象 

2671
02:12:29,125 --> 02:12:33,166
就像帽子一样 在它的最终形式中 我们使用Hat类

2672
02:12:33,166 --> 02:12:35,833
就说Hat 大写H 点排序 

2673
02:12:35,833 --> 02:12:37,458
我们不需要先制作一顶帽子 

2674
02:12:37,458 --> 02:12:39,708
我们只是使用了类本身 

2675
02:12:39,708 --> 02:12:41,791
那么我现在要在这里做什么？

2676
02:12:41,791 --> 02:12:43,041
让我下到主楼去 

2677
02:12:43,041 --> 02:12:46,791
注意我现在可以做什么 而不是说Get_Student 

2678
02:12:46,791 --> 02:12:51,625
Student.get 其他一切都可以保持不变 

2679
02:12:51,625 --> 02:12:55,416
我现在所做的就是把我所有的逻辑

2680
02:12:55,416 --> 02:12:58,541
来自Get_Student 它是这个自己的独立函数 

2681
02:12:58,541 --> 02:13:01,291
但显然与学生有名字上的联系 

2682
02:13:01,291 --> 02:13:05,458
我真的将相同的代码移到了内部

2683
02:13:05,458 --> 02:13:09,458
在名为Get的更简单的命名函数中 

2684
02:13:09,458 --> 02:13:11,541
但如果我愿意的话 我还是可以叫它Get_Student 

2685
02:13:11,541 --> 02:13:14,791
在学生班上称它为Get_Student似乎有些多余 

2686
02:13:14,791 --> 02:13:16,291
所以我在简化 

2687
02:13:16,291 --> 02:13:20,208
我有一个名为Get的方法 但我将其称为类方法

2688
02:13:20,208 --> 02:13:22,333
以避免鸡肉和鸡蛋的问题 

2689
02:13:22,333 --> 02:13:27,958
我希望能够在我的世界中没有学生对象的情况下调用GET

2690
02:13:27,958 --> 02:13:28,791
已经有了 

2691
02:13:28,791 --> 02:13:32,041
它的语法是@类方法 

2692
02:13:32,041 --> 02:13:35,333
约定是给该方法至少一个参数 

2693
02:13:35,333 --> 02:13:38,291
根据称为类的CLS的约定 它正在进行

2694
02:13:38,291 --> 02:13:40,125
作为对类本身的引用 

2695
02:13:40,125 --> 02:13:43,500
11号线和12号线和它们以前的样子是一样的 

2696
02:13:43,500 --> 02:13:46,666
和Get_Student--这里唯一的新语法是 

2697
02:13:46,666 --> 02:13:50,500
但这也是面向对象编程的特性之一 

2698
02:13:50,500 --> 02:13:57,791
现在 只需使用传入的CLS即可实例化学生对象 

2699
02:13:57,791 --> 02:14:00,583
从技术上讲 我可以利用学生 资本S 

2700
02:14:00,583 --> 02:14:03,333
但事实证明 我在做更传统的事情 因为

2701
02:14:03,333 --> 02:14:07,458
将通过更复杂的代码来解决和避免问题 

2702
02:14:07,458 --> 02:14:11,916
这一行 在第13行 只是表示创建当前类的对象 

2703
02:14:11,916 --> 02:14:12,708
那是什么班？

2704
02:14:12,708 --> 02:14:13,791
好吧 不管CLS是什么 

2705
02:14:13,791 --> 02:14:17,458
嗯 根据它的运作方式的定义 那将是学生 

2706
02:14:17,458 --> 02:14:22,250
我希望你像往常一样 用名字和房子来初始化它 

2707
02:14:22,250 --> 02:14:25,666
现在 向下滚动 我的代码是这样的 

2708
02:14:25,666 --> 02:14:27,875
这本书读起来很不错 

2709
02:14:27,875 --> 02:14:31,791
你可能得先尝一尝--我这句话听起来有点奇怪 

2710
02:14:31,791 --> 02:14:32,750
这本书读起来很不错 

2711
02:14:32,750 --> 02:14:36,125
但事实上 学生 GET只是告诉我发生了什么 

2712
02:14:36,125 --> 02:14:37,375
我要去找一个学生 

2713
02:14:37,375 --> 02:14:40,958
我不需要在文件中使用由我编写的名为Get_Student的单独函数

2714
02:14:40,958 --> 02:14:41,750
它本身 

2715
02:14:41,750 --> 02:14:44,875
Get功能内置于类中 

2716
02:14:44,875 --> 02:14:47,416
我所有与学生相关的代码现在都在一起了 

2717
02:14:47,416 --> 02:14:51,041
因此 让我转到我的终端窗口 运行Student.py的Python 回车 

2718
02:14:51,041 --> 02:14:52,083
让我们输入哈里 

2719
02:14:52,083 --> 02:14:53,416
让我们输入格兰芬多 

2720
02:14:53,416 --> 02:14:54,958
我们又回到了开始的地方 

2721
02:14:54,958 --> 02:15:00,541
但是 但是 但是所有与学生有关的东西 现在都在这个班级里 

2722
02:15:00,541 --> 02:15:04,500
文件中唯一的其他内容是main 这是一个有条件的内容

2723
02:15:04,500 --> 02:15:08,458
 我们经常使用它来避免在制作

2724
02:15:08,458 --> 02:15:10,833
模块或包或类似物 

2725
02:15:10,833 --> 02:15:13,541
所以 同样 一个问题的解决方案--

2726
02:15:13,541 --> 02:15:16,875
对于相对较小的程序来说 不是很大的一个 而是一个

2727
02:15:16,875 --> 02:15:19,041
你最终会在你的程序中遇到

2728
02:15:19,041 --> 02:15:24,083
变得越来越长 需要代表的实体越来越多 

2729
02:15:24,083 --> 02:15:29,000
现在关于类方法的使用的问题 

2730
02:15:29,000 --> 02:15:32,291
迈克尔：类必须在主函数之前定义吗 

2731
02:15:32,291 --> 02:15:34,458
就节目的顺序而言？

2732
02:15:34,458 --> 02:15:36,083
大卫·J·马兰：这是一个非常好的问题 

2733
02:15:36,083 --> 02:15:37,291
所以 如果有疑问 让我们试试这个 

2734
02:15:37,291 --> 02:15:38,666
所以让我们试着改变一下顺序 

2735
02:15:38,666 --> 02:15:41,208
让我们把主线移到顶端 这是我经常鼓励的 

2736
02:15:41,208 --> 02:15:44,208
因此 让我们继续 在全班之上 做这件事 

2737
02:15:44,208 --> 02:15:47,000
请注意 从技术上讲 第二行

2738
02:15:47,000 --> 02:15:51,458
提到了学生 直到第6行及以下才存在 

2739
02:15:51,458 --> 02:15:54,666
让我继续清除我的终端并运行Student.py的Python 

2740
02:15:54,666 --> 02:15:55,875
到现在为止还好 

2741
02:15:55,875 --> 02:15:58,750
哈利--格兰芬多 好的 

2742
02:15:58,750 --> 02:16:00,458
事实上 哈里来自格兰芬多 

2743
02:16:00,458 --> 02:16:03,541
原因 迈克尔 在这种情况下这无关紧要

2744
02:16:03,541 --> 02:16:06,791
是因为我们实际上直到最后才调用Main 

2745
02:16:06,791 --> 02:16:10,375
就像过去一样 这意味着Python有机会读取所有内容 

2746
02:16:10,375 --> 02:16:11,625
从上到下 从左到右 

2747
02:16:11,625 --> 02:16:13,083
所以一切都是存在的 

2748
02:16:13,083 --> 02:16:17,458
我想说的是 类通常在文件的顶部定义 

2749
02:16:17,458 --> 02:16:21,916
然而 移动类定义甚至可能更干净

2750
02:16:21,916 --> 02:16:25,083
到它自己的文件 然后将其导入 所以本质上

2751
02:16:25,083 --> 02:16:28,750
通过将代码放入您自己的模块或包来生成可重用的代码

2752
02:16:28,750 --> 02:16:31,083
因此 不仅是这个项目 还有许多其他项目

2753
02:16:31,083 --> 02:16:33,541
也可以使用学生的定义 

2754
02:16:33,541 --> 02:16:37,750
现在关于类、类方法或类似的其他问题 

2755
02:16:37,750 --> 02:16:44,833
听众：我想问 有没有办法宣布所有可能的--

2756
02:16:44,833 --> 02:16:47,583
类的所有可能属性？

2757
02:16:47,583 --> 02:16:51,000
因为它看起来太不一致了 

2758
02:16:51,000 --> 02:16:52,750
大卫·J·马兰：好吧 我要说的是

2759
02:16:52,750 --> 02:16:55,208
这就是Python对这些原则的处理方法 

2760
02:16:55,208 --> 02:16:57,791
不同的语言 如Java 只是采取了不同的方法

2761
02:16:57,791 --> 02:16:59,666
但都有非常相似的特征 

2762
02:16:59,666 --> 02:17:01,500
语法只是有变化的趋势 

2763
02:17:01,500 --> 02:17:05,208
这就是Python社区选择实现这一想法的方式 

2764
02:17:05,208 --> 02:17:08,750
归根结底 正确的心理模型是这些实例变量 

2765
02:17:08,750 --> 02:17:14,958
即时方法属于特定对象或对其进行操作--

2766
02:17:14,958 --> 02:17:17,750
一个特定的学生 一个特定的帽子 

2767
02:17:17,750 --> 02:17:22,500
类变量和类方法对整个类进行操作

2768
02:17:22,500 --> 02:17:26,125
本身或该类的所有对象 这些对象

2769
02:17:26,125 --> 02:17:30,000
我们还没有看到演示 但这是一个更高层次的概念 

2770
02:17:30,000 --> 02:17:32,583
所以事实证明 除了这些类方法之外 

2771
02:17:32,583 --> 02:17:35,625
它们与那些实例方法不同 公平地说 

2772
02:17:35,625 --> 02:17:39,375
没有自己的修饰符--默认情况下 它们只是实例方法 

2773
02:17:39,375 --> 02:17:42,458
在Python中的类中还可以使用其他类型的方法 

2774
02:17:42,458 --> 02:17:44,875
它们往往被称为静态方法 它们也是如此 

2775
02:17:44,875 --> 02:17:48,041
附带另一个称为@Static方法的装饰器 它

2776
02:17:48,041 --> 02:17:49,666
是一个我们不会掉下去的兔子洞 

2777
02:17:49,666 --> 02:17:52,125
但要意识到还有其他功能

2778
02:17:52,125 --> 02:17:54,750
您可以在面向对象编程中利用它 

2779
02:17:54,750 --> 02:17:59,041
但我们认为我们应该真正专注于一些最终的核心功能

2780
02:17:59,041 --> 02:18:02,166
这不仅在Python中可以看到 在其他语言中也是如此 

2781
02:18:02,166 --> 02:18:05,750
而且可能是面向对象编程最引人注目的特性之一

2782
02:18:05,750 --> 02:18:09,375
我们还没有明确使用--尽管事实证明我们已经看到

2783
02:18:09,375 --> 02:18:11,458
在过去的几周里--

2784
02:18:11,458 --> 02:18:13,625
就是这种继承的概念 

2785
02:18:13,625 --> 02:18:16,250
事实证明 通过面向对象编程 

2786
02:18:16,250 --> 02:18:19,666
实际上有一个机会来设计你的课程

2787
02:18:19,666 --> 02:18:25,125
在分层方式中 可以从一个类继承

2788
02:18:25,125 --> 02:18:30,833
或借用属性--即 来自另一个类的方法或变量

2789
02:18:30,833 --> 02:18:33,291
如果他们都有这些共同点的话 

2790
02:18:33,291 --> 02:18:35,083
那么 我在这里所说的是什么意思？

2791
02:18:35,083 --> 02:18:39,708
好吧 让我建议我们在这里的VS代码中实现

2792
02:18:39,708 --> 02:18:42,250
一个名为wizard.py的全新文件 

2793
02:18:42,250 --> 02:18:45,583
让我继续运行wizard.py的代码 

2794
02:18:45,583 --> 02:18:50,333
然后让我们像以前一样开始 定义一个名为Student的类 

2795
02:18:50,333 --> 02:18:54,416
让我们继续 首先定义下划线 init方法 

2796
02:18:54,416 --> 02:18:57,291
当然 在传统上 最低限度地要接受一个论点

2797
02:18:57,291 --> 02:18:58,000
叫赛尔夫 

2798
02:18:58,000 --> 02:19:01,375
在这种情况下 让我们也让它像以前一样接受一个名字和一个房子 

2799
02:19:01,375 --> 02:19:03,875
然后在这个初始化方法中 让我们继续

2800
02:19:03,875 --> 02:19:08,208
并分配实例变量--self.name=name 

2801
02:19:08,208 --> 02:19:11,208
和自己 房子=房子 

2802
02:19:11,208 --> 02:19:13,375
让我们假设有一些其他功能

2803
02:19:13,375 --> 02:19:15,083
在这节课上也是一样--点 点 点 

2804
02:19:15,083 --> 02:19:18,416
但现在让我们来实施教授的概念

2805
02:19:18,416 --> 02:19:20,208
在魔法界也是如此 

2806
02:19:20,208 --> 02:19:24,625
所以对于这节课 我们就叫它教授吧 

2807
02:19:24,625 --> 02:19:26,958
比如说 一位教授也要去

2808
02:19:26,958 --> 02:19:29,416
要有自己的初始化方法 

2809
02:19:29,416 --> 02:19:30,708
所以__init 

2810
02:19:30,708 --> 02:19:32,000
这需要自我--

2811
02:19:32,000 --> 02:19:33,791
总是作为第一个论点 

2812
02:19:33,791 --> 02:19:35,500
教授也有名字 

2813
02:19:35,500 --> 02:19:37,166
所以我们也会以第二名的成绩通过 

2814
02:19:37,166 --> 02:19:39,958
尽管有些教授是房子的头儿 

2815
02:19:39,958 --> 02:19:42,041
让我们假设一位教授确实被确认为

2816
02:19:42,041 --> 02:19:45,500
通过他们的名字和他们的学科领域--他们教的班级 

2817
02:19:45,500 --> 02:19:48,041
所以我们把这第三个论点称为主题 

2818
02:19:48,041 --> 02:19:51,791
现在 像以前一样 让我们继续将self.name=name 

2819
02:19:51,791 --> 02:19:56,083
让我们在这里指定self.Subject=SUBJECT 

2820
02:19:56,083 --> 02:19:59,541
和前面一样 让我们假设有一些更多的相关功能

2821
02:19:59,541 --> 02:20:01,083
教授们也是如此 

2822
02:20:01,083 --> 02:20:05,625
那么 在我对学生的定义中 你注意到了什么吗？

2823
02:20:05,625 --> 02:20:07,333
教授们呢？

2824
02:20:07,333 --> 02:20:11,750
通常 我们不太愿意在代码中考虑任何冗余 

2825
02:20:11,750 --> 02:20:16,041
在这里 我感觉我的初始化方法是为学生取了一个名字；

2826
02:20:16,041 --> 02:20:18,625
我的初始化方法也是取一个教授的名字；

2827
02:20:18,625 --> 02:20:22,458
我有这些相同的代码行 比如self.name=name 

2828
02:20:22,458 --> 02:20:25,208
如果我现在去补充说 这只会加剧

2829
02:20:25,208 --> 02:20:26,083
一些错误检查 

2830
02:20:26,083 --> 02:20:29,916
举个例子 如果不是名字 我们

2831
02:20:29,916 --> 02:20:32,083
应该养成养成养东西的习惯

2832
02:20:32,083 --> 02:20:36,208
比如说明性消息中的值错误 比如“缺少名称” 

2833
02:20:36,208 --> 02:20:37,166
你知道吗？

2834
02:20:37,166 --> 02:20:39,750
如果一位教授遗漏了他们的名字 我可能应该

2835
02:20:39,750 --> 02:20:41,291
把代码复制粘贴到这里 

2836
02:20:41,291 --> 02:20:43,666
这就是危险信号应该发出的地方 

2837
02:20:43,666 --> 02:20:45,916
因此 一旦您开始复制粘贴代码 

2838
02:20:45,916 --> 02:20:50,208
可能有一种更好的方法 这样我们可以只写一次代码 也许

2839
02:20:50,208 --> 02:20:51,500
以某种方式重复使用它 

2840
02:20:51,500 --> 02:20:54,916
在这里 面向对象编程也提供了一种解决方案 

2841
02:20:54,916 --> 02:20:58,041
事实证明 Python语言中的面向对象编程

2842
02:20:58,041 --> 02:21:03,458
还支持继承 从而可以定义多个类

2843
02:21:03,458 --> 02:21:05,125
以某种方式相互联系 

2844
02:21:05,125 --> 02:21:07,833
它们不需要以这种方式并行存在 

2845
02:21:07,833 --> 02:21:10,375
实际上 它们之间可能存在某种等级关系 

2846
02:21:10,375 --> 02:21:12,333
举个例子 在魔法世界里 我们

2847
02:21:12,333 --> 02:21:15,583
可以争辩说 学生和教授最终都是 

2848
02:21:15,583 --> 02:21:16,291
奇才队 

2849
02:21:16,291 --> 02:21:19,666
所以也许我们真正应该定义的是第三类 

2850
02:21:19,666 --> 02:21:21,958
例如 名为向导 它有任何

2851
02:21:21,958 --> 02:21:25,916
学生和教授的共同属性 

2852
02:21:25,916 --> 02:21:27,791
就目前而言 我们保持了相对简单的做法 

2853
02:21:27,791 --> 02:21:30,666
它们唯一的共同点就是名字和名字 

2854
02:21:30,666 --> 02:21:32,458
分别在学生和教授身上 

2855
02:21:32,458 --> 02:21:35,416
那么 为什么我们不先把这一点考虑到最低限度呢？

2856
02:21:35,416 --> 02:21:37,083
好了 让我继续讲下去 

2857
02:21:37,083 --> 02:21:39,708
为了让事情井然有序 在我的文件顶部 让我们

2858
02:21:39,708 --> 02:21:41,833
定义名为向导的第三个类 

2859
02:21:41,833 --> 02:21:45,208
并且向导将有其自己的初始化方法 

2860
02:21:45,208 --> 02:21:49,541
所以 一如既往地定义__init_(Self) 

2861
02:21:49,541 --> 02:21:52,333
而一个巫师 比方说 现在只会去

2862
02:21:52,333 --> 02:21:55,625
以这种方式使用它们的名称进行初始化 

2863
02:21:55,625 --> 02:21:58,791
现在 我将继续进行一些错误检查 

2864
02:21:58,791 --> 02:22:02,708
因此 如果不是这样 名称将在向导类中引发一个值错误 

2865
02:22:02,708 --> 02:22:06,041
否则 我们将继续做自己的名字等于名字 

2866
02:22:06,041 --> 02:22:09,666
还有 见鬼 点 也许还有其他一些功能 

2867
02:22:09,666 --> 02:22:13,041
但不是一个特定于教授的主题 而不是一个房子 

2868
02:22:13,041 --> 02:22:15,166
我声称这是专门针对学生的 

2869
02:22:15,166 --> 02:22:18,375
现在 我想我们可以开始移除

2870
02:22:18,375 --> 02:22:20,833
我们这里其他班级的一些裁员 

2871
02:22:20,833 --> 02:22:24,416
举个例子 跟学生打交道 我为什么不

2872
02:22:24,416 --> 02:22:28,750
继续删除此处的错误检查并删除此错误--

2873
02:22:28,750 --> 02:22:32,166
这个self.name=name的赋值 因为我已经

2874
02:22:32,166 --> 02:22:33,291
在向导中执行此操作 

2875
02:22:33,291 --> 02:22:35,958
同样 在这里 教授 为什么我不做同样的事情呢？

2876
02:22:35,958 --> 02:22:37,583
让我们去掉错误检查 

2877
02:22:37,583 --> 02:22:41,083
让我们去掉self.name=name 因为我已经在这样做了

2878
02:22:41,083 --> 02:22:43,041
巫师也在那里 

2879
02:22:43,041 --> 02:22:45,916
但现在 即使它们都在同一个文件里 

2880
02:22:45,916 --> 02:22:50,666
我没有告诉Python学生是巫师 教授是巫师 

2881
02:22:50,666 --> 02:22:53,000
所以我真的需要把这两者联系起来 

2882
02:22:53,000 --> 02:22:57,500
你可以规定继承的方式 一个类应该

2883
02:22:57,500 --> 02:23:00,041
从另一个类继承 或者相反 从一个类继承

2884
02:23:00,041 --> 02:23:03,541
应该是从另一个进化而来的--我们可以做到 

2885
02:23:03,541 --> 02:23:05,125
我可以说是同学 

2886
02:23:05,125 --> 02:23:08,416
但是在冒号之前 我可以在括号里说 

2887
02:23:08,416 --> 02:23:13,916
学生继承自向导 或者是向导的子类 相反 

2888
02:23:13,916 --> 02:23:16,666
是student类的超类 

2889
02:23:16,666 --> 02:23:19,583
这意味着 当我定义一个学生类时 

2890
02:23:19,583 --> 02:23:23,958
继续前进 并继承所有的特点 一个向导以及 

2891
02:23:23,958 --> 02:23:26,875
我也会为教授做同样的事

2892
02:23:26,875 --> 02:23:30,166
所以（巫师）在班级名称教授之后 

2893
02:23:30,166 --> 02:23:33,833
这将使我能够访问一些相同的功能 

2894
02:23:33,833 --> 02:23:37,458
但是因为我的学生班和教授班

2895
02:23:37,458 --> 02:23:39,416
仍然有相同的init方法 

2896
02:23:39,416 --> 02:23:41,291
是将要被调用的方法 

2897
02:23:41,291 --> 02:23:44,916
每当我用代码创造一个学生或者一个教授 

2898
02:23:44,916 --> 02:23:47,625
我需要明确地说我也

2899
02:23:47,625 --> 02:23:51,916
要使用Wizard类的init方法中的功能 

2900
02:23:51,916 --> 02:23:54,916
在Python中这样做的方法如下 

2901
02:23:54,916 --> 02:23:56,958
让我们来看看Student的init方法 

2902
02:23:56,958 --> 02:23:59,958
让我给super打个电话 没有参数 

2903
02:23:59,958 --> 02:24:03,333
是对该类的超类的引用 

2904
02:24:03,333 --> 02:24:05,916
如果这个类是Student 那么超类 

2905
02:24:05,916 --> 02:24:07,791
父类是Wizard 

2906
02:24:07,791 --> 02:24:13,875
所以super（）将具有访问超类的效果 

2907
02:24:13,875 --> 02:24:17,750
然后我将继续并显式调用它的init方法 

2908
02:24:17,750 --> 02:24:21,416
我将把它传递给向导的init方法

2909
02:24:21,416 --> 02:24:24,958
传递给学生的init方法的名称 

2910
02:24:24,958 --> 02:24:28,000
我将继续在Wizard中做同样的事情 

2911
02:24:28,000 --> 02:24:29,666
这是一行复制 粘贴 

2912
02:24:29,666 --> 02:24:32,375
但我觉得我在这里挺好的因为

2913
02:24:32,375 --> 02:24:34,291
允许我完成所有的名字分配

2914
02:24:34,291 --> 02:24:37,000
并改为在向导类中进行错误检查 

2915
02:24:37,000 --> 02:24:42,250
我想我们现在只要为两个学生调用Super.init就可以了

2916
02:24:42,250 --> 02:24:43,416
和教授一样 

2917
02:24:43,416 --> 02:24:47,208
现在 无可否认 这种语法确实存在--事实是

2918
02:24:47,208 --> 02:24:49,541
我们在圆括号和圆点中称其为Super.

2919
02:24:49,541 --> 02:24:52,458
并在init的左侧和右侧加下划线 

2920
02:24:52,458 --> 02:24:54,875
但这只是这两个想法的结合 

2921
02:24:54,875 --> 02:25:00,916
Super()是以编程方式访问当前类的父类的一种方式

2922
02:25:00,916 --> 02:25:05,291
类 或超类 当然 __init只是指 现在 

2923
02:25:05,291 --> 02:25:08,041
该类自己的初始化方法 

2924
02:25:08,041 --> 02:25:09,958
现在 根据点 点 点--所以可能有

2925
02:25:09,958 --> 02:25:11,500
在这些课程中有更多的内容 

2926
02:25:11,500 --> 02:25:15,208
但现在最好的是巫师作为一个班级

2927
02:25:15,208 --> 02:25:18,291
负责所有巫师名字的分配 

2928
02:25:18,291 --> 02:25:20,458
不管那个巫师是学生还是教授 

2929
02:25:20,458 --> 02:25:22,416
它甚至还进行了一些错误检查 以使

2930
02:25:22,416 --> 02:25:25,125
当然 这个名字确实是传进来的 

2931
02:25:25,125 --> 02:25:29,166
同时 学生继承了所有这些功能

2932
02:25:29,166 --> 02:25:32,333
并通过调用超类自己的init方法来使用它 

2933
02:25:32,333 --> 02:25:35,041
但它还额外征用了房子 这可能是

2934
02:25:35,041 --> 02:25:37,375
传递到学生构造函数中 

2935
02:25:37,375 --> 02:25:40,833
并将其赋给自己的实例变量--self.house 

2936
02:25:40,833 --> 02:25:44,458
同样 教授 或自我恢复的学科 

2937
02:25:44,458 --> 02:25:47,875
这个主题也被传递到了那个主题中 

2938
02:25:47,875 --> 02:25:49,916
现在 我们该如何使用这些类呢？

2939
02:25:49,916 --> 02:25:53,500
好的 我们将继续挥舞我们的手 在这里介绍一些细节 

2940
02:25:53,500 --> 02:25:56,750
但在此文件的底部 或导入此文件的任何其他文件中 

2941
02:25:56,750 --> 02:25:58,833
我现在可以像这样编写代码了 

2942
02:25:58,833 --> 02:26:01,208
我可以创建一个学生变量并将

2943
02:26:01,208 --> 02:26:03,458
它是学生构造函数调用的返回值 

2944
02:26:03,458 --> 02:26:07,625
也许那个学生叫哈里和那个学生的房子 

2945
02:26:07,625 --> 02:26:10,041
例如 可能是格兰芬多 

2946
02:26:10,041 --> 02:26:14,750
同时 我可能会做这样的事情 教授=这里的教授 

2947
02:26:14,750 --> 02:26:18,541
注意 小写的S在左边 大写的S在右边 

2948
02:26:18,541 --> 02:26:21,875
左边的教授也一样--右边是小写和大写

2949
02:26:21,875 --> 02:26:22,750
分别进行了分析 

2950
02:26:22,750 --> 02:26:25,625
教授 引用 引用 “西弗勒斯” 以及如何

2951
02:26:25,625 --> 02:26:30,500
关于黑魔法防御的话题会是他的主题吗？

2952
02:26:30,500 --> 02:26:32,791
同时 如果我们愿意 更笼统地说 

2953
02:26:32,791 --> 02:26:37,291
我只是个巫师 现在既不是学生也不是教授

2954
02:26:37,291 --> 02:26:39,375
积极授课 我们甚至可以这样做 

2955
02:26:39,375 --> 02:26:43,458
我们可以用右手边的大写W表示WANDIZE=WANDIZE

2956
02:26:43,458 --> 02:26:45,708
等号 因为它是班级的名字 

2957
02:26:45,708 --> 02:26:47,166
像阿不思这样的人--

2958
02:26:47,166 --> 02:26:49,958
只传了阿不思的名字--

2959
02:26:49,958 --> 02:26:55,708
不是房子 也不是主题 因为在这种情况下 他只被称为巫师 

2960
02:26:55,708 --> 02:26:58,750
同时 对于这些调用中的每一个 这行代码

2961
02:26:58,750 --> 02:27:01,833
这里将确保调用向导类的init方法 

2962
02:27:01,833 --> 02:27:05,583
这里的这行代码将确保学生的init方法

2963
02:27:05,583 --> 02:27:09,250
类 然后调用超类向导的init方法 

2964
02:27:09,250 --> 02:27:11,541
最后 在这最后一行代码中 

2965
02:27:11,541 --> 02:27:15,625
此语法是否能确保教授类的init方法

2966
02:27:15,625 --> 02:27:20,375
被调用 而后者又调用超类的init方法 

2967
02:27:20,375 --> 02:27:24,083
现在对继承这一概念有任何疑问 

2968
02:27:24,083 --> 02:27:29,125
哪一项是许多面向对象编程语言的关键特性？

2969
02:27:33,458 --> 02:27:36,708
迈克尔：就我目前所见 很多时候 都有很多筑巢的地方 

2970
02:27:36,708 --> 02:27:38,375
如果你做的是超级的 会涨一分吗？

2971
02:27:38,375 --> 02:27:44,375
是否存在这样的情况：它也嵌套在向导上方的另一个类中 

2972
02:27:44,375 --> 02:27:44,875
比方说？

2973
02:27:44,875 --> 02:27:46,500
大卫·J·马兰：这是一个非常好的问题 

2974
02:27:46,500 --> 02:27:48,375
如果你有一个超级班级--所以

2975
02:27:48,375 --> 02:27:52,833
您的层次结构甚至比这两个层次结构还要高

2976
02:27:52,833 --> 02:27:56,625
我们目前拥有的 绝对是 

2977
02:27:56,625 --> 02:27:59,250
继承的好处 顾名思义 是 

2978
02:27:59,250 --> 02:28:02,583
就像你作为一个人类可能继承了某些特征一样

2979
02:28:02,583 --> 02:28:06,000
从你的祖父和祖母或你的曾祖父

2980
02:28:06,000 --> 02:28:08,333
或曾祖母 其中一些财产

2981
02:28:08,333 --> 02:28:13,083
实际上也可以在代码的上下文中慢慢地传递给你 

2982
02:28:13,083 --> 02:28:17,291
所以当你从另一个阶级下来的时候

2983
02:28:17,291 --> 02:28:21,541
也就是说 当你子类化一个超类或一个超超类时 

2984
02:28:21,541 --> 02:28:23,958
你实际上继承了所有的功能 

2985
02:28:23,958 --> 02:28:26,625
不是从你上面一层而是从两三层

2986
02:28:26,625 --> 02:28:29,583
因此您确实也可以访问某些功能 

2987
02:28:29,583 --> 02:28:32,666
你甚至可以覆盖它 如果你想要其中的一些类

2988
02:28:32,666 --> 02:28:35,750
和其他人有一点点不同

2989
02:28:35,750 --> 02:28:38,125
关于继承的其他问题

2990
02:28:38,125 --> 02:28:39,875
观众：所以它和上一个类似 

2991
02:28:39,875 --> 02:28:43,125
但你能让两个父母处于同一水平吗

2992
02:28:43,125 --> 02:28:44,750
David J. Malan：一个非常好的问题 

2993
02:28:44,750 --> 02:28:49,875
因此 有一些方法可以实现多个父代的后代 

2994
02:28:49,875 --> 02:28:53,125
有不同的方法来做到这一点 不仅仅是在Python中 还有其他语言 

2995
02:28:53,125 --> 02:28:57,916
不过 我们在这里保持了简单 只使用一个继承路径 

2996
02:28:57,916 --> 02:28:58,666
问得好

2997
02:28:58,666 --> 02:29:01,291
再问一个关于继承的问题怎么样？

2998
02:29:01,291 --> 02:29:07,208
观众：我们可以在super中有多个参数 init？

2999
02:29:07,208 --> 02:29:11,000
大卫·J·马兰：是的 但在这种情况下 我只在第18行传递一个名字 

3000
02:29:11,000 --> 02:29:13,666
我只在第10行输入名字

3001
02:29:13,666 --> 02:29:14,166
为什么要这样？

3002
02:29:14,166 --> 02:29:18,208
因为 在第2行 当我为Wizard类定义init方法时 

3003
02:29:18,208 --> 02:29:20,375
我只希望有一个论点 

3004
02:29:20,375 --> 02:29:23,583
但我完全可以有其他的通用功能 

3005
02:29:23,583 --> 02:29:24,750
我可以加一个守护神 

3006
02:29:24,750 --> 02:29:27,125
如果学生和教授都有赞助人

3007
02:29:27,125 --> 02:29:30,958
可以从他们的魔杖中发出 我可以有两个论点 

3008
02:29:30,958 --> 02:29:33,708
我们一直在使用面向对象编程的这个特性

3009
02:29:33,708 --> 02:29:37,000
在很长一段时间内 以例外的形式 

3010
02:29:37,000 --> 02:29:40,625
实际上 如果你查看Python中异常的官方文档 

3011
02:29:40,625 --> 02:29:43,208
你会发现这甚至不是我们在课堂上看到的 

3012
02:29:43,208 --> 02:29:44,541
比如价值错误和其他 

3013
02:29:44,541 --> 02:29:48,666
还有很多其他的 但他们都是 他们自己 

3014
02:29:48,666 --> 02:29:50,125
等级制的

3015
02:29:50,125 --> 02:29:54,416
这只是内置到Python中的可用异常的一个子集 

3016
02:29:54,416 --> 02:29:58,125
实际上 作为程序员 您也可以创建自己的异常 

3017
02:29:58,125 --> 02:30:01,916
但正如这张图表所显示的那样 

3018
02:30:01,916 --> 02:30:06,125
我们到目前为止看到的所有例外情况实际上都是从

3019
02:30:06,125 --> 02:30:09,041
或者已经从超类继承 

3020
02:30:09,041 --> 02:30:10,833
因此 例如 在这个列表的底部

3021
02:30:10,833 --> 02:30:13,250
下面是ValueError 我们已经见过很多次了 

3022
02:30:13,250 --> 02:30:17,583
如果你沿着这张ASCII图表上的直线向上 

3023
02:30:17,583 --> 02:30:22,083
您将看到ValueError有一个父类、类或超类 称为异常 

3024
02:30:22,083 --> 02:30:25,958
同时 Except类有一个称为基异常的父类 

3025
02:30:25,958 --> 02:30:28,125
为什么Python的作者要这样做呢？

3026
02:30:28,125 --> 02:30:32,958
事实证明 无论是值错误还是键错误

3027
02:30:32,958 --> 02:30:35,416
或断言错误或任何数量的其他错误 

3028
02:30:35,416 --> 02:30:40,250
所有这些类型的错误都有很多共同的功能

3029
02:30:40,250 --> 02:30:42,458
你想要的--

3030
02:30:42,458 --> 02:30:44,958
您希望程序员能够使用的 

3031
02:30:44,958 --> 02:30:48,375
所以 事实证明 Python的作者们决定 你知道吗？

3032
02:30:48,375 --> 02:30:51,791
我们不要有十几个或更多不同的班级

3033
02:30:51,791 --> 02:30:55,166
只是都有复制、粘贴类似的功能 

3034
02:30:55,166 --> 02:30:57,250
让我们创建这个层次结构 这样 即使

3035
02:30:57,250 --> 02:31:00,875
尽管这份名单中垫底的例外情况非常准确 

3036
02:31:00,875 --> 02:31:02,291
他们至少继承了--

3037
02:31:02,291 --> 02:31:05,583
也就是说 借用上面一些非常常见的功能 

3038
02:31:05,583 --> 02:31:09,541
因此 当您在Python中使用Try和Accept关键字时 

3039
02:31:09,541 --> 02:31:13,291
一般来说 我们会尝试捕捉非常具体的例外情况 

3040
02:31:13,291 --> 02:31:14,291
比如ValueError 

3041
02:31:14,291 --> 02:31:17,458
但从技术上讲 你可以抓住孩子的父母 甚至

3042
02:31:17,458 --> 02:31:20,375
给定异常的祖父母异常 

3043
02:31:20,375 --> 02:31:23,500
尤其是当你不确定哪一个会被抚养长大的时候 

3044
02:31:23,500 --> 02:31:27,041
或者 更好的是 可能会有许多例外被提出 

3045
02:31:27,041 --> 02:31:28,958
但你想对他们一视同仁 

3046
02:31:28,958 --> 02:31:31,000
你不一定要列举它们

3047
02:31:31,000 --> 02:31:33,041
在括号中 用逗号隔开 

3048
02:31:33,041 --> 02:31:36,625
你想说你想处理某个超类的所有异常

3049
02:31:36,625 --> 02:31:38,416
以同样的方式 

3050
02:31:38,416 --> 02:31:40,833
所以这一直都是潜伏的 每当我们

3051
02:31:40,833 --> 02:31:45,166
看到或使用或捕获 或者现在 引发异常 并内置到Python中

3052
02:31:45,166 --> 02:31:46,041
就是这种等级制度 

3053
02:31:46,041 --> 02:31:47,916
如果你要发明自己的例外 

3054
02:31:47,916 --> 02:31:50,250
一般来说 你不会想从头开始 

3055
02:31:50,250 --> 02:31:54,041
你会想要从--也就是说 子类 

3056
02:31:54,041 --> 02:31:58,958
异常 并添加自己的扭曲 你自己的功能以及 

3057
02:31:58,958 --> 02:32:02,208
面向对象编程的最后一个特点

3058
02:32:02,208 --> 02:32:04,750
我们今天想和大家分享的

3059
02:32:04,750 --> 02:32:08,291
也许会让你大开眼界 看看你现在能做什么

3060
02:32:08,291 --> 02:32:10,208
你可以随意上课

3061
02:32:10,208 --> 02:32:12,791
这也是一个令人惊讶的特点 

3062
02:32:12,791 --> 02:32:15,458
你我已经习以为常了

3063
02:32:15,458 --> 02:32:18,250
这已经奏效了 但它的实施方式

3064
02:32:18,250 --> 02:32:20,208
你现在可以利用自己 

3065
02:32:20,208 --> 02:32:23,166
事实证明 Python和其他一些语言 

3066
02:32:23,166 --> 02:32:27,041
支持这种运算符重载的概念 

3067
02:32:27,041 --> 02:32:32,250
你可以使用非常常见的符号 比如加号、减号或其他类似的语法 

3068
02:32:32,250 --> 02:32:37,416
在键盘上 你可以实现你自己的解释 

3069
02:32:37,416 --> 02:32:40,791
加不等于加 

3070
02:32:40,791 --> 02:32:43,291
减不一定等于减 

3071
02:32:43,291 --> 02:32:45,708
事实上 你和我已经看到了另一个背景

3072
02:32:45,708 --> 02:32:48,541
其中加号代表别的意思 

3073
02:32:48,541 --> 02:32:52,750
在Python中 加号本身并不总是意味着加法 

3074
02:32:52,750 --> 02:32:56,458
Python还用plus做什么？

3075
02:32:56,458 --> 02:32:57,458
观众：串联？

3076
02:32:57,458 --> 02:32:58,875
DAVID J. MALAN：用于连接 

3077
02:32:58,875 --> 02:33:02,875
对于连接两个字符串 对于添加到列表中 您也可以使用加号 

3078
02:33:02,875 --> 02:33:07,666
有趣的是 Python的作者们实际上已经重载了So plus

3079
02:33:07,666 --> 02:33:08,541
为我们

3080
02:33:08,541 --> 02:33:12,000
所以我们可以用和加法一样的方法来使用这个符号

3081
02:33:12,000 --> 02:33:15,250
但使用不同的数据类型来解决略有不同的问题 

3082
02:33:15,250 --> 02:33:18,250
我建议我们回到VS Code

3083
02:33:18,250 --> 02:33:22,250
让我继续创建一个新的最终文件 名为vault.py 

3084
02:33:22,250 --> 02:33:24,000
所以代码是vault.py 

3085
02:33:24,000 --> 02:33:27,416
让我提议我们实施一个金库的想法

3086
02:33:27,416 --> 02:33:30,541
在古灵阁 保持主题 其中有

3087
02:33:30,541 --> 02:33:32,291
哈利·波特世界里的银行

3088
02:33:32,291 --> 02:33:35,083
在这家银行里 家庭和个人

3089
02:33:35,083 --> 02:33:38,958
在魔法世界里有各种各样的钱

3090
02:33:38,958 --> 02:33:41,583
在哈利·波特的世界里 

3091
02:33:41,583 --> 02:33:44,791
是被称为加隆、镰刀和克努特的硬币

3092
02:33:44,791 --> 02:33:47,083
这些是按价值递减的顺序排列的 

3093
02:33:47,083 --> 02:33:49,750
在金库里可能有一大堆硬币

3094
02:33:49,750 --> 02:33:53,000
金 银 铜 基本上 每一个在这些面额 

3095
02:33:53,000 --> 02:33:53,833
藏起来了

3096
02:33:53,833 --> 02:33:58,083
那么首先 我该如何实现保险库的概念呢

3097
02:33:58,083 --> 02:34:02,375
这样我就可以储存 比如 哈利波特 

3098
02:34:02,375 --> 02:34:05,916
是在他家的金库里 还是罗恩·韦斯莱的金库里

3099
02:34:05,916 --> 02:34:08,291
好吧 让我继续 vault.py 首先

3100
02:34:08,291 --> 02:34:12,291
创建一个名为Vault的类 基本上表示银行金库 

3101
02:34:12,291 --> 02:34:15,000
完美 另一个真实的世界 或者幻想的世界 

3102
02:34:15,000 --> 02:34:17,500
我想用代码表示的实体 

3103
02:34:17,500 --> 02:34:19,958
我可以用一个元组或者一个列表或者一个字典 

3104
02:34:19,958 --> 02:34:23,083
但是 我还是要用类来获得更多的功能 

3105
02:34:23,083 --> 02:34:26,125
and we'll我们会see one final最后flourish繁荣with operators运营商.

3106
02:34:26,125 --> 02:34:28,875
在跳马课里 我们来做这个 

3107
02:34:28,875 --> 02:34:32,625
让我定义我的init方法 使用它的第一个参数self 

3108
02:34:32,625 --> 02:34:35,625
让我来定义三个论点 

3109
02:34:35,625 --> 02:34:38,541
当你创建一个保险库时 在我的代码中 

3110
02:34:38,541 --> 02:34:41,750
我希望能用一些加隆来初始化它 一些数字

3111
02:34:41,750 --> 02:34:43,375
镰刀和坚果

3112
02:34:43,375 --> 02:34:46,791
我希望用户 程序员 能够传入一个或多个

3113
02:34:46,791 --> 02:34:47,833
这些价值观的理想 

3114
02:34:47,833 --> 02:34:50,083
但它们可以是可选的 所以我给它们默认值 

3115
02:34:50,083 --> 02:34:53,000
让我们定义一个名为galleons的参数 

3116
02:34:53,000 --> 02:34:57,041
其缺省值为0；镰刀 其缺省值也为0；

3117
02:34:57,041 --> 02:35:00,083
和knts 其缺省值也将为0 

3118
02:35:00,083 --> 02:35:04,541
因此程序员可以传入一个或两个或三个 甚至一个也不传入 

3119
02:35:04,541 --> 02:35:07,125
而且它们都会有一些隐含的违约 

3120
02:35:07,125 --> 02:35:10,500
我要如何记住那些传入的值呢？

3121
02:35:10,500 --> 02:35:11,541
好吧 那就让我来吧 

3122
02:35:11,541 --> 02:35:14,583
大帆船=帆船 

3123
02:35:14,583 --> 02:35:17,416
和自我 镰刀=镰刀 

3124
02:35:17,416 --> 02:35:20,708
和self.knerts=knits 

3125
02:35:20,708 --> 02:35:24,541
因此 我可以添加一些错误检查 特别是如果您不通过的话 

3126
02:35:24,541 --> 02:35:27,708
我可以将这些转换为属性 以进行更多的验证 

3127
02:35:27,708 --> 02:35:30,791
但让我们保持简单 一如既往地只关注新想法 

3128
02:35:30,791 --> 02:35:33,291
所以我只会相信这些值是传入的 

3129
02:35:33,291 --> 02:35:36,708
我会立即把它们赋给这些实例变量 

3130
02:35:36,708 --> 02:35:38,416
现在 我想要做什么？

3131
02:35:38,416 --> 02:35:41,208
好吧 让我们想出一种打印输出的方法

3132
02:35:41,208 --> 02:35:44,000
最终 某人的金库里有什么 

3133
02:35:44,000 --> 02:35:45,291
但首先让我们这样做 

3134
02:35:45,291 --> 02:35:50,083
让我们通过分配创建一个新的保险库 从而为波特一家创建一个保险库 

3135
02:35:50,083 --> 02:35:55,125
假设陶工有100只大帆船 50把镰刀和24克朗 

3136
02:35:55,125 --> 02:35:58,541
它就在那个保险库里 让我们打印出来 比方说 波特 

3137
02:35:58,541 --> 02:36:00,916
好的 让我们运行这段代码 看看它现在是如何工作的 

3138
02:36:00,916 --> 02:36:05,083
让我继续运行Vault.py的Python.Enter 

3139
02:36:05,083 --> 02:36:06,083
看起来很管用 

3140
02:36:06,083 --> 02:36:08,041
没有语法错误或其他任何错误 

3141
02:36:08,041 --> 02:36:10,791
但这并不是很有启发性 

3142
02:36:10,791 --> 02:36:15,291
回想我们以前做过的事情 我该如何解决这个问题呢？

3143
02:36:15,291 --> 02:36:17,958
观众：您必须使用__str 

3144
02:36:17,958 --> 02:36:18,958
大卫·J·马兰：没错 

3145
02:36:18,958 --> 02:36:22,291
我需要使用类附带的一种特殊方法

3146
02:36:22,291 --> 02:36:26,625
并自己定义我希望将保险库打印为字符串的方式 

3147
02:36:26,625 --> 02:36:27,916
因此 让我继续下去 这样做 

3148
02:36:27,916 --> 02:36:32,541
让我定义将self作为其唯一参数的str方法 

3149
02:36:32,541 --> 02:36:34,500
让我们只返回一个非常简单的字符串

3150
02:36:34,500 --> 02:36:36,833
这正好揭示了保险库里有什么 

3151
02:36:36,833 --> 02:36:39,958
所以我将返回一个格式化的f字符串 

3152
02:36:39,958 --> 02:36:44,166
里面是帆船 然后是帆船这个词 

3153
02:36:44,166 --> 02:36:45,875
所以我知道那些是什么了 

3154
02:36:45,875 --> 02:36:49,458
然后让我们自己做 镰刀 让我们输出单词 镰刀 

3155
02:36:49,458 --> 02:36:53,083
最后 让我们输出self.knuts 然后在这里输出knuts 

3156
02:36:53,083 --> 02:36:58,041
所以我知道 在这根绳子上 每一枚硬币有多少

3157
02:36:58,041 --> 02:37:01,666
我在这个特殊家庭的金库里 好的 让我继续

3158
02:37:01,666 --> 02:37:06,166
并运行Vault.py的Python 除了str方法外 不更改其他任何内容 

3159
02:37:06,166 --> 02:37:11,625
现在 我们确实看到哈利有100艘大帆船 50把镰刀和25枚坚果 

3160
02:37:11,625 --> 02:37:13,541
好吧 好吧 我们再做一件事 

3161
02:37:13,541 --> 02:37:16,875
下面 让我们继续定义一个Weasley变量 

3162
02:37:16,875 --> 02:37:20,583
罗恩的金库里似乎从来没有哈利那么多钱 

3163
02:37:20,583 --> 02:37:24,541
因此 假设韦斯莱跳马将有25、50和100个 

3164
02:37:24,541 --> 02:37:27,041
所以我就把这些面额的顺序颠倒一下 

3165
02:37:27,041 --> 02:37:29,541
而不是哈利的100 50 25 

3166
02:37:29,541 --> 02:37:33,125
现在让我继续把韦斯莱印成这样 

3167
02:37:33,125 --> 02:37:37,291
让我们继续清除我的终端窗口 运行Vault.py的Python 

3168
02:37:37,291 --> 02:37:40,541
这次 字符串方法将被调用两次 一次

3169
02:37:40,541 --> 02:37:42,416
这些保险库对象中的每一个 

3170
02:37:42,416 --> 02:37:44,666
我们会看到 确实 哈利的第一个

3171
02:37:44,666 --> 02:37:48,125
分别得到了100 50和25 而罗恩只有25 50 

3172
02:37:48,125 --> 02:37:50,583
和100 

3173
02:37:50,583 --> 02:37:52,458
但现在让我们做一些有趣的事情 

3174
02:37:52,458 --> 02:37:56,333
假设您想要合并两个存储库的内容 

3175
02:37:56,333 --> 02:37:58,875
不管是哈里和罗恩还是其他两个人 

3176
02:37:58,875 --> 02:38:02,083
您将如何在代码中进行这项工作？

3177
02:38:02,083 --> 02:38:06,000
如果我想为某人组合保险库 我可以这么做 

3178
02:38:06,000 --> 02:38:08,333
嗯 我可以做同样的大帆船--

3179
02:38:08,333 --> 02:38:13,958
让我们来做陶器 大帆船+小帆船 

3180
02:38:13,958 --> 02:38:16,250
这给了我一个名为Galleons的变量 它具有

3181
02:38:16,250 --> 02:38:19,041
哈利和罗恩的大帆船的总和 

3182
02:38:19,041 --> 02:38:25,333
接下来让我们做镰刀=陶器 镰刀+韦斯莱镰刀 

3183
02:38:25,333 --> 02:38:31,916
最后 让我们来做knts=potter.knts+weasley.kutts 

3184
02:38:31,916 --> 02:38:32,958
我有三个变量 

3185
02:38:32,958 --> 02:38:34,666
我现在能用这些值做什么呢？

3186
02:38:34,666 --> 02:38:37,833
那我们就建第三个新金库总数将

3187
02:38:37,833 --> 02:38:41,416
这个变量的名字等于一个新的保险库 大写V 注意 

3188
02:38:41,416 --> 02:38:43,916
现在 让我们传入这三个新变量--

3189
02:38:43,916 --> 02:38:47,000
大帆船 镰刀 和坚果

3190
02:38:47,000 --> 02:38:49,625
就这样 让我们打印出整个保险库 

3191
02:38:49,625 --> 02:38:52,750
所以我们现在应该看到三个拱顶--一个是哈利的 一个是罗恩的 

3192
02:38:52,750 --> 02:38:55,208
以及两者的结合 

3193
02:38:55,208 --> 02:38:58,875
让我继续搜索vault.py的Python 然后我们就得到了它 

3194
02:38:58,875 --> 02:39:04,875
100 50 25和25 50和100 现在通过加法合并 

3195
02:39:04,875 --> 02:39:08,250
是125 100 125

3196
02:39:08,250 --> 02:39:10,541
所以很简单 使用几周前的技术

3197
02:39:10,541 --> 02:39:14,541
之前 我们只是声明了一些新的变量并做了一些加法 

3198
02:39:14,541 --> 02:39:18,208
但如果我能做这样的事不是很酷吗？

3199
02:39:18,208 --> 02:39:20,541
如果我能以某种方式 

3200
02:39:20,541 --> 02:39:24,541
而不是手动创建我自己的保险库 在这里做所有这些烦人的数学运算--

3201
02:39:24,541 --> 02:39:30,541
如果我能做波特和韦斯莱 摆脱这里所有的逻辑呢？

3202
02:39:30,541 --> 02:39:34,750
如果我让操作员超载不是很好吗

3203
02:39:34,750 --> 02:39:37,666
我们知道加号 就像str一样 

3204
02:39:37,666 --> 02:39:42,041
就像list一样--允许我把两个保险库加在一起

3205
02:39:42,041 --> 02:39:43,875
在左边和右边 

3206
02:39:43,875 --> 02:39:48,250
在Python中 通过运算符重载 

3207
02:39:48,250 --> 02:39:50,250
有一种方法可以做到这一点 

3208
02:39:50,250 --> 02:39:52,708
如果你查阅文档 

3209
02:39:52,708 --> 02:39:56,750
这个方法和其他许多随类而来的特殊方法 

3210
02:39:56,750 --> 02:39:59,916
第三个是这个

3211
02:39:59,916 --> 02:40:03,291
__add__.

3212
02:40:03,291 --> 02:40:05,458
你会发现它被描述得很一般

3213
02:40:05,458 --> 02:40:09,333
适用于任何对象 无论是Vault还是String

3214
02:40:09,333 --> 02:40:10,791
或者是一份名单或者别的什么

3215
02:40:10,791 --> 02:40:13,458
按照惯例 第一个参数是self 

3216
02:40:13,458 --> 02:40:17,083
然后它会用到另一个参数 按照惯例 叫做other 

3217
02:40:17,083 --> 02:40:20,083
self实际上指的是

3218
02:40:20,083 --> 02:40:22,250
对象位于加号的左侧 

3219
02:40:22,250 --> 02:40:24,166
另一个是指

3220
02:40:24,166 --> 02:40:26,291
在加号的右边

3221
02:40:26,291 --> 02:40:30,333
从而给了我们一种用代码描述操作数的方法

3222
02:40:30,333 --> 02:40:35,416
操作数在运算符的左边 操作数在运算符的右边 加上 介于两者之间 

3223
02:40:35,416 --> 02:40:37,958
也就是说 如果我回到VS Code 

3224
02:40:37,958 --> 02:40:42,083
我想做的是为这个项目提供支持 

3225
02:40:42,083 --> 02:40:45,041
好吧 让我试试 暂时不写其他代码--

3226
02:40:45,041 --> 02:40:47,541
vault.py的Python 输入--

3227
02:40:47,541 --> 02:40:53,541
TypeError：+：'Vault'和'vault'不支持的操作数类型 '

3228
02:40:53,541 --> 02:40:56,750
也就是说 Python此时不知道

3229
02:40:56,750 --> 02:40:59,083
就是把两个拱顶加在一起 

3230
02:40:59,083 --> 02:41:00,500
你和我可能有一种直觉 

3231
02:41:00,500 --> 02:41:03,958
可能想把加隆镰刀和坚果结合起来

3232
02:41:03,958 --> 02:41:04,791
分别

3233
02:41:04,791 --> 02:41:05,958
Python不知道这一点 

3234
02:41:05,958 --> 02:41:08,291
它只知道你有一个名为Vault的新类 

3235
02:41:08,291 --> 02:41:10,250
让我们来教Python如何做到这一点 

3236
02:41:10,250 --> 02:41:12,166
我来清空终端窗口 

3237
02:41:12,166 --> 02:41:15,208
让我回到这个类本身 在那里 目前 

3238
02:41:15,208 --> 02:41:18,250
我只有两个特殊的方法-- init和str 

3239
02:41:18,250 --> 02:41:20,458
但让我们加上第三个 

3240
02:41:20,458 --> 02:41:26,625
让我在这里进入类并定义__add__ 然后指定它的第一个

3241
02:41:26,625 --> 02:41:30,791
参数作为self 然后为这个特定的

3242
02:41:30,791 --> 02:41:32,583
方法调用 按照约定 其他 

3243
02:41:32,583 --> 02:41:34,833
现在 像往常一样 我可以给这些参数取任何名字

3244
02:41:34,833 --> 02:41:37,000
我也想 但我还是按惯例来吧 

3245
02:41:37,000 --> 02:41:39,041
现在 在这个方法中 我是不是

3246
02:41:39,041 --> 02:41:42,375
把两个保险库里的东西加在一起

3247
02:41:42,375 --> 02:41:43,333
哪两个金库？

3248
02:41:43,333 --> 02:41:46,291
好吧 如果我们向下滚动到我们手头的目标 当然 

3249
02:41:46,291 --> 02:41:48,583
就是加上这个保险库和另一个保险库 波特

3250
02:41:48,583 --> 02:41:50,208
还有韦斯莱

3251
02:41:50,208 --> 02:41:53,958
在Python中 当你重载一个运算符 

3252
02:41:53,958 --> 02:41:56,291
另外 自动发生的事情 

3253
02:41:56,291 --> 02:42:01,666
一旦Python看到这个 它会调用__add__方法 

3254
02:42:01,666 --> 02:42:04,041
它会传递到论证中 

3255
02:42:04,041 --> 02:42:07,333
不管左边的操作数是什么--在这个例子中是potter--

3256
02:42:07,333 --> 02:42:10,666
以及右边的操作数--这里是韦斯莱 

3257
02:42:10,666 --> 02:42:15,500
而这些价值将分别作为自我和他人传递进来 

3258
02:42:15,500 --> 02:42:18,375
这意味着我们可以在这里访问他们的内容

3259
02:42:18,375 --> 02:42:20,458
在我们的Add实现中 如下所示 

3260
02:42:20,458 --> 02:42:24,125
让我们继续定义一个名为Galleon的局部变量 并将

3261
02:42:24,125 --> 02:42:27,500
例如 等于自身大帆船的和--

3262
02:42:27,500 --> 02:42:30,125
不管本案中波特的保险库里有什么 

3263
02:42:30,125 --> 02:42:33,041
再加上本案中韦斯利金库里的任何东西

3264
02:42:33,041 --> 02:42:35,000
会是另一艘大帆船 

3265
02:42:35,000 --> 02:42:36,708
让我对镰刀做同样的事情 

3266
02:42:36,708 --> 02:42:40,125
自我 镰刀+其他 镰刀 

3267
02:42:40,125 --> 02:42:41,958
最后 让我为克努茨做这件事 

3268
02:42:41,958 --> 02:42:45,791
所以自己人+其他人 

3269
02:42:45,791 --> 02:42:47,625
但归根结底 我需要

3270
02:42:47,625 --> 02:42:51,500
返回一个全新的更大的保险库 其中包含所有这些内容

3271
02:42:51,500 --> 02:42:52,250
在一起 

3272
02:42:52,250 --> 02:42:56,791
如果我们最终想要将更大的保险库赋给一个像Total这样的变量

3273
02:42:56,791 --> 02:43:01,083
在这里 在左边 我们最好从这个Add方法返回一个值 

3274
02:43:01,083 --> 02:43:04,791
所以我要继续前进 给自己一个全新的跳马 就像回到

3275
02:43:04,791 --> 02:43:08,916
Capital Vault 当然 它将调用我的存储库函数

3276
02:43:08,916 --> 02:43:11,750
我现在可以传递其中一些初始化参数 

3277
02:43:11,750 --> 02:43:13,625
那么 有多少大帆船、镰刀和坚果

3278
02:43:13,625 --> 02:43:15,541
我想让这个全新的保险库容纳？

3279
02:43:15,541 --> 02:43:19,666
我希望它能装这么多大帆船这么多把镰刀 

3280
02:43:19,666 --> 02:43:21,291
还有这么多坚果 

3281
02:43:21,291 --> 02:43:23,708
所以最终 我们在这个实现中所做的

3282
02:43:23,708 --> 02:43:27,791
加法是把那些大帆船、镰刀和坚果加在一起 通过

3283
02:43:27,791 --> 02:43:30,958
这样我们就能得到一个全新的更大的保险库 

3284
02:43:30,958 --> 02:43:33,833
并将其全部归还 

3285
02:43:33,833 --> 02:43:36,041
所以现在我定义了这个新的特殊方法

3286
02:43:36,041 --> 02:43:42,250
名为Add的应用程序现在应该只对两个保险库执行plus操作 

3287
02:43:42,250 --> 02:43:42,833
让我们看看 

3288
02:43:42,833 --> 02:43:46,750
让我运行到我的终端窗口 即Vault.py的Python 然后按Enter键 

3289
02:43:46,750 --> 02:43:51,958
好了 现在我们实现了一个重载运算符 

3290
02:43:51,958 --> 02:43:54,166
去做你我作为人类所希望的事情

3291
02:43:54,166 --> 02:43:56,458
将两个存储库添加到一起时会出现这种情况 

3292
02:43:56,458 --> 02:43:58,916
但我现在已经更具体地编写了代码

3293
02:43:58,916 --> 02:44:04,500
教Python把两个保险库加在一起的具体含义 

3294
02:44:04,500 --> 02:44:06,708
它的代码非常相似 

3295
02:44:06,708 --> 02:44:09,541
Python在后台对两个字符串做这样的操作 

3296
02:44:09,541 --> 02:44:13,875
将它们连接在一起 将两个列表连接成一个新的列表 

3297
02:44:13,875 --> 02:44:16,875
还有很多其他的课程

3298
02:44:16,875 --> 02:44:22,166
关于运算符重载或者这个例子还有什么问题吗？

3299
02:44:22,166 --> 02:44:23,875
观众：你会如何创作

3300
02:44:23,875 --> 02:44:31,833
为两个单独的班级添加学生和Vault的功能？

3301
02:44:31,833 --> 02:44:33,250
有可能吗？

3302
02:44:33,250 --> 02:44:35,125
大卫·J·马兰：让我看看这里发生了什么 

3303
02:44:35,125 --> 02:44:36,041
我也不知道 

3304
02:44:36,041 --> 02:44:36,875
开始吧

3305
02:44:36,875 --> 02:44:38,541
让我们创建一个str 看看会发生什么 

3306
02:44:38,541 --> 02:44:40,875
如果我加上波特再加一个

3307
02:44:40,875 --> 02:44:41,500
String对象 

3308
02:44:41,500 --> 02:44:42,666
是啊 所以它会工作 

3309
02:44:42,666 --> 02:44:44,708
我只是在想办法 埃里克 

3310
02:44:44,708 --> 02:44:47,000
所以说清楚 我只是

3311
02:44:47,000 --> 02:44:48,958
把韦斯莱改成了str 只是想看看

3312
02:44:48,958 --> 02:44:54,166
当我加上一个拱顶和一个str的时候 理论上是可行的 

3313
02:44:54,166 --> 02:44:54,791
为什么要这样？

3314
02:44:54,791 --> 02:45:01,541
因为只要左边的值类型实现了add方法 

3315
02:45:01,541 --> 02:45:04,291
其他可以是任何你想要的类型 

3316
02:45:04,291 --> 02:45:06,583
你只需要决定并编码它是什么

3317
02:45:06,583 --> 02:45:09,625
从概念上讲 这意味着增加一个保险库和一个字符串 

3318
02:45:09,625 --> 02:45:13,458
在这种情况下 可能没有任何意义 但这是可能的 

3319
02:45:13,458 --> 02:45:15,208
它将是左边的操作数 

3320
02:45:15,208 --> 02:45:16,250
我在推断 

3321
02:45:16,250 --> 02:45:17,958
我刚才不知道答案 

3322
02:45:17,958 --> 02:45:22,916
我这样推断是因为我得到的是第11行的属性错误

3323
02:45:22,916 --> 02:45:27,125
因为巨蟒不喜欢这样其他的 大帆船没有工作 

3324
02:45:27,125 --> 02:45:29,666
但我可以想办法解决

3325
02:45:29,666 --> 02:45:30,791
问得好

3326
02:45:30,791 --> 02:45:32,291
我自己都不知道 

3327
02:45:32,291 --> 02:45:35,916
关于运算符重载的其他问题？

3328
02:45:35,916 --> 02:45:38,291
问：你能在Python中定义新的操作符吗？

3329
02:45:38,291 --> 02:45:39,666
大卫·J·马兰：我不这么认为 

3330
02:45:39,666 --> 02:45:44,583
有一个很长但很精确的操作符列表可以重载 

3331
02:45:44,583 --> 02:45:48,500
我不相信你可以任意分配字符

3332
02:45:48,500 --> 02:45:50,541
Python中的操作符

3333
02:45:50,541 --> 02:45:52,458
让我在聊天中听从卡特的意见--

3334
02:45:52,458 --> 02:45:55,166
好的 我看到我的两个同事在说 不 不可能 

3335
02:45:55,166 --> 02:45:57,166
因此 我将按照我的第一直觉 不 

3336
02:45:57,166 --> 02:45:58,583
不然的话 那就太酷了 

3337
02:45:58,583 --> 02:46:00,875
你可以让表情符号做任何你想做的事情 

3338
02:46:00,875 --> 02:46:04,000
最后一个关于操作符重载的问题如何？

3339
02:46:04,000 --> 02:46:08,416
观众：这是你唯一能做的手术吗？

3340
02:46:08,416 --> 02:46:10,041
你也能做减法吗？

3341
02:46:10,041 --> 02:46:11,041
大卫·J·马兰：你可以的 

3342
02:46:11,041 --> 02:46:13,583
你可以做这么多别人让我做的事 

3343
02:46:13,583 --> 02:46:16,583
如果 卡特 你不介意在这里调出这个网址--

3344
02:46:16,583 --> 02:46:19,750
所以这里的链接--特殊方法名称和今天的幻灯片 

3345
02:46:19,750 --> 02:46:23,208
您将看到可以重载的所有操作符的长长列表 

3346
02:46:23,208 --> 02:46:26,583
你可以做小于、等于、加等于、减等于 

3347
02:46:26,583 --> 02:46:29,291
你看到我在屏幕上输入的几乎所有符号

3348
02:46:29,291 --> 02:46:33,166
可以在类的上下文中重载 

3349
02:46:33,166 --> 02:46:35,541
所以 即使今天 我们完全专注于

3350
02:46:35,541 --> 02:46:38,625
在面向对象编程方面 这是我们一直在使用的一种技术 

3351
02:46:38,625 --> 02:46:41,791
真的 从上课的第一周开始 因为那些INT 

3352
02:46:41,791 --> 02:46:45,291
那些STR 那些花车 那些列表 那些词典 

3353
02:46:45,291 --> 02:46:49,083
而在这段时间里 引擎盖下已经有了更多的东西--课程

3354
02:46:49,083 --> 02:46:50,125
以及它的宗旨 

3355
02:46:50,125 --> 02:46:52,041
但你现在 作为一名程序员 有能力

3356
02:46:52,041 --> 02:46:55,583
要使用自己的实例或类变量创建自己的类 

3357
02:46:55,583 --> 02:46:58,875
使用您自己的实例或类方法 使用您自己的属性 

3358
02:46:58,875 --> 02:47:01,958
甚至可以使用您自己为操作员定制的行为 

3359
02:47:01,958 --> 02:47:04,625
所以最终 你完全可以继续

3360
02:47:04,625 --> 02:47:09,291
使用这些简单的元组或列表或那些词典或其他结构

3361
02:47:09,291 --> 02:47:09,791
也是 

3362
02:47:09,791 --> 02:47:13,416
但面向对象编程 以及随之而来的类和现在的这些对象

3363
02:47:13,416 --> 02:47:15,208
只是您工具包中的另一个工具 

3364
02:47:15,208 --> 02:47:18,041
大胆地说 随着您的代码变得更加复杂

3365
02:47:18,041 --> 02:47:20,041
你的问题变得更大 你会发现

3366
02:47:20,041 --> 02:47:23,708
能够对这些现实世界甚至幻想世界的实体进行建模

3367
02:47:23,708 --> 02:47:26,458
使用类以及相关数据和功能

3368
02:47:26,458 --> 02:47:30,583
最终将允许您定义不仅正确而且永远正确的代码

3369
02:47:30,583 --> 02:47:32,833
也是精心设计的 

3370
02:47:32,833 --> 02:47:35,541
这是CS50 

