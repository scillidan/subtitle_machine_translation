
1
00:00:00,000 --> 00:00:03,458
[古典音乐]
[CLASSICAL MUSIC]

2
00:00:23,875 --> 00:00:26,583
大卫·J·马兰：好的 这是CS50的S介绍
DAVID J. MALAN: All right, this is CS50's Introduction

3
00:00:26,583 --> 00:00:27,916
到使用Python语言编程 
to Programming with Python.

4
00:00:27,916 --> 00:00:31,541
我的名字是David Malan 这是我们的面向对象编程周 
My name is David Malan, and this is our week on object-oriented programming,

5
00:00:31,541 --> 00:00:32,791
或者OOP 
or OOP.

6
00:00:32,791 --> 00:00:34,750
事实证明 在编程的世界里 
It turns out that, in the world of programming,

7
00:00:34,750 --> 00:00:37,583
编程语言有不同的范例 
there's different paradigms of programming languages.

8
00:00:37,583 --> 00:00:40,208
有不同的方法来解决代码问题 
There's different ways of solving problems with code,

9
00:00:40,208 --> 00:00:42,000
一开始很难看到这一点
and it's a little hard to see this at first

10
00:00:42,000 --> 00:00:43,916
如果你只学过一门语言 
if you've only learned one language.

11
00:00:43,916 --> 00:00:47,416
但随着时间的推移 如果你学习了除Python之外的其他语言 
But over time, if and when you learn other languages besides Python,

12
00:00:47,416 --> 00:00:50,083
您将开始注意到某些模式和某些功能
you'll start to notice certain patterns and certain capabilities

13
00:00:50,083 --> 00:00:52,000
一些语言 而不是另一种语言 
of some languages but not another.

14
00:00:52,000 --> 00:00:54,791
到目前为止 在Python的世界里 你和我
Thus far, within the world of Python, you and I

15
00:00:54,791 --> 00:00:58,541
在很大程度上是在编写本质上是程序性的代码 因此我们
have largely been writing code that's procedural in nature, whereby we're

16
00:00:58,541 --> 00:01:00,708
编写过程；我们正在编写函数；
writing procedures; we're writing functions;

17
00:01:00,708 --> 00:01:03,166
我们从头到尾都在做事情 
and we're doing things top to bottom.

18
00:01:03,166 --> 00:01:05,458
一切都是循序渐进的 就像你会做的那样
Everything is step by step by step, as you would

19
00:01:05,458 --> 00:01:07,208
一般说来 对算法的期望 
expect in general from an algorithm.

20
00:01:07,208 --> 00:01:09,250
但在这一过程中 我们实际上涉足了
But along the way, we've actually dabbled

21
00:01:09,250 --> 00:01:14,083
在另一种称为使用Python的函数式编程的范例中 我们已经
in another paradigm known as functional programming with Python whereby we've

22
00:01:14,083 --> 00:01:15,875
能够传递函数 
been able to pass functions around.

23
00:01:15,875 --> 00:01:18,666
几周前我们甚至有一个匿名功能 
We even had an anonymous function some weeks ago.

24
00:01:18,666 --> 00:01:22,500
这是函数式编程语言特点的证据 
And that's evidence of features of a functional programming language,

25
00:01:22,500 --> 00:01:24,708
尽管我们只是触及了它的皮毛 
even though we've just scratched the surface thereof.

26
00:01:24,708 --> 00:01:28,083
今天我们关注的是另一种模式 这个模式更加详细--
Today we focus on another paradigm, and this one in more detail--

27
00:01:28,083 --> 00:01:30,166
即面向对象编程 
namely object-oriented programming.

28
00:01:30,166 --> 00:01:32,958
现在 虽然你们中的一些人可能有过编程经验
And now, while some of you might have prior programming experience

29
00:01:32,958 --> 00:01:36,500
并且已经学习了像Java这样的语言 根据设计 这些语言基本上
and have learned languages like Java, which are, by design, fundamentally

30
00:01:36,500 --> 00:01:40,291
面向对象的 Python确实允许您具有一定的灵活性
object-oriented, Python indeed allows you a bit of flexibility

31
00:01:40,291 --> 00:01:43,250
当谈到如何用代码解决问题时 
when it comes to how you solve problems with code.

32
00:01:43,250 --> 00:01:46,458
但事实证明 面向对象编程
But it turns out object-oriented programming

33
00:01:46,458 --> 00:01:49,000
是一个非常令人信服的问题解决方案
is a pretty compelling solution to problems

34
00:01:49,000 --> 00:01:52,666
当你的程序变得更长 更大 
that you invariably encounter as your programs get longer, larger,

35
00:01:52,666 --> 00:01:54,375
而且更复杂 
and more complicated.

36
00:01:54,375 --> 00:01:56,333
因此 事实上 对于我们的目的 OOP将
So indeed, OOP, for our purposes, is going

37
00:01:56,333 --> 00:02:00,791
成为一个建立在过去许多教训基础上的问题的解决方案 
to be a solution to a problem that builds on so many of the lessons past.

38
00:02:00,791 --> 00:02:02,458
所以让我们继续做这件事 
So let's go ahead and do this.

39
00:02:02,458 --> 00:02:05,833
让我们从非常程序化地编写程序开始
Let's start by writing a program very procedurally

40
00:02:05,833 --> 00:02:07,625
在这里打开VS代码 
by opening up VS Code here.

41
00:02:07,625 --> 00:02:10,875
我将继续创建一个名为Student.py的程序 
I'm going to go ahead and create a program called student.py.

42
00:02:10,875 --> 00:02:14,083
在这个节目中 我想做一些相对简单的事情
And in this program, I want to do something relatively simple

43
00:02:14,083 --> 00:02:18,375
最初 就像我们几周前可能做的那样 我只是
initially, as we might have done some weeks ago now, where I just

44
00:02:18,375 --> 00:02:22,166
向用户询问他们的名字 也许是在《哈利波特》的上下文中
ask a user for their name and, maybe in the context of the Harry Potter

45
00:02:22,166 --> 00:02:26,291
宇宙 他们的房子 然后打印出那个学生来自哪里 
universe, their house, and just print out where that student is from.

46
00:02:26,291 --> 00:02:30,166
让我们通过向它添加越来越多的功能来逐步增强这个程序
And let's gradually enhance this program by adding more and more features to it

47
00:02:30,166 --> 00:02:33,875
看看我们是否会偶然发现一些问题 到目前为止 
and see if we don't stumble upon problems that, up until now,

48
00:02:33,875 --> 00:02:36,958
我们可能没有非常优雅、精心设计的解决方案来解决 
we might not have had very elegant, well-designed solutions to.

49
00:02:36,958 --> 00:02:40,250
但是如果我们明确地引入面向对象编程
But if we introduce, explicitly, object-oriented programming

50
00:02:40,250 --> 00:02:43,250
作为一种编程技术 我打赌我们可以清理我们的代码
as a programming technique, I bet we can clean up our code

51
00:02:43,250 --> 00:02:47,208
并为编写更复杂、更长的程序奠定了基础
and set the stage for writing even more sophisticated programs, longer programs

52
00:02:47,208 --> 00:02:48,083
顺着路线走下去 
down the line.

53
00:02:48,083 --> 00:02:51,791
因此 在Student.py中 让我继续做一个名称变量 
So in student.py, let me go ahead and do a name variable,

54
00:02:51,791 --> 00:02:54,250
将其设置为等于输入的返回值 
setting it equal to the return value of input,

55
00:02:54,250 --> 00:02:57,041
只需提示用户输入他们的名字 如下所示 
and just prompt the user for their name like this.

56
00:02:57,041 --> 00:02:59,791
然后让我们继续对house变量执行相同的操作
And then let me go ahead and do the same for a house variable

57
00:02:59,791 --> 00:03:03,041
并提示用户输入他们的房子 如下所示 
and prompt the user for their house, using input like this.

58
00:03:03,041 --> 00:03:05,208
现在让我们做一些非常简单的事情 
And let's do something super simple now.

59
00:03:05,208 --> 00:03:07,875
让我们继续打印一个f字符串
Let's just go ahead and print out an f string

60
00:03:07,875 --> 00:03:11,291
上面写着房子里的名字 
that says something like name from house,

61
00:03:11,291 --> 00:03:13,958
这样我就可以确认这些变量的内容
just so that I can confirm that the contents of these variables

62
00:03:13,958 --> 00:03:15,000
确实如我所料 
are indeed as I expect.

63
00:03:15,000 --> 00:03:17,083
我不会执行任何错误检查或修剪
I'm not going to do any error checking or trimming

64
00:03:17,083 --> 00:03:18,333
或任何类似的东西 目前 
or anything like that for now.

65
00:03:18,333 --> 00:03:21,416
我真的要把用户刚输入的内容吐出来 
I'm really just going to spit back out whatever the user just typed in.

66
00:03:21,416 --> 00:03:24,375
好的 让我继续运行PYTHON of Student.py 
All right, let me go ahead and run Python of student.py.

67
00:03:24,375 --> 00:03:29,083
让我们使用我们的首选 就像《哈利·波特》中的《格兰芬多》 
Let's use our go-to, like Harry, as in Harry Potter, from Gryffindor.

68
00:03:29,083 --> 00:03:32,958
当我按回车键时 现在让我们看看我是否看到来自格兰芬多的哈里
And when I hit Enter, now let's see if I see that Harry from Gryffindor

69
00:03:32,958 --> 00:03:34,041
确实是这样 
is indeed the case.

70
00:03:34,041 --> 00:03:37,375
好的 我想我们现在有一个工作计划 但让我们
All right, so I think we have a working program at this point, but let's

71
00:03:37,375 --> 00:03:40,541
现在介绍一下从零周开始学到的一些经验教训
now introduce some of those lessons learned way back from week zero

72
00:03:40,541 --> 00:03:42,583
在那里我们开始编写自己的函数 
where we started writing our own functions,

73
00:03:42,583 --> 00:03:46,250
不一定是因为它更正确地解决了问题--
not necessarily because it solves the problem more correctly--

74
00:03:46,250 --> 00:03:47,916
我敢说这是正确的 
I daresay this is correct as is.

75
00:03:47,916 --> 00:03:52,041
但它开始为我们提供我们可以扩展的构建块
But it begins to give us building blocks that we can extend so

76
00:03:52,041 --> 00:03:54,125
至于解决更复杂的程序 
as to solve more complicated programs.

77
00:03:54,125 --> 00:03:58,375
所以让我回到Student.py 让我们现在继续做这件事 
So let me go back up to student.py, and let's go ahead now and do this.

78
00:03:58,375 --> 00:04:01,875
让我们将我刚刚编写的整个逻辑放在我们的典型方法中
Let's put the entire logic I just wrote inside of our typical method

79
00:04:01,875 --> 00:04:05,458
名为main 让我缩进这三行 这样至少它们是
called main, and let me indent those three lines so that at least they're

80
00:04:05,458 --> 00:04:07,333
现在结合成一个主要的方法 
now combined into one main method.

81
00:04:07,333 --> 00:04:12,208
但是不是使用线路2上的输入与线路3上的输入 
But instead of using input on line 2 an input on line 3,

82
00:04:12,208 --> 00:04:14,083
我们现在是不是应该假设 
don't we go ahead and assume, for the moment,

83
00:04:14,083 --> 00:04:17,000
我们在世界上有一个名为get_name的函数 
that we've got some function called get_name in the world,

84
00:04:17,000 --> 00:04:19,958
让我们继续并假设我们有另一个类似Get_house的函数
and let's go ahead and assume we've got another function like get_house

85
00:04:19,958 --> 00:04:21,708
世界上不需要参数的人 
in the world that don't take parameters.

86
00:04:21,708 --> 00:04:24,166
但他们的生活目标 在他们的名字里 
But their purpose in life is, by their name,

87
00:04:24,166 --> 00:04:28,458
将分别获得用户的名称和他们的用户的房子 
going to be to get the user's name and to get their users house, respectively.

88
00:04:28,458 --> 00:04:32,083
然后我将打印出和之前完全相同的f字符串 
And then I'm going to print out the exact same f string as before.

89
00:04:32,083 --> 00:04:34,333
当然 我现在需要实现这些功能 
I, of course, need to implement these functions now.

90
00:04:34,333 --> 00:04:38,291
因此 让我在文件的下面定义一个名为GET_NAME的函数 
So let me go lower in my file and define a function called get_name.

91
00:04:38,291 --> 00:04:41,375
这些括号里什么都没有 因为它不会接受参数 
Nothing in these parentheses because it's not going to take a parameter.

92
00:04:41,375 --> 00:04:44,083
我将继续做一些类似于名称等于输入的操作
And I'm going to go ahead and do something like name equals input

93
00:04:44,083 --> 00:04:48,750
(“name”) 就像以前一样 然后我将继续并返回name 
("Name"), just like before, and then I'm going to go ahead and return name.

94
00:04:48,750 --> 00:04:52,000
所以这是一个超级简单的函数 但它是一个抽象的 
So it's a super simple function, but it's an abstraction.

95
00:04:52,000 --> 00:04:55,458
我现在有一个名为get_name的函数 它的实现细节
I now have a function called get_name whose implementation details

96
00:04:55,458 --> 00:04:56,916
我再也不需要关心了 
I don't have to care about anymore.

97
00:04:56,916 --> 00:04:58,458
我只知道这个功能是存在的 
I just know that the function exists.

98
00:04:58,458 --> 00:05:00,250
事实上 我可以加强这一点 
And I can tighten this up, in fact, .

99
00:05:00,250 --> 00:05:02,875
在第8行中并不真正需要名称变量
Don't really need a name variable on line 8

100
00:05:02,875 --> 00:05:05,875
如果我要立即在第9行返回相同名称的变量 
if I'm immediately going to return that same name variable on line 9.

101
00:05:05,875 --> 00:05:07,833
所以让我把这个绷紧一点
So let me just tighten this up a little bit

102
00:05:07,833 --> 00:05:09,791
即使它不会改变功能
even though it doesn't change the functionality

103
00:05:09,791 --> 00:05:15,750
并且只需立即返回此处INPUTS函数调用的返回值 
and just immediately return the return value of the inputs function call here.

104
00:05:15,750 --> 00:05:18,916
现在让我们为Get_house做一些非常类似的事情 
Let's do something very similar now for get_house,

105
00:05:18,916 --> 00:05:20,750
同样 这也不会有任何争论 
which will similarly take no arguments.

106
00:05:20,750 --> 00:05:22,666
我要继续并退回退款
I'm going to go ahead and return the return

107
00:05:22,666 --> 00:05:25,541
输入值 这一次提示用户选择他们的房子 
value of input, this time prompting the user for their house.

108
00:05:25,541 --> 00:05:27,250
我还需要最后一个细节 
And I need one final detail.

109
00:05:27,250 --> 00:05:32,208
在最下面 让我们继续我们的习惯 如果此文件的名称
At the very bottom, let's continue our habit of doing if the name of this file

110
00:05:32,208 --> 00:05:35,750
等于 等于 引号 不引号 主键 然后让我们继续
equals, equals, quote, unquote, main, then let's go ahead

111
00:05:35,750 --> 00:05:38,875
然后实际呼叫Main并回想一下我们已经准备好了
and actually call main and recall that we have that in place

112
00:05:38,875 --> 00:05:42,458
所以 如果这最终成为一个模块的一部分 一个各种各样的库 
so that, if this eventually becomes part of a module, a library of sorts,

113
00:05:42,458 --> 00:05:44,791
我不会不小心盲目地给Main打电话 
I don't accidentally call main blindly.

114
00:05:44,791 --> 00:05:50,250
只有当我打算从该文件的命令行运行main时 我才会这样做 
I only do it if I mean to run main from the command line on this file.

115
00:05:50,250 --> 00:05:53,458
好的 如果我没有犯任何错误 让我继续
All right, so if I didn't make any mistakes here, let me go ahead

116
00:05:53,458 --> 00:05:57,416
然后 在我的终端窗口中 再次运行Student.py的Python 输入 
and, in my terminal window, again, run Python of student.py, Enter.

117
00:05:57,416 --> 00:05:59,250
让我们输入哈里 回车 
Let's type in Harry, Enter.

118
00:05:59,250 --> 00:06:01,541
让我们输入格兰芬多 回车 
Let's type in Gryffindor, Enter.

119
00:06:01,541 --> 00:06:02,875
我们已经准备好了 
And we're set.

120
00:06:02,875 --> 00:06:05,583
来自格兰芬多的哈里似乎还在工作 
Harry from Gryffindor seems to still be working.

121
00:06:05,583 --> 00:06:09,416
所以我们并没有真正正确地解决这个问题 
So we haven't really solved the problem any more correctly,

122
00:06:09,416 --> 00:06:11,875
但我已经奠定了基础 也许现在就可以
but I've laid the foundation to maybe now do

123
00:06:11,875 --> 00:06:13,583
一些更有趣的事情 因为我已经
some more interesting things because I've

124
00:06:13,583 --> 00:06:16,875
把这些积木放在适当的位置 
had these building blocks in place.

125
00:06:16,875 --> 00:06:21,083
但让我提议 我们可以用一点不同的方式来做这件事 
But let me propose that we could be doing this a little bit differently.

126
00:06:21,083 --> 00:06:23,000
GET_NAME GET_HOUSE很好 
get_name, get_house is fine.

127
00:06:23,000 --> 00:06:26,416
但归根结底 我真的是想从用户那里得到一个学生 
But at the end of the day, I'm really trying to get a student from the user.

128
00:06:26,416 --> 00:06:30,083
我要他们的名字和他们的房子 而不只是其中之一 
I want their name and their house, not just one or the other.

129
00:06:30,083 --> 00:06:32,833
所以也许它会更干净一点
So maybe it would be a little cleaner still

130
00:06:32,833 --> 00:06:36,083
定义一个名为Get_Student的函数并让
to define a function called get_student and let

131
00:06:36,083 --> 00:06:38,291
Get_Student为我们做所有这些工作 
get_student do all of this work for us.

132
00:06:38,291 --> 00:06:43,000
现在 理论上 get学生可以调用get_name 也可以调用get_house 
Now, theoretically, get_student could call get_name and could call get_house.

133
00:06:43,000 --> 00:06:44,750
但由于这些函数太短了 
But because these functions are so short,

134
00:06:44,750 --> 00:06:48,875
我想我可以只定义一个名为Get_Student的函数 
I think I'm OK with just defining one function, called get_student,

135
00:06:48,875 --> 00:06:50,666
同样 这也不需要任何论据 
that similarly won't take any arguments.

136
00:06:50,666 --> 00:06:52,250
但它会做两件事 
But it's going to do two things.

137
00:06:52,250 --> 00:06:55,875
它将通过像以前一样提示他们输入 来获得学生的名字 
It's going to get the students name, by prompting them with input as before.

138
00:06:55,875 --> 00:06:57,625
它会夺走学生的房子 
And it's going to get the student's house,

139
00:06:57,625 --> 00:07:01,125
通过也像以前一样提示他们 
by also prompting them as before.

140
00:07:01,125 --> 00:07:02,416
现在 嗯 
Now, hmm.

141
00:07:02,416 --> 00:07:04,833
我想把学生还回去 但我觉得
I want to return the student, but I think

142
00:07:04,833 --> 00:07:06,875
我可能把自己逼到了墙角
I might have painted myself into a corner

143
00:07:06,875 --> 00:07:10,125
因为我现在有两个变量--name和house 
here because I now have two variables-- name and house.

144
00:07:10,125 --> 00:07:13,250
然而 到目前为止 我们基本上只退还了其中的一种 
And yet, up until now, we've pretty much returned one or the other.

145
00:07:13,250 --> 00:07:15,000
我们返回了一个值 
We've returned one value.

146
00:07:15,000 --> 00:07:17,500
所以有没有什么建议可以让我们
So any suggestions for how we can perhaps

147
00:07:17,500 --> 00:07:22,375
解决我刚刚为自己创造的这个问题 借此我想返回 
solve this problem that I just created for myself, whereby I want to return,

148
00:07:22,375 --> 00:07:28,083
真的 我是个学生 但我现在有一个名字变量和一个房子变量 
really, a student, but I currently have a name variable and a house variable.

149
00:07:28,083 --> 00:07:30,541
我至少想把这两件都退货 
I'd minimally like to return both of those.

150
00:07:30,541 --> 00:07:33,208
听众：我相信 我们可以归还一本词典 
AUDIENCE: I believe that, we can return a dictionary,

151
00:07:33,208 --> 00:07:35,000
包括名字和房子 
includes the name and the house.

152
00:07:35,000 --> 00:07:36,833
大卫·J·马兰：是的 所以我们绝对可以
DAVID J. MALAN: Yeah, so we absolutely could

153
00:07:36,833 --> 00:07:41,000
返回一个字典--Python中的Dict对象 其中可能有一个键是name；
return a dictionary-- a dict object in Python, whereby maybe one key is name;

154
00:07:41,000 --> 00:07:43,666
一把钥匙是房子 它的价值恰好是
one key is house; and the values thereof are exactly

155
00:07:43,666 --> 00:07:44,916
这些变量的值 
the values of these variables.

156
00:07:44,916 --> 00:07:46,791
所以我们完全可以这么做 
So we could totally do that.

157
00:07:46,791 --> 00:07:49,375
我担心这可能会变得有点复杂 
I worry that that might be getting a little complicated.

158
00:07:49,375 --> 00:07:51,916
我想知道有没有更简单的方法来代替 
I wonder if there's a simpler way instead.

159
00:07:51,916 --> 00:07:55,000
还有其他本能吗--即使你不确定它会奏效吗？
Any other instincts-- even if you're not sure it would work?

160
00:07:55,000 --> 00:07:56,541
观众：名字和房子都要还吗？
AUDIENCE: Return both name and house?

161
00:07:56,541 --> 00:07:58,333
大卫·J·马兰：把名字和房子都还回来 
DAVID J. MALAN: Return both name and house.

162
00:07:58,333 --> 00:07:59,416
我喜欢听你这么说 
I like the sound of that.

163
00:07:59,416 --> 00:08:00,250
这听起来很简单 
It sounds simple.

164
00:08:00,250 --> 00:08:03,041
我不需要考虑字典会是什么样子的 
I don't have to figure out what a dictionary is going to look like.

165
00:08:03,041 --> 00:08:05,750
事实上 这也是一种有效的方法 
And in fact, this, too, would be a valid approach,

166
00:08:05,750 --> 00:08:07,250
即使你以前没见过这个 
even if you've not seen this before.

167
00:08:07,250 --> 00:08:11,625
事实证明 在Python中 您可以返回多个值 
It turns out, in Python, that you can return multiple values,

168
00:08:11,625 --> 00:08:12,958
但这是一个善意的谎言 
but that's a bit of a white lie.

169
00:08:12,958 --> 00:08:16,333
或者我们可以采用穆罕默德的方法 实际上归还一本词典
Or we could take Muhammad's approach of actually returning a dictionary

170
00:08:16,333 --> 00:08:17,833
并在其中放置多个钥匙 
and putting multiple keys therein.

171
00:08:17,833 --> 00:08:19,833
所以在这里 我们又有了另一个例子
So here, again, we have yet another example

172
00:08:19,833 --> 00:08:22,375
你如何至少用两种方式解决同样的问题 
of how you can solve the same problem in at least two ways,

173
00:08:22,375 --> 00:08:24,708
我敢说 我们即将看到更多 
and I daresay we're about to see even more.

174
00:08:24,708 --> 00:08:27,916
因此 解决这个问题的一种方法是
So one way you could solve this problem, whereby

175
00:08:27,916 --> 00:08:32,916
如果想要返回多个值 可以这样做 
you want to return multiple values, would be to do something like this.

176
00:08:32,916 --> 00:08:37,666
我可以按字面意思返回 不只是名字 还可以加一个逗号
I could go ahead and literally return not just name, but I could put a comma

177
00:08:37,666 --> 00:08:39,250
也要把房子还回去 
and also return house.

178
00:08:39,250 --> 00:08:41,958
这不一定是您可以在其他语言中完成的操作
This is not necessarily something you can do in other languages

179
00:08:41,958 --> 00:08:44,166
如果您以前用过其他语言编程 
if you have programmed in other languages before.

180
00:08:44,166 --> 00:08:45,416
这取决于语言 
It depends on the language.

181
00:08:45,416 --> 00:08:49,291
但看起来 多亏了这个逗号 也许我可以 实际上 
But it looks like, thanks to this comma, maybe I can, in fact,

182
00:08:49,291 --> 00:08:51,916
返回[INAUDIBLE]建议的两个值 
return two values as [INAUDIBLE] proposed.

183
00:08:51,916 --> 00:08:55,375
好 如果我用这种方式返回第10行的值 
Well, if I'm returning to values in this way on line 10,

184
00:08:55,375 --> 00:08:57,916
如何同时获得这两个值？
how do I get both values at the same time?

185
00:08:57,916 --> 00:08:59,208
好吧 有几种方法 
Well, there's a couple of ways.

186
00:08:59,208 --> 00:09:01,833
让我继续我的主要任务 
Let me go up to my main function.

187
00:09:01,833 --> 00:09:04,416
我知道 至少 我将不得不更改get_name
I know, minimally, I'm going to have to change the get_name

188
00:09:04,416 --> 00:09:05,958
找一间房子去找一名学生 
and get_house to get_student.

189
00:09:05,958 --> 00:09:09,041
但是我要把返回值存储在什么地方呢？
But what am I going to store the return value in?

190
00:09:09,041 --> 00:09:11,500
我想我真的能做到 
I think I could actually do this.

191
00:09:11,500 --> 00:09:14,916
我们以前见过这种技术 你可以打开行李 
And we have seen this technique before, where you can unpack,

192
00:09:14,916 --> 00:09:17,541
可以说 一系列的价值正在回归 
so to speak, sequences of values that are coming back.

193
00:09:17,541 --> 00:09:21,083
事实上 你可以认为这就是事实 名字,
And indeed, consider this to be exactly that. name,

194
00:09:21,083 --> 00:09:25,000
房子是我要返回的某种值序列--名字 房子 
house is some kind of sequence that I'm returning of values-- name, house.

195
00:09:25,000 --> 00:09:27,291
因此 如果我想打开这些文件并存储退货
So if I want to unpack those and store the return

196
00:09:27,291 --> 00:09:30,000
在两个独立变量中的值 我可以 事实上 
values in two separate variables, I can, in fact,

197
00:09:30,000 --> 00:09:34,208
使用赋值运算符左侧的逗号、等号、
use the commas on the left-hand side of my assignment operator, the equal sign,

198
00:09:34,208 --> 00:09:35,416
正是为了做到这一点 
to do just that.

199
00:09:35,416 --> 00:09:40,000
现在 为了清楚起见 我不需要在这里将这些变量称为name和house 
Now, to be clear, I don't need to call these variables name and house here.

200
00:09:40,000 --> 00:09:43,500
我可以简化这个 在这里只用n 在这里用h 
I could simplify this and use just n here and h here,

201
00:09:43,500 --> 00:09:46,583
然后我可以只返回n和h 
and then I could return just n and h.

202
00:09:46,583 --> 00:09:51,208
但我认为这对读者来说并不是很清楚到底发生了什么 
But I would argue that's not very clear to the reader as to what's going on.

203
00:09:51,208 --> 00:09:52,958
所以我认为 在这种情况下 即使它是
So I think, in this case, even though it's

204
00:09:52,958 --> 00:09:56,000
巧合的是 我在Get_Student中使用了相同的变量名
a coincidence that I've used the same variable names in get_student

205
00:09:56,000 --> 00:09:59,875
和get_name 在Main中 对于像我这样的人来说 它更具可读性 
and get_name, and in main, it's a little more readable to someone like me.

206
00:09:59,875 --> 00:10:01,541
所以我会让它保持原样 
So I'm going to leave it as is.

207
00:10:01,541 --> 00:10:04,041
好吧 让我们来看看 现在 这个方法是否奏效 
Well, let's go ahead and see, now, if this works.

208
00:10:04,041 --> 00:10:07,166
让我清空下面的屏幕 然后运行Student.py的Python 回车 
Let me clear my screen down here and run Python of student.py, Enter.

209
00:10:07,166 --> 00:10:08,375
让我们再输入一次哈里 
Let's again type in Harry.

210
00:10:08,375 --> 00:10:11,041
让我们再次输入Gryffindor 回车 
Let's again type in Gryffindor, Enter.

211
00:10:11,041 --> 00:10:14,791
瞧 我们仍然看到哈里来自格兰芬多 
And voila, we still see that Harry is from Gryffindor.

212
00:10:14,791 --> 00:10:16,958
但我们到底在这里做什么呢？
But what are we actually doing here?

213
00:10:16,958 --> 00:10:19,666
我们返回这个值实际上是在做什么？
What are we actually doing by returning this value?

214
00:10:19,666 --> 00:10:24,333
事实证明 我们刚才所做的是使用元组 
Well, it turns out that what we've just done is use a tuple.

215
00:10:24,333 --> 00:10:29,791
元组是Python中的另一种数据类型 它是值的集合--
A tuple is another type of data in Python that's a collection of values--

216
00:10:29,791 --> 00:10:32,291
X y或x y z 
x, y or x, y, z.

217
00:10:32,291 --> 00:10:36,750
从这个意义上说 它在精神上类似于列表 但它是一成不变的 
It's similar in spirit to a list, in that sense, but it's immutable.

218
00:10:36,750 --> 00:10:37,666
它不是可变的 
It's not mutable.

219
00:10:37,666 --> 00:10:38,708
那么 这意味着什么呢？
Now, what does that mean?

220
00:10:38,708 --> 00:10:41,708
正如我们以前看到的 列表是Python中的一种数据结构
A list, as we've seen it before, is a data structure in Python

221
00:10:41,708 --> 00:10:43,458
您可以更改的值 
that you can change the values of.

222
00:10:43,458 --> 00:10:47,250
您可以进入第一个位置的括号0 并在那里更改值 
You can go into bracket 0 for the first location and change the value there.

223
00:10:47,250 --> 00:10:50,208
您可以转到括号1、括号2、括号3 然后实际更改
You can go to bracket 1, bracket 2, bracket 3 and actually change

224
00:10:50,208 --> 00:10:51,458
列表中的值 
the values in lists.

225
00:10:51,458 --> 00:10:54,791
但如果您不想更改变量的值
But if you have no intention of changing the values of variables

226
00:10:54,791 --> 00:10:57,750
你想要有效地返回多个值 
and you want to return, effectively, multiple values,

227
00:10:57,750 --> 00:10:59,541
您甚至不需要将其作为列表返回 
you don't have to even return it as a list.

228
00:10:59,541 --> 00:11:03,416
您可以将其作为元组返回 只需使用逗号 
You can return it as a tuple instead, just by using a comma.

229
00:11:03,416 --> 00:11:07,000
事实证明 我们可以清楚地表明--这是一个善意的谎言 
And it turns out we can make explicit that-- here's the white lie.

230
00:11:07,000 --> 00:11:10,500
实际上 我并不是要回到价值观本身 
I'm not actually returning to values per se.

231
00:11:10,500 --> 00:11:13,416
每当您在第9行使用逗号时 
Whenever you use a comma in this way on line 9,

232
00:11:13,416 --> 00:11:17,500
您实际上返回了一个值 这是一个元组 
you're actually returning one value, which is a tuple.

233
00:11:17,500 --> 00:11:20,291
现在 该元组内部有两个值 
Inside of that tuple now are two values.

234
00:11:20,291 --> 00:11:23,791
所以这在本质上类似于在这里返回一个列表和两个东西
So it's similar in spirit to returning one list with two thing Here

235
00:11:23,791 --> 00:11:26,291
我要返回一个包含两个元素的元组 
I'm returning one tuple with two things.

236
00:11:26,291 --> 00:11:28,958
事实是我只用了逗号 没有用其他
And the mere fact that I've used a comma and nothing else

237
00:11:28,958 --> 00:11:31,375
告诉Python我确实想返回一个元组 
tells Python that I indeed want to return a tuple.

238
00:11:31,375 --> 00:11:34,083
但是 我们可以使用更显式的语法 
But there's more explicit syntax that we can use instead.

239
00:11:34,083 --> 00:11:39,291
我实际上可以--更详细地--用显式的圆括号将值括起来
I can actually-- more verbosely-- put explicit parentheses around the values

240
00:11:39,291 --> 00:11:42,458
为了让我和读者更清楚地了解这个元组
of this tuple just to make more clear to me, to the reader

241
00:11:42,458 --> 00:11:44,083
这本身并不是两种价值 
that this isn't two values per se.

242
00:11:44,083 --> 00:11:46,500
这是一个价值 里面有两个东西 
This is one value with two things inside of it.

243
00:11:46,500 --> 00:11:48,458
而我实际上能做的也是--
And what I can actually do then, too, is--

244
00:11:48,458 --> 00:11:51,000
可以这么说 我不需要在这里解开这些东西 
I don't have to unpack this up here, so to speak.

245
00:11:51,000 --> 00:11:54,833
我可以在这里取个更贴切的名字 比如学生 
I can actually go up here and maybe give a more apt name, like student,

246
00:11:54,833 --> 00:11:58,375
我可以给值命名 或者说给变量命名
and I can name the value, or rather name the variable

247
00:11:58,375 --> 00:12:01,333
其中我将get_student的返回值存储为 
in which I'm storing the return value of get_student as,

248
00:12:01,333 --> 00:12:02,791
“学生 “
quote, unquote, "student."

249
00:12:02,791 --> 00:12:05,166
所以也许这是一个更好的设计
So maybe this is a little better design now

250
00:12:05,166 --> 00:12:08,625
因为我在抽象学生是什么 
because I'm sort of abstracting away what a student is.

251
00:12:08,625 --> 00:12:11,666
它目前被实现为具有两个值的元组 
It's implemented at the moment as a tuple with two values.

252
00:12:11,666 --> 00:12:15,875
但至少 现在我有了一个变量 叫做学生 
But at least, now I have a variable called what I mean, a student.

253
00:12:15,875 --> 00:12:17,375
但会有一个陷阱 
But there's going to be a catch.

254
00:12:17,375 --> 00:12:21,583
在第3行 我仍然想打印出那个学生的名字和他们的房子 
On line 3, I still want to print out that student's name and their house.

255
00:12:21,583 --> 00:12:24,541
但是我没有名字变量了 我也没有房子了 
But I don't have a name variable anymore, and I don't have a house.

256
00:12:24,541 --> 00:12:28,625
我也没有字典 就像之前说的 所以我甚至不能
And I also don't have a dictionary, as was proposed earlier, so I can't even

257
00:12:28,625 --> 00:12:31,833
按名字去拿钥匙
go at those keys by name.

258
00:12:31,833 --> 00:12:35,166
但元组是什么--它在本质上与列表非常相似 
But what a tuple is-- it's very similar in spirit to a list,

259
00:12:35,166 --> 00:12:37,000
但它确实是不可变的 
but it is indeed just immutable.

260
00:12:37,000 --> 00:12:39,791
我的意思是我仍然可以索引到它
And what I mean by that is I can still index into it

261
00:12:39,791 --> 00:12:45,041
用数字表示学生[0]
numerically by saying student [0] for the item

262
00:12:45,041 --> 00:12:47,000
在元组的第一个位置 
in the first location in that tuple.

263
00:12:47,000 --> 00:12:50,416
然后在这里 我可以说学生 而不是房子 
And then over here, instead of house, I can say student [1].

264
00:12:50,416 --> 00:12:54,291
student [1]将给出元组中的第二个位置 
student [1] is going to give me the second location in that tuple.

265
00:12:54,291 --> 00:12:56,166
我先去清空终端窗口 
Let me go ahead and clear my terminal window.

266
00:12:56,166 --> 00:12:58,083
再次运行student.py的Python 
Again, run Python of student.py.

267
00:12:58,083 --> 00:12:59,250
让我们输入哈里 
Let's type in Harry.

268
00:12:59,250 --> 00:13:04,500
让我们输入格兰芬多 回车 我们还有一些工作代码 
Let's type in Gryffindor, Enter, and we still have some working code.

269
00:13:04,500 --> 00:13:07,208
让我在这里暂停一下 看看是否有
Let me pause here now and see if there are

270
00:13:07,208 --> 00:13:11,500
关于返回元组的技术 
any questions on this technique of returning a tuple

271
00:13:11,500 --> 00:13:14,750
并以这种方式索引它 
and indexing into it in this way.

272
00:13:14,750 --> 00:13:17,125
观众：我想 什么是一个实际的用例 
AUDIENCE: I guess, what's an actual use case where

273
00:13:17,125 --> 00:13:21,333
你会使用元组还是列表或者其他类似的东西？
you would use a tuple versus a list or something else that's similar?

274
00:13:21,333 --> 00:13:23,166
大卫·J·马兰：这是一个很好的问题 
DAVID J. MALAN: It's a really good question.

275
00:13:23,166 --> 00:13:25,291
什么时候使用元组而不是列表？
When would you use a tuple versus a list?

276
00:13:25,291 --> 00:13:28,208
当你想进行防御性编程时 或者 一般来说 
When you want to program defensively, or, in general,

277
00:13:28,208 --> 00:13:31,375
当你知道这个变量中的值不应该改变时 
when you know that the values in this variable shouldn't change,

278
00:13:31,375 --> 00:13:34,333
那么 为什么要使用允许它们被更改的数据类型呢？
so why would you use a data type that allows them to be changed?

279
00:13:34,333 --> 00:13:37,791
它只会招致错误 臭虫 要么
It just invites mistakes, bugs down the line, either

280
00:13:37,791 --> 00:13:40,666
由您或与您的代码交互的同事创建 
by you or colleagues who are interacting with your code.

281
00:13:40,666 --> 00:13:44,083
因此 元组只是另一种您可以增加
So tuple is just another way where you can increase

282
00:13:44,083 --> 00:13:47,708
不让任何人 包括你自己 
the probability of correctness by just not letting anyone, yourself included,

283
00:13:47,708 --> 00:13:49,750
更改其中的内容 
change the contents therein.

284
00:13:49,750 --> 00:13:52,250
所以它只是您工具箱中的另一个工具 
So it's just another tool in your toolkit.

285
00:13:52,250 --> 00:13:55,333
但是 让我们明确一下我所说的“不变”是什么意思 
But let's make clear, then, what I mean by "immutable."

286
00:13:55,333 --> 00:13:58,833
同样 我声称“不可变”意味着您不能更改该值 
Again, I claim that "immutable" means that you cannot change the value.

287
00:13:58,833 --> 00:14:01,000
好吧 让我们继续试着这样做 
Well, let's go ahead and try to do this.

288
00:14:01,000 --> 00:14:03,750
让我继续按原样运行这个程序--
Let me go ahead and run this program once more as is--

289
00:14:03,750 --> 00:14:05,291
Student.py的蟒蛇 
Python of student.py.

290
00:14:05,291 --> 00:14:09,416
例如 让我继续输入--
Let me go ahead and type in, for instance--

291
00:14:09,416 --> 00:14:11,375
帕德玛的名字呢？
how about Padma's name?

292
00:14:11,375 --> 00:14:13,208
我要说的是 帕德玛
And I'm going to go ahead and say that Padma

293
00:14:13,208 --> 00:14:14,916
是在格兰芬多 就像电影里一样 
is in Gryffindor as in the movies.

294
00:14:14,916 --> 00:14:16,958
我们看到了--格兰芬多的帕德玛 
And we see-- Padma from Gryffindor.

295
00:14:16,958 --> 00:14:20,791
但严格来说 我走进这个兔子洞是为了看哈利波特
But technically, I went down this rabbit hole in looking at Harry Potter

296
00:14:20,791 --> 00:14:21,541
离得更近 
more closely.

297
00:14:21,541 --> 00:14:25,000
严格来说 在书中 我相信帕德玛来自拉文克劳 
Technically, in the books, Padma, I believe, was from Ravenclaw.

298
00:14:25,000 --> 00:14:27,083
因此 这实际上是一个错误或不一致
So this is actually a mistake or an inconsistency

299
00:14:27,083 --> 00:14:28,750
在电影和书之间 
between the movies and the books.

300
00:14:28,750 --> 00:14:31,625
让我们看看我们是否不能修复代码中的这种不一致 
Let's see if we can't fix this inconsistency in our code.

301
00:14:31,625 --> 00:14:33,208
那我们来做这个怎么样？
So how about we do this?

302
00:14:33,208 --> 00:14:36,333
如果输入的学生姓名等于帕德玛 
If the student's name that's inputted equals Padma,

303
00:14:36,333 --> 00:14:40,208
我们为什么不不管这房子是什么
why don't we override whatever the house is

304
00:14:40,208 --> 00:14:42,875
把它改成真正的格兰芬多 
and change it to be properly Gryffindor.

305
00:14:42,875 --> 00:14:46,083
让我继续做 如果学生--
Let me go ahead and do if student--

306
00:14:46,083 --> 00:14:49,708
现在 如果我想得到帕德玛的名字 我将不得不做学生[0] 
now, if I want to get at Padma's name, I'm going to have to do student [0].

307
00:14:49,708 --> 00:14:52,625
我必须知道这个名字在这个元组中的位置 
I have to know what location the name is in in this tuple.

308
00:14:52,625 --> 00:14:57,750
但是 如果该值等于Padma 那么让我们继续执行这条if语句
But if that value equals equals Padma, let's go ahead with this if statement

309
00:14:57,750 --> 00:14:58,666
并做出改变 
and make a change.

310
00:14:58,666 --> 00:15:02,208
让我们更改学生的[1]值 
Let's change the student's [1] value.

311
00:15:02,208 --> 00:15:04,625
所以第二个值 如果我们是零索引--
So the second value, if we're zero indexing--

312
00:15:04,625 --> 00:15:07,375
让我们把它变成哈利波特世界里的另一座房子
let's change it to be another house in the world of Harry Potter

313
00:15:07,375 --> 00:15:08,916
叫拉文克劳 
called Ravenclaw.

314
00:15:08,916 --> 00:15:11,750
所以我只是在修复可能是用户的输入 
So I'm just fixing maybe the user's input.

315
00:15:11,750 --> 00:15:14,166
他们看了这部电影 然后输入帕德玛·格兰芬多 
They watched the movie so they type in Padma Gryffindor,

316
00:15:14,166 --> 00:15:17,333
但是 嗯 在书里 是拉文克劳的帕德玛 
but, mm-mm, in the books, it was Padma from Ravenclaw.

317
00:15:17,333 --> 00:15:20,250
好了 让我继续下去 到我的终端窗口 
All right, let me go ahead and go down to my terminal window,

318
00:15:20,250 --> 00:15:24,041
清除我的终端 然后执行Student.py的Python 回车 
clear my terminal, and do Python of student.py, Enter.

319
00:15:24,041 --> 00:15:27,000
我会像格兰芬多一样模仿哈里 只是为了证明
I'm going to do Harry as well as Gryffindor, just to demonstrate

320
00:15:27,000 --> 00:15:29,750
这一点仍在发挥预期的作用 
that that is still working as intended.

321
00:15:29,750 --> 00:15:33,958
不过 让我再次清除屏幕 并在Padma上运行PYSTONT.PY 
Let me clear my screen again, though, and run Python of student.py on Padma,

322
00:15:33,958 --> 00:15:37,500
我也会把她放进格兰芬多 就像电影里的那样 然后按Enter键 
and I'll put her, too, in Gryffindor, as in the movies, and hit Enter.

323
00:15:37,500 --> 00:15:40,916
现在我只在屏幕上看到一大堆错误 
And now I just see a big mess of errors on the screen.

324
00:15:40,916 --> 00:15:42,708
已经抛出了某种例外 
Some kind of exception has been thrown.

325
00:15:42,708 --> 00:15:45,166
事实上 确实发生了一个类型错误 
And indeed, a type error has happened.

326
00:15:45,166 --> 00:15:48,750
我使用的数据类型中存在错误 错误是什么？
I'm using a data type wherein there's an error, and what is that error?

327
00:15:48,750 --> 00:15:53,041
嗯 “tuple”对象不支持项赋值 
Well, 'tuple' object does not support item assignment.

328
00:15:53,041 --> 00:15:57,375
它有点神秘莫测--也就是说 它对用户并不是很友好 
It's a little arcanely expressed-- that is, it's not really very user friendly.

329
00:15:57,375 --> 00:15:59,250
但如果你想一想这些话的意思 
But if you think about what those words mean,

330
00:15:59,250 --> 00:16:01,458
“tuple”对象不支持项分配 
'tuple" object does not support item assignment.

331
00:16:01,458 --> 00:16:03,458
所以作业是从右到左复制的 
So assignment is copying from right to left.

332
00:16:03,458 --> 00:16:05,208
因此 不知何故 这是无效的 
So somehow, that's invalid.

333
00:16:05,208 --> 00:16:10,250
这是元组的不变性的一个表现 
And here is a manifestation of the immutability of tuples.

334
00:16:10,250 --> 00:16:14,208
您不能更改位置0或1或内部的任何内容 
You cannot change location 0 or 1 or anything inside.

335
00:16:14,208 --> 00:16:15,250
这是一个特点 
That is a feature.

336
00:16:15,250 --> 00:16:17,250
这就是元组的设计 
That is the design of a tuple.

337
00:16:17,250 --> 00:16:20,000
所以如果我想推翻这一点 我想我是
So if I want to override that, I think I'm

338
00:16:20,000 --> 00:16:23,125
我们将不得不使用我们以前使用过的不同类型的数据--
going to have to use a different type of data that we've used before--

339
00:16:23,125 --> 00:16:24,750
也就是一份清单 这很好 
namely a list, and that's fine.

340
00:16:24,750 --> 00:16:28,416
如果您想让您自己和同事能够使用您的代码
If you want to enable yourself and colleagues using your code

341
00:16:28,416 --> 00:16:31,083
要更改该容器中的内容物 
to change the contents of that container,

342
00:16:31,083 --> 00:16:34,375
好的 我们可以继续使用返回不是元组
well, we can go ahead and return not a tuple using

343
00:16:34,375 --> 00:16:37,541
明确的圆括号或没有圆括号 只有逗号 
explicit parentheses or no parentheses, just the comma,

344
00:16:37,541 --> 00:16:39,250
但我可以使用方括号 
but I can use square brackets.

345
00:16:39,250 --> 00:16:41,916
如果我在左边和右边用方括号 
And if I'm using square brackets on the left and the right,

346
00:16:41,916 --> 00:16:44,458
这确实是一份明确的清单 
this is indeed explicitly a list.

347
00:16:44,458 --> 00:16:47,041
想法相同 但它是可变的 
Same idea, but it's mutable.

348
00:16:47,041 --> 00:16:50,000
也就是说 您可以更改列表的内容 
That is to say you can change the contents of a list.

349
00:16:50,000 --> 00:16:53,125
所以不做其他更改 只返回一个列表
So making no other changes, just returning a list

350
00:16:53,125 --> 00:16:57,833
使用方括号 而不是使用圆括号或仅使用逗号的元组 
with square brackets instead of a tuple with parentheses or just the comma.

351
00:16:57,833 --> 00:17:01,041
现在让我继续运行PYTHON of Student.py Enter 
Let me go ahead now and run Python of student.py, Enter.

352
00:17:01,041 --> 00:17:04,000
让我再输入一次哈利和格兰芬多 
Let me type in Harry and Gryffindor again.

353
00:17:04,000 --> 00:17:05,458
这还在起作用 
That's still working.

354
00:17:05,458 --> 00:17:06,416
很高兴见到你 
Good to see.

355
00:17:06,416 --> 00:17:11,416
让我再运行一次 输入帕德玛和格兰芬多 就像电影里那样 
Let me run this once more and type in Padma and Gryffindor, as in the movies,

356
00:17:11,416 --> 00:17:15,333
但现在我们更正为拉文克劳的帕德玛
but no, now we've corrected it to be Padma from Ravenclaw,

357
00:17:15,333 --> 00:17:17,958
就像书上写的那样
as in the books instead.

358
00:17:17,958 --> 00:17:22,541
关于元组和列表或者这个想法还有什么问题吗
Any questions now on tuples versus lists or this idea

359
00:17:22,541 --> 00:17:26,541
不变性与可变性的对比
of immutability versus mutability.

360
00:17:26,541 --> 00:17:31,833
观众：我们可以在Python中使用嵌套元组吗 比如嵌套列表？
AUDIENCE: Can we use a nested tuple in Python, like a nest list?

361
00:17:31,833 --> 00:17:32,958
大卫·J·马兰：当然 
DAVID J. MALAN: Absolutely.

362
00:17:32,958 --> 00:17:35,250
Python中不仅可以有嵌套列表 
You can have not only nested lists in Python,

363
00:17:35,250 --> 00:17:38,291
其中一个列表中的元素可以是另一个列表 
where one of the elements in a list could be another list-- so you

364
00:17:38,291 --> 00:17:41,500
这里有一些方括号 你可能会有一些其他的方括号
have some square brackets out here; you might have some other square brackets

365
00:17:41,500 --> 00:17:42,041
里面
inside.

366
00:17:42,041 --> 00:17:44,833
你完全可以用一个元组做同样的事情 
You can absolutely do the same with a tuple as well.

367
00:17:44,833 --> 00:17:47,833
对于可以放入的值的类型没有限制 
There is no constraint on the types of values you can put in there.

368
00:17:47,833 --> 00:17:50,125
我们在这件事上还没有这样做的机会 
We've not had occasion to do that in this case.

369
00:17:50,125 --> 00:17:54,041
我只是返回一个包含两个元素的简单元组 
I'm just returning a simple tuple with two elements.

370
00:17:54,041 --> 00:17:56,291
但是 是的 你绝对可以这样做 太 
But yes, you could absolutely do that, too.

371
00:17:56,291 --> 00:17:59,416
关于元组和列表的其他问题？
Other questions on tuples versus lists?

372
00:17:59,416 --> 00:18:03,208
观众：好的 举个例子 当我看到方括号时 
AUDIENCE: OK, for example, when I see the square brackets,

373
00:18:03,208 --> 00:18:05,250
主要用于名单？
is it mainly used for the list?

374
00:18:05,250 --> 00:18:07,041
大卫·J·马兰：哦 一个很好的问题 
DAVID J. MALAN: Oh, a really good question.

375
00:18:07,041 --> 00:18:07,875
算是吧
Sort of.

376
00:18:07,875 --> 00:18:12,250
所以当你创建一个像列表这样的值时 你要用方括号 
So when you create a value like a list, you use square brackets,

377
00:18:12,250 --> 00:18:14,041
这确实是一个视觉指示器
and that would indeed be a visual indicator

378
00:18:14,041 --> 00:18:16,458
这绝对是一份名单
that this is definitely a list.

379
00:18:16,458 --> 00:18:19,041
如果你看到的是圆括号 那是一个视觉指示器 
If you instead see parentheses, that's a visual indicator,

380
00:18:19,041 --> 00:18:21,708
当创建一个值时 它肯定是一个元组 
when creating a value, that it's definitely a tuple.

381
00:18:21,708 --> 00:18:26,416
然而 有点令人困惑的是 列表和元组都
However, somewhat confusingly, both lists and tuples

382
00:18:26,416 --> 00:18:30,375
在访问它们的内容时使用方括号 
use square brackets when you access the contents of them.

383
00:18:30,375 --> 00:18:34,000
当你在位置0或位置1索引它们时
When you index into them at location 0 or location 1

384
00:18:34,000 --> 00:18:36,083
你总是用方括号 
you always use square brackets.

385
00:18:36,083 --> 00:18:37,500
这就是区别 
So that's the distinction there.

386
00:18:37,500 --> 00:18:38,875
问得好
Good question.

387
00:18:38,875 --> 00:18:42,916
如果可以的话 请允许我提议 我们用另一种方式解决这个问题 
Allow me to propose now, if I may, that we solve this problem yet another way,

388
00:18:42,916 --> 00:18:46,250
看看我们是在让事情变得更好还是更糟
and let's see if we're either making things better or for worse than us.

389
00:18:46,250 --> 00:18:49,916
回想一下 字典或dict对象也存在于Python中 
Recall that dictionaries, or dict objects, also exist in Python.

390
00:18:49,916 --> 00:18:53,250
字典就是键和值的集合 
And a dictionary is this collection of keys and values.

391
00:18:53,250 --> 00:18:55,458
尤其是字典的好处是
And the upside, in particular, of a dictionary

392
00:18:55,458 --> 00:18:57,083
就是它们有更好的语义 
is that they have better semantics.

393
00:18:57,083 --> 00:18:59,625
你不需要假设一个名字总是
You don't just have to assume that a name is always

394
00:18:59,625 --> 00:19:03,291
将位于位置0；房屋将始终位于位置1 
going to be at location 0; house is always going to be at location 1.

395
00:19:03,291 --> 00:19:06,916
这就是那种事情 特别是如果你有三个、四个或更多的价值观--
That's the kind of thing, especially if you had three, four, or more values--

396
00:19:06,916 --> 00:19:10,000
最终 你或某人将会迷惑并忘记
eventually you or someone is going to get confused and forget

397
00:19:10,000 --> 00:19:12,958
命令是什么 您将编写有错误的代码 
what the order is and you're going to write buggy code.

398
00:19:12,958 --> 00:19:15,333
所以词典的功能更强大一点
So a dictionary is a little more powerful

399
00:19:15,333 --> 00:19:19,000
因为您可以在语义上关联关键字、小描述
in that you can semantically associate keys, little descriptions,

400
00:19:19,000 --> 00:19:20,041
有了这些价值观--
with the values--

401
00:19:20,041 --> 00:19:22,541
分别是那些键和那些值 
those keys and those values, respectively.

402
00:19:22,541 --> 00:19:25,666
所以让我继续这样做 我们可以用几种不同的方式来做这件事 
So let me go ahead and do this, and we can do this in a few different ways.

403
00:19:25,666 --> 00:19:28,958
但让我建议我们在这里重点关注Get_Student 
But let me propose that we focus on get_student here .

404
00:19:28,958 --> 00:19:30,583
让我们继续做这件事 
And let's go ahead and do this.

405
00:19:30,583 --> 00:19:35,875
让我们继续 按原样删除Get_Student的实现 
Let me go ahead and delete the implementation of get_student as is.

406
00:19:35,875 --> 00:19:40,083
让我创建一个学生变量 并将其初始化为空词典 
Let me create a student variable and initialize it to an empty dictionary.

407
00:19:40,083 --> 00:19:43,083
我只需要两个花括号就可以做到这一点 
And I can do that with just two curly braces here.

408
00:19:43,083 --> 00:19:46,958
然后让我继续 在词典中设置两个键 
And then let me go ahead and set two keys inside of that dictionary.

409
00:19:46,958 --> 00:19:49,708
在学生体内 将会有一个“名字” 
Inside of the student, there will be, quote unquote, a "name"

410
00:19:49,708 --> 00:19:53,625
键 它的值将是输入的返回值
key, and the value of that is going to be whatever the return value of input

411
00:19:53,625 --> 00:19:55,625
是当我提示用户输入他们的名字时 
is when I prompt the user for their name.

412
00:19:55,625 --> 00:19:59,708
然后是同一本学生词典里的“房子”钥匙 
And then the "house" key, inside of that same student dictionary,

413
00:19:59,708 --> 00:20:02,750
将是用户键入的任何内容的返回值
is going to be the return value of whatever the user types

414
00:20:02,750 --> 00:20:07,000
为他们的房子买单  最后 我要继续下去 把学生送回来 
in for their house. , And lastly I'm going to go ahead and return student.

415
00:20:07,000 --> 00:20:11,000
所以现在我还是要退回一样东西 
So now I am literally returning one thing, still,

416
00:20:11,000 --> 00:20:15,291
但这一次 它是一个词典而不是一个元组 而不是一个列表 
but this time, it's a dict rather than a tuple, rather than a list.

417
00:20:15,291 --> 00:20:18,041
但这里面还是有两样东西 严格来说有四样东西
But there are still two things in it, technically four things

418
00:20:18,041 --> 00:20:19,708
如果你计算一下键和值 
if you count the keys and the values.

419
00:20:19,708 --> 00:20:22,083
但是有两个键值对 
But there's two key value pairs.

420
00:20:22,083 --> 00:20:24,625
现在 我这里的代码将不得不稍作更改 
Now, my code up here is going to have to change a little bit.

421
00:20:24,625 --> 00:20:27,375
让我们简化这一点 例如 现在删除
And let's simplify this and remove, for instance, now

422
00:20:27,375 --> 00:20:31,458
Padma IF声明只是为了关注手头正在发生的变化 
the Padma if statement just to focus on what's changing at hand.

423
00:20:31,458 --> 00:20:34,000
现在让我继续 让2号线单独运行 
And let me go ahead now and leave line 2 alone.

424
00:20:34,000 --> 00:20:37,708
我仍然会有一个学生变量 该变量被赋值为返回
I'm still going to have a student variable that gets assigned the return

425
00:20:37,708 --> 00:20:39,166
Get_Student的值 
value of get_student.

426
00:20:39,166 --> 00:20:45,375
但我现在想要做的是实际访问其中的密钥
But what I want to do here now is actually access the keys inside of that

427
00:20:45,375 --> 00:20:49,083
字典--不是按元组和列表的数字索引--
dictionary-- not by numeric index, which was for tuples and lists--

428
00:20:49,083 --> 00:20:52,541
0和1 但通过密钥的方式 
0 and 1, but by way of the keys.

429
00:20:52,541 --> 00:20:55,291
现在 正常情况下 我可能有这个习惯 因为我个人
Now, normally, I might be in the habit, as I personally

430
00:20:55,291 --> 00:20:58,916
AM 使用双引号--引号 不引号 “名字”在里面
am, of using double quotes-- quote, unquote, "name" inside of there

431
00:20:58,916 --> 00:21:02,166
引用 引述 “房子”在里面 
and quote, unquote, "house" inside of there.

432
00:21:02,166 --> 00:21:05,833
但在我运行这段代码并向你们展示一个错误之前--
But before I even run this code and show you a mistake--

433
00:21:05,833 --> 00:21:08,750
看到屏幕上的错误 有谁想喊出来吗
see an error on the screen, does anyone want to call out

434
00:21:08,750 --> 00:21:10,666
我在这里做错了什么？
what I have done wrong here?

435
00:21:10,666 --> 00:21:12,375
这只是一根f弦 
This is just an f string.

436
00:21:12,375 --> 00:21:16,708
我只想打印出名字键的值 房子的价值
I just want to print out the value of the name key, the value of the house

437
00:21:16,708 --> 00:21:18,666
输入这本词典 
key in this dictionary.

438
00:21:18,666 --> 00:21:21,083
观众：[听不见]
AUDIENCE: [INAUDIBLE]

439
00:21:21,333 --> 00:21:23,625
大卫·J·马兰：你的音频对我们来说有点乱码 
DAVID J. MALAN: Your audio was a little garbled for us.

440
00:21:23,625 --> 00:21:26,250
但我想我听到了双引号和单引号 
But I think I heard double quotes and single quotes.

441
00:21:26,250 --> 00:21:29,708
所以我假设 确实 你已经准确地确定了问题所在 
So I'm going to assume that, indeed, you've identified precisely the issue.

442
00:21:29,708 --> 00:21:31,541
我现在只是要混淆一下Python 
I'm just going to confuse Python right now.

443
00:21:31,541 --> 00:21:35,833
即使这是双引号内的f字符串 以f为前缀 
Even though this is an f string inside of double quotes, prefixed with an f,

444
00:21:35,833 --> 00:21:39,000
我不能在我的双引号中使用双引号
I can't actually use my double quotes inside my double quotes

445
00:21:39,000 --> 00:21:41,125
因为这可能会让Python感到困惑 
because that's going to potentially confuse Python.

446
00:21:41,125 --> 00:21:44,375
如果我现在运行这个程序 那么Student.py的Python和点击
If I run this program now, Python of student.py and hit

447
00:21:44,375 --> 00:21:46,166
回车 我得到一个语法错误 
Enter, I get a syntax error.

448
00:21:46,166 --> 00:21:48,000
因此 该程序甚至没有完全运行 
So the program didn't even run fully.

449
00:21:48,000 --> 00:21:51,958
它只是无法理解 因为它被那些双引号搞糊涂了 
It just couldn't be understood because it got confused by those double quotes.

450
00:21:51,958 --> 00:21:54,041
所以这里最简单的解决办法就是
So the simplest fix here would indeed just

451
00:21:54,041 --> 00:21:58,250
不是用双引号而是用单引号将键引起来 
be to use not double quotes but single quotes around the keys,

452
00:21:58,250 --> 00:22:02,041
或者相反 将外部的双引号改为单引号 
or conversely, flip the double quotes on the outside to single quotes,

453
00:22:02,041 --> 00:22:03,583
然后在内部使用双引号 
then use double quotes in the inside.

454
00:22:03,583 --> 00:22:05,125
你只想保持一致 
You just want to be consistent.

455
00:22:05,125 --> 00:22:09,041
这是一个微妙的细节 但同样 这是特定于词典语法的 
So a subtle detail, but again, this is now specific to dictionary syntax.

456
00:22:09,041 --> 00:22:14,666
这并不是我们如何解决当前问题的根本 
This isn't fundamental to how we're solving this current problem at hand.

457
00:22:14,666 --> 00:22:16,083
好吧 让我们来试试这个 
Well, let's go ahead and try this.

458
00:22:16,083 --> 00:22:18,416
现在让我继续运行Student.py的Python 
Let me go ahead now and run Python of student.py.

459
00:22:18,416 --> 00:22:19,833
让我们继续输入哈里 
Let's go ahead and type in Harry.

460
00:22:19,833 --> 00:22:20,916
让我们输入格兰芬多 
Let's type in Gryffindor.

461
00:22:20,916 --> 00:22:24,083
希望哈里能从格兰芬多回来 
And hopefully, Harry is back from Gryffindor.

462
00:22:24,083 --> 00:22:25,375
没有语法错误 
No syntax errors.

463
00:22:25,375 --> 00:22:26,250
没有其他错误 
No other errors.

464
00:22:26,250 --> 00:22:28,000
我想我又回来做生意了 
I think I'm back in business here.

465
00:22:28,000 --> 00:22:31,125
关于使用词典 我想明确的是
And what I do like to be clear about using a dictionary

466
00:22:31,125 --> 00:22:34,000
它让我获得了更好的语义 
is that it's allowing me just better semantics.

467
00:22:34,000 --> 00:22:38,958
再说一次 我不需要记住 记住 文件 0是名字；
And again, I don't have to remember, memorize, document that 0 is name;

468
00:22:38,958 --> 00:22:40,166
1是House 
1 is house.

469
00:22:40,166 --> 00:22:43,291
相反 “name”是名字 “house”是house 
Instead, "name" is name and "house" is house.

470
00:22:43,291 --> 00:22:45,500
它只是更清晰一点 更有表现力一点 
It's just a little clearer, a little more expressive.

471
00:22:45,500 --> 00:22:49,250
因此 这通常是一件好事 特别是如果我们存储了更多关于
So that's generally a good thing, especially if we stored more data about

472
00:22:49,250 --> 00:22:53,000
学生不仅仅是他们的名字和他们的房子--如果你有三个领域 四个 
students than just their name and their house-- if you had three fields, four,

473
00:22:53,000 --> 00:22:54,625
五到十个不同的领域--
five, 10 different fields--

474
00:22:54,625 --> 00:22:58,875
没有人会想要记住或能够永远记住这是零
no one's going to want to remember or be able to remember forever which is zero

475
00:22:58,875 --> 00:23:00,625
这是1 这是2 以此类推 
which is 1, which is 2, and so forth.

476
00:23:00,625 --> 00:23:04,958
最好引入名字 比如本例中的“name”和“house” 
Better to introduce names, like "name" and "house" in this case.

477
00:23:04,958 --> 00:23:07,125
但让我进一步收紧这一点 
But let me tighten this up further.

478
00:23:07,125 --> 00:23:10,541
我通常习惯于不引入不必要的变量 
I'm typically in the habit of not introducing variables unnecessarily,

479
00:23:10,541 --> 00:23:12,250
除非它们使代码更具可读性 
unless they make the code more readable.

480
00:23:12,250 --> 00:23:15,958
格式化相同代码的另一种方法是这样 
And an alternative way to format the same code would be this.

481
00:23:15,958 --> 00:23:19,333
严格地说 我不需要创建一本空词典 
Strictly speaking, I don't need to create an empty dictionary,

482
00:23:19,333 --> 00:23:23,375
然后给它添加一个密钥 然后给它添加第二个密钥 
then add one key to it, then add a second key to it,

483
00:23:23,375 --> 00:23:25,375
然后把那本词典还给我 
and then return that dictionary.

484
00:23:25,375 --> 00:23:29,458
如果你愿意的话 我可以把这一切归结为一份声明 
I can actually consolidate this all into one statement, if you will.

485
00:23:29,458 --> 00:23:30,958
让我继续做这件事 
Let me go ahead and do this.

486
00:23:30,958 --> 00:23:35,458
让我继续说 名称等于输入返回值 
Let me go ahead and say name equals inputs return value,

487
00:23:35,458 --> 00:23:38,583
House等于输入返回值 然后 
house equals inputs return value, and then,

488
00:23:38,583 --> 00:23:41,666
而不是返回任何变量名学生 这是我要建议的
instead of returning any variable name student, which I'm going to propose

489
00:23:41,666 --> 00:23:44,208
不需要再存在了 让我来创造
doesn't need to exist anymore, let me just create

490
00:23:44,208 --> 00:23:46,416
然后一次把词典全部归还 
and return the dictionary all at once.

491
00:23:46,416 --> 00:23:50,458
让我这样做 引用 不引用 这里用小写的“name” 然后是变量 
Let me do, quote, unquote, "name" in lowercase here, and then the variable.

492
00:23:50,458 --> 00:23:52,041
它存储用户的姓名 
It's storing the user's name.

493
00:23:52,041 --> 00:23:55,208
然后 引用 不引用 “house”作为我的第二个密钥 它的价值
Then, quote, unquote, "house," as my second key, the value of which

494
00:23:55,208 --> 00:23:57,083
将会是House 这个变量 
is going to be house, the variable.

495
00:23:57,083 --> 00:23:58,166
现在 这是不是更好了？
Now, is this better?

496
00:23:58,166 --> 00:23:59,000
可能会 也可能不会 
Maybe, maybe not.

497
00:23:59,000 --> 00:24:00,958
也许第一种方法更具可读性 
Maybe the first way was a little more readable,

498
00:24:00,958 --> 00:24:03,416
这完全可以用来制造变量
and that's totally fine to create variables

499
00:24:03,416 --> 00:24:05,833
如果它们提高了代码的可读性 
if they improve the readability of your code.

500
00:24:05,833 --> 00:24:09,833
但要知道 您还可以即时创建和返回词典
But just know that you can also create and return a dictionary on the fly

501
00:24:09,833 --> 00:24:12,208
像这样 可以说 都在一行里 而我
like this, so to speak, all in one line, and I

502
00:24:12,208 --> 00:24:14,333
我认为在这种情况下 这是相当合理的 
think it's arguably pretty reasonable in this case.

503
00:24:14,333 --> 00:24:14,875
为什么？
Why?

504
00:24:14,875 --> 00:24:16,083
就是太短了 
It's just pretty short.

505
00:24:16,083 --> 00:24:18,875
如果它变得越来越长 我可能不会这么做 
I probably wouldn't do this if it got longer and longer and longer.

506
00:24:18,875 --> 00:24:22,583
然后 我至少可以开始将我的键值对移动到不同的行 
I might minimally then start moving my key value pairs to separate lines.

507
00:24:22,583 --> 00:24:27,458
但这也只是一种稍微更紧凑的方式 
But this would just be a slightly more compact way of doing this as well.

508
00:24:27,458 --> 00:24:29,375
但让我提议我们再做一次改变 
But let me propose we do one more change.

509
00:24:29,375 --> 00:24:32,958
让我们继续介绍Padma相同特殊外壳
Let's go ahead and introduce that same special casing of Padma

510
00:24:32,958 --> 00:24:36,458
例如 为了修缮她从格兰芬多到拉文克劳的房子 
to fix her house from Gryffindor, for instance, to Ravenclaw.

511
00:24:36,458 --> 00:24:38,250
我们如何用词典做到这一点呢？
How do we do this with dictionaries?

512
00:24:38,250 --> 00:24:41,625
词典和列表一样 都是可变的 
Well, dictionaries, like lists, are mutable.

513
00:24:41,625 --> 00:24:45,416
您可以更改它们中的内容 就像您可以列出列表一样 
You can change what is in them, just like you can lists.

514
00:24:45,416 --> 00:24:46,250
你怎么做到的？
How do you do that?

515
00:24:46,250 --> 00:24:48,041
只是在句法上有一点不同 
It's just a little different syntactically.

516
00:24:48,041 --> 00:24:50,291
因此 让我们返回到Main并进行此修复 
So let's go back into main and do this fix.

517
00:24:50,291 --> 00:24:57,708
如果学生变量有一个等于Padma的名称键 那么 
If the student variable has a name key that equals equals Padma, then,

518
00:24:57,708 --> 00:25:04,375
缩进 继续并更改该学生体内的房屋钥匙的值
indented, go ahead and change the value of the house key inside of that student

519
00:25:04,375 --> 00:25:08,666
词典改为 引用 不引用 取而代之的是“RavenClaw” 
dictionary to be, quote, unquote, "Ravenclaw" instead.

520
00:25:08,666 --> 00:25:11,416
在精神上与我们用清单做的事情非常相似 
So very similar in spirit to what we did with a list.

521
00:25:11,416 --> 00:25:16,250
但我们没有使用位置0和1 而是更清楚、更明确地说 
But instead of using location 0 and 1, we're much more clearly, explicitly,

522
00:25:16,250 --> 00:25:19,375
语义上使用 引号 不引号 “名字”和 引号 不引号 
semantically using, quote, unquote, "name" and, quote, unquote,

523
00:25:19,375 --> 00:25:24,250
“house” 因为您使用数字来索引列表和元组 但您是在索引
"house," because you index into lists and tuples using numbers, but you index

524
00:25:24,250 --> 00:25:27,916
变成使用字符串的词典 就像我在这里所做的那样 
into dictionaries using strings, as I've done here.

525
00:25:27,916 --> 00:25:31,250
好的 让我继续运行PYTHON of Student.py 
All right, let me go ahead and run Python of student.py.

526
00:25:31,250 --> 00:25:33,208
我们再来一次《格兰芬多》中的哈利 
We'll again do Harry from Gryffindor.

527
00:25:33,208 --> 00:25:35,125
我认为一切都很好 
And I think all is well.

528
00:25:35,125 --> 00:25:38,708
让我再说一次 这一次是帕德玛 在电影中 
Let me run it one more time this time with Padma, who, in the movies,

529
00:25:38,708 --> 00:25:43,375
来自格兰芬多 但实际上应该来自拉文克劳 
is from Gryffindor, but should really be from Ravenclaw.

530
00:25:43,375 --> 00:25:49,250
那么 在从元组到列表再到词典的过程中 还有什么问题吗？
Any questions then on this progression from tuples to lists to dictionaries?

531
00:25:49,250 --> 00:25:53,458
除了这些元组之外 我们没有必要引入任何新的东西 
We haven't necessarily introduced anything new, other than those tuples,

532
00:25:53,458 --> 00:25:56,250
在这段时间里 我们一直都能得到 
which have been available to us all this time.

533
00:25:56,250 --> 00:26:00,000
但目前的目标只是为了证明这一区别
But the goal at the moment is just to demonstrate this distinction

534
00:26:00,000 --> 00:26:02,250
在这些不同的数据类型中以及它们如何
among these different data types and how they

535
00:26:02,250 --> 00:26:04,333
每种方法的工作原理都略有不同 
each work a little bit differently.

536
00:26:04,333 --> 00:26:10,416
观众：如果我们的元组中有列表的组合呢？
AUDIENCE: What if a combination of lists is there in our tuple?

537
00:26:10,416 --> 00:26:16,125
我们可以改变列表 因为列表是不变的 但是列表是可变的？
We can change the list because are immutable but lists are mutable?

538
00:26:16,125 --> 00:26:17,125
大卫·J·马兰：正确 
DAVID J. MALAN: Correct.

539
00:26:17,125 --> 00:26:19,291
您可以更改列表的内容 并且您可以
You can change the contents of lists, and you

540
00:26:19,291 --> 00:26:23,125
几乎可以放任何你想要的东西--其他的列表或字符串 就像我做的那样 
can put most anything you want in them-- other lists or strings, as I've done,

541
00:26:23,125 --> 00:26:24,583
整数或其他任何值 
integers, or anything else.

542
00:26:24,583 --> 00:26:27,916
元组您可以执行完全相同的操作 但不能一次更改它们
Tuples you can do the exact same thing, but you cannot change them once

543
00:26:27,916 --> 00:26:29,083
是你创造了它们 
you've created them.

544
00:26:29,083 --> 00:26:33,041
字典更像是一个列表 因为它是可变的 
A dictionary is more like a list in that it is mutable.

545
00:26:33,041 --> 00:26:34,208
你可以改变的 
You can change it.

546
00:26:34,208 --> 00:26:37,583
但是你索引词典的方式是
But the way you index into a dictionary is

547
00:26:37,583 --> 00:26:40,541
通过这些钥匙 这些弦 就像我们一直说的 
by way of these keys, these strings, as we keep saying,

548
00:26:40,541 --> 00:26:42,250
而不是通过数字--
rather than by numbers--

549
00:26:42,250 --> 00:26:45,083
那些数字索引 
those numeric indices.

550
00:26:45,083 --> 00:26:47,875
好吧 好吧 让我来提议一下
All right, well, let me propose that there is yet

551
00:26:47,875 --> 00:26:50,458
解决这个问题的另一种方法 
another way of solving this problem.

552
00:26:50,458 --> 00:26:53,875
我会争辩说 现在有一个机会近在眼前 
And I would argue that there's now an opportunity at hand.

553
00:26:53,875 --> 00:26:56,750
尽管这个程序并不是特别复杂--
Even though this program isn't particularly complicated--

554
00:26:56,750 --> 00:27:01,208
我所要做的就是从用户和房子中收集一个名字
all I'm doing is collecting a name from the user and a house

555
00:27:01,208 --> 00:27:03,166
从用户那里--你可以想象想要 
from the user-- you could imagine wanting,

556
00:27:03,166 --> 00:27:05,291
从长远来看 为了收集更多的信息 
longer term, to collect even more information,

557
00:27:05,291 --> 00:27:07,791
就像学生的守护神或魔咒
like the student's patronus or magical spell

558
00:27:07,791 --> 00:27:10,666
或者一大堆其他可能属于学生的信息 
or a whole bunch of other information that might belong in a student.

559
00:27:10,666 --> 00:27:15,291
现在 我们只是使用这些非常通用的数据
And right now, we're just using these very general purpose data

560
00:27:15,291 --> 00:27:16,458
Python中的类型--
types in Python--

561
00:27:16,458 --> 00:27:20,083
用于将一些值组合在一起的元组；用于执行相同操作的列表 
a tuple to combine some values together; a list to do the same,

562
00:27:20,083 --> 00:27:23,625
但让我们以后再改吧；字典 它更强大
but let us change it later; a dictionary, which is more powerful

563
00:27:23,625 --> 00:27:25,250
因为它更有条理一些 
because it's a little more structured.

564
00:27:25,250 --> 00:27:28,708
它确实有钥匙 而且它有价值 而不仅仅是价值 
It does have keys, and it has values, not just values.

565
00:27:28,708 --> 00:27:30,250
但是你知道吗？
But you know what?

566
00:27:30,250 --> 00:27:33,500
如果Python的作者 我们就不必进行这次对话
We wouldn't have to be having this conversation if the authors of Python

567
00:27:33,500 --> 00:27:37,125
刚刚给我们提供了一个名为Student的数据类型 
had just given us a data type called student.

568
00:27:37,125 --> 00:27:39,000
如果能有一个
Wouldn't it have been nice if there were just

569
00:27:39,000 --> 00:27:42,166
我可以在代码中创建一种变量 叫做student？
a type of variable I could create in my code called student?

570
00:27:42,166 --> 00:27:43,916
那我们就不用搞清楚
Then we wouldn't have to figure out, well,

571
00:27:43,916 --> 00:27:46,416
我们是用元组 列表还是字典
do we use a tuple or a list or a dictionary?

572
00:27:46,416 --> 00:27:48,333
但这也很合理 
But that's pretty reasonable.

573
00:27:48,333 --> 00:27:52,166
你可以想象这是一个多么滑的斜坡 可以这么说 
You can imagine just how slippery of a slope that is, so to speak,

574
00:27:52,166 --> 00:27:55,166
如果一种语言的创造者必须预见到
if the creators of a language had to anticipate

575
00:27:55,166 --> 00:27:58,250
所有可能的数据类型 
all the possible types of data that programmers like you

576
00:27:58,250 --> 00:28:00,375
我想把它存储在你的程序里
and me want to store in your programs.

577
00:28:00,375 --> 00:28:02,875
所以他们只是给了我们这些通用工具 
So they just gave us these general purpose tools.

578
00:28:02,875 --> 00:28:05,750
但他们给了我们另一个通用工具
But they gave us another general purpose tool

579
00:28:05,750 --> 00:28:09,375
这也将允许我们创建自己的数据类型
that's going to allow us to create our own data types as well

580
00:28:09,375 --> 00:28:14,291
并给它们起名字 这个术语就是一个类 
and actually give them names, and that terminology is a class.

581
00:28:14,291 --> 00:28:20,125
类就像是数据对象片段的蓝图 
A class is like a blueprint for pieces of data objects.

582
00:28:20,125 --> 00:28:24,166
类是一个你可以定义和命名的模型 
A class is a mold that you can define and give a name.

583
00:28:24,166 --> 00:28:26,875
当你用那个模型或者蓝图的时候 
And when you use that mold or you use that blueprint,

584
00:28:26,875 --> 00:28:31,000
你得到的数据类型完全是你想要的 
you get types of data that are designed exactly as you want.

585
00:28:31,000 --> 00:28:36,208
所以简而言之 类允许您在Python中发明自己的数据类型
So in short, classes allow you to invent your own data types in Python

586
00:28:36,208 --> 00:28:37,375
给他们起个名字
and give them a name.

587
00:28:37,375 --> 00:28:41,291
这是面向对象编程的主要特征 
And this is a primary feature of object oriented programming,

588
00:28:41,291 --> 00:28:44,041
能够以这种方式创建自己的对象
to be able to create your own objects in this way

589
00:28:44,041 --> 00:28:48,291
而且 对于Python中的类 甚至可以给它们一些自定义的名称 
and, in the case of Python in classes, even give them some custom names.

590
00:28:48,291 --> 00:28:50,333
那么 这在实际意义上意味着什么呢？
So what does this mean in real terms?

591
00:28:50,333 --> 00:28:52,375
好吧 让我继续 
Well, let me go ahead and come back to VS Code

592
00:28:52,375 --> 00:28:56,500
这里 让我建议我们引入一点新的语法 
here, and let me propose that we introduce a little bit of new syntax.

593
00:28:56,500 --> 00:28:58,916
我要先清空我的终端窗口 
I'm going to go ahead and clear my terminal window first.

594
00:28:58,916 --> 00:29:02,791
我要翻到我的档案的最上面 我只是要开始一个想法 
I'm going to go to the top of my file, and I'm just going to start a thought

595
00:29:02,791 --> 00:29:03,916
但还没完成
but not finish it yet.

596
00:29:03,916 --> 00:29:09,083
我将使用这个新的关键字来表示类 字面上叫做class 
I'm going to use this new keyword for classes, called, literally, class,

597
00:29:09,083 --> 00:29:11,708
所以我们要用新的关键词
so the new keyword we're going to have here.

598
00:29:11,708 --> 00:29:13,916
如果我回到我们的幻灯片 
And if I go back to our slides here, this

599
00:29:13,916 --> 00:29:16,083
将是官方网址 你可以阅读更多
would be the official URL where you can read up more

600
00:29:16,083 --> 00:29:18,000
Python的这个特性 
on this particular feature of Python.

601
00:29:18,000 --> 00:29:22,083
在官方教程中 class是我们可以使用的新关键字 
In the official tutorial, class is a new keyword we can use.

602
00:29:22,083 --> 00:29:25,500
现在 巧合的是 这与学生有关 因为学生上课 
Now, this is coincidentally related to students because students take classes,

603
00:29:25,500 --> 00:29:28,500
但这与我们正在与学生打交道的事实无关 
but it has nothing to do with the fact that we're dealing with students.

604
00:29:28,500 --> 00:29:31,791
类在许多语言中是一个通用术语--
Class is a general purpose term in a lot of languages--

605
00:29:31,791 --> 00:29:35,500
其中就有Python 它允许您定义这些定制容器
Python among them-- that allow you to define these custom containers

606
00:29:35,500 --> 00:29:38,625
具有数据片段的自定义名称 
with custom names for pieces of data.

607
00:29:38,625 --> 00:29:39,875
因此 让我们回到VS代码 
So let's go back to VS Code.

608
00:29:39,875 --> 00:29:41,333
让我们使用这个新的关键字 
Let's use this new keyword.

609
00:29:41,333 --> 00:29:44,500
让我提议创建一个名为“学生”的类 
And let me propose that we create a class called Student.

610
00:29:44,500 --> 00:29:47,000
按照惯例 我将在这里使用大写的S 
And by convention, I'm going to use a capital S here,

611
00:29:47,000 --> 00:29:49,583
接下来 我将使用冒号 
and I'm going to go ahead, and with a colon,

612
00:29:49,583 --> 00:29:52,500
稍后 我们将介绍这个类的实现 
get to, later, the implementation of this class.

613
00:29:52,500 --> 00:29:55,625
所以我将使用. 这是目前有效的占位符 
So I'm just going to use dot dot dot, which is a valid placeholder for now,

614
00:29:55,625 --> 00:29:57,833
这对我来说只是预示着我会回来
that just indicates to me that I'm going to come back

615
00:29:57,833 --> 00:29:59,000
到以后实施这一点 
to implementing this later.

616
00:29:59,000 --> 00:30:02,125
但到目前为止 它确实存在 
But as of now, it does, in fact, exist.

617
00:30:02,125 --> 00:30:08,458
我现在已经为我定义了一个学生类 现在我可以在这里的代码中使用它 
I now have a student class defined for me that I can now use in my code here.

618
00:30:08,458 --> 00:30:09,875
我要怎么用它呢？
How am I going to use it?

619
00:30:09,875 --> 00:30:13,250
好的 首先 让我下楼去找学生 
Well, first of all, let me go down to get_student,

620
00:30:13,250 --> 00:30:18,625
让我将这段代码更改为不再使用字典 而是使用这个类 
and let me change this code to no longer use a dictionary but to use this class.

621
00:30:18,625 --> 00:30:19,666
我要做这件事 
I'm going to do this.

622
00:30:19,666 --> 00:30:22,791
我将给自己一个名为Student的变量 就像我以前做过的那样 
I'm going to give myself a variable called student, as I've done before,

623
00:30:22,791 --> 00:30:26,166
但我会将其设置为等于大写学生() 
but I'm going to set it equal to capital Student ().

624
00:30:28,916 --> 00:30:32,208
所以我要做的似乎是调用一个函数
So I'm going to do what appears to be calling a function

625
00:30:32,208 --> 00:30:35,583
和那个函数 大写的学生S 通知 
and that function, Student with a capital S, notice,

626
00:30:35,583 --> 00:30:39,500
匹配我在文件顶部为这个类指定的名称 
matches the name that I gave this class at the top of my file.

627
00:30:39,500 --> 00:30:41,166
好了 我下一步想做什么？
All right, what do I next want to do?

628
00:30:41,166 --> 00:30:43,333
我要继续 给这个学生起个名字 
I'm going to go ahead and give this student a name.

629
00:30:43,333 --> 00:30:46,041
现在 如果我还在用字典 我
Now, if I were still using a dictionary, I

630
00:30:46,041 --> 00:30:50,541
会用方括号写出学生 引用 不引用 “名字” 
would say student, quote, unquote, "name," using square brackets.

631
00:30:50,541 --> 00:30:52,125
但这不是一本词典 
But this is not a dictionary.

632
00:30:52,125 --> 00:30:54,500
事实证明 目前 我们将在课堂上
It turns out classes have what, for now, we'll

633
00:30:54,500 --> 00:30:58,916
调用属性 这是一种允许在
call attributes, properties of sorts that allow you to specify values inside

634
00:30:58,916 --> 00:30:59,416
他们中的一员 
of them.

635
00:30:59,416 --> 00:31:01,708
而它的语法恰好是一个点 
And the syntax for that happens to be a dot.

636
00:31:01,708 --> 00:31:03,166
我们以前见过圆点 
We've seen dots before.

637
00:31:03,166 --> 00:31:06,333
我们已经在模块和库的上下文中更普遍地使用了它 
We've used it in the context of modules and libraries, more generally.

638
00:31:06,333 --> 00:31:08,875
这是另一个类似的精神使用点
This is another similar in spirit use of a dot

639
00:31:08,875 --> 00:31:12,125
它能让你从别的东西里得到别的东西 
that allows you to get at something inside of something else.

640
00:31:12,125 --> 00:31:15,208
所以student.name将是语法
So student.name is going to be the syntax

641
00:31:15,208 --> 00:31:18,083
我给这个学生取了个名字 
I use for giving this student a name.

642
00:31:18,083 --> 00:31:21,666
这个名字将是“Name”的返回值 
And that name is going to be whatever the return value of "Name" is.

643
00:31:21,666 --> 00:31:24,958
然后我继续说student.house 
And then I'm going to go ahead and say student.house to give

644
00:31:24,958 --> 00:31:29,291
另一个名为“House”的属性 并给出输入的返回值
another attribute called "House" and give that the return value of input

645
00:31:29,291 --> 00:31:30,750
在这里 提示用户进行房屋 
here, prompting the user for house.

646
00:31:30,750 --> 00:31:33,625
然后 像以前一样 我只是要返回学生 
And then, as before, I'm just going to return student.

647
00:31:33,625 --> 00:31:37,166
但现在关于阶级真正强大的是 
But now what's really powerful about class,

648
00:31:37,166 --> 00:31:39,791
和面向对象的编程更普遍地说 
and object-oriented programming more generally,

649
00:31:39,791 --> 00:31:43,375
我创建了一种自定义数据类型 
is that I've created this custom data type called, literally,

650
00:31:43,375 --> 00:31:47,333
学生 大写S 我在变量中存储了一个这样的学生
Student, capital S. I've stored one such student in a variable

651
00:31:47,333 --> 00:31:50,833
就像我在变量student中做的那样 
like I can always do in a variable called student, lowercase s.

652
00:31:50,833 --> 00:31:52,333
但我想怎么叫都行 
But I could call it anything I want.

653
00:31:52,333 --> 00:31:56,166
称之为学生也是有道理的 但为了清楚起见 我还是要说清楚 
It just makes sense to call it student as well, but lowercase for clarity.

654
00:31:56,166 --> 00:31:58,291
然后我返回这个变量 
And then I'm returning that variable.

655
00:31:58,291 --> 00:32:01,666
因为我在第14和15行的语法 
And because of my syntax in lines 14 and 15,

656
00:32:01,666 --> 00:32:05,083
结果就是把这个类
that has the result of putting inside of that class

657
00:32:05,083 --> 00:32:09,291
name属性和house属性 
a name attribute and a house attribute.

658
00:32:09,291 --> 00:32:11,625
我只需要在这里再做一个改变 
I just need to make one more change up here.

659
00:32:11,625 --> 00:32:13,416
我要把帕德玛
I'm going to go ahead and remove our Padma

660
00:32:13,416 --> 00:32:15,500
代码 这样我们就可以只关注新的东西 
code, just so we can focus only on what's new,

661
00:32:15,500 --> 00:32:17,416
而不是修房子
rather than fixing her house.

662
00:32:17,416 --> 00:32:20,208
我要在这里修改语法
And I'm going to go in here and change the syntax that

663
00:32:20,208 --> 00:32:21,916
以前是字典 
previously was for dictionaries.

664
00:32:21,916 --> 00:32:26,958
同样 字典使用方括号 然后在引号中使用字符串 
Again, dictionaries use square brackets and then strings in quotes--

665
00:32:26,958 --> 00:32:29,958
单引号或双引号 取决于上下文 
either single quotes or double quotes, depending on the context.

666
00:32:29,958 --> 00:32:33,208
在这里 我将把它改为student.name 
Here, though, I'm going to change this to be student.name,

667
00:32:33,208 --> 00:32:37,458
在这里 我将把它改为student.house 
and over here, I'm going to change it to be student.house.

668
00:32:37,458 --> 00:32:40,791
这就是我的新语法 
And that's just going to be my new syntax for getting the contents of what

669
00:32:40,791 --> 00:32:43,250
似乎是一个叫做学生的类 
appears to be a class called student.

670
00:32:43,250 --> 00:32:47,458
让我继续搜索student.py的Python 回车 
Let me go ahead and rerun Python of student.py, Enter.

671
00:32:47,458 --> 00:32:49,333
让我们像以前一样输入哈利的名字 
Let's type in Harry's name as before.

672
00:32:49,333 --> 00:32:52,500
我们把他送进格兰芬多监狱 像往常一样祈祷 
Let's put him in Gryffindor, crossing our fingers as we often do,

673
00:32:52,500 --> 00:32:56,500
哈里确实来自格兰芬多 
and Harry is indeed from Gryffindor.

674
00:32:56,500 --> 00:32:58,166
不过 我都做了些什么？
What, though, have I done?

675
00:32:58,166 --> 00:33:01,000
让我们在这里介绍另一个术语
Let's introduce one other bit of terminology here

676
00:33:01,000 --> 00:33:05,583
事实证明 我可以使用那个CLASS关键字创建一个类 
it turns out that I can create a class, using that class keyword.

677
00:33:05,583 --> 00:33:09,958
但无论何时使用类 都是在创建所谓的对象 
But any time you use a class, you're creating what are called objects.

678
00:33:09,958 --> 00:33:14,666
这里是单词对象 作为一种面向对象的编程 或OOP 
And here is the word objects, as an object-oriented programming, or OOP.

679
00:33:14,666 --> 00:33:16,250
让我在这里回到我的代码 
Let me go back to my code here.

680
00:33:16,250 --> 00:33:18,916
尽管我还没有真正实现它的大部分--
And even though I haven't really implemented much of it at all--

681
00:33:18,916 --> 00:33:20,958
我真的只留下了一个点 点 点--
I literally just left it with a dot, dot, dot--

682
00:33:20,958 --> 00:33:25,416
这是足够的代码 第1行和第2行 仅仅发明了一个新的数据类型
that's enough code, lines 1 and 2, to just invent a new data type called

683
00:33:25,416 --> 00:33:29,708
学生 首都S 这可能会也可能不会有一些未来的功能 
Student, capital S, that may or may not have some future functionality as well.

684
00:33:29,708 --> 00:33:31,375
这足以创建一个类 
That's enough to create a class.

685
00:33:31,375 --> 00:33:34,166
然而 我在11号线上做了什么？
What, though, am I doing on line 11?

686
00:33:34,166 --> 00:33:40,083
在第11行 从技术上讲 我要做的是创建该类的对象 
On line 11, what I'm technically doing is creating an object of that class.

687
00:33:40,083 --> 00:33:42,000
因此 这也是另一个艺术术语 
So this, too, is another term of art.

688
00:33:42,000 --> 00:33:44,791
您可以从类创建对象 
You create objects from classes.

689
00:33:44,791 --> 00:33:47,000
因此 如果我们回到那个比喻 这个类是
So if we go back to that metaphor, that a class is

690
00:33:47,000 --> 00:33:50,916
就像房子或班级的蓝图就像一个模具 
like a blueprint for a house or a class is like a mold,

691
00:33:50,916 --> 00:33:54,750
对象是指当你使用该蓝图建造特定的房屋时
an object is when you use that blueprint to build a specific house

692
00:33:54,750 --> 00:33:58,458
或者是从石膏 模具里出来的东西 当你实际
or something that comes out of-- in plaster, the mold, when you actually

693
00:33:58,458 --> 00:34:01,250
使用该模具来创建这样的对象 
use that mold to create such an object.

694
00:34:01,250 --> 00:34:04,916
因此 类又是一种新数据类型的定义 
So a class is, again, the definition of a new data type.

695
00:34:04,916 --> 00:34:10,125
对象是的化身 或技术上的实例化 
The object is the incarnation of, or technically instantiation of.

696
00:34:10,125 --> 00:34:13,583
对象的另一个术语实际上是实例 
And another term for objects would actually be an instance.

697
00:34:13,583 --> 00:34:16,208
您也有类的实例 
You have instances of classes as well.

698
00:34:16,208 --> 00:34:17,458
所以这是大量的词汇量 
So that's a lot of vocabulary.

699
00:34:17,458 --> 00:34:19,708
但归根结底 它只是归结为这一点 
But at the end of the day, it just boils down to this.

700
00:34:19,708 --> 00:34:22,750
您可以定义自己的类 这实际上是您自己的数据类型 
You can define your own class, which is really your own data type.

701
00:34:22,750 --> 00:34:26,791
然后 您可以在其中存储属性 在这里使用这个点符号 
You can then store attributes inside of it, using this dot notation here.

702
00:34:26,791 --> 00:34:31,041
然后 您可以使用下面这样的代码访问这些相同的属性 
And then you can access those same attributes using code like this here.

703
00:34:31,041 --> 00:34:33,958
现在 我有了一个合适的“学生”数据类型 
And now, I have a proper "student" data type,

704
00:34:33,958 --> 00:34:36,625
我不需要把一些东西拼凑在一起
and I don't have to hack something together

705
00:34:36,625 --> 00:34:39,000
使用元组或列表 甚至使用字典 
using a tuple or a list or even a dictionary.

706
00:34:39,000 --> 00:34:43,500
我现在有了一个名为“Student”的适当数据类型 该数据类型是Python的作者
I now have a proper data type called "student" that the authors of Python

707
00:34:43,500 --> 00:34:46,041
没有给我 我给了我自己 
didn't give me; I gave myself.

708
00:34:46,041 --> 00:34:50,791
现在有没有关于CLASS、这个新关键字、CLASS或这个概念的问题
Any questions now on classes, this new keyword, class, or this idea

709
00:34:50,791 --> 00:34:53,625
这些物体或其实例？
of these objects or instances thereof?

710
00:34:53,625 --> 00:34:58,333
观众：类对象是可变的还是不可变的？
AUDIENCE: Is the class object mutable or immutable?

711
00:34:58,333 --> 00:34:59,666
大卫·J·马兰：问得好 
DAVID J. MALAN: A good question.

712
00:34:59,666 --> 00:35:02,208
我们显然已经为进行这种对话奠定了基础
And we've clearly laid the stage for having that conversation

713
00:35:02,208 --> 00:35:03,541
关于现在的每种数据类型 
about every data type now.

714
00:35:03,541 --> 00:35:07,958
我们将看到它们是可变的 但您可以使它们不可变 
We will see that they are mutable, but you can make them immutable.

715
00:35:07,958 --> 00:35:10,083
这样你就可以两全其美了 
So you can get the best of both worlds.

716
00:35:10,083 --> 00:35:13,416
现在 通过编写一些实际的代码--我们将编写比圆点更多的代码 
Now, by writing some actual code-- and we'll write more code than the dot,

717
00:35:13,416 --> 00:35:18,208
点 点进一点 关于类或其对象的其他问题？
dot, dot in just a bit, other questions on classes or these objects thereof?

718
00:35:18,208 --> 00:35:21,625
观众：那么这些职业有什么特点呢？
AUDIENCE: Then what would be the properties of those classes?

719
00:35:21,625 --> 00:35:24,750
大卫·J·马兰：所以现在 这些属性--或者属性 
DAVID J. MALAN: So at the moment, the properties of-- or the attributes of,

720
00:35:24,750 --> 00:35:28,250
到目前为止 我一直这样称呼它们--就是“名字”和“房子” 
as I've been calling them thus far-- would just be "Name" and "House."

721
00:35:28,250 --> 00:35:32,333
事实证明 类中很可能还内置了其他属性
It turns out that there may very well be other attributes built into classes

722
00:35:32,333 --> 00:35:33,541
我们可能很快就会看到 
that we may see before long.

723
00:35:33,541 --> 00:35:36,166
但现在 我唯一关心的两个属性
But for now, the only two attributes that I care about

724
00:35:36,166 --> 00:35:38,333
是我自己创造的--
are the ones that I myself created--

725
00:35:38,333 --> 00:35:42,208
即“名字”和“房子” 或者 再一次 我称之为属性 
namely "Name" and "House" or, again, what I would call attributes.

726
00:35:42,208 --> 00:35:43,916
稍后 我们将开始
And in a little bit, we're going to start

727
00:35:43,916 --> 00:35:47,541
将这些相同的属性称为实例变量 更专业地说是实例变量 
calling those same attributes, more technically, instance variables.

728
00:35:47,541 --> 00:35:50,708
“名字”和“房子” 就像我在VS代码中展示的那样
"Name" and "House," as I presented them here in VS Code

729
00:35:50,708 --> 00:35:55,750
实际上只是在内部称为“name”和“house”的变量
are really just variables called "name" and called "house" inside

730
00:35:55,750 --> 00:36:00,125
类型为学生的对象的 
of an object whose type is student.

731
00:36:00,125 --> 00:36:02,583
好的 那么我们还能用这些课程做些什么呢？
All right, so what more can we do with these classes?

732
00:36:02,583 --> 00:36:06,208
再次说明 第11行是我们要实例化的地方
Well, again, on line 11 is where we're instantiating

733
00:36:06,208 --> 00:36:11,000
学生类的对象 并将其赋给学生变量 
an object of the student class and assigning it to a student variable.

734
00:36:11,000 --> 00:36:12,416
然后我们添加属性--
We're then adding attributes--

735
00:36:12,416 --> 00:36:16,000
“名字”和“房子”--目前分别在第12行和第13行 
"Name" and "House," respectively-- on lines 12 and 13 currently.

736
00:36:16,000 --> 00:36:17,958
从技术上讲 这两者的价值都是
Both of those have values that are technically

737
00:36:17,958 --> 00:36:21,208
字符串或STR 因为这就是输入的返回值 
strings or strs, because that's what the return value of the input is.

738
00:36:21,208 --> 00:36:24,000
但这些属性值实际上可以是任何数据类型 
But those attributes values could actually be any data type.

739
00:36:24,000 --> 00:36:27,000
我们只是让事情变得简单 专注于定义学生
We're just keeping things simple and focusing on defining students

740
00:36:27,000 --> 00:36:28,333
就两根弦而言--
in terms of two strings--

741
00:36:28,333 --> 00:36:29,375
“名字”和“房子”
"Name" and "House."

742
00:36:29,375 --> 00:36:32,125
然后 在第14行 我们返回该变量 
And then, on line 14, we're returning that variable.

743
00:36:32,125 --> 00:36:35,333
我们将该对象返回给Main 这样我们就可以实际
We're returning that object to main so that we can actually

744
00:36:35,333 --> 00:36:37,708
打印出谁是哪个房子的人 
print out who is from what house.

745
00:36:37,708 --> 00:36:40,958
好吧 让我们继续在这里添加一些功能 因为 现在 
Well, let's go ahead and add a bit more functionality here because, right now,

746
00:36:40,958 --> 00:36:44,166
在第12行和第13行 这是一个小手册 
on lines 12 and 13, this is a little manual.

747
00:36:44,166 --> 00:36:47,333
我太鲁莽了 把所有的东西
And it's a little reckless of me to just be putting anything

748
00:36:47,333 --> 00:36:50,333
我想要进入这个学生物体的内部 
I want inside of this student object.

749
00:36:50,333 --> 00:36:53,041
事实证明 与字典不同 课堂上的情况不同 
It turns out with classes, unlike with dictionaries,

750
00:36:53,041 --> 00:36:57,625
我们实际上可以更多地标准化这些属性
we can actually standardize, all the more, what those attributes can be

751
00:36:57,625 --> 00:37:00,291
以及您可以将它们设置为什么样的值 
and what kinds of values you can set them to.

752
00:37:00,291 --> 00:37:02,375
所以让我继续做这件事 
So let me go ahead and do this.

753
00:37:02,375 --> 00:37:04,375
让我提议 它实际上将是真正的
Let me propose that it would actually be really

754
00:37:04,375 --> 00:37:08,875
如果让我继续下去 而不是在这里做这个 那真是太好了
nice if, instead of doing this here, let me go ahead

755
00:37:08,875 --> 00:37:10,833
并按如下方式简化我的代码 
and simplify my code as follows.

756
00:37:10,833 --> 00:37:13,708
接下来 让我为自己指定一个名为name的局部变量
Let me go ahead and give myself a local variable called name

757
00:37:13,708 --> 00:37:17,208
并将其设置为等于输入的返回值 就像我们现在多次做的那样
and set it equal to the return value of input, like we've done many times now

758
00:37:17,208 --> 00:37:17,791
已经有了 
already.

759
00:37:17,791 --> 00:37:20,333
现在让我给自己另一个变量 叫做house 
Let me give myself one other variable for now, called house,

760
00:37:20,333 --> 00:37:23,333
并将其设置为等于输入的返回值
and set it equal to the return value of input

761
00:37:23,333 --> 00:37:25,291
以及提示用户选择他们的房子 
as well, prompting the user for their house.

762
00:37:25,291 --> 00:37:30,416
现在 不是从我的学生类创建一个学生对象
And now, instead of creating a student object from my student class

763
00:37:30,416 --> 00:37:34,500
然后手动将名称属性放入其中
and then manually putting the name attribute inside of it

764
00:37:34,500 --> 00:37:37,166
和它里面的房子属性 让
and the house attribute inside of it, let

765
00:37:37,166 --> 00:37:39,458
我实际上做了一些更有力量的事情 
me actually do something more powerful.

766
00:37:39,458 --> 00:37:40,583
让我来做吧 
Let me do this.

767
00:37:40,583 --> 00:37:45,333
让我调用学生函数 它与类名相同--
Let me call that Student function, which is identical to the class name--

768
00:37:45,333 --> 00:37:48,125
只需定义一个类 就可以获得一个函数
just by defining a class, you get a function

769
00:37:48,125 --> 00:37:52,583
其名称与类名相同 包含大写字母 
whose name is identical to the class name, with the capital letter included.

770
00:37:52,583 --> 00:37:54,625
但是 不是只做开括号 
But instead of just doing open parenthesis,

771
00:37:54,625 --> 00:37:58,166
右括号 让我把我的名字传进去
closed parenthesis, let me pass in the name that I

772
00:37:58,166 --> 00:38:02,791
我想用这个物体和我想放进那个物体的房子来填充
want to fill this object with and the house that I want to put in that object

773
00:38:02,791 --> 00:38:03,375
也是 
as well.

774
00:38:03,375 --> 00:38:09,375
现在让我像以前一样设置返回值为学生等于 就像这样 
And now let me set the return value as before to be student equals like this.

775
00:38:09,375 --> 00:38:11,083
那么 我做了什么不同的事情呢？
So what have I done that's different?

776
00:38:11,083 --> 00:38:13,583
从根本上说 我仍然以同样的方式获得用户输入 
Fundamentally, I'm still getting user input in the same way.

777
00:38:13,583 --> 00:38:16,750
我在第11行使用输入 在第12行使用输入 
I'm using input on line 11 and input on line 12.

778
00:38:16,750 --> 00:38:21,125
我只是碰巧将这些返回值存储在局部变量中 
And I just so happen to be storing those return values in local variables.

779
00:38:21,125 --> 00:38:24,875
现在 我们正在为类的更强大的功能做准备
And now we're setting the stage for the more powerful features of classes

780
00:38:24,875 --> 00:38:27,208
以及更一般的面向对象编程 
and object-oriented programming more generally.

781
00:38:27,208 --> 00:38:31,500
注意 我是故意传递给这个首都S的学生
Notice that I'm deliberately passing to this capital S Student

782
00:38:31,500 --> 00:38:33,875
功能 名字 房子--
function, name, house--

783
00:38:33,875 --> 00:38:36,291
我正在向该函数传递参数 
I'm passing in arguments to the function.

784
00:38:36,291 --> 00:38:39,750
现在 学生们还不知道该怎么处理这些东西 
Now, the student class is not going to know what to do with those yet,

785
00:38:39,750 --> 00:38:44,791
但现在 我正在标准化如何将数据传递到这个学生班级 
but now I'm standardizing how I'm passing data into this student class.

786
00:38:44,791 --> 00:38:47,833
最终 这将给我一个犯错的机会
And ultimately, it's going to give me an opportunity to error

787
00:38:47,833 --> 00:38:51,166
检查这些输入 以确保名称有效 并且具有值
check those inputs, to make sure that the name is valid, that it has a value

788
00:38:51,166 --> 00:38:52,875
而且 不仅仅是用户按了Enter键 
and it's not just the user hitting Enter.

789
00:38:52,875 --> 00:38:56,041
这将使我能够确保它是一所有效的房子 它是
It's going to allow me to ensure that it's a valid house, that it's

790
00:38:56,041 --> 00:38:59,208
格兰芬多、赫奇帕奇、拉文克劳或斯莱特林
Gryffindor or Hufflepuff or Ravenclaw or Slytherin

791
00:38:59,208 --> 00:39:02,916
或者不只是按回车键或用户输入的某个随机值 
or not just hitting Enter or some random value that the user types in.

792
00:39:02,916 --> 00:39:05,916
因为我要把“名字”和“房子”传给学生
Because I'm passing "Name" and "House" to the student

793
00:39:05,916 --> 00:39:08,791
类 这个特殊的函数 我要
class, this particular function, I'm going

794
00:39:08,791 --> 00:39:11,416
以便更好地控制我的数据的正确性 
to have more control over the correctness of my data.

795
00:39:11,416 --> 00:39:14,541
现在让我们来看看学生班 到目前为止 
So let's now go up to the student class, which, up until now,

796
00:39:14,541 --> 00:39:16,125
我离开时只是点点 点点 点点 
I left as just dot, dot, dot.

797
00:39:16,125 --> 00:39:19,625
事实证明 在课程的背景下 
It turns out that, in the context of classes,

798
00:39:19,625 --> 00:39:23,916
有许多不只是属性或实例
there are a number of not just attributes or instance

799
00:39:23,916 --> 00:39:27,041
可以放在里面的变量 也可以放入方法 
variables that you can put inside, but also methods.

800
00:39:27,041 --> 00:39:32,083
类带有某些方法 或其中的函数 
Classes come with certain methods, or functions inside of them,

801
00:39:32,083 --> 00:39:35,708
你可以定义 他们只是以一种特殊的方式行事 
that you can define, and they just behave in a special way,

802
00:39:35,708 --> 00:39:37,875
从本质上讲 它是如何工作的 
by nature of how Python works.

803
00:39:37,875 --> 00:39:42,625
这些函数允许您以标准方式确定行为 
These functions allow you to determine behavior in a standard way.

804
00:39:42,625 --> 00:39:45,083
从这个意义上说 它们是特殊的方法 
They are special methods in that sense.

805
00:39:45,083 --> 00:39:46,333
现在 我这么说是什么意思 
Now, what do I mean by this.

806
00:39:46,333 --> 00:39:48,083
好吧 让我回到VS代码这里 
Well, let me go back to VS Code here.

807
00:39:48,083 --> 00:39:53,000
让我提议我开始定义一个标准函数
And let me propose that I start to define a standard function

808
00:39:53,000 --> 00:39:56,916
被称为下划线 或下划线 因为它是
called underscore underscore, or Dunder, as it's

809
00:39:56,916 --> 00:39:59,916
缩写、缩写、下划线、下划线
abbreviated, init, underscore underscore,

810
00:39:59,916 --> 00:40:02,916
然后我要继续做开括号 
and then I'm going to go ahead and do open parentheses,

811
00:40:02,916 --> 00:40:06,875
然后我要在这里加上 字面上的 自我这个词 
and then I'm going to put in here, literally, the word self.

812
00:40:06,875 --> 00:40:08,416
稍后将详细介绍这一点 
More on that in just a moment.

813
00:40:08,416 --> 00:40:11,791
但现在 在这个函数中 我将有机会
But now, inside of this function, I'm going to have an opportunity

814
00:40:11,791 --> 00:40:16,791
若要自定义此类的对象 请执行以下操作 
to customize this class's objects.

815
00:40:16,791 --> 00:40:20,333
也就是说 这个下划线 下划线init方法 
That is to say this underscore, underscore init method,

816
00:40:20,333 --> 00:40:25,208
或者DUnder Init方法具体称为实例方法 
or Dunder init method is specifically known as an instance method,

817
00:40:25,208 --> 00:40:26,708
它的名字就是这个 
and it's called exactly this.

818
00:40:26,708 --> 00:40:28,875
这是由Python的作者设计的 
This is designed by the authors of Python.

819
00:40:28,875 --> 00:40:34,291
如果您想从类中初始化对象的内容 
And if you want to initialize the contents of an object from a class,

820
00:40:34,291 --> 00:40:37,875
您定义了这个方法 我们将在这里看到它将要做什么 
you define this method, and we'll see what it's about to do here.

821
00:40:37,875 --> 00:40:41,250
让我回到VS代码 让我来做一些类似的事情 
Let me go back to VS Code, and let me do something like this.

822
00:40:41,250 --> 00:40:47,750
Self.name=name self.house=house 
self.name = name, and self.house = house.

823
00:40:47,750 --> 00:40:51,250
但我不想只是泛泛地初始化这个对象 
But I don't want to just init this object very generically.

824
00:40:51,250 --> 00:40:56,166
我希望这种名为init的方法不仅接受自己 还接受名字 
I want this method, called init, to take in not just self but name,

825
00:40:56,166 --> 00:40:58,375
豪斯也是 
house as well.

826
00:40:58,375 --> 00:40:59,916
现在 世界上到底发生了什么？
Now, what in the world is going on?

827
00:40:59,916 --> 00:41:01,708
因为这里有很多奇怪的语法 
Because there's a lot of weird syntax here.

828
00:41:01,708 --> 00:41:03,375
有一种DUnder Init方法--
There's this Dunder init method--

829
00:41:03,375 --> 00:41:05,791
双下划线 初始化 双下划线 
double underscore, init, double underscore.

830
00:41:05,791 --> 00:41:08,750
突然间 这个参数被称为SELF 
There's, all of a sudden, this parameter called self.

831
00:41:08,750 --> 00:41:12,458
然后是这个新的语法--self.name和self.house 
And then there's this new syntax-- self.name and self.house.

832
00:41:12,458 --> 00:41:16,541
现在 您真正看到了面向对象编程的一种表现 
Now you're seeing really a manifestation of object-oriented programming.

833
00:41:16,541 --> 00:41:18,250
从根本上说 这并没有什么不同
It's not all that different fundamentally

834
00:41:18,250 --> 00:41:20,541
从我们几周来对词典所做的工作来看 
from what we've been doing for weeks with dictionaries,

835
00:41:20,541 --> 00:41:23,125
通过向词典添加关键字 
by adding keys to dictionaries.

836
00:41:23,125 --> 00:41:28,333
但在这种情况下 我们向对象添加变量 也就是 
But in this case, we're adding variables to objects, a.k.a.

837
00:41:28,333 --> 00:41:30,500
将实例变量转换为对象 
instance variables to objects.

838
00:41:30,500 --> 00:41:31,458
现在 这是怎么回事？
Now, what's going on?

839
00:41:31,458 --> 00:41:32,541
让我们反过来来做这件事 
Let's do this in reverse.

840
00:41:32,541 --> 00:41:34,750
让我们回到前面编写的代码行 
Let's go back to the line of code we wrote earlier.

841
00:41:34,750 --> 00:41:38,708
在第15行 我把这个班级的名字
On line 15, I am treating the name of this class--

842
00:41:38,708 --> 00:41:41,916
学生用大写S--作为函数 
Student with a capital S-- as a function.

843
00:41:41,916 --> 00:41:44,583
我要传递两个值--
And I am passing in two values--

844
00:41:44,583 --> 00:41:45,916
“名字”和“房子”
"Name" and "House."

845
00:41:45,916 --> 00:41:48,708
我在屏幕上第15行突出显示的是 
What I've highlighted here on the screen, on line 15,

846
00:41:48,708 --> 00:41:51,250
通常称为构造函数调用 
is generally known as a constructor call.

847
00:41:51,250 --> 00:41:56,875
这行代码将为我构造一个学生对象 
This is a line of code that is going to construct a student object for me.

848
00:41:56,875 --> 00:42:02,791
使用同义词 它将为我实例化一个学生对象 
Using synonyms, it is going to instantiate a student object for me.

849
00:42:02,791 --> 00:42:05,583
再说一次 它将如何创建那个对象？
And again, how is it going to create that object?

850
00:42:05,583 --> 00:42:09,458
它将使用学生类作为模板 作为某种模型
It's going to use the student class as a template, as a mold of sorts

851
00:42:09,458 --> 00:42:12,291
所以每个学生的结构都是一样的 
so that every student is structured the same.

852
00:42:12,291 --> 00:42:13,875
每个学生都会有一个名字 
Every student is going to have a name.

853
00:42:13,875 --> 00:42:15,458
每个学生都会有一所房子 
Every student's going to have a house.

854
00:42:15,458 --> 00:42:20,916
但是因为我可以把参数传递给这个学生函数 大写的S 
But because I can pass in arguments to this Student function, capital S,

855
00:42:20,916 --> 00:42:26,666
我将能够定制该对象的内容 
I'm going to be able to customize the contents of that object.

856
00:42:26,666 --> 00:42:29,666
所以如果你想一想现实世界--如果你曾经走在街上
So if you think about the real world-- if you've ever been on a street

857
00:42:29,666 --> 00:42:34,666
或者是一个社区 所有的房子看起来都一样 但他们可能
or a neighborhood where all of the houses look the same but they might be

858
00:42:34,666 --> 00:42:37,541
油漆不同；它们的装饰可能会略有不同
painted differently; they might be decorated a little bit differently

859
00:42:37,541 --> 00:42:40,958
在外面 所有这些房子都可能是用完全相同的
on the outside, all of those houses might have been built using the exact

860
00:42:40,958 --> 00:42:42,541
同样的蓝图--
same blueprint--

861
00:42:42,541 --> 00:42:43,875
一个模子 如果你愿意的话 
a mold, if you will.

862
00:42:43,875 --> 00:42:48,083
但然后你就可以专门研究那些房子的细微之处了 
But then you can specialize exactly the finer points of those houses.

863
00:42:48,083 --> 00:42:51,000
通过给外面涂上不同的颜色或种植不同的树 
By painting the outside a different color or planting different trees,

864
00:42:51,000 --> 00:42:52,500
您可以设置不同的样式 
you can style them differently.

865
00:42:52,500 --> 00:42:57,750
在精神上与这里相似 我们有一个学生蓝图
Similar in spirit here, we have a Student blueprint

866
00:42:57,750 --> 00:43:01,583
它现在总会有名字和房子 但这取决于你和我
that's always going to have now a name and a house, but it's up to you and me

867
00:43:01,583 --> 00:43:04,166
传递我们想要的任何名字和任何房子 
to pass in any name and any house that we want.

868
00:43:04,166 --> 00:43:06,041
现在 这个函数在哪里？
Now, where is this function?

869
00:43:06,041 --> 00:43:09,125
我叫学生 大写 S 然后是一个括号
The fact that I'm calling Student, capital, S and then a parenthesis

870
00:43:09,125 --> 00:43:11,250
和一个内含参数的右括号
and a closed parenthesis with arguments inside

871
00:43:11,250 --> 00:43:12,958
暗示在某个地方有一个函数
suggest that there's a function somewhere

872
00:43:12,958 --> 00:43:17,500
在已经定义的世界中 使用def 这将被称为 
in the world that has been defined, with def, that's going to be called.

873
00:43:17,500 --> 00:43:20,416
嗯 正如您现在可能已经猜到的那样 函数
Well, as you might have guessed by now, the function

874
00:43:20,416 --> 00:43:25,500
通过定义Python类的工作方式 它将始终被调用 
that will always be called, by definition of how Python classes work,

875
00:43:25,500 --> 00:43:30,000
是一个名为双下划线、初始化、双下划线的函数 
is a function called double underscore, init, double underscore.

876
00:43:30,000 --> 00:43:30,500
为什么？
Why?

877
00:43:30,500 --> 00:43:33,333
这是一个疯狂的名字 但它是Python的作者
It's a crazy name, but it's what the authors of Python

878
00:43:33,333 --> 00:43:38,750
选择只在Python中实现对象的初始化 
chose to just implement the initialization of an object in Python.

879
00:43:38,750 --> 00:43:40,916
现在 唯一奇怪的是--
Now, the only weird thing--

880
00:43:40,916 --> 00:43:43,125
我承认 特别奇怪的是 这一点 
especially weird thing, I will admit, is this.

881
00:43:43,125 --> 00:43:49,125
对我来说 如果初始化的唯一两个参数是
It would be way clearer, to me, too, if the only two parameters for init we're

882
00:43:49,125 --> 00:43:50,666
只是名字 豪斯 
just name, house.

883
00:43:50,666 --> 00:43:53,541
到目前为止 我们就是这样定义类中的每个函数的 
That's how we've defined every function thus far in the class.

884
00:43:53,541 --> 00:43:57,291
您只需指定希望函数接受的参数 
You just specify the parameters that you want the function to accept.

885
00:43:57,291 --> 00:44:00,333
这与我在第15行所做的是一致的 
And that lines up with what I'm doing on line 15.

886
00:44:00,333 --> 00:44:04,541
我只向学生函数传递了两件事 
I am only passing in two things to the student function.

887
00:44:04,541 --> 00:44:07,833
但事实证明 Python的作者
But it turns out that the authors of Python

888
00:44:07,833 --> 00:44:09,541
需要在这里给我们一点帮助
need to give us a little bit of help here

889
00:44:09,541 --> 00:44:14,458
因为假设您将“name”和“house”传递给这个init方法 
because suppose that you pass in "Name" and "House" to this init method.

890
00:44:14,458 --> 00:44:17,833
而方法只是类中的一个函数 
And a method is just a function inside of a class.

891
00:44:17,833 --> 00:44:20,291
你打算怎么处理这个名字和房子？
What are you going to do with the name and the house?

892
00:44:20,291 --> 00:44:22,333
从字面上看 你打算把它们放在哪里？
Literally, where are you going to put them?

893
00:44:22,333 --> 00:44:26,500
如果你想记住这个学生的名字和房子 
If you want to remember the name and the house for this student,

894
00:44:26,500 --> 00:44:29,166
你必须能够将这些值存储在某个地方 
you've got to be able to store those values somewhere.

895
00:44:29,166 --> 00:44:32,416
以及如何将它们存储在当前对象中
And how do you store them in the current object

896
00:44:32,416 --> 00:44:34,833
刚刚被“实例化”了吗？
that has just been "instantiated?"

897
00:44:34,833 --> 00:44:37,625
好吧 Python语言的作者们决定
Well, the authors of Python decided that the convention

898
00:44:37,625 --> 00:44:41,958
这个初始化方法也会半秘密地
is going to be that this init method also, semi secretly, takes

899
00:44:41,958 --> 00:44:44,625
第三个论点 那必须放在第一位 
a third argument, that has to come first.

900
00:44:44,625 --> 00:44:46,666
按照惯例 它被称为SELF 但你可以
By convention, it's called self, but you could

901
00:44:46,666 --> 00:44:48,250
严格来说 你可以叫它任何你想要的东西 
call it technically anything you want.

902
00:44:48,250 --> 00:44:50,208
但惯例是 它总是自称是自己 
But the convention is to always call it self.

903
00:44:50,208 --> 00:44:53,500
而SELF 顾名思义 给了你访问
And self, as its name implies, gives you access

904
00:44:53,500 --> 00:44:56,791
添加到刚刚创建的当前对象 
to the current object that was just created.

905
00:44:56,791 --> 00:44:58,000
那是什么意思？
What does that mean?

906
00:44:58,000 --> 00:45:02,166
再一次 现在 在第14行 现在它向下移动了一点 
Again, now, on line 14, now that it's moved down a little bit,

907
00:45:02,166 --> 00:45:04,083
这里的这行是一个构造函数 
this line here is a constructor.

908
00:45:04,083 --> 00:45:06,166
它构造了一个学生对象 
It constructs a student object.

909
00:45:06,166 --> 00:45:08,291
但最初那个物体里什么都没有 
But there's nothing in that object initially.

910
00:45:08,291 --> 00:45:09,750
没有名字 没有房子 
There's no name; there's no house.

911
00:45:09,750 --> 00:45:12,791
但该对象存在于计算机的内存中 
But the object exists in the computer's memory.

912
00:45:12,791 --> 00:45:16,541
现在 您需要将姓名和房子存储在该对象中 
It's up to, now, you to store the name and the house inside of that object.

913
00:45:16,541 --> 00:45:17,500
你怎么做到的？
How do you do that?

914
00:45:17,500 --> 00:45:21,500
嗯 Python会自动为您调用这个init方法 
Well, Python will just automatically call this init method for you,

915
00:45:21,500 --> 00:45:27,500
它将自动传递对一个参数的引用 该参数
and it's going to automatically pass in a reference to an argument that

916
00:45:27,500 --> 00:45:32,375
表示它刚刚在内存中为您构造的当前对象 
represents the current object that it just constructed in memory for you,

917
00:45:32,375 --> 00:45:34,708
而这取决于你用价值观来填充它 
and it's up to you to populate it with values.

918
00:45:34,708 --> 00:45:37,666
这意味着 在您的init方法中 
And what this means is that, inside of your init method,

919
00:45:37,666 --> 00:45:42,875
从字面上看 您可以使用self.name来创建一个新的属性 也就是 
you can literally do self.name to create a new attribute, a.k.a.

920
00:45:42,875 --> 00:45:46,166
一个实例变量 位于该变量内部 否则为空
an instance variable, inside of that otherwise empty

921
00:45:46,166 --> 00:45:48,416
对象 并将此名称放入其中 
object and put this name inside of it.

922
00:45:48,416 --> 00:45:51,875
它允许你自己做房子 并储存房子的价值 
It allows you to do self.house and store that value of house.

923
00:45:51,875 --> 00:45:54,000
现在 你可以给这些东西取任何你想要的名字 
Now, you could call these things anything you want.

924
00:45:54,000 --> 00:45:54,750
它们可能是n 
They could be n.

925
00:45:54,750 --> 00:45:56,416
它们可能是h 就像以前一样 
They could be h, as before.

926
00:45:56,416 --> 00:46:00,250
但这真的不是很清楚 
But that's really not very self-explanatory.

927
00:46:00,250 --> 00:46:04,250
做这样的大会要好得多 Self.name等于name 
Much better to do this kind of convention. self.name equals name.

928
00:46:04,250 --> 00:46:06,333
自个儿 房子等于房子 
self.house equals house.

929
00:46:06,333 --> 00:46:11,708
这就像是将值名称安装到其他空的对象中
And this is like installing into the otherwise empty object the value name

930
00:46:11,708 --> 00:46:16,083
并将它们存放和存储在名称完全相同的实例中
and house and storing them in, really, identically named instance

931
00:46:16,083 --> 00:46:17,708
对象中的变量 
variables in the object.

932
00:46:17,708 --> 00:46:20,833
同样 对象只是类的一个实例 
And again, an object is just an instance of a class.

933
00:46:20,833 --> 00:46:23,208
现在 我知道那是很多词汇量 
Now, I know that was a lot of vocabulary.

934
00:46:23,208 --> 00:46:24,875
这是很多奇怪的语法 
That's a lot of weird syntax.

935
00:46:24,875 --> 00:46:28,625
所以任何关于这个初始化方法的问题 它在生活中的目的 
So any questions on this init method, whose purpose in life,

936
00:46:28,625 --> 00:46:33,541
还是要在第一次创建一个空对象时对其进行初始化？
again, is to initialize an otherwise empty object when you first create it?

937
00:46:33,541 --> 00:46:36,791
受众：那么init方法和默认方法有什么不同呢
AUDIENCE: So what is the difference between the init method and default

938
00:46:36,791 --> 00:46:37,500
构造者？
constructor?

939
00:46:37,500 --> 00:46:38,833
大卫·J·马兰：问得好 
DAVID J. MALAN: A good question.

940
00:46:38,833 --> 00:46:41,583
所以在其他语言中--如果你以前编程过 
So in other languages-- if you programmed before.

941
00:46:41,583 --> 00:46:45,166
例如 Java--有一些函数被显式调用
For instance, Java-- there are functions that are explicitly called

942
00:46:45,166 --> 00:46:47,916
构造对象的构造函数 
constructors that construct an object.

943
00:46:47,916 --> 00:46:49,416
它们使用值对其进行初始化 
They initialize it with values.

944
00:46:49,416 --> 00:46:53,291
从技术上讲 Python将这个init方法称为初始化方法 
Python technically calls this init method the initialization method.

945
00:46:53,291 --> 00:46:54,958
它初始化值 
It initializes the value.

946
00:46:54,958 --> 00:47:00,875
现在我的代码在第15行 如果我向下滚动 从技术上讲 我是
It's on line 15 now of my code, if I scroll back down, that I'm technically

947
00:47:00,875 --> 00:47:02,416
构建对象 
constructing the object.

948
00:47:02,416 --> 00:47:05,333
原来 在Python中还有另一种特殊的方法 
It turns out there's another special method in Python,

949
00:47:05,333 --> 00:47:07,291
今天我们不会详细讨论 
that we won't talk about in detail today,

950
00:47:07,291 --> 00:47:11,125
调用下划线下划线、新下划线、下划线
called underscore underscore, new, underscore underscore

951
00:47:11,125 --> 00:47:13,375
它实际上处理了创建
that actually handles the process of creating

952
00:47:13,375 --> 00:47:15,458
在我们的记忆中有一个空的物体 
an empty object in memory for us.

953
00:47:15,458 --> 00:47:17,833
但是 总的来说 你这个程序员 
But, generally speaking, you, the programmer,

954
00:47:17,833 --> 00:47:19,916
不需要操控新函数 
don't need to manipulate the new function.

955
00:47:19,916 --> 00:47:20,916
它只对你有效 
It just works for you.

956
00:47:20,916 --> 00:47:23,750
相反 您可以在这里定义您自己的init方法
Instead, you define your own init method here

957
00:47:23,750 --> 00:47:27,041
和init函数在您的类中 该方法
and init function inside of your class, and that method

958
00:47:27,041 --> 00:47:29,916
初始化对象的内容 
initializes the contents of the object.

959
00:47:29,916 --> 00:47:32,750
所以从技术上讲 构造对象与构建对象之间存在区别
So there's technically a distinction between constructing the object

960
00:47:32,750 --> 00:47:35,250
使用new并使用init对其进行初始化 
with new and initializing it with init.

961
00:47:35,250 --> 00:47:39,250
但在Python的世界中 您几乎只担心init方法 
But in the world of Python, you pretty much only worry about the init method.

962
00:47:39,250 --> 00:47:42,250
Python通常会为您完成另一部分工作 
Python generally does the other part for you.

963
00:47:42,250 --> 00:47:43,000
问得好 
A good question.

964
00:47:43,000 --> 00:47:44,333
其他?
Others?

965
00:47:44,333 --> 00:47:48,166
观众：如果你想存储多个名字怎么办？
AUDIENCE: What about if you want to store more than one name or more

966
00:47:48,166 --> 00:47:49,083
不只是一栋房子？
than one house?

967
00:47:49,083 --> 00:47:49,750
大卫·J·马兰：问得好 
DAVID J. MALAN: A good question.

968
00:47:49,750 --> 00:47:52,666
如果要存储多个名称或多个房屋 
If you want to store more than one name or more than one house,

969
00:47:52,666 --> 00:47:54,083
你可以用不同的方式来做这件事 
you can do this in different ways.

970
00:47:54,083 --> 00:47:57,916
您可以创建其他属性--技术上称为实例变量--
You could create other attributes-- technically called instance variables--

971
00:47:57,916 --> 00:48:01,708
如self.name1、self.name2 
like self.name1, self.name2.

972
00:48:01,708 --> 00:48:03,708
但我们在过去已经看到 这并不是
But we've seen, in the past, that that is not

973
00:48:03,708 --> 00:48:06,291
一个非常好的设计 仅仅是有多个变量来存储
a very good design, just to have multiple variables to store

974
00:48:06,291 --> 00:48:07,250
多件事 
multiple things.

975
00:48:07,250 --> 00:48:12,625
也许 相反 您有一个名为self.name、复数
Maybe, instead, you have an instance variable called self.names, plural,

976
00:48:12,625 --> 00:48:15,958
你把它设置成一个名字列表或一个房屋列表 
and you set it equal to a list of names or a list of houses.

977
00:48:15,958 --> 00:48:19,000
现在 在这种情况下 我不认为这真的解决了问题 因为我
Now, in this case, I don't think that really solves a problem because I'm

978
00:48:19,000 --> 00:48:22,958
试图实现一个学生 单数 所以它没有真正的意义
trying to implement a student, singular, so it doesn't really make sense

979
00:48:22,958 --> 00:48:24,250
有多个名字 
to have multiple first names.

980
00:48:24,250 --> 00:48:27,166
可能是昵称 也可能是姓氏 所以我们也可以加上这些 
Maybe a nickname, maybe a last name, so we could add those, too.

981
00:48:27,166 --> 00:48:29,375
但我不认为我们本身需要多个名字
But I don't think we need multiple names per se

982
00:48:29,375 --> 00:48:31,333
在这种情况下 还有多栋房子 
and, in this case, multiple houses.

983
00:48:31,333 --> 00:48:34,500
但绝对可以使用我们熟悉的一些构建块来实现这一点
But absolutely, you could do that using some of our familiar building blocks

984
00:48:34,500 --> 00:48:35,916
就像清单一样 
like lists.

985
00:48:35,916 --> 00:48:37,541
还有其他问题吗？
Other questions?

986
00:48:37,541 --> 00:48:40,291
观众：类或对象在内存中是如何表示的？
AUDIENCE: How are classes or objects represented in memory?

987
00:48:40,291 --> 00:48:43,041
David J.Malan：类和对象在内存中是如何表示的？
DAVID J. MALAN: How are classes and objects represented in memory?

988
00:48:43,041 --> 00:48:44,958
所以从技术上讲 这个类只是代码 
So the class is technically just code.

989
00:48:44,958 --> 00:48:48,333
这是我文件顶部的代码--第1行到第4行--
It is the code on the top of my file-- lines 1 through fou4--

990
00:48:48,333 --> 00:48:52,250
它定义了蓝图 模板 如果你愿意的话 
that defines that blueprint, that template, if you will.

991
00:48:52,250 --> 00:48:54,833
对象存储在计算机的内存中
Objects are stored in the computer's memory

992
00:48:54,833 --> 00:48:56,333
通过占用一定数量的字节 
by taking up some number of bytes.

993
00:48:56,333 --> 00:48:59,125
所以您可能对字节、千字节或兆字节很熟悉 
So you're probably familiar with bytes or kilobytes or megabytes.

994
00:48:59,125 --> 00:49:01,750
有一些字节块 可能都是
There's some chunk of bytes, probably all

995
00:49:01,750 --> 00:49:03,708
在计算机内存中的相同位置
in the same location in the computer's memory

996
00:49:03,708 --> 00:49:07,916
或RAM 其中存储这些对象 
or RAM, where those objects are stored.

997
00:49:07,916 --> 00:49:11,500
但这就是程序Python为您处理的 
But that's what Python, the program, handles for you.

998
00:49:11,500 --> 00:49:14,958
解释程序会找出将其放在计算机内存中的位置 
Python the interpreter figures out where in the computer's memory to put it.

999
00:49:14,958 --> 00:49:18,041
你和我 作为程序员 在这个层面上思考和解决问题 
You and I, the programmers, get to think and solve problems at this level.

1000
00:49:18,041 --> 00:49:21,916
作为解释器的Python将为您处理这些较低级别的细节 
Python, the interpreter, handles those lower level details for you.

1001
00:49:21,916 --> 00:49:25,166
最后一个关于类和对象的问题怎么样？
How about one final question on classes and objects?

1002
00:49:25,166 --> 00:49:28,125
听众：所以我的问题是 我们是否也能这样做
AUDIENCE: So my question is if we can the same do

1003
00:49:28,125 --> 00:49:31,625
字典也是如此 那么为什么要使用类呢？
the same thing with the dictionaries, so why to use classes?

1004
00:49:31,625 --> 00:49:32,875
大卫·J·马兰：问得好 
DAVID J. MALAN: Good question.

1005
00:49:32,875 --> 00:49:34,750
如果你能用字典做同样的事情 
If you can do the same things as you can with dictionaries,

1006
00:49:34,750 --> 00:49:35,958
为什么要使用类？
why should you use classes?

1007
00:49:35,958 --> 00:49:38,416
因为我们现在只是触及了什么的皮毛
Because we are just scratching the surface now of what

1008
00:49:38,416 --> 00:49:39,833
你可以用课程来应付 
you can do with classes.

1009
00:49:39,833 --> 00:49:42,666
现在 请允许我回到我的键盘上 向你们展示
Allow me to go back, now, to my keyboard and show you

1010
00:49:42,666 --> 00:49:44,375
更多关于您可以使用类所做的事情 
more of what you can do with classes.

1011
00:49:44,375 --> 00:49:47,750
但简而言之 您可以使用类做更多的事情 
But in short, you can do much more with classes.

1012
00:49:47,750 --> 00:49:51,791
使用类可以更好地确保数据的正确性 
You can ensure the correctness of your data much more with classes.

1013
00:49:51,791 --> 00:49:53,166
你可以错误地检查一些东西 
You can error-check things.

1014
00:49:53,166 --> 00:49:57,375
通常 您可以更有效地设计更复杂的软件 
And generally, you can design more complicated software more effectively.

1015
00:49:57,375 --> 00:49:59,458
今天我们将继续看到一些特色
And we'll continue to see, today, features

1016
00:49:59,458 --> 00:50:02,416
更广泛地说 是关于Python和面向对象编程的
of Python and object-oriented programming more generally

1017
00:50:02,416 --> 00:50:04,875
这使我们能够做到这一点 
that allows us to do just that.

1018
00:50:04,875 --> 00:50:09,333
所以让我提议 事实上 首先 让我们收紧这股电流
So let me propose, in fact, that first, let's just tighten up this current

1019
00:50:09,333 --> 00:50:13,916
实现 这也为我们提供了一个init方法 它只声明了两个
implementation, which again has us with an init method that just declares two

1020
00:50:13,916 --> 00:50:16,875
实例变量--self.name和self.house house 同样 
instance variables-- self.name and self.house, house, which, again,

1021
00:50:16,875 --> 00:50:21,416
只是在原本为空的对象内创建这些变量 并将
just creates those variables inside of the otherwise empty object and assigns

1022
00:50:21,416 --> 00:50:22,125
他们的价值观--
them values--

1023
00:50:22,125 --> 00:50:23,708
分别是名字和房子 
name and house, respectively.

1024
00:50:23,708 --> 00:50:26,000
让我继续在这里做一件小事 
Let me go ahead and just do one little thing here.

1025
00:50:26,000 --> 00:50:27,791
我真的不需要这个学生变量 
I don't really need this student variable.

1026
00:50:27,791 --> 00:50:31,750
让我来加强一下 这样每次我们改进或更改代码时 
Let me just tighten this up so that each time we improve or change the code,

1027
00:50:31,750 --> 00:50:35,000
我们真的只关注最小的变化 
we're focusing, really, on just the minimal changes alone.

1028
00:50:35,000 --> 00:50:37,250
所以我从根本上没有做任何不同的事情 
So I've not fundamentally done anything different.

1029
00:50:37,250 --> 00:50:39,291
我刚刚去掉了变量名 我只是
I just got rid of the variable name, and I'm just

1030
00:50:39,291 --> 00:50:43,125
返回此学生函数的返回值
returning the return value of this student function

1031
00:50:43,125 --> 00:50:45,125
这是在为我构建我的新对象 
that's constructing my new object for me.

1032
00:50:45,125 --> 00:50:48,833
因此 我只是像过去多次做的那样 收紧措施 
So I'm just tightening things up as we've done many times in the past.

1033
00:50:48,833 --> 00:50:53,291
那么 如果在创造这个学生的过程中出了什么问题呢？
Well, what if something goes wrong in creating this student?

1034
00:50:53,291 --> 00:50:56,791
例如 如果用户没有给我们提供姓名 他们只是点击
For instance, what if the user does not give us a name, and they just hit

1035
00:50:56,791 --> 00:50:58,791
系统提示输入名称时 请输入 
Enter when prompted for name.

1036
00:50:58,791 --> 00:51:01,250
我不想把我的电脑的内存
I don't want to put in my computer's memory

1037
00:51:01,250 --> 00:51:04,375
一个没有名字的假学生对象 
a bogus student object that has no name.

1038
00:51:04,375 --> 00:51:07,833
理想情况下 我甚至希望在创建它之前检查错误
I'd ideally like to check for errors before I even create it

1039
00:51:07,833 --> 00:51:09,583
所以我不会创造一个无名的学生 
so I don't create a nameless student.

1040
00:51:09,583 --> 00:51:13,791
拥有一个没有名称的对象会很奇怪 而且可能是一个错误 
It would just be weird and probably a bug to have an object that has no name.

1041
00:51:13,791 --> 00:51:16,208
同样 我不希望用户能够输入
Similarly, I don't want the user to be able to type

1042
00:51:16,208 --> 00:51:18,708
在随机的地方 比如他们的房子 
in something random as their house.

1043
00:51:18,708 --> 00:51:21,375
至少在哈利波特的世界里 真的有
At least in the world of Harry Potter, there's really

1044
00:51:21,375 --> 00:51:23,791
只有四栋房子 至少在霍格沃茨 
only four houses, at Hogwarts at least.

1045
00:51:23,791 --> 00:51:25,666
又是格兰芬多和赫奇帕奇
There's, again, Gryffindor and Hufflepuff

1046
00:51:25,666 --> 00:51:29,625
以及拉文克劳和斯莱特林--四所有效房屋的名单 
and Ravenclaw and Slytherin-- a list of four valid houses.

1047
00:51:29,625 --> 00:51:34,291
如果我以某种方式验证用户的输入确实是
It would be nice if I somehow validated that the user's input is indeed

1048
00:51:34,291 --> 00:51:35,541
在那张单子上 
in that list.

1049
00:51:35,541 --> 00:51:39,916
现在 我可以在我的Get_Student函数中执行所有的验证 
Now, I could do all of that validation in my get_student function.

1050
00:51:39,916 --> 00:51:41,750
我可以查一下 名字是空的吗？
I could check, is the name empty?

1051
00:51:41,750 --> 00:51:44,416
如果是这样的话 不要创建学生对象 
If so, don't create the student object.

1052
00:51:44,416 --> 00:51:46,666
这栋房子是那四栋房子中的一栋吗？
Is the house one of those four houses?

1053
00:51:46,666 --> 00:51:49,083
如果不是 请不要创建学生对象 
If not, don't create the student object.

1054
00:51:49,083 --> 00:51:52,750
但这将与学生本身脱钩 
But that would be rather decoupled from the student itself.

1055
00:51:52,750 --> 00:51:57,625
Get_Student目前仅作为我自己的函数存在于我的Student.py文件中 
get_student currently exists as just my own function in my student.py file.

1056
00:51:57,625 --> 00:52:01,125
但是类--以及真正的面向对象编程--更多
But classes-- and really, object-oriented programming-- more

1057
00:52:01,125 --> 00:52:05,291
通常会鼓励您在内部封装
generally encourages you to encapsulate, inside

1058
00:52:05,291 --> 00:52:09,750
类的所有功能 所有与该类相关的功能 
of a class, all functionality related to that class.

1059
00:52:09,750 --> 00:52:12,375
因此 如果你想验证一个名字是否存在--
So if you want to validate that a name exists--

1060
00:52:12,375 --> 00:52:14,750
如果你想验证房子是正确 
if you want to validate that a house is correct,

1061
00:52:14,750 --> 00:52:20,041
从根本上说属于学生这个阶层 
that belongs just fundamentally in the class called student itself,

1062
00:52:20,041 --> 00:52:22,583
而不是你在别处写的随机函数
not in some random function that you wrote elsewhere.

1063
00:52:22,583 --> 00:52:24,875
这只是一种方法 因为 
Again, this is just methodology because, again,

1064
00:52:24,875 --> 00:52:28,541
如果我们考虑写越来越长的代码 
if we think about writing code that gets longer and longer, more and more

1065
00:52:28,541 --> 00:52:31,250
很复杂 它应该只是直观的感觉 
complicated, it should make just intuitive sense that,

1066
00:52:31,250 --> 00:52:34,250
如果你保留所有的房子
if you keep all the house--

1067
00:52:34,250 --> 00:52:37,208
所有的名字和所有与房子相关的代码 
all of the name and all of the house-related code in the student,

1068
00:52:37,208 --> 00:52:38,708
只是更好的组织 
it's just better organization.

1069
00:52:38,708 --> 00:52:41,583
把所有相关的代码放在一起 
Keep all of the related code together, and that's probably

1070
00:52:41,583 --> 00:52:43,125
会让你更成功
going to set you up for more success.

1071
00:52:43,125 --> 00:52:45,166
实际上 这是我们方法论的一部分
And indeed, that's part of this methodology

1072
00:52:45,166 --> 00:52:47,125
面向对象的编程 
of object-oriented programming.

1073
00:52:47,125 --> 00:52:51,916
现在让我来给我的学生换个班
Let me go ahead now and change my students classes

1074
00:52:51,916 --> 00:52:53,875
init方法来实现 
init method to do this.

1075
00:52:53,875 --> 00:52:56,375
如果名字是空的--
If the name is blank--

1076
00:52:56,375 --> 00:52:59,333
所以如果不是name--我们以前见过这种语法 
so if not name-- and we've seen this kind of syntax before.

1077
00:52:59,333 --> 00:53:02,666
如果你在Python中说 如果不是name 
If you say in Python, Pythonically, if not name,

1078
00:53:02,666 --> 00:53:04,500
做这种事的人
that's doing something like this.

1079
00:53:04,500 --> 00:53:07,291
如果name等于 等于 引号 不引号
If name equals, equals, quote, unquote--

1080
00:53:07,291 --> 00:53:09,041
但我可以做得更优雅一点
but I can do this a little more elegantly.

1081
00:53:09,041 --> 00:53:11,958
只是说 如果没有名字 将是更多的Pythonic 
Just say, if not name, would be the more Pythonic.

1082
00:53:11,958 --> 00:53:15,583
我想返回一个错误 
Well, I want to return an error.

1083
00:53:15,583 --> 00:53:17,208
我可能想做这样的事 
I might want to do something like this.

1084
00:53:17,208 --> 00:53:18,916
打印缺少的姓名 
Print missing name.

1085
00:53:18,916 --> 00:53:20,541
但这还不够 
But this is not good enough.

1086
00:53:20,541 --> 00:53:24,000
仅仅打印缺少的姓名是不够的
It does not suffice to just print out missing name

1087
00:53:24,000 --> 00:53:26,083
然后让剩下的代码通过 
and then let the rest of the code go through.

1088
00:53:26,083 --> 00:53:27,791
好吧 好吧 那我能做什么呢？
All right, well, what could I do instead?

1089
00:53:27,791 --> 00:53:30,791
在过去 我们已经看到了另一种技术 我可以做系统退出 
In the past, we've seen another technique I could do sys.exit,

1090
00:53:30,791 --> 00:53:33,583
我可以说一些像缺少名字的东西 我可以在这里
and I could say something like missing name, and I could go up here

1091
00:53:33,583 --> 00:53:34,750
我可以导入系统 
and I could import sys.

1092
00:53:34,750 --> 00:53:37,958
但这是一个非常令人讨厌的解决问题的方法 
But this is a really obnoxious solution to the problem.

1093
00:53:37,958 --> 00:53:41,250
只是因为你或者某个同事搞砸了
Just because you or maybe a colleague messed up

1094
00:53:41,250 --> 00:53:43,750
并调用了一个具有无效名称的函数 
and called a function with an invalid name,

1095
00:53:43,750 --> 00:53:45,666
你要退出我的整个项目吗
you're going to quit my whole program?

1096
00:53:45,666 --> 00:53:49,750
这反应真的很极端
That's really, really extreme of a response,

1097
00:53:49,750 --> 00:53:52,125
如果你的程序
and you probably don't want to do that if your program is

1098
00:53:52,125 --> 00:53:53,041
在跑步的中途 
in the middle of running.

1099
00:53:53,041 --> 00:53:54,625
你可能想清理一下 
You might want to clean some stuff up.

1100
00:53:54,625 --> 00:53:57,958
您可能想要保存有时不想退出程序的文件
You might want to save files you don't want to just exit a program sometimes

1101
00:53:57,958 --> 00:54:01,208
在某些任意行中 只是因为输入无效 
in some arbitrary line, just because input was invalid.

1102
00:54:01,208 --> 00:54:03,333
因此 我认为我们也不想这么做 
So I don't think we want to do that either.

1103
00:54:03,333 --> 00:54:07,375
但我们现在确实有一种发出错误信号的机制 
But we do, now, have a mechanism for signaling errors.

1104
00:54:07,375 --> 00:54:09,500
不幸的是 我不能做这样的事 
Unfortunately, I can't do something like this.

1105
00:54:09,500 --> 00:54:13,625
我可以试着一个都不回 然后说 嗯-嗯 这个学生不存在 
I could try returning none and say, uh-uh, this student does not exist.

1106
00:54:13,625 --> 00:54:15,666
我要一分钱都不还给你 
I'm going to hand you back none instead.

1107
00:54:15,666 --> 00:54:16,916
但为时已晚 
But it's too late.

1108
00:54:16,916 --> 00:54:21,416
如果我们向下滚动到我创建学生的位置 它在第17行
If we scroll back down to where I'm creating the student, it's on line 17

1109
00:54:21,416 --> 00:54:23,083
现在我突出显示了这段代码 
now where I've highlighted this code.

1110
00:54:23,083 --> 00:54:25,541
已经创建了该学生 
The student has already been created.

1111
00:54:25,541 --> 00:54:28,750
在计算机内存中的某个地方有一个对象
There is an object somewhere in the computer's memory

1112
00:54:28,750 --> 00:54:30,375
作为一名学生 这是一种结构 
that's structured as a student.

1113
00:54:30,375 --> 00:54:32,708
只是它里面没有任何价值 
It just doesn't have any values inside of it.

1114
00:54:32,708 --> 00:54:35,541
但因此 现在什么都不回已经太晚了 
But it's too late, therefore, to return none.

1115
00:54:35,541 --> 00:54:36,666
那艘船已经启航了 
That ship has sailed.

1116
00:54:36,666 --> 00:54:37,958
该对象存在 
The object exists.

1117
00:54:37,958 --> 00:54:40,458
你不能突然说 不 不 没有物体 
You can't just suddenly say, nope, nope, there is no object.

1118
00:54:40,458 --> 00:54:41,625
有一件物品 
There is an object.

1119
00:54:41,625 --> 00:54:43,583
这取决于你是否发出错误信号 
It's up to you to signal an error.

1120
00:54:43,583 --> 00:54:45,333
如何发出错误信号？
And how do you signal an error?

1121
00:54:45,333 --> 00:54:48,083
实际上 我们以前见过这种情况 但我们还没有机会
Well, we've actually seen this before, but we haven't had occasion

1122
00:54:48,083 --> 00:54:49,583
制造我们自己的错误 
to create our own errors.

1123
00:54:49,583 --> 00:54:54,750
原来 在Python中 还有另一个与异常相关的关键字
It turns out, in Python, there's another keyword related to exceptions

1124
00:54:54,750 --> 00:54:58,583
它本身用来引发我们的所有异常
that Python itself uses to raise all of those exceptions we've

1125
00:54:58,583 --> 00:54:59,750
在过去曾被谈论过 
talked about in the past.

1126
00:54:59,750 --> 00:55:04,500
当您发现值错误或其他类似的异常时 
When you've caught things like value errors or other such exceptions that

1127
00:55:04,500 --> 00:55:09,083
和Python一起来 好吧 原来你 程序员可以提出--
come with Python, well, it turns out you, the programmer can raise--

1128
00:55:09,083 --> 00:55:12,875
那就是当某些事情真的出了问题时 创建自己的例外--
that is create your own exceptions when something just really goes wrong--

1129
00:55:12,875 --> 00:55:15,750
还没有错到你想退出并退出整个计划 
not wrong enough that you want to quit and exit the whole program,

1130
00:55:15,750 --> 00:55:18,958
但足以让您以某种方式提醒程序员
but enough that you need to somehow alert the programmer

1131
00:55:18,958 --> 00:55:20,583
这是一个错误 
that there has been an error.

1132
00:55:20,583 --> 00:55:23,583
一些不同寻常的东西 以一种非常糟糕的方式--一些东西
Something exceptional, in a very bad way-- something

1133
00:55:23,583 --> 00:55:29,250
异常已经发生 让他们在需要时尝试捕获该异常 
exceptional has happened, and let them try to catch that exception as needed.

1134
00:55:29,250 --> 00:55:32,250
因此 让我回到VS代码 并提出建议
So let me go back to VS Code here and propose

1135
00:55:32,250 --> 00:55:36,500
如果用户传入了无效的名称--它只是空的 
that, if the user passes in an invalid name-- it's just empty,

1136
00:55:36,500 --> 00:55:37,833
所以没有名字 
so there's not a name.

1137
00:55:37,833 --> 00:55:39,875
我真正想做的是这件事 
Well, what I really want to do is this.

1138
00:55:39,875 --> 00:55:43,041
我想引发一个值错误 
I want to raise a value error.

1139
00:55:43,041 --> 00:55:45,208
我们以前也见过数值错误 
And we've seen the value errors before.

1140
00:55:45,208 --> 00:55:47,833
我们以前曾意外地制造了价值错误 
We've created value errors accidentally before.

1141
00:55:47,833 --> 00:55:51,416
一般来说 如果他们发生了 你和我都会试图抓住他们 
And generally, you and I have tried to catch them if they happen.

1142
00:55:51,416 --> 00:55:55,375
嗯 在像Python这样的语言中 这种异常特性的另一面
Well, the flip side of this feature of exceptions in a language like Python

1143
00:55:55,375 --> 00:55:58,125
作为程序员 您也可以引发异常
is that you, the programmer, can also raise exceptions

1144
00:55:58,125 --> 00:56:00,000
当一些不寻常的事情发生时 
when something exceptional happens.

1145
00:56:00,000 --> 00:56:01,791
你甚至可以说得更准确 
And you can even be more precise.

1146
00:56:01,791 --> 00:56:05,250
您不必引发泛型值错误并让程序员找出
You don't have to raise a generic value error and let the programmer figure out

1147
00:56:05,250 --> 00:56:06,083
哪里出了问题 
what went wrong.

1148
00:56:06,083 --> 00:56:10,291
您可以将值错误和Python中的所有异常视为类似的函数
You can treat value error and all exceptions in Python like functions

1149
00:56:10,291 --> 00:56:14,583
并向他们传递一条解释性信息 比如 引用 不引用 
and actually pass to them an explanatory message like, quote, unquote,

1150
00:56:14,583 --> 00:56:17,875
“缺少名字” 至少让程序员在遇到
"Missing name," so that at least the programmer, when they encounter

1151
00:56:17,875 --> 00:56:19,458
这个错误 知道 哦 我搞砸了 
this error, knows, oh, I messed up.

1152
00:56:19,458 --> 00:56:22,833
我不确定该用户是否有名字 
I didn't make sure that the user has a name.

1153
00:56:22,833 --> 00:56:25,125
现在 你想做什么呢？
And now, what do you want to do instead?

1154
00:56:25,125 --> 00:56:28,708
现在 如果你是程序员 你可以做这样的事情 
Well, now, if you're the programmer, you could do something like this.

1155
00:56:28,708 --> 00:56:34,708
您可以尝试创建一个学生 除非存在值错误 
You could try to create a student except if there's a value error.

1156
00:56:34,708 --> 00:56:37,208
然后你就可以用某种方式来处理它 
Then you could handle it in some way.

1157
00:56:37,208 --> 00:56:39,500
我要用一个圆点 
And I'm going to wave my hand with a dot, dot, dot,

1158
00:56:39,500 --> 00:56:40,791
你会如何处理这件事 
at how you would handle it.

1159
00:56:40,791 --> 00:56:44,666
但您将使用尝试和接受来处理它 就像我们过去所做的那样 
But you would handle it using try and accept, just like we have in the past,

1160
00:56:44,666 --> 00:56:46,666
这将允许你 作为程序员 
and that would allow you, the programmer,

1161
00:56:46,666 --> 00:56:48,166
试图创造出这个学生 
to try to create the student.

1162
00:56:48,166 --> 00:56:52,291
但如果出了问题 好吧 我还是会处理的 
But if something goes wrong, OK, I'll handle it nonetheless.

1163
00:56:52,291 --> 00:56:54,958
所以 这里的新内容是 再一次 这个提升关键字 
So what's new here, again, is this raise keyword,

1164
00:56:54,958 --> 00:56:59,250
这只是让你和我实际上提出了我们自己的例外
that just lets you and I actually raise our own exceptions

1165
00:56:59,250 --> 00:57:00,458
发出这些错误的信号 
to signal these errors.

1166
00:57:00,458 --> 00:57:03,000
好吧 让我回到我的代码 我只是
Well, let me go back to my code here, and I'm just

1167
00:57:03,000 --> 00:57:06,208
我要继续下去 不费心尝试或捕捉这个错误 
going to go ahead and not bother trying or catching this error.

1168
00:57:06,208 --> 00:57:09,083
现在 我们只专注于提高它 并假设
For now, we'll just focus on raising it and assume

1169
00:57:09,083 --> 00:57:12,375
从我们的侦察例外中 您可以添加尝试和接受
that, from our recon exceptions, you could add try and accept

1170
00:57:12,375 --> 00:57:13,833
在一些地方需要的时候 
as needed in places.

1171
00:57:13,833 --> 00:57:16,916
让我回到这里的代码 并建议其他东西可以
Let me go back to the code here and propose that something else could

1172
00:57:16,916 --> 00:57:18,416
豪斯出事了 
go wrong with house.

1173
00:57:18,416 --> 00:57:19,791
如果有名字的话 我们就没问题了 
If there is a name, we're good.

1174
00:57:19,791 --> 00:57:22,083
但如果我们得到了一所房子 但它是无效的 
But if we're given a house but it's invalid,

1175
00:57:22,083 --> 00:57:24,958
我们也应该破例一次
we should probably raise an exception for that, too.

1176
00:57:24,958 --> 00:57:26,208
如果我们这么做呢？
So what if we do this?

1177
00:57:26,208 --> 00:57:32,208
如果豪斯不在格兰芬多的名单上 
If house is not in the list containing "Gryffindor," quote, unquote,

1178
00:57:32,208 --> 00:57:34,708
“赫奇帕奇” 原话是
"Hufflepuff," quote, unquote--

1179
00:57:34,708 --> 00:57:38,875
我想想 “拉文克劳 ”引用 不引用 或者“斯莱特林 ”
let's see, "Ravenclaw," quote, unquote, or "Slytherin,"

1180
00:57:38,875 --> 00:57:41,833
引用 引用 然后 用我的冒号 让我们
quote, unquote, then, with my colon, let's

1181
00:57:41,833 --> 00:57:43,416
引发另一种类型的值错误 
raise another type of value error.

1182
00:57:43,416 --> 00:57:45,458
但是 与其引发一般值错误 
But rather than raise a generic value error,

1183
00:57:45,458 --> 00:57:49,750
让我们传递一个参数 引用 不引用 “无效的房子 “
let's pass in an argument, quote, unquote, "Invalid house."

1184
00:57:49,750 --> 00:57:52,708
所以我们现在看到了一种能力 
And so here we now see a capability that we

1185
00:57:52,708 --> 00:57:55,916
可以用字典做不到的类 
can do with classes that we can't with dictionaries.

1186
00:57:55,916 --> 00:58:00,541
如果你给字典添加一个属性 一个键 
If you add an attribute to a dictionary, a key to a dictionary,

1187
00:58:00,541 --> 00:58:02,083
无论如何都要进去
it's going in no matter what.

1188
00:58:02,083 --> 00:58:06,000
即使名字是空的 即使房子是完全随机的字符串
Even if the name is empty, even if the house is a completely random string

1189
00:58:06,000 --> 00:58:07,833
不属于这四所房子的文字
of text that's not one of these four houses,

1190
00:58:07,833 --> 00:58:09,333
就会被收入字典里
it's going into that dictionary.

1191
00:58:09,333 --> 00:58:12,708
但是对于类 通过这个init方法 
But with a class, and by way of this init method,

1192
00:58:12,708 --> 00:58:17,750
你和我现在可以精确地控制将要安装的东西 如果你愿意的话 
you and I can now control exactly what's going to be installed, if you will,

1193
00:58:17,750 --> 00:58:19,041
在这个物体里面 
inside of this object.

1194
00:58:19,041 --> 00:58:22,458
你现在对正确性有了更多的控制 
You have a little more control now over correctness.

1195
00:58:22,458 --> 00:58:26,583
现在让我继续向下滚动到终端窗口
And so now let me go ahead and scroll back down to my terminal window

1196
00:58:26,583 --> 00:58:27,291
并清除它 
and clear it.

1197
00:58:27,291 --> 00:58:29,500
让我运行student.py的Python 
Let me run Python of student.py.

1198
00:58:29,500 --> 00:58:31,250
让我输入一些像哈里 
Let me type in something like Harry.

1199
00:58:31,250 --> 00:58:33,958
让我输入Gryffindor Enter 然后我们看到
Let me type in Gryffindor, Enter, and we see

1200
00:58:33,958 --> 00:58:35,666
哈利确实是格兰芬多的
that, indeed, Harry is from Gryffindor.

1201
00:58:35,666 --> 00:58:37,666
如果我犯了个错误呢？
What if I made a mistake, though?

1202
00:58:37,666 --> 00:58:40,750
如果我运行student.py的Python并输入Harry作为名字 
What if I ran Python of student.py and typed Harry as the name,

1203
00:58:40,750 --> 00:58:44,416
但这次输入的是女贞路四号 
but this time typed in Number Four, Privet Drive, which

1204
00:58:44,416 --> 00:58:47,500
是他长大的地方而不是他真正的霍格沃茨
is where he grew up, instead of his proper Hogwarts house.

1205
00:58:47,500 --> 00:58:51,333
现在按下Enter键 您将看到一个值错误 
Let me hit Enter now, and now you see a value error.

1206
00:58:51,333 --> 00:58:54,458
但本质上 这不是Python为我们生成的 
But this isn't one that Python generated for us, per se.

1207
00:58:54,458 --> 00:58:56,166
我提出了这个错误 
I raised this error.

1208
00:58:56,166 --> 00:58:59,666
因此 如果我在get_student函数中编写更多的代码 
And therefore, if I went in and wrote more code in my get_student function,

1209
00:58:59,666 --> 00:59:04,666
我也可以用我们常用的try except语法来捕获这个错误 
I could also catch this error with our usual try except syntax.

1210
00:59:04,666 --> 00:59:09,250
所以我们现在所拥有的不仅仅是工具箱中的类 还有更多的功能
So all we have now is not just classes in our toolkit, but even more powers

1211
00:59:09,250 --> 00:59:12,583
而不仅仅是我们自己去捕捉它们
when it comes to exceptions, and not just catching them ourselves

1212
00:59:12,583 --> 00:59:15,333
但我们自己也要抚养他们
but raising them ourselves, too.

1213
00:59:15,333 --> 00:59:21,708
关于类和init的用法还有这个能力
Any questions now on this use of classes and init and now this ability

1214
00:59:21,708 --> 00:59:26,000
在初始化过程中出错时引发异常
to raise exceptions when something goes wrong inside of the initialization?

1215
00:59:26,000 --> 00:59:29,416
观众：那么如果用户有一个中间名呢？
AUDIENCE: So what if the user has a middle name--

1216
00:59:29,416 --> 00:59:31,291
名字中间名和姓氏
name, middle name, and last name?

1217
00:59:31,291 --> 00:59:32,750
你要怎么解决？
How would you fix that?

1218
00:59:32,750 --> 00:59:35,250
大卫·J·马兰：问得好 
DAVID J. MALAN: Good question.

1219
00:59:35,250 --> 00:59:38,916
如果你想让学生有名字、中间名和姓氏 
If you wanted the student to have a first name, middle name, and last name,

1220
00:59:38,916 --> 00:59:41,041
我们可以用很多不同的方法来做 
we could do this in a bunch of different ways.

1221
00:59:41,041 --> 00:59:44,458
最简单的 如果--让我清空屏幕 
The simplest, though, if-- let me clear my screen here, and let

1222
00:59:44,458 --> 00:59:46,041
我只是暂时这么做 
me just temporarily do this.

1223
00:59:46,041 --> 00:59:51,333
让我建议init方法接受第一个参数 一个中间参数 
Let me propose that the init method take in a first argument, a middle argument,

1224
00:59:51,333 --> 00:59:53,000
最后一个论点 
and a last argument.

1225
00:59:53,000 --> 00:59:57,833
然后我想我会在这里做的是最终有第一=第一 
And then what I think I would do down here is ultimately have first = first,

1226
00:59:57,833 --> 01:00:00,916
然后我会对中间和最后做同样的事情 
and then I would do the same thing for middle and last.

1227
01:00:00,916 --> 01:00:05,541
中间和中间 最后和最后 
So middle and middle, and then last and last.

1228
01:00:05,541 --> 01:00:08,583
接下来我要做的是 
And then what I would have to do here is,

1229
01:00:08,583 --> 01:00:11,208
当我问用户他们的名字时 
when I actually ask the user for their name,

1230
01:00:11,208 --> 01:00:12,750
我可能真的需要全力以赴 
I might need to really go all out.

1231
01:00:12,750 --> 01:00:15,166
我可能要先问他们的名字
I might need to ask them first for their first name

1232
01:00:15,166 --> 01:00:18,916
并将其存储在一个名为first的变量中 因此首先传入 
and store that in a variable called first, and therefore pass in first.

1233
01:00:18,916 --> 01:00:21,833
我可能同样需要问他们的中间名
I might similarly need to ask them for their middle name

1234
01:00:21,833 --> 01:00:25,500
并将其存储在一个变量中 然后传入第二个参数 middle 
and store that in a variable and then pass in a second argument, middle.

1235
01:00:25,500 --> 01:00:28,375
最后 如果你愿意 让我继续创造
And then lastly, if you will, let me go ahead and create

1236
01:00:28,375 --> 01:00:31,916
第三个变量last 输入他们的姓氏 
a third variable called last, get the input for their last name,

1237
01:00:31,916 --> 01:00:34,041
把它也传进去 
and pass that in as well.

1238
01:00:34,041 --> 01:00:38,125
我可以只使用一个输入 只要求他们输入全名 
I could instead just use one input and just ask them for their whole name.

1239
01:00:38,125 --> 01:00:42,583
所以输入大卫·马兰 回车 或者大卫·J·马兰--三个都是 
So type in David Malan, Enter, or David J. Malan-- all three of them,

1240
01:00:42,583 --> 01:00:45,666
也许我可以用Python的split函数
and maybe I could use Python's split function,

1241
01:00:45,666 --> 01:00:47,583
也许是一个正则表达式来区分它 
maybe a regular expression to tease it apart.

1242
01:00:47,583 --> 01:00:49,625
这可能会很麻烦 因为
That's probably going to be messy because there's

1243
01:00:49,625 --> 01:00:52,083
他们的名字不会只有两三个 
going to be people who don't have just two or three names.

1244
01:00:52,083 --> 01:00:53,458
他们可能有四个或五个 
They might have four or five.

1245
01:00:53,458 --> 01:00:55,958
因此 有时使用多个提示可能更好 
So maybe sometimes it's better to have multiple prompts.

1246
01:00:55,958 --> 01:00:58,291
但这不是问题 因为 在上课的时候 
But that's not a problem because, with a class,

1247
01:00:58,291 --> 01:01:02,291
如果我们想要 我们有表现力接受更多的论点 
we have the expressiveness to take in more arguments if we want.

1248
01:01:02,291 --> 01:01:04,041
如果我们愿意 我们甚至可以列一张单子 
We could even take a list if we wanted.

1249
01:01:04,041 --> 01:01:06,916
但我认为我们可能会想要进行更多的错误检查 
But I think we'd probably want to have even more error checking then,

1250
01:01:06,916 --> 01:01:11,458
不仅是名字 而且是第一次 然后可能是中间 然后是
not just for name but for first, and then maybe for middle, and then

1251
01:01:11,458 --> 01:01:12,208
也许是最后一次 
maybe for last.

1252
01:01:12,208 --> 01:01:14,541
所以它只是越来越多的代码 尽管会有
So it just is more and more code, though there would be

1253
01:01:14,541 --> 01:01:17,041
或许也有巩固这一点的方法 
ways to perhaps consolidate that, too.

1254
01:01:17,041 --> 01:01:22,500
让我把所有这些都撤销 看看现在课堂上是否还有其他问题 
Let me undo all of that and see if there are other questions now on classes.

1255
01:01:22,500 --> 01:01:24,291
观众：我想上课是我
AUDIENCE: I assume classes are something I

1256
01:01:24,291 --> 01:01:25,916
在项目开始时可能会做的事情 
might do at the beginning of a project.

1257
01:01:25,916 --> 01:01:28,583
我可以将它们放在不同的文件中并导入它们吗
Can I just put them in a different file and import them

1258
01:01:28,583 --> 01:01:32,083
根据需要添加到我的项目中 还是我的主代码中？
into my project, or my main code as needed?

1259
01:01:32,083 --> 01:01:33,208
大卫·J·马兰：当然 
DAVID J. MALAN: Absolutely.

1260
01:01:33,208 --> 01:01:34,208
这是一个非常好的问题 
A really good question.

1261
01:01:34,208 --> 01:01:36,083
你可以想象想要利用这个学生
You could imagine wanting to use this student

1262
01:01:36,083 --> 01:01:40,666
类 不仅在Student.py中 而且在您的其他文件或其他项目中 
class, not just in student.py but in other files or other projects of yours.

1263
01:01:40,666 --> 01:01:44,458
当然 您可以创建自己的类库
And absolutely, you can create your own library of classes

1264
01:01:44,458 --> 01:01:48,000
通过将学生类放入您自己的模块或包中 
by putting the student class in your own module or package,

1265
01:01:48,000 --> 01:01:50,583
根据我们过去对图书馆更一般的讨论 
per our discussion in the past about libraries more generally.

1266
01:01:50,583 --> 01:01:52,250
当然 你可以做到的 
And absolutely, you can do that.

1267
01:01:52,250 --> 01:01:54,833
今天晚些时候 我们看到的是我们实际上
And later today, what we see is we've actually

1268
01:01:54,833 --> 01:01:58,166
我以前一直在第三方库中使用类--你和我 
been using classes-- you and I-- before, in third party libraries.

1269
01:01:58,166 --> 01:02:00,416
所以你也完全可以做同样的事情 
So you, too, can absolutely do the same.

1270
01:02:00,416 --> 01:02:03,666
再问一个关于课上的问题如何？
How about one more question on classes?

1271
01:02:03,666 --> 01:02:06,541
听众：你可以在类中有可选变量吗？
AUDIENCE: Can you have optional variables in classes?

1272
01:02:06,541 --> 01:02:09,666
第二 你能有自己的错误名称吗 比如--
And two, can you have your own error names, like--

1273
01:02:09,666 --> 01:02:13,250
让我们以自我为中心 说我想提出Eric Error？
let's be egotistical and say I want to raise Eric error?

1274
01:02:13,250 --> 01:02:16,166
大卫·J·马兰：简而言之 是的 
DAVID J. MALAN: Short answer, yes.

1275
01:02:16,166 --> 01:02:18,750
这些初始化函数更像是Python函数
These init functions are just like Python functions more

1276
01:02:18,750 --> 01:02:21,000
一般说来 尽管它们很特别 但它们
generally, even though they're special in that they're

1277
01:02:21,000 --> 01:02:23,666
它将自动由Python为您调用 
going to get called automatically by Python for you.

1278
01:02:23,666 --> 01:02:25,375
但如果你想让房子变成可选的 
But if you wanted to make house optional,

1279
01:02:25,375 --> 01:02:26,750
你可以做这样的事情 
you could do something like this.

1280
01:02:26,750 --> 01:02:31,791
您可以在init函数的签名中给它一个缺省值
You could give it a default value in the init function's signature

1281
01:02:31,791 --> 01:02:34,250
可以这么说--在第二行第一行代码中 
so to speak-- in that first line of code on line two.

1282
01:02:34,250 --> 01:02:36,875
这样我就不用进屋了 
And that would allow me to not have to pass in house.

1283
01:02:36,875 --> 01:02:39,750
在这种情况下 我将继续传递姓名和住所 
In this case, I'm going to continue to always pass in name and house,

1284
01:02:39,750 --> 01:02:41,500
但你可以把这些设置为可选的 
but you could make things optional.

1285
01:02:41,500 --> 01:02:45,458
是的 关于你的第二个问题 如果你想有你自己的错误信息 
And yes, to your second question, if you wanted to have your own error message,

1286
01:02:45,458 --> 01:02:50,791
就像Eric错误一样 您实际上可以创建自己的Eric错误异常 
like an Eric error, you could actually create your own Eric error exception.

1287
01:02:50,791 --> 01:02:53,000
稍后我们会看到 实际上
And we'll see, in a little bit, that there's actually

1288
01:02:53,000 --> 01:02:58,041
一整套存在的例外 你也可以发明这些例外 
a whole suite of exceptions that exist, and you, too, can invent those as well.

1289
01:02:58,041 --> 01:03:01,375
不过 让我提议 我们现在介绍
Let me propose, though, that we now introduce

1290
01:03:01,375 --> 01:03:06,250
另一个方面是 我们尝试打印出学生的样子 
one other aspect of this whereby we try printing out what a student looks like.

1291
01:03:06,250 --> 01:03:08,916
目前 如果我向下滚动到我的主要功能 
At the moment, if I scroll back down to my main function,

1292
01:03:08,916 --> 01:03:11,791
我还在非常手动地打印这名学生的姓名和住处 
I'm still printing the student's name and house very manually.

1293
01:03:11,791 --> 01:03:14,833
我要进入物体的内部 做学生 名字 
I'm going inside of the object, doing student.name,

1294
01:03:14,833 --> 01:03:17,708
我要再次进入这个物体 让学生 房子 
and I'm going inside of the object again and getting student.house,

1295
01:03:17,708 --> 01:03:20,750
只是想看看这名学生来自哪里 
just to see where the student is from.

1296
01:03:20,750 --> 01:03:23,666
但如果我能把学生的指纹印出来 
But wouldn't it be nice if I could just print the student,

1297
01:03:23,666 --> 01:03:25,583
就像我已经打印了几个星期--
like I've been printing for weeks--

1298
01:03:25,583 --> 01:03:29,458
ANY、INT或FLOAT、STR或任何其他数据类型？
any, int, or float, or str, or any other data type?

1299
01:03:29,458 --> 01:03:32,500
好吧 让我们看看如果我试着打印学生会发生什么 
Well, let's see what happens if I just try printing the student,

1300
01:03:32,500 --> 01:03:36,166
而不是手动进入并试图自己创建这句话 
instead of manually going inside and trying to create that sentence myself.

1301
01:03:36,166 --> 01:03:39,250
好的 在我的终端窗口中--让我继续运行PYTHON of Student.py
Well, in my terminal window-- let me go ahead and run Python of student.py

1302
01:03:39,250 --> 01:03:40,166
再来一次 
again.

1303
01:03:40,166 --> 01:03:41,250
让我输入哈里 
Let me type in Harry.

1304
01:03:41,250 --> 01:03:42,541
让我输入格兰芬多 
Let me type in Gryffindor.

1305
01:03:42,541 --> 01:03:50,333
看 哈利--哇 好的 主要学生对象在0x102733e80 
And voila, Harry-- whoa, OK, main student object at 0x102733e80.

1306
01:03:50,333 --> 01:03:51,916
好吧 这是怎么回事？
Well, what is going on?

1307
01:03:51,916 --> 01:03:53,708
如果你要运行相同的代码 你
Well, if you were to run the same code, you

1308
01:03:53,708 --> 01:03:56,000
可能会在您的计算机上看到一些不同的内容
might actually see something different on your computer

1309
01:03:56,000 --> 01:03:57,208
就这个数字而言 
in terms of that number.

1310
01:03:57,208 --> 01:04:01,958
但你真正看到的是潜在的表示 作为一个字符串 
But what you're really seeing is the underlying representation, as a string,

1311
01:04:01,958 --> 01:04:03,625
这一特定物体的 
of this specific object.

1312
01:04:03,625 --> 01:04:06,875
特别是 您可以看到它在计算机内存中的什么位置 
In particular, you're seeing where in the computer's memory it is.

1313
01:04:06,875 --> 01:04:12,750
这个数字30x102733e80实质上指的是一个特定的位置
This number, 30x102733e80, refers to, essentially, a specific location

1314
01:04:12,750 --> 01:04:14,541
在计算机的内存或RAM中 
in the computer's memory or RAM.

1315
01:04:14,541 --> 01:04:19,166
这对我或你来说都不是很有趣 或者 总的来说 
That's not really that interesting for me or you or, generally speaking,

1316
01:04:19,166 --> 01:04:22,250
程序员 但这只是默认的描述方式 
programmers, but it's just the default way of describing,

1317
01:04:22,250 --> 01:04:25,791
通过印刷品 这是什么东西 
via print, what this thing is.

1318
01:04:25,791 --> 01:04:28,250
但我也可以推翻这一点 
But I can override this as well.

1319
01:04:28,250 --> 01:04:31,791
原来 在Python中还有其他特殊的方法
It turns out that there are other special methods in Python

1320
01:04:31,791 --> 01:04:32,958
当涉及到课程时--
when it comes to classes--

1321
01:04:32,958 --> 01:04:36,375
不只是下划线 初始化 下划线 
not just underscore underscore, init, underscore underscore,

1322
01:04:36,375 --> 01:04:40,541
但是 继续使用相同模式 在下划线、字符串
but, continuing in that same pattern, underscore underscore, str,

1323
01:04:40,541 --> 01:04:42,041
下划线 
underscore underscore.

1324
01:04:42,041 --> 01:04:47,000
因此 这也是一个特殊的方法 如果您在类中定义它 
So this, too, is a special method that, if you define it inside of your class,

1325
01:04:47,000 --> 01:04:50,541
Python将自动调用此函数
Python will just automatically call this function

1326
01:04:50,541 --> 01:04:56,541
任何时候 某个其他函数想要将您的对象视为字符串 
for you any time some other function wants to see your object as a string.

1327
01:04:56,541 --> 01:04:59,750
Print希望将您的对象显示为字符串 
Print wants to see your object as a string.

1328
01:04:59,750 --> 01:05:02,958
但默认情况下 如果您的类中没有定义此方法 
But by default, if you don't have this method defined in your class,

1329
01:05:02,958 --> 01:05:06,416
它将打印出非常难看的深奥的化身 
it's going to print out that very ugly esoteric incarnation thereof,

1330
01:05:06,416 --> 01:05:10,416
其中写着Main__ 学生对象在0x 点 
where it says main__.Student object at 0x, dot, dot, dot.

1331
01:05:10,416 --> 01:05:13,250
那么 我该如何定义自己的str函数呢？
Well, how can I then define my own str function?

1332
01:05:13,250 --> 01:05:17,041
好了 回到VS Code 让我提议我进入
Well, here, back in VS Code, let me propose that I go in

1333
01:05:17,041 --> 01:05:23,416
不仅定义__init 还让我在这个类中定义第二个函数
and define not just __ init, but let me define a second function in this class

1334
01:05:23,416 --> 01:05:25,041
这里 如下所示--
here, as follows--

1335
01:05:25,041 --> 01:05:28,416
定义__字符串__ 
def __ str __.

1336
01:05:28,416 --> 01:05:29,333
有两个 
There are two.

1337
01:05:29,333 --> 01:05:32,541
尽管VS代码中的字体将这两个下划线放得如此之近 
Even though the font in VS Code is putting the two underscore so close,

1338
01:05:32,541 --> 01:05:34,375
它看起来就像是一个更长的下划线 
it just looks like a longer underscore.

1339
01:05:34,375 --> 01:05:37,583
确实有两个 在左边和右边 就像init一样 
There are indeed two there, on the left and the right just like for init.

1340
01:05:37,583 --> 01:05:42,791
这一论点只有一个论点 按照惯例 总是被称为自我
This one only takes one argument that, by convention, is always called self

1341
01:05:42,791 --> 01:05:44,500
这样你就可以访问它了 
so that you have access to it.

1342
01:05:44,500 --> 01:05:47,708
然后 在冒号后面缩进 
And then, indented below that after a colon,

1343
01:05:47,708 --> 01:05:51,125
我将继续创建格式字符串并返回它 
I'm going to go ahead and create a format string and return it.

1344
01:05:51,125 --> 01:05:53,500
所以让我继续下去 回到--
So let me go ahead and return--

1345
01:05:53,500 --> 01:05:56,375
不如先说个普通的词 比如“一个学生” 
how about something generic first like "a student."

1346
01:05:56,375 --> 01:05:58,916
所以我甚至不会费心去找出
So I'm not going to bother even trying to figure out

1347
01:05:58,916 --> 01:06:00,625
这个学生的名字或住处是什么 
what this student's name or house is.

1348
01:06:00,625 --> 01:06:02,875
我只会一直返回“一个学生” 
I'm just going to always return "a student."

1349
01:06:02,875 --> 01:06:08,666
现在让我回到我之前的代码 它在第16行有print(Student) 
Let me go back now to my earlier code, which has print (student) on line 16.

1350
01:06:08,666 --> 01:06:13,041
让我清除我的终端窗口 并重新运行Student.py的Python 回车 
Let me clear my terminal window and rerun Python of student.py, Enter.

1351
01:06:13,041 --> 01:06:14,958
输入哈里 输入格兰芬多 
Type in Harry, type in Gryffindor.

1352
01:06:14,958 --> 01:06:17,333
上一次 我看到了非常神秘的输出 
Last time, I saw that very cryptic output.

1353
01:06:17,333 --> 01:06:20,958
这一次 我看到 更笼统地说 “一个学生” 
This time, I see, more generically, "a student."

1354
01:06:20,958 --> 01:06:23,375
更具可读性 但不太有启发性 
More readable but not very enlightening.

1355
01:06:23,375 --> 01:06:24,541
这是哪个学生？
Which student is this?

1356
01:06:24,541 --> 01:06:31,791
注意 双下划线字符串方法在这个self参数中接受
Well, notice that the double underscore str method takes in this self argument

1357
01:06:31,791 --> 01:06:36,708
默认情况下 这正是Python作者设计此方法的方式 
by default. It's just the way the Python authors designed this method.

1358
01:06:36,708 --> 01:06:41,833
它将始终被传递一个对当前学生对象的引用 
It will always be passed a reference to the current student object.

1359
01:06:41,833 --> 01:06:43,000
我这么说是什么意思？
What do I mean by that?

1360
01:06:43,000 --> 01:06:45,916
当调用第6行上的这行代码时 
When this line of code on line 6 is called,

1361
01:06:45,916 --> 01:06:48,666
打印 因为它希望它会得到一个字符串 
print, because it's hoping it's going to get a string,

1362
01:06:48,666 --> 01:06:52,750
将触发下划线、字符串、下划线
is going to trigger the underscore underscore, str, underscore

1363
01:06:52,750 --> 01:06:54,458
给要调用的方法加下划线 
underscore method to be called.

1364
01:06:54,458 --> 01:06:58,416
对于您来说 Python将自动传递到该方法中
And Python, for you, automatically is going to pass into that method

1365
01:06:58,416 --> 01:07:01,208
引用正在尝试成为的对象
a reference to the object that's trying to be

1366
01:07:01,208 --> 01:07:05,291
打印出来 这样作为程序员 您就可以做这样的事情 
printed so that you, the programmer, can do something like this.

1367
01:07:05,291 --> 01:07:08,000
和往常一样 这里有一个带有双引号的f字符串 
Here's an f string with double quotes as usual.

1368
01:07:08,000 --> 01:07:10,458
我要用一些花括号 然后说打印出来
I'm going to use some curly braces and say print out

1369
01:07:10,458 --> 01:07:14,250
来自self.house的self.name 
self.name from self.house.

1370
01:07:14,250 --> 01:07:17,458
所以我刚才所做的并没有什么新意 
So there's nothing new in what I've just done.

1371
01:07:17,458 --> 01:07:19,958
这只是一个f弦--开头是f 
It's just an f string-- an f on the beginning,

1372
01:07:19,958 --> 01:07:22,708
两个双引号 几对花括号 
two double quotes, a couple of pairs of curly braces.

1373
01:07:22,708 --> 01:07:28,750
但这是因为 可以说 这个字符串方法会自动传递给自己 
But because, automatically, this str method gets passed self, so to speak,

1374
01:07:28,750 --> 01:07:32,333
对当前对象的引用 我可以进入该对象的内部
a reference to the current object, I can go inside of that object

1375
01:07:32,333 --> 01:07:33,083
然后取下名字 
and grab the name.

1376
01:07:33,083 --> 01:07:36,000
我可以再一次进入那个物体里面 然后拿到房子 
I can go inside that object again and grab the house.

1377
01:07:36,000 --> 01:07:38,791
所以现在 当我回到我的终端窗口--
So now, when I go back to my terminal window--

1378
01:07:38,791 --> 01:07:41,041
此前 它只是打印出了一个学生 
previously it just printed out a student.

1379
01:07:41,041 --> 01:07:44,416
但现在 如果我运行Student.py的Python 输入--
But now, if I run Python of student.py, Enter--

1380
01:07:44,416 --> 01:07:48,083
输入Harry 输入Gryffindor 然后再按一次Enter 
type in Harry, type in Gryffindor, and one more time hit Enter,

1381
01:07:48,083 --> 01:07:50,750
哈利又是从格兰芬多来的 
Harry is again from Gryffindor.

1382
01:07:50,750 --> 01:07:52,500
但如果我再运行一次--
But if I run this yet again--

1383
01:07:52,500 --> 01:07:57,125
比方说 德拉科来自斯莱特林 回车 
let's, for instance, do Draco is from Slytherin, Enter.

1384
01:07:57,125 --> 01:07:58,625
德拉科来自斯莱特林 
Draco's from Slytherin.

1385
01:07:58,625 --> 01:08:04,291
现在 它针对我们试图打印的特定对象进行了定制 
Now it's customized to the specific object that we're trying to print.

1386
01:08:04,291 --> 01:08:08,250
关于这个功能的问题--
Questions on this function here--

1387
01:08:08,250 --> 01:08:11,666
此DUnder字符串方法 
this Dunder str method.

1388
01:08:11,666 --> 01:08:14,541
观众：下划线还有什么要强调的吗？
AUDIENCE: Is there anything else that the underscore underscore,

1389
01:08:14,541 --> 01:08:16,666
字符串方法能做什么？
str method can do?

1390
01:08:16,666 --> 01:08:19,416
另一个问题是 str和epr之间有什么不同 
The other question is, what's the difference between str and repr.

1391
01:08:19,416 --> 01:08:20,750
大卫·J·马兰：问得好 
DAVID J. MALAN: A good question.

1392
01:08:20,750 --> 01:08:24,458
因此 还有许多其他方法随Python类一起提供
So there are many other methods that come with Python classes

1393
01:08:24,458 --> 01:08:26,041
这是以下划线开始的 
that start with underscore underscore.

1394
01:08:26,041 --> 01:08:27,958
我们只是触及了皮毛 我们几乎会
We're just scratching the surface, and we'll pretty much

1395
01:08:27,958 --> 01:08:29,083
主要集中在这些方面 
focus primarily on these.

1396
01:08:29,083 --> 01:08:30,833
但是 是的 还有很多其他的 我们会
But yes, there are many others, and we'll

1397
01:08:30,833 --> 01:08:33,666
至少在一小段时间内能看到另一个 
see at least one other in just a little bit.

1398
01:08:33,666 --> 01:08:37,375
其中有一个名为REPR的软件 它是
Among the others is one called repr, which is

1399
01:08:37,375 --> 01:08:39,583
Python对象的表示形式 
a representation of the Python object.

1400
01:08:39,583 --> 01:08:43,000
一般而言 下划线、REPR、
Generally speaking, the underscore underscore, repr,

1401
01:08:43,000 --> 01:08:45,791
下划线方法是给开发人员看的 
underscore underscore method is meant for developers' eyes.

1402
01:08:45,791 --> 01:08:49,166
它通常比《格兰芬多来的哈利》有更多的信息 
It typically has more information than "Harry from Gryffindor."

1403
01:08:49,166 --> 01:08:53,083
它还会说明它是什么类型的对象 比如学生、首都
It would also say what type of object it is, like a student, capital

1404
01:08:53,083 --> 01:08:56,583
S 而下划线、字符串、下划线通常是
S, whereas underscore underscore, str, underscore underscore is generally

1405
01:08:56,583 --> 01:08:58,125
面向用户--
meant for users--

1406
01:08:58,125 --> 01:09:01,500
该程序的用户 它的目的是更友好的用户 
the users of the program, and it's meant to be even more user-friendly.

1407
01:09:01,500 --> 01:09:04,208
但这两个都可以在你认为合适的情况下被推翻 
But both of those can be overridden as you see fit.

1408
01:09:04,208 --> 01:09:08,041
好吧 现在让我提议 我们继续我们停止的学生
Well, let me propose now that we pick up where we've left off on student

1409
01:09:08,041 --> 01:09:11,958
添加更多的功能 但不仅仅是这些特殊的方法
and just add even more functionality, but not just these special methods

1410
01:09:11,958 --> 01:09:15,166
如双下划线init和双下划线str 
like double underscore init and double underscore str.

1411
01:09:15,166 --> 01:09:18,750
让我们创建我们自己的方法 因为这是真正的力量所在
Let's create our own methods because therein lies the real power

1412
01:09:18,750 --> 01:09:21,875
以及类的灵活性 如果你和我都是程序员
and flexibility of classes if you and I as the programmers

1413
01:09:21,875 --> 01:09:25,291
可以发明专门针对学生的新功能 
can invent new functionality that's specific to students.

1414
01:09:25,291 --> 01:09:29,125
例如 霍格沃茨的学生 在校期间 
For instance, students at Hogwarts, over the time in school,

1415
01:09:29,125 --> 01:09:31,500
学习如何施展某种类型的咒语 
learn how to cast a certain type of spell.

1416
01:09:31,500 --> 01:09:34,083
所以当他们说 Expeto Patronum时 
So when they say, Expecto Patronum, something

1417
01:09:34,083 --> 01:09:36,083
从他们的魔杖里出来的东西通常类似于
comes out of their wand that typically resembles

1418
01:09:36,083 --> 01:09:37,458
一种动物之类的东西 
an animal or something like that.

1419
01:09:37,458 --> 01:09:40,000
这是一种特殊的咒语 他们必须练习和练习 
It's a special spell that they have to practice and practice.

1420
01:09:40,000 --> 01:09:44,041
所以让我们看看我们是否不能存储 不仅仅是学生的名字和他们的房子 
So let's see if we can't store, not just the student's name and their house,

1421
01:09:44,041 --> 01:09:47,041
还有他们的“守护神” 实际上 他们
but also their "patronus," what, actually, they

1422
01:09:47,041 --> 01:09:48,625
在使用这个咒语时召唤 
conjure when using this spell.

1423
01:09:48,625 --> 01:09:50,750
好吧 让我继续清理我的终端窗口 
Well, let me go ahead and clear my terminal window.

1424
01:09:50,750 --> 01:09:56,583
在我代码的顶部 在学生的init方法中 让我继续
And in the top of my code here, in the init method of Student, let me go ahead

1425
01:09:56,583 --> 01:10:00,875
并开始期待除了self之外的第三个参数 这会自动
and start expecting a third argument, in addition to self, which automatically

1426
01:10:00,875 --> 01:10:02,833
被传递进来 被称为守护神 
gets passed in, called patronus.

1427
01:10:02,833 --> 01:10:06,125
现在 我不会担心 关于验证
And I'm not going to worry, for now, on validating

1428
01:10:06,125 --> 01:10:10,041
官方有效赞助人名单中的赞助人或赞助人 
the patronus from an official list of valid patronuses, or patroni.

1429
01:10:10,041 --> 01:10:13,041
相反 我将继续并盲目地分配
I'm instead going to go ahead and just blindly assign

1430
01:10:13,041 --> 01:10:16,458
它属于自己 守护神=守护神 而我们
it to self.patronus = patronus, and we're

1431
01:10:16,458 --> 01:10:19,083
现在将允许用户输入他们想要的任何内容 
going to let the user type whatever they want for now.

1432
01:10:19,083 --> 01:10:21,333
但是我当然可以添加更多的错误检查
But I could certainly add more error checking

1433
01:10:21,333 --> 01:10:25,583
如果我想把赞助人限制在这里的特定名单上 
if I wanted to limit the patronus to a specific list of them here.

1434
01:10:25,583 --> 01:10:29,000
现在让我继续并提示用户输入此守护神 
Let me go ahead now and prompt the user for this patronus,

1435
01:10:29,000 --> 01:10:33,666
在我的Get_Student函数中 通过定义一个变量
as by-- in my get_student function-- defining a variable

1436
01:10:33,666 --> 01:10:36,375
被称为守护神或其他任何东西 提示用户
called patronus or anything else, prompting the user

1437
01:10:36,375 --> 01:10:38,333
为他们的守护神提供意见 
for input for their patronus.

1438
01:10:38,333 --> 01:10:42,708
现在我要继续 传递第三个变量 
And now I'm going to go ahead and pass in that third variable here.

1439
01:10:42,708 --> 01:10:46,041
因此 在精神上类似于只是添加越来越多的属性
So again, similar in spirit to just adding more and more attributes

1440
01:10:46,041 --> 01:10:47,875
对全班同学来说 我要把三门课都通过
to the class, I'm going to pass in all three

1441
01:10:47,875 --> 01:10:49,791
而不是只有两个 
of these values instead of just two.

1442
01:10:49,791 --> 01:10:52,333
我还不打算用这个值做任何有趣的事情 
I'm not going to do anything interesting with that value yet.

1443
01:10:52,333 --> 01:10:55,583
但为了确保我不会因为破坏密码而让事情更糟 
But just to make sure I haven't made things worse by breaking my code,

1444
01:10:55,583 --> 01:10:57,875
让我运行Student.py的Python 
let me run Python of student.py.

1445
01:10:57,875 --> 01:10:59,083
我来打哈里 
I'll type in Harry.

1446
01:10:59,083 --> 01:11:00,416
我会打进格兰芬多 
I'll type in Gryffindor.

1447
01:11:00,416 --> 01:11:02,500
结果发现他的守护神是一只雄鹿 
And it turns out his patronus was a stag, .

1448
01:11:02,500 --> 01:11:06,125
然后按回车键我还没有看到他的庇护在我的输出中是什么
And hit Enter I haven't seen what his patronus is in my output

1449
01:11:06,125 --> 01:11:08,708
因为我还没有更改我的str方法 
because I didn't change my str method yet.

1450
01:11:08,708 --> 01:11:10,625
但至少我没有任何语法错误 
But at least I don't have any syntax errors.

1451
01:11:10,625 --> 01:11:12,958
所以至少我没有让事情变得更糟 
So at least I've not made anything worse.

1452
01:11:12,958 --> 01:11:16,416
但是假设 现在 我想要有功能 而不仅仅是
But suppose, now, I want to have functionality, not just

1453
01:11:16,416 --> 01:11:19,708
用于初始化学生并打印出学生 
for initializing a student and printing out a student.

1454
01:11:19,708 --> 01:11:23,666
如果我的班级真的是一名学生 我能做的是
If my class is really meant to be a student, what I can do

1455
01:11:23,666 --> 01:11:27,416
不仅仅是记住有关学生数据的信息 
is not just remember information about data about students.

1456
01:11:27,416 --> 01:11:31,291
与字典不同 课堂的强大之处在于 
What's powerful about classes, unlike dictionaries alone,

1457
01:11:31,291 --> 01:11:36,708
is that classes can have, not just variables or instance variables--
is that classes can have, not just variables or instance variables--

1458
01:11:36,708 --> 01:11:38,625
those attributes we keep creating.
those attributes we keep creating.

1459
01:11:38,625 --> 01:11:42,458
They can also have functions built in, a.k.a.
They can also have functions built in, a.k.a.

1460
01:11:42,458 --> 01:11:43,083
methods.
methods.

1461
01:11:43,083 --> 01:11:45,958
When a function is inside of a class, it's called a "method,"
When a function is inside of a class, it's called a "method,"

1462
01:11:45,958 --> 01:11:47,666
but it's still just a function.
but it's still just a function.

1463
01:11:47,666 --> 01:11:51,000
At this point, we've seen two functions already-- two methods--
At this point, we've seen two functions already-- two methods--

1464
01:11:51,000 --> 01:11:54,958
called a double underscore init and double underscore str,
called a double underscore init and double underscore str,

1465
01:11:54,958 --> 01:11:57,958
but those are special methods in that they just work.
but those are special methods in that they just work.

1466
01:11:57,958 --> 01:12:01,416
If you define them, Python calls them automatically for you.
If you define them, Python calls them automatically for you.

1467
01:12:01,416 --> 01:12:04,958
But what if you wanted to create more functionality for a student
But what if you wanted to create more functionality for a student

1468
01:12:04,958 --> 01:12:09,000
so that your class really represents this real world, or maybe "fantasy"
so that your class really represents this real world, or maybe "fantasy"

1469
01:12:09,000 --> 01:12:13,375
world notion of a student, where students not only have names and houses
world notion of a student, where students not only have names and houses

1470
01:12:13,375 --> 01:12:16,375
and patronuses; they also have functionality.
and patronuses; they also have functionality.

1471
01:12:16,375 --> 01:12:22,541
They have actions they can perform like casting a charm, a spell, magically.
They have actions they can perform like casting a charm, a spell, magically.

1472
01:12:22,541 --> 01:12:26,333
Could we implement, therefore, a function called charm, that
Could we implement, therefore, a function called charm, that

1473
01:12:26,333 --> 01:12:30,291
actually uses their magical knowledge?
actually uses their magical knowledge?

1474
01:12:30,291 --> 01:12:33,791
Well, let's go ahead and define our very own function as follows.
Well, let's go ahead and define our very own function as follows.

1475
01:12:33,791 --> 01:12:37,583
Let me clear my terminal window, scroll back up to my student class.
Let me clear my terminal window, scroll back up to my student class.

1476
01:12:37,583 --> 01:12:40,916
And instead of creating yet another function that's special,
And instead of creating yet another function that's special,

1477
01:12:40,916 --> 01:12:45,416
with double underscores, I'm going to invent my own function, or method,
with double underscores, I'm going to invent my own function, or method,

1478
01:12:45,416 --> 01:12:46,916
inside of this class.
inside of this class.

1479
01:12:46,916 --> 01:12:51,500
I want to give Harry and Hermione and all of the other students
I want to give Harry and Hermione and all of the other students

1480
01:12:51,500 --> 01:12:55,000
the ability to cast charms, so I'm going to define a function that I
the ability to cast charms, so I'm going to define a function that I

1481
01:12:55,000 --> 01:12:57,291
can completely, on my own, call charm.
can completely, on my own, call charm.

1482
01:12:57,291 --> 01:12:59,125
I could call this function anything I want.
I could call this function anything I want.

1483
01:12:59,125 --> 01:13:01,708
But because it's a method inside of a class,
But because it's a method inside of a class,

1484
01:13:01,708 --> 01:13:06,083
the convention is that it's always going to take at least one argument, called
the convention is that it's always going to take at least one argument, called

1485
01:13:06,083 --> 01:13:11,000
self, by convention so that you have access to the current object,
self, by convention so that you have access to the current object,

1486
01:13:11,000 --> 01:13:13,083
even if you don't plan to use it, per se.
even if you don't plan to use it, per se.

1487
01:13:13,083 --> 01:13:16,708
All right, let me go ahead and propose that we implement charm in such a way
All right, let me go ahead and propose that we implement charm in such a way

1488
01:13:16,708 --> 01:13:21,750
that the method returns an emoji that's appropriate for each student's
that the method returns an emoji that's appropriate for each student's

1489
01:13:21,750 --> 01:13:23,125
patronus.
patronus.

1490
01:13:23,125 --> 01:13:25,750
如何实现这一点--嗯 在Charm方法内部 
How to implement this-- well, inside of the charm method,

1491
01:13:25,750 --> 01:13:29,041
让我们继续比赛吧 帕特诺斯 
let's go ahead and match on self.patronus,

1492
01:13:29,041 --> 01:13:31,416
它是包含一个字符串的实例变量 该字符串
which is the instance variable containing a string that

1493
01:13:31,416 --> 01:13:33,458
代表每个学生的资助人 
represents each student's patronus.

1494
01:13:33,458 --> 01:13:38,208
如果它与一只雄鹿匹配 例如 对于哈里 让我们继续
And in the case that it matches a stag, for instance, for Harry, let's go ahead

1495
01:13:38,208 --> 01:13:40,333
并返回最接近的表情符号--
and return maybe the closest emoji--

1496
01:13:40,333 --> 01:13:41,750
这匹马在这里 
this horse here.

1497
01:13:41,750 --> 01:13:44,625
以水獭为例呢？
How about in the case of an otter?

1498
01:13:44,625 --> 01:13:49,708
好吧 那样的话 让我们继续回去吧 哦 也许是最接近的匹配
Well, in that case, let's go ahead and return, oh, maybe the closest match

1499
01:13:49,708 --> 01:13:52,583
这可能就是这个表情符号 
to the otter, which might be this emoji here.

1500
01:13:52,583 --> 01:13:57,000
让我们看看 在a的情况下 对于罗恩 而不是赫敏
And let's see, in the case of a-- for Ron, rather than Hermione--

1501
01:13:57,000 --> 01:14:02,791
一只杰克·罗素梗犬 让我们继续前进并返回--
a Jack Russell terrier, let's go ahead and return--

1502
01:14:02,791 --> 01:14:04,625
在这里没有那么多的选择 
don't have as many options here.

1503
01:14:04,625 --> 01:14:08,750
如果是那样的话 我们为什么不把最可爱的狗还回去呢？
Why don't we go ahead and return the cutest available dog in that case.

1504
01:14:08,750 --> 01:14:14,250
在不承认赞助人的情况下 
And in the case of no patronus recognized,

1505
01:14:14,250 --> 01:14:16,375
就像覆盖像德拉科这样的人一样 我们继续
as might cover someone like Draco, let's go ahead

1506
01:14:16,375 --> 01:14:19,750
并像过去一样使用使用下划线的默认大小写 
and use a default case using the underscore as in the past,

1507
01:14:19,750 --> 01:14:22,791
让我们继续下去 回到这个--哦 会发生什么
and let's go ahead and return for this-- oh, what should happen

1508
01:14:22,791 --> 01:14:24,250
如果有人没有守护神呢？
if someone doesn't have a patronus?

1509
01:14:24,250 --> 01:14:26,541
为什么我们不直接看看魔杖呢？
Why don't we just see a magical wand that

1510
01:14:26,541 --> 01:14:28,958
似乎失败了 就像这件事一样？
seems to fizzle out, as in this case?

1511
01:14:28,958 --> 01:14:31,333
好的 现在 与其只打印学生的照片 
All right, well, now, rather than just print the student,

1512
01:14:31,333 --> 01:14:33,375
让我们开始打印他们的实际赞助人吧 
let's go about printing their actual patronus.

1513
01:14:33,375 --> 01:14:36,000
因此 我将在这里介绍我的主要功能 
So I'm going to go down to my main function here.

1514
01:14:36,000 --> 01:14:39,250
使用Get_Student函数 我仍将获得一名学生 
I'm going to still get a student, using the get_student function.

1515
01:14:39,250 --> 01:14:44,208
但是 与其打印学生 不如让我们宣布“Exspecto Patronum！”
But rather than print student, let's go ahead and declare "Expecto Patronum!"

1516
01:14:44,208 --> 01:14:46,791
仅将其作为纯文本打印出来 
printing out just that as pure text.

1517
01:14:46,791 --> 01:14:50,750
现在让我们继续打印出来 不是学生 而是 
And now let's go ahead and print out, not the student but, rather,

1518
01:14:50,750 --> 01:14:54,416
返回值属于自己的魅力方法 
the return value of their own charm method.

1519
01:14:54,416 --> 01:14:58,583
因此 让我返回到我的终端窗口并运行Student.py的Python
So let me go back down to my terminal window and run Python of student.py

1520
01:14:58,583 --> 01:14:59,708
然后进入 
and Enter.

1521
01:14:59,708 --> 01:15:01,250
名字--让我们从哈里开始 
Name-- let's start with Harry.

1522
01:15:01,250 --> 01:15:03,500
他住在格兰芬多 
He lives in Gryffindor.

1523
01:15:03,500 --> 01:15:05,083
守护神是只雄鹿 
Patronus is a stag.

1524
01:15:05,083 --> 01:15:06,291
让我们来看看--
And let's see--

1525
01:15:06,291 --> 01:15:08,125
期待守护神！
Expecto Patronum!

1526
01:15:08,125 --> 01:15:10,708
当然 我们还会看到雄鹿表情符号 
And of course, we'd see the stag emoji.

1527
01:15:10,708 --> 01:15:13,333
像德拉科这样的人呢 至少在书上是这样的 
What about someone like Draco, who, at least in the books,

1528
01:15:13,333 --> 01:15:15,333
没有已知的守护神？
doesn't have a known patronus?

1529
01:15:15,333 --> 01:15:17,416
好吧 让我们继续清理我的终端窗口 
Well, let's go ahead and clear my terminal window,

1530
01:15:17,416 --> 01:15:22,625
重新运行Student.py的Python 这一次 让我们键入Draco作为名称 
rerun Python of student.py, and this time, let's type in Draco for name,

1531
01:15:22,625 --> 01:15:25,750
斯莱特林为豪斯 守护神未知 
Slytherin for house, and Patronus is unknown.

1532
01:15:25,750 --> 01:15:27,583
所以我要继续按Enter键 
So I'm just going to go ahead and hit Enter.

1533
01:15:27,583 --> 01:15:29,666
现在 Expeto Patronum！
And now, Expecto Patronum!

1534
01:15:29,666 --> 01:15:32,916
取而代之的是 它只发出了嘶嘶声 
And it just of sizzles instead.

1535
01:15:32,916 --> 01:15:38,208
好吧 让我提议 现在 我们删除这个守护神代码
Well, let me propose, now, that we remove this patronus code just

1536
01:15:38,208 --> 01:15:41,833
简化我们的世界 专注于其他一些核心
to simplify our world and focus on some of the other core

1537
01:15:41,833 --> 01:15:43,208
类的能力 
capabilities of classes.

1538
01:15:43,208 --> 01:15:44,958
所以冒着让人失望的风险 我要去
So at the risk of disappointing, I'm going

1539
01:15:44,958 --> 01:15:47,916
为了摆脱所有这些美丽的表情符号和魅力 
to get rid of all of these beautiful emoji and charms,

1540
01:15:47,916 --> 01:15:51,875
我要继续下去 现在停止向用户索要他们的守护神 
and I'm going to go ahead and stop asking the user now for their patronus.

1541
01:15:51,875 --> 01:15:54,708
我不会再把它传递给init了 
And I'm going to stop passing it into init here.

1542
01:15:54,708 --> 01:15:57,541
我在这里不会再这么做了 
And I'm going to stop doing this here.

1543
01:15:57,541 --> 01:16:03,333
我要继续 恢复我们对印刷品的使用 学生
And I'm going to instead just go ahead and restore our use of print student

1544
01:16:03,333 --> 01:16:06,541
在这里 我要继续下去 摆脱这里的守护神 
here, and I'm going to go ahead and get rid of patronus down here.

1545
01:16:06,541 --> 01:16:10,541
所以 从根本上说 只要取消我们刚刚创造的所有有趣的魅力 
So just essentially undo all of the fun charms we just created.

1546
01:16:10,541 --> 01:16:16,291
所以我们现在回到故事的这一点 我们有一个学生班 
So we're now back at the point in the story where we have a student class,

1547
01:16:16,291 --> 01:16:18,041
只有两种方法--
with only two methods--

1548
01:16:18,041 --> 01:16:19,416
Init和str.
init and str.

1549
01:16:19,416 --> 01:16:21,375
当然 第一个镜头是赛尔夫
The first of those takes, of course, self

1550
01:16:21,375 --> 01:16:25,125
像往常一样 第一个论点 加上另外两个--名字和房子 
as the first argument as it always will, plus two more now-- name and house,

1551
01:16:25,125 --> 01:16:26,208
不再有守护神了 
no more patronus.

1552
01:16:26,208 --> 01:16:28,041
我们正在验证上面的名字 
We're validating name up here.

1553
01:16:28,041 --> 01:16:29,833
我们在这下面验证豪斯 
We're validating house down here.

1554
01:16:29,833 --> 01:16:32,375
然后我们会分别指定名字和房子 
And then we're assigning name and house, respectively,

1555
01:16:32,375 --> 01:16:35,625
也称为name和house的两个实例变量 
to two instance variables called name and house also.

1556
01:16:35,625 --> 01:16:38,875
但我们使用SELF来访问当前对象 
But we use self to get access to the current object,

1557
01:16:38,875 --> 01:16:40,750
将这些值存储在其中 
to store those values therein.

1558
01:16:40,750 --> 01:16:44,583
然后我们在这里仍然有我们的str方法 它接受一个参数--
We then still have our str method here, which takes one argument--

1559
01:16:44,583 --> 01:16:46,208
默认情况下是Self 仅此而已 
by default, self, and that's it.

1560
01:16:46,208 --> 01:16:49,750
该函数将在任何时候被自动调用
And that function is going to be called automatically any time

1561
01:16:49,750 --> 01:16:52,625
您想要将学生对象转换为字符串 
you want to convert a student object to a string,

1562
01:16:52,625 --> 01:16:55,125
就像印刷品在这里可能想要做的那样 
just like print might want to do here.

1563
01:16:55,125 --> 01:16:57,791
所以让我继续下去 只是确保我没有打碎任何东西 
So let me go ahead and just make sure I haven't broken anything.

1564
01:16:57,791 --> 01:16:59,750
让我运行Student.py的Python 
Let me run Python of student.py.

1565
01:16:59,750 --> 01:17:00,916
我来打哈里 
I'll type in Harry.

1566
01:17:00,916 --> 01:17:03,041
我会输入格兰芬多 回车 
I'll type in Gryffindor, Enter.

1567
01:17:03,041 --> 01:17:04,416
好了 我们又开始营业了 
OK, we're back in business.

1568
01:17:04,416 --> 01:17:08,166
魅力和守护神消失了 但至少我又回到了一个
Gone are the charms and patronus, but at least I'm back to a situation

1569
01:17:08,166 --> 01:17:10,250
我有名字和房子的地方 
where I have names and houses.

1570
01:17:10,250 --> 01:17:14,416
但事实证明 目前 我们对类的使用
But it turns out, at the moment, our use of classes

1571
01:17:14,416 --> 01:17:20,083
并不是很强健 尽管我们有这个机制 非常聪明 
is not very robust, even though we have this mechanism, very cleverly,

1572
01:17:20,083 --> 01:17:23,041
如果可以的话 在我们的初始方法中
if I may, in our init method of making sure

1573
01:17:23,041 --> 01:17:27,125
我们正在验证名字和房子 确保名字不是空的 
that we're validating name and house, making sure that name is not blank,

1574
01:17:27,125 --> 01:17:32,625
并确保这所房子是霍格沃茨四所房子中的一所有效的房子 
and making sure that house is a valid house among those four Hogwarts houses.

1575
01:17:32,625 --> 01:17:35,208
事实证明 课程仍然会让我
It turns out that classes will still let me

1576
01:17:35,208 --> 01:17:38,541
获取那些属性 那些所谓的实例变量 
get at those attributes, those so-called instance variables,

1577
01:17:38,541 --> 01:17:40,750
无论如何都要用点符号 
using dot notation anyway.

1578
01:17:40,750 --> 01:17:44,500
那么让我向下滚动 试着以一种相反的方式来做这件事 
Let me scroll down then and try to do this a little adversarially.

1579
01:17:44,500 --> 01:17:48,500
假设在线16我继续调用Get_Student 
Suppose that online 16 I go ahead and call get_student,

1580
01:17:48,500 --> 01:17:52,541
和以前一样存在 然后我将返回值存储在一个学生
which exists as before, and then I store the return value in a student

1581
01:17:52,541 --> 01:17:54,791
变量--同样在第16行 
variable-- again, on line 16.

1582
01:17:54,791 --> 01:18:00,291
这将确保Get_Student被调用 它调用输入和输入 
That will ensure that get_student gets called, which calls input and input.

1583
01:18:00,291 --> 01:18:02,916
然后它调用学生构造函数 
And then it calls the student constructor,

1584
01:18:02,916 --> 01:18:05,541
它自动调用该init方法 
which invokes, automatically, this init method.

1585
01:18:05,541 --> 01:18:08,458
因此 通过我们如何布局我的代码 我们
So by way of how we've laid out my code, we're

1586
01:18:08,458 --> 01:18:11,750
要确保名字不是空的 房子肯定是
going to ensure that name is not blank and house is definitely

1587
01:18:11,750 --> 01:18:12,916
这四个值之一 
one of those four values.

1588
01:18:12,916 --> 01:18:16,541
我的纠错--或者说错误检查已经到位 
My error correction-- or error checking is in place.

1589
01:18:16,541 --> 01:18:20,708
但如果我有一点敌意 我仍然可以绕过它 
But if I'm a little adversarial, I can still circumvent it.

1590
01:18:20,708 --> 01:18:25,541
假设--好吧 需要我输入哈利和格兰芬多吗？
Suppose that-- fine, going to require me to type in Harry and Gryffindor?

1591
01:18:25,541 --> 01:18:28,083
我要继续输入Student.house 
I'm going to go ahead and type in student.house

1592
01:18:28,083 --> 01:18:31,541
等于 引号 引号 “女贞路四号 ”
equals, quote, unquote, "Number Four, Privet Drive,"

1593
01:18:31,541 --> 01:18:33,333
你阻止不了我的 
and you're not going to be able to stop me.

1594
01:18:33,333 --> 01:18:34,083
为什么？
Why?

1595
01:18:34,083 --> 01:18:36,708
嗯 事实证明 使用类和对象
Well, it turns out, with classes and objects

1596
01:18:36,708 --> 01:18:40,375
因此 您和我仍然可以访问这些实例变量
thereof, you and I can still access those instance variables

1597
01:18:40,375 --> 01:18:42,083
使用这个熟悉的点符号 
using this familiar dot notation.

1598
01:18:42,083 --> 01:18:45,125
这就是我们如何开始类的故事--只需设置这些属性
That's how we began the story of classes-- just setting these attributes

1599
01:18:45,125 --> 01:18:45,875
我们自己 
ourselves.

1600
01:18:45,875 --> 01:18:48,541
但您也可以读取这些属性本身
But you can also read these attributes themselves

1601
01:18:48,541 --> 01:18:50,750
如果你想的话以后再换 
and change them later if you want.

1602
01:18:50,750 --> 01:18:55,833
这将有效地绕过IF条件和另一个IF条件
And this will effectively circumvent the if condition and the other if condition

1603
01:18:55,833 --> 01:19:00,000
在我们的init方法中 因为只有当你第一次
in our init method because that is only called when you first

1604
01:19:00,000 --> 01:19:02,125
创建学生对象 
create the student object.

1605
01:19:02,125 --> 01:19:04,541
现在没有什么能阻止我
There's nothing stopping me, at the moment,

1606
01:19:04,541 --> 01:19:08,291
从只是改变房子或名字后 
from just changing the house or the name after.

1607
01:19:08,291 --> 01:19:12,541
所以如果我现在清除终端窗口并运行student.py的Python 
So if I now clear my terminal window and run Python of student.py,

1608
01:19:12,541 --> 01:19:16,208
我还是会输入哈利和格兰芬多来满足我的要求
I'll still type in Harry and Gryffindor to meet my requirements

1609
01:19:16,208 --> 01:19:17,916
这房子是这四个之一 
that the house be one of those four.

1610
01:19:17,916 --> 01:19:21,375
但是当它被打印出来的时候 注意 我还是覆盖了它 
But when it's printed, notice, I've still overridden it.

1611
01:19:21,375 --> 01:19:26,083
因此 虽然类确实允许我们对数据进行更多的控制 
So it seems that, while classes do allow us a little more control over the data

1612
01:19:26,083 --> 01:19:30,250
我们储存的信息 并不一定能阻止用户--
we're storing, it doesn't necessarily prevent the user--

1613
01:19:30,250 --> 01:19:33,625
或者更确切地说是程序员--可能是我自己 也可能是同事 
or rather the programmer-- be it myself or maybe a colleague,

1614
01:19:33,625 --> 01:19:35,791
把事情搞砸
from still messing things up.

1615
01:19:35,791 --> 01:19:39,083
在这里 同样 本着编程的精神 
So here, too, in the spirit of programming a little more

1616
01:19:39,083 --> 01:19:43,916
为了防御 请允许我介绍Python的另一个特性--
defensively, allow me to introduce another feature of Python as well--

1617
01:19:43,916 --> 01:19:46,208
即财产 
namely properties.

1618
01:19:46,208 --> 01:19:49,375
所以属性实际上只是一个属性
So a property is really just an attribute

1619
01:19:49,375 --> 01:19:52,750
有更多的防御机制 
that has even more defense mechanisms put into place,

1620
01:19:52,750 --> 01:19:58,208
多一点的功能 防止像我这样的程序员 
a little more functionality implemented by you to prevent programmers, like me

1621
01:19:58,208 --> 01:20:01,083
还有你 把这些属性搞砸了
and you, from messing things up like these attributes.

1622
01:20:01,083 --> 01:20:04,375
同样 属性是一个属性 你和我只是
So again, a property is going to be an attribute that you and I just

1623
01:20:04,375 --> 01:20:06,083
有更多的控制权 
have more control over.

1624
01:20:06,083 --> 01:20:06,750
怎么做？
How?

1625
01:20:06,750 --> 01:20:09,791
我们只是使用一些Python约定编写了更多的代码 
We just write a little more code, using some Python conventions.

1626
01:20:09,791 --> 01:20:14,333
我们要做的是 马上 使用一个功能--
And how we're going to do that is going to use, in just a moment, a feature--

1627
01:20:14,333 --> 01:20:18,083
一个名为@property的关键字 从技术上讲 它是一个函数 
a keyword known as @property, which is technically a function.

1628
01:20:18,083 --> 01:20:19,916
属性是Python中的一个函数 
Property is a function in Python.

1629
01:20:19,916 --> 01:20:24,791
但是我们即将看到一些新的@语法 它允许你装饰函数 
But we're about to see some new @ syntax that allows you to decorate functions.

1630
01:20:24,791 --> 01:20:26,125
这也是一种艺术术语 
And this, too, is a term of art.

1631
01:20:26,125 --> 01:20:28,916
在Python的世界里 你可以有装饰器 
In the world of Python, you can have decorators,

1632
01:20:28,916 --> 01:20:33,166
它们是修改其他函数的行为的函数 
which are functions that modify the behavior of other functions,

1633
01:20:33,166 --> 01:20:36,708
如果你愿意的话 我们就不谈这个了 不谈太多的杂草 
if you will, and we'll leave it at that without going too much into the weeds.

1634
01:20:36,708 --> 01:20:39,291
我们将通过例子来了解如何使用这些装饰器 
And we'll see, by, example how you can use these decorators,

1635
01:20:39,291 --> 01:20:41,541
特别是定义属性 
specifically to define properties.

1636
01:20:41,541 --> 01:20:43,708
让我们回到VS Code 
So let me go back to VS Code here.

1637
01:20:43,708 --> 01:20:46,791
我建议我来做 
And let me propose that I do this.

1638
01:20:46,791 --> 01:20:49,375
我要继续下去 创造--
I'm going to go ahead and create--

1639
01:20:49,375 --> 01:20:54,291
一个叫房子的房产怎么样 如下所示 
how about a property called house as follows.

1640
01:20:54,291 --> 01:21:00,833
在我的学生课堂上 我将继续--在我的init方法下面
Inside of my student class, I'm going to go ahead-- and below my init method

1641
01:21:00,833 --> 01:21:03,958
在我str方法下面 我将继续定义
and below my str method, I'm going to go ahead and define

1642
01:21:03,958 --> 01:21:09,000
一个名为house的函数 它总是至少接受一个参数 
a function called house that takes, as it always must, one argument at least,

1643
01:21:09,000 --> 01:21:10,041
叫赛尔夫 
called self.

1644
01:21:10,041 --> 01:21:15,458
我现在要做的就是把自己送回去 
And what I'm going to do now is return self.house.

1645
01:21:15,458 --> 01:21:17,625
所以我只需要定义一个名为
So I'm just going to define a method called

1646
01:21:17,625 --> 01:21:23,375
房子 其生活的唯一目的是返还房子的价值 
house, whose sole purpose in life is to return the value of house.

1647
01:21:23,375 --> 01:21:27,375
但我将定义另一种方法 奇怪的是 它也被称为House 
But I'm going to define one other method, curiously also called house,

1648
01:21:27,375 --> 01:21:31,375
但作为论据 这将涉及到两个价值观--
but that's going to take into, as arguments, two values--

1649
01:21:31,375 --> 01:21:35,625
一如既往的自我 也有一种叫房子的价值 
self as always and also a value called house.

1650
01:21:35,625 --> 01:21:37,291
现在我要这样做了 
And I'm going to now do this.

1651
01:21:40,375 --> 01:21:43,958
我要自己动手 
I'm going to do self.house = house.

1652
01:21:43,958 --> 01:21:45,250
现在 我做了什么？
Now, what have I done?

1653
01:21:45,250 --> 01:21:47,625
那么 让我暂时在这里补充一些评论 
Well, let me just temporarily add some comments here.

1654
01:21:47,625 --> 01:21:50,166
稍后 我们将开始泛泛地提到这一点
In a moment, we're going to start referring to this generally

1655
01:21:50,166 --> 01:21:51,083
作为一名吸毒者 
as a getter.

1656
01:21:51,083 --> 01:21:54,083
在这里 我将把这称为二传手 
And down here, I'm going to refer to this as a setter.

1657
01:21:54,083 --> 01:21:56,875
这是在Java世界中经常看到的术语 
And this is terminology frequently see in the world of Java.

1658
01:21:56,875 --> 01:21:58,791
你们中的一些人以前用Java编程过 
Some of you have programmed in Java before.

1659
01:21:58,791 --> 01:22:01,875
但是顾名思义 getter是一个函数
But as the names imply, a getter is a function

1660
01:22:01,875 --> 01:22:05,333
对于获得某些属性的类 
for a class that gets some attributes.

1661
01:22:05,333 --> 01:22:10,291
Setter是某个类中设置某些值的函数 
A setter is a function in some class that sets some value.

1662
01:22:10,291 --> 01:22:14,125
现在 尽管我们还没有完成 代码中有一点错误
And now, even though we're not done, and there's a bit of a mistake in the code

1663
01:22:14,125 --> 01:22:17,916
直觉上 我已经写过了 我们要做的是 
I've already written, intuitively, what we're going to do is this.

1664
01:22:17,916 --> 01:22:21,000
我们正在努力防止程序员 包括我自己 
We're trying to prevent programmers, myself included,

1665
01:22:21,000 --> 01:22:23,541
避免我的错误检查 即我
from circumventing my error checking that I

1666
01:22:23,541 --> 01:22:25,666
把名字和房子放在适当的位置 
put into place for name and house.

1667
01:22:25,666 --> 01:22:26,958
我怎么能做到这一点？
How can I do that?

1668
01:22:26,958 --> 01:22:29,500
嗯 我们在编程方面没有那么多的积木 
Well, we don't have that many building blocks in programming.

1669
01:22:29,500 --> 01:22:33,541
我们有数据的变量 我们有行动的函数 
We have things like variables for data, and we have functions for actions.

1670
01:22:33,541 --> 01:22:35,000
好吧 为什么我们不这样做呢？
Well, why don't we do this?

1671
01:22:35,000 --> 01:22:39,958
为什么我们不以某种方式要求 为了访问属性 
Why don't we somehow require that, in order to access an attribute,

1672
01:22:39,958 --> 01:22:41,375
你要经历一些功能 
you go through some function.

1673
01:22:41,375 --> 01:22:44,583
让我们要求 为了设置一些属性 
And let's require that, in order to set some attribute,

1674
01:22:44,583 --> 01:22:46,291
你要经历一些功能 
you go through some function.

1675
01:22:46,291 --> 01:22:51,958
通常 这些函数称为getter函数和setter函数
And conventionally, those functions are called a getter function and a setter

1676
01:22:51,958 --> 01:22:52,708
功能 
function.

1677
01:22:52,708 --> 01:22:56,541
为什么我们要在类中使用函数或方法呢？
And why are we using functions or, in this case, methods inside of a class?

1678
01:22:56,541 --> 01:23:00,000
嗯 一旦你有了功能 这些就只是动作或动词
Well, once you have functions, those are just actions or verbs

1679
01:23:00,000 --> 01:23:01,583
你和我可以创造我们自己 
that you and I can create ourselves.

1680
01:23:01,583 --> 01:23:05,208
我们可以在这些函数中添加我想要的任何纠错
We can put any error correction I want in these functions

1681
01:23:05,208 --> 01:23:08,416
因为这是要从上到下执行的代码 
because it's code that's going to get executed top to bottom.

1682
01:23:08,416 --> 01:23:15,541
那么 我现在如何防止用户将房屋设置为无效值呢？
So how can I now prevent the user from setting the house to an invalid value?

1683
01:23:15,541 --> 01:23:20,500
让我借用前面的一些逻辑 而不是盲目地这样做--只需设置
Let me borrow some logic from before rather than blindly do this-- just set

1684
01:23:20,500 --> 01:23:25,291
Self.house等于传入的房屋价值--让我们加上我们的错误
self.house equal to the house value that's passed in-- let's add our error

1685
01:23:25,291 --> 01:23:26,166
在那里检查 
checking there.

1686
01:23:26,166 --> 01:23:34,791
因此 如果豪斯不在格兰芬多或赫奇帕奇的以下名单中
So if house is not in the following list of Gryffindor or Hufflepuff

1687
01:23:34,791 --> 01:23:40,708
或者拉文克劳或斯莱特林 就像以前一样 
or Ravenclaw or Slytherin, just as before,

1688
01:23:40,708 --> 01:23:44,541
让我们继续引发一个值错误 只是为了表示 嗯-嗯 某件事
let's go ahead and raise a value error, just to signify that, uh-uh, something

1689
01:23:44,541 --> 01:23:45,291
出了问题 
has gone wrong.

1690
01:23:45,291 --> 01:23:46,333
我会说得更清楚些 
I'll be more explicit.

1691
01:23:46,333 --> 01:23:50,541
我会加上一条消息 比如 “无效的房子 ”引用 不引用 
I'll include a message like, "invalid house," quote, unquote.

1692
01:23:50,541 --> 01:23:56,166
否则 我将继续 现在 第21行 设置自己 挨家挨户 
Otherwise, I'm going to proceed on, now, line 21 to set self.house to house.

1693
01:23:56,166 --> 01:24:00,416
所以我只是复制了 或者重新输入了我的错误检查
So I've just copied, if you will, or retyped my error checking inside

1694
01:24:00,416 --> 01:24:02,333
这个所谓的setter函数 
of this so-called setter function.

1695
01:24:02,333 --> 01:24:03,666
现在 我为什么要这么做？
Now, why have I done that?

1696
01:24:03,666 --> 01:24:07,458
明确地说 每当用户或程序员
Well, to be clear, whenever the user or the programmer

1697
01:24:07,458 --> 01:24:12,375
像这样写代码 Student.house等于 什么是
writes code like this, student.house equals, what's

1698
01:24:12,375 --> 01:24:16,166
即将神奇地发生的是 Python将不仅仅是
about to happen magically is Python will not just

1699
01:24:16,166 --> 01:24:19,916
让程序员直接访问学生宿舍--该属性 
let the programmer access student house directly-- that attribute,

1700
01:24:19,916 --> 01:24:21,750
那个实例变量 也就是 
that instance variable, a.k.a.

1701
01:24:21,750 --> 01:24:22,875
自己的房子 
self house.

1702
01:24:22,875 --> 01:24:26,833
取而代之的是它会神奇地自动调用
It's instead going to magically automatically call

1703
01:24:26,833 --> 01:24:28,791
这个定时器对我来说很有作用 
this setter function for me.

1704
01:24:28,791 --> 01:24:30,708
Python是如何知道要这样做的？
How does Python know to do that?

1705
01:24:30,708 --> 01:24:35,666
嗯 如果是这样的话 在左手边 有自己的房子 
Well, if it's see that, on the left-hand side, there is self.house,

1706
01:24:35,666 --> 01:24:42,125
其中house是获取者或二传者的名字 然后它看到一个等号 
where house is the name of the getter or setter, and then it sees an equal sign,

1707
01:24:42,125 --> 01:24:45,625
指示任务 这只是一个足够的视觉线索说 
indicating assignment, that's just enough of a visual clue to say,

1708
01:24:45,625 --> 01:24:46,208
等一下 
wait a minute.

1709
01:24:46,208 --> 01:24:49,250
我不会让您直接访问该属性 
I'm not going to let you access that attribute directly.

1710
01:24:49,250 --> 01:24:51,791
我将改用定位器 
I'm going to use the setter instead.

1711
01:24:51,791 --> 01:24:52,291
为什么？
Why?

1712
01:24:52,291 --> 01:24:54,291
因为等号表示我在试着设置 
Because the equal sign means I'm trying to set.

1713
01:24:54,291 --> 01:24:58,250
我正在尝试将一个从右到左的值赋给该属性 
I'm trying to assign a value from right to left into that attribute.

1714
01:24:58,250 --> 01:25:00,500
因此 Python将自动执行的操作
So what Python's is going to do automatically

1715
01:25:00,500 --> 01:25:02,083
就是为我调用这个函数 
is call this function for me.

1716
01:25:02,083 --> 01:25:06,708
这很令人惊讶 因为现在我可以执行代码--一个用于检查的算法 
And that's amazing because now I can execute code-- an algorithm to check,

1717
01:25:06,708 --> 01:25:08,625
我想让用户--
do I want to let the user--

1718
01:25:08,625 --> 01:25:12,041
程序员是否将该属性设置为该值？
the programmer set that attribute to that value?

1719
01:25:12,041 --> 01:25:13,916
如果不是 我将引发一个值错误 
If not, I'm going to raise a value error,

1720
01:25:13,916 --> 01:25:15,833
你就是做不到 
and you're just not going to be able to do it.

1721
01:25:15,833 --> 01:25:17,500
如果真是这样的话 
If so fine.

1722
01:25:17,500 --> 01:25:19,416
我去给您安排一下 
I'll go ahead and set it for you.

1723
01:25:19,416 --> 01:25:21,958
但为了做到这一点 我们需要更多的语法 
But in order to do this, we need a little more syntax.

1724
01:25:21,958 --> 01:25:25,375
我要去掉我的评论 我要用那个装饰物 
And I'm going to get rid of my comment, and I'm going to use that decorator.

1725
01:25:25,375 --> 01:25:29,583
我需要告诉Python将此方法作为一个getter来处理 
I need to tell Python to treat this method as a getter.

1726
01:25:29,583 --> 01:25:32,083
然后 setter的语法略有不同 
And then the syntax for the setter is a little different.

1727
01:25:32,083 --> 01:25:34,500
你现在说的是house.setter 
You now say house.setter.

1728
01:25:34,500 --> 01:25:37,500
我希望一个是得到者 另一个是塞特人 
I wish one was getter and the other was setter.

1729
01:25:37,500 --> 01:25:39,458
这不是他们设计的方式 
That's not the way they designed it.

1730
01:25:39,458 --> 01:25:44,291
当您想定义一个getter时 只需在函数上方加上@Property即可 
When you want to define a getter, you just say @property above the function.

1731
01:25:44,291 --> 01:25:48,833
并且您可以完全按照您希望的属性来命名函数
And you name the function exactly like you would like the property

1732
01:25:48,833 --> 01:25:51,000
被称为--引用 引用 “房子 ”
to be called-- quote, unquote, "house."

1733
01:25:51,000 --> 01:25:54,416
这样做之后 您现在就可以使用新的装饰器了
Once you do that, you can now use a new decorator

1734
01:25:54,416 --> 01:25:57,625
它是自动为您创建的 名为@House 
that's automatically created for you called @house,

1735
01:25:57,625 --> 01:25:58,750
因为我叫它房子 
because I called it house.

1736
01:25:58,750 --> 01:26:01,416
然后你字面上说 @house.setter 
And then you literally say, @house.setter.

1737
01:26:01,416 --> 01:26:05,333
而这一整行 在第17行 是关于Python的线索
And this whole line, on line 17, is a clue to Python

1738
01:26:05,333 --> 01:26:08,750
这就是一个名称完全相同的函数--
that here comes a function, whose name is identical--

1739
01:26:08,750 --> 01:26:12,541
但请注意 它需要两个参数--都是self 所以您可以访问
but notice that it takes two arguments-- both self, so you have access

1740
01:26:12,541 --> 01:26:15,208
对象的内容 和房子 这是公正的
to the contents of the object, and house, which is just

1741
01:26:15,208 --> 01:26:20,041
将是来自程序员的字符串 来自人工输入返回
going to be a str that comes from the programmer from the human input return

1742
01:26:20,041 --> 01:26:23,958
值 以便您也可以设置该值 
value so that you can set that value as well.

1743
01:26:23,958 --> 01:26:27,375
但我现在有一个问题需要解决 就是这里 
But there's one fix I need to make now, here.

1744
01:26:27,375 --> 01:26:29,625
我认为 其他一切都还不错 
Everything else, I think, is still good.

1745
01:26:29,625 --> 01:26:31,250
然而 看看这个 
However watch this.

1746
01:26:31,250 --> 01:26:34,500
我在这里不再需要这个错误检查 
I no longer need this error check here.

1747
01:26:34,500 --> 01:26:35,333
为什么？
Why?

1748
01:26:35,333 --> 01:26:39,375
因为 如果我向下滚动到我的代码 
Because, if I scroll back down to my code here,

1749
01:26:39,375 --> 01:26:46,250
我刚才声称 像这样的代码 带有Student.house等于 
I claimed a moment ago that code like this, with student.house equals,

1750
01:26:46,250 --> 01:26:49,666
会自动让Python为我调用我的setter 
is going to automatically get Python to call my setter for me.

1751
01:26:49,666 --> 01:26:50,666
你猜怎么着？
Guess what?

1752
01:26:50,666 --> 01:26:55,875
即使在这里 在我的init方法中 调用self.house也等于
Even up here, in my init method, calling self.house equals

1753
01:26:55,875 --> 01:27:00,208
还将调用我的setter方法 这很令人惊讶
is also going to call my setter method, which is amazing

1754
01:27:00,208 --> 01:27:06,083
因为现在我可以将所有错误检查保存在setter中的一个位置 
because now I can keep all of my error checking in one place in the setter,

1755
01:27:06,083 --> 01:27:10,833
当我第一次创建对象时 它现在将被调用 
and it will now get called either when I create the object for the first time,

1756
01:27:10,833 --> 01:27:14,541
因为init 或者即使程序员
because of init, or even if the programmer

1757
01:27:14,541 --> 01:27:19,375
尝试绕过init方法并更改该属性值 
tries to circumvent that init method and change the value of this attribute,

1758
01:27:19,375 --> 01:27:21,041
我的二传手也会被叫来 
my setter will also get called.

1759
01:27:21,041 --> 01:27:26,000
每当我访问.house时 我的setter都会被调用 
My setter will get called any time I access .house.

1760
01:27:26,000 --> 01:27:28,458
但有一件事我需要解决 
But there's one fix I need to make.

1761
01:27:28,458 --> 01:27:32,958
不幸的是 我的名字有冲突 
Unfortunately, I have collided names.

1762
01:27:32,958 --> 01:27:38,458
现在 如果我们往上走 在第5行 这是一个实例变量 
Right now, if we go up here, on line 5, this is an instance variable.

1763
01:27:38,458 --> 01:27:42,333
它是我自己内部的一个字符串 在当前的学生对象内部 
It's a string inside of my self, inside of the current student object,

1764
01:27:42,333 --> 01:27:43,083
骂人的名字 
called name.

1765
01:27:43,083 --> 01:27:46,958
这是另一个名为house的实例变量 
And this is another instance variable called house.

1766
01:27:46,958 --> 01:27:51,291
不幸的是 如果我有一个名为name and house的实例变量 
Unfortunately, if I have an instance variable called name and house,

1767
01:27:51,291 --> 01:27:54,750
我不能同时拥有称为House的功能 
I cannot also have functions called house.

1768
01:27:54,750 --> 01:27:55,916
它们将会相撞 
They're going to collide.

1769
01:27:55,916 --> 01:27:57,041
你必须做出决定 
You've got to decide.

1770
01:27:57,041 --> 01:27:59,250
是否要将该变量命名为house？
Do you want the variable to be called house?

1771
01:27:59,250 --> 01:28:01,708
或者 您希望将该功能命名为House？
Or do you want the function to be called house?

1772
01:28:01,708 --> 01:28:04,208
不幸的是 你不能两者兼得 因为现在
Unfortunately, you can't have both because now Python

1773
01:28:04,208 --> 01:28:06,041
会把其中一个混淆为另一个 
is going to confuse one for the other.

1774
01:28:06,041 --> 01:28:09,291
因此 传统的解决办法是这样做--
So the conventional fix for this is to do this--

1775
01:28:09,291 --> 01:28:15,250
为了让setter不存储在self.house中传递的值 
to have the setter not store the value that's passed in self.house,

1776
01:28:15,250 --> 01:28:19,125
但使用一个几乎相同的名字 但使用一个小指示器
but to use an almost identical name, but to use a little indicator that

1777
01:28:19,125 --> 01:28:21,208
意味着你知道这样做是正确的 
means you know doing this correctly.

1778
01:28:21,208 --> 01:28:23,666
按照惯例 您通常会加下划线
You typically, by convention, put an underscore

1779
01:28:23,666 --> 01:28:27,041
在实例变量的名称前面 
in front of the instance variable's name.

1780
01:28:27,041 --> 01:28:31,208
当你在这里返回它的时候 你同样会加一个下划线 
And when you return it up here, you similarly put an underscore.

1781
01:28:31,208 --> 01:28:36,541
所以现在 从技术上讲 我的实例变量名为_house 
So now, technically, my instance variable is called _house,

1782
01:28:36,541 --> 01:28:41,791
但我的财产 这是一个更华丽的属性 如果你愿意的话 
but my property, which is a fancier attribute, if you will,

1783
01:28:41,791 --> 01:28:44,916
叫孤家寡人 
is called house alone.

1784
01:28:44,916 --> 01:28:48,666
我知道语法量很大 但它是一个非常强大的功能 
Huge amount of syntax, I know, but it's a very powerful feature.

1785
01:28:48,666 --> 01:28:52,708
这也是为什么你可以从字典中毕业 
And again, this is why you can graduate from dictionaries alone and have

1786
01:28:52,708 --> 01:28:55,500
更多功能任您使用 
so much more functionality at your disposal.

1787
01:28:55,500 --> 01:28:58,916
让我继续清理我的终端窗口 运行student.py的Python 
Let me go ahead and clear my terminal window and run Python of student.py,

1788
01:28:58,916 --> 01:29:00,458
输入姓名
Enter, name.

1789
01:29:00,458 --> 01:29:02,708
好吧 让我们继续输入哈里 
All right, let's go ahead and type in Harry.

1790
01:29:02,708 --> 01:29:04,625
让我们继续输入格兰芬多 
Let's go ahead and type in Gryffindor.

1791
01:29:04,625 --> 01:29:06,416
像往常一样交叉手指 
Crossing my fingers as always.

1792
01:29:06,416 --> 01:29:09,083
而现在 看 "病人的房子.“
And now, look, "Invalid house."

1793
01:29:09,083 --> 01:29:10,250
这是好事
This is a good thing.

1794
01:29:10,250 --> 01:29:10,750
为什么要这样？
Why?

1795
01:29:10,750 --> 01:29:13,958
因为 注意 在我的主函数中 
Because, notice, in my main function, I'm

1796
01:29:13,958 --> 01:29:19,125
仍然试图 恶意地 如果你愿意 改变哈利的房子
still trying, maliciously, if you will, to change Harry's house

1797
01:29:19,125 --> 01:29:21,000
不属于四个有效之一
to not be one of the four valid ones.

1798
01:29:21,000 --> 01:29:24,833
我想把它改成他童年的家女贞路四号
I'm trying to change it to his childhood home of Number Four, Privet Drive.

1799
01:29:24,833 --> 01:29:29,208
但是因为Python知道 等一下 你要分配--
But because Python knows that, wait a minute, you're trying to assign--

1800
01:29:29,208 --> 01:29:30,708
也就是说 设定一个值--
that is, set a value--

1801
01:29:30,708 --> 01:29:34,208
这个值也就是房屋 现在被定义为
and that value, a.k.a. house, is now defined

1802
01:29:34,208 --> 01:29:38,333
作为一个属性 你将不得不通过setter函数 
as a property you're going to have to go through the setter function instead

1803
01:29:38,333 --> 01:29:40,958
让你改变这个值 
to even let you change that value.

1804
01:29:40,958 --> 01:29:44,208
因为我有这个加薪ValueError 
And because I have this raise ValueError.

1805
01:29:44,208 --> 01:29:46,916
如果房子不像预期的那样 
If the house is not as intended, you're not

1806
01:29:46,916 --> 01:29:49,458
将被允许将其更改为无效值 
going to be allowed to change it to an invalid value.

1807
01:29:49,458 --> 01:29:52,458
所以我通过init方法在进入的过程中保护数据 
So I'm protecting the data on the way in, through the init method,

1808
01:29:52,458 --> 01:29:56,708
如果你试图在那里覆盖它 我甚至会为数据辩护 
and I'm even defending the data if you try to override it there.

1809
01:29:56,708 --> 01:29:59,208
所以我认为对我这个程序员来说 
So I think the only solution for me, the programmer,

1810
01:29:59,208 --> 01:30:01,250
别试图破解我的密码
is, don't try to break my own code.

1811
01:30:01,250 --> 01:30:04,083
让我把这句话去掉 因为它不起作用 
Let me remove that line because it's just not going to work.

1812
01:30:04,083 --> 01:30:07,250
让我运行student.py的Python 再次输入Harry;
Let me run Python of student.py and, again, type in Harry;

1813
01:30:07,250 --> 01:30:10,916
输入格兰芬多 回车 哈利确实是格兰芬多的 
type in Gryffindor, Enter, and Harry's indeed from Gryffindor.

1814
01:30:10,916 --> 01:30:15,708
如果我做错了什么 就像《四号》里的哈利 
If I did something incorrect, like Harry from Number Four,

1815
01:30:15,708 --> 01:30:20,541
女贞路 回车 我们再次看到值错误
Privet Drive, Enter, we're again going to see the value error

1816
01:30:20,541 --> 01:30:25,083
因为我的代码不允许手动输入这个值
because my code just doesn't let that value in via manual input now

1817
01:30:25,083 --> 01:30:28,541
或者通过这种对抗性的变化 
or via that adversarial change.

1818
01:30:28,541 --> 01:30:29,958
好吧 这是很多 
All right, that was a lot.

1819
01:30:29,958 --> 01:30:35,208
关于财产有什么问题吗？
But any question on properties?

1820
01:30:35,208 --> 01:30:37,125
问：为什么我们使用getter 然后使用setter？
AUDIENCE: Why we are using getter then setter?

1821
01:30:37,125 --> 01:30:41,541
只是为了让我们能找到
It's just for the purpose so that we can find

1822
01:30:41,541 --> 01:30:43,791
那个方法 我们代码中的函数 
that method, that function in our code.

1823
01:30:43,791 --> 01:30:46,833
大卫·J·马兰：我之所以要费力去定义
DAVID J. MALAN: The reason that I'm going through the trouble of defining

1824
01:30:46,833 --> 01:30:52,375
这个getter或setter是因为我想确保程序员不能
this getter or setter is because I want to make sure that programmers cannot do

1825
01:30:52,375 --> 01:30:53,250
诸如此类的事情 
things like this.

1826
01:30:53,250 --> 01:30:55,500
如果我正在经历验证的麻烦
If I'm going through the trouble of validating

1827
01:30:55,500 --> 01:30:58,708
这些学生对象的属性 
the attributes for these student objects,

1828
01:30:58,708 --> 01:31:02,041
我不希望你能进去 随意更改它们 
I don't want you to be able to go in there and just change them at will.

1829
01:31:02,041 --> 01:31:04,625
我想要对那个物体有一定的控制权
I want to have some control over that object

1830
01:31:04,625 --> 01:31:07,708
这样你就可以相信它会像设计的那样正确 
so that you can just trust that it's going to be correct as designed.

1831
01:31:07,708 --> 01:31:11,041
所以使用getter和setter实际上只是启用了
So using a getter and setter really just enables

1832
01:31:11,041 --> 01:31:15,416
当您尝试手动设置值时 可以自动检测到这一点 
Python to automatically detect when you're trying to manually set a value.

1833
01:31:15,416 --> 01:31:18,333
等号和圆点 就像我在这里强调的 
The equal sign and the dot, as I've highlighted here,

1834
01:31:18,333 --> 01:31:20,666
足以让我们意识到 等一下 
is enough of a clue to Python to realize, wait a minute,

1835
01:31:20,666 --> 01:31:21,916
你在试着设定一个价值 
you're trying to set a value.

1836
01:31:21,916 --> 01:31:24,750
让我看看这个类是否定义了setter 
Let me see if this class has a setter defined.

1837
01:31:24,750 --> 01:31:26,875
如果是这样的话 我会把它称为 我不仅仅是
And if so, I'm going to call that, and I'm not just

1838
01:31:26,875 --> 01:31:30,125
从右到左盲目赋值 
going to blindly assign the value from right to left.

1839
01:31:30,125 --> 01:31:32,541
所以它只是给了我更多的控制权 
So it's just giving me more control.

1840
01:31:32,541 --> 01:31:35,041
关于属性的其他问题 
Other questions on properties.

1841
01:31:35,041 --> 01:31:39,458
听众：当我们使用getter时 我们只有一个参数 
AUDIENCE: When we use getters, we just have just one argument.

1842
01:31:39,458 --> 01:31:43,291
如果我们使用setter 它总是会有两个参数？
And if we use setters, it's always going to be two arguments?

1843
01:31:43,291 --> 01:31:44,291
这正常吗？
Is that normal?

1844
01:31:44,291 --> 01:31:45,291
大卫·J·马兰：正确 
DAVID J. MALAN: Correct.

1845
01:31:45,291 --> 01:31:47,833
永远只有一个争论--自我
It's always going to be one argument-- self

1846
01:31:47,833 --> 01:31:52,625
对于getter setter有两个参数--self和其他东西 
for the getter, two arguments for the setter-- self and something else.

1847
01:31:52,625 --> 01:31:55,375
直觉是 如果你得到了一个价值 
And the intuition for that is, if you're getting a value,

1848
01:31:55,375 --> 01:31:58,875
您不需要传入任何其他内容 因为您已经知道该对象 
you don't need to pass anything else in because you already know the object.

1849
01:31:58,875 --> 01:32:00,291
在这种情况下 它被称为学生 
It's called student in this case.

1850
01:32:00,291 --> 01:32:02,791
所以你只需要得到这处房产的价值 
So you're just going to get the value of that property.

1851
01:32:02,791 --> 01:32:05,458
但如果要将该属性设置为其他值 
But if you want to set the property to something else,

1852
01:32:05,458 --> 01:32:07,125
你必须把这一论点传递出去 
you've got to pass in that argument.

1853
01:32:07,125 --> 01:32:09,625
您必须传入要为其设置的值 
You've got to pass in the value to which you want to set it.

1854
01:32:09,625 --> 01:32:11,291
所以它总是0或1 
So it's always 0 or 1.

1855
01:32:11,291 --> 01:32:17,541
但是 您可以将其视为1或2 因为同样 类中的任何函数 
However, you see it as 1 or 2 because, again, any function inside of a class,

1856
01:32:17,541 --> 01:32:18,041
也就是 
a.k.a.

1857
01:32:18,041 --> 01:32:22,291
一个方法 将自动传递给您自己 这样您就可以访问
a method, is going to be automatically passed self so that you have access

1858
01:32:22,291 --> 01:32:25,208
到内存中的当前对象 
to that current object in memory.

1859
01:32:25,208 --> 01:32:27,708
另一个关于房产的问题怎么样？
How about one other question on properties?

1860
01:32:27,708 --> 01:32:31,791
观众：为什么我们没有使用相同的下划线房屋初始化方法？
AUDIENCE: Why didn't we use the same underscore house init method?

1861
01:32:31,791 --> 01:32:33,125
大卫·J·马兰：问得好 
DAVID J. MALAN: A good question.

1862
01:32:33,125 --> 01:32:36,750
所以即使我在我的二传手里用的是下划线的房子 
So even though I'm using the underscore house here, in my setter,

1863
01:32:36,750 --> 01:32:39,125
下划线的房子在我的吸尘器里 
and the underscore house here, in my getter,

1864
01:32:39,125 --> 01:32:41,958
我故意不在这里用它 
I deliberately did not use it up here.

1865
01:32:41,958 --> 01:32:47,333
原因是 通过使用self.house和这个等号 
The reason for that is that, by using self.house and this equal sign,

1866
01:32:47,333 --> 01:32:50,375
这与我希望Python识别的模式是相同的 
that's the same pattern that I want Python to recognize.

1867
01:32:50,375 --> 01:32:53,208
我希望Python自动调用setter 
I want Python to automatically call the setter,

1868
01:32:53,208 --> 01:32:56,791
即使当我通过init方法进入房子时也是如此 
even when I'm passing in the house via the init method.

1869
01:32:56,791 --> 01:33:01,458
如果我改变这一点来做这件事 那就绕过了二传手 
If I were to change this to do this, that would circumvent the setter,

1870
01:33:01,458 --> 01:33:05,041
现在 无论如何 在init中都没有错误签入 
and now there's no error checking in init whatsoever.

1871
01:33:05,041 --> 01:33:06,333
因此 这是一条如此微妙的界线 
So it's such a fine line.

1872
01:33:06,333 --> 01:33:10,041
唯一阻碍我们进行错误检查或不进行错误检查的事情
The only thing standing between us and error checking or no error checking

1873
01:33:10,041 --> 01:33:12,750
是有没有这个下划线 
is the presence or absence of this underscore.

1874
01:33:12,750 --> 01:33:14,625
但这是通常的惯例 
But that's typically the convention.

1875
01:33:14,625 --> 01:33:17,375
通过不使用那里的下划线 确保
By not using the underscore there, make sure

1876
01:33:17,375 --> 01:33:19,708
即使是这项任务也要经过设定者
that even that assignment goes through the setter

1877
01:33:19,708 --> 01:33:22,416
所以 老实说 我 不必复制粘贴同样的错误
so that, honestly, I, don't have to copy paste the same error

1878
01:33:22,416 --> 01:33:23,583
入住两个地方 
checking in two places.

1879
01:33:23,583 --> 01:33:25,375
我可以把它放在二传手里 
I can put it just in the setter.

1880
01:33:25,375 --> 01:33:28,791
所以这是一个更好的设计 这就是为什么我一开始手动重新打字的原因 
So it's a better design, and that's why I manually retyped it at first,

1881
01:33:28,791 --> 01:33:31,166
但后来我把它从init中删除了 
but then I deleted it from init.

1882
01:33:31,166 --> 01:33:34,625
好吧 请允许我提议我们对这份文件做另一项修改 
Well, allow me to propose that we make one other change to this file.

1883
01:33:34,625 --> 01:33:38,708
不妨继续为名称定义一个属性 
Might as well go ahead and define a property for name as well.

1884
01:33:38,708 --> 01:33:41,458
让我继续做这件事--也许是在房产上方
And let me go ahead and do this-- maybe above the house property

1885
01:33:41,458 --> 01:33:45,041
只是为了让事情保持在我之前定义的相同顺序 
just to keep things in the same order as I defined them earlier.

1886
01:33:45,041 --> 01:33:47,375
让我给自己另一处房产吧 
Let me give myself another property.

1887
01:33:47,375 --> 01:33:49,125
这一次将被称为名字 
This one is going to be called name.

1888
01:33:49,125 --> 01:33:51,583
它将一如既往地采用一个叫做自我的论点 
It's going to take one argument called self, as always.

1889
01:33:51,583 --> 01:33:55,625
与此非常相似的是 这个函数将返回self._name 
And this one, very similarly, is just going to return self._name.

1890
01:33:55,625 --> 01:33:57,333
所以我会预料到我会去
So I'm going to anticipate that I'm going

1891
01:33:57,333 --> 01:34:01,166
还必须重命名名称 这样我就不会发生与
to have to rename name also so that I don't have that same collision as

1892
01:34:01,166 --> 01:34:01,875
在此之前 
before.

1893
01:34:01,875 --> 01:34:05,541
但现在让我继续定义另一个二传手--
But now let me go ahead and define another setter--

1894
01:34:05,541 --> 01:34:06,750
这是名字的名字 
this one for name.

1895
01:34:06,750 --> 01:34:09,416
因此 约定为@name.setter 
So the convention is @name.setter.

1896
01:34:09,416 --> 01:34:10,375
为什么要取这个名字？
Why name?

1897
01:34:10,375 --> 01:34:13,916
因为我刚刚创建的属性名为Name 
Because the property I just created is called name.

1898
01:34:13,916 --> 01:34:18,833
因此 如果您愿意的话 getter和setter以这种方式协同工作 
So the getter and setter work in conjunction in this way, if you will.

1899
01:34:18,833 --> 01:34:22,291
让我们使用名称setter来定义另一个函数 
Let me go down under that name setter and define another function,

1900
01:34:22,291 --> 01:34:23,375
也叫名字 
also called name.

1901
01:34:23,375 --> 01:34:25,791
但这里的关键是 它们并不完全相同 
But the key thing here is that it's not identical.

1902
01:34:25,791 --> 01:34:30,000
它不是完全相同的函数名称和完全相同的参数数量 
It's not the exact same function name and the exact same number of arguments.

1903
01:34:30,000 --> 01:34:32,500
同样 setter接受第二个参数 
The setter, again, takes a second argument.

1904
01:34:32,500 --> 01:34:34,250
我可以随心所欲地叫它 但我
And I can call it anything I want, but I'm

1905
01:34:34,250 --> 01:34:36,750
我要给它起个名字 因为这就是传入的东西 
going to call it name because that's what's being passed in.

1906
01:34:36,750 --> 01:34:39,041
我要把我的错误检查放在这里 
And I'm going to put my error checking here.

1907
01:34:39,041 --> 01:34:43,541
如果不是名称 就像我们以前所做的那样 让我们继续并引发一个值错误 
If not name, just like we used to do, let's go ahead and raise a value error,

1908
01:34:43,541 --> 01:34:48,750
让我们加上一条解释性的信息 比如“缺少名字” 引用 不引用 
and let's put an explanatory message like "Missing name," quote, unquote.

1909
01:34:48,750 --> 01:34:55,250
否则 让我们继续并将self._name更新为等名 
Otherwise, let's go ahead and update self._name to equal name.

1910
01:34:55,250 --> 01:34:58,500
而且我不需要改变它的名字 只是为了摆脱它
And I don't have to change init except to get rid

1911
01:34:58,500 --> 01:35:02,333
重复错误检查 因为 再一次 
of this duplicate error checking now because, again,

1912
01:35:02,333 --> 01:35:07,166
如果我使用self.name等于这里 使用self.house等于这里
if I use self.name equals here and self.house equals here

1913
01:35:07,166 --> 01:35:09,916
没有下划线 这两个作业
with no underscore, both of those assignments

1914
01:35:09,916 --> 01:35:13,375
现在我们来看看我的两个setter函数 
are going to go through my two setter functions now.

1915
01:35:13,375 --> 01:35:15,416
在我们开始之前 让我继续删除
Before we run this, let me go ahead and remove

1916
01:35:15,416 --> 01:35:18,791
这个敌对的代码 我们知道它不会起作用 因为我们正在捕获它 
this adversarial code, which we know won't work because we're catching it.

1917
01:35:18,791 --> 01:35:22,375
让我返回到我的终端窗口并运行Student.py的Python 
Let me go back down to my terminal window and run Python of student.py,

1918
01:35:22,375 --> 01:35:22,916
进来吧 
Enter.

1919
01:35:22,916 --> 01:35:23,958
让我们输入哈里 
Let's type in Harry.

1920
01:35:23,958 --> 01:35:25,125
让我们输入格兰芬多 
Let's type in Gryffindor.

1921
01:35:25,125 --> 01:35:26,708
这似乎奏效了 
And that seems to work.

1922
01:35:26,708 --> 01:35:29,458
不过 让我们再次尝试运行Student.py的Python
Let's try though, again, to run Python of student.py

1923
01:35:29,458 --> 01:35:32,708
和来自女贞路四号的哈里 
with Harry from Number Four, Privet Drive.

1924
01:35:32,708 --> 01:35:34,416
这是行不通的 
This will not work.

1925
01:35:34,416 --> 01:35:37,291
无效房屋的值错误 因为这不是
A value error with invalid house, because that's not

1926
01:35:37,291 --> 01:35:38,791
霍格沃茨的四所房子中的一所 
one of the four Hogwarts houses.

1927
01:35:38,791 --> 01:35:41,041
现在 为了更好地衡量 让我们再运行一次 
And now, for good measure, let's run it one more time.

1928
01:35:41,041 --> 01:35:42,583
我们甚至都不给它起个名字 
And let's not even give it a name.

1929
01:35:42,583 --> 01:35:44,375
出现提示时 我们只需按Enter键即可 
Let's just hit Enter when prompted.

1930
01:35:44,375 --> 01:35:45,875
我可以为房子打任何东西 
I can type anything for the house.

1931
01:35:45,875 --> 01:35:47,958
我继续 格兰芬多 请进 
I'll go ahead and still give it Gryffindor, Enter.

1932
01:35:47,958 --> 01:35:52,958
现在我们得到另一个值错误 但这个错误是因为缺少名称 
And now we get another value error, but this one is for missing name.

1933
01:35:52,958 --> 01:35:56,500
所以我们现在似乎有了更多的防御机制
So we seem, now, to have all the more of a defense mechanism in place

1934
01:35:56,500 --> 01:35:58,833
确保这个名字符合我们的预期
to ensure that name is as we expect.

1935
01:35:58,833 --> 01:36:01,000
它必须有非空的值 
It's got to have some value that's not blank.

1936
01:36:01,000 --> 01:36:02,500
房子也如我们所料 
And house is as we expect.

1937
01:36:02,500 --> 01:36:05,000
它必须有这四个值之一 
It's got to have one of those four values.

1938
01:36:05,000 --> 01:36:08,000
但冒着戳破每个人的泡沫的风险
But at the risk of bursting everyone's bubble

1939
01:36:08,000 --> 01:36:11,958
让你想知道 为什么我们要经历这一切 
and making you wonder, why did we just go through all of that,

1940
01:36:11,958 --> 01:36:18,875
不幸的是 Python真正关注的是约定 而不是硬约束 
unfortunately Python really focuses on conventions, not hard constraints.

1941
01:36:18,875 --> 01:36:20,291
我说的是这个 
And by that, I mean this.

1942
01:36:20,291 --> 01:36:25,208
如果我在第30行找到一个学生后 
If I go back into my main function after I've gotten a student on line 30

1943
01:36:25,208 --> 01:36:30,375
我试着用相反的方式做一些事情--student.house等于
and I try to adversarially do something like this-- student.house equals

1944
01:36:30,375 --> 01:36:33,625
“女贞路四号”我们知道
"Number Four, Privet Drive," we know this

1945
01:36:33,625 --> 01:36:37,416
因为我的家犬会被传染的 
won't work because my setter for house is going to catch this.

1946
01:36:37,416 --> 01:36:38,333
再看一遍 
Watch again.

1947
01:36:38,333 --> 01:36:40,833
Python的student.py 
Python of student.py.

1948
01:36:40,833 --> 01:36:42,041
让我们输入哈里 
Let's type in Harry.

1949
01:36:42,041 --> 01:36:44,541
让我们输入格兰芬多 这至少会通过
Let's type in Gryffindor, which will at least pass

1950
01:36:44,541 --> 01:36:46,958
我们的检查由init引发 
our check that's induced by init.

1951
01:36:46,958 --> 01:36:52,041
但是第31行将触发调用同一个setter 
But line 31 is going to trigger the same setter to be called,

1952
01:36:52,041 --> 01:36:55,583
我们会抛出一个值错误 说“无效的房子 “
and we're going to raise a value error saying "Invalid house."

1953
01:36:55,583 --> 01:36:58,250
不幸的是 如果你们中的一些人已经
Unfortunately, and if some of you are already

1954
01:36:58,250 --> 01:37:02,375
想想你能做什么
thinking a little adversarially, tragically, look what you can do.

1955
01:37:02,375 --> 01:37:05,500
你可以改变.房子是._房子
You can change .house to be ._house.

1956
01:37:05,500 --> 01:37:06,041
为什么要这样？
Why?

1957
01:37:06,041 --> 01:37:10,416
实例变量现在被称为_house 
Well, the instance variable is now called _house.

1958
01:37:10,416 --> 01:37:13,125
房子的名字是house 没有下划线 
The property is called house, no underscore.

1959
01:37:13,125 --> 01:37:19,041
但是作为实例变量实现的基础属性仍然被调用
But the underlying attribute implemented as an instance variable is still called

1960
01:37:19,041 --> 01:37:19,791
_房子 
_house.

1961
01:37:19,791 --> 01:37:23,541
可悲的是 学生的Python 
And tragically, Python of student.py.

1962
01:37:23,541 --> 01:37:25,000
让我们输入哈里 
Let's type in Harry.

1963
01:37:25,000 --> 01:37:27,375
我们输入格兰芬多 这是正确的 
Let's type in Gryffindor, which is correct.

1964
01:37:27,375 --> 01:37:28,958
但看看现在发生了什么 
But watch what happens now.

1965
01:37:28,958 --> 01:37:30,333
天啊
Oh, my God.

1966
01:37:30,333 --> 01:37:32,000
我们溜过去 
We slip through.

1967
01:37:32,000 --> 01:37:35,708
那么我强调的重点是什么呢
So what was the point of all of this emphasis from me

1968
01:37:35,708 --> 01:37:39,541
用“正确的方式”来做事情 Python的快速方式是让这个getter
on doing things the "right way," the Python quick way by having this getter

1969
01:37:39,541 --> 01:37:40,291
setter？
and setter?

1970
01:37:40,291 --> 01:37:43,208
与Java等语言不同 
Well, unlike languages like Java, that just

1971
01:37:43,208 --> 01:37:46,208
防止你做这样的事情 Python
prevent you from doing things like this, Python

1972
01:37:46,208 --> 01:37:49,041
它本身允许您指定某些实例变量可以
itself allows you to specify that certain instance variables can

1973
01:37:49,041 --> 01:37:52,666
是公开的 任何人的代码都可以访问 或者是受保护的 
be public and accessible to anyone's code, or protected,

1974
01:37:52,666 --> 01:37:56,791
或私有 这意味着其他任何人都不能更改这些值 
or private, which means that no one else should be able to change these values.

1975
01:37:56,791 --> 01:38:00,125
在Python的世界里 这只是一个荣誉系统 
In the world of Python, it's just the honor system.

1976
01:38:00,125 --> 01:38:02,416
它并没有融入到语言本身中 
It's not baked into the language itself that there's

1977
01:38:02,416 --> 01:38:05,500
可见性的概念 公共的或私人的 甚至介于两者之间的某个地方
a notion of visibility, public or private or even somewhere in between

1978
01:38:05,500 --> 01:38:06,250
受到保护 
protected.

1979
01:38:06,250 --> 01:38:08,208
取而代之的是 你在荣誉体系中 
Instead, you're on the honor system.

1980
01:38:08,208 --> 01:38:11,666
通常的惯例是 如果一个实例
And the convention generally is, if an instance

1981
01:38:11,666 --> 01:38:15,750
变量以下划线开头 请不要碰它 
variable starts with an underscore, please don't touch it.

1982
01:38:15,750 --> 01:38:16,708
就是不要 
Just don't.

1983
01:38:16,708 --> 01:38:19,750
如果你碰了那个变量 弄坏了东西 那就怪你了 
That's on you if you touch that variable and break things.

1984
01:38:19,750 --> 01:38:22,000
下划线表示约定
The underscore is meant to signify a convention

1985
01:38:22,000 --> 01:38:24,583
这本应是“私人的” 但它真的只是
that this is meant to be "private," but it really just

1986
01:38:24,583 --> 01:38:25,875
意思是 请不要碰这个 
means, please don't touch this.

1987
01:38:25,875 --> 01:38:27,958
有时 如果有两个下划线 你可以使用 
Sometimes, if there's two underscores, which you can use,

1988
01:38:27,958 --> 01:38:30,541
同样 这也是程序员们更大的努力 他们说 
too, that's an even greater effort by programmers to say,

1989
01:38:30,541 --> 01:38:32,000
真的不要碰这个 
really don't touch this.

1990
01:38:32,000 --> 01:38:35,166
但从技术上讲 没有什么能阻止你或我
But technically speaking, there's nothing stopping you or me

1991
01:38:35,166 --> 01:38:38,875
绕过所有这些机制 这些特性 
from circumventing all of these mechanisms, these properties,

1992
01:38:38,875 --> 01:38:40,125
这些获得者和二传者 
these getters and setters.

1993
01:38:40,125 --> 01:38:42,250
我们最终只是在荣誉系统上
We're ultimately just on the honor system

1994
01:38:42,250 --> 01:38:46,291
当我们看到实例变量以1为前缀时 不要这样做 
not to do so when we see instance variables prefixed with one,

1995
01:38:46,291 --> 01:38:48,041
或者甚至是两个下划线 
or perhaps even two underscores.

1996
01:38:48,041 --> 01:38:50,583
好了 这是一下子做了很多事--
All right, so this is a lot all at once--

1997
01:38:50,583 --> 01:38:52,875
这是面向对象编程的入门 
this Introduction to object-oriented programming.

1998
01:38:52,875 --> 01:38:56,166
但这可能会让人相当惊讶 即使我们
But it might come as quite a surprise that, even though we

1999
01:38:56,166 --> 01:39:00,458
在过去的几周里可能已经认出了OOP的名字 
might have identified OOP by name in weeks past,

2000
01:39:00,458 --> 01:39:05,458
在这堂课上 我们已经使用类和对象好几个星期了 
we've all been using classes and objects for weeks now in this class.

2001
01:39:05,458 --> 01:39:08,791
事实上 如果你回想一下我们在这堂课上做的第一件事 
In fact, if you think back on one of the very first things we did in this class,

2002
01:39:08,791 --> 01:39:12,083
我们使用了整数 只是从用户那里获得了整数 
we used integers and just got integers from the user.

2003
01:39:12,083 --> 01:39:13,791
但如果你还没有--
But if you haven't already--

2004
01:39:13,791 --> 01:39:17,500
如果您深入研究有关整数的文档 
if you go and dig into the documentation for integers,

2005
01:39:17,500 --> 01:39:19,916
同样 它位于这个URL上 您
which, again, lives at this URL here, you

2006
01:39:19,916 --> 01:39:26,166
会发现INT本身就是一门课 几周来一直是这样 
would actually find that int itself is and has been for weeks a class.

2007
01:39:26,166 --> 01:39:30,541
事实上 这是对int的构造函数调用的签名 
And in fact, this is the signature of the constructor call for an int,

2008
01:39:30,541 --> 01:39:35,125
借此传入x 如数字、引号、不引号、“50”或引号 
whereby you pass in x, like a number, quote, unquote, "50" or, quote,

2009
01:39:35,125 --> 01:39:38,458
引用一句话 还有一些东西--你可以选择性地传递基数--
unquote, something else-- you pass in optionally the base--

2010
01:39:38,458 --> 01:39:41,750
10表示十进制 2表示二进制或其他任何值 
10 for decimal, 2 for binary or anything else.

2011
01:39:41,750 --> 01:39:46,208
这个整型函数会一直返回给你 
And that int function will actually return to you, all this time,

2012
01:39:46,208 --> 01:39:49,625
类型为int的对象 
an object of type int.

2013
01:39:49,625 --> 01:39:52,083
也就是说 int是一个类 
That is to say int is a class.

2014
01:39:52,083 --> 01:39:55,250
它是一个模板 一个在内存中创建整数的蓝图 
It is a template, a blueprint for creating integers in memory.

2015
01:39:55,250 --> 01:39:59,125
任何时候 只要你和我把一个字符串转换成一个整型 
And any time you and I have converted a string, for, instance to an int,

2016
01:39:59,125 --> 01:40:03,958
您和我一直在创建一个int类型的对象 该对象调用
you and I have been creating an object of type int that was calling,

2017
01:40:03,958 --> 01:40:07,875
显然 下划线 init 下划线下划线方法 
apparently, the underscore underscore, init, underscore underscore method,

2018
01:40:07,875 --> 01:40:09,666
其他人--《巨蟒》的作者--
that someone else-- the authors of Python--

2019
01:40:09,666 --> 01:40:12,500
写给我们的是正确的整数 
wrote to give us back that proper integer.

2020
01:40:12,500 --> 01:40:16,541
除此之外 如果你相信的话 STR、Python中的字符串
Besides that, if you can believe it, strs, strings in Python

2021
01:40:16,541 --> 01:40:20,000
从这节课的第一周就开始上课了 
have been classes since the first week of this class as well.

2022
01:40:20,000 --> 01:40:22,000
如果您在文档中查找字符串 
If you look up the documentation for a str,

2023
01:40:22,000 --> 01:40:26,541
它位于一个类似的URL中 您会发现 当您实例化
which lives at a similar URL there, you will find that, when you instantiate--

2024
01:40:26,541 --> 01:40:28,083
也就是说 创建一个字符串--
that is, create a str--

2025
01:40:28,083 --> 01:40:32,166
它可选地接受一个在这里称为Object的参数 
it takes, optionally, a parameter called object here,

2026
01:40:32,166 --> 01:40:34,666
其缺省值为JUST、QUOTE、UNQUOTE、
the default value of which is just, quote, unquote,

2027
01:40:34,666 --> 01:40:38,000
这实际上允许您创建一个空字符串、一个空字符串、
which allows you to create, in effect, an empty string, a blank string,

2028
01:40:38,000 --> 01:40:38,500
如果你愿意的话 
if you will.

2029
01:40:38,500 --> 01:40:42,541
但任何时候你和我创建了STR或甚至明确使用
But any time you and I have created strs or even used explicitly

2030
01:40:42,541 --> 01:40:47,333
Str函数 您将返回一个str类型对象 
the str function, you are getting back an object of type str.

2031
01:40:47,333 --> 01:40:52,375
任何时候您和我根据文档将字符串强制为小写时 
Any time you and I have forced a string to lowercase per the documentation,

2032
01:40:52,375 --> 01:40:58,041
使用这样的语法 您和我已经获取了一个类型为str的对象
using syntax like this, you and I have been taking an object of type str

2033
01:40:58,041 --> 01:41:03,125
并通过调用名为Low的方法将其全部强制为小写 
and forcing it all to lowercase by calling a method called lower,

2034
01:41:03,125 --> 01:41:07,958
一种由Python的作者构建到str类中的方法 
a method that the authors of Python built into the str class,

2035
01:41:07,958 --> 01:41:11,041
但它从一开始就存在 所以这个方法的概念不是
but it's been there from the get-go, so this notion of methods is not

2036
01:41:11,041 --> 01:41:11,833
即使是今天的新鲜事 
even new today.

2037
01:41:11,833 --> 01:41:13,750
你不会这么做这么久的 
You wouldn't have been doing it for this long.

2038
01:41:13,750 --> 01:41:17,416
如果您曾经调用strain来删除前导空格和尾随空格
If you've ever called strip to remove the leading and the trailing whitespace

2039
01:41:17,416 --> 01:41:22,166
从Python中的一个字符串中 您将调用另一个随Python提供的方法--
from a string in Python, you are calling another method that came with Python--

2040
01:41:22,166 --> 01:41:23,750
由Python的作者编写 
written by the authors of Python.

2041
01:41:23,750 --> 01:41:26,000
尽管我们当时并没有把它叫做课程 
And even though we didn't call it a class at the time,

2042
01:41:26,000 --> 01:41:29,708
一直以来 字符串都是一门课 
a str, all this time, has been a class.

2043
01:41:29,708 --> 01:41:33,541
字符串的实例本身就是对象 
And instances of strings are, themselves, objects.

2044
01:41:33,541 --> 01:41:36,291
因此 这些对象具有以下功能
And those objects come therefore with these functions

2045
01:41:36,291 --> 01:41:39,458
内置--也就是 允许我们做像武力这样的事情的方法
built in-- a.k.a. methods that allow us to do things like force

2046
01:41:39,458 --> 01:41:42,791
从开头和结尾开始小写并去掉空格 
to lowercase and strip whitespace from the beginning and end.

2047
01:41:42,791 --> 01:41:43,958
让我们再来一次 
Let's do another.

2048
01:41:43,958 --> 01:41:49,541
List--任何时候您创建了一个列表 无论是语法上的Square
list-- any time you've created a list, either syntactically with square

2049
01:41:49,541 --> 01:41:53,541
括号或字面意思是L-I-S-T 左括号 右括号 
brackets or literally with L-I-S-T, open parentheses, closed parentheses,

2050
01:41:53,541 --> 01:41:56,375
这也是可能的 你一直在使用一个类 
which is also possible, you have been using a class.

2051
01:41:56,375 --> 01:41:59,833
如果您转到列表的文档 请访问类似的URL
If you go to the documentation for list, at this similar URL

2052
01:41:59,833 --> 01:42:04,083
在这里 或者更具体地说 关于在Python中的列表的教程 
here, or more specifically, the tutorial on lists here in Python,

2053
01:42:04,083 --> 01:42:07,208
你会看到一份清单现在和过去都是 
you will see that a list is and has been,

2054
01:42:07,208 --> 01:42:10,958
从这节课的前几周开始 一节课就开始了 
since the early weeks of this class, a class itself.

2055
01:42:10,958 --> 01:42:16,166
作为其初始化的一部分 该List类
And that list class takes, as part of its initialization,

2056
01:42:16,166 --> 01:42:21,000
可选的可迭代的 可以迭代的东西--比如1 2 3 
an optional iterable, something that can be iterated over-- like 1, 2, 3,

2057
01:42:21,000 --> 01:42:24,125
或某个值列表 然后您可以返回
or some list of values, and you can then get back

2058
01:42:24,125 --> 01:42:27,416
包含这些相同可迭代值的列表 
a list containing those same iterable values.

2059
01:42:27,416 --> 01:42:30,666
如果你曾经在这节课的列表上添加过什么 
If you've ever appended something to a list in this class,

2060
01:42:30,666 --> 01:42:32,583
就像我过去做的那样 你一直
as I have myself in the past, you've been

2061
01:42:32,583 --> 01:42:37,416
使用List类附带的名为append的方法 根据x
using a method called append that comes with the list class that, per the x

2062
01:42:37,416 --> 01:42:40,541
在这里 接受一个允许您追加某些内容的参数
here, takes an argument that allows you to append something

2063
01:42:40,541 --> 01:42:42,833
添加到当前名单中 也就是 
to the current list, a.k.a.

2064
01:42:42,833 --> 01:42:45,125
在这种方法的背景下 自我 
Self in the context of that method.

2065
01:42:45,125 --> 01:42:46,416
我们可以一整天都这样做 
We can do this all day long.

2066
01:42:46,416 --> 01:42:49,625
如果你用过Python中的词典或词典--
If you've used a dictionary or a dict in Python--

2067
01:42:49,625 --> 01:42:53,125
实际上 一直以来 我都把它们叫做词典对象 
I've actually, all this time, been calling them dict objects,

2068
01:42:53,125 --> 01:42:54,500
这是有原因的 
and that's for a reason.

2069
01:42:54,500 --> 01:42:57,250
DICT本身就是一个用Python编写的类 如果你把它拉上来
dict itself is a class in Python, if you pull up

2070
01:42:57,250 --> 01:42:59,166
它的官方文件在这里 
its official documentation here.

2071
01:42:59,166 --> 01:43:03,375
您将看到它确实被定义为一个类 
And you'll see that it is defined, indeed, as itself a class.

2072
01:43:03,375 --> 01:43:05,333
而且这个类也附带了方法 
And that class comes with methods as well.

2073
01:43:05,333 --> 01:43:07,291
所以 每当我们操纵词典时 
And so any time we've manipulated dictionaries,

2074
01:43:07,291 --> 01:43:11,916
我们已经在引擎盖下 使用了所有这些相同的方法 
we've been underneath the hood, using all of those same methods.

2075
01:43:11,916 --> 01:43:14,208
事实上 如果我们真的很好奇 我们就能看到这一点 
And in fact, we can see this if we're really curious.

2076
01:43:14,208 --> 01:43:17,375
让我回到这里来VS Code 
Let me go back over here to VS Code.

2077
01:43:17,375 --> 01:43:20,250
让我们继续创建一个新文件 该文件非常简单
And let me go ahead and create a new file that, very simply, does

2078
01:43:20,250 --> 01:43:22,500
与数据类型有关的东西 
something play around with data types.

2079
01:43:22,500 --> 01:43:24,833
让我继续创建一个新文件 例如 
And let me go ahead and create a new file, for instance,

2080
01:43:24,833 --> 01:43:30,666
名为type.py 这样我就可以查看一些值了 
called, say, type.py, just so that I can poke around inside of some values.

2081
01:43:30,666 --> 01:43:34,333
在type.py中 我将继续执行此操作 
And in type.py, I'm just going to go ahead and do this.

2082
01:43:34,333 --> 01:43:38,375
我要打印出任何类型的东西 比如说数字50 
I'm going to print out whatever the type is of, say, the number 50.

2083
01:43:38,375 --> 01:43:41,500
这是一个你们还没有见过我用过的函数 
And This is a function you've not necessarily seen me use already,

2084
01:43:41,500 --> 01:43:44,500
而且您不会在自己的代码中频繁使用它 
and it's not one you would frequently use in your own code.

2085
01:43:44,500 --> 01:43:46,958
如果需要的话 还有其他方法可以检测到 
There are other ways to detect, if you need to,

2086
01:43:46,958 --> 01:43:48,625
变量的类型是什么 
what the type is of a variable.

2087
01:43:48,625 --> 01:43:53,791
但在这种情况下 50的类型只会告诉我 然后打印出来
But in this case, type of 50 is just going to tell me and then print out

2088
01:43:53,791 --> 01:43:55,833
该值的数据类型是什么 
what the data type is of that value.

2089
01:43:55,833 --> 01:43:58,416
现在 希望我们所有人都能猜到 50确实是
Now, hopefully, all of us could guess that 50 is indeed

2090
01:43:58,416 --> 01:43:59,458
将会是一个整数--
going to be an integer--

2091
01:43:59,458 --> 01:44:01,666
这是一个int 但我们可以这样看它 
that is, an int, but we can see it in this way.

2092
01:44:01,666 --> 01:44:04,541
这也是懂一点编程的强大之处 
And this, too, is what's powerful about knowing a bit of programming.

2093
01:44:04,541 --> 01:44:06,416
如果你想知道问题的答案 
If you want to know the answer to a question,

2094
01:44:06,416 --> 01:44:08,208
试一试 就像我在这里一样 
just try it out, like I am here.

2095
01:44:08,208 --> 01:44:11,125
因此 让我继续运行type.py的Python 回车 
So let me go ahead and run Python of type.py, Enter.

2096
01:44:11,125 --> 01:44:12,208
事实就是如此 
And there it is.

2097
01:44:12,208 --> 01:44:17,458
当你打印出数字50的类型时 你会在屏幕上看到 
When you print out the type of the number 50, you'll see on the screen,

2098
01:44:17,458 --> 01:44:20,625
在这个神秘的语法中 类为“int” 
in this cryptic syntax, class 'int.'

2099
01:44:20,625 --> 01:44:23,541
这可能不是您想要向用户展示的东西 
This is not something that you probably want to show to the user.

2100
01:44:23,541 --> 01:44:26,625
但如果你自己只是想四处走走看看发生了什么
But if you yourself just want to poke around and see what's going on

2101
01:44:26,625 --> 01:44:29,166
或者以某种方式利用这些信息 这是
or maybe use that information somehow, it's

2102
01:44:29,166 --> 01:44:32,833
当然 您可以使用此类型的函数来实现这一点 
certainly at your disposal to use this type function for that.

2103
01:44:32,833 --> 01:44:34,583
让我们稍微改变一下 
Let's change it around a little bit.

2104
01:44:34,583 --> 01:44:38,375
不是作为参数传递给类型50 而是作为整型传递 
Instead of passing as the argument to type 50, as an int,

2105
01:44:38,375 --> 01:44:41,291
让我们输入一些熟悉的东西 比如“Hello world ”
let's type something also familiar, like "hello, world,"

2106
01:44:41,291 --> 01:44:43,166
在双引号或单引号中 
in double or single quotes.

2107
01:44:43,166 --> 01:44:45,541
让我回到我的终端窗口 清除屏幕 
Let me go back to my terminal window, clear the screen,

2108
01:44:45,541 --> 01:44:47,208
并再次运行type.py的Python 
and run Python of type.py again.

2109
01:44:47,208 --> 01:44:49,333
现在 瞧 就是这样 
And now, voila, there it is.

2110
01:44:49,333 --> 01:44:52,750
一直以来 字符串也是一个类 
All this time, a str is also a class.

2111
01:44:52,750 --> 01:44:54,333
我们可以再这样做几次 因为 
We can do this a few more times, For.

2112
01:44:54,333 --> 01:44:54,833
实例 
Instance.

2113
01:44:54,833 --> 01:44:58,875
让我们继续 把“你好 世界”变成一个空的清单--
Let's go ahead and change "hello, world" to just an empty list--

2114
01:44:58,875 --> 01:45:01,291
开方括号和闭方括号 
open square bracket, closed square bracket.

2115
01:45:01,291 --> 01:45:03,375
这看起来有点神秘 
And this is starting to look a little cryptic,

2116
01:45:03,375 --> 01:45:04,791
但是 再说一次 注意我在做什么 
but, again, notice what I'm doing.

2117
01:45:04,791 --> 01:45:06,708
方括号中是一个空列表 
In square brackets is an empty list.

2118
01:45:06,708 --> 01:45:08,083
我们以前也这么做过 
We've done that before.

2119
01:45:08,083 --> 01:45:11,583
这是这个新类型函数的唯一参数 
That is the sole argument to this new type function.

2120
01:45:11,583 --> 01:45:14,666
它只是被传递给打印函数
And that's just being passed to the print function

2121
01:45:14,666 --> 01:45:18,458
这样 type的返回值就是要打印的参数 
so that the return value of type is the argument to print.

2122
01:45:18,458 --> 01:45:22,541
因此 如果我现在运行这段代码 即type.py的Python 它就在那里 
So if I now run this code, Python of type.py, there it is.

2123
01:45:22,541 --> 01:45:24,458
清单也是一个类 
A list is a class, too.

2124
01:45:24,458 --> 01:45:28,000
您可能还记得我说过 您还可以创建一个空列表
You might recall that I said that you can also create an empty list

2125
01:45:28,000 --> 01:45:31,541
按字面意思做list() 
by literally doing list ().

2126
01:45:31,541 --> 01:45:34,375
这有点不一致 就像我们现在可以做的那样
This is a bit of an inconsistency, as we can now

2127
01:45:34,375 --> 01:45:39,958
标识int和字符串 现在列出--从技术上讲 它们都是小写 
identify that int and str and now list-- they're technically all lowercase.

2128
01:45:39,958 --> 01:45:44,708
我不遗余力地创建了我的学生班级 以拥有这样的资本
And I went to great lengths of creating my student class to have that capital

2129
01:45:44,708 --> 01:45:46,583
这是一次会议 
S. That's a convention.

2130
01:45:46,583 --> 01:45:51,250
因为int、stir、list和其他代码都是随Python一起提供的 
Because int and stir and list and others come with Python,

2131
01:45:51,250 --> 01:45:55,416
他们决定让他们的内置数据类型--尽管它们是类--
they decided to make their built-in data types-- even though they're classes--

2132
01:45:55,416 --> 01:45:56,375
全是小写字母 
all lowercase.

2133
01:45:56,375 --> 01:45:59,750
但是约定 在创建时在Python社区中的推荐
But the convention, the recommendation in the Python community when creating

2134
01:45:59,750 --> 01:46:03,541
你们的课程是大写第一个字母 就像我做的那样 
your classes is to capitalize the first letter, as I did,

2135
01:46:03,541 --> 01:46:10,541
在像学生这样的地方 大写S 但是list()等同于
in something like Student, capital S. But list () is identical to really just

2136
01:46:10,541 --> 01:46:12,041
两个空的方括号 
two empty square brackets.

2137
01:46:12,041 --> 01:46:16,416
如果我清空屏幕并再次运行type.py 您将看到完全相同的结果 
If I clear my screen and run type.py again, you see the exact same thing.

2138
01:46:16,416 --> 01:46:17,750
这个类被称为List 
The class is called list.

2139
01:46:17,750 --> 01:46:19,041
让我们再来一次 
Let's do one more.

2140
01:46:19,041 --> 01:46:23,041
让我将列表更改为不是方括号 而是花括号 
Let me change the list to be not square brackets but curly braces.

2141
01:46:23,041 --> 01:46:24,125
我们以前也这么做过 
We've done this before.

2142
01:46:24,125 --> 01:46:27,916
每当我做了两个中间没有花括号的花括号时 当然 
Any time I've done two curly braces with nothing in between, this, of course,

2143
01:46:27,916 --> 01:46:31,458
是空词典 或者是Python中的Dict对象 
is an empty dictionary, or a dict object in Python.

2144
01:46:31,458 --> 01:46:32,750
嗯 我们现在可以看到了 
Well, we can see that now.

2145
01:46:32,750 --> 01:46:35,500
让我清空我的屏幕 运行type.py的Python 回车 
Let me clear my screen, run Python of type.py, Enter,

2146
01:46:35,500 --> 01:46:37,666
这就是--班级的口头禅 “
and there it is-- class 'dict."

2147
01:46:37,666 --> 01:46:39,458
它一直都在那里 
It's been there this whole time.

2148
01:46:39,458 --> 01:46:42,333
我们只是直到今天才把它称为一门课 
We just didn't call it a class until today.

2149
01:46:42,333 --> 01:46:44,625
我同样可以明确地做这一件事 
I can similarly do this one explicitly.

2150
01:46:44,625 --> 01:46:48,500
我们不用两个大括号 而是用两个圆括号写出dict 
Instead of two curly braces, let's write out dict with two parentheses.

2151
01:46:48,500 --> 01:46:51,541
现在我们又有了很多圆括号 就像List一样 
Now we have a lot of parentheses again, like with list.

2152
01:46:51,541 --> 01:46:55,250
但这只是更加清楚地表明 DICT对象的类型
But this is just making even more clear that the type of a dict object

2153
01:46:55,250 --> 01:46:58,333
确实是班级 DICT 本身 
is indeed the class, dict, itself.

2154
01:46:58,333 --> 01:47:02,375
这就是说 尽管今天的许多概念和语法都很新 
So this is to say that, as new as a lot of today's idea and syntax,

2155
01:47:02,375 --> 01:47:05,708
可能你真的在用它 也许你不知道 
might be you've actually been using it, perhaps unbeknownst to you,

2156
01:47:05,708 --> 01:47:06,750
已经好几个星期了 
for weeks now.

2157
01:47:06,750 --> 01:47:09,416
我们现在只有一些术语来描述
We now just have terminology to describe what

2158
01:47:09,416 --> 01:47:10,958
这是我们一直在做的事情 
it is we've been doing all this time.

2159
01:47:10,958 --> 01:47:14,166
现在你有了表现力 通过一些练习 
And you now have the expressiveness, with some practice,

2160
01:47:14,166 --> 01:47:18,791
要创建您自己的类 其中包含您自己的实例变量 
to create your own classes, inside of which are your own instance variables,

2161
01:47:18,791 --> 01:47:23,708
可能包装了这些属性和您自己的实例方法 
perhaps wrapped with those properties and your own instance methods.

2162
01:47:23,708 --> 01:47:27,125
但事实证明 世界上还有其他类型的方法 
But it turns out there's other types of methods in the world.

2163
01:47:27,125 --> 01:47:29,375
到目前为止 我一直在慎重地打电话给
Thus far, I've been deliberate in calling

2164
01:47:29,375 --> 01:47:34,375
我们的所有变量、实例变量和所有方法实例
all of our variables instance variables and all of our methods instance

2165
01:47:34,375 --> 01:47:35,125
方法：研究方法 
methods.

2166
01:47:35,125 --> 01:47:40,333
结果发现还有其他类型的变量和方法 
It turns out there's other types of variables and methods out there,

2167
01:47:40,333 --> 01:47:42,875
其中之一被称为类方法 
and one of those is called class methods.

2168
01:47:42,875 --> 01:47:48,333
事实证明 有时这并不是真正必要或明智的
It turns out that sometimes it's not really necessary or sensible

2169
01:47:48,333 --> 01:47:52,333
要将函数与类的对象相关联 
to associate a function with objects of a class,

2170
01:47:52,333 --> 01:47:55,000
而是与班级本身有关 
but rather with the class itself.

2171
01:47:55,000 --> 01:47:59,833
实例或类的对象是其非常特定的化身 
An instance, or an object of a class, is a very specific incarnation thereof.

2172
01:47:59,833 --> 01:48:03,333
再说一次 在那个有许多外观相同的建筑的社区 
Again, on that neighborhood that has a lot of identical looking buildings,

2173
01:48:03,333 --> 01:48:06,458
但它们都有一点不同 因为油漆不同 
but they're all a little bit different because of different paint and such,

2174
01:48:06,458 --> 01:48:09,666
有时 您可能有相关的功能
sometimes you might have functionality related

2175
01:48:09,666 --> 01:48:13,541
对每一栋房子来说都不是独一无二的
to each of those houses that isn't distinct or unique for any

2176
01:48:13,541 --> 01:48:14,333
所有的房子 
of the houses.

2177
01:48:14,333 --> 01:48:17,375
它的功能将是完全相同的 不是
It's functionality that's going to be exactly the same no

2178
01:48:17,375 --> 01:48:19,208
让问题中的房子变得更重要 
matter the house in question.

2179
01:48:19,208 --> 01:48:21,541
面向对象编程领域也是如此 
Same in the world of object-oriented programming.

2180
01:48:21,541 --> 01:48:24,375
有时你想要一些功能 一些动作
Sometimes you want some functionality, some action

2181
01:48:24,375 --> 01:48:29,500
与类本身相关联 而不管特定对象的
to be associated with the class itself, no matter what the specific object's

2182
01:48:29,500 --> 01:48:32,333
自己的值或实例变量是 
own values or instance variables are.

2183
01:48:32,333 --> 01:48:36,125
为此 我们有一个名为@类方法的关键字 
And for that, we have a keyword called @classmethod.

2184
01:48:36,125 --> 01:48:38,458
这是另一个装饰者--真的 另一个
This is another decorator-- really, another

2185
01:48:38,458 --> 01:48:43,416
函数--你可以用它来指定这个方法不是 
function-- that you can use to specify that this method is not,

2186
01:48:43,416 --> 01:48:46,208
默认情况下 隐式地提供一个实例方法 
by default, implicitly an instance method that

2187
01:48:46,208 --> 01:48:48,791
可以访问self 对象本身 
has access to self, the object itself.

2188
01:48:48,791 --> 01:48:51,750
这是一个不能访问self的类方法 
This is a class method that's not going to have access to self,

2189
01:48:51,750 --> 01:48:54,166
但它知道自己所在的类
but it does know what class it's inside.

2190
01:48:54,166 --> 01:48:55,625
那么我这样说是什么意思呢？
So what do I mean by this?

2191
01:48:55,625 --> 01:48:57,416
让我们回到VS Code 
Well, let me go back to VS Code here.

2192
01:48:57,416 --> 01:49:01,291
我建议我们创建一个新文件 
And let me propose that we create a new file this time implementing

2193
01:49:01,291 --> 01:49:04,958
分院帽的概念 也来自哈利波特的世界 
the notion of a-- the sorting hat, from the world of Harry Potter as well,

2194
01:49:04,958 --> 01:49:06,041
保持主题 
to stay on theme.

2195
01:49:06,041 --> 01:49:08,666
我将继续运行hat.py的代码 
I'm going to go ahead and run code of hat.py.

2196
01:49:08,666 --> 01:49:12,041
在hat.py中 让我们实现排序帽的概念 
And in hat.py, let's implement the notion of the sorting hat.

2197
01:49:12,041 --> 01:49:14,583
如果在书中和电影中不熟悉
If unfamiliar in the books and in the films

2198
01:49:14,583 --> 01:49:17,333
有一顶尖尖的帽子
there is literally a pointy hat that, when

2199
01:49:17,333 --> 01:49:20,916
一个学生把它戴在头上 可以说 
a student put it's on their head, that sorting hat, so to speak,

2200
01:49:20,916 --> 01:49:23,708
决定学生住哪间房子--不管是
decides what house the student is in-- whether it's

2201
01:49:23,708 --> 01:49:25,416
格兰芬多或者别的什么 
Gryffindor or something else.

2202
01:49:25,416 --> 01:49:29,500
让我们用代码实现这个排序帽的概念 
So let's implement, in code, this notion of a sorting hat such that,

2203
01:49:29,500 --> 01:49:33,250
当我们把一个学生的名字传递给排序帽时 
when we pass to the sorting hat the name of a student, like, quote, unquote,

2204
01:49:33,250 --> 01:49:36,083
“哈利”这个排序帽 用代码实现 
"Harry" this sorting hat, implemented in code,

2205
01:49:36,083 --> 01:49:40,041
会告诉我们那个学生应该在哪个房子里
will tell us what house that student should be in.

2206
01:49:40,041 --> 01:49:41,750
好吧 让我们开始吧 
Well, let's go ahead and do this.

2207
01:49:41,750 --> 01:49:46,708
在hat.py中 首先 让我们继续定义一个名为hat的类 
In hat.py, first, let's go ahead and define a class called hat,

2208
01:49:46,708 --> 01:49:49,333
然后让我们回到实现它本身 
and then let's get back to implementing it itself.

2209
01:49:49,333 --> 01:49:52,041
我发现这是一个有用的技巧 不仅仅是教学
And I find this to be a helpful technique, not just with teaching

2210
01:49:52,041 --> 01:49:53,375
而是写代码的时候
but when writing code.

2211
01:49:53,375 --> 01:49:55,291
我知道我想上帽子课 
I know I want a hat class.

2212
01:49:55,291 --> 01:49:57,541
我还不知道我想让它做什么
I don't necessarily know what I want it to do yet,

2213
01:49:57,541 --> 01:50:00,083
所以我要创建这个占位符 点 
so I'm going to create this placeholder, dot, dot, dot,

2214
01:50:00,083 --> 01:50:01,791
所以我会回到这个话题 
so I'll come back to that.

2215
01:50:01,791 --> 01:50:05,000
现在让我们试着使用这个类 就好像它存在一样 
Let's now try to use this class as though it existed.

2216
01:50:05,000 --> 01:50:08,250
从那里 我也许能意识到
And from there, I perhaps can realize exactly what

2217
01:50:08,250 --> 01:50:11,625
类需要具备的功能来支持我的用例 
functionality that class needs to have to support my use case.

2218
01:50:11,625 --> 01:50:14,708
让我们继续 在所有的数组中创建一个名为hat的变量
Let me go ahead and create a variable called hat in all lowercase

2219
01:50:14,708 --> 01:50:17,500
并实例化一个帽子对象 
and instantiate a hat object.

2220
01:50:17,500 --> 01:50:21,041
所以不管帽子班最后是什么样子 
So no matter what the hat class ends up looking like,

2221
01:50:21,041 --> 01:50:24,125
这是实例化的常用语法
this is the common syntax for instantiating

2222
01:50:24,125 --> 01:50:25,916
某一类的物体 
an object of a certain class.

2223
01:50:25,916 --> 01:50:28,958
在过去 我们看到学生都是小写的 
In the past, we saw student, all lowercase,

2224
01:50:28,958 --> 01:50:32,708
等于大写的学生 左括号 右括号 
equals capital Student, open parenthesis, close parentheses,

2225
01:50:32,708 --> 01:50:35,375
最后 我们加上了名字和房子之类的东西 
and then eventually, we added in things like name and house.

2226
01:50:35,375 --> 01:50:39,375
现在 让我们假设这顶帽子比一个学生简单得多 
For now, let's assume that the hat is much simpler than a student,

2227
01:50:39,375 --> 01:50:41,500
而且它只有分类能力 
and it only has sorting capabilities.

2228
01:50:41,500 --> 01:50:44,791
因此 我甚至不会在这里传递任何论点 
So I'm not going to even pass any arguments there, too.

2229
01:50:44,791 --> 01:50:50,708
让我假设分类帽有一个函数--其中有一个方法
Let me assume that the sorting hat has one function-- one method inside of it

2230
01:50:50,708 --> 01:50:51,583
叫 Sort 
called, sort.

2231
01:50:51,583 --> 01:50:59,666
因此 如果我要HAT.Sort(“Harry”) 让我们建议打印出什么房子
And so if I do hat.sort ("Harry"), let's propose that that prints out what house

2232
01:50:59,666 --> 01:51:01,458
那个学生应该在里面 
that student should be in.

2233
01:51:01,458 --> 01:51:02,541
就是这样了 
So that's it.

2234
01:51:02,541 --> 01:51:04,541
我要概括一下--
I'm going to encapsulate--

2235
01:51:04,541 --> 01:51:06,916
它被藏在一个帽子班里--
that is tuck away inside of a hat class--

2236
01:51:06,916 --> 01:51:11,250
所有这些必需的功能 我将打印到屏幕上
all of this requisite functionality, and I'm going to print out onto the screen

2237
01:51:11,250 --> 01:51:12,458
什么帽子--
what hat--

2238
01:51:12,458 --> 01:51:15,208
哈利属于哪所房子 
what house Harry belongs in.

2239
01:51:15,208 --> 01:51:20,166
现在我想我需要开始实际初始化这个类了 
Now I think I need to get into the weeds of actually initializing this class.

2240
01:51:20,166 --> 01:51:22,041
好吧 让我继续做这件事 
Well, let me go ahead and do this.

2241
01:51:22,041 --> 01:51:24,791
如果我不介意将帽子参数化--
If I don't care to parameterize hat--

2242
01:51:24,791 --> 01:51:29,083
例如 我只想对值进行排序 
I just want to, for instance sort values,

2243
01:51:29,083 --> 01:51:31,916
让我们继续定义这个函数 首先是排序 
let's go ahead and define this function, sort, first.

2244
01:51:31,916 --> 01:51:35,291
所以让我们定义Sort 作为第一个参数 
So let's define sort, as taking a first argument, self,

2245
01:51:35,291 --> 01:51:39,125
在将实例方法定义为
which is always going to be the case when defining an instance method as

2246
01:51:39,125 --> 01:51:39,750
在此之前 
before.

2247
01:51:39,750 --> 01:51:43,750
但Sort方法显然接受了程序员我的一个参数--
But the sort method clearly takes one argument from the programmer, me--

2248
01:51:43,750 --> 01:51:45,583
即学生的名字 
namely the student's name.

2249
01:51:45,583 --> 01:51:47,708
再说一次 我们以前见过这种二分法 
And again, we've seen this dichotomy before.

2250
01:51:47,708 --> 01:51:52,083
即使我试图传递一个参数 当我定义该方法时 
Even though I'm trying to pass in one argument, when I define the method,

2251
01:51:52,083 --> 01:51:55,166
它需要这么多的争论 再加上一个--
it's got to take that many arguments, plus one more--

2252
01:51:55,166 --> 01:51:58,208
自身 它始终将由Python自动传入
self which is always going to be automatically passed in by Python

2253
01:51:58,208 --> 01:51:59,583
第一 
first.

2254
01:51:59,583 --> 01:52:01,291
我想要做什么？
What do I want to do?

2255
01:52:01,291 --> 01:52:03,291
好吧 让我们继续做这样的事情 
Well, let's go ahead and do something like this.

2256
01:52:06,166 --> 01:52:12,375
Print 这个名字--比如“is in” “Some House” 
Print, this name-- how about "is in," "some house."

2257
01:52:12,375 --> 01:52:14,291
我将再次使用一些占位符代码
I'm going to, again, use some placeholder code

2258
01:52:14,291 --> 01:52:18,000
对于我自己来说 因为我不太确定如何完成这个排序
for myself because I'm not quite sure how to finish implementing this sorting

2259
01:52:18,000 --> 01:52:18,583
帽子 
hat.

2260
01:52:18,583 --> 01:52:21,708
但我认为这足以测试我的代码现在在哪里 
But I think that's enough to just test where my code is at now.

2261
01:52:21,708 --> 01:52:25,625
让我继续运行hat.py的Python 然后按Enter键 
Let me go ahead and run Python of hat.py and hit Enter.

2262
01:52:25,625 --> 01:52:28,250
而且看起来 哈里确实在某个房子里 
And it looks like, indeed, Harry is in some house.

2263
01:52:28,250 --> 01:52:31,958
我们还没有完成 因为它显然没有做任何有趣的事情 
We're not done yet because it's clearly not doing anything interesting,

2264
01:52:31,958 --> 01:52:35,791
但它至少运行正常 没有任何错误 
but it at least is running correctly with no errors.

2265
01:52:35,791 --> 01:52:40,125
好吧 让我们现在继续 决定在哪里--
Well, let's go ahead now and decide where--

2266
01:52:40,125 --> 01:52:43,541
通过引入一点随机性 哈里到底应该是什么样的人
what house Harry should actually be in by introducing a bit of randomness

2267
01:52:43,541 --> 01:52:45,625
并随机选择一所房子 
and choosing a house randomly.

2268
01:52:45,625 --> 01:52:47,500
虽然我可以用几种方法来做到这一点 但让我们 
While I can do this in a few ways, Let.

2269
01:52:47,500 --> 01:52:48,875
我继续做这件事 
Me go ahead and do this.

2270
01:52:48,875 --> 01:52:51,541
我需要一份某处的房屋清单 
I need to have a list of houses somewhere.

2271
01:52:51,541 --> 01:52:52,833
我该把它放在哪里呢？
So where can I put that?

2272
01:52:52,833 --> 01:52:54,708
我可以用不同的方法解决这个问题 
I could solve this problem in different ways.

2273
01:52:54,708 --> 01:52:56,000
让我提议我做这件事 
Let me propose that I do this.

2274
01:52:56,000 --> 01:52:58,833
让我定义一个名为init的方法 就像我以前所做的那样 
Let me define a method called init, as I've done before,

2275
01:52:58,833 --> 01:53:01,250
这是针对自己的 但没有其他论点 
that takes in self, but no other arguments.

2276
01:53:01,250 --> 01:53:04,583
无论何时实例化分类帽子 我们都要这样做 
And whenever the sorting hat is instantiated, let's do this.

2277
01:53:04,583 --> 01:53:09,958
让我们创建一个House实例变量 复数 等于这个列表--
Let's create a houses instance variable, plural, that equals this list--

2278
01:53:09,958 --> 01:53:16,958
格兰芬多 赫奇帕奇 拉文克劳 斯莱特林 
Gryffindor, Hufflepuff, Ravenclaw, Slytherin,

2279
01:53:16,958 --> 01:53:19,416
所以我们之前用过的一模一样的名单 
so the exact same list that we've used before,

2280
01:53:19,416 --> 01:53:23,333
我将它存储在这个类的一个实例变量中 
and I'm storing it in an instance variable inside of this class.

2281
01:53:23,333 --> 01:53:26,708
我不会拿自己以外的任何论点来灌输 
I'm not taking any arguments beyond self to init,

2282
01:53:26,708 --> 01:53:30,625
但我只是需要这个值列表的某个地方 例如 
but I just need this list of values somewhere, for instance.

2283
01:53:30,625 --> 01:53:32,250
那么我能在这里做些什么呢？
So what can I do here?

2284
01:53:32,250 --> 01:53:36,416
好吧 让我继续把一些房子换成真正的房子 
Well, let me go ahead and replace some house with the actual house.

2285
01:53:36,416 --> 01:53:37,541
那么 我在这里能做什么呢？
Well, what could I do here?

2286
01:53:37,541 --> 01:53:39,583
嗯 我想在那里建一栋房子 
Well, I want to put a house there.

2287
01:53:39,583 --> 01:53:42,083
好 让我们继续创建一个名为house的变量 
Well, let's go ahead and create a variable called house.

2288
01:53:42,083 --> 01:53:46,291
如果你回想一下我们在随机模块中对库的讨论 
And if you think back to our discussion of libraries, in the random module,

2289
01:53:46,291 --> 01:53:51,791
有一个名为Choose的函数 如果您传入一个选项列表 
there is a function called choice that, if you pass in a list of choices,

2290
01:53:51,791 --> 01:53:56,333
就像自己的房子一样 它会从这四个房子中随机挑选一座房子 
like self.houses, that will pick a random house out of those four.

2291
01:53:56,333 --> 01:53:58,750
然后在第7行 我可以把它传进去 
And then on line 7, I can pass it in.

2292
01:53:58,750 --> 01:54:01,916
如果我想加强这一点 让我继续并突出显示该代码 
If I want to tighten this up, let me just go ahead and highlight that code,

2293
01:54:01,916 --> 01:54:03,125
去掉变量 
get rid of the variable.

2294
01:54:03,125 --> 01:54:04,541
从技术上讲 这是不必要的 
It's technically unnecessary.

2295
01:54:04,541 --> 01:54:06,666
而且由于代码行仍然很短 
And because the line of code is still pretty short,

2296
01:54:06,666 --> 01:54:09,458
我可以把所有的事情都放在一句话里 
I'm OK with just putting it all in one line.

2297
01:54:09,458 --> 01:54:13,000
但我肯定可以像刚才一样使用这个变量 
But I could certainly use the variable like I did a moment ago.

2298
01:54:13,000 --> 01:54:14,041
那么我做了什么呢？
So what have I done?

2299
01:54:14,041 --> 01:54:20,708
在我的init函数中 我定义了对象的初始化
In my init function, I have defined a initialization of the object

2300
01:54:20,708 --> 01:54:23,875
储存在自己的房子里 有四栋房子 
that stores in self.houses the list of four houses.

2301
01:54:23,875 --> 01:54:26,583
然后 在某种程度上 我访问了同样的列表 
And then, in sort, I'm accessing that same list,

2302
01:54:26,583 --> 01:54:30,041
但我随机选择了那里的一套房子 
but I'm randomly choosing the set of houses there.

2303
01:54:30,041 --> 01:54:31,791
现在 我为什么要这样做呢？
Now, why have I done it in this way?

2304
01:54:31,791 --> 01:54:33,750
这也是普遍的惯例 
This, too, is general convention.

2305
01:54:33,750 --> 01:54:35,916
任何时候你有一张清单--谁知道呢？
Any time you have a list of things that-- who knows?

2306
01:54:35,916 --> 01:54:38,000
也许会随着时间的推移而改变 
Maybe will change over time.

2307
01:54:38,000 --> 01:54:41,541
像哈佛这样的地方多年来一直在建造新房子 
Places like Harvard have constructed new houses over the years,

2308
01:54:41,541 --> 01:54:43,958
因此 您可能需要更改可用房屋的列表 
so you might have to change the list of available houses.

2309
01:54:43,958 --> 01:54:47,083
这并没有出现在哈利波特的七本书或八部电影中 
It didn't happen in seven books or eight films of Harry Potter.

2310
01:54:47,083 --> 01:54:49,208
但你可以想象也许霍格沃茨最终
But you could imagine maybe Hogwarts eventually

2311
01:54:49,208 --> 01:54:54,291
有第五宫 所以把常量列表放在
has a fifth house, so there's generally some value in putting list of constants

2312
01:54:54,291 --> 01:54:57,333
在你的文件顶部 在类的顶部 所以它只是
toward the top of your file, toward the top of the class so it's just

2313
01:54:57,333 --> 01:54:59,875
很明显 值的列表是什么 
obvious what the list of values is.

2314
01:54:59,875 --> 01:55:02,750
你不一定想把它藏在某些功能中 
You don't want to necessarily tuck it away in some function,

2315
01:55:02,750 --> 01:55:06,375
就像排序一样 特别是当你想使用这个函数的时候--
like sort, especially if you might want to use that function--

2316
01:55:06,375 --> 01:55:10,166
抱歉 特别是如果您想在多个功能中使用该列表 而不是
sorry, especially if you want to use that list in multiple functions, not

2317
01:55:10,166 --> 01:55:10,708
只是整理一下 
just sort.

2318
01:55:10,708 --> 01:55:12,583
但如果我继续增加这门课 你可能会
But if I kept adding to this class, you might

2319
01:55:12,583 --> 01:55:15,083
想要在多个功能中使用相同的房屋列表 
want to use that same list of houses in multiple functions.

2320
01:55:15,083 --> 01:55:20,541
因此 让我们通过将其存储在self.house中来将其保存在对象本身中 
So let's keep it in the object itself by storing it in self.houses.

2321
01:55:20,541 --> 01:55:23,625
好吧 好吧 我们可能要改变历史进程了 
All right, well, we're about to change the course of history here perhaps.

2322
01:55:23,625 --> 01:55:27,666
让我来做一个HAT.PY的蟒蛇 我想我们即将把Harry
Let me do Python of hat.py, and I think we're about to assign Harry

2323
01:55:27,666 --> 01:55:30,833
去那四所房子中的一所 
to one of those four houses randomly.

2324
01:55:30,833 --> 01:55:33,041
嗯 名字错误 
Huh, NameError.

2325
01:55:33,041 --> 01:55:35,041
未定义名称‘RANDOM’ 
Name 'random' is not defined.

2326
01:55:35,041 --> 01:55:38,416
嗯 等一下 我哪里出错了？
Well, wait a minute, where did I go wrong here?

2327
01:55:38,416 --> 01:55:43,541
回想一下我们关于图书馆的课程 为什么我的代码崩溃了 而没有告诉我
Thinking back to our class on libraries, why did my code break and not tell me

2328
01:55:43,541 --> 01:55:45,625
哈里要去哪里？
where Harry is to be?

2329
01:55:45,625 --> 01:55:48,708
观众：您没有导入随机库 
AUDIENCE: You did not import the random library.

2330
01:55:48,708 --> 01:55:49,708
大卫·J·马兰：没错 
DAVID J. MALAN: Exactly.

2331
01:55:49,708 --> 01:55:52,541
如果我想使用随机库或模块 
If the random library or module is something I want to use,

2332
01:55:52,541 --> 01:55:55,583
我需要在我的文件顶部告诉Python这一点 
I need to tell Python that at the top of my file.

2333
01:55:55,583 --> 01:55:58,958
所以让我在这里做随机导入 
So let me go up here and do import random.

2334
01:55:58,958 --> 01:56:01,708
然后 在这下面 让我继续清除我的终端窗口
And then, below that, let me go ahead and clear my terminal window

2335
01:56:01,708 --> 01:56:02,416
再试一次 
and try again.

2336
01:56:02,416 --> 01:56:08,041
在我的手指上祈祷 看看哈里将会在哪里结束 
Python of hat.py, crossing my fingers, seeing where Harry is going to end up.

2337
01:56:08,041 --> 01:56:12,041
好了 哈里现在正式加入赫奇帕奇了 
And, OK, Harry as of now is officially in Hufflepuff,

2338
01:56:12,041 --> 01:56:14,500
不管你读过或看到过什么 
despite everything you've read or seen.

2339
01:56:14,500 --> 01:56:15,875
好吧 让我们再来一次 
Well, let's run this again.

2340
01:56:15,875 --> 01:56:19,833
让我清理我的窗口并运行Python中的hat.py 现在他在RavenClaw 
Let me clear my window and run Python of hat.py, and now he's in Ravenclaw.

2341
01:56:19,833 --> 01:56:21,541
这与使用随机数是一致的 
That's consistent with using random.

2342
01:56:21,541 --> 01:56:23,375
我们清除它 然后再运行一次 
Let's clear that and run it again.

2343
01:56:23,375 --> 01:56:25,458
他还在拉文克劳 但这是有可能的
He's still in Ravenclaw, but that could happen,

2344
01:56:25,458 --> 01:56:26,833
尽管有四个选择 
even though there's four choices.

2345
01:56:26,833 --> 01:56:27,625
我们再来一次吧 
Let's do it again.

2346
01:56:27,625 --> 01:56:29,250
赫奇帕奇--回到赫奇帕奇 
Hufflepuff-- back in Hufflepuff.

2347
01:56:29,250 --> 01:56:31,666
我们似乎得不到正确的答案 
We can't seem to get the right answer.

2348
01:56:31,666 --> 01:56:34,375
现在他在格兰芬多 尽管是随机的 
Now he's in Gryffindor, albeit randomly.

2349
01:56:34,375 --> 01:56:37,208
因此 我们似乎有一个项目 基于这些有限的测试 
So we seem to have a program that, based on these limited tests,

2350
01:56:37,208 --> 01:56:41,166
似乎是在随机给哈里分配一所房子 
seems to be assigning Harry to a house randomly.

2351
01:56:41,166 --> 01:56:45,416
现在 我有点懒得让SORT打印出这个值 
Now I'm somewhat lazily just letting sort print out this value.

2352
01:56:45,416 --> 01:56:50,375
我可以做其他的事情 比如返回一个字符串 然后让我在第13行 
I could do something else, like return a string, and then let me, on line 13,

2353
01:56:50,375 --> 01:56:51,916
帮我打印一下 
do the printing for me.

2354
01:56:51,916 --> 01:56:57,000
但就目前而言 我认为我们有一个名为Hat的班级的例子 
But for now, I think we have an example of a class called hat that,

2355
01:56:57,000 --> 01:57:00,125
尽管如此 今天还是应用了我们到目前为止学到的一些经验教训 
nonetheless, applies some of our lessons learned thus far today,

2356
01:57:00,125 --> 01:57:03,333
在那里我创建了一个类--因为坦率地说 分院帽是--
where I've created a class-- because a sorting hat is, frankly--

2357
01:57:03,333 --> 01:57:06,250
好吧 我正要说真实世界的实体 但真的
well, I was about to say real world entity, but really

2358
01:57:06,250 --> 01:57:07,875
一个虚幻的世界实体 
a fantasy world entity.

2359
01:57:07,875 --> 01:57:11,791
事实上 这可能是一种常见的启发式或心智模式 
And indeed, that's a, perhaps, common heuristic or mental model to have.

2360
01:57:11,791 --> 01:57:16,041
应该在什么时候使用类来表示代码中的某些内容？
When should you use a class to represent something in your code?

2361
01:57:16,041 --> 01:57:20,625
通常 当你试图代表一些真实世界的实体时
Very often, when you're trying to represent some real world entity

2362
01:57:20,625 --> 01:57:25,791
或者是幻想世界的实体 比如学生 这是现实世界中的东西 
or fantasy world entity, like a student, which is something in the real world,

2363
01:57:25,791 --> 01:57:28,625
就像一顶分院帽 好吧 根本不存在 
like a sorting hat, which, OK, doesn't exist,

2364
01:57:28,625 --> 01:57:32,166
但它确实是这样的 所以有一个关于HAT的类是很合理的 
but hat's certainly do, so quite reasonable to have a class for hat.

2365
01:57:32,166 --> 01:57:36,500
类代表真实世界实体的情况并不总是这样 
And that's not always the case that classes represent real world entities.

2366
01:57:36,500 --> 01:57:42,291
但到目前为止 我们已经看到int、stir、list和dict--这些
But we've seen thus far that int and stir and list and dict-- these

2367
01:57:42,291 --> 01:57:44,666
都是你在现实世界中可能会有的结构 
are all structures that you might have in the real world.

2368
01:57:44,666 --> 01:57:47,416
我们有整数和文本字符串以及其他东西 
We have integers and strings of text and other things.

2369
01:57:47,416 --> 01:57:50,833
因此 更严格地说 甚至代表这些东西也是有意义的 
So it rather makes sense to represent even those things, more technically,

2370
01:57:50,833 --> 01:57:52,625
也使用类 
using a class as well.

2371
01:57:52,625 --> 01:57:56,291
你可以只用一本词典来代表一个学生或一顶帽子 
You could use just a dictionary to represent a student or a hat.

2372
01:57:56,291 --> 01:58:00,875
但同样 类带来了所有这些 甚至更多的功能 
But again, with classes come all this and even more functionality.

2373
01:58:00,875 --> 01:58:06,791
但老实说 我在这里并没有以“正确的方式”使用类 
But I honestly am not using classes in, really, the "right way" here.

2374
01:58:06,791 --> 01:58:07,416
为什么？
Why?

2375
01:58:07,416 --> 01:58:10,625
好吧 在哈利波特的世界里 真的只有 
Well, in the world of Harry Potter there really is only,

2376
01:58:10,625 --> 01:58:12,791
据我所知 一顶分院帽 
to my knowledge, one sorting hat.

2377
01:58:12,791 --> 01:58:17,000
然而 在这里 我实现了一个名为Hat的类 
And yet, here I have gone and implemented a class called hat.

2378
01:58:17,000 --> 01:58:20,333
同样 类就像一张蓝图 一个模板 
And again, a class is like a blueprint, a template,

2379
01:58:20,333 --> 01:58:24,625
允许您在其中创建一个或多个对象的模具 
a mold that allows you to create one or more objects thereof.

2380
01:58:24,625 --> 01:58:27,041
到目前为止 我的大多数程序都很简单 
Now, most of my programs Thus far have been pretty simple,

2381
01:58:27,041 --> 01:58:28,750
我刚刚创造了一个学生 
and I've just created one student.

2382
01:58:28,750 --> 01:58:31,208
但可以肯定的是 如果我花更多的时间和编写更多的代码 
But certainly, if I spent more time and wrote more code,

2383
01:58:31,208 --> 01:58:33,583
您可以想象编写一个程序 
you could imagine writing one program that

2384
01:58:33,583 --> 01:58:36,208
有一份学生名单--更多的学生
has a list of students-- many more students

2385
01:58:36,208 --> 01:58:38,708
而不仅仅是我们一直在演示的那个 
than just the one we keep demonstrating.

2386
01:58:38,708 --> 01:58:40,625
然而 这会有点奇怪--
Yet it would be a little weird--

2387
01:58:40,625 --> 01:58:43,291
这与现实或幻想有点不一致
it's a little inconsistent with the real or the fantasy

2388
01:58:43,291 --> 01:58:48,041
哈利波特世界实例化一个、两个、三个或更多的分类帽子 
world of Harry Potter to instantiate one, two, three or more sorting hats.

2389
01:58:48,041 --> 01:58:49,708
真的只有一个 
There really is just one.

2390
01:58:49,708 --> 01:58:51,875
真的只有一个人 如果你愿意的话 那就是
Really one singleton, if you will, which is

2391
01:58:51,875 --> 01:58:54,458
在许多编程环境中 这是一种艺术术语 
a term of art in a lot of contexts of programming.

2392
01:58:54,458 --> 01:58:58,125
所以让我建议我们实际上改进分拣帽的设计
So let me propose that we actually improve the design of the sorting hat

2393
01:58:58,125 --> 01:59:03,083
这样我们就不必实例化分类帽了 因为现在
so that we don't have to instantiate a sorting hat because right now this

2394
01:59:03,083 --> 01:59:08,791
允许我做一些像帽子1=帽子 帽子2=帽子 帽子3= 
is kind of allowing me to do something like hat 1 = hat, hat 2 = hat, hat 3 =,

2395
01:59:08,791 --> 01:59:09,458
以此类推 
and so forth.

2396
01:59:09,458 --> 01:59:11,291
我并不真的需要这种能力 
I don't really need that capability.

2397
01:59:11,291 --> 01:59:15,250
我真的只需要用一个类来表示分拣帽 
I really just need to represent the sorting hat with a class,

2398
01:59:15,250 --> 01:59:17,125
但我真的不需要实例化它 
but I don't really need to instantiate it.

2399
01:59:17,125 --> 01:59:17,625
为什么？
Why?

2400
01:59:17,625 --> 01:59:18,708
因为它已经存在了 
Because it already exists.

2401
01:59:18,708 --> 01:59:19,625
我只需要一个 
I need just one.

2402
01:59:19,625 --> 01:59:23,041
所以事实证明 在Python中 到目前为止 
So it turns out, in Python, that, up until now,

2403
01:59:23,041 --> 01:59:25,833
我们一直在使用 就像我一直叫它们的 实例方法--
we've been using, as I keep calling them, instance methods--

2404
01:59:25,833 --> 01:59:30,416
在自动传递引用的类中编写函数
writing functions inside of classes that are automatically passed a reference

2405
01:59:30,416 --> 01:59:32,375
设置为自身 即当前对象 
to self, the current object.

2406
01:59:32,375 --> 01:59:34,375
但有时你就是不需要这样 
But sometimes you just don't need that.

2407
01:59:34,375 --> 01:59:37,083
有时候 仅仅知道这个类是什么就足够了
Sometimes it suffices to just know what the class is

2408
01:59:37,083 --> 01:59:40,875
并假设甚至可能没有该类的任何对象 
and assume that there might not even be any objects of that class.

2409
01:59:40,875 --> 01:59:45,666
因此 从这个意义上说 您可以将类真正用作数据的容器
So in this sense, you can use a class really as a container for data

2410
01:59:45,666 --> 01:59:50,291
和/或在概念上有某种关联的功能--
and/or functionality that is just somehow conceptually related--

2411
01:59:50,291 --> 01:59:52,791
和分院帽有关的东西 
things related to a sorting hat.

2412
01:59:52,791 --> 01:59:56,083
还有另一个称为@类方法的装饰符或函数
And there's this other decorator or function called @classmethod

2413
01:59:56,083 --> 01:59:57,750
使我们能够做到这一点 
that allows us to do just this.

2414
01:59:57,750 --> 01:59:59,375
现在让我回到我的代码 
So let me go back to my code here.

2415
01:59:59,375 --> 02:00:05,041
让我提议 如果我不打算实例化多个房屋 
And let me propose that, if I'm not going to instantiate multiple houses,

2416
02:00:05,041 --> 02:00:07,916
我真的不需要这个init方法 因为它真的
I don't really need this init method because that's really

2417
02:00:07,916 --> 02:00:12,250
旨在从该蓝图、该模板、
meant to initialize specific objects from that blueprint, that template,

2418
02:00:12,250 --> 02:00:13,083
那个霉菌 
that mold.

2419
02:00:13,083 --> 02:00:14,708
所以让我把这个处理掉 
So let me get rid of this.

2420
02:00:14,708 --> 02:00:17,791
但如果我摆脱了这一切 我就再也无法接触到自我了 
But if I get rid of this, I no longer have access to self.

2421
02:00:17,791 --> 02:00:22,750
但这没问题 因为事实证明 除了他们现有的班级
But that's OK because it turns out, in addition to their existing class

2422
02:00:22,750 --> 02:00:26,416
方法 还有我们所说的类变量 
methods, there are also what we might call class variables.

2423
02:00:26,416 --> 02:00:30,791
并且类变量存在于类本身中 
And class variables exist within the class itself.

2424
02:00:30,791 --> 02:00:33,833
而这个变量只有一个副本
And there's just one copy of that variable

2425
02:00:33,833 --> 02:00:35,958
对于它的所有目的 
for all of the objects thereof.

2426
02:00:35,958 --> 02:00:40,291
如果您愿意的话 它们都共享同一个变量--可以是int还是str
They all share, if you will, the same variable-- be it an int or str

2427
02:00:40,291 --> 02:00:41,750
或者 在这种情况下 是一份名单 
or, in this case, a list.

2428
02:00:41,750 --> 02:00:49,041
所以我在这里所做的就是在我的HAT类中 在一个类变量中定义
So what I've done here is define, inside of my hat class, in a class variable

2429
02:00:49,041 --> 02:00:50,208
所谓的房子--
called houses--

2430
02:00:50,208 --> 02:00:53,083
我不说自我 是因为自我不再相关 
I don't say self because self is no longer relevant.

2431
02:00:53,083 --> 02:00:54,791
自我是指特定的对象 
Self refers to specific objects.

2432
02:00:54,791 --> 02:00:58,166
我希望这个类中有一个变量 也就是 
I want a variable inside of this class, a.k.a.

2433
02:00:58,166 --> 02:01:00,791
与该列表相等的类变量 
A class variable that equals that list.

2434
02:01:00,791 --> 02:01:03,708
因为它在这顶帽子里 现在 同学们 
Because it's inside of this hat, now, class,

2435
02:01:03,708 --> 02:01:07,208
我可以在我的任何函数中使用该列表 
I can use that list in any of my functions.

2436
02:01:07,208 --> 02:01:08,958
我现在只有一个 叫Sort 
I've only got one now, called sort.

2437
02:01:08,958 --> 02:01:11,791
但如果我有更多 所有这些方法都可以访问它
But if I had more, it would be accessible to all of those methods

2438
02:01:11,791 --> 02:01:12,666
也是 
as well.

2439
02:01:12,666 --> 02:01:15,791
而对于排序 这也没有真正意义上的意义
And with sort, it also doesn't really make sense

2440
02:01:15,791 --> 02:01:19,250
在特定的分类帽子中进行排序 因为我再次
to sort within a specific sorting hat because, again, I

2441
02:01:19,250 --> 02:01:20,500
我只想有一个 
only want there to be one.

2442
02:01:20,500 --> 02:01:25,875
所以我实际上可以通过说@类方法来指定这是类方法 
So I can actually specify that this is class method by saying @classmethod.

2443
02:01:25,875 --> 02:01:28,083
我再也不会通过赛尔夫了 
And I don't pass in self anymore.

2444
02:01:28,083 --> 02:01:33,250
实际上 按照惯例 我传入了对类本身的引用 
I actually, by convention, pass in a reference to the class itself.

2445
02:01:33,250 --> 02:01:35,250
它通常被写成CLS 
It's typically written as cls.

2446
02:01:35,250 --> 02:01:35,791
为什么？
Why?

2447
02:01:35,791 --> 02:01:40,916
那么 如果你写的是C-L-A-S-S 那实际上就和这个关键词有冲突
Well, if you wrote C-L-A-S-S, that would actually conflict with the keyword

2448
02:01:40,916 --> 02:01:42,791
我们在这里一直用的“类”这个词 
"class" that we keep using up here.

2449
02:01:42,791 --> 02:01:47,125
所以世界意识到 哦 我们不能在这里重复使用同样的短语 
So the world realized that, oops, we can't reuse that same phrase here.

2450
02:01:47,125 --> 02:01:48,833
所以我们就把这门课叫作 
So let's just call this class.

2451
02:01:48,833 --> 02:01:51,541
这在某些情况下很有用 包括这一点 
This is useful in some contexts including this one.

2452
02:01:51,541 --> 02:01:52,041
为什么？
Why?

2453
02:01:52,041 --> 02:01:54,125
好了 注意我现在能做什么 
Well, notice what I can now do.

2454
02:01:54,125 --> 02:01:56,916
我现在可以把自己变成一个普通的人了 
I can now change self to be just class.

2455
02:01:56,916 --> 02:01:57,541
为什么？
Why?

2456
02:01:57,541 --> 02:02:02,708
因为house现在--不是一个实例变量 可以通过self.house访问 
Because houses now-- not an instance variable, accessible via self.houses.

2457
02:02:02,708 --> 02:02:07,041
它现在是一个类变量 可以通过类.house访问 
It is now a class variable, accessible via class.houses,

2458
02:02:07,041 --> 02:02:10,375
或者从技术上讲 在这起案件中是Cls.House 
or technically cls.houses in this case.

2459
02:02:10,375 --> 02:02:12,666
但现在 最后的繁荣是这样的 
But now the final flourish is this.

2460
02:02:12,666 --> 02:02:19,208
现在 我不必像以前在这里第13行那样实例化任何HAT对象 
Now, I don't have to instantiate any hat objects as I used to on here, line 13.

2461
02:02:19,208 --> 02:02:22,833
我可以只使用这个类附带的功能 
I can just use functionality that comes with this class.

2462
02:02:22,833 --> 02:02:24,791
所以我要把这一行全部删除 
So I'm going to delete that line altogether.

2463
02:02:24,791 --> 02:02:32,416
我将在这条新的13行上大写帽子 然后只说Hat 排序 
I'm going to capitalize the hat on this new line 13 and just say hat.sort,

2464
02:02:32,416 --> 02:02:33,333
(“哈利”) 
("Harry").

2465
02:02:33,333 --> 02:02:34,750
那么我做了什么呢？
So what have I done?

2466
02:02:34,750 --> 02:02:38,541
我没有费心实例化一个类型为Hat的对象 
I've not bothered instantiating an object of type, hat.

2467
02:02:38,541 --> 02:02:42,791
我只是在访问HAT类内部的一个类方法
I am just accessing a class method inside of the hat class

2468
02:02:42,791 --> 02:02:43,666
那--你知道吗？
that-- you know what?

2469
02:02:43,666 --> 02:02:45,208
都会奏效的 
Is just going to work.

2470
02:02:45,208 --> 02:02:46,708
这就是类方法的工作方式 
This is how class methods work.

2471
02:02:46,708 --> 02:02:51,041
您使用类名、大写字母和全部、点方法名、
You use the name of the class, capital letter and all, dot method name,

2472
02:02:51,041 --> 02:02:53,041
传递您想要的任何参数 
passing in any arguments you want.

2473
02:02:53,041 --> 02:02:57,000
Python将自动传入某个变量 通过该变量
Python is going to automatically pass in some variable via which

2474
02:02:57,000 --> 02:03:00,625
您可以在该函数中引用该类
you can refer to that class in that function

2475
02:03:00,625 --> 02:03:02,458
您在该类中实现的
that you've implemented inside of that class

2476
02:03:02,458 --> 02:03:04,125
这样我才能做这样的事 
so that I can do something like this.

2477
02:03:04,125 --> 02:03:07,833
这并不是说我希望在这个函数中有一个名为house的本地变量 
It's not that I want a variable called houses locally in this function,

2478
02:03:07,833 --> 02:03:12,541
我想要与当前类关联的名为house的变量
I want the variable called houses that's associated with this current class

2479
02:03:12,541 --> 02:03:17,166
因此 我仍然可以访问我在第6行定义的相同列表 
so I can still access this same list that I defined on line 6.

2480
02:03:17,166 --> 02:03:21,500
现在 如果我返回到我的终端并运行Hot.py的Python 
And now, if I go back down here to my terminal and run Python of hat.py,

2481
02:03:21,500 --> 02:03:24,875
进来吧 哈里还在赫奇帕奇 
Enter, Harry is still in Hufflepuff once more.

2482
02:03:24,875 --> 02:03:27,041
哈利又一次加入了赫奇帕奇乐队 
Harry is still in Hufflepuff once more.

2483
02:03:27,041 --> 02:03:31,250
哈利回到了格兰芬多 至少是随机的 
Harry is back in Gryffindor, at least randomly.

2484
02:03:31,250 --> 02:03:36,333
现在 关于这些类变量或类方法的问题 
Questions, now, on these class variables or these class methods,

2485
02:03:36,333 --> 02:03:41,416
它们与实例变量和实例方法形成对比 
which are in contrast with instance variables and instance methods.

2486
02:03:41,416 --> 02:03:43,875
至少有一件事 那是有点奇怪的
And the one thing, at least, that's a little strange

2487
02:03:43,875 --> 02:03:47,666
这就是 尽管有一个叫做“类方法”的装饰者 
here is that, even though there's a decorator called @classmethod,

2488
02:03:47,666 --> 02:03:51,291
没有一种方法叫@instancemthod 
there is not one called @instancemethod.

2489
02:03:51,291 --> 02:03:55,666
在以下情况下 一个方法就自动成为所谓的“即时方法”
A method is just automatically a so-called "instant method" when

2490
02:03:55,666 --> 02:03:57,541
你不需要任何装饰者来定义它 
you define it without any decorator.

2491
02:03:57,541 --> 02:04:00,291
观众：你能在另一个班级里有一个班级吗？
AUDIENCE: Can you have a class inside another class?

2492
02:04:00,291 --> 02:04:01,291
大卫·J·马兰：你可以的 
DAVID J. MALAN: You can.

2493
02:04:01,291 --> 02:04:03,666
您可以在另一个类中定义一个类 
You can define one class inside of another.

2494
02:04:03,666 --> 02:04:06,041
一般来说 这并没有完成 但在那里
Generally speaking, this isn't done, but there

2495
02:04:06,041 --> 02:04:08,416
在某些情况下 它可能会有所帮助 尤其是
are cases where it can be helpful, especially

2496
02:04:08,416 --> 02:04:10,625
用于更大、更复杂的程序 
for larger, more sophisticated programs.

2497
02:04:10,625 --> 02:04:13,541
所以 是的 这是可能的 
So yes, it is possible.

2498
02:04:13,541 --> 02:04:14,750
其他问题 
Other questions.

2499
02:04:14,750 --> 02:04:17,958
观众：问题是关于房子本身的 
AUDIENCE: The question was about the self.houses.

2500
02:04:17,958 --> 02:04:25,083
当我们删除它并传递数据时 变量本身就会被创建 
When we remove it and we pass data, variable is created itself,

2501
02:04:25,083 --> 02:04:27,458
S 我们为什么要去除自我？
s why we remove the self?

2502
02:04:27,458 --> 02:04:29,625
大卫·J·马兰：在前面的例子中--
DAVID J. MALAN: So in the previous examples--

2503
02:04:29,625 --> 02:04:32,625
无论是帽子演示还是所有学生
both of the hat demonstration and also all of the student

2504
02:04:32,625 --> 02:04:36,708
演示--我们创造了一个学生
demonstrations-- we were creating a student

2505
02:04:36,708 --> 02:04:40,625
对象 大写S 左括号 右括号 
object by calling Student, capital S, open parenthesis, close parenthesis,

2506
02:04:40,625 --> 02:04:43,125
最后 带着名字和一栋房子进来了 
with, eventually, name and a house passed in.

2507
02:04:43,125 --> 02:04:46,833
然后我们使用了双下划线初始化方法
And then we were using the double underscore init method

2508
02:04:46,833 --> 02:04:52,708
初始化self.name和self.house实例变量
to initialize the self.name and the self.house instance variables

2509
02:04:52,708 --> 02:04:55,333
与这些相应的值对应 
therein to those respective values.

2510
02:04:55,333 --> 02:04:57,750
在这个最新版本的分院帽中 
In this latest version of the sorting hat,

2511
02:04:57,750 --> 02:05:02,166
我在任何地方都没有为自己操心 只是因为 从概念上讲 我
I haven't bothered with self anywhere, only because, conceptually, I

2512
02:05:02,166 --> 02:05:05,708
不需要也不希望世界上有多顶帽子 
don't need or want there to be multiple hats in the world.

2513
02:05:05,708 --> 02:05:11,041
我只是将这个类作为一个容器来打包这个房屋列表 
I'm just using the class as a container to bundle up this list of houses,

2514
02:05:11,041 --> 02:05:12,500
这种排序功能 
this sorting functionality.

2515
02:05:12,500 --> 02:05:14,875
也许最终都会给它增加更多的功能 
Maybe eventually all add more functionality to it.

2516
02:05:14,875 --> 02:05:15,875
但仅此而已 
But that's it.

2517
02:05:15,875 --> 02:05:18,833
因此 有时您可以使用面向对象的编程
And so sometimes you can use object-oriented programming

2518
02:05:18,833 --> 02:05:22,458
以这种稍微不同的方式 当您想要有功能时
in this somewhat different way when you want there to be functionality

2519
02:05:22,458 --> 02:05:25,333
但它并不特定于任何一顶特定的帽子 
but it's not specific to any one specific hat.

2520
02:05:25,333 --> 02:05:29,416
它是专门针对分拣帽本身的 
It's specific to the sorting hat itself.

2521
02:05:29,416 --> 02:05:33,958
现在再来看另一个问题 关于这些类变量或方法--只是
How about one other question now, on these class variables or methods-- just

2522
02:05:33,958 --> 02:05:37,000
使用面向对象编程的另一种方法 但要解决
another way of using object-oriented programming but to solve

2523
02:05:37,000 --> 02:05:38,541
一个有点不同的问题？
a somewhat different problem?

2524
02:05:38,541 --> 02:05:40,916
观众：嗯 这两门课有什么不同
AUDIENCE: Well, what's the difference between the class

2525
02:05:40,916 --> 02:05:44,833
帽子和帽子的作用？
hat and a function of hat?

2526
02:05:44,833 --> 02:05:46,166
大卫·J·马兰：问得好 
DAVID J. MALAN: A good question.

2527
02:05:46,166 --> 02:05:48,500
那么 我们为什么要使用一个类 而不仅仅是
So why are we using a class at all and not just

2528
02:05:48,500 --> 02:05:51,916
有一个名为hat.py的文件 其中包含一个名为
having a file called hat.py with a variable called

2529
02:05:51,916 --> 02:05:54,500
房屋和一个名为Sort的函数？
houses and a function called sort?

2530
02:05:54,500 --> 02:05:56,166
为什么我们要增加这种复杂性？
Why are we adding this complexity?

2531
02:05:56,166 --> 02:05:58,958
在这种特殊情况下 我们不一定需要这样做 
In this particular case, we don't necessarily need to.

2532
02:05:58,958 --> 02:06:01,166
我完全可以走进这里 
I could absolutely go in here.

2533
02:06:01,166 --> 02:06:02,833
我可以把这门课赶走 
I could get rid of the class.

2534
02:06:02,833 --> 02:06:05,625
我可以解开这个凹痕 
I could undo this indentation.

2535
02:06:05,625 --> 02:06:07,666
我可以除掉这个装饰师 
I could get rid of this decorator.

2536
02:06:07,666 --> 02:06:09,541
这样我就可以摆脱帽点了 
And I could get rid of hat dot.

2537
02:06:09,541 --> 02:06:12,291
我可以这样做 另外
And I could just do this and additionally

2538
02:06:12,291 --> 02:06:14,208
让我们说 让我们摆脱这里的类 
let's say, let's get rid of class here.

2539
02:06:14,208 --> 02:06:15,833
让我们把这里的课去掉吧 
Let's get rid of class here.

2540
02:06:15,833 --> 02:06:19,833
现在运行hat.py的Python 回车 它仍然可以工作 
And now run Python of hat.py, Enter, and it still works.

2541
02:06:19,833 --> 02:06:22,125
把哈利放错了房间 但这就是我们所拥有的--
Put Harry in the wrong house, but that's what we have--

2542
02:06:22,125 --> 02:06:23,208
随机发生的事情 
what happens randomly.

2543
02:06:23,208 --> 02:06:24,500
这也很好 
That's fine, too.

2544
02:06:24,500 --> 02:06:27,750
我们今天要介绍的是 通过面向对象编程 
What we're introducing today, by way of object-oriented programming,

2545
02:06:27,750 --> 02:06:30,208
是一种不同的建模世界的方式 
is just a different way of modeling the world.

2546
02:06:30,208 --> 02:06:32,916
像这样的例子并不能令人信服 
It's not really compelling with an example like this,

2547
02:06:32,916 --> 02:06:35,125
坦率地说 这是相对简单的 
frankly, that's relatively simple.

2548
02:06:35,125 --> 02:06:36,125
这并不是很复杂 
It's not very complex.

2549
02:06:36,125 --> 02:06:37,416
没有太多的功能 
There's not much functionality.

2550
02:06:37,416 --> 02:06:40,875
老实说 我们刚刚输入的版本--这10行--这很好 
Honestly, the version that we just typed up-- these 10 lines-- this is fine.

2551
02:06:40,875 --> 02:06:42,208
这就解决了这个问题 
This solves this problem.

2552
02:06:42,208 --> 02:06:45,708
但随着我们的代码变得更长 随着我们开始与其他人合作 
But as our code gets longer, as we start collaborating with other people,

2553
02:06:45,708 --> 02:06:48,666
随着我们试图用代码解决的问题变得越来越复杂 
as the problems we're trying to solve with code get more sophisticated,

2554
02:06:48,666 --> 02:06:52,125
您会发现您的代码很快就会变得杂乱无章 
you're going to find that your code gets messy quickly.

2555
02:06:52,125 --> 02:06:55,458
你会发现你有大量的功能 例如 
And you're going to find that you have a huge number of functions, for instance,

2556
02:06:55,458 --> 02:06:56,500
在一个文件中 
in one file.

2557
02:06:56,500 --> 02:06:59,958
它们中的一些是相互关联的 而另一些是不相关的 
And some of them are related to each other, but some of them are not.

2558
02:06:59,958 --> 02:07:02,625
嗯 在这一点上 组织他们不是很好吗？
Well, at that point, wouldn't it be nice to just organize them

2559
02:07:02,625 --> 02:07:03,500
有点不同吗？
a little differently?

2560
02:07:03,500 --> 02:07:06,500
在哈利波特的世界里 让我们为学生开设一个班级；
And in the world of Harry Potter, let's have a class for student;

2561
02:07:06,500 --> 02:07:09,916
让我们为教授上课；让我们为分院帽上课；
let's have a class for Professor; let's have a class for the sorting hat;

2562
02:07:09,916 --> 02:07:11,708
我们来上一堂其他的课吧 
let's have a class for something else.

2563
02:07:11,708 --> 02:07:14,625
因此 一旦你的世界变得比一些
And so once your world gets much more complicated than some

2564
02:07:14,625 --> 02:07:17,791
当我们想要集中注意力时 我们在课堂上做的演示
of the demonstrations we do here in class when we want to focus

2565
02:07:17,791 --> 02:07:21,500
就个人观点而言 面向对象编程只是一种方式
on individual ideas, object-oriented programming is just a way

2566
02:07:21,500 --> 02:07:24,083
封装相关数据--
of encapsulating related data--

2567
02:07:24,083 --> 02:07:27,291
也就是说 变量相关的功能--也就是方法--
that is, variables-- related functionality-- that is, methods--

2568
02:07:27,291 --> 02:07:29,583
在有名字的东西里面 
inside of things that have names.

2569
02:07:29,583 --> 02:07:31,625
这些东西被称为类 
These things are called classes.

2570
02:07:31,625 --> 02:07:33,750
所以这只是解决问题的另一种方式 
So it's just another way to solve problems.

2571
02:07:33,750 --> 02:07:36,125
几周前 当我们关注图书馆时 
And when we focused on libraries a couple of weeks back,

2572
02:07:36,125 --> 02:07:38,791
这也是同样问题的另一种解决方案 
that, too, was another solution to the same problem.

2573
02:07:38,791 --> 02:07:42,291
你可以定义你自己的模块或包 把你的一些数据
You could define your own modules or packages, put some of your data

2574
02:07:42,291 --> 02:07:44,708
和/或功能 这也是很好的 
and/or functionality in there, and that's fine, too.

2575
02:07:44,708 --> 02:07:48,000
有时你应该使用哪一个是重叠的 
And sometimes which one you should use overlaps.

2576
02:07:48,000 --> 02:07:51,333
如果你熟悉维恩图 重叠区域
If you're familiar with Venn diagrams, the overlapping region

2577
02:07:51,333 --> 02:07:54,791
可能意味着您可以使用类；您可以使用模块或包；
might mean that you could use a class; you could use a module or a package;

2578
02:07:54,791 --> 02:07:57,500
您可以只使用单个本地文件 
you could just use a single local file.

2579
02:07:57,500 --> 02:07:59,916
随着时间的推移 你会发展出一种本能 甚至
Over time, you'll develop an instinct and maybe even

2580
02:07:59,916 --> 02:08:04,291
个人对要使用的工具的偏好 
a personal preference for which tool to use.

2581
02:08:04,291 --> 02:08:08,416
好的 现在让我提议 我们应用类方法的相同概念
All right, let me propose, now, that we apply this same idea of a class method

2582
02:08:08,416 --> 02:08:10,583
来清理另一件事 
to clean up one other thing as well.

2583
02:08:10,583 --> 02:08:16,041
让我关闭Hot.py并重新打开之前离开的Student.py 
Let me close that hat.py and reopen student.py as we left it earlier,

2584
02:08:16,041 --> 02:08:19,500
让我继续下去 把它简化一点 
and let me go ahead and simplify it just a little bit.

2585
02:08:19,500 --> 02:08:22,750
我要继续下去 处理掉这些房产 
I'm going to go ahead and get rid of the properties,

2586
02:08:22,750 --> 02:08:24,666
不是因为他们有什么不对劲 
not because there's anything, wrong with them,

2587
02:08:24,666 --> 02:08:27,416
但仅仅因为我想让我们把注意力集中在一些关键的想法上
but just because I want us to focus on some of the key ideas

2588
02:08:27,416 --> 02:08:29,333
当我们开始这个节目的时候 
when we began with this program.

2589
02:08:29,333 --> 02:08:31,750
因此 我将继续并保持Main 
So I'm going to go ahead and keep main as well.

2590
02:08:31,750 --> 02:08:35,583
我不会反驳地试图更改亨利在那里的地址 
I'm not going to adversarially try to change Henry's address there.

2591
02:08:35,583 --> 02:08:38,666
不过 我打算继续 只打印学生 
I'm going to instead go ahead, though, and just print the student.

2592
02:08:38,666 --> 02:08:41,750
但这是我在这里想要重点关注的事情 
But this is the thing I want to focus on here.

2593
02:08:41,750 --> 02:08:46,541
在我们前面的学生示例中 这是一个错失的机会
This, in our previous student examples, was a missed opportunity

2594
02:08:46,541 --> 02:08:48,125
来清理我的代码 
to clean up my code.

2595
02:08:48,125 --> 02:08:49,708
我这么说是什么意思？
Well, what do I mean by that?

2596
02:08:49,708 --> 02:08:51,750
好的 在这个文件的顶部--甚至
Well, up here at the top of this file-- even

2597
02:08:51,750 --> 02:08:53,958
虽然我简化了它 但去掉了属性
though I've simplified it, but getting rid of the properties

2598
02:08:53,958 --> 02:08:55,708
以及所有的错误检查--因为我
and all of that error checking-- because I

2599
02:08:55,708 --> 02:08:58,708
现在我想把重点放在这门课的本质上--只讲学生的名字
want to focus on the essence of this class now-- just the student's name

2600
02:08:58,708 --> 02:09:00,875
以及房子和它的印刷品 
and the house and the printing thereof.

2601
02:09:00,875 --> 02:09:05,000
这是面向对象编程中类的本质 
This is, by nature of classes in object-oriented programming,

2602
02:09:05,000 --> 02:09:09,666
理论上讲 我所有针对学生的功能 
theoretically, all of my student-specific functionality.

2603
02:09:09,666 --> 02:09:14,083
也就是说 如果我有一个学生的功能和数据 你 
That is to say, if I have functionality and data related to a student, you,

2604
02:09:14,083 --> 02:09:16,583
程序员 我的同事 会认为
the programmer, my colleague, would assume

2605
02:09:16,583 --> 02:09:18,875
它们都被捆绑在一起 被封装起来 所以
that it's all bundled up, encapsulated, so

2606
02:09:18,875 --> 02:09:20,791
要说 在学生班里 
to speak, inside of the student class.

2607
02:09:20,791 --> 02:09:24,208
然而 如果你进一步向下滚动 这是什么？
And yet, if you scroll down further, what is this?

2608
02:09:24,208 --> 02:09:27,458
有一个名为Get_Student的函数 它只存在于其他地方
There's a function called get_student that just exists elsewhere

2609
02:09:27,458 --> 02:09:31,166
在该文件中 提示用户输入名称 提示用户输入房屋 
in this file that prompts the user for a name, prompts the user for a house,

2610
02:09:31,166 --> 02:09:34,083
创建学生对象 然后返回 
creates the student object, and then returns.

2611
02:09:34,083 --> 02:09:35,500
这没有错 
That's not wrong.

2612
02:09:35,500 --> 02:09:36,208
它起作用了 
It works.

2613
02:09:36,208 --> 02:09:39,041
我们看到了很多很多次 它一直在工作 
And we saw many, many times it kept working.

2614
02:09:39,041 --> 02:09:42,208
但这有点奇怪 因为如果这
But this is a little weird because, if this

2615
02:09:42,208 --> 02:09:45,208
是一个帮助你获得一个学生的函数 
is a function that helps you get a student,

2616
02:09:45,208 --> 02:09:48,916
帮你查到一个学生的名字和住处 为什么不
helps you get the name of a student and the house of a student, why isn't

2617
02:09:48,916 --> 02:09:51,125
类本身中的功能吗？
that functionality in the class itself?

2618
02:09:51,125 --> 02:09:54,291
毕竟 随着我的代码变得越来越复杂 做的事情越来越多 
After all, as my code gets more and more complicated and does more things,

2619
02:09:54,291 --> 02:09:56,125
我要看的是学生们的课
I'm going to be looking at the student class

2620
02:09:56,125 --> 02:09:57,750
用于所有与学生相关的功能 
for all student-related functionality.

2621
02:09:57,750 --> 02:10:00,625
我不会向下滚动 期待着 哦 也许有
I'm not going to be scrolling down, expecting that, oh, maybe there's

2622
02:10:00,625 --> 02:10:04,708
其他一些学生功能只是随机出现在这个文件的后面 
some other student functionality just randomly later in this file.

2623
02:10:04,708 --> 02:10:05,958
所以这不是错的 
So it's not wrong.

2624
02:10:05,958 --> 02:10:09,625
但这再次证明了可能是糟糕的设计--
But this is, again, evidence of maybe bad design--

2625
02:10:09,625 --> 02:10:11,541
对于这个小程序 就不是那么多了 
not so much with this small program.

2626
02:10:11,541 --> 02:10:14,458
但这又是一个代码气味的例子 
But this is an example, again, of code smell.

2627
02:10:14,458 --> 02:10:16,000
这里有股不对劲的味道 
Something smells a little off here.

2628
02:10:16,000 --> 02:10:17,791
这可能会给我们带来麻烦
This is probably going to get us in trouble

2629
02:10:17,791 --> 02:10:20,791
通过分离相关功能 
by separating related functionality.

2630
02:10:20,791 --> 02:10:24,541
因此 这再一次是设计原则 而不是正确性问题 
So again it's a design principle, not a correctness concern.

2631
02:10:24,541 --> 02:10:27,958
但是类方法也允许我们解决这个问题 
But class methods allow us to address this, too.

2632
02:10:27,958 --> 02:10:29,791
让我继续做这件事 
Let me go ahead and do this.

2633
02:10:29,791 --> 02:10:32,666
我要一起删除Get_Student 离开
I'm going to delete get_student all together, leaving

2634
02:10:32,666 --> 02:10:35,458
这里只有main作为我的另一个函数 
only main as my other function here.

2635
02:10:35,458 --> 02:10:38,541
在我的学生课堂上 我要这么做 
And inside of my student class, I'm going to do this.

2636
02:10:38,541 --> 02:10:42,375
我将定义一个函数 更简单地称为GET 
I'm going to define a function, even more simply called, get.

2637
02:10:42,375 --> 02:10:45,291
从类方法的工作方式来看 它是
And by nature of how class methods work, it's

2638
02:10:45,291 --> 02:10:47,625
将采用类本身的名称
going to take in the name of the class itself

2639
02:10:47,625 --> 02:10:49,833
或将其作为论据引用 
or a reference thereto as an argument.

2640
02:10:49,833 --> 02:10:53,083
我将把功能从Get_Student移到学生中
And I'm going to move the functionality from get_student into the student

2641
02:10:53,083 --> 02:10:53,583
班级 
class.

2642
02:10:53,583 --> 02:10:58,750
我将这样做--名字等于输入、引号、不引号、名字、房子
And I'm going to do this-- name equals input, quote, unquote, name, house

2643
02:10:58,750 --> 02:11:01,708
等于输入、引用、不引用、房子 
equals input, quote, unquote, house.

2644
02:11:01,708 --> 02:11:04,291
然后这个函数要做的是
And then what this function is going to do

2645
02:11:04,291 --> 02:11:11,333
是通过调用类返回一个新学生对象 同样 这也只是
is return a new student object by calling class, which, again, is just

2646
02:11:11,333 --> 02:11:14,250
自动传入的对类的引用
an automatically passed-in reference to the class

2647
02:11:14,250 --> 02:11:17,666
本身 传递名字和房子 
itself, passing in name and house.

2648
02:11:17,666 --> 02:11:22,916
我承认这个语法看起来有点奇怪 现在我调用CLS
And I will admit this syntax seems a little strange that now I'm calling cls

2649
02:11:22,916 --> 02:11:24,375
我把这些论点传递给大家 
and I'm passing in these arguments.

2650
02:11:24,375 --> 02:11:26,125
但让我在这里做最后一次修正 
But let me do one final fix here.

2651
02:11:26,125 --> 02:11:28,041
让我转到此函数的顶部 然后执行更多操作
Let me go to the top of this function and more

2652
02:11:28,041 --> 02:11:31,125
显式地说这是一个类方法 
explicitly say this is a class method.

2653
02:11:31,125 --> 02:11:34,541
这解决了一个潜在的鸡和蛋的问题 可以说 
This solves a potential chicken and the egg problem, so to speak,

2654
02:11:34,541 --> 02:11:37,291
因此 潜在地 一个需要先于另一个 
whereby one needs to come before the other, potentially.

2655
02:11:37,291 --> 02:11:39,250
那我在这里做什么？
So what am I doing here?

2656
02:11:39,250 --> 02:11:43,916
在我的学生类中 我现在有一个名为Get的函数 
Inside of my student class, I now have a function called get.

2657
02:11:43,916 --> 02:11:47,333
我要说 它是一个类方法 这意味着什么 
It is, I shall claim, a class method what does that mean.

2658
02:11:47,333 --> 02:11:53,000
它只是意味着我可以调用此方法 而无需实例化学生
It just means I can call this method without instantiating a student

2659
02:11:53,000 --> 02:11:54,125
对象优先 
object first.

2660
02:11:54,125 --> 02:11:57,333
这就是潜在的鸡和蛋的问题 
Therein lies the potential chicken and the egg problem.

2661
02:11:57,333 --> 02:12:00,375
如果不熟悉 这是一种表达 意思是 很好 并做了世界
And if unfamiliar, that's an expression, meaning, well, and did the world

2662
02:12:00,375 --> 02:12:03,291
先有下蛋的鸡 还是有蛋？
have chickens first that laid eggs, or was there an egg

2663
02:12:03,291 --> 02:12:06,958
然后生下了鸡 但鸡蛋是如何到达那里的呢？
that then yielded the chickens, but how did the egg get there?

2664
02:12:06,958 --> 02:12:08,791
这是一个奇怪的循环问题 
It's this weird, circular problem.

2665
02:12:08,791 --> 02:12:10,208
这就是我们现在面临的问题 
And that's what we're facing here.

2666
02:12:10,208 --> 02:12:16,375
如果您必须创建一个学生对象才能调用Get 
It would be weird if you had to create a student object in order to call get,

2667
02:12:16,375 --> 02:12:19,791
为了得到另一个学生对象 
in order to get another student object.

2668
02:12:19,791 --> 02:12:20,875
这听起来很乱 
That sounds messy.

2669
02:12:20,875 --> 02:12:24,833
让我们通过类方法来获取一个学生
Let's just get a student via a class method

2670
02:12:24,833 --> 02:12:29,125
根据定义 这不需要您首先创建一个学生对象 
that, by definition, does not require you to create a student object first.

2671
02:12:29,125 --> 02:12:33,166
就像帽子一样 在它的最终形式中 我们使用Hat类
Just like the hat, in its final form, we use the hat class

2672
02:12:33,166 --> 02:12:35,833
就说Hat 大写H 点排序 
to just say Hat, capital H, dot sort.

2673
02:12:35,833 --> 02:12:37,458
我们不需要先制作一顶帽子 
We didn't need to create a hat first.

2674
02:12:37,458 --> 02:12:39,708
我们只是使用了类本身 
We just used the class itself.

2675
02:12:39,708 --> 02:12:41,791
那么我现在要在这里做什么？
So what am I going to do here now?

2676
02:12:41,791 --> 02:12:43,041
让我下到主楼去 
Let me go down to main.

2677
02:12:43,041 --> 02:12:46,791
注意我现在可以做什么 而不是说Get_Student 
And instead of saying get_student, notice what I can now do.

2678
02:12:46,791 --> 02:12:51,625
Student.get 其他一切都可以保持不变 
Student.get, and everything else can stay the same.

2679
02:12:51,625 --> 02:12:55,416
我现在所做的就是把我所有的逻辑
All I've done now is I've migrated all of my logic

2680
02:12:55,416 --> 02:12:58,541
来自Get_Student 它是这个自己的独立函数 
from get_student, which was this own standalone function,

2681
02:12:58,541 --> 02:13:01,291
但显然与学生有名字上的联系 
but clearly related to students by name.

2682
02:13:01,291 --> 02:13:05,458
我真的将相同的代码移到了内部
I've moved the same code, really, to inside

2683
02:13:05,458 --> 02:13:09,458
在名为Get的更简单的命名函数中 
of the student class in a more simply named function called get.

2684
02:13:09,458 --> 02:13:11,541
但如果我愿意的话 我还是可以叫它Get_Student 
But I could still call it get_student if I want.

2685
02:13:11,541 --> 02:13:14,791
在学生班上称它为Get_Student似乎有些多余 
It just seems a little redundant to call it get_student in a student class,

2686
02:13:14,791 --> 02:13:16,291
所以我在简化 
so I'm simplifying.

2687
02:13:16,291 --> 02:13:20,208
我有一个名为Get的方法 但我将其称为类方法
So I have a method called get, but I'm calling it a class method

2688
02:13:20,208 --> 02:13:22,333
以避免鸡肉和鸡蛋的问题 
to avoid that chicken and the egg problem.

2689
02:13:22,333 --> 02:13:27,958
我希望能够在我的世界中没有学生对象的情况下调用GET
I want to be able to call a get without having a student object in my universe

2690
02:13:27,958 --> 02:13:28,791
已经有了 
already.

2691
02:13:28,791 --> 02:13:32,041
它的语法是@类方法 
And the syntax for that is @classmethod.

2692
02:13:32,041 --> 02:13:35,333
约定是给该方法至少一个参数 
The convention is to give this method at least one argument,

2693
02:13:35,333 --> 02:13:38,291
根据称为类的CLS的约定 它正在进行
by convention called cls for class, which is just going

2694
02:13:38,291 --> 02:13:40,125
作为对类本身的引用 
to be a reference to the class itself.

2695
02:13:40,125 --> 02:13:43,500
11号线和12号线和它们以前的样子是一样的 
Lines 11 and 12 are identical to what they've always been.

2696
02:13:43,500 --> 02:13:46,666
和Get_Student--这里唯一的新语法是 
And get_student-- the only new syntax here is this,

2697
02:13:46,666 --> 02:13:50,500
但这也是面向对象编程的特性之一 
but this, again, is one of the features of object-oriented programming.

2698
02:13:50,500 --> 02:13:57,791
现在 只需使用传入的CLS即可实例化学生对象 
You can now instantiate a student object by just using cls that's passed in.

2699
02:13:57,791 --> 02:14:00,583
从技术上讲 我可以利用学生 资本S 
I technically could use Student, capital S,

2700
02:14:00,583 --> 02:14:03,333
但事实证明 我在做更传统的事情 因为
but it turns out I'm doing what's more conventional because this

2701
02:14:03,333 --> 02:14:07,458
将通过更复杂的代码来解决和避免问题 
will both solve and avoid problems down the line with more complicated code.

2702
02:14:07,458 --> 02:14:11,916
这一行 在第13行 只是表示创建当前类的对象 
This line here, on line 13, just means create an object of the current class.

2703
02:14:11,916 --> 02:14:12,708
那是什么班？
What class is that?

2704
02:14:12,708 --> 02:14:13,791
好吧 不管CLS是什么 
Well, whatever cls is.

2705
02:14:13,791 --> 02:14:17,458
嗯 根据它的运作方式的定义 那将是学生 
Well, that, by definition of how it all works, is going to be student.

2706
02:14:17,458 --> 02:14:22,250
我希望你像往常一样 用名字和房子来初始化它 
And I want you to initialize it, as always, with name and house.

2707
02:14:22,250 --> 02:14:25,666
现在 向下滚动 我的代码是这样的 
So now, scrolling down, my code is this.

2708
02:14:25,666 --> 02:14:27,875
这本书读起来很不错 
And this is just nice to read.

2709
02:14:27,875 --> 02:14:31,791
你可能得先尝一尝--我这句话听起来有点奇怪 
You perhaps have to acquire a taste for this-- and I sound a little odd saying,

2710
02:14:31,791 --> 02:14:32,750
这本书读起来很不错 
this is nice to read.

2711
02:14:32,750 --> 02:14:36,125
但事实上 学生 GET只是告诉我发生了什么 
But indeed, student.get just tells me what's going on.

2712
02:14:36,125 --> 02:14:37,375
我要去找一个学生 
I'm going to get a student.

2713
02:14:37,375 --> 02:14:40,958
我不需要在文件中使用由我编写的名为Get_Student的单独函数
I don't need a separate function written by me called get_student in the file

2714
02:14:40,958 --> 02:14:41,750
它本身 
itself.

2715
02:14:41,750 --> 02:14:44,875
Get功能内置于类中 
The get functionality is built into the class.

2716
02:14:44,875 --> 02:14:47,416
我所有与学生相关的代码现在都在一起了 
All my student-related code now is together.

2717
02:14:47,416 --> 02:14:51,041
因此 让我转到我的终端窗口 运行Student.py的Python 回车 
So let me go down to my terminal window and run Python of student.py, Enter.

2718
02:14:51,041 --> 02:14:52,083
让我们输入哈里 
Let's type in Harry.

2719
02:14:52,083 --> 02:14:53,416
让我们输入格兰芬多 
Let's type in Gryffindor.

2720
02:14:53,416 --> 02:14:54,958
我们又回到了开始的地方 
And we're back to where we began.

2721
02:14:54,958 --> 02:15:00,541
但是 但是 但是所有与学生有关的东西 现在都在这个班级里 
But, but, but everything related to students, now, is in this here class.

2722
02:15:00,541 --> 02:15:04,500
文件中唯一的其他内容是main 这是一个有条件的内容
The only other thing in the file is main and this conditional

2723
02:15:04,500 --> 02:15:08,458
 我们经常使用它来避免在制作
that we always use to avoid accidentally executing main when we're making

2724
02:15:08,458 --> 02:15:10,833
模块或包或类似物 
a module or a package or the like.

2725
02:15:10,833 --> 02:15:13,541
所以 同样 一个问题的解决方案--
So again, a solution to a problem--

2726
02:15:13,541 --> 02:15:16,875
对于相对较小的程序来说 不是很大的一个 而是一个
not a big one in the case of a relatively small program, but one

2727
02:15:16,875 --> 02:15:19,041
你最终会在你的程序中遇到
that you will eventually encounter as your programs

2728
02:15:19,041 --> 02:15:24,083
变得越来越长 需要代表的实体越来越多 
get longer and longer, with more and more entities to represent.

2729
02:15:24,083 --> 02:15:29,000
现在关于类方法的使用的问题 
Questions now on this use of a class method.

2730
02:15:29,000 --> 02:15:32,291
迈克尔：类必须在主函数之前定义吗 
MICHAEL: Does the class have to be defined before the main function,

2731
02:15:32,291 --> 02:15:34,458
就节目的顺序而言？
in terms of the order of the program?

2732
02:15:34,458 --> 02:15:36,083
大卫·J·马兰：这是一个非常好的问题 
DAVID J. MALAN: A really good question.

2733
02:15:36,083 --> 02:15:37,291
所以 如果有疑问 让我们试试这个 
So when in doubt, let's try this.

2734
02:15:37,291 --> 02:15:38,666
所以让我们试着改变一下顺序 
So let's try to change the order.

2735
02:15:38,666 --> 02:15:41,208
让我们把主线移到顶端 这是我经常鼓励的 
Let's move main to the top, which I've often encouraged.

2736
02:15:41,208 --> 02:15:44,208
因此 让我们继续 在全班之上 做这件事 
So let's go ahead and, above the class, do this.

2737
02:15:44,208 --> 02:15:47,000
请注意 从技术上讲 第二行
And notice now that, technically, line two

2738
02:15:47,000 --> 02:15:51,458
提到了学生 直到第6行及以下才存在 
is mentioning student, which does not exist until line 6 and below.

2739
02:15:51,458 --> 02:15:54,666
让我继续清除我的终端并运行Student.py的Python 
Let me go ahead and clear my terminal and run Python of student.py.

2740
02:15:54,666 --> 02:15:55,875
到现在为止还好 
So far, so good.

2741
02:15:55,875 --> 02:15:58,750
哈利--格兰芬多 好的 
Harry-- Gryffindor, OK.

2742
02:15:58,750 --> 02:16:00,458
事实上 哈里来自格兰芬多 
Indeed, Harry's from Gryffindor.

2743
02:16:00,458 --> 02:16:03,541
原因 迈克尔 在这种情况下这无关紧要
The reason, Michael, it does not matter in this case

2744
02:16:03,541 --> 02:16:06,791
是因为我们实际上直到最后才调用Main 
is because we're not actually calling main until the very end.

2745
02:16:06,791 --> 02:16:10,375
就像过去一样 这意味着Python有机会读取所有内容 
And just as in the past, that means that Python has a chance to read everything,

2746
02:16:10,375 --> 02:16:11,625
从上到下 从左到右 
top to bottom, left to right.

2747
02:16:11,625 --> 02:16:13,083
所以一切都是存在的 
So everything exists.

2748
02:16:13,083 --> 02:16:17,458
我想说的是 类通常在文件的顶部定义 
I would say, generally classes are defined at the top of the file.

2749
02:16:17,458 --> 02:16:21,916
然而 移动类定义甚至可能更干净
However, it would be even maybe cleaner to move the Classes definition

2750
02:16:21,916 --> 02:16:25,083
到它自己的文件 然后将其导入 所以本质上
to its own file and then import it, so essentially

2751
02:16:25,083 --> 02:16:28,750
通过将代码放入您自己的模块或包来生成可重用的代码
to make reusable code by putting it into your own module or package

2752
02:16:28,750 --> 02:16:31,083
因此 不仅是这个项目 还有许多其他项目
so that not just this program but many others

2753
02:16:31,083 --> 02:16:33,541
也可以使用学生的定义 
can use that definition of student as well.

2754
02:16:33,541 --> 02:16:37,750
现在关于类、类方法或类似的其他问题 
Other questions now on classes, class methods, or the like.

2755
02:16:37,750 --> 02:16:44,833
听众：我想问 有没有办法宣布所有可能的--
AUDIENCE: I wanted to ask, is there a way to declare all the possible--

2756
02:16:44,833 --> 02:16:47,583
类的所有可能属性？
all the possible attributes of the class?

2757
02:16:47,583 --> 02:16:51,000
因为它看起来太不一致了 
Because it looks so inconsistent.

2758
02:16:51,000 --> 02:16:52,750
大卫·J·马兰：好吧 我要说的是
DAVID J. MALAN: Well, so my takeaway there

2759
02:16:52,750 --> 02:16:55,208
这就是Python对这些原则的处理方法 
is this is Python's approach to these principles.

2760
02:16:55,208 --> 02:16:57,791
不同的语言 如Java 只是采取了不同的方法
Different languages, like Java, just take a different approach

2761
02:16:57,791 --> 02:16:59,666
但都有非常相似的特征 
but have very similar features.

2762
02:16:59,666 --> 02:17:01,500
语法只是有变化的趋势 
The syntax just tends to vary.

2763
02:17:01,500 --> 02:17:05,208
这就是Python社区选择实现这一想法的方式 
And this is how the Python community chose to implement this idea.

2764
02:17:05,208 --> 02:17:08,750
归根结底 正确的心理模型是这些实例变量 
The right mental model, ultimately, is that these instance variables,

2765
02:17:08,750 --> 02:17:14,958
即时方法属于特定对象或对其进行操作--
instant methods belong to or operate on specific objects--

2766
02:17:14,958 --> 02:17:17,750
一个特定的学生 一个特定的帽子 
a specific student, a specific hat.

2767
02:17:17,750 --> 02:17:22,500
类变量和类方法对整个类进行操作
Class variables and class methods operate on the entire class

2768
02:17:22,500 --> 02:17:26,125
本身或该类的所有对象 这些对象
itself or, in turn, all objects of that class, which

2769
02:17:26,125 --> 02:17:30,000
我们还没有看到演示 但这是一个更高层次的概念 
we've not seen a demonstration of, but it's a higher level concept.

2770
02:17:30,000 --> 02:17:32,583
所以事实证明 除了这些类方法之外 
So it turns out, besides these class methods,

2771
02:17:32,583 --> 02:17:35,625
它们与那些实例方法不同 公平地说 
which are distinct from those instance methods, which, to be fair,

2772
02:17:35,625 --> 02:17:39,375
没有自己的修饰符--默认情况下 它们只是实例方法 
do not have their own decorator-- they just are, by default, instance method,

2773
02:17:39,375 --> 02:17:42,458
在Python中的类中还可以使用其他类型的方法 
there's yet other types of Methods You can have in classes in Python.

2774
02:17:42,458 --> 02:17:44,875
它们往往被称为静态方法 它们也是如此 
They tend to be called static methods, and they, too,

2775
02:17:44,875 --> 02:17:48,041
附带另一个称为@Static方法的装饰器 它
come with another decorator called @static method, which

2776
02:17:48,041 --> 02:17:49,666
是一个我们不会掉下去的兔子洞 
is a rabbit hole we won't go down.

2777
02:17:49,666 --> 02:17:52,125
但要意识到还有其他功能
But realize that there is yet other functionality

2778
02:17:52,125 --> 02:17:54,750
您可以在面向对象编程中利用它 
that you can leverage within object-oriented programming.

2779
02:17:54,750 --> 02:17:59,041
但我们认为我们应该真正专注于一些最终的核心功能
But what we thought we'd do is focus really on some final core features

2780
02:17:59,041 --> 02:18:02,166
这不仅在Python中可以看到 在其他语言中也是如此 
that you see not just in Python but other languages as well.

2781
02:18:02,166 --> 02:18:05,750
而且可能是面向对象编程最引人注目的特性之一
And perhaps one of the most compelling features of object-oriented programming

2782
02:18:05,750 --> 02:18:09,375
我们还没有明确使用--尽管事实证明我们已经看到
that we haven't yet used explicitly-- though it turns out we've seen

2783
02:18:09,375 --> 02:18:11,458
在过去的几周里--
implicitly over the past weeks--

2784
02:18:11,458 --> 02:18:13,625
就是这种继承的概念 
is this notion of inheritance.

2785
02:18:13,625 --> 02:18:16,250
事实证明 通过面向对象编程 
It turns out, via object-oriented programming,

2786
02:18:16,250 --> 02:18:19,666
实际上有一个机会来设计你的课程
there's actually an opportunity to design your classes

2787
02:18:19,666 --> 02:18:25,125
在分层方式中 可以从一个类继承
in a hierarchical fashion, whereby you can have one class inherit from

2788
02:18:25,125 --> 02:18:30,833
或借用属性--即 来自另一个类的方法或变量
or borrow attributes-- that is, methods or variables from another class

2789
02:18:30,833 --> 02:18:33,291
如果他们都有这些共同点的话 
if they all have those in common.

2790
02:18:33,291 --> 02:18:35,083
那么 我在这里所说的是什么意思？
So what do I mean by this here?

2791
02:18:35,083 --> 02:18:39,708
好吧 让我建议我们在这里的VS代码中实现
Well, let me propose that we implement, over in VS Code here,

2792
02:18:39,708 --> 02:18:42,250
一个名为wizard.py的全新文件 
a brand new file called wizard.py.

2793
02:18:42,250 --> 02:18:45,583
让我继续运行wizard.py的代码 
Let me go ahead and run code of wizard.py.

2794
02:18:45,583 --> 02:18:50,333
然后让我们像以前一样开始 定义一个名为Student的类 
And then let's start as before, defining a class called student.

2795
02:18:50,333 --> 02:18:54,416
让我们继续 首先定义下划线 init方法 
And let's go ahead and first define the underscore underscore, init method,

2796
02:18:54,416 --> 02:18:57,291
当然 在传统上 最低限度地要接受一个论点
which of course, is minimally going to take an argument traditionally

2797
02:18:57,291 --> 02:18:58,000
叫赛尔夫 
called self.

2798
02:18:58,000 --> 02:19:01,375
在这种情况下 让我们也让它像以前一样接受一个名字和一个房子 
And in this case, let's also have it take as before a name and a house.

2799
02:19:01,375 --> 02:19:03,875
然后在这个初始化方法中 让我们继续
And then in this init method, let's go ahead

2800
02:19:03,875 --> 02:19:08,208
并分配实例变量--self.name=name 
and assign the instance variables-- self.name = name,

2801
02:19:08,208 --> 02:19:11,208
和自己 房子=房子 
and self.house = house.

2802
02:19:11,208 --> 02:19:13,375
让我们假设有一些其他功能
Let's assume that there's some other functionality

2803
02:19:13,375 --> 02:19:15,083
在这节课上也是一样--点 点 点 
in this class as well-- dot, dot, dot.

2804
02:19:15,083 --> 02:19:18,416
但现在让我们来实施教授的概念
But let's move on now to implementing the notion of a professor

2805
02:19:18,416 --> 02:19:20,208
在魔法界也是如此 
in the wizarding world as well.

2806
02:19:20,208 --> 02:19:24,625
所以对于这节课 我们就叫它教授吧 
So for this class, let's call it Professor.

2807
02:19:24,625 --> 02:19:26,958
比如说 一位教授也要去
And a professor, let's say, is also going

2808
02:19:26,958 --> 02:19:29,416
要有自己的初始化方法 
to have its own initialization method.

2809
02:19:29,416 --> 02:19:30,708
所以__init 
So __ init.

2810
02:19:30,708 --> 02:19:32,000
这需要自我--
It's going to take self--

2811
02:19:32,000 --> 02:19:33,791
总是作为第一个论点 
always as the first argument.

2812
02:19:33,791 --> 02:19:35,500
教授也有名字 
A professor also has a name.

2813
02:19:35,500 --> 02:19:37,166
所以我们也会以第二名的成绩通过 
So we'll pass that in second, too.

2814
02:19:37,166 --> 02:19:39,958
尽管有些教授是房子的头儿 
And even though some professors are heads of houses,

2815
02:19:39,958 --> 02:19:42,041
让我们假设一位教授确实被确认为
let's assume that a professor is really identified

2816
02:19:42,041 --> 02:19:45,500
通过他们的名字和他们的学科领域--他们教的班级 
by their name and their subject area-- the class that they teach.

2817
02:19:45,500 --> 02:19:48,041
所以我们把这第三个论点称为主题 
So we'll call this third argument, subject.

2818
02:19:48,041 --> 02:19:51,791
现在 像以前一样 让我们继续将self.name=name 
Now, as before, let's go ahead and assign self.name = name,

2819
02:19:51,791 --> 02:19:56,083
让我们在这里指定self.Subject=SUBJECT 
and let's assign self.subject = subject here.

2820
02:19:56,083 --> 02:19:59,541
和前面一样 让我们假设有一些更多的相关功能
And as before, let's assume that there's some more functionality associated

2821
02:19:59,541 --> 02:20:01,083
教授们也是如此 
with professors as well.

2822
02:20:01,083 --> 02:20:05,625
那么 在我对学生的定义中 你注意到了什么吗？
Well, what do you notice already here in my definitions of students

2823
02:20:05,625 --> 02:20:07,333
教授们呢？
and professors?

2824
02:20:07,333 --> 02:20:11,750
通常 我们不太愿意在代码中考虑任何冗余 
Typically, we're a bit reluctant to allow for any redundancy in our code.

2825
02:20:11,750 --> 02:20:16,041
在这里 我感觉我的初始化方法是为学生取了一个名字；
And here, I feel like my init method is taking a name for students;

2826
02:20:16,041 --> 02:20:18,625
我的初始化方法也是取一个教授的名字；
my init method is also taking a name for a professor;

2827
02:20:18,625 --> 02:20:22,458
我有这些相同的代码行 比如self.name=name 
and I have these identical lines of code, like self.name = name.

2828
02:20:22,458 --> 02:20:25,208
如果我现在去补充说 这只会加剧
And this is only going to get exacerbated if I now go and add

2829
02:20:25,208 --> 02:20:26,083
一些错误检查 
some error checking.

2830
02:20:26,083 --> 02:20:29,916
举个例子 如果不是名字 我们
So for instance, how about if not name, we

2831
02:20:29,916 --> 02:20:32,083
应该养成养成养东西的习惯
should probably be in the habit of raising something

2832
02:20:32,083 --> 02:20:36,208
比如说明性消息中的值错误 比如“缺少名称” 
like a value error in an explanatory message, like "Missing name."

2833
02:20:36,208 --> 02:20:37,166
你知道吗？
And you know what?

2834
02:20:37,166 --> 02:20:39,750
如果一位教授遗漏了他们的名字 我可能应该
If a professor is missing their name, I should probably

2835
02:20:39,750 --> 02:20:41,291
把代码复制粘贴到这里 
copy, paste that code down here.

2836
02:20:41,291 --> 02:20:43,666
这就是危险信号应该发出的地方 
And that's where red flags should be going off,

2837
02:20:43,666 --> 02:20:45,916
因此 一旦您开始复制粘贴代码 
whereby, as soon as you start copy pasting code,

2838
02:20:45,916 --> 02:20:50,208
可能有一种更好的方法 这样我们可以只写一次代码 也许
there's probably a better way so that we can write the code once and perhaps

2839
02:20:50,208 --> 02:20:51,500
以某种方式重复使用它 
reuse it in some way.

2840
02:20:51,500 --> 02:20:54,916
在这里 面向对象编程也提供了一种解决方案 
And here, too, object-oriented programming offers a solution.

2841
02:20:54,916 --> 02:20:58,041
事实证明 Python语言中的面向对象编程
It turns out that object-oriented programming in Python

2842
02:20:58,041 --> 02:21:03,458
还支持继承 从而可以定义多个类
also supports inheritance, whereby you can define multiple classes that

2843
02:21:03,458 --> 02:21:05,125
以某种方式相互联系 
somehow relate to one another.

2844
02:21:05,125 --> 02:21:07,833
它们不需要以这种方式并行存在 
They don't need to exist in parallel in this way.

2845
02:21:07,833 --> 02:21:10,375
实际上 它们之间可能存在某种等级关系 
There could actually be some hierarchy between them.

2846
02:21:10,375 --> 02:21:12,333
举个例子 在魔法世界里 我们
So for instance, in the wizarding world, we

2847
02:21:12,333 --> 02:21:15,583
可以争辩说 学生和教授最终都是 
could argue that both a student and a professor are, at the end of the day,

2848
02:21:15,583 --> 02:21:16,291
奇才队 
Wizards.

2849
02:21:16,291 --> 02:21:19,666
所以也许我们真正应该定义的是第三类 
So maybe what we should really define is a third class,

2850
02:21:19,666 --> 02:21:21,958
例如 名为向导 它有任何
for instance, called wizard, that has any

2851
02:21:21,958 --> 02:21:25,916
学生和教授的共同属性 
of the common attributes for students and professors alike.

2852
02:21:25,916 --> 02:21:27,791
就目前而言 我们保持了相对简单的做法 
And for now, we've kept it relatively simple.

2853
02:21:27,791 --> 02:21:30,666
它们唯一的共同点就是名字和名字 
The only thing they have in common is a name and a name,

2854
02:21:30,666 --> 02:21:32,458
分别在学生和教授身上 
in student and professor, respectively.

2855
02:21:32,458 --> 02:21:35,416
那么 为什么我们不先把这一点考虑到最低限度呢？
So why don't we minimally factor that out first?

2856
02:21:35,416 --> 02:21:37,083
好了 让我继续讲下去 
All right, so let me go ahead here.

2857
02:21:37,083 --> 02:21:39,708
为了让事情井然有序 在我的文件顶部 让我们
And just to keep things organized, at the top of my file, let's

2858
02:21:39,708 --> 02:21:41,833
定义名为向导的第三个类 
define a third class called Wizard.

2859
02:21:41,833 --> 02:21:45,208
并且向导将有其自己的初始化方法 
And a wizard will have its own initialization method.

2860
02:21:45,208 --> 02:21:49,541
所以 一如既往地定义__init_(Self) 
So def __init__(self), as always.

2861
02:21:49,541 --> 02:21:52,333
而一个巫师 比方说 现在只会去
And a wizard, let's say for now, is only going

2862
02:21:52,333 --> 02:21:55,625
以这种方式使用它们的名称进行初始化 
to be initialized with their name in this way.

2863
02:21:55,625 --> 02:21:58,791
现在 我将继续进行一些错误检查 
And now, I'm going to go ahead and do some of that error checking.

2864
02:21:58,791 --> 02:22:02,708
因此 如果不是这样 名称将在向导类中引发一个值错误 
So if not name will raise a value error in the wizard class.

2865
02:22:02,708 --> 02:22:06,041
否则 我们将继续做自己的名字等于名字 
Otherwise, we'll go ahead and do self name equals name,

2866
02:22:06,041 --> 02:22:09,666
还有 见鬼 点 也许还有其他一些功能 
and, heck, dot, dot, dot, maybe some other functionality as well.

2867
02:22:09,666 --> 02:22:13,041
但不是一个特定于教授的主题 而不是一个房子 
But not a subject, which is specific to professors, and not a house,

2868
02:22:13,041 --> 02:22:15,166
我声称这是专门针对学生的 
which I've claimed is specific to students.

2869
02:22:15,166 --> 02:22:18,375
现在 我想我们可以开始移除
Now, I think we can begin to maybe remove

2870
02:22:18,375 --> 02:22:20,833
我们这里其他班级的一些裁员 
some of the redundancies in our other classes here.

2871
02:22:20,833 --> 02:22:24,416
举个例子 跟学生打交道 我为什么不
So for instance, down with student, why don't I

2872
02:22:24,416 --> 02:22:28,750
继续删除此处的错误检查并删除此错误--
go ahead and remove this error checking here and remove this error--

2873
02:22:28,750 --> 02:22:32,166
这个self.name=name的赋值 因为我已经
this assignment of self.name = name because I'm already

2874
02:22:32,166 --> 02:22:33,291
在向导中执行此操作 
doing that in Wizard.

2875
02:22:33,291 --> 02:22:35,958
同样 在这里 教授 为什么我不做同样的事情呢？
And similarly, down here, in Professor, why don't I do the same?

2876
02:22:35,958 --> 02:22:37,583
让我们去掉错误检查 
Let's get rid of the error checking.

2877
02:22:37,583 --> 02:22:41,083
让我们去掉self.name=name 因为我已经在这样做了
Let's get rid of self.name = name because, again, I'm doing that already

2878
02:22:41,083 --> 02:22:43,041
巫师也在那里 
up there for Wizard as well.

2879
02:22:43,041 --> 02:22:45,916
但现在 即使它们都在同一个文件里 
But at the moment, even though they're all in the same file,

2880
02:22:45,916 --> 02:22:50,666
我没有告诉Python学生是巫师 教授是巫师 
I haven't told Python that a student is a wizard and a professor is a wizard.

2881
02:22:50,666 --> 02:22:53,000
所以我真的需要把这两者联系起来 
So I really need to link these two together.

2882
02:22:53,000 --> 02:22:57,500
你可以规定继承的方式 一个类应该
And the way you can prescribe inheritance, whereby one class should

2883
02:22:57,500 --> 02:23:00,041
从另一个类继承 或者相反 从一个类继承
inherit from another, or conversely, one class

2884
02:23:00,041 --> 02:23:03,541
应该是从另一个进化而来的--我们可以做到 
should descend from another-- we can do this.

2885
02:23:03,541 --> 02:23:05,125
我可以说是同学 
I can say class Student.

2886
02:23:05,125 --> 02:23:08,416
但是在冒号之前 我可以在括号里说 
But before the colon, I can go in and say in parentheses,

2887
02:23:08,416 --> 02:23:13,916
学生继承自向导 或者是向导的子类 相反 
a student inherits from, or is a subclass of wizard, which, conversely,

2888
02:23:13,916 --> 02:23:16,666
是student类的超类 
is the superclass of the student class.

2889
02:23:16,666 --> 02:23:19,583
这意味着 当我定义一个学生类时 
So this just means that, when I define a student class,

2890
02:23:19,583 --> 02:23:23,958
继续前进 并继承所有的特点 一个向导以及 
go ahead and inherit all of the characteristics of a wizard as well.

2891
02:23:23,958 --> 02:23:26,875
我也会为教授做同样的事
And I'm going to do the same thing for Professor.

2892
02:23:26,875 --> 02:23:30,166
所以（巫师）在班级名称教授之后 
So (Wizard) after the class name Professor,

2893
02:23:30,166 --> 02:23:33,833
这将使我能够访问一些相同的功能 
and that's going to give me access to some of that same functionality.

2894
02:23:33,833 --> 02:23:37,458
但是因为我的学生班和教授班
But because my student class and my professor class

2895
02:23:37,458 --> 02:23:39,416
仍然有相同的init方法 
still have their same init methods, those

2896
02:23:39,416 --> 02:23:41,291
是将要被调用的方法 
are the methods that are going to get called.

2897
02:23:41,291 --> 02:23:44,916
每当我用代码创造一个学生或者一个教授 
Whenever I create a student in code or I create a professor in code,

2898
02:23:44,916 --> 02:23:47,625
我需要明确地说我也
I need to somehow explicitly say that I also

2899
02:23:47,625 --> 02:23:51,916
要使用Wizard类的init方法中的功能 
want to use the functionality in the Wizard class's init method.

2900
02:23:51,916 --> 02:23:54,916
在Python中这样做的方法如下 
And the way to do this in Python is as follows.

2901
02:23:54,916 --> 02:23:56,958
让我们来看看Student的init方法 
Let me go into my init method for Student,

2902
02:23:56,958 --> 02:23:59,958
让我给super打个电话 没有参数 
and let me call super, with no arguments, which

2903
02:23:59,958 --> 02:24:03,333
是对该类的超类的引用 
is a reference to the superclass of this class.

2904
02:24:03,333 --> 02:24:05,916
如果这个类是Student 那么超类 
So if this class is Student, the superclass-- that is,

2905
02:24:05,916 --> 02:24:07,791
父类是Wizard 
the parent class-- is Wizard.

2906
02:24:07,791 --> 02:24:13,875
所以super（）将具有访问超类的效果 
So super() will have the effect of accessing the superclass.

2907
02:24:13,875 --> 02:24:17,750
然后我将继续并显式调用它的init方法 
And then I'm going to go ahead and explicitly call its init method,

2908
02:24:17,750 --> 02:24:21,416
我将把它传递给向导的init方法
and I'm going to pass to the Wizard's init method

2909
02:24:21,416 --> 02:24:24,958
传递给学生的init方法的名称 
the name that the student's init method was passed.

2910
02:24:24,958 --> 02:24:28,000
我将继续在Wizard中做同样的事情 
And I'm going to go ahead and do the same down here in Wizard.

2911
02:24:28,000 --> 02:24:29,666
这是一行复制 粘贴 
This is one line of copy, paste.

2912
02:24:29,666 --> 02:24:32,375
但我觉得我在这里挺好的因为
But I think I'm OK with it here because it's still

2913
02:24:32,375 --> 02:24:34,291
允许我完成所有的名字分配
allowing me to do all of the name assignment

2914
02:24:34,291 --> 02:24:37,000
并改为在向导类中进行错误检查 
and the error checking up in the Wizard class instead.

2915
02:24:37,000 --> 02:24:42,250
我想我们现在只要为两个学生调用Super.init就可以了
I think we're OK now by just calling super.init for both student

2916
02:24:42,250 --> 02:24:43,416
和教授一样 
and Professor alike.

2917
02:24:43,416 --> 02:24:47,208
现在 无可否认 这种语法确实存在--事实是
Now, admittedly, this syntax is definitely out there-- the fact

2918
02:24:47,208 --> 02:24:49,541
我们在圆括号和圆点中称其为Super.
that we're calling super in parentheses and dots

2919
02:24:49,541 --> 02:24:52,458
并在init的左侧和右侧加下划线 
and underscore underscore on the left and the right of init here,

2920
02:24:52,458 --> 02:24:54,875
但这只是这两个想法的结合 
but it's just a combination of these two ideas.

2921
02:24:54,875 --> 02:25:00,916
Super()是以编程方式访问当前类的父类的一种方式
super() is a way of programmatically accessing a current class's parent

2922
02:25:00,916 --> 02:25:05,291
类 或超类 当然 __init只是指 现在 
class, or superclass, and __init, of course, is just referring to, now,

2923
02:25:05,291 --> 02:25:08,041
该类自己的初始化方法 
that class's own initialization method.

2924
02:25:08,041 --> 02:25:09,958
现在 根据点 点 点--所以可能有
Now, per the dot, dot, dot-- so there could be

2925
02:25:09,958 --> 02:25:11,500
在这些课程中有更多的内容 
a lot more going on in these classes.

2926
02:25:11,500 --> 02:25:15,208
但现在最好的是巫师作为一个班级
But what's nice now is that Wizard as a class

2927
02:25:15,208 --> 02:25:18,291
负责所有巫师名字的分配 
is taking care of all of the assignment of a wizard's name,

2928
02:25:18,291 --> 02:25:20,458
不管那个巫师是学生还是教授 
whether that wizard is a student or a professor.

2929
02:25:20,458 --> 02:25:22,416
它甚至还进行了一些错误检查 以使
And it's even doing some error checking to make

2930
02:25:22,416 --> 02:25:25,125
当然 这个名字确实是传进来的 
sure the name was actually passed in.

2931
02:25:25,125 --> 02:25:29,166
同时 学生继承了所有这些功能
Meanwhile, student is inheriting all of that functionality

2932
02:25:29,166 --> 02:25:32,333
并通过调用超类自己的init方法来使用它 
and using it by calling the superclass's own init method.

2933
02:25:32,333 --> 02:25:35,041
但它还额外征用了房子 这可能是
But it's additionally taking the house, that's presumably

2934
02:25:35,041 --> 02:25:37,375
传递到学生构造函数中 
passed into the student constructor function,

2935
02:25:37,375 --> 02:25:40,833
并将其赋给自己的实例变量--self.house 
and assigning it to its own instance variable-- self.house,

2936
02:25:40,833 --> 02:25:44,458
同样 教授 或自我恢复的学科 
and similarly, professor, or restoring in self.subject

2937
02:25:44,458 --> 02:25:47,875
这个主题也被传递到了那个主题中 
the subject that was passed into that one as well.

2938
02:25:47,875 --> 02:25:49,916
现在 我们该如何使用这些类呢？
Now, how might we use these classes?

2939
02:25:49,916 --> 02:25:53,500
好的 我们将继续挥舞我们的手 在这里介绍一些细节 
Well, we'll continue to wave our hands with a little bit of detail here.

2940
02:25:53,500 --> 02:25:56,750
但在此文件的底部 或导入此文件的任何其他文件中 
But at the bottom of this file, or any other file that imports this one,

2941
02:25:56,750 --> 02:25:58,833
我现在可以像这样编写代码了 
I could now write code like this.

2942
02:25:58,833 --> 02:26:01,208
我可以创建一个学生变量并将
I could create a student variable and assign

2943
02:26:01,208 --> 02:26:03,458
它是学生构造函数调用的返回值 
it the return value of the student constructor call.

2944
02:26:03,458 --> 02:26:07,625
也许那个学生叫哈里和那个学生的房子 
and maybe that student is named Harry and that student's house,

2945
02:26:07,625 --> 02:26:10,041
例如 可能是格兰芬多 
for instance, might be Gryffindor.

2946
02:26:10,041 --> 02:26:14,750
同时 我可能会做这样的事情 教授=这里的教授 
And meanwhile, I might do something like this. professor = Professor over here.

2947
02:26:14,750 --> 02:26:18,541
注意 小写的S在左边 大写的S在右边 
And notice, the lowercase S on the left, capital S on the right.

2948
02:26:18,541 --> 02:26:21,875
左边的教授也一样--右边是小写和大写
Same for professor on the left-- lowercase and uppercase on the right

2949
02:26:21,875 --> 02:26:22,750
分别进行了分析 
respectively.

2950
02:26:22,750 --> 02:26:25,625
教授 引用 引用 “西弗勒斯” 以及如何
Professor, quote, unquote, "Severus," and how

2951
02:26:25,625 --> 02:26:30,500
关于黑魔法防御的话题会是他的主题吗？
about Defense Against the Dark Arts will be his subject?

2952
02:26:30,500 --> 02:26:32,791
同时 如果我们愿意 更笼统地说 
And meanwhile, if we want, more generically,

2953
02:26:32,791 --> 02:26:37,291
我只是个巫师 现在既不是学生也不是教授
just a wizard, who, at the moment is neither student nor professor

2954
02:26:37,291 --> 02:26:39,375
积极授课 我们甚至可以这样做 
teaching classes actively, we could even do that.

2955
02:26:39,375 --> 02:26:43,458
我们可以用右手边的大写W表示WANDIZE=WANDIZE
We could do wizard = Wizard in capital W on the right-hand side

2956
02:26:43,458 --> 02:26:45,708
等号 因为它是班级的名字 
of the equal sign, because it's the name of the class.

2957
02:26:45,708 --> 02:26:47,166
像阿不思这样的人--
And someone like Albus--

2958
02:26:47,166 --> 02:26:49,958
只传了阿不思的名字--
passing in only Albus's name--

2959
02:26:49,958 --> 02:26:55,708
不是房子 也不是主题 因为在这种情况下 他只被称为巫师 
not a house, not a subject, because, in this case, he's known only as a wizard.

2960
02:26:55,708 --> 02:26:58,750
同时 对于这些调用中的每一个 这行代码
Meanwhile, with each of these calls, this line of code

2961
02:26:58,750 --> 02:27:01,833
这里将确保调用向导类的init方法 
here will ensure that the init method for the wizard class is called.

2962
02:27:01,833 --> 02:27:05,583
这里的这行代码将确保学生的init方法
This line of code here will ensure that the init method of the student

2963
02:27:05,583 --> 02:27:09,250
类 然后调用超类向导的init方法 
class and, in turn, the init method of the superclass wizard is called.

2964
02:27:09,250 --> 02:27:11,541
最后 在这最后一行代码中 
And then lastly, on this final line of code,

2965
02:27:11,541 --> 02:27:15,625
此语法是否能确保教授类的init方法
will this syntax ensure that the init method of the professor class

2966
02:27:15,625 --> 02:27:20,375
被调用 而后者又调用超类的init方法 
is called, which, in turn, calls the init method of the superclass as well.

2967
02:27:20,375 --> 02:27:24,083
现在对继承这一概念有任何疑问 
Any questions now on this idea of inheritance,

2968
02:27:24,083 --> 02:27:29,125
哪一项是许多面向对象编程语言的关键特性？
which is a key feature of a lot of object-oriented programming languages?

2969
02:27:33,458 --> 02:27:36,708
迈克尔：就我目前所见 很多时候 都有很多筑巢的地方 
MICHAEL: From what I've seen so far, a lot of times, there's a lot of nesting.

2970
02:27:36,708 --> 02:27:38,375
如果你做的是超级的 会涨一分吗？
If you do super, does it go one up?

2971
02:27:38,375 --> 02:27:44,375
是否存在这样的情况：它也嵌套在向导上方的另一个类中 
Is there any situation where it's nested in another class as well, above Wizard,

2972
02:27:44,375 --> 02:27:44,875
比方说？
let's say?

2973
02:27:44,875 --> 02:27:46,500
大卫·J·马兰：这是一个非常好的问题 
DAVID J. MALAN: A really good question.

2974
02:27:46,500 --> 02:27:48,375
如果你有一个超级班级--所以
If you were to have a super superclass-- so

2975
02:27:48,375 --> 02:27:52,833
您的层次结构甚至比这两个层次结构还要高
your hierarchy is even taller than the two levels of hierarchy

2976
02:27:52,833 --> 02:27:56,625
我们目前拥有的 绝对是 
that we currently have, absolutely.

2977
02:27:56,625 --> 02:27:59,250
继承的好处 顾名思义 是 
What's nice about inheritance, as the name implies, is,

2978
02:27:59,250 --> 02:28:02,583
就像你作为一个人类可能继承了某些特征一样
just as you might have inherited certain traits as a human

2979
02:28:02,583 --> 02:28:06,000
从你的祖父和祖母或你的曾祖父
from your grandfather and grandmother or your great-grandfather

2980
02:28:06,000 --> 02:28:08,333
或曾祖母 其中一些财产
or great-grandmother, some of those properties

2981
02:28:08,333 --> 02:28:13,083
实际上也可以在代码的上下文中慢慢地传递给你 
can actually trickle down to you in the context of code as well.

2982
02:28:13,083 --> 02:28:17,291
所以当你从另一个阶级下来的时候
So when you descend from another class--

2983
02:28:17,291 --> 02:28:21,541
也就是说 当你子类化一个超类或一个超超类时 
that is, when you subclass a superclass or a super superclass,

2984
02:28:21,541 --> 02:28:23,958
你实际上继承了所有的功能 
you actually do inherit all of the functionality,

2985
02:28:23,958 --> 02:28:26,625
不是从你上面一层而是从两三层
not just from one level above you but from two or three,

2986
02:28:26,625 --> 02:28:29,583
因此您确实也可以访问某些功能 
so you can indeed access some of that functionality as well.

2987
02:28:29,583 --> 02:28:32,666
你甚至可以覆盖它 如果你想要其中的一些类
And you can even override it if you want some of these classes

2988
02:28:32,666 --> 02:28:35,750
和其他人有一点点不同
to behave a little bit differently than others.

2989
02:28:35,750 --> 02:28:38,125
关于继承的其他问题
Other questions on inheritance.

2990
02:28:38,125 --> 02:28:39,875
观众：所以它和上一个类似 
AUDIENCE: So it's similar to the last one,

2991
02:28:39,875 --> 02:28:43,125
但你能让两个父母处于同一水平吗
but can you have two parents on the same level?

2992
02:28:43,125 --> 02:28:44,750
David J. Malan：一个非常好的问题 
DAVID J. MALAN: A really good question.

2993
02:28:44,750 --> 02:28:49,875
因此 有一些方法可以实现多个父代的后代 
So there are ways to implement descendants from multiple parents.

2994
02:28:49,875 --> 02:28:53,125
有不同的方法来做到这一点 不仅仅是在Python中 还有其他语言 
And there's different ways to do this, not just in Python but other languages.

2995
02:28:53,125 --> 02:28:57,916
不过 我们在这里保持了简单 只使用一个继承路径 
We've kept things simple here, though, by having a single inheritance path.

2996
02:28:57,916 --> 02:28:58,666
问得好
A good question.

2997
02:28:58,666 --> 02:29:01,291
再问一个关于继承的问题怎么样？
How about one more question on inheritance?

2998
02:29:01,291 --> 02:29:07,208
观众：我们可以在super中有多个参数 init？
AUDIENCE: Can we have multiple arguments in super.__init?

2999
02:29:07,208 --> 02:29:11,000
大卫·J·马兰：是的 但在这种情况下 我只在第18行传递一个名字 
DAVID J. MALAN: Yes, but in this case, I'm only passing a name on line 18,

3000
02:29:11,000 --> 02:29:13,666
我只在第10行输入名字
and I'm only passing in name on line 10.

3001
02:29:13,666 --> 02:29:14,166
为什么要这样？
Why?

3002
02:29:14,166 --> 02:29:18,208
因为 在第2行 当我为Wizard类定义init方法时 
Because, on line 2, when I define the init method for the Wizard class,

3003
02:29:18,208 --> 02:29:20,375
我只希望有一个论点 
I only expect a single argument.

3004
02:29:20,375 --> 02:29:23,583
但我完全可以有其他的通用功能 
But I could absolutely have other common functionality.

3005
02:29:23,583 --> 02:29:24,750
我可以加一个守护神 
I could add in a patronus.

3006
02:29:24,750 --> 02:29:27,125
如果学生和教授都有赞助人
If both students and professors have patronuses

3007
02:29:27,125 --> 02:29:30,958
可以从他们的魔杖中发出 我可以有两个论点 
that can come out of their wands, I could have two arguments instead.

3008
02:29:30,958 --> 02:29:33,708
我们一直在使用面向对象编程的这个特性
We've been using this feature of object-oriented programming

3009
02:29:33,708 --> 02:29:37,000
在很长一段时间内 以例外的形式 
now for quite some time in the form of exceptions.

3010
02:29:37,000 --> 02:29:40,625
实际上 如果你查看Python中异常的官方文档 
Indeed, if you look at the official documentation for exceptions in Python,

3011
02:29:40,625 --> 02:29:43,208
你会发现这甚至不是我们在课堂上看到的 
you'll see that there's not even the ones we've seen in class,

3012
02:29:43,208 --> 02:29:44,541
比如价值错误和其他 
like value error and others.

3013
02:29:44,541 --> 02:29:48,666
还有很多其他的 但他们都是 他们自己 
There's any number of others as well, but they are all, themselves,

3014
02:29:48,666 --> 02:29:50,125
等级制的
hierarchical in nature.

3015
02:29:50,125 --> 02:29:54,416
这只是内置到Python中的可用异常的一个子集 
This is just a subset of the available exceptions that come built into Python.

3016
02:29:54,416 --> 02:29:58,125
实际上 作为程序员 您也可以创建自己的异常 
And you can actually, as a programmer, create your own exceptions as well.

3017
02:29:58,125 --> 02:30:01,916
但正如这张图表所显示的那样 
But as this chart here captures hierarchically,

3018
02:30:01,916 --> 02:30:06,125
我们到目前为止看到的所有例外情况实际上都是从
all exceptions we've seen thus far actually descend from

3019
02:30:06,125 --> 02:30:09,041
或者已经从超类继承 
or inherit from superclasses already.

3020
02:30:09,041 --> 02:30:10,833
因此 例如 在这个列表的底部
So for instance, at the bottom of this list

3021
02:30:10,833 --> 02:30:13,250
下面是ValueError 我们已经见过很多次了 
here is ValueError, which we've seen quite a bit.

3022
02:30:13,250 --> 02:30:17,583
如果你沿着这张ASCII图表上的直线向上 
And if you follow the line straight up on this ascii rendition of this chart,

3023
02:30:17,583 --> 02:30:22,083
您将看到ValueError有一个父类、类或超类 称为异常 
you'll see that ValueError has a parent, class, or superclass, called exception.

3024
02:30:22,083 --> 02:30:25,958
同时 Except类有一个称为基异常的父类 
And the exception class, meanwhile, has a parent class called base exception.

3025
02:30:25,958 --> 02:30:28,125
为什么Python的作者要这样做呢？
Why did the authors of Python do this?

3026
02:30:28,125 --> 02:30:32,958
事实证明 无论是值错误还是键错误
Well, it turns out that, whether you have a value error or a key error

3027
02:30:32,958 --> 02:30:35,416
或断言错误或任何数量的其他错误 
or an assertion error or any number of others,

3028
02:30:35,416 --> 02:30:40,250
所有这些类型的错误都有很多共同的功能
there's a lot of functionality common to all of those types of errors

3029
02:30:40,250 --> 02:30:42,458
你想要的--
that you want--

3030
02:30:42,458 --> 02:30:44,958
您希望程序员能够使用的 
that you want a programmer to be able to use.

3031
02:30:44,958 --> 02:30:48,375
所以 事实证明 Python的作者们决定 你知道吗？
And so it turns out that the authors of Python decided, you know what?

3032
02:30:48,375 --> 02:30:51,791
我们不要有十几个或更多不同的班级
Let's not have a dozen or more different classes

3033
02:30:51,791 --> 02:30:55,166
只是都有复制、粘贴类似的功能 
that all just have copy, pasted similar functionality.

3034
02:30:55,166 --> 02:30:57,250
让我们创建这个层次结构 这样 即使
Let's create this hierarchy so that, even

3035
02:30:57,250 --> 02:31:00,875
尽管这份名单中垫底的例外情况非常准确 
though the exceptions toward the bottom of this list are very precise,

3036
02:31:00,875 --> 02:31:02,291
他们至少继承了--
they at least inherit--

3037
02:31:02,291 --> 02:31:05,583
也就是说 借用上面一些非常常见的功能 
that is, borrow some very common functionality up above.

3038
02:31:05,583 --> 02:31:09,541
因此 当您在Python中使用Try和Accept关键字时 
So it turns out that, when you use the Try and the Accept keyword in Python,

3039
02:31:09,541 --> 02:31:13,291
一般来说 我们会尝试捕捉非常具体的例外情况 
generally speaking, we've tried to catch very specific exceptions,

3040
02:31:13,291 --> 02:31:14,291
比如ValueError 
like ValueError.

3041
02:31:14,291 --> 02:31:17,458
但从技术上讲 你可以抓住孩子的父母 甚至
But technically, you could capture the parents or even

3042
02:31:17,458 --> 02:31:20,375
给定异常的祖父母异常 
the grandparent exception for a given exception,

3043
02:31:20,375 --> 02:31:23,500
尤其是当你不确定哪一个会被抚养长大的时候 
especially if you're not necessarily sure which one is going to get raised.

3044
02:31:23,500 --> 02:31:27,041
或者 更好的是 可能会有许多例外被提出 
Or, better yet, there could be many exceptions that get raised,

3045
02:31:27,041 --> 02:31:28,958
但你想对他们一视同仁 
but you want to handle them all the same,

3046
02:31:28,958 --> 02:31:31,000
你不一定要列举它们
and you don't want to necessarily enumerate them

3047
02:31:31,000 --> 02:31:33,041
在括号中 用逗号隔开 
in parentheses, separated by commas.

3048
02:31:33,041 --> 02:31:36,625
你想说你想处理某个超类的所有异常
You want to say you want to handle all exceptions of a certain superclass

3049
02:31:36,625 --> 02:31:38,416
以同样的方式 
in much the same way.

3050
02:31:38,416 --> 02:31:40,833
所以这一直都是潜伏的 每当我们
So this has been latent this whole time, any time we've

3051
02:31:40,833 --> 02:31:45,166
看到或使用或捕获 或者现在 引发异常 并内置到Python中
seen or used or caught or, now, raised exceptions, and built into Python

3052
02:31:45,166 --> 02:31:46,041
就是这种等级制度 
is this hierarchy.

3053
02:31:46,041 --> 02:31:47,916
如果你要发明自己的例外 
And if you were to invent your own exception,

3054
02:31:47,916 --> 02:31:50,250
一般来说 你不会想从头开始 
generally, you wouldn't want to start from scratch.

3055
02:31:50,250 --> 02:31:54,041
你会想要从--也就是说 子类 
You would want to descend from-- that is, subclass, one of these existing

3056
02:31:54,041 --> 02:31:58,958
异常 并添加自己的扭曲 你自己的功能以及 
exceptions and add your own twist on it, your own functionality as well.

3057
02:31:58,958 --> 02:32:02,208
面向对象编程的最后一个特点
Well, there's one final feature of object oriented programming

3058
02:32:02,208 --> 02:32:04,750
我们今天想和大家分享的
that we'd like to share with you today, and then it

3059
02:32:04,750 --> 02:32:08,291
也许会让你大开眼界 看看你现在能做什么
will perhaps be quite the eye opener as to what you can really do now

3060
02:32:08,291 --> 02:32:10,208
你可以随意上课
that you have classes at your disposal.

3061
02:32:10,208 --> 02:32:12,791
这也是一个令人惊讶的特点 
And this, too, surprise, has been a feature

3062
02:32:12,791 --> 02:32:15,458
你我已经习以为常了
you and I have been taking for granted for weeks now.

3063
02:32:15,458 --> 02:32:18,250
这已经奏效了 但它的实施方式
This has just worked, but it's been implemented in a way

3064
02:32:18,250 --> 02:32:20,208
你现在可以利用自己 
that you can now leverage yourself.

3065
02:32:20,208 --> 02:32:23,166
事实证明 Python和其他一些语言 
It turns out that Python, and some other languages, too,

3066
02:32:23,166 --> 02:32:27,041
支持这种运算符重载的概念 
support this notion of operator overloading, whereby

3067
02:32:27,041 --> 02:32:32,250
你可以使用非常常见的符号 比如加号、减号或其他类似的语法 
you can take very common symbols, like plus or minus or other such syntax

3068
02:32:32,250 --> 02:32:37,416
在键盘上 你可以实现你自己的解释 
on the keyboard, and you can implement your own interpretation thereof.

3069
02:32:37,416 --> 02:32:40,791
加不等于加 
Plus does not have to equal addition.

3070
02:32:40,791 --> 02:32:43,291
减不一定等于减 
And minus does not have to equal subtraction.

3071
02:32:43,291 --> 02:32:45,708
事实上 你和我已经看到了另一个背景
And in fact, you and I have already seen another context

3072
02:32:45,708 --> 02:32:48,541
其中加号代表别的意思 
in which plus means something else.

3073
02:32:48,541 --> 02:32:52,750
在Python中 加号本身并不总是意味着加法 
Plus has not always, in Python, meant addition, per se.

3074
02:32:52,750 --> 02:32:56,458
Python还用plus做什么？
What else has Python used plus for?

3075
02:32:56,458 --> 02:32:57,458
观众：串联？
AUDIENCE: Concatenation?

3076
02:32:57,458 --> 02:32:58,875
DAVID J. MALAN：用于连接 
DAVID J. MALAN: For concatenation.

3077
02:32:58,875 --> 02:33:02,875
对于连接两个字符串 对于添加到列表中 您也可以使用加号 
For joining two strings, for adding to a list can you use plus as well.

3078
02:33:02,875 --> 02:33:07,666
有趣的是 Python的作者们实际上已经重载了So plus
So plus has actually been, funny enough, overloaded by the authors of Python

3079
02:33:07,666 --> 02:33:08,541
为我们
for us.

3080
02:33:08,541 --> 02:33:12,000
所以我们可以用和加法一样的方法来使用这个符号
And so we can use the same symbol in much the same way as addition

3081
02:33:12,000 --> 02:33:15,250
但使用不同的数据类型来解决略有不同的问题 
but with different data types to solve slightly different problems.

3082
02:33:15,250 --> 02:33:18,250
我建议我们回到VS Code
Well, let me propose that we go back over to VS Code here,

3083
02:33:18,250 --> 02:33:22,250
让我继续创建一个新的最终文件 名为vault.py 
and let me go ahead and create a new final file called vault.py.

3084
02:33:22,250 --> 02:33:24,000
所以代码是vault.py 
So code of vault.py.

3085
02:33:24,000 --> 02:33:27,416
让我提议我们实施一个金库的想法
And let me propose that we implement the idea of a vault

3086
02:33:27,416 --> 02:33:30,541
在古灵阁 保持主题 其中有
at Gringotts, keeping on theme, wherein there's

3087
02:33:30,541 --> 02:33:32,291
哈利·波特世界里的银行
a bank in the world of Harry Potter.

3088
02:33:32,291 --> 02:33:35,083
在这家银行里 家庭和个人
And within this bank, families and individuals

3089
02:33:35,083 --> 02:33:38,958
在魔法世界里有各种各样的钱
have vaults containing all sorts of money in the wizarding world.

3090
02:33:38,958 --> 02:33:41,583
在哈利·波特的世界里 
And the type of money that exists in the world of Harry Potter

3091
02:33:41,583 --> 02:33:44,791
是被称为加隆、镰刀和克努特的硬币
are coins called galleons and sickles and Knuts,

3092
02:33:44,791 --> 02:33:47,083
这些是按价值递减的顺序排列的 
and those are in descending order of value.

3093
02:33:47,083 --> 02:33:49,750
在金库里可能有一大堆硬币
And so inside of a vault might be a whole bunch of coins--

3094
02:33:49,750 --> 02:33:53,000
金 银 铜 基本上 每一个在这些面额 
gold, silver, and bronze, essentially, each in those denominations,

3095
02:33:53,000 --> 02:33:53,833
藏起来了
tucked away.

3096
02:33:53,833 --> 02:33:58,083
那么首先 我该如何实现保险库的概念呢
So how can I go about implementing, first of all, the idea of a vault

3097
02:33:58,083 --> 02:34:02,375
这样我就可以储存 比如 哈利波特 
so that I can store, for instance, for Harry Potter, how much coinage

3098
02:34:02,375 --> 02:34:05,916
是在他家的金库里 还是罗恩·韦斯莱的金库里
is in his family's vault, or for Ron Weasley the same?

3099
02:34:05,916 --> 02:34:08,291
好吧 让我继续 vault.py 首先
Well, let me go ahead and vault.py and first

3100
02:34:08,291 --> 02:34:12,291
创建一个名为Vault的类 基本上表示银行金库 
create a class called Vault, essentially meant to represent a bank vault.

3101
02:34:12,291 --> 02:34:15,000
完美 另一个真实的世界 或者幻想的世界 
Perfect, another real world, or fantasy world,

3102
02:34:15,000 --> 02:34:17,500
我想用代码表示的实体 
entity that I want to represent with code.

3103
02:34:17,500 --> 02:34:19,958
我可以用一个元组或者一个列表或者一个字典 
I could use a tuple or a list or a dictionary.

3104
02:34:19,958 --> 02:34:23,083
但是 我还是要用类来获得更多的功能 
But again, I'm going to get a lot more functionality with classes,

3105
02:34:23,083 --> 02:34:26,125
and we'll我们会see one final最后flourish繁荣with operators运营商.
and we'll see one final flourish with operators.

3106
02:34:26,125 --> 02:34:28,875
在跳马课里 我们来做这个 
Inside of this vault class, let's go ahead and do this.

3107
02:34:28,875 --> 02:34:32,625
让我定义我的init方法 使用它的第一个参数self 
Let me define my init method, taking its first argument of self.

3108
02:34:32,625 --> 02:34:35,625
让我来定义三个论点 
And let me define three arguments to this.

3109
02:34:35,625 --> 02:34:38,541
当你创建一个保险库时 在我的代码中 
When you create a vault, in my code here,

3110
02:34:38,541 --> 02:34:41,750
我希望能用一些加隆来初始化它 一些数字
I want to be able to initialize it with some number of galleons, some number

3111
02:34:41,750 --> 02:34:43,375
镰刀和坚果
of sickles and, some number of Knuts.

3112
02:34:43,375 --> 02:34:46,791
我希望用户 程序员 能够传入一个或多个
I want the user, the programmer, to be able to pass in one or more

3113
02:34:46,791 --> 02:34:47,833
这些价值观的理想 
of those values ideally.

3114
02:34:47,833 --> 02:34:50,083
但它们可以是可选的 所以我给它们默认值 
But they can be optional, so I'll give them defaults.

3115
02:34:50,083 --> 02:34:53,000
让我们定义一个名为galleons的参数 
So let's go ahead and define a parameter called galleons,

3116
02:34:53,000 --> 02:34:57,041
其缺省值为0；镰刀 其缺省值也为0；
whose default value will be 0; sickles, whose default value will also be 0;

3117
02:34:57,041 --> 02:35:00,083
和knts 其缺省值也将为0 
and knuts, whose default value will be 0 as well.

3118
02:35:00,083 --> 02:35:04,541
因此程序员可以传入一个或两个或三个 甚至一个也不传入 
So the programmer can pass in one or two or three or even none of those,

3119
02:35:04,541 --> 02:35:07,125
而且它们都会有一些隐含的违约 
and they'll all have some implied defaults.

3120
02:35:07,125 --> 02:35:10,500
我要如何记住那些传入的值呢？
How do I want to remember those values that are passed in?

3121
02:35:10,500 --> 02:35:11,541
好吧 那就让我来吧 
Well, let me do this.

3122
02:35:11,541 --> 02:35:14,583
大帆船=帆船 
self.galleons = galleons.

3123
02:35:14,583 --> 02:35:17,416
和自我 镰刀=镰刀 
And self.sickles = sickles.

3124
02:35:17,416 --> 02:35:20,708
和self.knerts=knits 
And self.knuts = knuts.

3125
02:35:20,708 --> 02:35:24,541
因此 我可以添加一些错误检查 特别是如果您不通过的话 
And so I could add some error checking, especially if you don't pass in.

3126
02:35:24,541 --> 02:35:27,708
我可以将这些转换为属性 以进行更多的验证 
A number I could turn these into properties to do even more validation.

3127
02:35:27,708 --> 02:35:30,791
但让我们保持简单 一如既往地只关注新想法 
But let's keep it simple and, as always, focus only on the new ideas.

3128
02:35:30,791 --> 02:35:33,291
所以我只会相信这些值是传入的 
So I'm just going to trust that these values were passed in,

3129
02:35:33,291 --> 02:35:36,708
我会立即把它们赋给这些实例变量 
and I'm going to immediately assign them to these instance variables.

3130
02:35:36,708 --> 02:35:38,416
现在 我想要做什么？
What, now, do I want to do?

3131
02:35:38,416 --> 02:35:41,208
好吧 让我们想出一种打印输出的方法
Well, let's come up with a way of printing out

3132
02:35:41,208 --> 02:35:44,000
最终 某人的金库里有什么 
what is in someone's vault, ultimately.

3133
02:35:44,000 --> 02:35:45,291
但首先让我们这样做 
But first let's do this.

3134
02:35:45,291 --> 02:35:50,083
让我们通过分配创建一个新的保险库 从而为波特一家创建一个保险库 
Let's create a vault for the Potters by creating, via assignment, a new vault.

3135
02:35:50,083 --> 02:35:55,125
假设陶工有100只大帆船 50把镰刀和24克朗 
And let's say that the potters have 100 galleons, 50 sickles, and 24 knuts.

3136
02:35:55,125 --> 02:35:58,541
它就在那个保险库里 让我们打印出来 比方说 波特 
And that's in that vault. And let's print out, for instance, potter.

3137
02:35:58,541 --> 02:36:00,916
好的 让我们运行这段代码 看看它现在是如何工作的 
All right, let's run this code and see how it works now.

3138
02:36:00,916 --> 02:36:05,083
让我继续运行Vault.py的Python.Enter 
Let me go ahead and run Python of vault.py, Enter.

3139
02:36:05,083 --> 02:36:06,083
看起来很管用 
Seems to work.

3140
02:36:06,083 --> 02:36:08,041
没有语法错误或其他任何错误 
No syntax errors or anything else.

3141
02:36:08,041 --> 02:36:10,791
但这并不是很有启发性 
But this is not very enlightening.

3142
02:36:10,791 --> 02:36:15,291
回想我们以前做过的事情 我该如何解决这个问题呢？
How do I fix this, thinking back to what we've done before?

3143
02:36:15,291 --> 02:36:17,958
观众：您必须使用__str 
AUDIENCE: You have to use the __str.

3144
02:36:17,958 --> 02:36:18,958
大卫·J·马兰：没错 
DAVID J. MALAN: Exactly.

3145
02:36:18,958 --> 02:36:22,291
我需要使用类附带的一种特殊方法
I need to use one of those special methods that comes with classes

3146
02:36:22,291 --> 02:36:26,625
并自己定义我希望将保险库打印为字符串的方式 
and define for myself how I want a vault to be printed as a string.

3147
02:36:26,625 --> 02:36:27,916
因此 让我继续下去 这样做 
So let me go ahead and do that.

3148
02:36:27,916 --> 02:36:32,541
让我定义将self作为其唯一参数的str方法 
Let me define the str method taking in self as its sole argument here.

3149
02:36:32,541 --> 02:36:34,500
让我们只返回一个非常简单的字符串
And let's just return a very simple string

3150
02:36:34,500 --> 02:36:36,833
这正好揭示了保险库里有什么 
that just reveals what's in the vault.

3151
02:36:36,833 --> 02:36:39,958
所以我将返回一个格式化的f字符串 
So I'm going to return a formatted f string,

3152
02:36:39,958 --> 02:36:44,166
里面是帆船 然后是帆船这个词 
inside of which is self.galleons and then the word galleon,

3153
02:36:44,166 --> 02:36:45,875
所以我知道那些是什么了 
so I know which those are.

3154
02:36:45,875 --> 02:36:49,458
然后让我们自己做 镰刀 让我们输出单词 镰刀 
Then let's do self.sickles, and let's output the word, sickles.

3155
02:36:49,458 --> 02:36:53,083
最后 让我们输出self.knuts 然后在这里输出knuts 
And then lastly let's output self.knuts, and then knuts here.

3156
02:36:53,083 --> 02:36:58,041
所以我知道 在这根绳子上 每一枚硬币有多少
So I know, in this string, just how many of each of those coins

3157
02:36:58,041 --> 02:37:01,666
我在这个特殊家庭的金库里 好的 让我继续
I have in this particular family's vault. All right, let me go ahead

3158
02:37:01,666 --> 02:37:06,166
并运行Vault.py的Python 除了str方法外 不更改其他任何内容 
and run Python of vault.py, changing nothing else except the str method.

3159
02:37:06,166 --> 02:37:11,625
现在 我们确实看到哈利有100艘大帆船 50把镰刀和25枚坚果 
And now, , we, see indeed that Harry has 100 galleons, 50 sickles, and 25 knuts.

3160
02:37:11,625 --> 02:37:13,541
好吧 好吧 我们再做一件事 
All right, well, let's do one thing more here.

3161
02:37:13,541 --> 02:37:16,875
下面 让我们继续定义一个Weasley变量 
Below that, let's go ahead and define a Weasley variable.

3162
02:37:16,875 --> 02:37:20,583
罗恩的金库里似乎从来没有哈利那么多钱 
And Ron never seemed to have quite as much money in the vault as did Harry.

3163
02:37:20,583 --> 02:37:24,541
因此 假设韦斯莱跳马将有25、50和100个 
So let's say that the Weasley vault will have 25, 50, and 100.

3164
02:37:24,541 --> 02:37:27,041
所以我就把这些面额的顺序颠倒一下 
So I'll just reverse the order of those denominations,

3165
02:37:27,041 --> 02:37:29,541
而不是哈利的100 50 25 
rather than Harry's 100, 50, 25.

3166
02:37:29,541 --> 02:37:33,125
现在让我继续把韦斯莱印成这样 
And now let me go ahead and print Weasley like this.

3167
02:37:33,125 --> 02:37:37,291
让我们继续清除我的终端窗口 运行Vault.py的Python 
And let's go ahead and clear my terminal window, run Python of vault.py.

3168
02:37:37,291 --> 02:37:40,541
这次 字符串方法将被调用两次 一次
This time, that str method will be invoked twice, once

3169
02:37:40,541 --> 02:37:42,416
这些保险库对象中的每一个 
for each of those vault objects.

3170
02:37:42,416 --> 02:37:44,666
我们会看到 确实 哈利的第一个
And we'll see, indeed, that the first one for Harry

3171
02:37:44,666 --> 02:37:48,125
分别得到了100 50和25 而罗恩只有25 50 
has got 100, 50, and 25, respectively, versus Ron's 25, 50,

3172
02:37:48,125 --> 02:37:50,583
和100 
and 100, respectively.

3173
02:37:50,583 --> 02:37:52,458
但现在让我们做一些有趣的事情 
But now let's do something interesting.

3174
02:37:52,458 --> 02:37:56,333
假设您想要合并两个存储库的内容 
Suppose that you wanted to combine the contents of two vaults,

3175
02:37:56,333 --> 02:37:58,875
不管是哈里和罗恩还是其他两个人 
be it Harry's and Ron's or any other two people.

3176
02:37:58,875 --> 02:38:02,083
您将如何在代码中进行这项工作？
How would you go about doing this in code?

3177
02:38:02,083 --> 02:38:06,000
如果我想为某人组合保险库 我可以这么做 
Well, if I wanted to combine the vaults for someone, I could do this.

3178
02:38:06,000 --> 02:38:08,333
嗯 我可以做同样的大帆船--
Well, I could do galleons equals--

3179
02:38:08,333 --> 02:38:13,958
让我们来做陶器 大帆船+小帆船 
let's do potter.galleons + weasley.galleons.

3180
02:38:13,958 --> 02:38:16,250
这给了我一个名为Galleons的变量 它具有
That gives me a variable called galleons that has

3181
02:38:16,250 --> 02:38:19,041
哈利和罗恩的大帆船的总和 
the sum of Harry and Ron's galleons.

3182
02:38:19,041 --> 02:38:25,333
接下来让我们做镰刀=陶器 镰刀+韦斯莱镰刀 
Let's next do sickles = potter.sickles + weasley.sickles.

3183
02:38:25,333 --> 02:38:31,916
最后 让我们来做knts=potter.knts+weasley.kutts 
And then lastly, let's do knuts = potter.knuts + weasley.knuts.

3184
02:38:31,916 --> 02:38:32,958
我有三个变量 
I've got three variables.

3185
02:38:32,958 --> 02:38:34,666
我现在能用这些值做什么呢？
What can I now do with these values?

3186
02:38:34,666 --> 02:38:37,833
那我们就建第三个新金库总数将
Well, let's create a third-- a new vault. Total will

3187
02:38:37,833 --> 02:38:41,416
这个变量的名字等于一个新的保险库 大写V 注意 
be the name of this variable equals a new vault, Capital V, notice.

3188
02:38:41,416 --> 02:38:43,916
现在 让我们传入这三个新变量--
And now, let's pass in those three new variables--

3189
02:38:43,916 --> 02:38:47,000
大帆船 镰刀 和坚果
galleons, sickles, and knuts.

3190
02:38:47,000 --> 02:38:49,625
就这样 让我们打印出整个保险库 
And that's it, and let's print out this total vault.

3191
02:38:49,625 --> 02:38:52,750
所以我们现在应该看到三个拱顶--一个是哈利的 一个是罗恩的 
So we should now see three vaults-- one for Harry, for Ron,

3192
02:38:52,750 --> 02:38:55,208
以及两者的结合 
and the combination-- the addition of the two.

3193
02:38:55,208 --> 02:38:58,875
让我继续搜索vault.py的Python 然后我们就得到了它 
Let me go ahead and rerun Python of vault.py, and there we have it.

3194
02:38:58,875 --> 02:39:04,875
100 50 25和25 50和100 现在通过加法合并 
What was 100, 50, 25 and 25, 50, and 100, combined through addition now,

3195
02:39:04,875 --> 02:39:08,250
是125 100 125
is 125, 100, 125.

3196
02:39:08,250 --> 02:39:10,541
所以很简单 使用几周前的技术
So pretty straightforward, using techniques from weeks

3197
02:39:10,541 --> 02:39:14,541
之前 我们只是声明了一些新的变量并做了一些加法 
ago, where we're just declaring a few new variables and doing some addition.

3198
02:39:14,541 --> 02:39:18,208
但如果我能做这样的事不是很酷吗？
But wouldn't it be cool if I could do something like this?

3199
02:39:18,208 --> 02:39:20,541
如果我能以某种方式 
Wouldn't it be cool if I could just somehow,

3200
02:39:20,541 --> 02:39:24,541
而不是手动创建我自己的保险库 在这里做所有这些烦人的数学运算--
not manually create my own vault and do all of this annoying math up here--

3201
02:39:24,541 --> 02:39:30,541
如果我能做波特和韦斯莱 摆脱这里所有的逻辑呢？
what if I could just do potter + weasley and get rid of all of this logic here?

3202
02:39:30,541 --> 02:39:34,750
如果我让操作员超载不是很好吗
Wouldn't it be nice if I overload the operator--

3203
02:39:34,750 --> 02:39:37,666
我们知道加号 就像str一样 
we know as plus, just like str does, just

3204
02:39:37,666 --> 02:39:42,041
就像list一样--允许我把两个保险库加在一起
like list does-- to allow me to add two vaults together

3205
02:39:42,041 --> 02:39:43,875
在左边和右边 
on the left and the right.

3206
02:39:43,875 --> 02:39:48,250
在Python中 通过运算符重载 
Well, it turns out in Python and through operator overloading,

3207
02:39:48,250 --> 02:39:50,250
有一种方法可以做到这一点 
there is a way to do just this.

3208
02:39:50,250 --> 02:39:52,708
如果你查阅文档 
If you consult the documentation, there's

3209
02:39:52,708 --> 02:39:56,750
这个方法和其他许多随类而来的特殊方法 
this and so many other special methods that come with classes.

3210
02:39:56,750 --> 02:39:59,916
第三个是这个
The third one we'll see here is this one here--

3211
02:39:59,916 --> 02:40:03,291
__add__.
__add__.

3212
02:40:03,291 --> 02:40:05,458
你会发现它被描述得很一般
And you'll see that it very generically is described

3213
02:40:05,458 --> 02:40:09,333
适用于任何对象 无论是Vault还是String
in the documentation is working for any object, be it a vault or str

3214
02:40:09,333 --> 02:40:10,791
或者是一份名单或者别的什么
or a list or something else.

3215
02:40:10,791 --> 02:40:13,458
按照惯例 第一个参数是self 
By convention, it's going to take a first argument called self,

3216
02:40:13,458 --> 02:40:17,083
然后它会用到另一个参数 按照惯例 叫做other 
and then it's going to take some other argument, by convention, called other.

3217
02:40:17,083 --> 02:40:20,083
self实际上指的是
self, in effect, is going to be referring to whatever

3218
02:40:20,083 --> 02:40:22,250
对象位于加号的左侧 
object is on the left of a plus sign.

3219
02:40:22,250 --> 02:40:24,166
另一个是指
other is going to be referring to whatever

3220
02:40:24,166 --> 02:40:26,291
在加号的右边
is on the right-hand side of a plus sign,

3221
02:40:26,291 --> 02:40:30,333
从而给了我们一种用代码描述操作数的方法
thereby giving us a way of describing, in code, the operand

3222
02:40:30,333 --> 02:40:35,416
操作数在运算符的左边 操作数在运算符的右边 加上 介于两者之间 
on the left and the operand on the right of the operator, plus, in between.

3223
02:40:35,416 --> 02:40:37,958
也就是说 如果我回到VS Code 
That is to say, if I go back to VS Code here,

3224
02:40:37,958 --> 02:40:42,083
我想做的是为这个项目提供支持 
what I'm trying to do is implement support for this.

3225
02:40:42,083 --> 02:40:45,041
好吧 让我试试 暂时不写其他代码--
Well, let me try, without writing any other code just yet--

3226
02:40:45,041 --> 02:40:47,541
vault.py的Python 输入--
Python of vault.py, Enter--

3227
02:40:47,541 --> 02:40:53,541
TypeError：+：'Vault'和'vault'不支持的操作数类型 '
TypeError: unsupported operand type(s) for +: 'Vault' and 'vault.'

3228
02:40:53,541 --> 02:40:56,750
也就是说 Python此时不知道
That is to say Python, at this moment, does not know what

3229
02:40:56,750 --> 02:40:59,083
就是把两个拱顶加在一起 
it means to add two vaults together.

3230
02:40:59,083 --> 02:41:00,500
你和我可能有一种直觉 
You and I might have an instinct.

3231
02:41:00,500 --> 02:41:03,958
可能想把加隆镰刀和坚果结合起来
Probably want to combine the galleons and the sickles and the knuts

3232
02:41:03,958 --> 02:41:04,791
分别
respectively.

3233
02:41:04,791 --> 02:41:05,958
Python不知道这一点 
Python doesn't know that.

3234
02:41:05,958 --> 02:41:08,291
它只知道你有一个名为Vault的新类 
It just knows that you have a new class called Vault.

3235
02:41:08,291 --> 02:41:10,250
让我们来教Python如何做到这一点 
But let's teach Python to do this.

3236
02:41:10,250 --> 02:41:12,166
我来清空终端窗口 
Let me clear my terminal window.

3237
02:41:12,166 --> 02:41:15,208
让我回到这个类本身 在那里 目前 
Let me scroll back up to the class itself, where, at the moment,

3238
02:41:15,208 --> 02:41:18,250
我只有两个特殊的方法-- init和str 
I only have two special methods-- init and str.

3239
02:41:18,250 --> 02:41:20,458
但让我们加上第三个 
But let's add this third.

3240
02:41:20,458 --> 02:41:26,625
让我在这里进入类并定义__add__ 然后指定它的第一个
Let me go into the class here and define __add__ and then specify its first

3241
02:41:26,625 --> 02:41:30,791
参数作为self 然后为这个特定的
parameter as self, as before, and then a second parameter for this particular

3242
02:41:30,791 --> 02:41:32,583
方法调用 按照约定 其他 
method called, by convention, other.

3243
02:41:32,583 --> 02:41:34,833
现在 像往常一样 我可以给这些参数取任何名字
Now, as always, I could name those parameters anything

3244
02:41:34,833 --> 02:41:37,000
我也想 但我还是按惯例来吧 
I want, but I'm going to stick with convention here.

3245
02:41:37,000 --> 02:41:39,041
现在 在这个方法中 我是不是
And now, inside of this method, am I going

3246
02:41:39,041 --> 02:41:42,375
把两个保险库里的东西加在一起
to have to now add together the contents of two vaults?

3247
02:41:42,375 --> 02:41:43,333
哪两个金库？
Well, what two vaults?

3248
02:41:43,333 --> 02:41:46,291
好吧 如果我们向下滚动到我们手头的目标 当然 
Well, if we scroll down to our goal at hand, the goal, of course,

3249
02:41:46,291 --> 02:41:48,583
就是加上这个保险库和另一个保险库 波特
is to add this vault plus this other vault-- potter

3250
02:41:48,583 --> 02:41:50,208
还有韦斯莱
plus weasley, respectively.

3251
02:41:50,208 --> 02:41:53,958
在Python中 当你重载一个运算符 
Well, it turns out, in Python, that, when you do overload an operator like

3252
02:41:53,958 --> 02:41:56,291
另外 自动发生的事情 
plus, what's going to happen automatically,

3253
02:41:56,291 --> 02:42:01,666
一旦Python看到这个 它会调用__add__方法 
as soon as Python sees that, is it's going to call that __add__ method,

3254
02:42:01,666 --> 02:42:04,041
它会传递到论证中 
and it's going to pass into it to arguments--

3255
02:42:04,041 --> 02:42:07,333
不管左边的操作数是什么--在这个例子中是potter--
whatever the operand is on the left-- potter, in this case--

3256
02:42:07,333 --> 02:42:10,666
以及右边的操作数--这里是韦斯莱 
and whatever the operand is on the right-- weasley, in this case.

3257
02:42:10,666 --> 02:42:15,500
而这些价值将分别作为自我和他人传递进来 
And those values are going to get passed in as self and other, respectively.

3258
02:42:15,500 --> 02:42:18,375
这意味着我们可以在这里访问他们的内容
What that means is that we can access their contents up here

3259
02:42:18,375 --> 02:42:20,458
在我们的Add实现中 如下所示 
in our implementation of add as follows.

3260
02:42:20,458 --> 02:42:24,125
让我们继续定义一个名为Galleon的局部变量 并将
Let me go ahead and define a local variable called galleons and set that

3261
02:42:24,125 --> 02:42:27,500
例如 等于自身大帆船的和--
equal to, for instance, the sum of self.galleons--

3262
02:42:27,500 --> 02:42:30,125
不管本案中波特的保险库里有什么 
whatever's in Potter's vault in this case,

3263
02:42:30,125 --> 02:42:33,041
再加上本案中韦斯利金库里的任何东西
plus whatever is in Wesley's vault in this case, which

3264
02:42:33,041 --> 02:42:35,000
会是另一艘大帆船 
would be other.galleons.

3265
02:42:35,000 --> 02:42:36,708
让我对镰刀做同样的事情 
Let me do the same for sickles.

3266
02:42:36,708 --> 02:42:40,125
自我 镰刀+其他 镰刀 
self.sickles + other.sickles.

3267
02:42:40,125 --> 02:42:41,958
最后 让我为克努茨做这件事 
And let me lastly do that for knuts.

3268
02:42:41,958 --> 02:42:45,791
所以自己人+其他人 
So self.knuts + other.knuts.

3269
02:42:45,791 --> 02:42:47,625
但归根结底 我需要
But at the end of the day, I'm going to need

3270
02:42:47,625 --> 02:42:51,500
返回一个全新的更大的保险库 其中包含所有这些内容
to return a brand new bigger vault that contains all of those contents

3271
02:42:51,500 --> 02:42:52,250
在一起 
together.

3272
02:42:52,250 --> 02:42:56,791
如果我们最终想要将更大的保险库赋给一个像Total这样的变量
And if we ultimately want to assign that bigger vault to a variable like total

3273
02:42:56,791 --> 02:43:01,083
在这里 在左边 我们最好从这个Add方法返回一个值 
here, on the left, we'd better return a value from this add method.

3274
02:43:01,083 --> 02:43:04,791
所以我要继续前进 给自己一个全新的跳马 就像回到
So I'm going to go ahead and give myself a brand new vault, as by returning

3275
02:43:04,791 --> 02:43:08,916
Capital Vault 当然 它将调用我的存储库函数
capital Vault, which of course, is going to call my vault function into which

3276
02:43:08,916 --> 02:43:11,750
我现在可以传递其中一些初始化参数 
I can now pass some of those initialization arguments.

3277
02:43:11,750 --> 02:43:13,625
那么 有多少大帆船、镰刀和坚果
Well, how many galleon, sickles, and knuts do

3278
02:43:13,625 --> 02:43:15,541
我想让这个全新的保险库容纳？
I want this brand new vault to contain?

3279
02:43:15,541 --> 02:43:19,666
我希望它能装这么多大帆船这么多把镰刀 
Well, I want it to contain this many galleons this many sickles,

3280
02:43:19,666 --> 02:43:21,291
还有这么多坚果 
and this many knuts.

3281
02:43:21,291 --> 02:43:23,708
所以最终 我们在这个实现中所做的
So ultimately, what we're doing in this implementation

3282
02:43:23,708 --> 02:43:27,791
加法是把那些大帆船、镰刀和坚果加在一起 通过
of add is adding together those galleons, sickles, and knuts, passing

3283
02:43:27,791 --> 02:43:30,958
这样我们就能得到一个全新的更大的保险库 
them to the vault function so that we get a brand new bigger vault,

3284
02:43:30,958 --> 02:43:33,833
并将其全部归还 
and return that altogether.

3285
02:43:33,833 --> 02:43:36,041
所以现在我定义了这个新的特殊方法
So now I've defined this new special method

3286
02:43:36,041 --> 02:43:42,250
名为Add的应用程序现在应该只对两个保险库执行plus操作 
called add that should now just make plus work for two vaults.

3287
02:43:42,250 --> 02:43:42,833
让我们看看 
Let's see.

3288
02:43:42,833 --> 02:43:46,750
让我运行到我的终端窗口 即Vault.py的Python 然后按Enter键 
Let me run down to my terminal window, Python of vault.py and hit Enter.

3289
02:43:46,750 --> 02:43:51,958
好了 现在我们实现了一个重载运算符 
And voila, and now we've implemented an overloaded operator, plus,

3290
02:43:51,958 --> 02:43:54,166
去做你我作为人类所希望的事情
to do what you and I as humans would hope

3291
02:43:54,166 --> 02:43:56,458
将两个存储库添加到一起时会出现这种情况 
would be the case when you add two vaults together.

3292
02:43:56,458 --> 02:43:58,916
但我现在已经更具体地编写了代码
But I've now written the code more specifically

3293
02:43:58,916 --> 02:44:04,500
教Python把两个保险库加在一起的具体含义 
to teach Python what it means concretely to add two vaults together.

3294
02:44:04,500 --> 02:44:06,708
它的代码非常相似 
And it's with very similar code in effect,

3295
02:44:06,708 --> 02:44:09,541
Python在后台对两个字符串做这样的操作 
underneath the hood, that Python is doing this for two strings,

3296
02:44:09,541 --> 02:44:13,875
将它们连接在一起 将两个列表连接成一个新的列表 
to concatenate them together, to joining two lists into a new list with list,

3297
02:44:13,875 --> 02:44:16,875
还有很多其他的课程
and so many other classes as well.

3298
02:44:16,875 --> 02:44:22,166
关于运算符重载或者这个例子还有什么问题吗？
Any questions now on operator overloading or this example here.

3299
02:44:22,166 --> 02:44:23,875
观众：你会如何创作
AUDIENCE: How would you go about creating

3300
02:44:23,875 --> 02:44:31,833
为两个单独的班级添加学生和Vault的功能？
a function for adding a student and a vault for two separate classes?

3301
02:44:31,833 --> 02:44:33,250
有可能吗？
Would that be possible?

3302
02:44:33,250 --> 02:44:35,125
大卫·J·马兰：让我看看这里发生了什么 
DAVID J. MALAN: Let me see what happens here.

3303
02:44:35,125 --> 02:44:36,041
我也不知道 
I don't know offhand.

3304
02:44:36,041 --> 02:44:36,875
开始吧
Let's do this.

3305
02:44:36,875 --> 02:44:38,541
让我们创建一个str 看看会发生什么 
Let's create a str and see what happens.

3306
02:44:38,541 --> 02:44:40,875
如果我加上波特再加一个
If I add Potter plus a str--

3307
02:44:40,875 --> 02:44:41,500
String对象 
str object.

3308
02:44:41,500 --> 02:44:42,666
是啊 所以它会工作 
Yeah, so it would work.

3309
02:44:42,666 --> 02:44:44,708
我只是在想办法 埃里克 
I'm just figuring this out as I go here, Eric.

3310
02:44:44,708 --> 02:44:47,000
所以说清楚 我只是
So just to be clear, what I did was I just

3311
02:44:47,000 --> 02:44:48,958
把韦斯莱改成了str 只是想看看
changed weasley to str just to see what would

3312
02:44:48,958 --> 02:44:54,166
当我加上一个拱顶和一个str的时候 理论上是可行的 
happen when I add a vault plus a str, and it will work, theoretically.

3313
02:44:54,166 --> 02:44:54,791
为什么要这样？
Why?

3314
02:44:54,791 --> 02:45:01,541
因为只要左边的值类型实现了add方法 
Because so long as the type of value on the left has an add method implemented,

3315
02:45:01,541 --> 02:45:04,291
其他可以是任何你想要的类型 
other can be any type that you want.

3316
02:45:04,291 --> 02:45:06,583
你只需要决定并编码它是什么
You just have to decide and code what it's

3317
02:45:06,583 --> 02:45:09,625
从概念上讲 这意味着增加一个保险库和一个字符串 
going to mean conceptually to add a vault plus a string, which,

3318
02:45:09,625 --> 02:45:13,458
在这种情况下 可能没有任何意义 但这是可能的 
in this case, probably doesn't make any sense at all, but it's possible.

3319
02:45:13,458 --> 02:45:15,208
它将是左边的操作数 
It's going to be the operand on the left.

3320
02:45:15,208 --> 02:45:16,250
我在推断 
And I'm inferring that.

3321
02:45:16,250 --> 02:45:17,958
我刚才不知道答案 
I did not know the answer a moment ago.

3322
02:45:17,958 --> 02:45:22,916
我这样推断是因为我得到的是第11行的属性错误
I'm inferring that because what I got was an attribute error here on line 11

3323
02:45:22,916 --> 02:45:27,125
因为巨蟒不喜欢这样其他的 大帆船没有工作 
because Python did not like this. other.galleons didn't work,

3324
02:45:27,125 --> 02:45:29,666
但我可以想办法解决
but I could make it work by figuring something out.

3325
02:45:29,666 --> 02:45:30,791
问得好
Really good question.

3326
02:45:30,791 --> 02:45:32,291
我自己都不知道 
Didn't know that one myself.

3327
02:45:32,291 --> 02:45:35,916
关于运算符重载的其他问题？
Other questions on operator overloading?

3328
02:45:35,916 --> 02:45:38,291
问：你能在Python中定义新的操作符吗？
AUDIENCE: Can you define new operators in Python?

3329
02:45:38,291 --> 02:45:39,666
大卫·J·马兰：我不这么认为 
DAVID J. MALAN: I don't think so.

3330
02:45:39,666 --> 02:45:44,583
有一个很长但很精确的操作符列表可以重载 
There is a very long but precise list of operators that you can overload.

3331
02:45:44,583 --> 02:45:48,500
我不相信你可以任意分配字符
I do not believe you can assign arbitrary characters

3332
02:45:48,500 --> 02:45:50,541
Python中的操作符
to be operators in Python.

3333
02:45:50,541 --> 02:45:52,458
让我在聊天中听从卡特的意见--
Let me defer to Carter in the chat to--

3334
02:45:52,458 --> 02:45:55,166
好的 我看到我的两个同事在说 不 不可能 
OK, I'm seeing two of my colleagues are saying, no, not possible.

3335
02:45:55,166 --> 02:45:57,166
因此 我将按照我的第一直觉 不 
So I'm going to go with my first instinct, no.

3336
02:45:57,166 --> 02:45:58,583
不然的话 那就太酷了 
Otherwise, that'd be kind of cool.

3337
02:45:58,583 --> 02:46:00,875
你可以让表情符号做任何你想做的事情 
You could make emoji do whatever you want to.

3338
02:46:00,875 --> 02:46:04,000
最后一个关于操作符重载的问题如何？
How about one final question on operator overloading?

3339
02:46:04,000 --> 02:46:08,416
观众：这是你唯一能做的手术吗？
AUDIENCE: Is that the only operation you can do as far as--

3340
02:46:08,416 --> 02:46:10,041
你也能做减法吗？
can you do a subtraction as well?

3341
02:46:10,041 --> 02:46:11,041
大卫·J·马兰：你可以的 
DAVID J. MALAN: You can.

3342
02:46:11,041 --> 02:46:13,583
你可以做这么多别人让我做的事 
You can do so many others let me.

3343
02:46:13,583 --> 02:46:16,583
如果 卡特 你不介意在这里调出这个网址--
If, Carter, you don't mind pulling up this URL here--

3344
02:46:16,583 --> 02:46:19,750
所以这里的链接--特殊方法名称和今天的幻灯片 
so this link here-- special method names and today's slides,

3345
02:46:19,750 --> 02:46:23,208
您将看到可以重载的所有操作符的长长列表 
you'll see a long list of all of the operators that you can overload.

3346
02:46:23,208 --> 02:46:26,583
你可以做小于、等于、加等于、减等于 
You can do less than, equals than, plus equals, minus equals.

3347
02:46:26,583 --> 02:46:29,291
你看到我在屏幕上输入的几乎所有符号
Pretty much any symbol you've seen me type on the screen

3348
02:46:29,291 --> 02:46:33,166
可以在类的上下文中重载 
can be overloaded in the context of classes.

3349
02:46:33,166 --> 02:46:35,541
所以 即使今天 我们完全专注于
So even though, today, we focused entirely

3350
02:46:35,541 --> 02:46:38,625
在面向对象编程方面 这是我们一直在使用的一种技术 
on object-oriented programming, this is a technique that we've been using,

3351
02:46:38,625 --> 02:46:41,791
真的 从上课的第一周开始 因为那些INT 
really, since the first week of the class because those ints,

3352
02:46:41,791 --> 02:46:45,291
那些STR 那些花车 那些列表 那些词典 
those strs, those floats, those lists, those dictionaries,

3353
02:46:45,291 --> 02:46:49,083
而在这段时间里 引擎盖下已经有了更多的东西--课程
and so much more were already underneath the hood this whole time-- classes

3354
02:46:49,083 --> 02:46:50,125
以及它的宗旨 
and objects thereof.

3355
02:46:50,125 --> 02:46:52,041
但你现在 作为一名程序员 有能力
But you now, as a programmer, have the ability

3356
02:46:52,041 --> 02:46:55,583
要使用自己的实例或类变量创建自己的类 
to create your own classes with your own instance or class variables,

3357
02:46:55,583 --> 02:46:58,875
使用您自己的实例或类方法 使用您自己的属性 
with your own instance or class methods, with your own properties,

3358
02:46:58,875 --> 02:47:01,958
甚至可以使用您自己为操作员定制的行为 
and even with your own custom behavior for operators.

3359
02:47:01,958 --> 02:47:04,625
所以最终 你完全可以继续
So ultimately, you can absolutely continue

3360
02:47:04,625 --> 02:47:09,291
使用这些简单的元组或列表或那些词典或其他结构
using those simple tuples or lists or those dictionaries or other structures

3361
02:47:09,291 --> 02:47:09,791
也是 
as well.

3362
02:47:09,791 --> 02:47:13,416
但面向对象编程 以及随之而来的类和现在的这些对象
But object-oriented programming, and with it, classes and now these objects

3363
02:47:13,416 --> 02:47:15,208
只是您工具包中的另一个工具 
is just another tool in your toolkit.

3364
02:47:15,208 --> 02:47:18,041
大胆地说 随着您的代码变得更加复杂
And daresay, as your code gets more sophisticated

3365
02:47:18,041 --> 02:47:20,041
你的问题变得更大 你会发现
and your problems get bigger, you'll find

3366
02:47:20,041 --> 02:47:23,708
能够对这些现实世界甚至幻想世界的实体进行建模
that being able to model these real world or even fantasy world entities

3367
02:47:23,708 --> 02:47:26,458
使用类以及相关数据和功能
with classes and related data and functionality

3368
02:47:26,458 --> 02:47:30,583
最终将允许您定义不仅正确而且永远正确的代码
will ultimately just allow you to define code that's not just correct but ever

3369
02:47:30,583 --> 02:47:32,833
也是精心设计的 
well-designed as well.

3370
02:47:32,833 --> 02:47:35,541
这是CS50 
This was CS50.

