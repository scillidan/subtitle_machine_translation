1
00:00:25,250 --> 00:00:28,400
David Malan：这是CS50的S介绍使用Python语言编程 

2
00:00:28,400 --> 00:00:29,480
我叫大卫·马兰 

3
00:00:29,480 --> 00:00:31,940
本周是我们进行单元测试的一周 

4
00:00:31,940 --> 00:00:34,070
到目前为止 我们一直在编写大量代码 

5
00:00:34,070 --> 00:00:37,207
您可能一直在通过运行您的程序来测试代码 

6
00:00:37,207 --> 00:00:40,040
并传入一些样本输入 然后再次运行它 然后传递

7
00:00:40,040 --> 00:00:42,530
在一些样本输入中 或者您可能一直在等待

8
00:00:42,530 --> 00:00:44,180
让我们测试您的代码 

9
00:00:44,180 --> 00:00:47,270
但实际上更好的做法是尽早养成这个习惯

10
00:00:47,270 --> 00:00:51,877
而不是稍后使用您自己的代码测试您自己的代码 

11
00:00:51,877 --> 00:00:53,960
事实上 无论你是在写一个个人项目

12
00:00:53,960 --> 00:00:57,065
或者在工业中工作 如今很常见的不仅仅是编写代码

13
00:00:57,065 --> 00:00:58,940
要解决你想要解决的问题 

14
00:00:58,940 --> 00:01:03,260
还可以编写一些额外的代码来测试您编写的代码 

15
00:01:03,260 --> 00:01:06,590
这就是我们今天要关注的 编写我们自己的测试

16
00:01:06,590 --> 00:01:08,900
更加自信 更加确定 

17
00:01:08,900 --> 00:01:12,930
我们一直试图解决的问题实际上得到了正确的解决 

18
00:01:12,930 --> 00:01:17,720
现在让我们回到几周前我们编写的一个程序 

19
00:01:17,720 --> 00:01:20,540
即计算数字 

20
00:01:20,540 --> 00:01:23,450
具体地说 我们没有使用这个计算器

21
00:01:23,450 --> 00:01:27,050
关于试图计算一个数字的幂 比如x的平方

22
00:01:27,050 --> 00:01:31,250
或者其中x可以是2、3或其他一些数字 

23
00:01:31,250 --> 00:01:34,850
让我进入终端窗口 继续恢复该文件

24
00:01:34,850 --> 00:01:38,750
在这里再次运行culator.py的代码 

25
00:01:38,750 --> 00:01:42,410
让我继续 从很久以前我们停止的地方开始

26
00:01:42,410 --> 00:01:44,367
通过在这里定义一个主函数 

27
00:01:44,367 --> 00:01:46,700
然后在我的主要功能中 我做了这样的事情 

28
00:01:46,700 --> 00:01:49,550
我说 x等于输入的int 

29
00:01:49,550 --> 00:01:52,730
我问用户 x是什么 问号？

30
00:01:52,730 --> 00:01:55,880
然后我立即开始打印 打印出了这样的东西 

31
00:01:55,880 --> 00:02:00,020
X的平方是 然后我作为第二个参数传入

32
00:02:00,020 --> 00:02:02,450
打印调用名为的函数的结果

33
00:02:02,450 --> 00:02:04,790
平方传递那个值 x 

34
00:02:04,790 --> 00:02:08,639
当然 现在我还没有实现Square函数 

35
00:02:08,639 --> 00:02:10,110
所以让我们也来定义一下 

36
00:02:10,110 --> 00:02:12,560
让我沿着几行来定义正方形 

37
00:02:12,560 --> 00:02:15,938
它需要一个参数调用 这个参数在当时

38
00:02:15,938 --> 00:02:18,980
我给n打了个号码 所以我会再做一次 尽管从技术上讲我可以

39
00:02:18,980 --> 00:02:21,140
为该变量选择任意名称 

40
00:02:21,140 --> 00:02:22,730
我记得 就是这样做的 

41
00:02:22,730 --> 00:02:25,190
我返回了n乘以n 

42
00:02:25,190 --> 00:02:27,560
有多种方法可以做到这一点 

43
00:02:27,560 --> 00:02:30,120
对一个数字进行平方就是将其自身相乘 

44
00:02:30,120 --> 00:02:32,150
所以我也可以在这里使用其他语法 但是这个

45
00:02:32,150 --> 00:02:34,130
是我们最终决定的 然后

46
00:02:34,130 --> 00:02:37,430
回想一下 我最终调用了Main 以便启动

47
00:02:37,430 --> 00:02:39,090
运行该程序的过程 

48
00:02:39,090 --> 00:02:41,900
因此 就像手动测试一样 让我继续运行

49
00:02:41,900 --> 00:02:44,750
Python.py并按Enter键 

50
00:02:44,750 --> 00:02:45,530
X是什么？

51
00:02:45,530 --> 00:02:47,180
让我们从2开始 

52
00:02:47,180 --> 00:02:48,530
X的平方是4 

53
00:02:48,530 --> 00:02:49,595
我想这是对的 

54
00:02:49,595 --> 00:02:51,470
所以让我们再运行一次 只是为了更好地衡量 

55
00:02:51,470 --> 00:02:55,880
Py的Python 这一次让我们输入x的3 

56
00:02:55,880 --> 00:02:57,110
X的平方是9 

57
00:02:57,110 --> 00:02:58,370
我认为这是正确的 

58
00:02:58,370 --> 00:03:00,412
在这一点上我可能感觉很好 

59
00:03:00,412 --> 00:03:02,450
然后我去把我的代码提交给一个课程 

60
00:03:02,450 --> 00:03:04,580
或者我把它发布到互联网上 供其他人使用 

61
00:03:04,580 --> 00:03:07,550
但我还没有真正系统地测试过这段代码 

62
00:03:07,550 --> 00:03:10,280
而且情况并不一定是完全有效的 

63
00:03:10,280 --> 00:03:13,100
事实上 我还没有真正考虑过一些角落案例 

64
00:03:13,100 --> 00:03:17,570
我用了一些非常明显的数字 比如2和3 但0呢？

65
00:03:17,570 --> 00:03:18,930
那么负数呢？

66
00:03:18,930 --> 00:03:20,990
那么任何数量的其他无穷大的数字呢？

67
00:03:20,990 --> 00:03:23,090
我们不会测试无限数量的输入

68
00:03:23,090 --> 00:03:25,007
对于这一点 因为这个程序永远不会停止 

69
00:03:25,007 --> 00:03:28,610
但我们最终应该测试一些有代表性的投入 

70
00:03:28,610 --> 00:03:31,970
但在此之前 让我们养成一个习惯 确保

71
00:03:31,970 --> 00:03:33,770
这条主干道并不总是被称为Main 

72
00:03:33,770 --> 00:03:43,910
让我们再一次养成这样的习惯 如果__name__==“__main__” 

73
00:03:43,910 --> 00:03:45,920
只有到那时 我们才能执行Main 

74
00:03:45,920 --> 00:03:48,320
我现在正在积极地做这件事 因为我

75
00:03:48,320 --> 00:03:53,210
我想确保在我导入平方函数时 也许

76
00:03:53,210 --> 00:03:56,930
从另一个库 从另一个文件 将其视为库 

77
00:03:56,930 --> 00:04:00,840
我希望确保main不会被自动调用 

78
00:04:00,840 --> 00:04:03,920
现在我现在想做什么 因为我已经

79
00:04:03,920 --> 00:04:06,320
是否按如下方式修改此程序？

80
00:04:06,320 --> 00:04:09,560
让我们继续编写一个完全不同的程序 它的唯一目的是

81
00:04:09,560 --> 00:04:12,210
现在就是在生活中考验这个程序 

82
00:04:12,210 --> 00:04:15,410
所以我得到了我的实际计算器和计算器.py 

83
00:04:15,410 --> 00:04:18,200
我已经准备好有条件地给Main打电话

84
00:04:18,200 --> 00:04:23,568
这样我就可以安全地将一个或多个内容从此文件导入到另一个文件中 

85
00:04:23,568 --> 00:04:24,860
另一个文件应该是什么？

86
00:04:24,860 --> 00:04:28,340
按照惯例 我将创建一个名为test_的文件 

87
00:04:28,340 --> 00:04:31,580
然后因为我测试的是这个计算器本身 

88
00:04:31,580 --> 00:04:34,910
让我们将该文件命名为test_culator.py 

89
00:04:34,910 --> 00:04:36,920
这将给我一个新的标签 在其中我

90
00:04:36,920 --> 00:04:39,080
我可以写一个全新的程序 它的人生目标

91
00:04:39,080 --> 00:04:41,330
现在专门用来测试这个程序 

92
00:04:41,330 --> 00:04:43,850
但实际上这是该程序的特定功能 

93
00:04:43,850 --> 00:04:46,700
该程序内置了Square函数 

94
00:04:46,700 --> 00:04:49,730
让我们专注于测试该功能 

95
00:04:49,730 --> 00:04:52,760
那么 我如何访问该程序中的功能呢？

96
00:04:52,760 --> 00:04:55,610
回想一下 我可以从另一个文件导入函数

97
00:04:55,610 --> 00:04:58,480
就好像它是我自己的一个库 一个所谓的模块 

98
00:04:58,480 --> 00:04:59,480
所以我要这么做 

99
00:04:59,480 --> 00:05:03,170
从计算器中导入正方形 

100
00:05:03,170 --> 00:05:05,600
我可以继续下去 只需导入Square本身 

101
00:05:05,600 --> 00:05:09,440
但是我必须在我使用的Square recall前面加上前缀

102
00:05:09,440 --> 00:05:12,440
通过说计算器到处都是点 它只是更干净一点

103
00:05:12,440 --> 00:05:14,060
来只导入一个函数 

104
00:05:14,060 --> 00:05:16,440
现在让我继续做这件事 

105
00:05:16,440 --> 00:05:19,910
让我们继续定义一个名为test square的函数 

106
00:05:19,910 --> 00:05:21,270
这也是一场大会 

107
00:05:21,270 --> 00:05:25,390
如果您想测试一个名为Square的函数 那么您要测试的函数

108
00:05:25,390 --> 00:05:27,700
应该称为test_square 

109
00:05:27,700 --> 00:05:30,430
或者 您也可以执行Square_test 

110
00:05:30,430 --> 00:05:31,930
我将在这里采用这一惯例 

111
00:05:31,930 --> 00:05:34,270
现在我们可以做什么样的测试呢？

112
00:05:34,270 --> 00:05:38,920
我不喜欢我之前运行的测试 测试x等于2 x等于3 

113
00:05:38,920 --> 00:05:41,745
但每次我之前想测试我的程序时 

114
00:05:41,745 --> 00:05:43,120
我必须手动完成这项工作 

115
00:05:43,120 --> 00:05:44,050
这将会变得单调乏味 

116
00:05:44,050 --> 00:05:45,880
对于其他人来说 测试它并不容易 

117
00:05:45,880 --> 00:05:47,990
如果我真的在现实世界中工作 

118
00:05:47,990 --> 00:05:49,720
如果我能不假思索地

119
00:05:49,720 --> 00:05:54,040
让我的程序通过运行一些自动化进程来一次又一次地进行测试

120
00:05:54,040 --> 00:05:54,910
我自己的代码 

121
00:05:54,910 --> 00:05:58,130
因此 让我们这样做 并最终将人类排除在方程式之外 

122
00:05:58,130 --> 00:06:00,850
那么我该如何开始测试平方函数呢

123
00:06:00,850 --> 00:06:03,670
我现在每一行都导入了什么？

124
00:06:03,670 --> 00:06:05,800
在我的检验平方函数中 为什么不这样做呢？

125
00:06:05,800 --> 00:06:11,198
如果调用2的平方的结果不等于4 

126
00:06:11,198 --> 00:06:13,240
为什么我们不继续打印一条错误消息 

127
00:06:13,240 --> 00:06:17,080
因为我知道在现实世界中 2的平方应该等于4 

128
00:06:17,080 --> 00:06:21,572
因此 如果2的平方不等于4 则我的程序中存在错误 

129
00:06:21,572 --> 00:06:22,780
我的函数中有一个错误 

130
00:06:22,780 --> 00:06:23,780
我犯了个错误 

131
00:06:23,780 --> 00:06:26,655
所以让我继续打印一些类似的东西 这样我或其他人

132
00:06:26,655 --> 00:06:30,050
例如 知道2的平方不是4 

133
00:06:30,050 --> 00:06:31,640
这样我就可以打印出这里的任何东西 

134
00:06:31,640 --> 00:06:33,163
也许下一次我应该做什么测试？

135
00:06:33,163 --> 00:06:34,330
让我们做不止一次测试 

136
00:06:34,330 --> 00:06:40,120
比方说 如果3的平方不等于3的平方9 那么我们继续

137
00:06:40,120 --> 00:06:43,390
打印出3的平方不是9 

138
00:06:43,390 --> 00:06:46,240
所以我没有比之前做更多的测试 

139
00:06:46,240 --> 00:06:52,390
但我已经将x等于2和x等于3这两个测试放入了我自己的代码中

140
00:06:52,390 --> 00:06:55,910
现在 我可以自动运行这些测试 如果您愿意的话 

141
00:06:55,910 --> 00:06:59,890
现在 仅仅定义一个称为检验平方的函数是不够的 

142
00:06:59,890 --> 00:07:02,830
实际上 如果我想运行这个函数 需要以某种方式调用它 

143
00:07:02,830 --> 00:07:06,250
我们这样做的惯例是一如既往的 

144
00:07:06,250 --> 00:07:08,530
在这个文件中 也让我定义Main 

145
00:07:08,530 --> 00:07:12,670
而Main在生活中的唯一目标将是测试Square 

146
00:07:12,670 --> 00:07:15,310
现在 和以前一样 在这个文件的底部 

147
00:07:15,310 --> 00:07:23,860
让我继续采用我的惯例：if__name__==“__main__” 

148
00:07:23,860 --> 00:07:26,170
然后继续呼叫Main 

149
00:07:26,170 --> 00:07:27,890
因此 这些都只是例行公事 

150
00:07:27,890 --> 00:07:29,890
我们以前见过这种情况 定义了一个主函数

151
00:07:29,890 --> 00:07:32,073
并调用一个函数来启动某个进程 

152
00:07:32,073 --> 00:07:34,240
现在在文件的底部添加条件

153
00:07:34,240 --> 00:07:37,900
以确保我只是有条件地调用main 以防我导入

154
00:07:37,900 --> 00:07:40,220
其他地方的这份文件里有没有发现 

155
00:07:40,220 --> 00:07:41,050
让我们来看看 

156
00:07:41,050 --> 00:07:43,030
现在让我们继续测试我的代码 

157
00:07:43,030 --> 00:07:47,800
让我继续运行test_culator Python并按Enter键 

158
00:07:47,800 --> 00:07:49,780
而且什么都不会产生 

159
00:07:49,780 --> 00:07:50,920
什么都没有输出 

160
00:07:50,920 --> 00:07:53,110
但我觉得这没问题 

161
00:07:53,110 --> 00:07:56,800
我认为没有输出是好的 因为看看我的测试平方函数 

162
00:07:56,800 --> 00:08:00,430
如果一切顺利 我不会打印任何东西 

163
00:08:00,430 --> 00:08:03,197
所以让我们回到我的计算器来演示一下 

164
00:08:03,197 --> 00:08:04,030
让我来打破它 

165
00:08:04,030 --> 00:08:05,180
让我来介绍一个错误 

166
00:08:05,180 --> 00:08:07,180
也许我第一次都没答对 

167
00:08:07,180 --> 00:08:09,010
也许我的代码最初是这样的 

168
00:08:09,010 --> 00:08:10,000
我当时没在想 

169
00:08:10,000 --> 00:08:11,200
我忘了带我的方格 

170
00:08:11,200 --> 00:08:15,160
所以我认为一个数字的平方是n加n 

171
00:08:15,160 --> 00:08:18,130
而不是n乘以n 所以犯了一个合理的错误 

172
00:08:18,130 --> 00:08:19,390
也许是算术上的 

173
00:08:19,390 --> 00:08:21,340
现在让我回到我的测试计算器 

174
00:08:21,340 --> 00:08:24,010
我不会改变它 但我会重新运行它 

175
00:08:24,010 --> 00:08:26,410
测试计算器.py的Python 

176
00:08:26,410 --> 00:08:29,170
我要在这里祈祷 但无缘无故 我

177
00:08:29,170 --> 00:08:33,309
马上就会发现3的平方不是9 

178
00:08:33,309 --> 00:08:35,020
现在是什么事？

179
00:08:35,020 --> 00:08:39,400
让我们看看 当你的测试失败时 我们怎么能指出哪里出了问题？

180
00:08:39,400 --> 00:08:42,520
有点有趣的是 我完全破坏了我的平方函数 

181
00:08:42,520 --> 00:08:45,460
然而 这些测试中只有一项失败了 

182
00:08:45,460 --> 00:08:49,672
这个测试 第9行和第10行 看起来没问题 

183
00:08:49,672 --> 00:08:51,130
因为我看不到这样的结果 

184
00:08:51,130 --> 00:08:54,310
但是当然这两条线 这个测试 

185
00:08:54,310 --> 00:08:57,640
失败了 因为当我使用加号时 3的平方不是9 

186
00:08:57,640 --> 00:09:03,880
所以在这里澄清一下 为什么我的功能只有部分损坏 

187
00:09:03,880 --> 00:09:04,930
我只想说清楚 

188
00:09:04,930 --> 00:09:07,990
为什么我只看到我的错误 而不是两个 

189
00:09:07,990 --> 00:09:11,785
即使平方函数现在在数学上被破坏了？

190
00:09:11,785 --> 00:09:13,200
演讲者1：因为2加2等于4 

191
00:09:13,200 --> 00:09:14,950
大卫·马兰：是的 就这么简单 

192
00:09:14,950 --> 00:09:18,313
我只是很幸运 2加2等于2乘以2 

193
00:09:18,313 --> 00:09:20,230
所以这是一个角落里的案例 而这个

194
00:09:20,230 --> 00:09:22,480
这就是为什么养成不只测试一件事的习惯是好的 

195
00:09:22,480 --> 00:09:25,610
但测试几个 并确保您的基础 可以这么说 

196
00:09:25,610 --> 00:09:27,010
所以我在这里很幸运 

197
00:09:27,010 --> 00:09:29,470
这就解释了为什么我只看到了I错误 

198
00:09:29,470 --> 00:09:32,800
尽管函数本身是有缺陷的 但让我建议

199
00:09:32,800 --> 00:09:35,050
另一种我们可以做的方式 因为老实说 

200
00:09:35,050 --> 00:09:39,280
如果我从这个简单的例子推断 运行的不仅仅是两个测试

201
00:09:39,280 --> 00:09:45,010
但是3个、4个、10个或20个测试 你可以想象 天哪 

202
00:09:45,010 --> 00:09:48,460
代码将变得比函数本身复杂得多 

203
00:09:48,460 --> 00:09:53,290
看 在culator.py中 有问题的函数已经有两行长了 

204
00:09:53,290 --> 00:09:58,330
然而 在TEST_COMPUATOR中 有问题的代码有五行长 

205
00:09:58,330 --> 00:10:01,900
我编写了比实际编写的原始代码更多的代码来测试我的代码 

206
00:10:01,900 --> 00:10:05,890
因此 我们在测试代码时可以编写的代码行越少 

207
00:10:05,890 --> 00:10:08,118
我觉得你和我越有可能这么做 

208
00:10:08,118 --> 00:10:09,910
因为从字面上讲 这将是一种

209
00:10:09,910 --> 00:10:12,740
工作量更少 犯错的机会也更少 

210
00:10:12,740 --> 00:10:15,400
那么 我还可以采取什么其他方法呢？

211
00:10:15,400 --> 00:10:19,700
事实证明 在Python中 还有一个我们还没有使用过的关键字 

212
00:10:19,700 --> 00:10:21,640
这就是这里 断言 

213
00:10:21,640 --> 00:10:25,330
Assert是Python和其他一些语言中的关键字

214
00:10:25,330 --> 00:10:28,300
它允许你这样做 就像在英语中 断言

215
00:10:28,300 --> 00:10:31,910
某件事是真的 大胆地宣称某事是真的 

216
00:10:31,910 --> 00:10:34,420
如果是这样的话 什么都不会发生 

217
00:10:34,420 --> 00:10:36,290
屏幕上不会出现任何错误 

218
00:10:36,290 --> 00:10:40,240
但如果你用Python语言断言某件事 而这不是真的 那就是 

219
00:10:40,240 --> 00:10:44,230
您要插入的断言是一个布尔表达式 它是假的 

220
00:10:44,230 --> 00:10:47,930
实际上 您将在屏幕上看到某种错误 

221
00:10:47,930 --> 00:10:50,870
因此 让我们继续尝试这个新关键字 如下所示 

222
00:10:50,870 --> 00:10:52,550
让我在这里回到我的代码 

223
00:10:52,550 --> 00:10:54,880
为了让事情简单一点 让我们

224
00:10:54,880 --> 00:10:58,130
我建议我使用这个新的关键字 如下所示 

225
00:10:58,130 --> 00:11:04,120
让我简单地断言 2的平方应该等于4 

226
00:11:04,120 --> 00:11:05,440
所以我改变了我的逻辑 

227
00:11:05,440 --> 00:11:07,480
而不是检查不等于 我现在是

228
00:11:07,480 --> 00:11:11,260
非常大声地断言它应该等于4 

229
00:11:11,260 --> 00:11:13,810
然后在另一行 让我做另一个测试 

230
00:11:13,810 --> 00:11:17,590
断言3的平方等于9 

231
00:11:17,590 --> 00:11:21,040
就是这样 没有缩进的指纹 

232
00:11:21,040 --> 00:11:24,010
我只想更简单地断言这两个

233
00:11:24,010 --> 00:11:26,080
我想要成真的事情 

234
00:11:26,080 --> 00:11:29,740
现在让我继续 计算器.py仍然是坏的 

235
00:11:29,740 --> 00:11:33,670
我还是不小心用了加号 而不是乘法 

236
00:11:33,670 --> 00:11:37,900
现在让我继续运行测试计算器.py的Python 

237
00:11:37,900 --> 00:11:41,320
像往常一样祈祷 但这一次不会很顺利 

238
00:11:41,320 --> 00:11:44,240
屏幕上似乎出现了一大堆错误 

239
00:11:44,240 --> 00:11:46,600
如果我滚动到这里进行回溯 

240
00:11:46,600 --> 00:11:53,020
我们将看到失败的是这里的这一行 断言Square(3)==9 

241
00:11:53,020 --> 00:11:55,450
不幸的是 当您使用ASSERT关键字时 

242
00:11:55,450 --> 00:11:57,460
它的用户友好性不是很好 

243
00:11:57,460 --> 00:11:59,982
它向您显示所涉及的文件和行号 

244
00:11:59,982 --> 00:12:02,440
但它确实向您显示了失败的特定代码行 

245
00:12:02,440 --> 00:12:04,600
可以说 这一断言失败了 

246
00:12:04,600 --> 00:12:08,560
现在就靠你和我来推断了 等等 

247
00:12:08,560 --> 00:12:11,020
为什么平方根3不等于9？

248
00:12:11,020 --> 00:12:13,187
所以它不是超级用户友好型的 但老实说 它

249
00:12:13,187 --> 00:12:14,770
是我要写的代码的一半 

250
00:12:14,770 --> 00:12:16,990
只有两行 而不是之前的四行 

251
00:12:16,990 --> 00:12:19,450
但请注意下面这一小块残留物 

252
00:12:19,450 --> 00:12:21,070
这是一个断言错误 

253
00:12:21,070 --> 00:12:23,350
我们以前也见过错误 

254
00:12:23,350 --> 00:12:27,460
当我们在代码中犯了其他错误时 我们以前也见过错误 

255
00:12:27,460 --> 00:12:34,010
在过去 我们捕捉这些错误的解决方案是什么？

256
00:12:34,010 --> 00:12:37,610
我们如何捕捉看起来像这样的错误 

257
00:12:37,610 --> 00:12:39,977
即使我们以前没见过这个？

258
00:12:39,977 --> 00:12:41,060
演讲者2：试着排除 

259
00:12:41,060 --> 00:12:44,060
David Malan：是的 在Python中 我们可以使用Try和Except关键字

260
00:12:44,060 --> 00:12:48,180
试着乐观地做某事 除非出了什么差错 

261
00:12:48,180 --> 00:12:49,680
相反 做些其他的事情 

262
00:12:49,680 --> 00:12:53,235
所以这是向前迈出的一步 因为我至少可以捕捉到这个错误 

263
00:12:53,235 --> 00:12:55,610
但这可能会是一种倒退 因为我

264
00:12:55,610 --> 00:12:59,700
我要提前承认 最终要写的是更多的代码 

265
00:12:59,700 --> 00:13:01,050
所以 让我继续试一试 

266
00:13:01,050 --> 00:13:02,850
让我在这里回到我的代码 

267
00:13:02,850 --> 00:13:05,960
与其盲目地断言 不如让

268
00:13:05,960 --> 00:13:10,400
我继续 按照托拉的提议 试着做第一个断言 

269
00:13:10,400 --> 00:13:16,280
除非出现断言错误 就像我们刚才看到的那样 然后继续

270
00:13:16,280 --> 00:13:18,320
并打印出更方便用户的内容

271
00:13:18,320 --> 00:13:20,210
这就解释了什么才是真正失败的 

272
00:13:20,210 --> 00:13:23,420
2的平方不是4 

273
00:13:23,420 --> 00:13:28,100
让我以同样的方式继续 试着断言3的平方

274
00:13:28,100 --> 00:13:33,000
等于9 除非存在断言错误 在这种情况下 

275
00:13:33,000 --> 00:13:37,370
我要打印出来 更人性化 3的平方不是9 

276
00:13:37,370 --> 00:13:39,920
所以我前进了一步 但也后退了一步 

277
00:13:39,920 --> 00:13:41,180
因为现在我有了更多的代码 

278
00:13:41,180 --> 00:13:44,288
但我至少引入了断言和例外

279
00:13:44,288 --> 00:13:46,580
以一种与我们过去所见一致的方式 

280
00:13:46,580 --> 00:13:50,450
当出现问题时 您实际上会看到异常被引发 

281
00:13:50,450 --> 00:13:53,330
现在让我继续运行这个版本的程序 

282
00:13:53,330 --> 00:13:57,800
测试计算器.py的巨蟒 祈祷我的手指

283
00:13:57,800 --> 00:14:00,170
它仍然失败 因为我看到了输出 

284
00:14:00,170 --> 00:14:02,850
但我们至少回到了用户友好的输出 

285
00:14:02,850 --> 00:14:05,690
因此 这至少是在某种程度上的进步 

286
00:14:05,690 --> 00:14:09,088
但同样 它的代码可能比理想的要多 

287
00:14:09,088 --> 00:14:11,630
事实上 如果我们继续这样做 如果我们真的

288
00:14:11,630 --> 00:14:14,900
还想在这里添加额外的测试用例吗？

289
00:14:14,900 --> 00:14:18,980
看起来我们最终可能会写出比理想中多得多的代码 

290
00:14:18,980 --> 00:14:21,260
例如 我现在正在测试2和3 

291
00:14:21,260 --> 00:14:24,000
我也应该测试一些负数 

292
00:14:24,000 --> 00:14:26,870
所以我为什么不继续加进去呢 比如说--让我继续

293
00:14:26,870 --> 00:14:28,710
复制粘贴这个

294
00:14:28,710 --> 00:14:32,780
让我试着断言负2的平方根等于

295
00:14:32,780 --> 00:14:34,978
等于4 数学上应该是这样 

296
00:14:34,978 --> 00:14:36,770
如果没有 让我继续改变这个

297
00:14:36,770 --> 00:14:39,410
负2的平方不是4

298
00:14:39,410 --> 00:14:41,930
让我继续复制粘贴这个 

299
00:14:41,930 --> 00:14:44,280
测试另一个负数 只是为了更好地衡量 

300
00:14:44,280 --> 00:14:47,900
让我们测试负3的平方根 它应该等于9 

301
00:14:47,900 --> 00:14:53,330
但如果不是 我们继续假设负3的平方不是9 

302
00:14:53,330 --> 00:14:56,900
在这里大声思考一下 还有什么值得测试的？

303
00:14:56,900 --> 00:14:57,890
我试过两次 

304
00:14:57,890 --> 00:14:58,550
我试过三个 

305
00:14:58,550 --> 00:14:59,330
我试过负2 

306
00:14:59,330 --> 00:15:00,247
我试过负3 

307
00:15:00,247 --> 00:15:01,820
我不能尝试无限的数字 

308
00:15:01,820 --> 00:15:03,320
但至少有一点

309
00:15:03,320 --> 00:15:04,737
这些价值观之间的差异 

310
00:15:04,737 --> 00:15:05,240
让我们试试0 

311
00:15:05,240 --> 00:15:08,540
0也是一个有趣的例子 以防万一 

312
00:15:08,540 --> 00:15:09,740
为什么是0？

313
00:15:09,740 --> 00:15:11,720
我只是凭直觉 

314
00:15:11,720 --> 00:15:14,928
正数的概率一般都是一样的 

315
00:15:14,928 --> 00:15:16,970
负数的行为通常是相同的 

316
00:15:16,970 --> 00:15:18,650
0可能有点反常 

317
00:15:18,650 --> 00:15:23,060
这不一定是科学 而是你自己考虑一下

318
00:15:23,060 --> 00:15:26,457
根据您自己的经验 潜在的极端情况是基于什么

319
00:15:26,457 --> 00:15:28,040
你要测试的功能上的区别吗

320
00:15:28,040 --> 00:15:29,790
我在试着测试一些数学问题 

321
00:15:29,790 --> 00:15:31,560
所以我想测试代表性的值 

322
00:15:31,560 --> 00:15:34,520
所以让我继续粘贴在一个尝试除了块 

323
00:15:34,520 --> 00:15:38,120
让我们断言0的平方应该等于0 

324
00:15:38,120 --> 00:15:43,460
如果不是 我会解释一下 比如0的平方不是0 

325
00:15:43,460 --> 00:15:48,950
现在如果我继续运行这个 Python的test_calculator.py 然后按Enter 

326
00:15:48,950 --> 00:15:50,780
现在我看到了多个错误 

327
00:15:50,780 --> 00:15:51,890
这很有趣

328
00:15:51,890 --> 00:15:55,580
这是一条线索 因为注意到一些 但不是全部 

329
00:15:55,580 --> 00:15:57,320
这些断言都失败了 

330
00:15:57,320 --> 00:16:02,210
正如我们前面提到的 1比2的平方显然是可以的 

331
00:16:02,210 --> 00:16:05,450
回想一下 2的平方正好是2加2 

332
00:16:05,450 --> 00:16:07,707
所以这个错误并不会影响我们的测试 

333
00:16:07,707 --> 00:16:09,290
但这是一件好事 我们测试了3 

334
00:16:09,290 --> 00:16:11,450
幸好我们检测到了负2和负3 

335
00:16:11,450 --> 00:16:13,370
因为所有这些测试都发现了这个错误 

336
00:16:13,370 --> 00:16:18,740
0测试没有注意到 因为0的平方当然是0 但0加0

337
00:16:18,740 --> 00:16:19,370
为0 

338
00:16:19,370 --> 00:16:22,130
因此 我们在那里变得幸运或不幸 取决于

339
00:16:22,130 --> 00:16:25,280
在这里 你如何看待杯子是半满还是半空 

340
00:16:25,280 --> 00:16:30,500
我们至少通过多次测试以某种方式发现了这个错误 

341
00:16:30,500 --> 00:16:35,870
所以 如果我们不在这里写那么多该死的代码 那就太好了 

342
00:16:35,870 --> 00:16:37,170
因为注意我的所作所为 

343
00:16:37,170 --> 00:16:39,710
我试过 除了试过 试过 

344
00:16:39,710 --> 00:16:41,150
我有所有这些断言 

345
00:16:41,150 --> 00:16:42,600
我有一个主要的功能 

346
00:16:42,600 --> 00:16:45,470
我在我的文件底部有这个有条件的 

347
00:16:45,470 --> 00:16:49,020
老实说 谁会想要写31行代码

348
00:16:49,020 --> 00:16:51,830
现在来测试一个两行函数？

349
00:16:51,830 --> 00:16:53,780
没有人会写出这样的测试代码

350
00:16:53,780 --> 00:16:57,620
如果我们都要编写更多的代码来进行实际测试 

351
00:16:57,620 --> 00:16:59,970
所以人们已经解决了这个问题 

352
00:16:59,970 --> 00:17:02,720
如果您习惯于大量测试代码 或者想要这样做 

353
00:17:02,720 --> 00:17:04,700
如果我养成了经常测试代码的习惯 

354
00:17:04,700 --> 00:17:07,283
如果现实世界中的每个人都有这种想要的习惯

355
00:17:07,283 --> 00:17:09,319
为了测试他们的代码 我们为什么不创建工具

356
00:17:09,319 --> 00:17:11,690
这会让你更容易做到这一点吗？

357
00:17:11,690 --> 00:17:14,000
事实上 有一种机制可以让你

358
00:17:14,000 --> 00:17:17,780
这就是说 我们可以使用一种通常被称为“最高测试”的工具 

359
00:17:17,780 --> 00:17:21,920
所以PYTEST是一个第三方程序 你可以下载和安装

360
00:17:21,920 --> 00:17:26,450
这将自动测试代码 只要您编写测试即可 

361
00:17:26,450 --> 00:17:29,150
但这个图书馆和其他图书馆有什么好的

362
00:17:29,150 --> 00:17:31,580
就像它采用了一些惯例 所以

363
00:17:31,580 --> 00:17:35,320
您不必自己手动编写那么多行代码 

364
00:17:35,320 --> 00:17:38,090
他们会自动为你做一些这样的事情 

365
00:17:38,090 --> 00:17:39,520
这是一个第三方图书馆 

366
00:17:39,520 --> 00:17:42,520
可以说 还有其他用于单元测试的库 

367
00:17:42,520 --> 00:17:44,440
测试你的代码单元 

368
00:17:44,440 --> 00:17:46,240
其中一些是由Python本身提供的 

369
00:17:46,240 --> 00:17:48,813
我们建议今天就来看看pytest

370
00:17:48,813 --> 00:17:50,980
因为它实际上比单位更简单

371
00:17:50,980 --> 00:17:53,170
测试Python自带的框架 

372
00:17:53,170 --> 00:17:54,760
单元测试是什么意思？

373
00:17:54,760 --> 00:17:57,910
单元测试只是描述测试的一种形式化方法

374
00:17:57,910 --> 00:18:00,297
你的程序的单个单元 

375
00:18:00,297 --> 00:18:01,630
这些个体单位是什么？

376
00:18:01,630 --> 00:18:02,960
它们是典型的函数 

377
00:18:02,960 --> 00:18:07,360
因此 单元测试通常是对您编写的函数的测试 

378
00:18:07,360 --> 00:18:09,610
这在实践中意味着什么 

379
00:18:09,610 --> 00:18:12,910
让我回到我的VS代码 

380
00:18:12,910 --> 00:18:17,260
我建议我们大大简化我的测试计算器 

381
00:18:17,260 --> 00:18:22,930
我要删除所有这些测试 

382
00:18:22,930 --> 00:18:24,400
喜欢31行代码 

383
00:18:24,400 --> 00:18:28,750
让我们看看我们是否可以使用pytest提取测试的本质 

384
00:18:28,750 --> 00:18:32,350
从我的同一个计算器程序 让我仍然进口平方 

385
00:18:32,350 --> 00:18:34,270
所以我仍然需要这行代码 

386
00:18:34,270 --> 00:18:35,980
可以测试它的具体功能 

387
00:18:35,980 --> 00:18:39,010
现在我要继续定义一个函数 就像我之前做的一样 

388
00:18:39,010 --> 00:18:39,800
如下

389
00:18:39,800 --> 00:18:42,430
我将定义一个函数 叫做测试正方形

390
00:18:42,430 --> 00:18:46,360
按照惯例 测试下划线和要测试的函数的名称 

391
00:18:46,360 --> 00:18:47,957
虽然不一定非要这样

392
00:18:47,957 --> 00:18:50,290
现在我要继续做一些断言 

393
00:18:50,290 --> 00:18:53,350
我断言2的平方应该等于4 

394
00:18:53,350 --> 00:18:57,310
我断言3的平方应该等于9 

395
00:18:57,310 --> 00:19:01,750
我断言负2的平方应该等于4 

396
00:19:01,750 --> 00:19:06,250
我断言负3的平方应该等于9 

397
00:19:06,250 --> 00:19:10,990
最后 我将断言0的平方应该等于0 

398
00:19:10,990 --> 00:19:14,860
所以我仍然使用assert关键字 正如我前面介绍的那样 

399
00:19:14,860 --> 00:19:17,290
尽管打字有点乏味 

400
00:19:17,290 --> 00:19:18,910
现在只有八行代码了

401
00:19:18,910 --> 00:19:20,440
它们很容易打字 

402
00:19:20,440 --> 00:19:22,750
这不是尝试和例外以及所有这一切 

403
00:19:22,750 --> 00:19:26,410
如果其他的东西 其他的人 

404
00:19:26,410 --> 00:19:31,930
办理了试车、排版、打印、所有标准化工作

405
00:19:31,930 --> 00:19:33,400
真的进行这些测试吗？

406
00:19:33,400 --> 00:19:36,370
事实上 这就是PYTEST发挥作用的地方 

407
00:19:36,370 --> 00:19:40,180
根据pytest的文档 它本身可以与pip一起安装 

408
00:19:40,180 --> 00:19:44,170
安装PYTEST 我们过去用它来安装其他库 

409
00:19:44,170 --> 00:19:47,980
您可以查看这里的文档 了解它的所有正式用法 

410
00:19:47,980 --> 00:19:51,760
但幸运的是 就测试框架而言 PYTEST是非常用户友好的 

411
00:19:51,760 --> 00:19:55,660
它实际上允许我们只需在代码上运行pytest就可以直接进入

412
00:19:55,660 --> 00:19:56,510
这是我们写的 

413
00:19:56,510 --> 00:20:00,310
因此 如果我回到这里的VS代码 并查看我的test_culator.py 

414
00:20:00,310 --> 00:20:04,210
注意 不再有主函数--它没有条件 

415
00:20:04,210 --> 00:20:05,440
它没有尝试过 

416
00:20:05,440 --> 00:20:06,460
它也不例外 

417
00:20:06,460 --> 00:20:07,450
它没有指纹 

418
00:20:07,450 --> 00:20:11,320
它只有我的几个断言--pytest和其他库

419
00:20:11,320 --> 00:20:14,890
就像它会自动为我运行这些测试一样

420
00:20:14,890 --> 00:20:20,320
并在屏幕上告诉我这些测试中是否有失败的 

421
00:20:20,320 --> 00:20:21,692
所以让我继续做这件事 

422
00:20:21,692 --> 00:20:24,400
我将继续增加我的终端窗口的大小

423
00:20:24,400 --> 00:20:26,567
暂时 只是为了让我们能在屏幕上看到更多 

424
00:20:26,567 --> 00:20:29,170
我要运行的不是蟒蛇 就像我一直做的那样 

425
00:20:29,170 --> 00:20:32,620
我将运行PYTEST 这也是第三方

426
00:20:32,620 --> 00:20:35,110
用于在代码中运行测试的工具 

427
00:20:35,110 --> 00:20:39,880
我将运行TEST_COMPUATOR的pytest 所以相同的文件 

428
00:20:39,880 --> 00:20:42,490
我要像往常一样祈祷然后按回车键 

429
00:20:42,490 --> 00:20:46,040
我们会发现有些事情失败了 

430
00:20:46,040 --> 00:20:48,340
现在不得不承认 尽管我确实认为你会

431
00:20:48,340 --> 00:20:51,290
我发现pytest使用起来相对简单 

432
00:20:51,290 --> 00:20:55,490
它的输出 至少乍一看 不一定是超级用户友好的 

433
00:20:55,490 --> 00:20:56,950
那么我们在这里看到的是什么呢？

434
00:20:56,950 --> 00:21:01,660
请注意 在我的窗口的最顶部是我在提示符后运行的命令 

435
00:21:01,660 --> 00:21:05,470
就在它的正下方是一个红色的F 意思是失败 

436
00:21:05,470 --> 00:21:07,180
所以并不是很鼓舞人心 

437
00:21:07,180 --> 00:21:10,600
我在这里真的很努力 但不及格是我在这个项目上的分数 

438
00:21:10,600 --> 00:21:12,460
但让我们来看看到底发生了什么 

439
00:21:12,460 --> 00:21:15,530
如果我看一下这段失败的节选 

440
00:21:15,530 --> 00:21:18,400
您将看到 测试正方形是失败的函数 

441
00:21:18,400 --> 00:21:20,650
这是有道理的 因为这是我唯一写的 

442
00:21:20,650 --> 00:21:25,390
您将在这里看到一些晦涩难懂的输出 描述错误是什么 

443
00:21:25,390 --> 00:21:28,930
所以你在这里看到的是第一行的输出等于4 

444
00:21:28,930 --> 00:21:29,530
这很好 

445
00:21:29,530 --> 00:21:32,230
下面没有红色错误消息 所以这一条是正常的 

446
00:21:32,230 --> 00:21:36,640
但这行代码断言3的平方等于9 

447
00:21:36,640 --> 00:21:40,880
皮斯特不喜欢这种断言 因为它最终并不是真的 

448
00:21:40,880 --> 00:21:44,480
事实上 根据这行开头的红色E 

449
00:21:44,480 --> 00:21:50,350
你们会看到 我实际上是在试图断言6等于9 

450
00:21:50,350 --> 00:21:52,280
现在 这6个人是从哪里来的？

451
00:21:52,280 --> 00:21:56,920
等等 如果我的测试涉及到这一点 注意6等于3的平方 

452
00:21:56,920 --> 00:22:01,360
这就是说 因为我调用了Square 传入了值3 

453
00:22:01,360 --> 00:22:03,790
结果是它的返回值是6 

454
00:22:03,790 --> 00:22:07,690
当然 从数学上讲 6不等于9 

455
00:22:07,690 --> 00:22:09,760
这就是为什么这一计划失败了 

456
00:22:09,760 --> 00:22:13,240
现在 PYTEST并不像告诉你的那样用户友好

457
00:22:13,240 --> 00:22:16,750
究竟为什么会有漏洞 或者如何修复它 

458
00:22:16,750 --> 00:22:19,840
这真的只是一个线索 告诉你肯定是哪里出了问题 

459
00:22:19,840 --> 00:22:23,020
你在这里看到的是第一次测试通过的线索 

460
00:22:23,020 --> 00:22:26,860
因为该行代码下面没有红色错误 但该测试失败了 

461
00:22:26,860 --> 00:22:32,290
不知何故 您的平方函数返回6

462
00:22:32,290 --> 00:22:34,840
当传入3而不是9时 

463
00:22:34,840 --> 00:22:37,180
所以在这一点上 你可以戴上你的侦探帽子 

464
00:22:37,180 --> 00:22:39,490
您返回到您的实际代码 然后您认为

465
00:22:39,490 --> 00:22:42,340
关于culator.py 世界上到底是怎样的

466
00:22:42,340 --> 00:22:47,380
我的Square函数的第7行返回6而不是9 

467
00:22:47,380 --> 00:22:49,380
在这一点上 很可能是灯泡

468
00:22:49,380 --> 00:22:51,130
会飞到你头上 这是众所周知的 

469
00:22:51,130 --> 00:22:55,390
你们会看到 我用的是加法 而不是乘法 

470
00:22:55,390 --> 00:22:57,640
但PYTEST为我们做的是自动化

471
00:22:57,640 --> 00:23:00,610
至少为我们指出这个错误的过程 

472
00:23:00,610 --> 00:23:03,147
如果我现在进去解决这个问题--让我继续 

473
00:23:03,147 --> 00:23:04,480
灯泡也熄灭了 

474
00:23:04,480 --> 00:23:08,320
我把加号改成乘号 

475
00:23:08,320 --> 00:23:10,660
现在我要继续 在清空我的屏幕后 

476
00:23:10,660 --> 00:23:15,130
我要运行的不是Python 而是test_culator.py的pytest 

477
00:23:15,130 --> 00:23:16,390
再一次为我祈祷 

478
00:23:16,390 --> 00:23:17,800
现在它是绿色的 

479
00:23:17,800 --> 00:23:21,760
我只看到一个点 这表明我唯一的一次测试通过了 

480
00:23:21,760 --> 00:23:27,080
我很好 在修复了那个错误后 我的测试现在100%成功 

481
00:23:27,080 --> 00:23:30,550
让我在这里暂停一下 看看有没有什么问题 

482
00:23:30,550 --> 00:23:33,520
演讲者3：所以我的问题是 如果用户 

483
00:23:33,520 --> 00:23:36,160
而不是因为我们从用户那里获取输入 

484
00:23:36,160 --> 00:23:41,590
如果用户有点恶意 而是输入了一个字符串 该怎么办

485
00:23:41,590 --> 00:23:46,420
或者他输入的是浮点数或其他数据类型？

486
00:23:46,420 --> 00:23:48,730
David Malan：是的 如果用户 像我们这样

487
00:23:48,730 --> 00:23:51,655
在以前的示例中看到 在以下情况下 键入cat 而不是数字

488
00:23:51,655 --> 00:23:52,780
我们要的是一个整数吗？

489
00:23:52,780 --> 00:23:54,940
我们怎么测试这样的东西呢？

490
00:23:54,940 --> 00:23:57,970
目前 我诚然不是在测试用户输入 

491
00:23:57,970 --> 00:24:02,750
如果我回到这里的代码 请注意我的计算器功能 当然 

492
00:24:02,750 --> 00:24:05,290
具有我们不断测试和重新测试的平方函数 

493
00:24:05,290 --> 00:24:08,470
但请注意 所有用户输入当前都是

494
00:24:08,470 --> 00:24:10,300
被降级为我的主要职责 

495
00:24:10,300 --> 00:24:14,120
诚然 到目前为止 我并没有测试我的主要功能 

496
00:24:14,120 --> 00:24:15,760
所以可能有一种虫子 

497
00:24:15,760 --> 00:24:19,600
事实上 会有的 因为如果用户输入一个字符串 就像猫一样 

498
00:24:19,600 --> 00:24:24,850
而不是像2或3这样整数 那么第二行调用实际上将

499
00:24:24,850 --> 00:24:26,990
引发值错误异常 

500
00:24:26,990 --> 00:24:28,160
所以我们以前见过这种情况 

501
00:24:28,160 --> 00:24:30,280
因此 在测试代码时 这一点

502
00:24:30,280 --> 00:24:35,080
实际上是在程序中拥有多个函数的一个很好的理由 

503
00:24:35,080 --> 00:24:37,900
与其将所有的逻辑都放在文件本身中 

504
00:24:37,900 --> 00:24:40,240
与其把所有的逻辑都放在Main里 

505
00:24:40,240 --> 00:24:43,030
这实际上是非常好的 非常有帮助的练习

506
00:24:43,030 --> 00:24:46,750
将你的想法分解成更小的函数

507
00:24:46,750 --> 00:24:48,370
他们自己是可测试的 

508
00:24:48,370 --> 00:24:49,630
我在这里是什么意思？

509
00:24:49,630 --> 00:24:52,270
Square是完全可测试的 

510
00:24:52,270 --> 00:24:52,810
为什么？

511
00:24:52,810 --> 00:24:56,020
因为它接受名为n的参数作为输入 

512
00:24:56,020 --> 00:24:59,680
并且它以整数形式返回输出 这是

513
00:24:59,680 --> 00:25:01,390
希望能成为正方形 

514
00:25:01,390 --> 00:25:04,120
它有一个定义良好的输入和一个定义良好的输出 

515
00:25:04,120 --> 00:25:08,080
因此 在测试程序中它完全在您的控制之下

516
00:25:08,080 --> 00:25:09,730
来传递这些值 

517
00:25:09,730 --> 00:25:15,730
现在我要说的是 如果您想测试Square是否正常运行

518
00:25:15,730 --> 00:25:18,280
当传递类似字符串的东西时 比如 引号 不引号 

519
00:25:18,280 --> 00:25:20,920
“猫” 我们绝对可以做这样的事情 

520
00:25:20,920 --> 00:25:24,520
断言引号的平方 不引号 “猫 ”

521
00:25:24,520 --> 00:25:26,050
它不会等于某些东西 

522
00:25:26,050 --> 00:25:28,210
您实际上可以使用不同的语法 

523
00:25:28,210 --> 00:25:31,000
断言将引发特定的异常 

524
00:25:31,000 --> 00:25:34,060
所以如果我们真的要回到平方函数 

525
00:25:34,060 --> 00:25:37,880
改进它 并故意引发异常 我们也可以测试这一点 

526
00:25:37,880 --> 00:25:41,200
但现在 我故意只测试平方函数 

527
00:25:41,200 --> 00:25:43,990
我不是在测试特定的用户输入 

528
00:25:43,990 --> 00:25:45,670
但这是另一个需要解决的问题 

529
00:25:45,670 --> 00:25:49,890
现在关于单元测试的其他问题？

530
00:25:49,890 --> 00:25:56,670
演讲者4：是否使用单元测试来测试CS50检查的代码？

531
00:25:56,670 --> 00:25:58,830
大卫·马兰：所以Check 50在精神上是相似的 

532
00:25:58,830 --> 00:26:03,000
Check 50是我们CS50编写的一个工具 它本质上是在做一些事情

533
00:26:03,000 --> 00:26:06,750
比如为了评估学生的代码而使用的PYTEST 

534
00:26:06,750 --> 00:26:10,080
它在精神上是相似的 但想想支票50

535
00:26:10,080 --> 00:26:12,697
如果你愿意的话 可以把它当做一种替代品 

536
00:26:12,697 --> 00:26:14,280
但它的工作原理略有不同 

537
00:26:14,280 --> 00:26:17,370
但是相同的想法 最快测试和单元测试更多

538
00:26:17,370 --> 00:26:19,890
通常是一种独立于CS50的技术

539
00:26:19,890 --> 00:26:23,430
和是您可以也应该对您自己的代码执行的操作 无论是在

540
00:26:23,430 --> 00:26:25,240
或者在这门课之外 

541
00:26:25,240 --> 00:26:31,322
我们的单元测试中还有一个问题呢？

542
00:26:31,322 --> 00:26:33,030
演讲者5：我的问题是

543
00:26:33,030 --> 00:26:37,140
四次写字 就像2的平方和4的平方 

544
00:26:37,140 --> 00:26:43,450
取而代之的是 我们能不能把我们想要的数字写在方括号中 

545
00:26:43,450 --> 00:26:44,980
而不是写四行？

546
00:26:44,980 --> 00:26:46,980
大卫·马兰：绝对是一个非常好的问题 

547
00:26:46,980 --> 00:26:49,620
现在 如果我返回到test_culator.py 

548
00:26:49,620 --> 00:26:51,420
这确实是相当手动的 

549
00:26:51,420 --> 00:26:54,570
我花了一段时间才说出并打出了这几行字 

550
00:26:54,570 --> 00:26:58,710
您可以想象编写某种类型的循环来在循环中断言

551
00:26:58,710 --> 00:27:02,220
这个等于那个 这个等于那个 以此类推 使用一个列表

552
00:27:02,220 --> 00:27:05,530
或者使用列表、词典或类似的结构 

553
00:27:05,530 --> 00:27:08,008
因此 是的 您完全可以自动执行其中的一些测试

554
00:27:08,008 --> 00:27:10,050
而不是一遍又一遍地做同样的事情 

555
00:27:10,050 --> 00:27:12,660
您仍然可以使用Python的所有语法来执行循环 

556
00:27:12,660 --> 00:27:16,200
但总的来说 您的测试应该非常简单 

557
00:27:16,200 --> 00:27:21,510
事实上 让我建议我们进一步改进这个设计 

558
00:27:21,510 --> 00:27:28,320
因为目前 当我进行所有这些测试时 情况并不理想

559
00:27:28,320 --> 00:27:32,010
当我的函数出现错误时 请注意我得到的输出 

560
00:27:32,010 --> 00:27:35,550
让我通过更改我的乘法来重新引入相同的错误

561
00:27:35,550 --> 00:27:36,520
为了加法 

562
00:27:36,520 --> 00:27:39,150
让我再次增加终端窗口的大小 

563
00:27:39,150 --> 00:27:42,600
让我再次运行test_culator.py的pytest 

564
00:27:42,600 --> 00:27:46,260
这就是我现在的代码版本 它又有了这个错误 

565
00:27:46,260 --> 00:27:49,290
所以我会看到一场巨大的失败

566
00:27:49,290 --> 00:27:52,530
这一失败已经向我展示了 

567
00:27:52,530 --> 00:27:55,260
但这并不像它可能的那样有帮助 

568
00:27:55,260 --> 00:27:58,180
因为我的代码中有所有这些其他测试 

569
00:27:58,180 --> 00:28:01,350
回想一下 我有 一 二 三 四 五个不同的测试 

570
00:28:01,350 --> 00:28:03,270
我只看到了第一个的输出 

571
00:28:03,270 --> 00:28:04,410
为什么会这样呢？

572
00:28:04,410 --> 00:28:06,690
如果我们回到我这里的代码 你会看到

573
00:28:06,690 --> 00:28:11,370
第一个失败的断言 也就是这里的这个断言 

574
00:28:11,370 --> 00:28:15,750
3的平方等于9 其他测试甚至没有运行 

575
00:28:15,750 --> 00:28:19,830
这并不是什么大事 因为我的代码有错误 所以一个或多个

576
00:28:19,830 --> 00:28:21,630
他们中的一些人可能无论如何都会失败 

577
00:28:21,630 --> 00:28:24,870
但是 知道他们中的哪些人会失败 不是很好吗？

578
00:28:24,870 --> 00:28:27,900
事实上 一次运行尽可能多的测试是理想的

579
00:28:27,900 --> 00:28:31,020
给你尽可能多的线索来找到你的虫子 

580
00:28:31,020 --> 00:28:35,010
所以让我建议我们改进我的测试代码的设计

581
00:28:35,010 --> 00:28:38,040
现在 仍然使用pyest 如下所示 

582
00:28:38,040 --> 00:28:41,280
而不是使用一个名为test_square的大函数

583
00:28:41,280 --> 00:28:45,090
它用这么多不同的输入来测试整个函数本身 

584
00:28:45,090 --> 00:28:48,270
让我们把我的测试分成不同的类别 

585
00:28:48,270 --> 00:28:51,100
在这里 也没有一种正确的方法来做到这一点 

586
00:28:51,100 --> 00:28:53,430
但我的头脑在想 也许我应该

587
00:28:53,430 --> 00:28:57,840
分别测试正数 分别测试负数 并测试0

588
00:28:57,840 --> 00:28:58,470
分开的 

589
00:28:58,470 --> 00:28:59,637
我可以想出其他办法 

590
00:28:59,637 --> 00:29:00,810
我可以测试偶数 

591
00:29:00,810 --> 00:29:03,930
我可以测试奇数或者其他模式 

592
00:29:03,930 --> 00:29:07,140
但将这一重大测试分成多个测试

593
00:29:07,140 --> 00:29:10,150
可能会在出问题的时候给我提供更多线索 

594
00:29:10,150 --> 00:29:11,620
那就让我来做吧 

595
00:29:11,620 --> 00:29:15,570
让我继续并将此函数重命名为初始测试阳性 

596
00:29:15,570 --> 00:29:19,170
让我在这个函数中只包含前两个测试 

597
00:29:19,170 --> 00:29:23,560
然后 让我在这里创建另一个函数 称为测试负值 

598
00:29:23,560 --> 00:29:27,780
在这个函数中 我只测试负2和负3 

599
00:29:27,780 --> 00:29:31,500
然后在这里 让我再定义一次test_Zero 

600
00:29:31,500 --> 00:29:33,660
我只会在那里做一次测试 

601
00:29:33,660 --> 00:29:36,690
所以我有同样的断言 同样的五个 

602
00:29:36,690 --> 00:29:39,960
但我现在将它们划分为三个不同的函数 

603
00:29:39,960 --> 00:29:43,470
PYTEST和其他单元测试框架有什么优点

604
00:29:43,470 --> 00:29:47,340
这三个测试功能都将自动运行 

605
00:29:47,340 --> 00:29:50,400
即使其中一个失败了 其他的也会尝试 

606
00:29:50,400 --> 00:29:53,790
这意味着如果他们中的一个或两个或三个失败了 

607
00:29:53,790 --> 00:29:58,235
我现在有一条、两条或三条线索来帮助我找出那个错误 

608
00:29:58,235 --> 00:30:01,110
因此 让我继续并再次增加我的终端窗口的大小 

609
00:30:01,110 --> 00:30:02,693
只是为了让我们能在屏幕上看到更多 

610
00:30:02,693 --> 00:30:07,350
我的计算器仍然有错误 使用加法 而不是乘法 

611
00:30:07,350 --> 00:30:12,060
让我们继续运行 不是运行Python 而是再次运行test_culator.py的pytest 

612
00:30:12,060 --> 00:30:14,550
一如既往地祈祷 现在 哦 我的上帝 

613
00:30:14,550 --> 00:30:16,500
屏幕上的错误甚至更多 

614
00:30:16,500 --> 00:30:19,038
但这本身就更有帮助 

615
00:30:19,038 --> 00:30:20,830
让我们自上而下地学习它们 

616
00:30:20,830 --> 00:30:22,677
所以 在这里失败的情况下 大写的 

617
00:30:22,677 --> 00:30:25,260
我知道看到失败并不是很令人振奋

618
00:30:25,260 --> 00:30:28,260
试图解决一个问题 但这就是这些框架所做的 

619
00:30:28,260 --> 00:30:31,530
在FAILES下 第一个失败的函数是TEST_PRECTIVE 

620
00:30:31,530 --> 00:30:34,230
但在这里 我们也看到了与以前相同的线索 

621
00:30:34,230 --> 00:30:38,230
第一个 2 2的平方等于4 那一个很好 

622
00:30:38,230 --> 00:30:40,210
它不会有任何红色错误 

623
00:30:40,210 --> 00:30:41,650
但下一次失败了 

624
00:30:41,650 --> 00:30:45,150
所以我知道当我传到3的时候 正方形是被打破的 

625
00:30:45,150 --> 00:30:46,122
那下面呢？

626
00:30:46,122 --> 00:30:49,080
不幸的是 看起来我的测试阴性功能也失败了 

627
00:30:49,080 --> 00:30:49,950
为什么？

628
00:30:49,950 --> 00:30:53,880
当我进入时--哦 这很有趣--现在 这里是负2

629
00:30:53,880 --> 00:30:55,270
都不管用了 

630
00:30:55,270 --> 00:30:56,640
所以我幸运地得到了正2 

631
00:30:56,640 --> 00:30:58,050
但负2不起作用 

632
00:30:58,050 --> 00:30:59,400
这是一个小小的线索 

633
00:30:59,400 --> 00:31:02,850
但总体而言 只有两次测试失败 

634
00:31:02,850 --> 00:31:07,500
所以请注意 在最下面 这个总结 两个失败 一个通过 

635
00:31:07,500 --> 00:31:08,400
另一个是什么？

636
00:31:08,400 --> 00:31:09,358
第三个是什么？

637
00:31:09,358 --> 00:31:10,020
测试零 

638
00:31:10,020 --> 00:31:11,970
因此 测试零正在通过 

639
00:31:11,970 --> 00:31:13,590
这两家公司都在失败 

640
00:31:13,590 --> 00:31:17,170
因此 如果你愿意的话 这可以从逻辑上、数学上引导我 

641
00:31:17,170 --> 00:31:18,282
找到了病毒的源头 

642
00:31:18,282 --> 00:31:20,490
我也要说清楚 如果你有很多测试 

643
00:31:20,490 --> 00:31:23,910
这一小行输出是有帮助的 尽管也有点令人沮丧 

644
00:31:23,910 --> 00:31:27,180
FAIL、FAIL和圆点表示通过 

645
00:31:27,180 --> 00:31:28,930
所以有刚才描述的三个测试

646
00:31:28,930 --> 00:31:31,480
在图形上有一点不同 

647
00:31:31,480 --> 00:31:35,590
现在让我回过头来 回到culator.py 

648
00:31:35,590 --> 00:31:38,050
让我们修复这个错误 因为让我们假设

649
00:31:38,050 --> 00:31:40,150
我已经推断出我在使用加法 

650
00:31:40,150 --> 00:31:42,460
我应该一直在用乘法 

651
00:31:42,460 --> 00:31:44,710
现在让我在修复错误之后再一次 

652
00:31:44,710 --> 00:31:46,550
让我回到我的大航站楼 

653
00:31:46,550 --> 00:31:51,160
让我运行test_culator.py的pytest 按Enter键 现在祈祷 

654
00:31:51,160 --> 00:31:53,620
圆点表示一切都很好 

655
00:31:53,620 --> 00:31:56,360
我所有的测试都通过了 三次都通过了 

656
00:31:56,360 --> 00:31:57,620
所以现在我很好 

657
00:31:57,620 --> 00:32:02,110
这并不一定意味着我的代码是100%正确的 

658
00:32:02,110 --> 00:32:05,950
但这确实意味着它已经100%通过了我目前的测试 

659
00:32:05,950 --> 00:32:10,150
因此 我们应该更认真地考虑一下

660
00:32:10,150 --> 00:32:11,710
我们应该测试更大的数字 

661
00:32:11,710 --> 00:32:13,600
也许我们应该测试更小的数字 

662
00:32:13,600 --> 00:32:15,610
也许我们应该测试一下字符串或其他东西 

663
00:32:15,610 --> 00:32:19,090
最终的责任是你来决定你要测试什么 

664
00:32:19,090 --> 00:32:22,360
但在现实世界中 你会对自己非常不满意

665
00:32:22,360 --> 00:32:25,900
或者其他人--也许你的老板会对你非常不满意--

666
00:32:25,900 --> 00:32:29,320
如果你没有在你的代码中发现一个错误 你可能已经发现了

667
00:32:29,320 --> 00:32:33,070
您是否刚刚编写了一个测试来尝试这种输入 

668
00:32:33,070 --> 00:32:35,500
让我再暂停一次 看看现在是否有任何问题

669
00:32:35,500 --> 00:32:38,740
关于使用pytest进行单元测试 

670
00:32:38,740 --> 00:32:41,950
演讲者6：所以 如果你想测试 就像之前有人建议的那样 

671
00:32:41,950 --> 00:32:45,430
用户输入以及测试您的功能 

672
00:32:45,430 --> 00:32:47,500
您是否在同一文件中执行此操作？

673
00:32:47,500 --> 00:32:50,260
或者 您是否为不同类型的测试创建单独的文件？

674
00:32:50,260 --> 00:32:51,677
大卫·马兰：这个问题问得很好 

675
00:32:51,677 --> 00:32:55,120
您绝对可以创建单独的文件来测试不同类型的东西 

676
00:32:55,120 --> 00:32:58,300
或者 如果您没有那么多 您可以将它们都保存在同一个文件中 

677
00:32:58,300 --> 00:33:01,827
目前 为了方便起见 我一直将我所有的测试存储在一个文件中 

678
00:33:01,827 --> 00:33:03,410
而且它们的数量也不是很多 

679
00:33:03,410 --> 00:33:05,380
但我们将通过一个例子来了解一下

680
00:33:05,380 --> 00:33:08,470
这样我就可以把它们放到一个文件夹里 甚至运行pytest

681
00:33:08,470 --> 00:33:11,090
在整个测试文件夹上也是如此 

682
00:33:11,090 --> 00:33:12,010
所以这是可能的 

683
00:33:12,010 --> 00:33:14,120
关于单元测试的其他问题 

684
00:33:14,120 --> 00:33:16,810
演讲者7：我有两个问题 

685
00:33:16,810 --> 00:33:22,960
几年前 您刚刚使用了一个名为--

686
00:33:22,960 --> 00:33:26,110
我不确定这是什么--哦 是的 断言错误 

687
00:33:26,110 --> 00:33:30,160
这个特定的错误到底捕捉到了什么？

688
00:33:30,160 --> 00:33:36,500
我的第二个问题是 Assert关键字

689
00:33:36,500 --> 00:33:39,320
站在编者面前 准确地告诉他们

690
00:33:39,320 --> 00:33:42,987
来插入这行特定的代码？

691
00:33:42,987 --> 00:33:43,820
大卫·马兰：确实如此 

692
00:33:43,820 --> 00:33:48,320
我们看到的ASSERT关键字和前面看到的断言错误

693
00:33:48,320 --> 00:33:49,530
是交织在一起的 

694
00:33:49,530 --> 00:33:52,460
因此 当您使用Assert而断言失败时 

695
00:33:52,460 --> 00:33:56,570
因为无论你用的是什么布尔表达式 都不是真的 而是假的 

696
00:33:56,570 --> 00:34:00,170
根据Python的定义 将引发断言错误 

697
00:34:00,170 --> 00:34:02,180
因此 这两者是协同工作的 

698
00:34:02,180 --> 00:34:06,920
那些错误 那些断言错误 仍然由我的代码引发

699
00:34:06,920 --> 00:34:09,320
在这里 当这些代码行中的任何一行失败时 

700
00:34:09,320 --> 00:34:12,139
然而 PYTEST这个第三方库 

701
00:34:12,139 --> 00:34:16,639
正在为我处理自动捕获这些异常的过程 

702
00:34:16,639 --> 00:34:18,810
以便给我这个标准的输出 

703
00:34:18,810 --> 00:34:22,488
因此 我们从自己真正实现单元测试开始了今天的故事 

704
00:34:22,488 --> 00:34:23,780
所有的代码都是我自己写的 

705
00:34:23,780 --> 00:34:24,440
我写了Main 

706
00:34:24,440 --> 00:34:25,400
我做了我的附带条件 

707
00:34:25,400 --> 00:34:26,540
我确实试过了 除了 

708
00:34:26,540 --> 00:34:29,277
老实说 编写测试将变得非常痛苦

709
00:34:29,277 --> 00:34:32,360
长期而言 如果你和我每次都要写那么多代码 特别是

710
00:34:32,360 --> 00:34:34,010
当我们的功能这么小的时候 

711
00:34:34,010 --> 00:34:38,239
因此 PYTEST和类似的单元测试框架可以自动完成很多工作 

712
00:34:38,239 --> 00:34:43,460
本质上 PYTEST为您添加了try、Except、If和指纹 

713
00:34:43,460 --> 00:34:46,580
因此 您可以只关注测试的本质 即

714
00:34:46,580 --> 00:34:49,130
真正的是这些输入和输出 

715
00:34:49,130 --> 00:34:52,980
这里还有一个关于单元测试的问题 你觉得呢？

716
00:34:52,980 --> 00:35:00,320
演讲者8：所以当我们输入-x或-5的平方时 

717
00:35:00,320 --> 00:35:03,270
这个数字的平方根就出来了 

718
00:35:03,270 --> 00:35:07,460
但当我们把6.6或5.6放入这个整数时 

719
00:35:07,460 --> 00:35:11,370
则行显示错误 

720
00:35:11,370 --> 00:35:13,590
那么那里发生了什么呢？

721
00:35:13,590 --> 00:35:16,850
大卫·马兰：所以我现在故意测试整数 

722
00:35:16,850 --> 00:35:19,953
很大程度上是因为我只想让POW对整数进行运算 

723
00:35:19,953 --> 00:35:23,120
这可能会在Python的文档或我自己的文档中传达出来

724
00:35:23,120 --> 00:35:24,050
来完成这项任务 

725
00:35:24,050 --> 00:35:26,850
如果你要传递其他东西 比如一个花车 

726
00:35:26,850 --> 00:35:30,920
事实证明 Python和其他语言中的浮点值

727
00:35:30,920 --> 00:35:33,150
实际上非常困难 如果不是不可能的话 

728
00:35:33,150 --> 00:35:35,420
以100%准确地代表 

729
00:35:35,420 --> 00:35:39,020
因此 如果你试图将其与其他价值进行比较 

730
00:35:39,020 --> 00:35:41,900
因此 可能会有轻微的舍入误差 

731
00:35:41,900 --> 00:35:43,940
我只是根据你所描述的推断 

732
00:35:43,940 --> 00:35:47,480
但我现在非常有意地测试这个函数 只使用输入

733
00:35:47,480 --> 00:35:48,680
这是我所期待的 

734
00:35:48,680 --> 00:35:53,300
如果传递了其他输入 它确实可能抛出其他错误 

735
00:35:53,300 --> 00:35:56,240
请允许我提议我们考虑一下如果双方达成协议

736
00:35:56,240 --> 00:35:58,100
实际上并没有传递一个数字 

737
00:35:58,100 --> 00:36:01,100
例如 如果我返回到culator.py 

738
00:36:01,100 --> 00:36:04,730
假设我 或者其他使用平方函数的人 

739
00:36:04,730 --> 00:36:09,020
只是忘记将输入的返回值从字符串转换为整型 

740
00:36:09,020 --> 00:36:11,270
例如 将行修改为此处 

741
00:36:11,270 --> 00:36:14,870
现在 如果我输入一个字符串 肯定会出错

742
00:36:14,870 --> 00:36:16,910
而不是看起来是整型的 

743
00:36:16,910 --> 00:36:18,980
例如 如果我在这里清除我的终端 

744
00:36:18,980 --> 00:36:22,250
运行culator.py的Python并按Enter--

745
00:36:22,250 --> 00:36:26,220
让我们输入cat作为x的值--当然 

746
00:36:26,220 --> 00:36:27,570
这现在引发了一个类型错误 

747
00:36:27,570 --> 00:36:28,070
为什么？

748
00:36:28,070 --> 00:36:30,620
不能将序列与类型为‘str.’的非int相乘 

749
00:36:30,620 --> 00:36:31,700
那是什么意思？

750
00:36:31,700 --> 00:36:35,000
你不能做猫乘以猫 因为事实上 正方形是

751
00:36:35,000 --> 00:36:36,860
期待这一结局的将是一些数字 

752
00:36:36,860 --> 00:36:39,650
但这并不一定意味着Square本身就有漏洞 

753
00:36:39,650 --> 00:36:43,070
但这确实意味着 如果我预计会引发类型错误 

754
00:36:43,070 --> 00:36:47,790
让我们也对此进行测试 这样我就知道行为确实像预期的那样工作 

755
00:36:47,790 --> 00:36:53,070
因此 让我回到test_culator.py 然后添加第四个测试

756
00:36:53,070 --> 00:36:53,570
这里 

757
00:36:53,570 --> 00:36:56,240
定义测试下划线如何 我将

758
00:36:56,240 --> 00:36:59,510
将其称为test_str 因为我将明确而有意地通过

759
00:36:59,510 --> 00:37:01,080
在用于测试的字符串中 

760
00:37:01,080 --> 00:37:06,290
我想在精神上断言 像猫对方这样的传球

761
00:37:06,290 --> 00:37:08,030
将引发类型错误 

762
00:37:08,030 --> 00:37:10,550
但是我们没有使用ASSERT关键字 

763
00:37:10,550 --> 00:37:11,630
相反 我们需要这个 

764
00:37:11,630 --> 00:37:14,570
让我转到此文件的顶部 并让我另外

765
00:37:14,570 --> 00:37:18,020
导入pytest库本身 因为它被证明

766
00:37:18,020 --> 00:37:20,180
在该库中有一个名为

767
00:37:20,180 --> 00:37:25,280
引发 这使我能够表示我希望引发异常 

768
00:37:25,280 --> 00:37:29,330
我可以用下面的pytest来表达这一点 

769
00:37:29,330 --> 00:37:33,180
然后在括号中 我可以传递我期望的异常类型 

770
00:37:33,180 --> 00:37:35,720
在这种情况下 这将是一个类型错误 

771
00:37:35,720 --> 00:37:38,720
现在 我应该在什么时候引发该类型错误呢？

772
00:37:38,720 --> 00:37:42,320
每当我做一些事情 比如调用Square 而不是传入数字时 

773
00:37:42,320 --> 00:37:44,150
但有点像猫 

774
00:37:44,150 --> 00:37:46,380
所以现在如果我回到我的终端窗口 

775
00:37:46,380 --> 00:37:51,050
运行测试计算器.py的pytest 这一次有四个测试 

776
00:37:51,050 --> 00:37:55,880
我应该看到现在所有四个都是成功的 

777
00:37:55,880 --> 00:37:59,870
现在让我们考虑如何测试不只是期望数字的代码

778
00:37:59,870 --> 00:38:02,000
作为输入 但实际上是字符串 

779
00:38:02,000 --> 00:38:04,640
让我在VS Code中及时回顾一下

780
00:38:04,640 --> 00:38:09,380
对于第一个程序 我们编写了几个不同版本的in hello.py

781
00:38:09,380 --> 00:38:11,610
它最终看起来有点像这样 

782
00:38:11,610 --> 00:38:14,480
我有一个主功能 可以提示用户

783
00:38:14,480 --> 00:38:18,020
通过问他们“你叫什么名字？”来获取变量的值 

784
00:38:18,020 --> 00:38:19,050
问号 

785
00:38:19,050 --> 00:38:21,650
然后我们继续前进 做了一些类似于打招呼的事情 

786
00:38:21,650 --> 00:38:26,570
打开Paren name 将该用户名传递给一个名为Hello的函数 

787
00:38:26,570 --> 00:38:30,210
现在函数Hello recall最终看起来是这样的 

788
00:38:30,210 --> 00:38:33,530
我们将Hello定义为接受一个名为to的参数 

789
00:38:33,530 --> 00:38:37,850
其缺省值为World 且该函数非常简单

790
00:38:37,850 --> 00:38:41,780
打印问候 后跟逗号 然后什么都行

791
00:38:41,780 --> 00:38:43,310
已传入的名称 

792
00:38:43,310 --> 00:38:46,520
然后我们最终调用了Main 但现在开始 

793
00:38:46,520 --> 00:38:48,650
如果有条件 我会一直加上这一点 

794
00:38:48,650 --> 00:38:53,360
如果名称等于等于下划线Main 则仅当

795
00:38:53,360 --> 00:38:54,380
我要不要给Main打电话 

796
00:38:54,380 --> 00:38:58,580
所以这基本上就是这个程序在上一次化身中的样子 

797
00:38:58,580 --> 00:39:00,560
我们该如何进行测试呢？

798
00:39:00,560 --> 00:39:03,800
在这里 我也不打算在main中测试用户的输入本身 

799
00:39:03,800 --> 00:39:07,580
我将真正集中在代码模块上

800
00:39:07,580 --> 00:39:10,220
这就是我们感兴趣的 这就是Hello函数本身 

801
00:39:10,220 --> 00:39:14,420
我如何开始测试Hello函数？

802
00:39:14,420 --> 00:39:19,550
不幸的是 即使我开始做一些类似于测试hello.py的代码--

803
00:39:19,550 --> 00:39:22,340
让我开始着手编写一个测试程序--

804
00:39:22,340 --> 00:39:26,210
我可以从我的Hello程序中导入一个名为Hello的函数 

805
00:39:26,210 --> 00:39:28,700
所以从问候导入中看到有点奇怪

806
00:39:28,700 --> 00:39:32,900
您好 但是请注意 在这一行 我是从模块导入的--

807
00:39:32,900 --> 00:39:36,680
这就是名为hello.py的文件--名为Hello的函数 

808
00:39:36,680 --> 00:39:40,400
我该如何进行测试呢？

809
00:39:40,400 --> 00:39:46,610
如果我有一个像定义测试参数这样的函数--

810
00:39:46,610 --> 00:39:48,090
让我来做吧 

811
00:39:48,090 --> 00:39:53,510
那么 如果我要定义一个函数 比如定义TEST_HELLO 我该怎么办呢？

812
00:39:53,510 --> 00:39:59,840
我可以用引号 不带引号 说“大卫”来打招呼

813
00:39:59,840 --> 00:40:04,760
然后检查它是否等于 “你好 大卫 ”

814
00:40:04,760 --> 00:40:07,400
那么 这种方法在这里行得通吗？

815
00:40:07,400 --> 00:40:10,730
如果我已经编写了一个名为test_Hello的测试 那么

816
00:40:10,730 --> 00:40:14,240
使用david参数调用Hello 然后测试其返回值 

817
00:40:14,240 --> 00:40:19,820
就像我们对我们的计算器所做的那样 这会像写的那样工作吗？

818
00:40:19,820 --> 00:40:22,370
让我稍后回到这个版本

819
00:40:22,370 --> 00:40:23,730
我们正在测试的问候 

820
00:40:23,730 --> 00:40:25,550
所以你可以看到函数Hello 

821
00:40:25,550 --> 00:40:27,380
这就是测试 

822
00:40:27,380 --> 00:40:29,900
以下是实际的代码 

823
00:40:29,900 --> 00:40:32,900
这项测试现在会奏效吗？

824
00:40:32,900 --> 00:40:34,010
有什么想法吗？

825
00:40:34,010 --> 00:40:38,060
演讲者9：我认为问题在于 在hello.py的第一个版本中 

826
00:40:38,060 --> 00:40:42,860
您使用的是您第一次声明的to参数 当您声明

827
00:40:42,860 --> 00:40:47,070
函数 而不是使用名称 

828
00:40:47,070 --> 00:40:50,580
大卫·马兰：这在这里实际上不是一个错误 

829
00:40:50,580 --> 00:40:53,730
所以让我规定在hello.py中 这段代码实际上

830
00:40:53,730 --> 00:40:54,863
确实如预期的那样工作 

831
00:40:54,863 --> 00:40:57,780
让我继续手动测试 只是为了演示一下 

832
00:40:57,780 --> 00:41:03,610
让我运行hello.py的Python 输入我的名字D-A-V-I-D 我看到了 

833
00:41:03,610 --> 00:41:05,280
事实上 它是在说 “你好 大卫 ”

834
00:41:05,280 --> 00:41:07,560
不过 如果我改变这个计划 

835
00:41:07,560 --> 00:41:11,460
去掉name参数 去掉name变量 

836
00:41:11,460 --> 00:41:14,790
然后再次调用Hello 运行hello.py的Python 

837
00:41:14,790 --> 00:41:17,700
这一次我甚至没有得到提示 因为我摆脱了我的输入电话 

838
00:41:17,700 --> 00:41:19,740
但它的表现确实符合我的预期 

839
00:41:19,740 --> 00:41:21,660
它确实在说“你好 世界 ”

840
00:41:21,660 --> 00:41:26,820
因此 让我规定当前形式的代码实际上是正确的 

841
00:41:26,820 --> 00:41:30,310
但我的测试并没有像我希望的那样奏效 

842
00:41:30,310 --> 00:41:38,310
我的Hello函数之间有一个细微的区别

843
00:41:38,310 --> 00:41:41,490
我的平方函数可以解释 

844
00:41:41,490 --> 00:41:45,420
为什么这项测试可能不会像预期的那样有效？

845
00:41:45,420 --> 00:41:47,445
演讲者10：因为它没有返回值 

846
00:41:47,445 --> 00:41:48,570
大卫·马兰：是的 确实如此 

847
00:41:48,570 --> 00:41:50,850
回想一下我们早先关于函数的讨论 

848
00:41:50,850 --> 00:41:54,420
函数可以返回值 就像我的方形函数Hands

849
00:41:54,420 --> 00:41:56,580
你支持有一定价值的平方 否则他们

850
00:41:56,580 --> 00:41:59,425
可能会有副作用 一种视觉假象

851
00:41:59,425 --> 00:42:02,550
这可能会发生在屏幕上 就像在屏幕上打印一些东西一样 

852
00:42:02,550 --> 00:42:05,290
根据定义 这就是印刷品的工作方式 

853
00:42:05,290 --> 00:42:08,550
注意Hello 它很短 但它最终实现了

854
00:42:08,550 --> 00:42:12,240
使用print函数 该函数并不像我在这里使用的那样返回值 

855
00:42:12,240 --> 00:42:15,510
相反 它的副作用是将一些东西打印到屏幕上 

856
00:42:15,510 --> 00:42:19,110
所以在我的测试函数中检查是不正确的

857
00:42:19,110 --> 00:42:23,820
如果Hello的返回值等于Hello David 

858
00:42:23,820 --> 00:42:26,280
因为再说一次 Hello不会返回任何内容 

859
00:42:26,280 --> 00:42:28,050
它是在打印一些东西 那种副作用 

860
00:42:28,050 --> 00:42:31,350
但请注意 从字面上看 它没有Return关键字 

861
00:42:31,350 --> 00:42:34,290
不像我的平方函数 它做到了 

862
00:42:34,290 --> 00:42:37,440
所以这是一个或许可以改变的机会

863
00:42:37,440 --> 00:42:41,040
我是如何实现我的实际功能的 

864
00:42:41,040 --> 00:42:44,790
事实证明 随着您的程序变得越来越复杂 越来越

865
00:42:44,790 --> 00:42:47,730
更复杂的是 最好不要

866
00:42:47,730 --> 00:42:50,250
如果你能避免的话会有副作用 

867
00:42:50,250 --> 00:42:52,650
尤其是如果您希望您的代码是可测试的 

868
00:42:52,650 --> 00:42:56,910
事实上 我将建议我们更改我的Hello程序以使其正常工作

869
00:42:56,910 --> 00:42:57,850
具体如下 

870
00:42:57,850 --> 00:43:03,180
让我继续更改该函数 不再打印问候和姓名 

871
00:43:03,180 --> 00:43:05,760
让我继续下去 也许真的会回来

872
00:43:05,760 --> 00:43:09,210
一个F字符串 它将使这一点变得更清楚 你好逗号

873
00:43:09,210 --> 00:43:11,970
在结尾用引号结束 

874
00:43:11,970 --> 00:43:15,540
所以我这里的语法就是熟悉的f字符串或格式字符串 

875
00:43:15,540 --> 00:43:19,800
它将返回Hello、World或Hello、David或Hello 不管是谁的名字

876
00:43:19,800 --> 00:43:23,010
作为该参数传入 但我现在返回它 

877
00:43:23,010 --> 00:43:24,810
我不会把它打印出来的 

878
00:43:24,810 --> 00:43:27,480
那么 这里需要改变的是什么呢？

879
00:43:27,480 --> 00:43:29,560
我可以做这样的事 

880
00:43:29,560 --> 00:43:33,000
我可以这样说 产出等于你好

881
00:43:33,000 --> 00:43:35,940
然后在我的Main函数中打印输出 

882
00:43:35,940 --> 00:43:38,880
或者我可以简化它 因为我并不真的需要这个变量 

883
00:43:38,880 --> 00:43:40,560
我可以干脆这么做 

884
00:43:40,560 --> 00:43:44,700
我仍然可以打个招呼 但我可以立即把结果打印出来 

885
00:43:44,700 --> 00:43:49,500
现在 我的Hello程序的这个版本实际上更易于测试 

886
00:43:49,500 --> 00:43:50,040
为什么？

887
00:43:50,040 --> 00:43:52,440
因为我们使用的这些断言语句 

888
00:43:52,440 --> 00:43:54,930
到目前为止我们的测试 真的是

889
00:43:54,930 --> 00:44:00,150
旨在测试函数中的参数并返回值

890
00:44:00,150 --> 00:44:02,450
它们来自 不是测试副作用 

891
00:44:02,450 --> 00:44:05,700
所以如果你做的是等于 你在寻找一个返回值 

892
00:44:05,700 --> 00:44:07,390
这是从函数返回的 

893
00:44:07,390 --> 00:44:08,340
所以这很好 

894
00:44:08,340 --> 00:44:11,970
如果我现在修改我的程序设计 不只是打印问候 

895
00:44:11,970 --> 00:44:17,400
但要返回我想要构建的字符串、句子和短语 

896
00:44:17,400 --> 00:44:19,290
我可以把它留给打电话的人--

897
00:44:19,290 --> 00:44:22,170
这就是使用Hello函数的函数--

898
00:44:22,170 --> 00:44:24,090
来处理实际的打印 

899
00:44:24,090 --> 00:44:25,830
这在我的代码中意味着什么？

900
00:44:25,830 --> 00:44:28,800
这意味着如果我的hello.py看起来像这样 

901
00:44:28,800 --> 00:44:33,000
在我的test_Hello函数中 Hello确实返回了一个值 

902
00:44:33,000 --> 00:44:35,320
我可以完全像这样测试它 

903
00:44:35,320 --> 00:44:38,970
因此 让我继续运行test_hello.py的pytest 

904
00:44:38,970 --> 00:44:42,300
像往常一样 我的手指交叉 瞧 一个过去了 

905
00:44:42,300 --> 00:44:45,240
所以我通过了这项测试 因为显然Hello的返回值

906
00:44:45,240 --> 00:44:48,300
确实等于“你好 大卫 ”

907
00:44:48,300 --> 00:44:49,920
让我们测试另一个场景 

908
00:44:49,920 --> 00:44:53,190
如果我在没有任何参数的情况下调用Hello会怎么样？

909
00:44:53,190 --> 00:44:56,730
让我们断言 在这些括号中没有任何内容的情况下呼叫Hello

910
00:44:56,730 --> 00:45:00,690
类似地 等于问候逗号 但世界 缺省值 

911
00:45:00,690 --> 00:45:04,560
现在让我继续运行test_hello.py的pytest 

912
00:45:04,560 --> 00:45:07,020
而这也完全过去了 

913
00:45:07,020 --> 00:45:09,780
但在这一点上 假设我犯了一些错误 

914
00:45:09,780 --> 00:45:12,030
假设我的代码中有一个错误 

915
00:45:12,030 --> 00:45:15,610
在这一个函数中组合多个测试可能不是最佳实践 

916
00:45:15,610 --> 00:45:18,330
因此 让我们更清楚地知道什么可能通过 什么可能失败 

917
00:45:18,330 --> 00:45:22,350
让我们调用第一个函数来测试此函数的缺省值 

918
00:45:22,350 --> 00:45:24,660
让我们只包含这第一行代码 

919
00:45:24,660 --> 00:45:28,140
然后让我们继续定义另一个函数 比如test_argument 

920
00:45:28,140 --> 00:45:30,730
来测试这里的另一行代码 

921
00:45:30,730 --> 00:45:32,820
所以现在我有两种不同的测试 每一种

922
00:45:32,820 --> 00:45:35,620
正在测试一些从根本上不同的东西 

923
00:45:35,620 --> 00:45:38,430
所以现在当我运行我的代码时 它仍然没有损坏 

924
00:45:38,430 --> 00:45:43,740
如果我运行test_hello.py的pytest 输入 我现在已经通过了两个测试 

925
00:45:43,740 --> 00:45:45,800
这和以前一样好 

926
00:45:45,800 --> 00:45:49,220
但如果我真的有缺陷 有两次测试而不是一次

927
00:45:49,220 --> 00:45:54,000
或许会给我更多一点关于哪里出了问题的提示 

928
00:45:54,000 --> 00:45:57,570
现在关于返回值测试的问题 

929
00:45:57,570 --> 00:46:00,720
当这些返回值现在是字符串而不是整数时

930
00:46:00,720 --> 00:46:02,310
我们为什么要这么做？

931
00:46:02,310 --> 00:46:07,050
演讲者11：所以我的问题是关于函数内部的函数 

932
00:46:07,050 --> 00:46:14,020
我们能不能也测试一下 或者我们还没见过的递归呢？

933
00:46:14,020 --> 00:46:17,200
David Malan：如果你有一个递归函数 我们还没有

934
00:46:17,200 --> 00:46:19,330
在这节课上讨论过的 是的 你绝对可以

935
00:46:19,330 --> 00:46:23,530
也可以通过简单地以这种方式调用它们来测试它们 

936
00:46:23,530 --> 00:46:25,603
递归不会影响此过程 

937
00:46:25,603 --> 00:46:27,520
下面是关于单元测试的另一个问题

938
00:46:27,520 --> 00:46:29,890
在我们看最后一个例子之前？

939
00:46:29,890 --> 00:46:34,780
演讲者12：在检验我们的论点时 我们可以

940
00:46:34,780 --> 00:46:41,220
使用循环之类的东西 还是在资产内部使用 或者用于价值？

941
00:46:41,220 --> 00:46:42,220
大卫·马兰：当然 

942
00:46:42,220 --> 00:46:45,100
您绝对可以使用循环来测试多个值 

943
00:46:45,100 --> 00:46:48,200
例如 在这种情况下 我可以做这样的事情 

944
00:46:48,200 --> 00:46:57,730
我可以在下面赫敏的名单上说出名字 比如说 哈利和罗恩 

945
00:46:57,730 --> 00:47:02,830
然后 我可以在这个循环中断言给定名称的Hello等于

946
00:47:02,830 --> 00:47:08,680
等于 比方说 Hello、逗号名称、

947
00:47:08,680 --> 00:47:13,390
然后在这里一次运行所有这些 再次运行 

948
00:47:13,390 --> 00:47:15,160
Test_hello.py的pytest 

949
00:47:15,160 --> 00:47:17,865
这仍然只是该功能中的一项测试 

950
00:47:17,865 --> 00:47:20,740
但如果这几根弦有什么有趣的地方 

951
00:47:20,740 --> 00:47:23,440
使得测试所有这些功能变得很有说服力 您完全可以

952
00:47:23,440 --> 00:47:24,860
以这种方式自动执行测试 

953
00:47:24,860 --> 00:47:27,520
也就是说 理想情况下 您的每一项测试都应该

954
00:47:27,520 --> 00:47:30,040
要非常简单 也要非常小 

955
00:47:30,040 --> 00:47:30,580
为什么？

956
00:47:30,580 --> 00:47:32,630
因为你不想写太多代码 

957
00:47:32,630 --> 00:47:35,860
如此复杂的代码 以至于您的测试可能存在缺陷 

958
00:47:35,860 --> 00:47:38,890
我们不想做的是为我们的测试和测试编写测试

959
00:47:38,890 --> 00:47:41,240
为了我们的测试 因为它永远不会结束 

960
00:47:41,240 --> 00:47:44,023
因此 让测试保持良好和简单才是真正的目标 

961
00:47:44,023 --> 00:47:45,940
所以一个有理智的人 包括你自己 

962
00:47:45,940 --> 00:47:49,630
可以盯着他们看 然后声称 是的 这是正确的 

963
00:47:49,630 --> 00:47:51,973
我们的测试不需要测试 

964
00:47:51,973 --> 00:47:53,140
还有一项功能呢？

965
00:47:53,140 --> 00:47:56,560
假设我们不只有一项测试 而是有许多不同的测试 

966
00:47:56,560 --> 00:47:59,920
我们希望开始将这些测试组织到多个文件中 甚至

967
00:47:59,920 --> 00:48:00,580
一个文件夹 

968
00:48:00,580 --> 00:48:03,740
Pytest和其他框架也支持这一范例 

969
00:48:03,740 --> 00:48:08,127
事实上 让我继续使用测试文件夹测试hello.py 

970
00:48:08,127 --> 00:48:09,960
从技术上讲只有一次测试 但它会

971
00:48:09,960 --> 00:48:12,520
代表那个文件夹里有更多的东西 

972
00:48:12,520 --> 00:48:15,700
接下来 我将创建一个名为test的新文件夹

973
00:48:15,700 --> 00:48:18,040
在我的命令行中使用mkdir 

974
00:48:20,315 --> 00:48:23,440
然后在该文件夹中 我将继续创建一个名为

975
00:48:23,440 --> 00:48:25,510
Test_hello.py 

976
00:48:25,510 --> 00:48:28,490
同时 在这个文件中 我将测试相同的东西 

977
00:48:28,490 --> 00:48:31,970
所以我将继续 从Hello开始 导入Hello 

978
00:48:31,970 --> 00:48:36,260
接下来 我将定义一个类似于测试默认设置的函数

979
00:48:36,260 --> 00:48:39,710
简单地测试不带参数的Hello的场景

980
00:48:39,710 --> 00:48:41,600
返回您好 逗号世界 

981
00:48:41,600 --> 00:48:43,610
我将拥有另一个功能 即

982
00:48:43,610 --> 00:48:45,802
我测试是否传递了一个参数 

983
00:48:45,802 --> 00:48:47,510
在这种情况下 我会选择一个论点

984
00:48:47,510 --> 00:48:50,360
比如断言 你好 引用 引用 大卫 

985
00:48:50,360 --> 00:48:54,740
等于 确实 你好 逗号 不是世界 而是大卫 

986
00:48:54,740 --> 00:48:57,440
因此 在这个例子中 我刚刚重新创建了与前面相同的测试 

987
00:48:57,440 --> 00:49:01,220
但它们现在位于一个名为TEST的文件夹中 

988
00:49:01,220 --> 00:49:03,260
PYTEST也允许我在这里运行这些程序 

989
00:49:03,260 --> 00:49:06,500
但要做到这一点 我实际上需要创建另一个文件 

990
00:49:06,500 --> 00:49:14,780
在我的测试目录中 我需要创建一个名为__init__.py的文件 

991
00:49:14,780 --> 00:49:18,200
它的效果是 即使这个文件是空的 

992
00:49:18,200 --> 00:49:24,230
告诉Python不仅要将该文件夹视为一个模块 还要将其视为一个包 

993
00:49:24,230 --> 00:49:25,190
可以这么说 

994
00:49:25,190 --> 00:49:28,340
包是一个或多个Python模块

995
00:49:28,340 --> 00:49:30,560
它们被组织在一个文件夹内 

996
00:49:30,560 --> 00:49:36,860
而这个名为__init__.py的文件只是一个可视指示器 用于指示Python确实

997
00:49:36,860 --> 00:49:39,170
它应该将该文件夹视为一个包 

998
00:49:39,170 --> 00:49:41,960
如果这个文件夹中有更多的代码 我可以做更多的事情

999
00:49:41,960 --> 00:49:42,683
用这份文件 

1000
00:49:42,683 --> 00:49:44,600
但就目前而言 这只是一个线索 表明它确实是

1001
00:49:44,600 --> 00:49:48,530
意味着是一个包 而不仅仅是一个模块或文件 

1002
00:49:48,530 --> 00:49:53,360
最后 我可以做的是运行pytest 而不是在该特定文件上运行 

1003
00:49:53,360 --> 00:49:55,460
而是一大堆测试 

1004
00:49:55,460 --> 00:50:00,920
因此 如果我运行pytest of test 其中test是该文件夹的名称 

1005
00:50:00,920 --> 00:50:03,530
PYTEST将自动搜索该文件夹 查找

1006
00:50:03,530 --> 00:50:07,650
对于所有可能的测试 假设只有这两个人在这个文件中 

1007
00:50:07,650 --> 00:50:11,480
但是 当我现在用Enter键运行它时 我仍然可以通过这些测试 

1008
00:50:11,480 --> 00:50:12,960
我还是会拿到100%的 

1009
00:50:12,960 --> 00:50:16,280
最终 我现在有了一种机制来测试我自己的代码 

1010
00:50:16,280 --> 00:50:19,580
因此 无论您是在编写返回整数的函数还是其他函数 

1011
00:50:19,580 --> 00:50:22,490
具有可重写为函数的副作用的函数

1012
00:50:22,490 --> 00:50:24,350
返回值 您现在就有了一种机制

1013
00:50:24,350 --> 00:50:27,740
不仅仅是等待 一个 像我们这样的人来测试你的代码

1014
00:50:27,740 --> 00:50:30,380
而不仅仅是一次又一次地手动测试代码 这

1015
00:50:30,380 --> 00:50:32,360
可能会变得单调乏味 你可能会犯错误

1016
00:50:32,360 --> 00:50:34,670
通过不包括一些可能的输入 我们现在

1017
00:50:34,670 --> 00:50:37,970
有一种自动机制来测试自己的代码 这是

1018
00:50:37,970 --> 00:50:41,100
当你开始与他人合作时 你会变得更加强大

1019
00:50:41,100 --> 00:50:44,030
这样您就可以编写测试 以确保如果它们

1020
00:50:44,030 --> 00:50:47,870
更改相同的代码 他们还没有破解您已经破译的代码

1021
00:50:47,870 --> 00:50:48,990
写的 

1022
00:50:48,990 --> 00:50:50,040
本周就到这里吧 

1023
00:50:50,040 --> 00:50:52,240
我们下次再见 

