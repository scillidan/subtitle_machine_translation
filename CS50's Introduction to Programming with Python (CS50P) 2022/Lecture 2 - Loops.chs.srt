1
00:00:00,000 --> 00:00:03,451
[音乐播放]

2
00:00:24,160 --> 00:00:25,180
大卫·马兰：好的 

3
00:00:25,180 --> 00:00:28,540
这是CS50的S介绍用PYTHON编程 

4
00:00:28,540 --> 00:00:33,010
我的名字是David Malan 这周我们主要关注循环 这是Python中的这一功能

5
00:00:33,010 --> 00:00:37,000
以及许多其他编程语言来一次又一次地做一些事情 

6
00:00:37,000 --> 00:00:38,500
这是一种循环 

7
00:00:38,500 --> 00:00:40,420
让我们看看我们能不能从激励

8
00:00:40,420 --> 00:00:45,310
这就是为什么我们有这种能力 使用这些循环循环地做事情 

9
00:00:45,310 --> 00:00:48,130
我将在这里继续 打开VS代码 

10
00:00:48,130 --> 00:00:50,260
在我的终端窗口中 让我们继续

11
00:00:50,260 --> 00:00:57,100
并通过代码cat.py进行创建 这是一个像猫一样发出猫叫声的Python程序 

12
00:00:57,100 --> 00:01:00,910
我将在这个代码选项卡中继续 可能非常简单 

13
00:01:00,910 --> 00:01:03,760
我将从使用打印来实现这个CAT开始 

14
00:01:03,760 --> 00:01:06,010
我们要让这只猫不发出声音 

15
00:01:06,010 --> 00:01:08,860
但只要在屏幕上打印三次猫咪、猫咪、猫咪就可以了 

16
00:01:08,860 --> 00:01:12,640
我想我能做到的最简单的方法就是打印猫咪一次 

17
00:01:12,640 --> 00:01:18,590
并再次打印猫咪 并在屏幕上打印最后一次猫咪 

18
00:01:18,590 --> 00:01:23,320
现在让我转到我的终端窗口 让我运行cat.py的Python 

19
00:01:23,320 --> 00:01:25,480
进来 然后叫 叫 叫 

20
00:01:25,480 --> 00:01:27,670
好了 这个程序起作用了 

21
00:01:27,670 --> 00:01:31,120
如果我的目标是让猫叫三次 这个程序确实有效 

22
00:01:31,120 --> 00:01:34,280
让我向你求婚 只是为了帮助我们

23
00:01:34,280 --> 00:01:36,430
计算机内部发生了什么 让我们

24
00:01:36,430 --> 00:01:38,810
我建议我们考虑这个流程图 

25
00:01:38,810 --> 00:01:40,810
所以像以前一样 我们有这个流程图 

26
00:01:40,810 --> 00:01:44,140
从这个椭圆形开始 意思就是从这里开始阅读 

27
00:01:44,140 --> 00:01:50,050
然后注意 它通过箭头发出猫叫声 然后停止 

28
00:01:50,050 --> 00:01:53,890
这是完全正确的 老实说 它非常简单 

29
00:01:53,890 --> 00:01:58,090
但我敢说 不管怎样 我们还是可以找出我的代码的错误 

30
00:01:58,090 --> 00:02:03,550
为什么我的代码可以说是设计得很差？

31
00:02:03,550 --> 00:02:05,680
现在 答案将是某种程度上的循环 

32
00:02:05,680 --> 00:02:08,169
但让我们看看我们能不能用什么方式

33
00:02:08,169 --> 00:02:12,950
在某种意义上 代码实际上设计得很差 

34
00:02:12,950 --> 00:02:13,660
让我们看看 

35
00:02:13,660 --> 00:02:14,260
任何想法 

36
00:02:14,260 --> 00:02:15,608
亚历克斯？

37
00:02:15,608 --> 00:02:16,150
观众：好的 

38
00:02:16,150 --> 00:02:21,580
所以 我的意思是 重复同样的动作三次甚至更多

39
00:02:21,580 --> 00:02:23,095
不是一个好习惯 

40
00:02:23,095 --> 00:02:24,970
大卫·马兰：是的 我只是在重复我自己 

41
00:02:24,970 --> 00:02:27,340
老实说 这没什么大不了的 

42
00:02:27,340 --> 00:02:31,780
如果我们在这里回到我的代码 我真的做了一件坏事吗

43
00:02:31,780 --> 00:02:34,180
只要打印三次猫叫 猫叫 猫叫就可以了？

44
00:02:34,180 --> 00:02:37,250
不完全是 但让我们考虑一下这一点的逻辑扩展 

45
00:02:37,250 --> 00:02:43,510
假设我想叫四次、五次、50次或500次 

46
00:02:43,510 --> 00:02:46,150
你真的认为 即使你以前从来没有编程过 

47
00:02:46,150 --> 00:02:50,350
这个问题的解决方案真的是点击复制粘贴50次吗？

48
00:02:50,350 --> 00:02:51,310
大概不会吧 

49
00:02:51,310 --> 00:02:52,840
我们或许可以做得更好 

50
00:02:52,840 --> 00:02:54,850
在这一点上 除了丑陋之外 

51
00:02:54,850 --> 00:02:57,732
有这么多行相同的代码 只是

52
00:02:57,732 --> 00:02:59,440
想象一下 如果您想要更改代码 

53
00:02:59,440 --> 00:03:02,607
也许我改变主意了 我不想养猫 我想养狗 

54
00:03:02,607 --> 00:03:04,930
所以现在它不得不多次说汪汪 汪汪 汪汪 

55
00:03:04,930 --> 00:03:07,780
现在我必须在50个不同的地方改变这一点 

56
00:03:07,780 --> 00:03:10,030
是的 当然 我可以找到并替换 

57
00:03:10,030 --> 00:03:12,070
但得了吧 就像我们现在是程序员一样 

58
00:03:12,070 --> 00:03:15,080
一定有更好的方法而不是重复我们自己 

59
00:03:15,080 --> 00:03:18,400
所以我敢打赌 如果我们稍微考虑一下 我们可以做得更好

60
00:03:18,400 --> 00:03:22,960
我们如何构建这个项目就更加困难了 

61
00:03:22,960 --> 00:03:26,750
只要我们稍微增加一点词汇量 我们就能做到这一点 

62
00:03:26,750 --> 00:03:28,870
事实证明 在Python和其他语言中 

63
00:03:28,870 --> 00:03:31,270
还有一个关键字叫做While 

64
00:03:31,270 --> 00:03:34,960
虽然这是我们可以表达所谓的循环的一种方式 

65
00:03:34,960 --> 00:03:38,530
一段代码 它将一次又一次地做一些事情--

66
00:03:38,530 --> 00:03:43,480
0倍 1倍 2倍 50倍 想要多少倍就多少倍 

67
00:03:43,480 --> 00:03:48,520
而是把细节留给我们

68
00:03:48,520 --> 00:03:52,010
关于我们如何一次又一次地表达自己去做某事 

69
00:03:52,010 --> 00:03:56,260
所以让我回到VS代码 让我提议我这样做 

70
00:03:56,260 --> 00:04:01,765
While是一个允许我一遍又一遍地问问题的结构 

71
00:04:01,765 --> 00:04:03,640
任何时候我们看到一个问题 它都是

72
00:04:03,640 --> 00:04:07,180
以布尔表达式的形式 问题的答案是

73
00:04:07,180 --> 00:04:08,900
对或错 

74
00:04:08,900 --> 00:04:10,250
我怎么能这么做呢？

75
00:04:10,250 --> 00:04:15,340
我怎么能打印三次猫咪 问三次问题呢？

76
00:04:15,340 --> 00:04:18,079
答案是真的还是假的？

77
00:04:18,079 --> 00:04:20,110
好吧 如果我数一数呢？

78
00:04:20,110 --> 00:04:21,560
就像真的在我手指上一样 

79
00:04:21,560 --> 00:04:25,360
如果我试着从三个倒数 我想猫叫三次 

80
00:04:25,360 --> 00:04:28,060
我可以竖起三根手指 然后我就会叫了 

81
00:04:28,060 --> 00:04:31,342
然后我可以把其中一根手指放下来 然后猫叫 

82
00:04:31,342 --> 00:04:33,550
我可以把其中一根手指放下来 然后我就能猫叫了 

83
00:04:33,550 --> 00:04:34,870
把其中一根手指放下 

84
00:04:34,870 --> 00:04:38,200
也许我每次猫叫的时候都会问这个问题

85
00:04:38,200 --> 00:04:40,840
是 我还能竖起手指吗？

86
00:04:40,840 --> 00:04:42,370
我还能竖起手指吗？

87
00:04:42,370 --> 00:04:43,662
我还能竖起手指吗？

88
00:04:43,662 --> 00:04:45,490
如果答案是真的 那就继续前进 

89
00:04:45,490 --> 00:04:48,040
如果答案是假的 请停止 

90
00:04:48,040 --> 00:04:50,710
那么 我如何将其转换为代码呢？

91
00:04:50,710 --> 00:04:53,020
好的 一旦我们添加了这个While关键字--

92
00:04:53,020 --> 00:04:57,590
我认为我们已经拥有了所有的构建块 让我提议我这样做 

93
00:04:57,590 --> 00:04:59,860
让我提议我给自己一个变量 

94
00:04:59,860 --> 00:05:02,740
我会把它叫做i代表整数 但我想怎么叫都行 

95
00:05:02,740 --> 00:05:04,780
我要把它初始化为3 

96
00:05:04,780 --> 00:05:07,780
然后我将使用Python的这个新功能 同时 

97
00:05:07,780 --> 00:05:12,380
我要问一个问题 答案必须是真的或假的 

98
00:05:12,380 --> 00:05:17,470
我要说 虽然我不等于0 

99
00:05:17,470 --> 00:05:22,630
所以我要问这个问题 虽然我不等于0 但请做以下操作 

100
00:05:22,630 --> 00:05:24,760
请注意该行末尾的冒号 

101
00:05:24,760 --> 00:05:25,890
注意我的凹痕 

102
00:05:25,890 --> 00:05:28,470
就像函数一样 就像条件句一样 

103
00:05:28,470 --> 00:05:34,440
缩进您只想作为另一件事的一部分执行的行 

104
00:05:34,440 --> 00:05:37,920
当我不等于0的时候 我想做什么？

105
00:05:37,920 --> 00:05:41,130
好吧 我想我只想猫叫一声 

106
00:05:41,130 --> 00:05:44,820
但仅仅编写这段代码是不够的 

107
00:05:44,820 --> 00:05:52,380
如果我现在非常危险地运行cat.py的Python并按Enter键 

108
00:05:52,380 --> 00:05:55,560
银幕上可能会发生什么？

109
00:05:55,560 --> 00:05:58,320
不管你以前是否编程过 

110
00:05:58,320 --> 00:06:01,200
为什么这是一件潜在的非常糟糕的事情？

111
00:06:01,200 --> 00:06:05,700
它不会弄坏东西 但它可能会失去对我电脑的控制

112
00:06:05,700 --> 00:06:07,270
不知怎么的

113
00:06:07,270 --> 00:06:08,620
有什么想法吗？

114
00:06:08,620 --> 00:06:10,120
喂 提莫？

115
00:06:10,120 --> 00:06:11,020
观众：嗨 

116
00:06:11,020 --> 00:06:18,790
我想它会继续输出meow 因为i总是等于3

117
00:06:18,790 --> 00:06:20,995
而while永远是真的

118
00:06:20,995 --> 00:06:22,120
大卫·马兰：是的 没错 

119
00:06:22,120 --> 00:06:26,320
如果我把i初始化为3--也就是说 在第1行设置它等于3 

120
00:06:26,320 --> 00:06:29,440
那么我会问 虽然i不等于0 

121
00:06:29,440 --> 00:06:31,810
这是真的 它不等于0

122
00:06:31,810 --> 00:06:34,240
它显然等于3 打印meow 

123
00:06:34,240 --> 00:06:38,950
while循环的工作方式是Python解释器

124
00:06:38,950 --> 00:06:40,480
不停地来回移动

125
00:06:40,480 --> 00:06:45,310
它从第一行到第二行 然后到第三行 

126
00:06:45,310 --> 00:06:48,490
然后它回到第二行再次提问 

127
00:06:48,490 --> 00:06:50,950
如果答案仍然为真 则转到第3行 

128
00:06:50,950 --> 00:06:52,420
然后它回到第2行 

129
00:06:52,420 --> 00:06:55,090
如果答案仍然为真 则返回到第3行 

130
00:06:55,090 --> 00:07:00,100
根据Timo的观点 如果你永远不改变i的值 

131
00:07:00,100 --> 00:07:04,450
它总是3 你会一直循环下去 

132
00:07:04,450 --> 00:07:07,028
这是一个偶然的无限循环

133
00:07:07,028 --> 00:07:08,570
所以我们得聪明点 

134
00:07:08,570 --> 00:07:09,820
我不会按回车键因为我不想

135
00:07:09,820 --> 00:07:12,195
我想失去对我的电脑的控制 这样它就

136
00:07:12,195 --> 00:07:14,080
永远打印出喵

137
00:07:14,080 --> 00:07:16,960
幸运的是 如果你真的这么做了

138
00:07:16,960 --> 00:07:21,940
在意外无限循环中 Control-C表示取消或中断

139
00:07:21,940 --> 00:07:23,110
会成为你的朋友

140
00:07:23,110 --> 00:07:26,110
如果你似乎失去了控制 你不需要重新启动

141
00:07:26,110 --> 00:07:27,520
或者关掉电脑

142
00:07:27,520 --> 00:07:30,430
您可以在终端窗口中按Control-C

143
00:07:30,430 --> 00:07:32,560
这可能会解决问题

144
00:07:32,560 --> 00:07:35,920
好吧 那我每次喵喵叫完之后 要做什么呢？

145
00:07:35,920 --> 00:07:39,820
我想我在这里想做的是这样的 

146
00:07:39,820 --> 00:07:46,750
让我把i更新为等于当前值减1

147
00:07:46,750 --> 00:07:47,530
哎呀 对不起 

148
00:07:47,530 --> 00:07:48,820
减去1 

149
00:07:48,820 --> 00:07:51,310
所以如果每次迭代时i--

150
00:07:51,310 --> 00:07:55,090
我在更新我 让我少一个 

151
00:07:55,090 --> 00:08:00,610
它最终应该会达到0 在这一点上 9.2%的S问题的答案

152
00:08:00,610 --> 00:08:02,540
现在将是假的 

153
00:08:02,540 --> 00:08:03,770
因此 让我们看看这是否奏效 

154
00:08:03,770 --> 00:08:06,790
我将转到我的终端窗口 运行cat.py的Python 

155
00:08:06,790 --> 00:08:09,700
我真的收到了三声猫叫 

156
00:08:09,700 --> 00:08:10,360
为什么？

157
00:08:10,360 --> 00:08:14,230
因为如果你愿意的话 我已经把它像一台软件里的机器一样连起来了 

158
00:08:14,230 --> 00:08:17,360
我设定i等于3 然后我继续问这个问题 

159
00:08:17,360 --> 00:08:21,940
但是我一直在转动齿轮 我一直在改变变量的值

160
00:08:21,940 --> 00:08:25,180
以确保最终它实际上是

161
00:08:25,180 --> 00:08:30,468
被递减--也就是说 递减1 直到我们最终达到0 

162
00:08:30,468 --> 00:08:33,010
现在对于那些认为我更生动一些的人来说 

163
00:08:33,010 --> 00:08:35,110
让我调出一个我们通常使用的流程图 

164
00:08:35,110 --> 00:08:38,610
这只是完全相同的事情的图形表示 

165
00:08:38,610 --> 00:08:39,610
注意正在发生的事情 

166
00:08:39,610 --> 00:08:44,020
我首先启动程序 然后将i初始化为3 

167
00:08:44,020 --> 00:08:46,300
然后我问我的第一个问题 

168
00:08:46,300 --> 00:08:48,577
再说一次 钻石总是代表着问题 

169
00:08:48,577 --> 00:08:50,410
答案将是真的或假的 

170
00:08:50,410 --> 00:08:52,690
我不等于0吗？

171
00:08:52,690 --> 00:08:54,190
嗯 它不是 它等于3 

172
00:08:54,190 --> 00:08:56,710
所以 如果我遵循真实的路线 我就会猫叫 

173
00:08:56,710 --> 00:09:01,690
然后我沿着这个箭头 我把i更新为等于i减1 

174
00:09:01,690 --> 00:09:05,200
在故事的这一点上 我大概在数学上等于2 

175
00:09:05,200 --> 00:09:06,400
我跟着箭头走 

176
00:09:06,400 --> 00:09:07,483
这就是循环 

177
00:09:07,483 --> 00:09:09,400
这就是为什么能以图形方式看到这一点是很好的 

178
00:09:09,400 --> 00:09:12,770
也许是因为你可以从字面上看到循环来回 

179
00:09:12,770 --> 00:09:14,240
现在我再问一遍这个问题 

180
00:09:14,240 --> 00:09:16,270
2不等于0吗？

181
00:09:16,270 --> 00:09:20,060
嗯 它不等于0 它是2 所以我们再叫一次 

182
00:09:20,060 --> 00:09:21,940
我们把i从2改为1 

183
00:09:21,940 --> 00:09:23,770
那么 1不等于0吗？

184
00:09:23,770 --> 00:09:27,490
显然1不是0 所以我们再猫咪一次 

185
00:09:27,490 --> 00:09:30,580
我们又一次减少了I 我现在是0 

186
00:09:30,580 --> 00:09:33,070
0不等于0吗？

187
00:09:33,070 --> 00:09:37,930
不 它等于0 所以答案是假的 我们停止 

188
00:09:37,930 --> 00:09:41,260
所以在那里 也许比我们以前的任何流程图都更有说服力 

189
00:09:41,260 --> 00:09:45,295
你真的看到项目内部发生的事情的结构了吗？

190
00:09:45,295 --> 00:09:47,920
你不必养成制作这些图表的习惯

191
00:09:47,920 --> 00:09:50,830
或创建这些图表 但只是作为第一次通过

192
00:09:50,830 --> 00:09:55,010
进入计算机内部 这确实是一种将其可视化的方法 

193
00:09:55,010 --> 00:09:57,760
好吧 让我提议 像往常一样 有很多不同的方式

194
00:09:57,760 --> 00:09:58,690
来解决这个问题 

195
00:09:58,690 --> 00:10:01,023
假设你只是喜欢有一点不同的想法 

196
00:10:01,023 --> 00:10:04,700
也许你不喜欢从3开始 然后倒数到0 

197
00:10:04,700 --> 00:10:05,200
为什么？

198
00:10:05,200 --> 00:10:07,075
也许你只是大脑不是这样工作的

199
00:10:07,075 --> 00:10:09,100
而且你更喜欢倒数 而不是倒数 

200
00:10:09,100 --> 00:10:10,400
完全没问题 

201
00:10:10,400 --> 00:10:15,700
让我继续更改我的代码 将i设置为等于1 而不是3 

202
00:10:15,700 --> 00:10:18,040
在这里 让我改变一下我的逻辑 

203
00:10:18,040 --> 00:10:20,500
而不是检查是否不等于0 比如

204
00:10:20,500 --> 00:10:23,500
你不喜欢这样想 不是因为这有点令人困惑 

205
00:10:23,500 --> 00:10:28,720
也可能是 让我们检查一下 i是否小于或等于3 

206
00:10:28,720 --> 00:10:30,310
所以我们会说得更清楚一些 

207
00:10:30,310 --> 00:10:34,690
我们会从1数到3 每次打印猫咪 

208
00:10:34,690 --> 00:10:36,970
但我需要在这里更改这条线 

209
00:10:36,970 --> 00:10:40,240
让我看看能不能叫人帮我换一下线路 

210
00:10:40,240 --> 00:10:47,560
如何将第4行更改为与从1开始向上计数一致

211
00:10:47,560 --> 00:10:52,080
从3点到3点？

212
00:10:52,080 --> 00:10:57,465
观众：每次你猫咪叫 我都会加1 

213
00:10:57,465 --> 00:10:58,590
大卫·马兰：是的 确实如此 

214
00:10:58,590 --> 00:11:01,800
在本例中 我们想要加1而不是减1 

215
00:11:01,800 --> 00:11:05,460
事实上 如果你仔细想想 这两部电影的结局可能会非常糟糕 

216
00:11:05,460 --> 00:11:09,630
如果你从1开始数 然后一直减1 减1 

217
00:11:09,630 --> 00:11:11,850
减去1 我想我们会发现我们自己

218
00:11:11,850 --> 00:11:15,780
有同样的问题 那就是我们永远不会停止 因为我们

219
00:11:15,780 --> 00:11:19,140
会变得越来越消极 而不是站起来

220
00:11:19,140 --> 00:11:20,160
到数字3 

221
00:11:20,160 --> 00:11:24,660
所以我认为你是对的 我需要把这个改成i等于i加1 

222
00:11:24,660 --> 00:11:27,840
现在 为了清楚起见 请注意等号

223
00:11:27,840 --> 00:11:30,810
也是我们从右到左的赋值运算符 

224
00:11:30,810 --> 00:11:33,150
从逻辑上讲 这可能会让你感到奇怪 

225
00:11:33,150 --> 00:11:35,880
比如我怎么能等于自己加1呢？

226
00:11:35,880 --> 00:11:39,720
除非你从右向左执行这段代码 

227
00:11:39,720 --> 00:11:44,550
你给i加1或者i减1 然后更新i的值

228
00:11:44,550 --> 00:11:45,240
左边即

229
00:11:45,240 --> 00:11:48,400
赋值将值从右向左复制 

230
00:11:48,400 --> 00:11:49,780
我还能怎么做

231
00:11:49,780 --> 00:11:55,110
好吧 我会说大多数程序员 更普遍的计算机科学家 

232
00:11:55,110 --> 00:11:57,180
往往从0开始计数 

233
00:11:57,180 --> 00:11:59,640
这是一个惯例 它实际上有好处 

234
00:11:59,640 --> 00:12:02,440
在Python和其他语言中 一般来说 

235
00:12:02,440 --> 00:12:04,600
从0开始计数是件好事

236
00:12:04,600 --> 00:12:07,620
而不是像我们在现实世界中那样从1开始计数 

237
00:12:07,620 --> 00:12:10,170
让我们现在就通过这项公约 

238
00:12:10,170 --> 00:12:14,400
让我把i设为0 现在我需要做一个改变 

239
00:12:14,400 --> 00:12:19,560
注意 如果我不改变我的逻辑 这个程序就会有bug 

240
00:12:19,560 --> 00:12:20,730
这只猫有一只虫子 

241
00:12:20,730 --> 00:12:23,940
如果我照现在的样子跑 它会叫四次 

242
00:12:23,940 --> 00:12:27,660
但最简单的解决办法是改变我的不等式

243
00:12:27,660 --> 00:12:31,810
是这个 小于而不是小于或等于 

244
00:12:31,810 --> 00:12:36,480
现在我从0开始 但我会一直到3 

245
00:12:36,480 --> 00:12:40,020
即使这可能 在我们目前看到的所有事情中 

246
00:12:40,020 --> 00:12:44,400
似乎是最不熟悉的 我们大多数人可能从1开始 2 然后3 

247
00:12:44,400 --> 00:12:47,220
这是一个好习惯 从0开始 

248
00:12:47,220 --> 00:12:52,110
最终达到但不是通过你所关心的价值 

249
00:12:52,110 --> 00:12:53,510
3在这种情况下

250
00:12:53,510 --> 00:12:55,260
好吧 让我把这里的东西弄紧一点 

251
00:12:55,260 --> 00:12:57,630
这不仅能解决我的数数问题 

252
00:12:57,630 --> 00:13:00,330
它现在的叫声是预期的3倍 

253
00:13:00,330 --> 00:13:03,240
一种更简洁的方式来表示i等于i

254
00:13:03,240 --> 00:13:06,690
加1 这是因为这是一个很流行的代码 

255
00:13:06,690 --> 00:13:11,830
你可以说i+等于1 就是这样 

256
00:13:11,830 --> 00:13:14,250
你不需要把所有东西都放在右边 

257
00:13:14,250 --> 00:13:19,320
这是一个特殊的语法 它说的是完全相同的事情 递增i 

258
00:13:19,320 --> 00:13:21,742
但它用的时间更少 

259
00:13:21,742 --> 00:13:24,700
只是打字更方便 阅读速度更快 

260
00:13:24,700 --> 00:13:25,830
这只是个会议而已 

261
00:13:25,830 --> 00:13:29,745
你们当中那些用C C++ Python编程的人--

262
00:13:29,745 --> 00:13:30,660
不 不是巨蟒 

263
00:13:30,660 --> 00:13:36,990
C、C++、Java、JavaScript可能在前面看到了加号或减号 

264
00:13:36,990 --> 00:13:40,080
对不起 Python没有它 所以您不能使用它 

265
00:13:40,080 --> 00:13:44,040
这是您的代码行可能获得的最简洁的代码 

266
00:13:44,040 --> 00:13:44,870
好的 

267
00:13:44,870 --> 00:13:46,620
让我在这里停下来看看 如果有

268
00:13:46,620 --> 00:13:53,400
关于While循环的这些实现的任何问题 

269
00:13:53,400 --> 00:13:55,620
观众：我们可以使用像for循环这样的东西吗

270
00:13:55,620 --> 00:14:02,760
在开始时将某个i值初始化为

271
00:14:02,760 --> 00:14:09,300
它从你放进东西里的特定条件中运行

272
00:14:09,300 --> 00:14:12,090
并在你前进的过程中递增？

273
00:14:12,090 --> 00:14:15,700
大卫·马兰：简而言之 不 你不能做你所描述的事情 

274
00:14:15,700 --> 00:14:18,790
但我们很快就会看到另一种类型的for循环 

275
00:14:18,790 --> 00:14:20,520
不过 让我们过一会儿再来讨论这个问题 

276
00:14:20,520 --> 00:14:26,080
关于在这里使用循环的其他问题？

277
00:14:26,080 --> 00:14:28,443
观众：所以我对这个流程图有一个问题 

278
00:14:28,443 --> 00:14:29,110
大卫·马兰：好的 

279
00:14:29,110 --> 00:14:30,490
观众：有--是的 

280
00:14:30,490 --> 00:14:36,510
有一些特定的符号代表着特定的陈述--

281
00:14:36,510 --> 00:14:42,283
他们是不是真的被用来发表这样的声明--

282
00:14:42,283 --> 00:14:43,200
大卫·马兰：是的 

283
00:14:43,200 --> 00:14:44,790
所以我考虑了--

284
00:14:44,790 --> 00:14:47,340
我故意使用某些类型的符号 某些形状

285
00:14:47,340 --> 00:14:51,570
在这里 椭圆形是启动和停止的常规方式 

286
00:14:51,570 --> 00:14:56,820
我将矩形用于任何代码语句 如赋值或打印

287
00:14:56,820 --> 00:14:57,630
以此类推 

288
00:14:57,630 --> 00:15:02,040
我用钻石来代表你可能会问的问题 

289
00:15:02,040 --> 00:15:03,988
正如我们所看到的情况 

290
00:15:03,988 --> 00:15:06,030
如果你是为了你自己 如果你只是

291
00:15:06,030 --> 00:15:07,950
试着理解你的代码并把它写下来 

292
00:15:07,950 --> 00:15:10,158
你当然不需要使用这些正式的符号 

293
00:15:10,158 --> 00:15:13,367
但我试图与一些最佳实践保持一致 

294
00:15:13,367 --> 00:15:15,450
事实上 让我回到同样的画面 

295
00:15:15,450 --> 00:15:17,533
因为这是我们照片的第一个版本 

296
00:15:17,533 --> 00:15:19,830
但自那以后 我们已经修改了几次代码 

297
00:15:19,830 --> 00:15:22,455
回想一下 这就是我们提出问题的版本

298
00:15:22,455 --> 00:15:26,340
我是不是不等于0 现在让我继续更改这个代码

299
00:15:26,340 --> 00:15:29,250
来代表我们做的下一个版本 回想一下 

300
00:15:29,250 --> 00:15:31,950
改变了我们的逻辑 从1开始计数 

301
00:15:31,950 --> 00:15:36,060
它将我们的问题改为检查 因为I小于或等于3 

302
00:15:36,060 --> 00:15:39,570
但是其他的一切都是一样的 除了计数 

303
00:15:39,570 --> 00:15:41,580
现在是正数而不是负数 

304
00:15:41,580 --> 00:15:47,040
然后我们把它进一步细化 从0数到

305
00:15:47,040 --> 00:15:48,570
但不是穿过3点 

306
00:15:48,570 --> 00:15:52,170
我们在这里通过将1递增来收紧代码

307
00:15:52,170 --> 00:15:54,220
通过使用稍微更简洁的语法 

308
00:15:54,220 --> 00:15:57,120
因此 在这一点上 这些流程图可能会变得越来越没有用处

309
00:15:57,120 --> 00:16:00,690
对于我们来说 因为一旦你的思想围绕着这个概念

310
00:16:00,690 --> 00:16:03,750
希望这张照片能帮助我们把这个概念变成现实 

311
00:16:03,750 --> 00:16:06,600
完全专注于代码当然是很好的

312
00:16:06,600 --> 00:16:09,240
只想着甚至画出这样的东西

313
00:16:09,240 --> 00:16:12,120
如果你需要考虑一些更复杂的事情

314
00:16:12,120 --> 00:16:13,200
比你习惯的要多 

315
00:16:13,200 --> 00:16:15,240
好吧 如果可以的话 让我继续说下去 并提出建议

316
00:16:15,240 --> 00:16:20,490
我们使用另一种循环类型转换到另一种方法

317
00:16:20,490 --> 00:16:22,740
关键字 即for循环 

318
00:16:22,740 --> 00:16:25,050
这个词确实存在于其他语言中 

319
00:16:25,050 --> 00:16:28,290
但不一定具有其他语言可能具有的功能

320
00:16:28,290 --> 00:16:29,260
用它来 

321
00:16:29,260 --> 00:16:33,300
但是还有一种不同类型的循环--不是While循环 而是for循环 

322
00:16:33,300 --> 00:16:37,620
而for循环将允许我们以不同的方式表达自己 

323
00:16:37,620 --> 00:16:40,020
但要做到这一点 我建议最简单的方法

324
00:16:40,020 --> 00:16:43,890
如果我们在Python语言中引入另一个概念 那就是列表 

325
00:16:43,890 --> 00:16:48,120
在这里 也没有双关语的意思 我们添加到数据类型列表中

326
00:16:48,120 --> 00:16:49,290
Python所支持的 

327
00:16:49,290 --> 00:16:51,480
我们见过STR或字符串 

328
00:16:51,480 --> 00:16:53,050
整型或整型 

329
00:16:53,050 --> 00:16:54,780
浮点值或浮点值 

330
00:16:54,780 --> 00:16:56,670
布尔或布尔表达式 

331
00:16:56,670 --> 00:17:00,480
Python也有列表 这是另一种数据类型 

332
00:17:00,480 --> 00:17:02,730
但奇妙的是 这一次可能非常熟悉 

333
00:17:02,730 --> 00:17:06,240
现实世界中的事物列表就是用Python编写的事物列表 

334
00:17:06,240 --> 00:17:11,490
这是一种在同一位置包含多个值的方式

335
00:17:11,490 --> 00:17:12,940
在同一个变量中 

336
00:17:12,940 --> 00:17:14,319
那么我这么说是什么意思呢？

337
00:17:14,319 --> 00:17:18,480
让我建议我们回到我们的VS代码 

338
00:17:18,480 --> 00:17:22,480
让我在这里重新开始我的代码 根本不使用While循环 

339
00:17:22,480 --> 00:17:24,690
但让我用这个新的关键字 

340
00:17:24,690 --> 00:17:30,363
For循环的工作方式是 它允许您迭代项目列表 

341
00:17:30,363 --> 00:17:31,530
那么这看起来像什么呢？

342
00:17:31,530 --> 00:17:32,940
它可能看起来像这样--

343
00:17:32,940 --> 00:17:39,030
对于i和以下项目列表 0 1 2 

344
00:17:39,030 --> 00:17:41,640
这是我的起点 在每次迭代中

345
00:17:41,640 --> 00:17:45,450
这个循环--也就是说 在每次执行这个循环时 

346
00:17:45,450 --> 00:17:47,550
我想把猫咪打印出来 

347
00:17:47,550 --> 00:17:51,360
现在我承认 我已经有点喜欢这段代码的外观了

348
00:17:51,360 --> 00:17:53,580
尽管这里有一些新的语法 

349
00:17:53,580 --> 00:17:55,770
因为它只是比While循环短 

350
00:17:55,770 --> 00:17:58,480
While循环刚才有多行

351
00:17:58,480 --> 00:18:01,320
我是什么 完全由我自己决定 

352
00:18:01,320 --> 00:18:04,530
我必须检查一个条件 我必须递增或递减i 

353
00:18:04,530 --> 00:18:07,230
就像我做了很多工作 相对而言 

354
00:18:07,230 --> 00:18:10,710
让那玩意儿转起来 让那个循环走下去 

355
00:18:10,710 --> 00:18:12,720
从某种意义上说 这是非常机械的 

356
00:18:12,720 --> 00:18:18,030
你可以在你的脑海中看到齿轮转动 就像所有这些变量一样

357
00:18:18,030 --> 00:18:21,120
正在发生变化 这些问题正在被提出 

358
00:18:21,120 --> 00:18:24,450
For循环简化了所有这一切 它只是

359
00:18:24,450 --> 00:18:27,480
也就是说 如果你想要一个像i这样的变量 一个数字 

360
00:18:27,480 --> 00:18:31,770
你事先就知道这个循环要执行多少次--三次

361
00:18:31,770 --> 00:18:34,380
我们只会具体说明它是什么

362
00:18:34,380 --> 00:18:37,560
就是你想让我显式地接受AS值 

363
00:18:37,560 --> 00:18:41,940
在这个循环中 我将被Python自动初始化为0 

364
00:18:41,940 --> 00:18:43,530
然后猫咪就会被打印出来 

365
00:18:43,530 --> 00:18:48,870
然后 Python会自动将i更新为等于1 然后将打印meow 

366
00:18:48,870 --> 00:18:53,520
然后 Python会自动将i更新为2 并打印meow 

367
00:18:53,520 --> 00:18:57,270
因为该列表中的值就是这样 所以Python将停止

368
00:18:57,270 --> 00:19:00,090
而且它总共只会叫三次 

369
00:19:00,090 --> 00:19:01,170
名单是什么？

370
00:19:01,170 --> 00:19:05,130
这个程序中的列表正好是 0 逗号 1 逗号 2 

371
00:19:05,130 --> 00:19:07,200
注意方括号 

372
00:19:07,200 --> 00:19:11,350
这些不是圆括号 那些是代表列表的方括号 

373
00:19:11,350 --> 00:19:15,540
作为程序员 这就是可视化的方式--这就是Python所熟知的语言

374
00:19:15,540 --> 00:19:18,460
你打算把它列成一个名单 

375
00:19:18,460 --> 00:19:23,490
因此 让我继续运行cat.py的这个Python 它的工作方式是一样的 

376
00:19:23,490 --> 00:19:24,660
但只有两行字 

377
00:19:24,660 --> 00:19:28,330
一旦您熟悉了该结构 它就非常容易阅读 

378
00:19:28,330 --> 00:19:33,970
但就我一贯的观点来说 正确性并不一定

379
00:19:33,970 --> 00:19:38,800
与设计一样 这个程序在什么意义上可能是

380
00:19:38,800 --> 00:19:40,150
设计得很差？

381
00:19:40,150 --> 00:19:41,140
它似乎起作用了 

382
00:19:41,140 --> 00:19:45,790
它叫了三次 但为什么这次不能

383
00:19:45,790 --> 00:19:48,130
是解决这个问题的最好办法吗？

384
00:19:48,130 --> 00:19:51,190
即使你以前从未编程过 再一次 

385
00:19:51,190 --> 00:19:54,310
想想角落里的情况 可能会发生也可能不会发生的事情 

386
00:19:54,310 --> 00:19:59,168
想一想真正测试代码质量的极端情况 

387
00:19:59,168 --> 00:19:59,710
观众：好的 

388
00:19:59,710 --> 00:20:06,880
我想这是因为我们说了0 1 2 3次 

389
00:20:06,880 --> 00:20:11,030
如果你想拿一百万 你可以说1 2 3 

390
00:20:11,030 --> 00:20:12,967
大卫·马兰：是的 确实如此 

391
00:20:12,967 --> 00:20:15,550
这就是我思考极端情况时的意思 

392
00:20:15,550 --> 00:20:18,430
如果您试图自己决定您自己的代码是否好

393
00:20:18,430 --> 00:20:22,120
或者其他人的代码很好 乍一看可能是这样的 

394
00:20:22,120 --> 00:20:23,530
但想一想极端的情况 

395
00:20:23,530 --> 00:20:26,410
如果这不是三件事 而是一百万件事呢？

396
00:20:26,410 --> 00:20:31,180
我是说 你真的要把0写到一百万还是0

397
00:20:31,180 --> 00:20:33,160
至9--

398
00:20:33,160 --> 00:20:38,090
999,999？

399
00:20:38,090 --> 00:20:40,840
就像不 你不会在屏幕上写那么多数字

400
00:20:40,840 --> 00:20:42,500
一定有更好的办法 

401
00:20:42,500 --> 00:20:45,100
所以让我们从一开始就做更好的事情

402
00:20:45,100 --> 00:20:47,980
而不是为做一些糟糕的事情铺平道路 

403
00:20:47,980 --> 00:20:52,090
我们可以解决这个问题来改进设计的一个方法

404
00:20:52,090 --> 00:20:56,950
不仅仅是手动指定值列表 使用函数 

405
00:20:56,950 --> 00:20:59,140
其他人的随附于Python的函数

406
00:20:59,140 --> 00:21:00,850
这就给了你想要的名单 

407
00:21:00,850 --> 00:21:02,680
而在Python中实现这一点的最简单方法是

408
00:21:02,680 --> 00:21:07,480
若要使用名为Range的函数 该函数将返回某个范围的值 

409
00:21:07,480 --> 00:21:09,940
它需要至少一个参数作为输入 

410
00:21:09,940 --> 00:21:14,170
这个数字将是您想要取回的值的数量 

411
00:21:14,170 --> 00:21:18,620
这些值将从0开始 一直到1、2 以此类推 

412
00:21:18,620 --> 00:21:22,910
但他们将增加两个 但不是通过您指定的数字 

413
00:21:22,910 --> 00:21:26,200
因此 通过指定范围3 您基本上是

414
00:21:26,200 --> 00:21:29,350
返还1、2、3个值 

415
00:21:29,350 --> 00:21:33,730
默认情况下 这些值是0、1和2 仅此而已 

416
00:21:33,730 --> 00:21:37,240
但这件事的精彩之处在于 霍普认为 如果我这样做

417
00:21:37,240 --> 00:21:38,950
想要叫一百万次--

418
00:21:38,950 --> 00:21:44,320
我的意思是 那是一只愤怒的猫 我现在只需输入一百万就可以做一百万 

419
00:21:44,320 --> 00:21:48,910
我不需要直接输入0 逗号 1 逗号 2 逗号 3 逗号 

420
00:21:48,910 --> 00:21:53,620
4 一直到999,999 我只是这样做 

421
00:21:53,620 --> 00:21:57,140
因此 从长远来看 这肯定是一种更好的方式 

422
00:21:57,140 --> 00:21:59,080
所以这确实是我们可以改进的一个方面

423
00:21:59,080 --> 00:22:03,050
Make Here仍然使用for循环 但现在使用此Range函数 

424
00:22:03,050 --> 00:22:05,470
我要向你们展示的是另一件毕德式的东西--

425
00:22:05,470 --> 00:22:07,690
严格来说 这并不是必需的 但通常

426
00:22:07,690 --> 00:22:11,560
完成了 我们可以在这里做一些小的改进 

427
00:22:11,560 --> 00:22:14,180
即使我们只猫叫了三次 

428
00:22:14,180 --> 00:22:20,710
请注意 即使我定义了一个变量i 我也从来没有使用过它 

429
00:22:20,710 --> 00:22:24,700
从逻辑上讲 这是必要的 因为据推测 

430
00:22:24,700 --> 00:22:26,620
必须用一些东西来计数 

431
00:22:26,620 --> 00:22:28,960
它必须知道它在迭代什么 

432
00:22:28,960 --> 00:22:30,970
但在Python语言中有这样一个约定

433
00:22:30,970 --> 00:22:35,320
如果您需要一个变量 仅仅因为编程功能需要

434
00:22:35,320 --> 00:22:38,890
它需要进行某种计数或自动更新 但你 人类 

435
00:22:38,890 --> 00:22:42,550
不关心它的价值 这里是一种毕脱式的改进

436
00:22:42,550 --> 00:22:45,520
将该变量命名为单下划线 

437
00:22:45,520 --> 00:22:48,280
只是因为它不是必需的 它不

438
00:22:48,280 --> 00:22:50,410
改变程序的正确性 但它

439
00:22:50,410 --> 00:22:54,190
它会向同事或老师发出信号 

440
00:22:54,190 --> 00:22:57,207
也在看你的代码 是的 它是一个变量 

441
00:22:57,207 --> 00:23:00,040
但你不在乎它的名字 因为你以后不用它 

442
00:23:00,040 --> 00:23:04,840
它只是为了使用这个功能 这个循环在这里 

443
00:23:04,840 --> 00:23:09,190
这只是一个小小的改进或改变 

444
00:23:09,190 --> 00:23:13,510
但要真正让你对Python的可能性感兴趣 

445
00:23:13,510 --> 00:23:15,140
我们再进一步

446
00:23:15,140 --> 00:23:19,780
所以如果我们真的想成为Python 这个 如果你以前编程过 

447
00:23:19,780 --> 00:23:22,310
会让你大吃一惊

448
00:23:22,310 --> 00:23:27,820
如果我想让猫叫三次 如果我真的这么做了呢？

449
00:23:27,820 --> 00:23:34,350
print open parenthesis quote-unquote meow times 3.

450
00:23:34,350 --> 00:23:37,620
你得有点极客才能觉得这很酷 但这确实有点酷 

451
00:23:37,620 --> 00:23:40,620
所以你可以直接打印你想要的 

452
00:23:40,620 --> 00:23:44,070
乘以你想要的次数

453
00:23:44,070 --> 00:23:47,760
你会得到完全相同的结果

454
00:23:47,760 --> 00:23:50,763
我好像犯了个错误 

455
00:23:50,763 --> 00:23:51,930
让我们看看它的作用 

456
00:23:51,930 --> 00:23:56,730
对你们中的一些人来说 它并不像这段代码看起来那么漂亮 

457
00:23:56,730 --> 00:23:57,240
对我

458
00:23:57,240 --> 00:24:00,300
让我运行cat.py的Python 回车 

459
00:24:00,300 --> 00:24:02,820
好吧 就像是饿猫之类的 

460
00:24:02,820 --> 00:24:04,350
它叫得很快 

461
00:24:04,350 --> 00:24:06,830
但我能解决这个问题 我敢打赌 

462
00:24:06,830 --> 00:24:10,010
现在让我们来思考一下我们讨论过的一些基本组成部分 

463
00:24:10,010 --> 00:24:13,160
问题显然是 从字面上喵 喵 

464
00:24:13,160 --> 00:24:16,460
喵喵叫重复了三次 但没有我想要的那么漂亮 

465
00:24:16,460 --> 00:24:19,910
我希望它是喵 喵 喵在不同的线上 

466
00:24:19,910 --> 00:24:22,850
有什么可能的解决方案

467
00:24:22,850 --> 00:24:26,780
使用这个乘法运算符？

468
00:24:26,780 --> 00:24:27,560
回想一下 

469
00:24:27,560 --> 00:24:30,170
我们已经使用加号连接字符串 

470
00:24:30,170 --> 00:24:33,980
显然 可以使用乘法连接字符串 但不止一次

471
00:24:33,980 --> 00:24:35,180
一遍又一遍

472
00:24:35,180 --> 00:24:37,580
我怎么才能在不恢复

473
00:24:37,580 --> 00:24:42,240
到我的For循环或我的While循环 并且仍然以这种方式使用乘法？

474
00:24:42,240 --> 00:24:45,975
观众：我们可以使用转义序列 即反斜杠n 

475
00:24:45,975 --> 00:24:46,850
大卫·马兰：太棒了 

476
00:24:46,850 --> 00:24:47,350
是 

477
00:24:47,350 --> 00:24:50,750
回想一下反斜杠n 这是您作为程序员的方式

478
00:24:50,750 --> 00:24:52,970
可以在代码中表示新行 

479
00:24:52,970 --> 00:24:57,560
我想 如果我听从你的建议 我会在里面加一个反斜杠

480
00:24:57,560 --> 00:25:02,390
所以在每一句M-E-O-W的结尾 都有一行新的 

481
00:25:02,390 --> 00:25:03,470
让我们看看这是什么样子 

482
00:25:03,470 --> 00:25:06,650
让我清空屏幕并运行cat.py的Python 

483
00:25:06,650 --> 00:25:08,270
好的 就差那么一点了 

484
00:25:08,270 --> 00:25:09,030
我喜欢这个 

485
00:25:09,030 --> 00:25:10,490
让我去找别人吧 

486
00:25:10,490 --> 00:25:13,670
我唯一不喜欢的是--我知道我现在真的很挑剔--

487
00:25:13,670 --> 00:25:15,840
它是猫叫 猫叫 猫叫在不同的线上 

488
00:25:15,840 --> 00:25:20,300
但有一条额外的空白线 我只是不喜欢审美上的 

489
00:25:20,300 --> 00:25:25,430
观众：我认为我们可以使n等于列--

490
00:25:25,430 --> 00:25:27,410
列 而不是--像斜杠n 

491
00:25:27,410 --> 00:25:28,160
大卫·马兰：是的 

492
00:25:28,160 --> 00:25:31,010
所以 这里也一样 就像我们在过去几周看到的所有事情一样

493
00:25:31,010 --> 00:25:32,630
就像是走到了一起 

494
00:25:32,630 --> 00:25:37,010
回想一下 打印函数允许您控制行尾是什么 

495
00:25:37,010 --> 00:25:39,570
默认情况下 它本身就是反斜杠n 

496
00:25:39,570 --> 00:25:41,540
这就是为什么在这张照片的最后 

497
00:25:41,540 --> 00:25:44,300
光标将再次移动到下一行 

498
00:25:44,300 --> 00:25:46,260
我们只需要推翻它就行了 

499
00:25:46,260 --> 00:25:50,420
让我在这里进入我的代码 并将其更改为逗号n

500
00:25:50,420 --> 00:25:54,890
等于引号-非引号 因此它不再是默认的反斜杠n 

501
00:25:54,890 --> 00:25:59,150
相反 现在它将什么都不是 

502
00:25:59,150 --> 00:26:03,890
那么 希望这应该会消除额外的空行 

503
00:26:03,890 --> 00:26:07,220
所以让我在这里运行最后一次 cat.py的Python 回车 

504
00:26:07,220 --> 00:26:08,640
现在我们就知道了 

505
00:26:08,640 --> 00:26:12,200
所以现在 至少在编程过程中 它是

506
00:26:12,200 --> 00:26:15,530
我可以把这些提炼成一小行 这真是太酷了

507
00:26:15,530 --> 00:26:17,120
一下子表达了自己的想法 

508
00:26:17,120 --> 00:26:19,520
现在 公平地说 它的可读性有所降低 

509
00:26:19,520 --> 00:26:21,950
就像现在我有反斜杠n 我有3倍 

510
00:26:21,950 --> 00:26:23,390
我得到了n等于引号-不引号 

511
00:26:23,390 --> 00:26:25,400
所以你不必用这种方式做事 

512
00:26:25,400 --> 00:26:28,440
我之前使用for循环的方法 完全没问题 

513
00:26:28,440 --> 00:26:31,940
我之前使用While循环的方法 完全可以 在某种意义上 

514
00:26:31,940 --> 00:26:33,740
完美的设计 

515
00:26:33,740 --> 00:26:36,600
但这只是另一种方式 

516
00:26:36,600 --> 00:26:40,250
但如果你或你的老师 你的同事 你的朋友

517
00:26:40,250 --> 00:26:42,410
将会很难读懂你自己的代码 

518
00:26:42,410 --> 00:26:47,870
但这是一些语言实际上没有的一个Python特性 

519
00:26:47,870 --> 00:26:51,110
好吧 让我提议让事情变得更有趣

520
00:26:51,110 --> 00:26:53,690
如果我们不只是猫叫三次 

521
00:26:53,690 --> 00:26:56,180
但我们的猫咪叫声次数是可变的 

522
00:26:56,180 --> 00:26:58,940
让我们来问问用户这只猫应该叫几次 

523
00:26:58,940 --> 00:27:03,540
所以让我清理一下屏幕 让我想想 好吧 

524
00:27:03,540 --> 00:27:05,760
我如何从用户那里获得号码？

525
00:27:05,760 --> 00:27:08,670
这里的问题是 如果我想让用户给我一个数字 

526
00:27:08,670 --> 00:27:12,290
我不是在做数学 本质上 我在猫叫 因此 用户

527
00:27:12,290 --> 00:27:14,630
必须给我一个积极的价值 

528
00:27:14,630 --> 00:27:17,100
用户必须给我一个正值 

529
00:27:17,100 --> 00:27:18,860
那么 我怎么能坚持这一点呢？

530
00:27:18,860 --> 00:27:25,800
如果我这样做 n等于输入的int 那么n是什么 问号？

531
00:27:25,800 --> 00:27:28,040
嗯 我想确认一下--

532
00:27:28,040 --> 00:27:32,150
我可以说 如果n小于0-

533
00:27:32,150 --> 00:27:34,430
如果它是阴性的 那么我可以这样做 

534
00:27:34,430 --> 00:27:35,870
好吧 那就再问一遍 

535
00:27:35,870 --> 00:27:40,370
INT INPUT n是什么 问号？

536
00:27:40,370 --> 00:27:43,312
好的 那么如果用户仍然不给我一个正数怎么办？

537
00:27:43,312 --> 00:27:45,770
如果真的很难 他们没有注意到呢

538
00:27:45,770 --> 00:27:47,395
然后他们输入了两个负数？

539
00:27:47,395 --> 00:27:53,000
如果n小于0 那么我们再来一次 N等于--

540
00:27:53,000 --> 00:27:54,170
这不会有好的结局 

541
00:27:54,170 --> 00:27:58,070
你不能无限次地不停地检查 是否定的吗 

542
00:27:58,070 --> 00:27:59,630
它是负面的 还是负面的？

543
00:27:59,630 --> 00:28:01,700
这个程序永远不会被写完 

544
00:28:01,700 --> 00:28:05,010
所以我们可以做这件事 我想更好 也许用一个循环 

545
00:28:05,010 --> 00:28:06,200
因此 让我提出这一点 

546
00:28:06,200 --> 00:28:09,020
在Python中有一个非常常见的范例 当您

547
00:28:09,020 --> 00:28:14,000
希望获得与您的特定期望相匹配的用户输入 

548
00:28:14,000 --> 00:28:17,570
这一切都是积极的 都是消极的 或者只是类似的东西 

549
00:28:17,570 --> 00:28:20,840
你马上就会说虽然是真的 

550
00:28:20,840 --> 00:28:24,380
你故意的 有点危险 但很老套 

551
00:28:24,380 --> 00:28:25,962
引发无限循环 

552
00:28:25,962 --> 00:28:27,170
那么什么是无限循环呢？

553
00:28:27,170 --> 00:28:28,550
它只是一个永远不会消失的东西 

554
00:28:28,550 --> 00:28:31,430
我们已经看到了这种情况是如何在数学上偶然发生的 

555
00:28:31,430 --> 00:28:34,700
当你说虽然是真的时 这绝对会发生 

556
00:28:34,700 --> 00:28:35,240
为什么？

557
00:28:35,240 --> 00:28:39,180
嗯 真正问题的答案总是正确的 

558
00:28:39,180 --> 00:28:41,570
因此 这是一种故意诱导循环的方式

559
00:28:41,570 --> 00:28:43,470
默认情况下 它将永远消失 

560
00:28:43,470 --> 00:28:46,940
所以我们需要一种方法来打破这个循环 当

561
00:28:46,940 --> 00:28:48,350
我们有我们想要的号码 

562
00:28:48,350 --> 00:28:50,600
大会 虽然在这个会议的其他方面

563
00:28:50,600 --> 00:28:52,970
无限循环就是问你关心的问题 

564
00:28:52,970 --> 00:28:55,760
比如通过提示用户输入来给我一个int 

565
00:28:55,760 --> 00:28:57,800
比如n是什么 问号？

566
00:28:57,800 --> 00:28:59,330
然后问你自己的问题 

567
00:28:59,330 --> 00:29:04,580
因此 如果n小于0 那么我认为我们希望Python继续

568
00:29:04,580 --> 00:29:05,910
以再次提示用户 

569
00:29:05,910 --> 00:29:09,760
也就是说 我们希望代码停留在循环中 调用输入函数 

570
00:29:09,760 --> 00:29:11,760
并希望用户给我们一个更好的答案 

571
00:29:11,760 --> 00:29:14,730
如果这一次它小于0 那么让我们按字面意思

572
00:29:14,730 --> 00:29:16,980
使用Python的关键字Continue 其意思是

573
00:29:16,980 --> 00:29:20,100
就是这样--继续保持在这个循环中 

574
00:29:20,100 --> 00:29:24,000
否则 如果不小于0 让我们继续前进 只需突破

575
00:29:24,000 --> 00:29:27,120
使用了Python语言中的另一个关键字Break 

576
00:29:27,120 --> 00:29:31,140
在这种情况下 Break将使您脱离最近开始的循环

577
00:29:31,140 --> 00:29:34,080
如果不是n小于0的情况 

578
00:29:34,080 --> 00:29:38,310
所以这是可行的 它将允许我们获得一个大于或等于0的值

579
00:29:38,310 --> 00:29:41,340
来自用户 但我认为我们可以进一步收紧它 以免

580
00:29:41,340 --> 00:29:43,500
不厌其烦地假设 然后 等等 

581
00:29:43,500 --> 00:29:49,227
为什么我们不直接说 如果n大于0 继续并中断呢？

582
00:29:49,227 --> 00:29:51,060
事实上 这并不是一个有趣的节目

583
00:29:51,060 --> 00:29:52,830
如果我们甚至允许用户输入0 

584
00:29:52,830 --> 00:29:56,430
所以让我们等到他们给我们一个大于0的整数

585
00:29:56,430 --> 00:29:59,040
然后跳出这个循环 

586
00:29:59,040 --> 00:30:00,960
我现在在这里能做些什么呢？

587
00:30:00,960 --> 00:30:07,260
对于i来说 不管n是什么值 都可以打印猫咪 

588
00:30:07,260 --> 00:30:10,340
老实说 我不需要我在这里 所以让我回到那个原则上

589
00:30:10,340 --> 00:30:10,840
在此之前 

590
00:30:10,840 --> 00:30:12,590
让我把它改成下划线

591
00:30:12,590 --> 00:30:14,110
如果你愿意的话 只是想表达一下毕多德式的意思 

592
00:30:14,110 --> 00:30:15,360
那到底是怎么回事？

593
00:30:15,360 --> 00:30:20,130
第1行到第4行故意实现无限循环

594
00:30:20,130 --> 00:30:23,280
否则 默认情况下 这种情况将永远消失 

595
00:30:23,280 --> 00:30:26,370
但我在问一个问题 在那个循环里 

596
00:30:26,370 --> 00:30:30,450
在第2行上从用户那里获得一个int之后 我将检查 

597
00:30:30,450 --> 00:30:32,310
它是否大于0？

598
00:30:32,310 --> 00:30:33,570
还是说是0？

599
00:30:33,570 --> 00:30:34,220
是阴性的吗？

600
00:30:34,220 --> 00:30:35,970
对于猫咪来说 这一切都说不通 

601
00:30:35,970 --> 00:30:38,380
好像我想让那只猫至少叫一次 

602
00:30:38,380 --> 00:30:41,220
因此 如果它大于0 则中断 

603
00:30:41,220 --> 00:30:45,030
这个Break语句 即使它是缩进的 缩进了两次 

604
00:30:45,030 --> 00:30:50,140
具有中断最近开始的While循环的效果 

605
00:30:50,140 --> 00:30:53,670
因此 一旦用户给你一个正值 

606
00:30:53,670 --> 00:30:58,650
然后我们到了第6行 在这一点上我们猫叫了很多次 因为

607
00:30:58,650 --> 00:30:59,850
6号线和7号线 

608
00:30:59,850 --> 00:31:03,960
所以 如果我现在运行这个cat.py的Python 输入 那么 n是什么？

609
00:31:03,960 --> 00:31:06,895
让我们从我们开始的3开始 喵 

610
00:31:06,895 --> 00:31:10,020
这一次 让我继续并增加我的终端窗口的大小

611
00:31:10,020 --> 00:31:11,100
只是暂时的 

612
00:31:11,100 --> 00:31:16,140
让我运行Cat.py的Python 让我运行10次 现在猫咪10次

613
00:31:16,140 --> 00:31:17,520
出现在屏幕上 

614
00:31:17,520 --> 00:31:20,640
这里要说的不仅仅是我们可以猫叫10次

615
00:31:20,640 --> 00:31:22,890
或者一次又一次地做某事 但这

616
00:31:22,890 --> 00:31:26,880
是在您想要再次做某事时 在Python中非常常见的范例

617
00:31:26,880 --> 00:31:31,320
一次又一次 但只有在用户真正给你

618
00:31:31,320 --> 00:31:34,230
这是你在这里所关心的价值 

619
00:31:34,230 --> 00:31:36,540
现在让我向你求婚 因为我们练习了

620
00:31:36,540 --> 00:31:41,830
更多的是我们一直在宣扬的 特别是当涉及到 比如说--

621
00:31:41,830 --> 00:31:45,075
尤其是当涉及到编写您自己的函数时 

622
00:31:45,075 --> 00:31:46,950
现在我都在猫叫了 可能会

623
00:31:46,950 --> 00:31:50,970
很高兴能真正拥有一个Monow函数 它是Python的发明者

624
00:31:50,970 --> 00:31:52,680
没想到 所以就让我来做吧 

625
00:31:52,680 --> 00:31:56,050
让我实际删除所有这些代码 让我继续执行此操作 

626
00:31:56,050 --> 00:31:59,950
让我继续说明定义一个主函数 就像我以前做过的那样 

627
00:31:59,950 --> 00:32:02,400
让我盲目地叫猫咪3 

628
00:32:02,400 --> 00:32:05,910
猫咪还不存在 但当它存在的时候 那就太好了 

629
00:32:05,910 --> 00:32:08,640
所以 现在让我来定义一下猫咪 

630
00:32:08,640 --> 00:32:11,850
所以我是猫咪函数应该接受的输入

631
00:32:11,850 --> 00:32:16,350
一个名为n的参数 或者我想要的任何东西 这部分现在很容易了 

632
00:32:16,350 --> 00:32:17,880
你是怎么叫n次的？

633
00:32:17,880 --> 00:32:22,470
好的 为了给n加下划线 也就是n的范围 你可以直接打印猫咪 

634
00:32:22,470 --> 00:32:24,780
所以和以前一样的代码 这里没有什么新鲜事 

635
00:32:24,780 --> 00:32:28,470
我只是把这个逻辑放在一个猫咪函数中

636
00:32:28,470 --> 00:32:30,810
这将会产生打印猫咪的副作用 

637
00:32:30,810 --> 00:32:34,620
现在 像以前一样 让我到下面来 让我确保我调用Main 

638
00:32:34,620 --> 00:32:39,420
如果我现在运行这段代码 猫的巨蟒 喵 

639
00:32:39,420 --> 00:32:42,960
它总是会做3 因为我已经硬编码到3 

640
00:32:42,960 --> 00:32:44,730
好吧 让我们在这里做一个改进 

641
00:32:44,730 --> 00:32:48,720
现在让我继续下去 也许可以这样做 

642
00:32:48,720 --> 00:32:50,350
让我向用户索要一个号码 

643
00:32:50,350 --> 00:32:54,700
让我们这样说 数字等于得到数字 

644
00:32:54,700 --> 00:32:55,200
好的 

645
00:32:55,200 --> 00:32:57,210
遗憾的是 在Python中没有函数

646
00:32:57,210 --> 00:32:59,940
从用户那里获得正数的被调用的GET号码 

647
00:32:59,940 --> 00:33:01,080
但这是我可以发明的 

648
00:33:01,080 --> 00:33:05,070
所以定义Get Number 打开Paren 关闭Paren 

649
00:33:05,070 --> 00:33:07,260
然后在这个函数内部 让我这样做 

650
00:33:07,260 --> 00:33:11,160
如果为真 则继续并从用户那里获取一个数字 

651
00:33:11,160 --> 00:33:14,730
将其转换为整型 问他们 n是什么 问号？

652
00:33:14,730 --> 00:33:19,260
如果n是我想要的 它就是一个大于0的值 

653
00:33:19,260 --> 00:33:24,710
一个正数 我不一定要打破这一次 

654
00:33:24,710 --> 00:33:26,000
虽然我可以 

655
00:33:26,000 --> 00:33:30,750
相反 我希望返回值 这样我就可以实际执行此操作 

656
00:33:30,750 --> 00:33:32,600
而这也是Python的一个特性 

657
00:33:32,600 --> 00:33:35,690
这种能力不仅仅是从一块代码中解脱出来 

658
00:33:35,690 --> 00:33:38,750
还可以在代码中返回值 

659
00:33:38,750 --> 00:33:42,590
实际上 返回一个值使您最终能够 

660
00:33:42,590 --> 00:33:47,030
显式返回值 以便您的函数不只有一个边

661
00:33:47,030 --> 00:33:51,650
效果是必然的 但它实际上是回馈 就像输入一样 

662
00:33:51,650 --> 00:33:56,220
就像int做的一样 就像Float做的一样 对用户来说是一个实际值 

663
00:33:56,220 --> 00:33:58,790
现在澄清一下 我不需要在这里返回n 

664
00:33:58,790 --> 00:34:02,330
我仍然可以像过去对代码所做的那样跳出循环

665
00:34:02,330 --> 00:34:06,860
像这样 但在循环之后 我仍然必须返回 

666
00:34:06,860 --> 00:34:10,969
所以这里发生的事情是 如果你使用Break来跳出循环 

667
00:34:10,969 --> 00:34:13,730
但您需要从函数中传回一个值 

668
00:34:13,730 --> 00:34:15,980
现在您仍然必须使用RETURN关键字

669
00:34:15,980 --> 00:34:20,389
显式地要么像我一样在循环中 要么现在在循环之外

670
00:34:20,389 --> 00:34:24,110
但仍在函数内部 

671
00:34:24,110 --> 00:34:26,420
我现在要做的最后一件事是改变

672
00:34:26,420 --> 00:34:28,969
我们之前硬编码的那个3 实际上

673
00:34:28,969 --> 00:34:31,590
是我们从用户那里获得的变量的值

674
00:34:31,590 --> 00:34:36,380
所以现在在这里 如果我运行cat.py的Python 输入 n是什么？

675
00:34:36,380 --> 00:34:40,219
我可以输入3 我可以得到我的三声 或者如果我只想要一声 

676
00:34:40,219 --> 00:34:43,020
我现在得到了一只猫叫 

677
00:34:43,020 --> 00:34:43,520
好的 

678
00:34:43,520 --> 00:34:48,230
因此 如果我们现在有能力在这些循环中一次又一次地做事情 

679
00:34:48,230 --> 00:34:51,800
让我们看看我们是否不能解决其他一些问题 通过

680
00:34:51,800 --> 00:34:55,894
周期性地表达自己 但也会得到一些有趣的答案 

681
00:34:55,894 --> 00:34:58,898
例如 让我提议 我们看起来

682
00:34:58,898 --> 00:35:00,440
更密切地关注这些榜单 

683
00:35:00,440 --> 00:35:03,107
事实证明 在Python中 而且实际上 在一般的程序中 

684
00:35:03,107 --> 00:35:05,600
有一个值列表很有用 因为我们是

685
00:35:05,600 --> 00:35:10,160
将能够处理越来越多的数据、越来越大的数据集 

686
00:35:10,160 --> 00:35:12,530
因此 让我建议我们回到VS代码这里

687
00:35:12,530 --> 00:35:15,620
让我们来做一些可能对一些人来说有点熟悉的事情 

688
00:35:15,620 --> 00:35:17,030
霍格沃茨的世界 

689
00:35:17,030 --> 00:35:19,850
让我继续编写一个名为霍格沃茨的文件 

690
00:35:19,850 --> 00:35:23,840
让我们看看我们能不能列出霍格沃茨的学生名单 

691
00:35:23,840 --> 00:35:26,270
因此 我有一个名为hogwarts.py的新选项卡 

692
00:35:26,270 --> 00:35:30,710
让我继续下去 提议我在这个程序中定义

693
00:35:30,710 --> 00:35:32,780
一份我事先知道名字的学生名单 

694
00:35:32,780 --> 00:35:34,572
因此 我暂时不会让用户输入 

695
00:35:34,572 --> 00:35:37,250
我从一开始就知道这三个人

696
00:35:37,250 --> 00:35:39,110
我想考虑的学生是这些 

697
00:35:39,110 --> 00:35:41,030
我们的变量将被称为学生 

698
00:35:41,030 --> 00:35:44,540
就像我在过去做的那样 它等于一个方括号 它

699
00:35:44,540 --> 00:35:46,100
意思是 嘿 这是一份清单 

700
00:35:46,100 --> 00:35:49,520
这些值将是引号中的赫敏 因为它是

701
00:35:49,520 --> 00:35:53,980
一个字符串；用引号引起来的哈里 因为它是一个字符串；然后罗恩用引号 

702
00:35:53,980 --> 00:35:55,230
因为它也是一根线 

703
00:35:55,230 --> 00:35:57,800
这是一个长度为3的列表 

704
00:35:57,800 --> 00:36:00,500
它在精神上类似于我之前列出的长度为3的列表 

705
00:36:00,500 --> 00:36:02,960
但这有3个整数 0 1 2 

706
00:36:02,960 --> 00:36:06,020
现在 我有了一个包含三个字符串的列表 

707
00:36:06,020 --> 00:36:08,940
而这在目前并不是很有用 

708
00:36:08,940 --> 00:36:11,600
但让我做点事作为我自己的支票 

709
00:36:11,600 --> 00:36:14,510
让我把这些学生逐一打印出来 

710
00:36:14,510 --> 00:36:19,760
嗯 等一下 我怎么打印列表的内容呢？

711
00:36:19,760 --> 00:36:22,610
在过去 当我们打印变量时 

712
00:36:22,610 --> 00:36:24,900
我们刚刚打印出了变量的名称 

713
00:36:24,900 --> 00:36:28,970
但我不想一下子把赫敏、哈利和罗恩都打印出来 

714
00:36:28,970 --> 00:36:33,350
也许我想先打印出赫敏 然后是哈利 然后是罗恩 

715
00:36:33,350 --> 00:36:36,050
所以我需要一种更准确的方式来表达

716
00:36:36,050 --> 00:36:37,790
我想要此列表中的值吗？

717
00:36:37,790 --> 00:36:42,590
在Python中实现这一点的方法是以另一种方式使用方括号 

718
00:36:42,590 --> 00:36:45,890
如果你有一个变量--在这个例子中 叫做学生 

719
00:36:45,890 --> 00:36:49,850
你想要进入这个变量并获得一个特定值--

720
00:36:49,850 --> 00:36:52,940
也就是说 您想要索引到列表中 

721
00:36:52,940 --> 00:36:57,500
您可以这样使用方括号 在方括号中使用数字 

722
00:36:57,500 --> 00:37:02,570
这就是我们看到用0来思考和计算的有用之处

723
00:37:02,570 --> 00:37:04,280
上行而不是1上行 

724
00:37:04,280 --> 00:37:08,120
Python中的这些列表是零索引的 

725
00:37:08,120 --> 00:37:13,700
列表中的第一项位于位置0 Python列表中的第二项位于位置0

726
00:37:13,700 --> 00:37:16,760
第一个是位置1 第三个是位置2 

727
00:37:16,760 --> 00:37:19,940
所以你在精神上总是差一点 但你会习惯的 

728
00:37:19,940 --> 00:37:22,275
如果你从来没有编程过 随着时间的推移 

729
00:37:22,275 --> 00:37:23,900
让我把这三个学生都打印出来 

730
00:37:23,900 --> 00:37:27,410
让我打印出学生括号0 然后学生括号1 

731
00:37:27,410 --> 00:37:30,290
最后 让我打印学生括号2 

732
00:37:30,290 --> 00:37:32,078
这是第三句也是最后一句

733
00:37:32,078 --> 00:37:35,120
当然 如果我运行这段代码 它可能会做你猜的事情 

734
00:37:35,120 --> 00:37:39,500
如果我运行hogwarts.py的Python 有赫敏、哈利和罗恩

735
00:37:39,500 --> 00:37:41,450
每个人都有自己的路线 

736
00:37:41,450 --> 00:37:43,443
但肯定有更好的办法尤其是

737
00:37:43,443 --> 00:37:45,860
如果我事先不知道谁会出现在这个名单上

738
00:37:45,860 --> 00:37:48,230
如果明年霍格沃茨有新学生 

739
00:37:48,230 --> 00:37:50,930
我们可以用循环来自动地做一些事情

740
00:37:50,930 --> 00:37:54,590
而不必手动输入0 然后输入1和2 

741
00:37:54,590 --> 00:37:57,110
这是Python的另一个特性 

742
00:37:57,110 --> 00:38:01,310
你可以使用for循环不仅仅是从0到1再到2 

743
00:38:01,310 --> 00:38:03,870
你可以用Python来覆盖任何东西 

744
00:38:03,870 --> 00:38:05,420
不仅仅是数字 还有字符串 

745
00:38:05,420 --> 00:38:07,100
所以我真的可以这么做 

746
00:38:07,100 --> 00:38:13,460
对于学生中的学生 冒号 然后在下面缩进 

747
00:38:13,460 --> 00:38:15,050
我可以说印刷学生 

748
00:38:15,050 --> 00:38:19,700
不管我有三个学生 四个还是四百个 

749
00:38:19,700 --> 00:38:23,930
这两行代码 这个循环会为我打印所有这些学生

750
00:38:23,930 --> 00:38:24,810
一次一个

751
00:38:24,810 --> 00:38:28,490
所以如果我现在运行hogwarts.py的Python 有相同的列表 

752
00:38:28,490 --> 00:38:32,420
但我不需要提前知道名单有多长

753
00:38:32,420 --> 00:38:35,130
注意 我做了一个有意识的决定 

754
00:38:35,130 --> 00:38:39,680
我没有把这个变量叫做下划线 因为这次我

755
00:38:39,680 --> 00:38:40,970
使用变量 

756
00:38:40,970 --> 00:38:44,210
虽然我能做到这一点 现在 不 

757
00:38:44,210 --> 00:38:46,130
你的代码太晦涩了

758
00:38:46,130 --> 00:38:48,860
如果你给变量命名为下划线 

759
00:38:48,860 --> 00:38:51,530
使用变量underscore 现在你帮不了任何人 

760
00:38:51,530 --> 00:38:54,890
现在你把读者搞糊涂了 你自己也搞糊涂了 

761
00:38:54,890 --> 00:38:57,370
您应该按变量的原样来命名它们 

762
00:38:57,370 --> 00:39:00,470
所以这是一个非常合适的名字 虽然我相信你可以想出其他名字 

763
00:39:00,470 --> 00:39:04,430
会是学生 而在这里 你可以说你也会继续当学生 

764
00:39:04,430 --> 00:39:06,710
如果你想说得更简洁些 那就是

765
00:39:06,710 --> 00:39:09,380
在这样的循环中做一些简洁的事情并不是不合理的 

766
00:39:09,380 --> 00:39:13,430
对于S来说 在学生名单中 使用的字母可能与

767
00:39:13,430 --> 00:39:15,740
它本身就是这样开始的 但再说一次 为什么要费心呢？

768
00:39:15,740 --> 00:39:17,510
Python应该更具可读性 

769
00:39:17,510 --> 00:39:22,530
如果您有学生列表 请一次迭代一个学生 

770
00:39:22,530 --> 00:39:25,490
让我在这里暂停一下 看看现在是否有关于名单的问题

771
00:39:25,490 --> 00:39:28,220
正如我现在定义的那样 在本例中是字符串列表 

772
00:39:28,220 --> 00:39:33,860
或者现在使用for循环迭代并打印每个名称 

773
00:39:33,860 --> 00:39:34,550
观众：是的 

774
00:39:34,550 --> 00:39:38,150
那么 在这种情况下 没有必要启动学生吗？

775
00:39:38,150 --> 00:39:40,575
或者我们可以只在循环中声明一个变量？

776
00:39:40,575 --> 00:39:41,700
大卫·马兰：问得好 

777
00:39:41,700 --> 00:39:43,450
您无需手动对其进行初始化 

778
00:39:43,450 --> 00:39:47,810
Python负责将Student变量初始化为Hermione

779
00:39:47,810 --> 00:39:49,960
第一 然后是哈利 然后是罗恩 第三 

780
00:39:49,960 --> 00:39:53,210
与其他语言不同 您不需要自己将其初始化为某个东西 

781
00:39:53,210 --> 00:39:55,250
它只是存在 而且会奏效的 

782
00:39:55,250 --> 00:39:58,662
其他关于循环和列表的问题是这样的吗？

783
00:39:58,662 --> 00:40:00,620
观众：既然你描述了Break 那么有没有

784
00:40:00,620 --> 00:40:04,232
有没有继续的概念 这样我们就可以在循环中跳过特定的情况？

785
00:40:04,232 --> 00:40:04,940
大卫·马兰：是的 

786
00:40:04,940 --> 00:40:06,933
您也可以继续使用其他语法 

787
00:40:06,933 --> 00:40:07,850
我们还没有证明这一点 

788
00:40:07,850 --> 00:40:10,668
目前 我们只关注休息时间 

789
00:40:10,668 --> 00:40:11,210
观众：好的 

790
00:40:11,210 --> 00:40:15,770
那么这个for循环可以与哈希表或其他类型的循环一起工作吗

791
00:40:15,770 --> 00:40:17,607
是表还是数组？

792
00:40:17,607 --> 00:40:18,440
大卫·马兰：确实如此 

793
00:40:18,440 --> 00:40:20,190
所以我们在这一点上超前了 

794
00:40:20,190 --> 00:40:22,610
但在Python中还有其他类型的数据 

795
00:40:22,610 --> 00:40:26,550
实际上 您也可以使用for循环来迭代这些代码 

796
00:40:26,550 --> 00:40:28,940
可以说 任何可迭代的东西都是

797
00:40:28,940 --> 00:40:32,030
可以与这样的循环一起使用的数据片段 

798
00:40:32,030 --> 00:40:34,290
但更多关于这些的--很快就会有更多的关于这些的 

799
00:40:34,290 --> 00:40:37,967
事实上 让我过渡到这里来展示另一种解决方案

800
00:40:37,967 --> 00:40:40,550
同样的问题 因为到目前为止 当我们使用循环时 

801
00:40:40,550 --> 00:40:43,040
我们真的依赖于数字 这很好

802
00:40:43,040 --> 00:40:45,620
如果你更喜欢呆在那个地方的话 

803
00:40:45,620 --> 00:40:49,610
假设我确实想使用像I和0这样的数字进行迭代 

804
00:40:49,610 --> 00:40:50,910
1、2等等 

805
00:40:50,910 --> 00:40:53,700
让我建议我们可以按如下方式更改此代码 

806
00:40:53,700 --> 00:40:56,930
如果您更愿意考虑 或者如果您正在进行的项目

807
00:40:56,930 --> 00:40:59,810
尝试实施需要使用这样的数字 

808
00:40:59,810 --> 00:41:00,830
你可能会这么做 

809
00:41:00,830 --> 00:41:04,820
对于我来说--嗯 我不想只说学生 

810
00:41:04,820 --> 00:41:07,580
因为那样我就不再是一个数字了 

811
00:41:07,580 --> 00:41:13,010
我将成为赫敏 然后是哈利 然后是罗恩 

812
00:41:13,010 --> 00:41:17,030
我需要从0到1再到2迭代 

813
00:41:17,030 --> 00:41:21,320
如果具有三个元素的列表具有这些位置 0 1 2 

814
00:41:21,320 --> 00:41:25,400
我需要以某种方式创建一个从0开始到2结束的循环 

815
00:41:25,400 --> 00:41:28,340
以前 当我想这么做的时候 我需要射程 

816
00:41:28,340 --> 00:41:30,290
但这两项计划行不通 

817
00:41:30,290 --> 00:41:32,750
我不能只说在学生的范围内 

818
00:41:32,750 --> 00:41:36,030
因为学生不是数字 也不是整数 

819
00:41:36,030 --> 00:41:37,640
所以你不能把球传给射程 

820
00:41:37,640 --> 00:41:39,260
Range需要一个整数 

821
00:41:39,260 --> 00:41:41,840
但这里有一个解决方案 

822
00:41:41,840 --> 00:41:47,390
原来在Python语言中有一个名为LENGTH或LEN的函数 L-E-N 

823
00:41:47,390 --> 00:41:51,890
这会告诉你清单的长度 以及以后的其他事情 

824
00:41:51,890 --> 00:41:55,850
现在我想我可以组装这些积木 并以一种方式

825
00:41:55,850 --> 00:41:57,740
请允许我以这种方式使用数字 

826
00:41:57,740 --> 00:42:02,870
所以Range不需要字符串列表 它需要一个数字 

827
00:42:02,870 --> 00:42:04,790
理想情况下 这个数字应该是3 

828
00:42:04,790 --> 00:42:07,580
所以我得到了一个值的范围 0、1和2 

829
00:42:07,580 --> 00:42:10,640
所以我想我可以像这样嵌套我的函数 

830
00:42:10,640 --> 00:42:15,410
如果我首先得到学生名单的长度 那将是3 

831
00:42:15,410 --> 00:42:18,620
然后 我将返回值作为参数传递

832
00:42:18,620 --> 00:42:23,840
对于Range 这将返回一个值的范围 0 然后1 然后是2 

833
00:42:23,840 --> 00:42:26,570
如果我想的话 这将允许我用代码来做什么

834
00:42:26,570 --> 00:42:28,310
不仅仅是这样 

835
00:42:28,310 --> 00:42:33,650
我现在可以打印出来了 学生们 这是现在

836
00:42:33,650 --> 00:42:38,270
我们看到的语法正在变得非常有表现力--新的 也许

837
00:42:38,270 --> 00:42:39,200
不熟悉 

838
00:42:39,200 --> 00:42:44,090
但如果我能做左方括号 0 左方括号 或左方括号 

839
00:42:44,090 --> 00:42:47,990
左方括号 或左方括号 2 右方括号 结果是 

840
00:42:47,990 --> 00:42:49,940
我实际上可以在里面放一个变量 然后我

841
00:42:49,940 --> 00:42:52,490
可以表示括号内的任何数字

842
00:42:52,490 --> 00:42:54,800
以便在循环中动态地打印出所有这些 

843
00:42:54,800 --> 00:42:57,680
让我来做这件事 巨蟒of hogwarts.py 回车 

844
00:42:57,680 --> 00:43:00,140
这是赫敏、哈里和罗恩 

845
00:43:00,140 --> 00:43:02,570
现在 如果我只是好奇 我只想戳

846
00:43:02,570 --> 00:43:05,060
或许我想做个排名 比如谁

847
00:43:05,060 --> 00:43:08,240
排名前三的学生是在学校还是在格兰芬多？

848
00:43:08,240 --> 00:43:11,000
嗯 我们已经看到 我可以一次打印多个东西 

849
00:43:11,000 --> 00:43:14,540
让我打印出来的不仅仅是现场的学生

850
00:43:14,540 --> 00:43:19,340
而是让我们先打印I 然后打印位置I的学生 

851
00:43:19,340 --> 00:43:22,850
所以要打印两件事 我们知道打印可以有两个论点 

852
00:43:22,850 --> 00:43:25,280
我们以前见过 它们会被一个空格隔开 

853
00:43:25,280 --> 00:43:26,900
让我继续并重新运行这个 

854
00:43:26,900 --> 00:43:31,533
现在我明白了 好吧 赫敏是最好的学生 但她是第零名 

855
00:43:31,533 --> 00:43:32,450
这有点奇怪 

856
00:43:32,450 --> 00:43:35,930
就像我们不需要向使用我的程序的人展示

857
00:43:35,930 --> 00:43:37,430
我们从0开始数 

858
00:43:37,430 --> 00:43:38,570
我可以把这里清理干净 

859
00:43:38,570 --> 00:43:41,600
我可以在这里的i上加1 现在我们

860
00:43:41,600 --> 00:43:43,640
查看排名前三的学生名单 

861
00:43:43,640 --> 00:43:47,540
赫敏是第一名 哈利是第二名 当然 罗恩是第三名 

862
00:43:47,540 --> 00:43:50,960
因此 我们也可以访问所有这些相同的值 

863
00:43:50,960 --> 00:43:55,320
这些清单上现在还有什么问题吗？

864
00:43:55,320 --> 00:43:58,320
这些清单上现在有什么问题吗？

865
00:43:58,320 --> 00:44:01,050
这个长度 这个范围 还是其他？

866
00:44:01,050 --> 00:44:08,350
观众：我的问题是 对于我在射程内 你能再解释一次吗？

867
00:44:08,350 --> 00:44:10,210
大卫·马兰：当然 

868
00:44:10,210 --> 00:44:12,640
所以 让我及时回顾一下 

869
00:44:12,640 --> 00:44:13,960
我们一开始就这么做 

870
00:44:13,960 --> 00:44:20,770
I in 0 1 2 然后我们用这种方式打印三次 

871
00:44:20,770 --> 00:44:23,830
For循环的工作方式是它创建

872
00:44:23,830 --> 00:44:27,730
一个变量 我把它叫做i 但我想叫它什么都行 

873
00:44:27,730 --> 00:44:31,390
然后 它将i初始赋值给列表中的第一个项 

874
00:44:31,390 --> 00:44:34,690
然后 它会自动将i赋给列表中的下一项 

875
00:44:34,690 --> 00:44:37,210
然后它将i赋给列表中的第三个项目 

876
00:44:37,210 --> 00:44:41,520
每次它都会执行下面的所有缩进代码 

877
00:44:41,520 --> 00:44:43,740
然而 我们意识到 这是不可能的

878
00:44:43,740 --> 00:44:46,380
如果我想做一百万次这样的事情 要有很好的伸缩性 

879
00:44:46,380 --> 00:44:48,480
因此 我们引入了Range 

880
00:44:48,480 --> 00:44:51,240
这产生了做同样事情的效果 

881
00:44:51,240 --> 00:44:55,080
它给我返回了一系列的值--实际上是三件事的清单 

882
00:44:55,080 --> 00:44:57,330
所以行为是完全一样的 

883
00:44:57,330 --> 00:45:01,890
如果我们现在快进到霍格沃茨的例子 我正在做的是

884
00:45:01,890 --> 00:45:04,500
就是把这些小点子结合起来 

885
00:45:04,500 --> 00:45:06,330
我仍在创建一个for循环 

886
00:45:06,330 --> 00:45:08,520
我还在创建一个名为i的变量 

887
00:45:08,520 --> 00:45:11,760
我想通过一系列的值来做这件事 但是有多少值呢？

888
00:45:11,760 --> 00:45:15,390
如果我使用LENGTH函数并传递给LENGTH函数

889
00:45:15,390 --> 00:45:18,300
价值清单 长度的人生目标

890
00:45:18,300 --> 00:45:21,120
就是告诉我这张单子有多长 是3张 

891
00:45:21,120 --> 00:45:25,740
所以这几乎就像以前 我刚刚做了这样的事情 

892
00:45:25,740 --> 00:45:29,220
但我不想硬编码3 我想动态地计算出

893
00:45:29,220 --> 00:45:30,870
霍格沃茨有多少学生 

894
00:45:30,870 --> 00:45:32,910
所以我只是作曲 

895
00:45:32,910 --> 00:45:36,210
或者嵌套所有这些不同的想法 

896
00:45:36,210 --> 00:45:38,880
好的 如果可以的话 现在让我过渡到--

897
00:45:38,880 --> 00:45:42,540
在霍格沃茨仍然引入了之前的最后一种数据类型

898
00:45:42,540 --> 00:45:45,690
我们把所有的东西和几个最终的节目结合在一起 

899
00:45:45,690 --> 00:45:49,410
事实证明 在Python中 不仅仅是字符串 而不仅仅是

900
00:45:49,410 --> 00:45:51,600
整数 而不仅仅是浮点值 而不是

901
00:45:51,600 --> 00:45:53,790
只是无稽之谈 不只是列表 还有

902
00:45:53,790 --> 00:45:58,560
所谓的词典或词典是一种数据结构 它允许您

903
00:45:58,560 --> 00:46:02,250
将一个值与另一个值相关联 

904
00:46:02,250 --> 00:46:04,380
字面意思是一本像人类世界一样的词典 

905
00:46:04,380 --> 00:46:07,680
如果你打开一本词典 无论是英语还是其他人类语言 

906
00:46:07,680 --> 00:46:09,190
词典里有什么？

907
00:46:09,190 --> 00:46:12,480
嗯 它是一堆单词和定义 

908
00:46:12,480 --> 00:46:14,760
不过 他是一名计算机科学家和一名程序员

909
00:46:14,760 --> 00:46:19,470
会更笼统地将这些描述为键和值

910
00:46:19,470 --> 00:46:21,360
与其他事物联系在一起 

911
00:46:21,360 --> 00:46:22,950
词典就是这么回事 

912
00:46:22,950 --> 00:46:25,930
它允许你将某物与另一物联系在一起 

913
00:46:25,930 --> 00:46:29,160
注意 这已经比列表更强大、更有趣了 

914
00:46:29,160 --> 00:46:32,670
列表只是由多个值组成的集合 

915
00:46:32,670 --> 00:46:36,240
但如果你愿意的话 字典是二维的 

916
00:46:36,240 --> 00:46:39,390
就像一本人类词典 一本书 它让人联想到一些东西

917
00:46:39,390 --> 00:46:42,210
用一些其他的东西 比如单词和它们的定义 

918
00:46:42,210 --> 00:46:44,500
那么 这实际上意味着什么呢？

919
00:46:44,500 --> 00:46:48,390
假设我们想要跟踪

920
00:46:48,390 --> 00:46:51,810
谁在霍格沃茨的哪栋房子里 

921
00:46:51,810 --> 00:46:54,240
嗯 我可以单用清单就能做到 

922
00:46:54,240 --> 00:46:55,950
让我回到这里的VS代码 让我

923
00:46:55,950 --> 00:46:59,470
只是暂时的--但我最终不会喜欢的--

924
00:46:59,470 --> 00:47:01,620
让我创建另一个名为house的变量 

925
00:47:01,620 --> 00:47:06,750
把它设为格兰芬多 相当于赫敏的房子 

926
00:47:06,750 --> 00:47:09,960
格兰芬多 对应于哈利的房子 格兰芬多 

927
00:47:09,960 --> 00:47:11,250
与罗恩的房子相对应 

928
00:47:11,250 --> 00:47:12,730
让我们把德拉科也加进去 

929
00:47:12,730 --> 00:47:14,640
所以我们现在有四个学生而不是三个

930
00:47:14,640 --> 00:47:18,810
只是为了让我们有一点变化 他在斯莱特林 

931
00:47:18,810 --> 00:47:21,300
所以现在我们有两个名单 

932
00:47:21,300 --> 00:47:24,750
我们可以在我们之间达成一致

933
00:47:24,750 --> 00:47:28,680
谁是第一名 谁就改变了人生

934
00:47:28,680 --> 00:47:31,410
在房子的第一个价值中 

935
00:47:31,410 --> 00:47:34,770
学生中排名第二的人住在第二所房子里 

936
00:47:34,770 --> 00:47:37,680
学生中排名第三的人住在第三栋房子里 

937
00:47:37,680 --> 00:47:38,730
我们可以这么做 

938
00:47:38,730 --> 00:47:41,430
但老实说 这将很快瓦解

939
00:47:41,430 --> 00:47:44,102
当我们有很多学生时 当我们有很多房子时 

940
00:47:44,102 --> 00:47:46,560
如果我们想要跟踪更多的东西呢？

941
00:47:46,560 --> 00:47:48,810
如果我们想要跟踪每个学生的家呢

942
00:47:48,810 --> 00:47:52,890
而守护神 这个他们魔术般的形象呢？

943
00:47:52,890 --> 00:47:55,290
那么 我们需要第三份清单 就像--这只是

944
00:47:55,290 --> 00:47:58,440
如果我们只是在荣誉系统上 很快就会变得一团糟

945
00:47:58,440 --> 00:48:02,640
使用多个列表 其中所有内容都在逻辑上排成一行 

946
00:48:02,640 --> 00:48:05,940
当您的代码变得更复杂时 结果不会很好 

947
00:48:05,940 --> 00:48:07,740
但我确实想要实施这个想法 

948
00:48:07,740 --> 00:48:09,990
我想把某事与某事联系起来 

949
00:48:09,990 --> 00:48:12,960
有房子的学生 有房子的学生 有房子的学生

950
00:48:12,960 --> 00:48:15,970
以此类推 那么我该如何着手做这些呢？

951
00:48:15,970 --> 00:48:18,570
好的 让我回到我的代码 让

952
00:48:18,570 --> 00:48:22,410
我建议我们使用一本Python词典来完成这项工作 

953
00:48:22,410 --> 00:48:25,560
这是我们将要看到的最后一种新语法 

954
00:48:25,560 --> 00:48:26,880
下面是新的语法 

955
00:48:26,880 --> 00:48:29,280
我们不使用方括号 而是

956
00:48:29,280 --> 00:48:32,500
在词典中也使用花括号 

957
00:48:32,500 --> 00:48:37,050
我们已经在f字符串的上下文中看到了完全无关的花括号 

958
00:48:37,050 --> 00:48:40,360
有时你会用完键盘上的键和语言的作者

959
00:48:40,360 --> 00:48:43,302
需要开始以不同的方式重新使用符号 这是

960
00:48:43,302 --> 00:48:44,260
即将发生的事情 

961
00:48:44,260 --> 00:48:46,150
我们正在以不同的方式使用花括号 

962
00:48:46,150 --> 00:48:48,690
现在 让我创建一个名为Students的变量 

963
00:48:48,690 --> 00:48:51,960
让我继续并将其设置为等于打开

964
00:48:51,960 --> 00:48:54,030
花括号和闭合花括号 

965
00:48:54,030 --> 00:48:56,670
这本词典目前是一本空词典 

966
00:48:56,670 --> 00:48:58,590
以下是词典的工作原理 

967
00:48:58,590 --> 00:49:01,150
它允许你将一些东西与其他东西联系在一起 

968
00:49:01,150 --> 00:49:02,400
然后你像这样做 

969
00:49:02,400 --> 00:49:07,777
赫敏 引号-不引号 冒号 然后是它的值 

970
00:49:07,777 --> 00:49:09,610
你想把赫敏和什么联系在一起？

971
00:49:09,610 --> 00:49:11,280
嗯 格兰芬多 

972
00:49:11,280 --> 00:49:13,680
我想把哈利和什么联系在一起？

973
00:49:13,680 --> 00:49:16,560
我想把他和格兰芬多联系起来 

974
00:49:16,560 --> 00:49:18,630
我想把罗恩和什么联系在一起？

975
00:49:18,630 --> 00:49:21,240
我想把他和格兰芬多联系起来 

976
00:49:21,240 --> 00:49:24,600
嗯 这实际上不会--这会很快变得非常丑陋 

977
00:49:24,600 --> 00:49:27,502
一旦我们加上德拉科和斯莱特林 我的代码就会变得太长 

978
00:49:27,502 --> 00:49:28,710
它要开始包装了 

979
00:49:28,710 --> 00:49:30,390
所以这纯粹是审美上的 

980
00:49:30,390 --> 00:49:33,450
它在Python和其他语言中是完全可以接受的

981
00:49:33,450 --> 00:49:36,570
为了更容易地格式化代码 只需添加新行

982
00:49:36,570 --> 00:49:38,040
如果它让它更具可读性的话 

983
00:49:38,040 --> 00:49:40,480
而这样做的一种方法可能如下所示 

984
00:49:40,480 --> 00:49:44,920
我的花托还在这 我的花托还在下面 

985
00:49:44,920 --> 00:49:47,400
但请注意 它现在的可读性更好了

986
00:49:47,400 --> 00:49:51,743
因为我的钥匙在左边 我的东西 我的价值观

987
00:49:51,743 --> 00:49:53,160
在右边 是我的其他东西 

988
00:49:53,160 --> 00:49:55,800
只是从上到下略读起来更容易一些 

989
00:49:55,800 --> 00:49:57,480
您也可以设置不同的格式 

990
00:49:57,480 --> 00:50:00,690
但我现在要说的是 德拉科

991
00:50:00,690 --> 00:50:03,210
当然 他住在斯莱特林 

992
00:50:03,210 --> 00:50:07,320
现在我把每一把钥匙都放在左边

993
00:50:07,320 --> 00:50:09,910
和右边的价值观 这真的 再一次 

994
00:50:09,910 --> 00:50:13,200
这只是这个想法的一个代码实现 一个小图表

995
00:50:13,200 --> 00:50:15,300
你可以用纸铅笔写出来

996
00:50:15,300 --> 00:50:17,620
当把某物与另一物联系在一起时 

997
00:50:17,620 --> 00:50:20,680
那么 我现在如何以一种有趣的方式使用这段代码呢？

998
00:50:20,680 --> 00:50:22,230
语法几乎是相同的 

999
00:50:22,230 --> 00:50:26,160
如果我想打印出第一个学生 赫敏的家 

1000
00:50:26,160 --> 00:50:27,150
我能做到的 

1001
00:50:27,150 --> 00:50:31,960
打印出变量的名称 但我需要进入变量内部 

1002
00:50:31,960 --> 00:50:33,810
我需要把它编入索引 

1003
00:50:33,810 --> 00:50:38,280
字典的巧妙之处在于 尽管列表

1004
00:50:38,280 --> 00:50:41,010
有数字形式的地点--

1005
00:50:41,010 --> 00:50:45,270
0 1 2；赫敏 哈利 罗恩 

1006
00:50:45,270 --> 00:50:50,520
可以说 词典允许你使用实际的单词作为你的索引 

1007
00:50:50,520 --> 00:50:52,750
您的索引以深入了解它们 

1008
00:50:52,750 --> 00:50:55,740
所以如果你想打印出赫敏的房子 

1009
00:50:55,740 --> 00:50:59,160
你关心的关键是 引用-引用 赫敏 

1010
00:50:59,160 --> 00:51:04,050
这里的语法要做的是--注意 它不是数字0、1或2 

1011
00:51:04,050 --> 00:51:05,970
这真的是赫敏的名字 

1012
00:51:05,970 --> 00:51:11,070
这就像早先去看图表 然后说 好吧 把赫敏给我

1013
00:51:11,070 --> 00:51:13,628
是我的钥匙 格兰芬多是价值 

1014
00:51:13,628 --> 00:51:15,420
这就是我们在这里从语法上所做的 

1015
00:51:15,420 --> 00:51:18,300
我们正在寻找赫敏 并得到它的价值 

1016
00:51:18,300 --> 00:51:21,120
所以 如果我回到我的代码 它应该会打印出格兰芬多 

1017
00:51:21,120 --> 00:51:24,330
如果我这样做几次 学生们 括号 引号-引号 

1018
00:51:24,330 --> 00:51:26,280
哈利应该把哈利的房子给我 

1019
00:51:26,280 --> 00:51:30,630
打印学生 打开括号 罗恩 这应该会给我罗恩的房子 

1020
00:51:30,630 --> 00:51:33,660
最后 如果我对学生们这样做 Branket Draco

1021
00:51:33,660 --> 00:51:35,727
这应该会给我德拉科的房子 

1022
00:51:35,727 --> 00:51:38,310
现在它仍然是一个小手册 我打赌我们可以改进这个 

1023
00:51:38,310 --> 00:51:40,620
但是让我在hogwarts.py上运行Python 我们

1024
00:51:40,620 --> 00:51:44,790
应该去看看格兰芬多 斯莱特林 

1025
00:51:44,790 --> 00:51:46,500
这正是我们所期待的 

1026
00:51:46,500 --> 00:51:48,810
现在我们所做的一切 再一次 是我们刚刚搬到

1027
00:51:48,810 --> 00:51:52,710
从只有一个简单的名字列表到再一次 两个维度 

1028
00:51:52,710 --> 00:51:56,070
像我们在纸上那样联想--用铅笔写东西和东西

1029
00:51:56,070 --> 00:51:58,920
否则 分别为带有值的键 

1030
00:51:58,920 --> 00:52:02,580
如果你愿意 请允许我 尽管我知道这有点花哨 

1031
00:52:02,580 --> 00:52:07,200
请允许我在这里稍微升级一下 并从查看

1032
00:52:07,200 --> 00:52:13,020
例如 在那里的模式中 只是对这些值进行硬编码

1033
00:52:13,020 --> 00:52:15,660
实际上 要更动态地打印这些内容 

1034
00:52:15,660 --> 00:52:19,510
让我继续使用我们的循环 这个问题也出现在前面 

1035
00:52:19,510 --> 00:52:25,450
让我继续说 对于学生中的每个学生 

1036
00:52:25,450 --> 00:52:31,240
继续打印出来 例如 学生们在--

1037
00:52:31,240 --> 00:52:32,920
好吧 让我们先说学生优先 

1038
00:52:32,920 --> 00:52:33,950
让我们简单点吧 

1039
00:52:33,950 --> 00:52:35,950
所以这还不会那么有趣 

1040
00:52:35,950 --> 00:52:41,470
但是 当我运行hogwarts.py的Python并按Enter时 请注意 我应该看到什么？

1041
00:52:41,470 --> 00:52:44,200
让我在这里回答一个问题 看看我是什么

1042
00:52:44,200 --> 00:52:48,910
当我在为学生做学生会的时候 我现在按回车键的时候会看到吗？

1043
00:52:48,910 --> 00:52:51,305
观众：是的 我想我们只会看到钥匙 

1044
00:52:51,305 --> 00:52:52,180
大卫·马兰：太好了 

1045
00:52:52,180 --> 00:52:53,020
这么好的直觉 

1046
00:52:53,020 --> 00:52:53,980
它可能是双向的 

1047
00:52:53,980 --> 00:52:55,540
可能是价值问题 房子问题 

1048
00:52:55,540 --> 00:53:01,300
但是 当您在Python中使用for循环迭代字典时 

1049
00:53:01,300 --> 00:53:03,550
它遍历所有键 

1050
00:53:03,550 --> 00:53:07,960
所以我们应该看看 我想 赫敏、哈利、罗恩和德拉科 

1051
00:53:07,960 --> 00:53:11,260
现在让我按Enter键 Enter键 确实 你说的完全正确 

1052
00:53:11,260 --> 00:53:12,580
我们只看到了钥匙 

1053
00:53:12,580 --> 00:53:15,580
但如果我真正关心的是

1054
00:53:15,580 --> 00:53:18,430
是谁住在哪里 我能把两个都打印出来吗？

1055
00:53:18,430 --> 00:53:19,930
嗯 我想我可以 

1056
00:53:19,930 --> 00:53:21,350
让我继续做这件事 

1057
00:53:21,350 --> 00:53:24,850
让我打印出的不仅仅是学生的名字 钥匙 

1058
00:53:24,850 --> 00:53:30,537
但让我使用关键字 他们的名字 来索引词典 

1059
00:53:30,537 --> 00:53:33,370
如果我在词典里知道这个词 让我查一下它的释义 

1060
00:53:33,370 --> 00:53:35,980
如果我知道那个学生的名字 让我查一下他们的房子 

1061
00:53:35,980 --> 00:53:40,720
而这个的语法 就像一个列表一样 是学生 括号 

1062
00:53:40,720 --> 00:53:44,480
就像过去我们在我还是数字的时候用i一样 

1063
00:53:44,480 --> 00:53:48,080
我们也可以在词典中使用字符串 

1064
00:53:48,080 --> 00:53:55,180
所以如果学生的名字是关键 那么这个语法 学生 

1065
00:53:55,180 --> 00:54:00,340
开括号 学生 关闭括号将前往赫敏的位置

1066
00:54:00,340 --> 00:54:01,330
然后拿回她的房子 

1067
00:54:01,330 --> 00:54:04,970
会去哈利的住处 拿回他的房子 等等 

1068
00:54:04,970 --> 00:54:08,943
因此 如果我执行hogwarts.py的Python 输入 现在我

1069
00:54:08,943 --> 00:54:11,485
见赫敏 格兰芬多；哈利 格兰芬多；罗恩 格兰芬多；

1070
00:54:11,485 --> 00:54:12,730
还有德拉科·斯莱特林 

1071
00:54:12,730 --> 00:54:14,940
现在看起来我给了他们所有人新的姓氏 

1072
00:54:14,940 --> 00:54:15,940
但我可以把它清理干净 

1073
00:54:15,940 --> 00:54:17,170
这只是一个打印的东西 

1074
00:54:17,170 --> 00:54:20,110
让我们继续更改默认空格中的分隔符

1075
00:54:20,110 --> 00:54:21,790
可能是一个空格 逗号 

1076
00:54:21,790 --> 00:54:26,110
现在使用打印功能 让我再次运行相同的程序 输入 

1077
00:54:26,110 --> 00:54:29,050
现在我只需要在里面加几个漂亮的逗号来说明

1078
00:54:29,050 --> 00:54:31,810
赫敏的姓氏其实不是格兰芬多 

1079
00:54:31,810 --> 00:54:33,730
但这只是一个指纹细节 

1080
00:54:33,730 --> 00:54:37,120
那么 对这些词典还有什么问题吗？还有我刚才做了什么？

1081
00:54:39,650 --> 00:54:45,410
关于这些词典的问题 然后在这里循环？

1082
00:54:45,410 --> 00:54:52,190
观众：我就是想不通学生中的学生 

1083
00:54:52,190 --> 00:54:54,860
如果我--如果我是对的就纠正我 

1084
00:54:54,860 --> 00:55:01,850
这是否意味着它导入了学生名单并使用了索引--

1085
00:55:01,850 --> 00:55:09,140
或者换句话说 赫敏、哈利和罗恩作为实际中的索引--

1086
00:55:09,140 --> 00:55:10,455
学生名单？

1087
00:55:10,455 --> 00:55:11,330
大卫·马兰：正确 

1088
00:55:11,330 --> 00:55:13,100
因此 这只是Python的一个功能 

1089
00:55:13,100 --> 00:55:17,150
当您在字典中使用for循环时 会发生这样的情况 

1090
00:55:17,150 --> 00:55:20,513
如果这是字典 关键字在上面 值在下面 

1091
00:55:20,513 --> 00:55:22,430
您可以选择变量的名称 

1092
00:55:22,430 --> 00:55:24,818
我给我的变量学生打电话 只是因为这有道理 

1093
00:55:24,818 --> 00:55:26,360
因为我每次只想要一个学生 

1094
00:55:26,360 --> 00:55:29,510
For循环所做的 就像它以前对数字所做的那样 

1095
00:55:29,510 --> 00:55:33,060
0、1和2 它允许我 例如 

1096
00:55:33,060 --> 00:55:35,810
将学生初始设置为与赫梅林的名字相等 

1097
00:55:35,810 --> 00:55:38,990
然后循环的下一个迭代 下一个周期 

1098
00:55:38,990 --> 00:55:42,800
将学生设置为哈利的名字 然后是罗恩 然后是德拉科 

1099
00:55:42,800 --> 00:55:44,300
这是自然而然发生的 

1100
00:55:44,300 --> 00:55:47,480
这就是Python解释器在以下情况下为您做的事情

1101
00:55:47,480 --> 00:55:49,140
它看到了这样的for循环 

1102
00:55:49,140 --> 00:55:53,090
因此 它在本质上非常类似于在列表上使用for循环迭代 

1103
00:55:53,090 --> 00:55:55,670
而不是迭代该数字位置 

1104
00:55:55,670 --> 00:56:01,700
0 1 2 它遍历此表示形式中的粗体键

1105
00:56:01,700 --> 00:56:02,930
图形化的 

1106
00:56:02,930 --> 00:56:05,960
请允许我再给我们举一个关于霍格沃茨的例子

1107
00:56:05,960 --> 00:56:09,320
在我们看另一个熟悉的领域之前 

1108
00:56:09,320 --> 00:56:11,670
冒着事态升级的风险 

1109
00:56:11,670 --> 00:56:15,320
让我提议让我们用最后一位霍格沃茨来继续这个故事

1110
00:56:15,320 --> 00:56:17,100
像这样的例子 

1111
00:56:17,100 --> 00:56:21,280
如果我们有更多关于我们每个学生的信息会怎么样？

1112
00:56:21,280 --> 00:56:23,030
这是不可避免的 

1113
00:56:23,030 --> 00:56:26,760
如果您正在实施一个与人或客户建立数据库的计划 

1114
00:56:26,760 --> 00:56:29,060
或员工或其他任何东西 你可以想象

1115
00:56:29,060 --> 00:56:33,230
拥有关于您在程序中表示的任何内容的大量数据

1116
00:56:33,230 --> 00:56:33,740
这里 

1117
00:56:33,740 --> 00:56:37,470
为了便于讨论 假设霍格沃茨的每个学生 当然 

1118
00:56:37,470 --> 00:56:41,480
有了名字 他们已经有了房子 但他们也有了守护神 

1119
00:56:41,480 --> 00:56:44,360
对于那些不熟悉的人来说 这是动物或实体

1120
00:56:44,360 --> 00:56:48,260
当他们施展某种魔法咒语时 魔杖的末端就会发出这种魔力 

1121
00:56:48,260 --> 00:56:51,410
这里的重点是 我们想要将

1122
00:56:51,410 --> 00:56:55,670
对学生只有一件事 但有多件事

1123
00:56:55,670 --> 00:57:00,110
还有--他们的名字 他们的房子 以及他们的赞助人 

1124
00:57:00,110 --> 00:57:02,400
那么 这样的代码可能是什么样子的呢？

1125
00:57:02,400 --> 00:57:07,100
好了 让我回到hogwarts.py 让我重新开始一小会儿 

1126
00:57:07,100 --> 00:57:10,650
让我建议我用更多的数据来加强这一点 

1127
00:57:10,650 --> 00:57:12,800
这些数据将如下所示 

1128
00:57:12,800 --> 00:57:18,360
我的学生现在变了 我建议我们把它当作一个列表 

1129
00:57:18,360 --> 00:57:21,320
如果我们有一份如下的词典清单 会怎么样？

1130
00:57:21,320 --> 00:57:24,960
事实上 我想在这里真正实现这一图景 

1131
00:57:24,960 --> 00:57:29,210
所以请注意 我之前的图片只代表了一本词典 

1132
00:57:29,210 --> 00:57:33,500
但假设我想编写一份词典列表 

1133
00:57:33,500 --> 00:57:36,650
也就是说 对于学生来说--所以有四名学生 

1134
00:57:36,650 --> 00:57:41,240
假设这些学生本身就是一本词典 

1135
00:57:41,240 --> 00:57:46,130
键值对、键和值的集合 

1136
00:57:46,130 --> 00:57:48,180
一件又一件 

1137
00:57:48,180 --> 00:57:50,990
好的 这是我们可以用代码实现的另一种方法 

1138
00:57:50,990 --> 00:57:55,130
让我回到这里的VS代码 并定义一个名为

1139
00:57:55,130 --> 00:57:58,100
等同于列表的学生 

1140
00:57:58,100 --> 00:58:01,343
我会先发制人地将光标移动到不同的行上 

1141
00:58:01,343 --> 00:58:03,260
因为我知道这会很漫长 而且我

1142
00:58:03,260 --> 00:58:07,320
我想将此列表中的所有元素都放入其中 

1143
00:58:07,320 --> 00:58:10,555
我现在要创建一本词典 每个学生一本词典 

1144
00:58:10,555 --> 00:58:11,930
我如何创建一本词典？

1145
00:58:11,930 --> 00:58:13,670
我只是用那些花括号 

1146
00:58:13,670 --> 00:58:16,220
但这取决于我来定义那些关键是什么 

1147
00:58:16,220 --> 00:58:18,500
让我提出这一次的一个关键

1148
00:58:18,500 --> 00:58:20,750
不会明确是学生的名字 是吗？

1149
00:58:20,750 --> 00:58:24,980
字面上是单词名字 在那里 将有名字赫敏 

1150
00:58:24,980 --> 00:58:28,700
同一个学生将有另一把名为House的钥匙

1151
00:58:28,700 --> 00:58:31,010
价值将是格兰芬多 

1152
00:58:31,010 --> 00:58:34,700
而同一个学生将拥有第三把钥匙 名为Patronus 

1153
00:58:34,700 --> 00:58:36,620
而它的价值将是--

1154
00:58:36,620 --> 00:58:39,710
我不得不去查一查--根据书上的说法 是一只水獭 

1155
00:58:39,710 --> 00:58:43,012
现在 我将在该列表中创建第二个词典 

1156
00:58:43,012 --> 00:58:44,720
再说一次 词典就像字面意思

1157
00:58:44,720 --> 00:58:46,710
就像人类的词典一样 

1158
00:58:46,710 --> 00:58:50,750
这是一本包含关键和价值观、词汇和定义的书 

1159
00:58:50,750 --> 00:58:53,630
我在每本词典里储存的三个单词是什么？

1160
00:58:53,630 --> 00:58:55,640
名字 房子和守护神 

1161
00:58:55,640 --> 00:58:58,940
这些词对赫敏的定义是什么？

1162
00:58:58,940 --> 00:59:01,850
分别是赫敏、格兰芬多和水獭 

1163
00:59:01,850 --> 00:59:05,840
对哈里来说 这本新词典的释义将有所不同 

1164
00:59:05,840 --> 00:59:08,270
让我再给自己配一副花箍

1165
00:59:08,270 --> 00:59:12,230
然后说这个 名字 引号 冒号 哈利 

1166
00:59:12,230 --> 00:59:15,500
这里的房子又一次将是格兰芬多 

1167
00:59:15,500 --> 00:59:21,620
而我认识的这位 他的守护神 在这种情况下 将是一只雄鹿 

1168
00:59:21,620 --> 00:59:23,330
接下来是第三本词典 

1169
00:59:23,330 --> 00:59:25,130
这里的名字将是罗恩 

1170
00:59:25,130 --> 00:59:27,560
我会像这样继续做下去 

1171
00:59:27,560 --> 00:59:31,070
接下来 我得到了房子 他也是格兰芬多 

1172
00:59:31,070 --> 00:59:38,120
最后 我要查一查 罗恩的赞助人是一只杰克·罗素梗犬 

1173
00:59:38,120 --> 00:59:42,100
最后是德拉科 

1174
00:59:42,100 --> 00:59:45,070
在第四本词典中--又一对花括号 

1175
00:59:45,070 --> 00:59:47,380
当然 这名学生的名字是德拉科 

1176
00:59:47,380 --> 00:59:50,650
这个学生的房子是斯莱特林 

1177
00:59:50,650 --> 00:59:55,630
而德拉科 有趣的是 至少根据互联网上的说法 

1178
00:59:55,630 --> 00:59:57,010
没有守护神 

1179
00:59:57,010 --> 00:59:59,230
从未在书中或电影中出现过 

1180
00:59:59,230 --> 01:00:02,290
事实证明 这实际上是一个很棒的可教的时刻 

1181
01:00:02,290 --> 01:00:08,170
在Python中有一个特殊的关键字 字面意思是None N-O-N-E 

1182
01:00:08,170 --> 01:00:10,360
第一个字母大写 

1183
01:00:10,360 --> 01:00:14,210
这正式地代表了价值的缺失 

1184
01:00:14,210 --> 01:00:17,440
所以我可以草率地做一些类似引用-引用的事情 

1185
01:00:17,440 --> 01:00:20,410
但这是否意味着我没有抽出时间来打字呢？

1186
01:00:20,410 --> 01:00:24,880
从语义上说 字面上没有 一个特殊的关键字 这是有点清楚的

1187
01:00:24,880 --> 01:00:29,620
我知道德拉科没有守护神 

1188
01:00:29,620 --> 01:00:32,320
这不仅仅是我的疏忽

1189
01:00:32,320 --> 01:00:36,370
现在我有了这个 我在电脑内存里有什么？

1190
01:00:36,370 --> 01:00:37,360
我有一个名单 

1191
01:00:37,360 --> 01:00:38,620
我怎么知道这是名单

1192
01:00:38,620 --> 01:00:42,310
因为我在开头看到一个方括号 

1193
01:00:42,310 --> 01:00:42,850
到最后

1194
01:00:42,850 --> 01:00:45,730
这只是我的视觉线索 好吧 我不一定知道

1195
01:00:45,730 --> 01:00:48,910
这里还有什么 但有一张清单

1196
01:00:48,910 --> 01:00:50,960
名单上有什么？

1197
01:00:50,960 --> 01:00:53,560
在这里 语法也是我们的线索 

1198
01:00:53,560 --> 01:00:57,820
因为第2行以花括号开始并以花括号结束 

1199
01:00:57,820 --> 01:01:02,570
我只知道 那是一个字典 一个键值对的集合 

1200
01:01:02,570 --> 01:01:04,930
现在这些都完美地显示在我的屏幕上 所以我

1201
01:01:04,930 --> 01:01:08,020
并没有麻烦将所有的键值对移动到新的行上 

1202
01:01:08,020 --> 01:01:11,620
它会变得很高 所以这次我把它放在一起 

1203
01:01:11,620 --> 01:01:15,520
但是这第一本字典有多少个键呢？

1204
01:01:15,520 --> 01:01:17,897
换句话说 在赫敏的物理字典里 

1205
01:01:17,897 --> 01:01:19,480
那本字典里有多少单词？

1206
01:01:19,480 --> 01:01:20,230
三.

1207
01:01:20,230 --> 01:01:22,990
这些词是名字 房子和守护神 

1208
01:01:22,990 --> 01:01:26,140
这些词的三个定义或价值是什么

1209
01:01:26,140 --> 01:01:27,640
在赫敏的字典里

1210
01:01:27,640 --> 01:01:31,000
赫敏 格兰芬多 水獭 

1211
01:01:31,000 --> 01:01:35,360
同样的故事也发生在哈利身上 然后是罗恩 

1212
01:01:35,360 --> 01:01:39,190
那么对于德拉科我特意选择了

1213
01:01:39,190 --> 01:01:44,440
给他们字典 所有相同的键 所有相同的名字 

1214
01:01:44,440 --> 01:01:47,200
但它们都有独特的价值 

1215
01:01:47,200 --> 01:01:50,080
这就是我的设计 这是我作为一个程序员的特权 

1216
01:01:50,080 --> 01:01:53,200
那么 为什么这在今天结束时有用呢？

1217
01:01:53,200 --> 01:01:57,130
我有一整套有趣的数据

1218
01:01:57,130 --> 01:01:59,620
我仍然可以做循环 

1219
01:01:59,620 --> 01:02:02,980
我可以说 对于学生中的学生来说 

1220
01:02:02,980 --> 01:02:05,590
允许我浏览一下学生名单

1221
01:02:05,590 --> 01:02:08,240
让我一次只打印一件东西 

1222
01:02:08,240 --> 01:02:10,610
我把现在学生的名字打印出来 

1223
01:02:10,610 --> 01:02:14,470
尽管字典很复杂 但这应该很方便 

1224
01:02:14,470 --> 01:02:18,490
对于学生中的学生 只需迭代列表中的每个学生 

1225
01:02:18,490 --> 01:02:20,420
总计1 2 3 4 

1226
01:02:20,420 --> 01:02:24,580
下一行将打印NAME键的值 

1227
01:02:24,580 --> 01:02:27,850
这就像打开物理词典 查找单词名称 

1228
01:02:27,850 --> 01:02:30,670
给我们赫敏、哈利、罗恩和德拉科

1229
01:02:30,670 --> 01:02:32,480
分别来自每个词典 

1230
01:02:32,480 --> 01:02:36,880
因此 如果我运行这个版本的霍格沃茨 然后按Enter键 在那里 我会得到所有三个

1231
01:02:36,880 --> 01:02:37,780
他们的名字 

1232
01:02:37,780 --> 01:02:39,790
但如果我想要更多的信息呢？

1233
01:02:39,790 --> 01:02:42,040
我要他们的名字和他们的房子 

1234
01:02:42,040 --> 01:02:47,650
好的 只要加上普莱特的论点 学生 左括号 房子 

1235
01:02:47,650 --> 01:02:48,910
右方括号 

1236
01:02:48,910 --> 01:02:50,740
好的 让我们继续运行这个 

1237
01:02:50,740 --> 01:02:53,170
Python of hogwarts.py并按Enter 

1238
01:02:53,170 --> 01:02:56,078
所以我现在看到了赫敏 格兰芬多 哈利 格兰芬多 等等 

1239
01:02:56,078 --> 01:02:58,120
好的 我们可以在美学上把这件事清理一下

1240
01:02:58,120 --> 01:03:01,480
通过添加带有印刷体的分隔符 如逗号和空格 

1241
01:03:01,480 --> 01:03:03,760
这样 当我再次运行此程序时 我现在

1242
01:03:03,760 --> 01:03:05,680
请看用逗号分隔这些值 

1243
01:03:05,680 --> 01:03:08,290
但请记住 学生不仅有一个名字 也不仅仅是

1244
01:03:08,290 --> 01:03:09,910
一栋房子 还有那个守护神 

1245
01:03:09,910 --> 01:03:12,700
因此 如果我们也想打印出来 我们现在

1246
01:03:12,700 --> 01:03:18,040
我有为每个学生编写同一本词典所使用的语法

1247
01:03:18,040 --> 01:03:22,010
并以他们的名义输出他们的赞助人和他们的房子 

1248
01:03:22,010 --> 01:03:24,520
所以如果我最后一次运行这个程序 现在我

1249
01:03:24,520 --> 01:03:28,490
请参阅本词典中的所有数据 

1250
01:03:28,490 --> 01:03:31,390
因此 我相信 一下子要消化的东西很多 

1251
01:03:31,390 --> 01:03:33,367
这是我们最后一种新的数据类型 

1252
01:03:33,367 --> 01:03:35,200
在清单的顶端 我们有这些词典 

1253
01:03:35,200 --> 01:03:37,750
但同样 一本词典 在一天结束的时候 

1254
01:03:37,750 --> 01:03:41,740
只是类似于这些值的值的集合

1255
01:03:41,740 --> 01:03:44,780
在这里 您可以将键与值相关联 

1256
01:03:44,780 --> 01:03:48,520
这个程序的第一个版本从字面上看与学生的

1257
01:03:48,520 --> 01:03:51,040
名字和他们的房子 但后来我意识到

1258
01:03:51,040 --> 01:03:53,920
在我的下一个版本中 等等 如果每个学生都没有

1259
01:03:53,920 --> 01:03:55,990
只是房子里的一个名字 但是一个守护神？

1260
01:03:55,990 --> 01:03:59,230
让我们真正标准化密钥的名称

1261
01:03:59,230 --> 01:04:03,850
是名字、房子和守护神 然后是这些关键字的价值

1262
01:04:03,850 --> 01:04:08,530
实际上可以是数据 比如赫敏、格兰芬多、水獭等等 

1263
01:04:08,530 --> 01:04:13,240
现在关于这些词典及其迭代的问题是什么？

1264
01:04:13,240 --> 01:04:18,710
听众：我只是在想 假设这本词典很大 

1265
01:04:18,710 --> 01:04:22,270
如果我想找一个特定的学生 

1266
01:04:22,270 --> 01:04:26,650
那么我怎么知道从哪里看那个学生呢？

1267
01:04:26,650 --> 01:04:29,470
比如我们能按字母顺序排序吗？

1268
01:04:29,470 --> 01:04:32,163
或数字顺序或类似的东西？

1269
01:04:32,163 --> 01:04:33,580
大卫·马兰：简而言之 是的 

1270
01:04:33,580 --> 01:04:37,570
Python的特点之一是它使这些词典非常高

1271
01:04:37,570 --> 01:04:38,680
为你表演的 

1272
01:04:38,680 --> 01:04:42,280
也就是说 即使它们非常大 因为它们将在未来几周内

1273
01:04:42,280 --> 01:04:45,910
当我们操作更多的数据时 Python会找到这些数据

1274
01:04:45,910 --> 01:04:48,520
你很快就会关心你的 

1275
01:04:48,520 --> 01:04:50,650
事实上 这是语言的一个特点 

1276
01:04:50,650 --> 01:04:53,560
这是一本词典的一个特点 可以让你快速获得数据 

1277
01:04:53,560 --> 01:04:55,480
还有一些你可以使用的函数 

1278
01:04:55,480 --> 01:04:57,550
你可以对数据进行分类 你可以筛选它 

1279
01:04:57,550 --> 01:05:01,870
你可以像我们最终所做的那样 做非常出色的手术 

1280
01:05:01,870 --> 01:05:05,800
那么 请允许我提议 当我们结束这些循环时 

1281
01:05:05,800 --> 01:05:08,740
我们只解决了最后几个问题 可能会

1282
01:05:08,740 --> 01:05:11,050
至少唤起了对往年的美好回忆

1283
01:05:11,050 --> 01:05:13,540
对我来说 在我成长过程中最喜欢的游戏之一

1284
01:05:13,540 --> 01:05:15,850
这张是在最初的任天堂上的吗？

1285
01:05:15,850 --> 01:05:19,240
这是一个角色向上移动的二维世界 

1286
01:05:19,240 --> 01:05:23,020
向下 向右 不是太靠左 跳过

1287
01:05:23,020 --> 01:05:25,060
像这样的金字塔和障碍物 

1288
01:05:25,060 --> 01:05:27,670
请允许我提议我们用这个来启发灵感 

1289
01:05:27,670 --> 01:05:31,180
不是做像这样色彩鲜艳或图形化的事情 而是

1290
01:05:31,180 --> 01:05:34,990
例如 要关注世界中部的这一障碍

1291
01:05:34,990 --> 01:05:38,080
在这里 马里奥或路易吉不得不跳过 

1292
01:05:38,080 --> 01:05:42,372
所以这里看起来就像是三块砖一块一块地踩在一起 

1293
01:05:42,372 --> 01:05:44,080
我们不会把事情做得很生动 

1294
01:05:44,080 --> 01:05:48,190
但让我们只实现一个非常简单的基于Python的文本版本

1295
01:05:48,190 --> 01:05:50,440
可能只使用散列来制作砖块 

1296
01:05:50,440 --> 01:05:53,500
因为这里有一个模式 一个在另一个之上 而我

1297
01:05:53,500 --> 01:05:56,170
我打赌我们可以用很多方法来解决这个问题 

1298
01:05:56,170 --> 01:05:58,720
好了 让我在这里切换回VS代码

1299
01:05:58,720 --> 01:06:03,340
让我建议我们使用代码创建一个名为mario.py的程序

1300
01:06:03,340 --> 01:06:04,750
在终端窗口中 

1301
01:06:04,750 --> 01:06:07,630
然后在这里 让我从实现相同的图景开始

1302
01:06:07,630 --> 01:06:11,590
尽可能简单地打印出散列 

1303
01:06:11,590 --> 01:06:14,830
然后是散列 然后是第三个最终散列 

1304
01:06:14,830 --> 01:06:17,500
这将是一个非常文本的近似值 

1305
01:06:17,500 --> 01:06:20,440
但我认为 如果我运行Python mario.py 我已经

1306
01:06:20,440 --> 01:06:25,840
可以说 我得到了一个非常简单的相同的砖柱版本 

1307
01:06:25,840 --> 01:06:28,150
但你可以想象在一场比赛中

1308
01:06:28,150 --> 01:06:31,380
可能这些柱子会变高或变低 

1309
01:06:31,380 --> 01:06:33,880
如果能写出更多的代码就好了

1310
01:06:33,880 --> 01:06:37,690
而不是仅仅使用打印 这就是字面意思

1311
01:06:37,690 --> 01:06:39,340
复制和粘贴 似乎是这样的 

1312
01:06:39,340 --> 01:06:42,550
所以至少让我采纳今天的一些经验教训

1313
01:06:42,550 --> 01:06:44,650
学到了东西 然后做了这样的事情 

1314
01:06:44,650 --> 01:06:50,620
为了在3的范围内加下划线 现在让我们一次只打印其中的一个 

1315
01:06:50,620 --> 01:06:53,230
但事实是 我现在用3来标示

1316
01:06:53,230 --> 01:06:55,840
意思是如果我想把它改成更大或更小的 

1317
01:06:55,840 --> 01:06:59,350
我在一个地方改变它 而不是在三个或更多的地方 

1318
01:06:59,350 --> 01:07:01,450
当然 这个代码也是如此 如果我没有弄错的话 

1319
01:07:01,450 --> 01:07:05,150
会打印出一模一样的东西 

1320
01:07:05,150 --> 01:07:06,610
所以我们在这里迭代 

1321
01:07:06,610 --> 01:07:08,860
但让我们看看我们现在能不能把我们的讨论

1322
01:07:08,860 --> 01:07:13,420
编写我们自己的函数 以开始编写一些更具动感的东西

1323
01:07:13,420 --> 01:07:16,180
并最终解决更复杂的问题 

1324
01:07:16,180 --> 01:07:18,130
函数的优点之一是

1325
01:07:18,130 --> 01:07:21,550
它们不仅允许我们编写我们可以使用和重复使用的代码 

1326
01:07:21,550 --> 01:07:24,640
它们允许我们创建抽象 如果您愿意的话 

1327
01:07:24,640 --> 01:07:28,990
抽象是对可能更复杂的概念的简化 

1328
01:07:28,990 --> 01:07:31,870
在几周的时间里 我们已经看到了几次这样的情况 

1329
01:07:31,870 --> 01:07:35,650
例如 我们有一个名为Hello的函数 当然 它不能

1330
01:07:35,650 --> 01:07:37,480
所有这些 它只是打印了问候 

1331
01:07:37,480 --> 01:07:40,960
但它让我可以准确地理解它的功能 

1332
01:07:40,960 --> 01:07:44,590
不是一般的打印东西 而是字面上的问候 

1333
01:07:44,590 --> 01:07:48,520
我已经能够使用类似的方法获得一个数字 方法是定义

1334
01:07:48,520 --> 01:07:50,320
我自己的函数 比如Get Number 

1335
01:07:50,320 --> 01:07:53,650
好吧 让我继续 举个例子 暂时假设

1336
01:07:53,650 --> 01:07:57,160
在我的主要功能中 我已经有了先见之明 

1337
01:07:57,160 --> 01:07:59,770
使用名为Print Column的函数 

1338
01:07:59,770 --> 01:08:03,190
这似乎是一个使用一个函数的好名字

1339
01:08:03,190 --> 01:08:05,290
打印一列砖 

1340
01:08:05,290 --> 01:08:07,660
那么 我现在该如何着手实施

1341
01:08:07,660 --> 01:08:12,100
这种抽象 这种简单的打印列与实际代码的想法？

1342
01:08:12,100 --> 01:08:14,500
嗯 我们以前见过def 我们可以做到这一点 

1343
01:08:14,500 --> 01:08:16,720
让我定义一个名为Print Column函数 

1344
01:08:16,720 --> 01:08:21,220
一般来说 让我接受一个名为Height的参数作为它的输入 

1345
01:08:21,220 --> 01:08:25,029
我可以称它为n或h 但现在用身高表示会更清楚一些

1346
01:08:25,029 --> 01:08:27,250
只是为了提醒我自己它在做什么 

1347
01:08:27,250 --> 01:08:30,819
现在我想我可以借用以前的一些相同的代码 

1348
01:08:30,819 --> 01:08:37,990
对于n个高度范围的下划线 请继续并打印出单个散列 

1349
01:08:37,990 --> 01:08:41,050
然后在整个程序结束时 让我们只调用main 

1350
01:08:41,050 --> 01:08:43,120
所以我把代码变得有点复杂了 

1351
01:08:43,120 --> 01:08:45,580
它目前还不能做更多的事情 但它

1352
01:08:45,580 --> 01:08:48,310
让我来解决我认为将要发生的事情

1353
01:08:48,310 --> 01:08:50,080
更复杂的问题 

1354
01:08:50,080 --> 01:08:53,170
如果我运行Python of mario.py 我们又回到了开始的地方 

1355
01:08:53,170 --> 01:08:57,520
但我现在有了一个函数 一个抽象 打印专栏 

1356
01:08:57,520 --> 01:09:00,040
这会让我考虑打印

1357
01:09:00,040 --> 01:09:03,432
一次是马里奥世界的一小部分 

1358
01:09:03,432 --> 01:09:05,140
我也可以用不同的方式做到这一点 

1359
01:09:05,140 --> 01:09:09,080
请注意 如果我真的想 我可以做这样的事情 

1360
01:09:09,080 --> 01:09:12,260
我可以用不同方式实现现在打印列 

1361
01:09:12,260 --> 01:09:15,260
尤其是当我在代码中使用打印列时 

1362
01:09:15,260 --> 01:09:19,220
或者 我的一位同事 一位朋友 互联网上的其他人

1363
01:09:19,220 --> 01:09:21,200
正在使用我的打印栏功能 

1364
01:09:21,200 --> 01:09:23,899
您编写的函数还有什么好的地方

1365
01:09:23,899 --> 01:09:27,770
是您可以更改它们的底层实现细节 

1366
01:09:27,770 --> 01:09:31,850
但只要您不更改函数的名称或其参数

1367
01:09:31,850 --> 01:09:35,870
或者它的回报是什么 如果说有什么不同的话 那就是没有人知道其中的区别 

1368
01:09:35,870 --> 01:09:37,970
您可以更改内部实现

1369
01:09:37,970 --> 01:09:41,760
如果你想改进它或随着时间的推移进行修复 你想要多少就有多少 

1370
01:09:41,760 --> 01:09:44,390
例如 我们可以实现打印列的另一种方式 

1371
01:09:44,390 --> 01:09:46,340
回想一下 应该是这样的 

1372
01:09:46,340 --> 01:09:48,920
用一个散列和一个新的行有点聪明 

1373
01:09:48,920 --> 01:09:51,750
然后也许我们可以做弦的乘法 

1374
01:09:51,750 --> 01:09:54,080
然后以引号-非引号结束此行 

1375
01:09:54,080 --> 01:09:57,110
同样 如果您不熟悉这种语法 也没有关系 

1376
01:09:57,110 --> 01:09:59,660
这是我们过去看到的一种更聪明的方法 

1377
01:09:59,660 --> 01:10:04,280
但是如果我在这里运行Python of mario.py 我仍然会看到一个包含三个元素的列 

1378
01:10:04,280 --> 01:10:07,040
但这里重要的是 Main并不

1379
01:10:07,040 --> 01:10:12,110
需要知道的是Print列的底层实现

1380
01:10:12,110 --> 01:10:13,980
已经改变了 

1381
01:10:13,980 --> 01:10:15,980
好吧 让我们过渡到一个不同的维度 

1382
01:10:15,980 --> 01:10:19,400
如果您愿意 与其打印出这些垂直的砖块 不如让我们

1383
01:10:19,400 --> 01:10:22,160
在游戏中快进到世界的这一部分 

1384
01:10:22,160 --> 01:10:25,490
在某些地方 马里奥在天空中遇到了这些砖块 

1385
01:10:25,490 --> 01:10:27,690
如果他从下面跳起来 它们就会变成硬币 

1386
01:10:27,690 --> 01:10:29,780
因此 他获得了他的分数 

1387
01:10:29,780 --> 01:10:32,270
但让我们继续 只关注那些硬币 

1388
01:10:32,270 --> 01:10:34,460
让我提议我们打印出来 哦 只是

1389
01:10:34,460 --> 01:10:36,110
这里有四个问号 

1390
01:10:36,110 --> 01:10:38,150
让我回到VS Code这里 

1391
01:10:38,150 --> 01:10:41,480
让我建议在VS代码中 就像以前一样 我们

1392
01:10:41,480 --> 01:10:43,010
试着把这件事抽象出来 

1393
01:10:43,010 --> 01:10:45,290
所以让我继续下去 去掉这个版本 

1394
01:10:45,290 --> 01:10:49,520
因为我们现在的产出是水平的 而不是垂直的 

1395
01:10:49,520 --> 01:10:53,690
让我说 好吧 打印行四次 

1396
01:10:53,690 --> 01:10:56,360
让我把手头的问题抽象出来 

1397
01:10:56,360 --> 01:10:59,180
我还不知道该如何打印这四个问号 

1398
01:10:59,180 --> 01:11:03,770
但让我们将其称为print row 4 我将假设我现在将解决这个问题 

1399
01:11:03,770 --> 01:11:06,800
现在让我们进入解决这个问题的那个兔子洞 

1400
01:11:06,800 --> 01:11:09,020
定义一个名为print row的函数 

1401
01:11:09,020 --> 01:11:11,570
它将采用宽度而不是高度 

1402
01:11:11,570 --> 01:11:14,030
因为它是水平的而不是垂直的 

1403
01:11:14,030 --> 01:11:15,750
我怎么才能做到这一点？

1404
01:11:15,750 --> 01:11:19,160
现在 我们有机会做更多的弦乘法

1405
01:11:19,160 --> 01:11:19,760
优雅地 

1406
01:11:19,760 --> 01:11:23,300
我可以说引号-不引号 问号 时间宽度 

1407
01:11:23,300 --> 01:11:28,010
这是一种非常精美的毕德式的打印方式 否则

1408
01:11:28,010 --> 01:11:29,990
做一个循环 这很好 但这是

1409
01:11:29,990 --> 01:11:32,630
继续为我打印那些问号 

1410
01:11:32,630 --> 01:11:37,130
让我们来做Python of mario.py 回车 现在我得到了四个问号 

1411
01:11:37,130 --> 01:11:39,530
它远不如更图形化的版本漂亮 

1412
01:11:39,530 --> 01:11:44,390
但这至少是迈向

1413
01:11:44,390 --> 01:11:47,870
现在是一个可重复使用的函数 如print row 

1414
01:11:47,870 --> 01:11:49,130
我为什么要做这一切？

1415
01:11:49,130 --> 01:11:52,820
比如 为什么我们要过度设计这些问题的解决方案

1416
01:11:52,820 --> 01:11:54,920
通过打印列和打印行吗？

1417
01:11:54,920 --> 01:11:57,620
嗯 这是一种有用的解决问题的技巧 

1418
01:11:57,620 --> 01:12:00,410
一旦你的世界看起来不是一维的

1419
01:12:00,410 --> 01:12:04,130
像这样或者用专栏的版本 但是这个呢？

1420
01:12:04,130 --> 01:12:08,270
后来在《超级马里奥兄弟》中 马里奥必须跳进这个世界吗？

1421
01:12:08,270 --> 01:12:11,000
那里有很多这样的黑社会障碍 

1422
01:12:11,000 --> 01:12:13,400
例如 这里的这个看起来像一个正方形 

1423
01:12:13,400 --> 01:12:16,400
它是二维的 有一个高度和一个宽度 

1424
01:12:16,400 --> 01:12:18,830
也就是说 有很多不同的方式

1425
01:12:18,830 --> 01:12:21,980
我们可以实施这件事 如果 也许是为了讨论 

1426
01:12:21,980 --> 01:12:26,780
这就像一个3x3的网格 一个3x3的正方形 

1427
01:12:26,780 --> 01:12:29,570
那么 我们该如何着手解决这个问题呢？

1428
01:12:29,570 --> 01:12:32,060
好吧 让我提议我们回到VS代码

1429
01:12:32,060 --> 01:12:36,420
让我提议我们用几种不同的方式来思考这个问题 

1430
01:12:36,420 --> 01:12:39,740
我可以这样做 

1431
01:12:39,740 --> 01:12:44,450
如果我知道我要去哪里 也许我是一个经验丰富的程序员 让我继续前进

1432
01:12:44,450 --> 01:12:45,060
然后这样做 

1433
01:12:45,060 --> 01:12:48,530
让我打印一个正方形 它的宽度和高度是3 

1434
01:12:48,530 --> 01:12:49,487
这是一个抽象的概念 

1435
01:12:49,487 --> 01:12:52,070
我只是认为那一刻是理所当然的

1436
01:12:52,070 --> 01:12:56,180
一个名为打印正方形的函数 它的高度为3

1437
01:12:56,180 --> 01:12:57,068
也是 

1438
01:12:57,068 --> 01:12:59,360
但总得有人来实施这一点 而目前 

1439
01:12:59,360 --> 01:13:01,580
键盘上只有我一个人 我们继续吧

1440
01:13:01,580 --> 01:13:03,020
并实施那个方块 

1441
01:13:03,020 --> 01:13:05,000
让我们继续定义一个名为

1442
01:13:05,000 --> 01:13:10,250
打印具有特定大小的正方形 包括高度和宽度 

1443
01:13:10,250 --> 01:13:13,310
这是我们有机会使用其中一些循环的地方 

1444
01:13:13,310 --> 01:13:16,250
我们可以以一种我们还没有使用过的方式来使用这些循环 

1445
01:13:16,250 --> 01:13:21,500
如果我想打印出所有这些行 但也要打印出所有这些列 

1446
01:13:21,500 --> 01:13:24,620
我现在要思考的不仅仅是循环所允许的循环 

1447
01:13:24,620 --> 01:13:26,960
但我需要从两个维度来思考 

1448
01:13:26,960 --> 01:13:30,560
如果你熟悉老式打字机甚至打印机

1449
01:13:30,560 --> 01:13:33,570
现在 它通常从上到下打印 

1450
01:13:33,570 --> 01:13:38,550
因此 即使您有多列 您也可以一次打印一行 

1451
01:13:38,550 --> 01:13:41,360
当你在那条线上时 打印机或打字机

1452
01:13:41,360 --> 01:13:42,750
指纹从左到右 

1453
01:13:42,750 --> 01:13:46,550
这就是你的黑白终端窗口应该具备的心理模型 

1454
01:13:46,550 --> 01:13:50,810
到目前为止 每个示例的所有输出都是从顶部开始的

1455
01:13:50,810 --> 01:13:52,340
跌到了谷底 

1456
01:13:52,340 --> 01:13:54,120
从上到下 从左到右 

1457
01:13:54,120 --> 01:13:58,770
所以我们必须以同样的方式产生我们的输出 我们的平方 

1458
01:13:58,770 --> 01:14:01,070
所以让我提议我们这样做 

1459
01:14:01,070 --> 01:14:04,790
让我建议我们知道我们需要迭代多次 3次或更多

1460
01:14:04,790 --> 01:14:05,810
一般大小 

1461
01:14:05,810 --> 01:14:06,560
那就让我来做吧 

1462
01:14:06,560 --> 01:14:12,200
对于尺码范围内的我来说 我需要做三次什么？

1463
01:14:12,200 --> 01:14:14,520
好吧 我想打印出什么？

1464
01:14:14,520 --> 01:14:17,790
1、2、3排砖 

1465
01:14:17,790 --> 01:14:20,850
但在每一行砖块中 我想打印什么？

1466
01:14:20,850 --> 01:14:24,220
具体是1、2、3块砖 

1467
01:14:24,220 --> 01:14:26,790
所以如果我们回到我们这里的图表 我

1468
01:14:26,790 --> 01:14:33,700
规定它确实应该是一个3乘3的正方形 3宽3高 

1469
01:14:33,700 --> 01:14:35,880
要打印第一行 我想做什么？

1470
01:14:35,880 --> 01:14:40,095
我想印砖头 砖头 

1471
01:14:40,095 --> 01:14:42,720
我想在第二行打印什么？砖头 砖头 砖头 

1472
01:14:42,720 --> 01:14:44,580
第三排 砖头 

1473
01:14:44,580 --> 01:14:48,390
所以我做了三件事 三次 

1474
01:14:48,390 --> 01:14:50,650
必须进行大量的打印工作 

1475
01:14:50,650 --> 01:14:53,670
所以让我回到我的代码 现在让我求婚

1476
01:14:53,670 --> 01:14:57,540
我们想到了我刚刚开始的这个外环

1477
01:14:57,540 --> 01:15:00,960
代表我们的每一排 

1478
01:15:00,960 --> 01:15:04,950
因为我在一定的尺寸范围内将确保 无论

1479
01:15:04,950 --> 01:15:10,920
接下来我要做的是 我可以打印出1、2、3行 或者更一般的情况 

1480
01:15:10,920 --> 01:15:15,030
大小 其中大小可以是3 但可以更小或更大 

1481
01:15:15,030 --> 01:15:17,520
我想在每一行上做什么？

1482
01:15:17,520 --> 01:15:21,270
嗯 就像一台老式打字机或打印机 每一排 

1483
01:15:21,270 --> 01:15:24,420
我想打印出砖 砖 砖；砖 

1484
01:15:24,420 --> 01:15:25,470
布里克 

1485
01:15:25,470 --> 01:15:28,260
嗯 听起来像是一个循环 某种循环 

1486
01:15:28,260 --> 01:15:31,740
所以也许我可以在一个循环中有另一个循环 

1487
01:15:31,740 --> 01:15:35,100
我不想再次使用i 因为我不想使用相同的变量

1488
01:15:35,100 --> 01:15:36,450
弄乱了我的计数 

1489
01:15:36,450 --> 01:15:38,860
所以我将按照惯例使用j 

1490
01:15:38,860 --> 01:15:41,460
非常常见的用法是先用i 然后用j--也许用k 

1491
01:15:41,460 --> 01:15:44,800
但在那之后 你们不应该一直在彼此的身体里筑巢 

1492
01:15:44,800 --> 01:15:47,790
让我继续说 对于大小为2的j 

1493
01:15:47,790 --> 01:15:50,940
因为它是一个正方形 然后每一排 

1494
01:15:50,940 --> 01:15:57,660
让我打印出一个散列 但没有新行 但在每行之后 

1495
01:15:57,660 --> 01:16:00,750
让我只打印一行新行 

1496
01:16:00,750 --> 01:16:03,720
所以这里发生了很多事情 特别是如果你从来没有

1497
01:16:03,720 --> 01:16:08,220
触摸到了Python 更不用说循环了 但请注意我在这里也做了什么 

1498
01:16:08,220 --> 01:16:10,800
为了清楚起见 我会补充一些评论 

1499
01:16:10,800 --> 01:16:22,300
对于正方形的每一行 对于每一行的每一块砖 打印砖块 

1500
01:16:22,300 --> 01:16:25,330
这里是评论的地方 更广泛地说 

1501
01:16:25,330 --> 01:16:28,990
伪代码真的可以帮助你向自己和他人解释

1502
01:16:28,990 --> 01:16:30,820
您的代码行在做什么 

1503
01:16:30,820 --> 01:16:35,410
在第8行 我从i等于0开始迭代 直到大小 

1504
01:16:35,410 --> 01:16:37,180
所以0 1 2 

1505
01:16:37,180 --> 01:16:41,560
在第11行 我做了完全相同的事情 但使用了0 1 2中的j 

1506
01:16:41,560 --> 01:16:45,490
但这很好 因为我代表了我的每一行 

1507
01:16:45,490 --> 01:16:49,300
当我在这些行中的每一行 在这个外部循环内时 

1508
01:16:49,300 --> 01:16:53,110
我要做砖 砖 砖；1 2 3；1 2 3；1 2 3 

1509
01:16:53,110 --> 01:16:56,830
但我不希望我的光标一直移动到下一行

1510
01:16:56,830 --> 01:17:01,260
当我在一排的时候 所以我只是在重写那行结尾 

1511
01:17:01,260 --> 01:17:03,010
但让我问你一个关于这个团体的问题

1512
01:17:03,010 --> 01:17:10,160
现在 为什么我在第16行有一个单独的指纹？

1513
01:17:10,160 --> 01:17:13,820
为什么我有一个单独的指纹呢？

1514
01:17:13,820 --> 01:17:19,180
请注意 它位于内部循环的下方 但在内部

1515
01:17:19,180 --> 01:17:22,300
可以说是外环的 

1516
01:17:22,300 --> 01:17:26,650
第16行上的循环最终要做什么？

1517
01:17:26,650 --> 01:17:29,080
观众：你每完成一行 你就会

1518
01:17:29,080 --> 01:17:33,490
我得在它的末尾加一行 

1519
01:17:33,490 --> 01:17:36,905
所以Print 它打印新的一行 

1520
01:17:36,905 --> 01:17:37,780
大卫·马兰：太好了 

1521
01:17:37,780 --> 01:17:40,330
我不想在每一块砖之后都换一条新的线 

1522
01:17:40,330 --> 01:17:42,670
我只想在这一排结束时这样做 

1523
01:17:42,670 --> 01:17:45,460
这就是为什么我现在的评论可能是有启发性的 

1524
01:17:45,460 --> 01:17:51,460
注意 这里的这个循环只是对行中的每一块砖进行迭代 

1525
01:17:51,460 --> 01:17:54,190
可以说 一旦我完成了内部循环 

1526
01:17:54,190 --> 01:17:57,760
一旦我完成了这些突出显示的行 按照伊夫林的观点 

1527
01:17:57,760 --> 01:17:59,927
我需要打印出一个空白的新行 

1528
01:17:59,927 --> 01:18:03,010
我们以前没有这样做过 但是当您不带参数地调用print时 

1529
01:18:03,010 --> 01:18:05,770
你得到的只是自动结束的行号 

1530
01:18:05,770 --> 01:18:09,110
光标移动到下一行的反斜杠n 

1531
01:18:09,110 --> 01:18:13,540
所以如果我现在返回到我的终端窗口并运行mario.py 

1532
01:18:13,540 --> 01:18:16,653
我想我应该买一个3乘3的正方形 

1533
01:18:16,653 --> 01:18:18,820
而且它在我的屏幕上看起来不太像一个正方形

1534
01:18:18,820 --> 01:18:22,300
因为这些散列比它们的宽度稍高一些 但事实上 

1535
01:18:22,300 --> 01:18:23,680
3x3 

1536
01:18:23,680 --> 01:18:26,140
但让我提议 就像我们在这里一贯做的那样 如何

1537
01:18:26,140 --> 01:18:28,030
我们可能会进一步收紧这一代码 

1538
01:18:28,030 --> 01:18:32,050
为了清楚起见 让我暂时抛开我的评论

1539
01:18:32,050 --> 01:18:35,680
这样我们就可以看到我们总共有多少行代码 

1540
01:18:35,680 --> 01:18:39,040
让我提议我们或许可以这样做 

1541
01:18:39,040 --> 01:18:41,737
让我提议 你知道吗 这个内部循环 

1542
01:18:41,737 --> 01:18:43,570
尤其是如果你在包装上有困难的话

1543
01:18:43,570 --> 01:18:46,360
你的思想围绕着另一个循环中的一个循环 

1544
01:18:46,360 --> 01:18:47,710
你并不完全需要它 

1545
01:18:47,710 --> 01:18:49,270
如果我们再来一次这个把戏呢？

1546
01:18:49,270 --> 01:18:54,130
如果我们在外部循环中打印出来 并且只有每个循环

1547
01:18:54,130 --> 01:18:57,910
这些散列的次数是我们想要的次数的倍数吗？

1548
01:18:57,910 --> 01:19:00,400
我们从早期的方法中获得灵感

1549
01:19:00,400 --> 01:19:03,980
现在我们在mario.py上运行Python 同样的结果 

1550
01:19:03,980 --> 01:19:07,480
但现在 Print Square真的很漂亮 很紧凑 

1551
01:19:07,480 --> 01:19:10,810
它有一个显式循环 并且仍在打印输出

1552
01:19:10,810 --> 01:19:15,340
使用字符串乘法一次将该行上的所有散列相乘 

1553
01:19:15,340 --> 01:19:19,600
如果您喜欢抽象 并且您想更多地考虑

1554
01:19:19,600 --> 01:19:21,580
代码是这样做的 好吧 让我们这样做 

1555
01:19:21,580 --> 01:19:23,770
如果你不太清楚发生了什么事 

1556
01:19:23,770 --> 01:19:25,870
让我们建议您实现一个名为

1557
01:19:25,870 --> 01:19:28,150
打印行 传入大小 

1558
01:19:28,150 --> 01:19:33,850
让我建议这个打印行函数 它只接受这个宽度

1559
01:19:33,850 --> 01:19:39,260
并多次打印出单个散列的次数 

1560
01:19:39,260 --> 01:19:43,870
换句话说 这是一个抽象的机会 由此 嗯 什么

1561
01:19:43,870 --> 01:19:45,157
是指打印一行吗？

1562
01:19:45,157 --> 01:19:46,990
嗯 当您实现Print Square时 

1563
01:19:46,990 --> 01:19:49,720
我真的不在乎打印一行意味着什么 

1564
01:19:49,720 --> 01:19:53,440
我只想知道有没有人负责打印这行 

1565
01:19:53,440 --> 01:19:56,740
您完全可以将责任转嫁给另一个函数 

1566
01:19:56,740 --> 01:19:58,360
打印行是如何工作的？

1567
01:19:58,360 --> 01:20:02,500
它可以使用for循环 它可以使用这个字符串乘法技巧 

1568
01:20:02,500 --> 01:20:05,980
这是一种采用更大程序的方法--这可能是

1569
01:20:05,980 --> 01:20:08,120
到目前为止我们已经看到了一个复杂的问题--

1570
01:20:08,120 --> 01:20:13,600
然后把它分解成这些更小的组件 一旦组装好 

1571
01:20:13,600 --> 01:20:16,390
实现你的最终想法 

1572
01:20:16,390 --> 01:20:19,780
看不到任何问题 我们对循环的了解就到此结束

1573
01:20:19,780 --> 01:20:22,900
在Python中 这种一次又一次循环地做事情的能力 

1574
01:20:22,900 --> 01:20:25,480
当我们把它们和条件句结合起来时 这种能力

1575
01:20:25,480 --> 01:20:28,870
提问和回答问题 并将它们与我们的函数和变量相结合 

1576
01:20:28,870 --> 01:20:31,450
我们现在真的拥有了大部分的构建块

1577
01:20:31,450 --> 01:20:34,060
我们需要解决更大、更有趣、更多

1578
01:20:34,060 --> 01:20:35,260
更多的私人问题 

1579
01:20:35,260 --> 01:20:39,100
因此 在接下来的几周里 我们将开始确切地看到可能会出现什么问题 

1580
01:20:39,100 --> 01:20:41,080
虽然 当我们这样做的时候 但我们会为你介绍

1581
01:20:41,080 --> 01:20:45,600
到所有更多的工具 您可以通过这些工具来解决这些相同的问题 

