
1
00:00:00,000 --> 00:00:03,451
[音乐播放]
[MUSIC PLAYING]

2
00:00:24,160 --> 00:00:25,180
大卫·马兰：好的 
DAVID MALAN: All right.

3
00:00:25,180 --> 00:00:28,540
这是CS50的S介绍用PYTHON编程 
This is CS50's Introduction to Programming with Python.

4
00:00:28,540 --> 00:00:33,010
我的名字是David Malan 这周我们主要关注循环 这是Python中的这一功能
My name is David Malan, and this week we focus on loops, this ability in Python

5
00:00:33,010 --> 00:00:37,000
以及许多其他编程语言来一次又一次地做一些事情 
and a lot of other programming languages to do something again and again,

6
00:00:37,000 --> 00:00:38,500
这是一种循环 
a cycle of sorts.

7
00:00:38,500 --> 00:00:40,420
让我们看看我们能不能从激励
And let's see if we can't begin by motivating

8
00:00:40,420 --> 00:00:45,310
这就是为什么我们有这种能力 使用这些循环循环地做事情 
exactly why we have this ability to do things cyclically using these loops.

9
00:00:45,310 --> 00:00:48,130
我将在这里继续 打开VS代码 
I'm going to go ahead here and open up VS Code.

10
00:00:48,130 --> 00:00:50,260
在我的终端窗口中 让我们继续
And in my terminal window, let's go ahead

11
00:00:50,260 --> 00:00:57,100
并通过代码cat.py进行创建 这是一个像猫一样发出猫叫声的Python程序 
and create via code cat.py, a Python program that meows like a cat.

12
00:00:57,100 --> 00:01:00,910
我将在这个代码选项卡中继续 可能非常简单 
And I'm going to go ahead here in this Code tab, and very simply, perhaps,

13
00:01:00,910 --> 00:01:03,760
我将从使用打印来实现这个CAT开始 
I'm going to start by implementing this cat just by using print.

14
00:01:03,760 --> 00:01:06,010
我们要让这只猫不发出声音 
We're going to have this cat not make audible sounds,

15
00:01:06,010 --> 00:01:08,860
但只要在屏幕上打印三次猫咪、猫咪、猫咪就可以了 
but just print meow, meow, meow on the screen three times.

16
00:01:08,860 --> 00:01:12,640
我想我能做到的最简单的方法就是打印猫咪一次 
Well, I think the simplest way I can do this is just to print meow once,

17
00:01:12,640 --> 00:01:18,590
并再次打印猫咪 并在屏幕上打印最后一次猫咪 
and to print meow again, and to print meow one last time on the screen.

18
00:01:18,590 --> 00:01:23,320
现在让我转到我的终端窗口 让我运行cat.py的Python 
And now let me go down to my terminal window, let me run Python of cat.py,

19
00:01:23,320 --> 00:01:25,480
进来 然后叫 叫 叫 
Enter, and meow, meow, meow.

20
00:01:25,480 --> 00:01:27,670
好了 这个程序起作用了 
All right, so this program works.

21
00:01:27,670 --> 00:01:31,120
如果我的目标是让猫叫三次 这个程序确实有效 
This program indeed works if my goal is to get the cat to meow three times.

22
00:01:31,120 --> 00:01:34,280
让我向你求婚 只是为了帮助我们
And let me propose, just to help us wrap our minds around

23
00:01:34,280 --> 00:01:36,430
计算机内部发生了什么 让我们
what's going on inside of the computer, let

24
00:01:36,430 --> 00:01:38,810
我建议我们考虑这个流程图 
me propose that we consider this flowchart.

25
00:01:38,810 --> 00:01:40,810
所以像以前一样 我们有这个流程图 
So as before, we have this flowchart that

26
00:01:40,810 --> 00:01:44,140
从这个椭圆形开始 意思就是从这里开始阅读 
starts with this oval, which just means start reading here.

27
00:01:44,140 --> 00:01:50,050
然后注意 它通过箭头发出猫叫声 然后停止 
And then notice, it goes via arrows to a meow, meow, meow, and then it stops.

28
00:01:50,050 --> 00:01:53,890
这是完全正确的 老实说 它非常简单 
It's perfectly correct, and honestly, it's wonderfully simple,

29
00:01:53,890 --> 00:01:58,090
但我敢说 不管怎样 我们还是可以找出我的代码的错误 
but I daresay we can find fault with my code nonetheless.

30
00:01:58,090 --> 00:02:03,550
为什么我的代码可以说是设计得很差？
Why is my code arguably poorly designed?

31
00:02:03,550 --> 00:02:05,680
现在 答案将是某种程度上的循环 
Now the answer is going to be loops in some way,

32
00:02:05,680 --> 00:02:08,169
但让我们看看我们能不能用什么方式
but let's see if we can identify in what way

33
00:02:08,169 --> 00:02:12,950
在某种意义上 代码实际上设计得很差 
the code is actually poorly designed in some sense.

34
00:02:12,950 --> 00:02:13,660
让我们看看 
Let's see.

35
00:02:13,660 --> 00:02:14,260
任何想法 
Any thoughts.

36
00:02:14,260 --> 00:02:15,608
亚历克斯？
Alex?

37
00:02:15,608 --> 00:02:16,150
观众：好的 
AUDIENCE: OK.

38
00:02:16,150 --> 00:02:21,580
所以 我的意思是 重复同样的动作三次甚至更多
So, I mean, repeating the same action like three times or even more

39
00:02:21,580 --> 00:02:23,095
不是一个好习惯 
is not a good habit.

40
00:02:23,095 --> 00:02:24,970
大卫·马兰：是的 我只是在重复我自己 
DAVID MALAN: Yeah, I'm just repeating myself.

41
00:02:24,970 --> 00:02:27,340
老实说 这没什么大不了的 
And honestly, it's not that big a deal.

42
00:02:27,340 --> 00:02:31,780
如果我们在这里回到我的代码 我真的做了一件坏事吗
If we go back to my code here, am I really doing such a bad thing

43
00:02:31,780 --> 00:02:34,180
只要打印三次猫叫 猫叫 猫叫就可以了？
by just printing meow, meow, meow three times?

44
00:02:34,180 --> 00:02:37,250
不完全是 但让我们考虑一下这一点的逻辑扩展 
Not really, but let's consider the logical extension of this.

45
00:02:37,250 --> 00:02:43,510
假设我想叫四次、五次、50次或500次 
Suppose I wanted to meow four times or five times or 50 times or 500 times.

46
00:02:43,510 --> 00:02:46,150
你真的认为 即使你以前从来没有编程过 
Do you really think, even if you've never programmed before,

47
00:02:46,150 --> 00:02:50,350
这个问题的解决方案真的是点击复制粘贴50次吗？
is the solution to this problem really going to be to hit copy-paste 50 times?

48
00:02:50,350 --> 00:02:51,310
大概不会吧 
Like probably not.

49
00:02:51,310 --> 00:02:52,840
我们或许可以做得更好 
We can probably do better than that.

50
00:02:52,840 --> 00:02:54,850
在这一点上 除了丑陋之外 
And beyond it just being ugly at that point,

51
00:02:54,850 --> 00:02:57,732
有这么多行相同的代码 只是
having so many lines of identical code, just

52
00:02:57,732 --> 00:02:59,440
想象一下 如果您想要更改代码 
imagine if you wanted to change the code.

53
00:02:59,440 --> 00:03:02,607
也许我改变主意了 我不想养猫 我想养狗 
Maybe I change my mind and I don't want to make a cat, I want to make a dog.

54
00:03:02,607 --> 00:03:04,930
所以现在它不得不多次说汪汪 汪汪 汪汪 
So now it has to say woof, woof, woof multiple times.

55
00:03:04,930 --> 00:03:07,780
现在我必须在50个不同的地方改变这一点 
Now I have to change that in 50 different places.

56
00:03:07,780 --> 00:03:10,030
是的 当然 我可以找到并替换 
And yeah, sure, I could do find and replace,

57
00:03:10,030 --> 00:03:12,070
但得了吧 就像我们现在是程序员一样 
but come on, like we're programmers now, there's

58
00:03:12,070 --> 00:03:15,080
一定有更好的方法而不是重复我们自己 
got to be a better way than just repeating ourselves.

59
00:03:15,080 --> 00:03:18,400
所以我敢打赌 如果我们稍微考虑一下 我们可以做得更好
So I bet we can do better than that if we think about a little

60
00:03:18,400 --> 00:03:22,960
我们如何构建这个项目就更加困难了 
harder how we go about structuring this program.

61
00:03:22,960 --> 00:03:26,750
只要我们稍微增加一点词汇量 我们就能做到这一点 
And we can do that if we augment our vocabulary just a little bit.

62
00:03:26,750 --> 00:03:28,870
事实证明 在Python和其他语言中 
It turns out in Python, and in other languages,

63
00:03:28,870 --> 00:03:31,270
还有一个关键字叫做While 
too, there's a keyword called while.

64
00:03:31,270 --> 00:03:34,960
虽然这是我们可以表达所谓的循环的一种方式 
And while is one way that we can express what's called a loop,

65
00:03:34,960 --> 00:03:38,530
一段代码 它将一次又一次地做一些事情--
a block of code that's going to do something again and again and again--

66
00:03:38,530 --> 00:03:43,480
0倍 1倍 2倍 50倍 想要多少倍就多少倍 
0 times, 1 time, 2 times, 50 times, as many times as we want.

67
00:03:43,480 --> 00:03:48,520
而是把细节留给我们
But while rather leaves to us the particulars

68
00:03:48,520 --> 00:03:52,010
关于我们如何一次又一次地表达自己去做某事 
of how we express ourselves to do something again and again.

69
00:03:52,010 --> 00:03:56,260
所以让我回到VS代码 让我提议我这样做 
So let me go back over to VS Code here and let me propose that I do this.

70
00:03:56,260 --> 00:04:01,765
While是一个允许我一遍又一遍地问问题的结构 
While is a construct that allows me to ask a question again and again.

71
00:04:01,765 --> 00:04:03,640
任何时候我们看到一个问题 它都是
And any time we've seen a question, it's been

72
00:04:03,640 --> 00:04:07,180
以布尔表达式的形式 问题的答案是
in the form of a Boolean expression, a question to which the answer is

73
00:04:07,180 --> 00:04:08,900
对或错 
true or false.

74
00:04:08,900 --> 00:04:10,250
我怎么能这么做呢？
Well, how could I do this?

75
00:04:10,250 --> 00:04:15,340
我怎么能打印三次猫咪 问三次问题呢？
How could I print out meow three times and ask three times a question

76
00:04:15,340 --> 00:04:18,079
答案是真的还是假的？
to which the answer is true or false?

77
00:04:18,079 --> 00:04:20,110
好吧 如果我数一数呢？
Well, what if I did some counting?

78
00:04:20,110 --> 00:04:21,560
就像真的在我手指上一样 
Like literally on my fingers.

79
00:04:21,560 --> 00:04:25,360
如果我试着从三个倒数 我想猫叫三次 
And if I'm trying to count maybe down from three, I want to meow three times,

80
00:04:25,360 --> 00:04:28,060
我可以竖起三根手指 然后我就会叫了 
I can put three fingers up and I can meow.

81
00:04:28,060 --> 00:04:31,342
然后我可以把其中一根手指放下来 然后猫叫 
And then I can put like one of the fingers down and then meow.

82
00:04:31,342 --> 00:04:33,550
我可以把其中一根手指放下来 然后我就能猫叫了 
And I can put one of the fingers down and I can meow.

83
00:04:33,550 --> 00:04:34,870
把其中一根手指放下 
Put one of the fingers down.

84
00:04:34,870 --> 00:04:38,200
也许我每次猫叫的时候都会问这个问题
And maybe the question I can ask every time I meow

85
00:04:38,200 --> 00:04:40,840
是 我还能竖起手指吗？
is, do I have any fingers up still?

86
00:04:40,840 --> 00:04:42,370
我还能竖起手指吗？
Do I have any fingers up still?

87
00:04:42,370 --> 00:04:43,662
我还能竖起手指吗？
Do I have any fingers up still?

88
00:04:43,662 --> 00:04:45,490
如果答案是真的 那就继续前进 
And if the answer is true, keep going.

89
00:04:45,490 --> 00:04:48,040
如果答案是假的 请停止 
If the answer is false, stop.

90
00:04:48,040 --> 00:04:50,710
那么 我如何将其转换为代码呢？
So how can I translate that to code?

91
00:04:50,710 --> 00:04:53,020
好的 一旦我们添加了这个While关键字--
Well, once we've added this while keyword--

92
00:04:53,020 --> 00:04:57,590
我认为我们已经拥有了所有的构建块 让我提议我这样做 
I think we have all the building blocks already, let me propose that I do this.

93
00:04:57,590 --> 00:04:59,860
让我提议我给自己一个变量 
Let me propose that I give myself a variable.

94
00:04:59,860 --> 00:05:02,740
我会把它叫做i代表整数 但我想怎么叫都行 
And I'll call it i for integer, but I could call it anything I want,

95
00:05:02,740 --> 00:05:04,780
我要把它初始化为3 
and I'm going to initialize it to 3.

96
00:05:04,780 --> 00:05:07,780
然后我将使用Python的这个新功能 同时 
Then I'm going to use this new feature of Python, while,

97
00:05:07,780 --> 00:05:12,380
我要问一个问题 答案必须是真的或假的 
and I'm going to ask a question, the answer to which must be true or false.

98
00:05:12,380 --> 00:05:17,470
我要说 虽然我不等于0 
And I'm going to say, while i does not equal 0.

99
00:05:17,470 --> 00:05:22,630
所以我要问这个问题 虽然我不等于0 但请做以下操作 
So I'm going to ask the question, while i does not equal 0, do the following.

100
00:05:22,630 --> 00:05:24,760
请注意该行末尾的冒号 
Notice the colon at the end of the line.

101
00:05:24,760 --> 00:05:25,890
注意我的凹痕 
Notice my indentation.

102
00:05:25,890 --> 00:05:28,470
就像函数一样 就像条件句一样 
And just like with functions, just like with conditionals,

103
00:05:28,470 --> 00:05:34,440
缩进您只想作为另一件事的一部分执行的行 
you indent the lines that you only want to execute as part of this other thing.

104
00:05:34,440 --> 00:05:37,920
当我不等于0的时候 我想做什么？
What do I want to do while i does not equal 0?

105
00:05:37,920 --> 00:05:41,130
好吧 我想我只想猫叫一声 
Well, I think I just want to meow.

106
00:05:41,130 --> 00:05:44,820
但仅仅编写这段代码是不够的 
But it's not enough just to write this code.

107
00:05:44,820 --> 00:05:52,380
如果我现在非常危险地运行cat.py的Python并按Enter键 
If I were to very dangerously run Python of cat.py and hit Enter right now,

108
00:05:52,380 --> 00:05:55,560
银幕上可能会发生什么？
what might happen on the screen?

109
00:05:55,560 --> 00:05:58,320
不管你以前是否编程过 
Whether you've programmed before or not.

110
00:05:58,320 --> 00:06:01,200
为什么这是一件潜在的非常糟糕的事情？
Why is this a very bad thing potentially?

111
00:06:01,200 --> 00:06:05,700
它不会弄坏东西 但它可能会失去对我电脑的控制
It's not going to break things, but it might lose control of my computer

112
00:06:05,700 --> 00:06:07,270
不知怎么的
somehow.

113
00:06:07,270 --> 00:06:08,620
有什么想法吗？
Any thoughts?

114
00:06:08,620 --> 00:06:10,120
喂 提莫？
Yeah, Timo?

115
00:06:10,120 --> 00:06:11,020
观众：嗨 
AUDIENCE: Hi.

116
00:06:11,020 --> 00:06:18,790
我想它会继续输出meow 因为i总是等于3
I think it's going to continue to print out meow since i is always equal to 3

117
00:06:18,790 --> 00:06:20,995
而while永远是真的
and the while is always true.

118
00:06:20,995 --> 00:06:22,120
大卫·马兰：是的 没错 
DAVID MALAN: Yeah, exactly.

119
00:06:22,120 --> 00:06:26,320
如果我把i初始化为3--也就是说 在第1行设置它等于3 
If I'm initializing i to 3-- that is, setting it equal to 3 on line 1,

120
00:06:26,320 --> 00:06:29,440
那么我会问 虽然i不等于0 
then I'm asking the question, while i does not equal 0,

121
00:06:29,440 --> 00:06:31,810
这是真的 它不等于0
and that's going to be true, it does not equal 0,

122
00:06:31,810 --> 00:06:34,240
它显然等于3 打印meow 
it obviously equals 3, print meow.

123
00:06:34,240 --> 00:06:38,950
while循环的工作方式是Python解释器
And the way a while loop works is that the Python interpreter just

124
00:06:38,950 --> 00:06:40,480
不停地来回移动
keeps going back and forth.

125
00:06:40,480 --> 00:06:45,310
它从第一行到第二行 然后到第三行 
It goes from line 1 to line 2, then to line 3,

126
00:06:45,310 --> 00:06:48,490
然后它回到第二行再次提问 
and then it goes back to line 2 to ask the question again.

127
00:06:48,490 --> 00:06:50,950
如果答案仍然为真 则转到第3行 
If the answer is still true, it goes to line 3.

128
00:06:50,950 --> 00:06:52,420
然后它回到第2行 
It then goes back to line 2.

129
00:06:52,420 --> 00:06:55,090
如果答案仍然为真 则返回到第3行 
If the answer is still true, it goes back to line 3.

130
00:06:55,090 --> 00:07:00,100
根据Timo的观点 如果你永远不改变i的值 
And to Timo's point, if you're never actually changing the value of i,

131
00:07:00,100 --> 00:07:04,450
它总是3 你会一直循环下去 
it's always 3, you're just going to be looping literally forever,

132
00:07:04,450 --> 00:07:07,028
这是一个偶然的无限循环
and this is an accidental infinite loop.

133
00:07:07,028 --> 00:07:08,570
所以我们得聪明点 
So we've got to be smarter than that.

134
00:07:08,570 --> 00:07:09,820
我不会按回车键因为我不想
And I'm not going to hit Enter because I don't

135
00:07:09,820 --> 00:07:12,195
我想失去对我的电脑的控制 这样它就
want to lose control over my computer here such that it's

136
00:07:12,195 --> 00:07:14,080
永远打印出喵
printing out meow forever.

137
00:07:14,080 --> 00:07:16,960
幸运的是 如果你真的这么做了
Fortunately, if you ever do do that and you find yourself

138
00:07:16,960 --> 00:07:21,940
在意外无限循环中 Control-C表示取消或中断
in an accidental infinite loop, Control-C for cancel or interrupt

139
00:07:21,940 --> 00:07:23,110
会成为你的朋友
is going to be your friend.

140
00:07:23,110 --> 00:07:26,110
如果你似乎失去了控制 你不需要重新启动
If you ever seem to lose control, you don't need to reboot

141
00:07:26,110 --> 00:07:27,520
或者关掉电脑
or turn off the computer.

142
00:07:27,520 --> 00:07:30,430
您可以在终端窗口中按Control-C
You can just hit Control-C in your terminal window

143
00:07:30,430 --> 00:07:32,560
这可能会解决问题
and that will likely fix it.

144
00:07:32,560 --> 00:07:35,920
好吧 那我每次喵喵叫完之后 要做什么呢？
All right, well what do I want to do, then, after meowing each time?

145
00:07:35,920 --> 00:07:39,820
我想我在这里想做的是这样的 
I think what I'd like to do here is maybe something like this.

146
00:07:39,820 --> 00:07:46,750
让我把i更新为等于当前值减1
Let me update i to equal whatever the current value is minus 1 here--

147
00:07:46,750 --> 00:07:47,530
哎呀 对不起 
whoops, sorry.

148
00:07:47,530 --> 00:07:48,820
减去1 
Minus 1.

149
00:07:48,820 --> 00:07:51,310
所以如果每次迭代时i--
So if i on each iteration--

150
00:07:51,310 --> 00:07:55,090
我在更新我 让我少一个 
I'm updating i to be one less, one less, one less,

151
00:07:55,090 --> 00:08:00,610
它最终应该会达到0 在这一点上 9.2%的S问题的答案
it should eventually hit 0, at which point the answer to 9.2's question

152
00:08:00,610 --> 00:08:02,540
现在将是假的 
will now be false.

153
00:08:02,540 --> 00:08:03,770
因此 让我们看看这是否奏效 
So let's see if this works.

154
00:08:03,770 --> 00:08:06,790
我将转到我的终端窗口 运行cat.py的Python 
I'm going to go down to my terminal window and run Python of cat.py,

155
00:08:06,790 --> 00:08:09,700
我真的收到了三声猫叫 
and I indeed get three meows.

156
00:08:09,700 --> 00:08:10,360
为什么？
Why?

157
00:08:10,360 --> 00:08:14,230
因为如果你愿意的话 我已经把它像一台软件里的机器一样连起来了 
Because I've wired this up like a machine in software, if you will.

158
00:08:14,230 --> 00:08:17,360
我设定i等于3 然后我继续问这个问题 
I've set i equal to 3, then I keep asking this question.

159
00:08:17,360 --> 00:08:21,940
但是我一直在转动齿轮 我一直在改变变量的值
But I keep turning the gears, I keep changing the value of the variable

160
00:08:21,940 --> 00:08:25,180
以确保最终它实际上是
to make sure that ultimately it is actually

161
00:08:25,180 --> 00:08:30,468
被递减--也就是说 递减1 直到我们最终达到0 
being decremented-- that is, decreased by 1 until we eventually hit 0.

162
00:08:30,468 --> 00:08:33,010
现在对于那些认为我更生动一些的人来说 
Now for those of you who think I'm a little more graphically,

163
00:08:33,010 --> 00:08:35,110
让我调出一个我们通常使用的流程图 
let me pull up one of our usual flow charts.

164
00:08:35,110 --> 00:08:38,610
这只是完全相同的事情的图形表示 
This is just a representation graphically of the exact same thing.

165
00:08:38,610 --> 00:08:39,610
注意正在发生的事情 
Notice what's happening.

166
00:08:39,610 --> 00:08:44,020
我首先启动程序 然后将i初始化为3 
I first start the program, and then I initialize i to 3,

167
00:08:44,020 --> 00:08:46,300
然后我问我的第一个问题 
and then I ask the first of my questions.

168
00:08:46,300 --> 00:08:48,577
再说一次 钻石总是代表着问题 
Again, the diamonds always represent questions.

169
00:08:48,577 --> 00:08:50,410
答案将是真的或假的 
And the answer is going to be true or false.

170
00:08:50,410 --> 00:08:52,690
我不等于0吗？
Does i not equal 0?

171
00:08:52,690 --> 00:08:54,190
嗯 它不是 它等于3 
Well, it doesn't, it equals 3.

172
00:08:54,190 --> 00:08:56,710
所以 如果我遵循真实的路线 我就会猫叫 
So if I follow the true line, I meow.

173
00:08:56,710 --> 00:09:01,690
然后我沿着这个箭头 我把i更新为等于i减1 
And then I follow this arrow, and I update i to equal i minus 1.

174
00:09:01,690 --> 00:09:05,200
在故事的这一点上 我大概在数学上等于2 
At this point in the story, i presumably equals 2 mathematically.

175
00:09:05,200 --> 00:09:06,400
我跟着箭头走 
I follow the arrow.

176
00:09:06,400 --> 00:09:07,483
这就是循环 
And there's the loop.

177
00:09:07,483 --> 00:09:09,400
这就是为什么能以图形方式看到这一点是很好的 
This is why it's nice to see this graphically,

178
00:09:09,400 --> 00:09:12,770
也许是因为你可以从字面上看到循环来回 
perhaps because you can literally see the loop back and forth.

179
00:09:12,770 --> 00:09:14,240
现在我再问一遍这个问题 
Now I ask the question again.

180
00:09:14,240 --> 00:09:16,270
2不等于0吗？
Does 2 not equal 0?

181
00:09:16,270 --> 00:09:20,060
嗯 它不等于0 它是2 所以我们再叫一次 
Well, it does not equal 0, it's 2, so we meow again.

182
00:09:20,060 --> 00:09:21,940
我们把i从2改为1 
We change i from 2 to 1.

183
00:09:21,940 --> 00:09:23,770
那么 1不等于0吗？
Well, does 1 not equal 0?

184
00:09:23,770 --> 00:09:27,490
显然1不是0 所以我们再猫咪一次 
Well obviously 1 is not 0, so we meow again.

185
00:09:27,490 --> 00:09:30,580
我们又一次减少了I 我现在是0 
We decrement i again. i is now 0.

186
00:09:30,580 --> 00:09:33,070
0不等于0吗？
Does 0 not equal 0?

187
00:09:33,070 --> 00:09:37,930
不 它等于0 所以答案是假的 我们停止 
No, it equals 0, so the answer is false and we stop.

188
00:09:37,930 --> 00:09:41,260
所以在那里 也许比我们以前的任何流程图都更有说服力 
So there, perhaps more so than any of our flowcharts before,

189
00:09:41,260 --> 00:09:45,295
你真的看到项目内部发生的事情的结构了吗？
do you really see the structure of what's happening inside of the program?

190
00:09:45,295 --> 00:09:47,920
你不必养成制作这些图表的习惯
And you don't have to get into the habit of making these charts

191
00:09:47,920 --> 00:09:50,830
或创建这些图表 但只是作为第一次通过
or creating these charts, but just as a first pass at what's

192
00:09:50,830 --> 00:09:55,010
进入计算机内部 这确实是一种将其可视化的方法 
going on inside of the computer, that's indeed one way to visualize it instead.

193
00:09:55,010 --> 00:09:57,760
好吧 让我提议 像往常一样 有很多不同的方式
Well let me propose that, like always, there's many different ways

194
00:09:57,760 --> 00:09:58,690
来解决这个问题 
to solve this problem.

195
00:09:58,690 --> 00:10:01,023
假设你只是喜欢有一点不同的想法 
And suppose you just like to think a little differently.

196
00:10:01,023 --> 00:10:04,700
也许你不喜欢从3开始 然后倒数到0 
Maybe you don't like starting at 3 and then counting down to 0.

197
00:10:04,700 --> 00:10:05,200
为什么？
Why?

198
00:10:05,200 --> 00:10:07,075
也许你只是大脑不是这样工作的
Maybe you're just brain doesn't work that way

199
00:10:07,075 --> 00:10:09,100
而且你更喜欢倒数 而不是倒数 
and you prefer to count up instead of down.

200
00:10:09,100 --> 00:10:10,400
完全没问题 
Totally fine.

201
00:10:10,400 --> 00:10:15,700
让我继续更改我的代码 将i设置为等于1 而不是3 
Let me go ahead and change my code here to set i equal to 1 instead of 3.

202
00:10:15,700 --> 00:10:18,040
在这里 让我改变一下我的逻辑 
And here, let me just change my logic.

203
00:10:18,040 --> 00:10:20,500
而不是检查是否不等于0 比如
Rather than checking for not equal to 0, like maybe

204
00:10:20,500 --> 00:10:23,500
你不喜欢这样想 不是因为这有点令人困惑 
you don't like thinking in terms of not because it's a little confusing,

205
00:10:23,500 --> 00:10:28,720
也可能是 让我们检查一下 i是否小于或等于3 
and it might be, let's just check that i is less than or equal to 3.

206
00:10:28,720 --> 00:10:30,310
所以我们会说得更清楚一些 
So we'll be a little more explicit.

207
00:10:30,310 --> 00:10:34,690
我们会从1数到3 每次打印猫咪 
We'll count from 1 up through 3, each time printing meow,

208
00:10:34,690 --> 00:10:36,970
但我需要在这里更改这条线 
but I'm going to need to change this line here.

209
00:10:36,970 --> 00:10:40,240
让我看看能不能叫人帮我换一下线路 
Let me see if we can't call on someone to change line for me.

210
00:10:40,240 --> 00:10:47,560
如何将第4行更改为与从1开始向上计数一致
How do I want to change line 4 to be consistent with counting from 1 up

211
00:10:47,560 --> 00:10:52,080
从3点到3点？
to and through 3?

212
00:10:52,080 --> 00:10:57,465
观众：每次你猫咪叫 我都会加1 
AUDIENCE: I would be plus 1 every time you meow.

213
00:10:57,465 --> 00:10:58,590
大卫·马兰：是的 确实如此 
DAVID MALAN: Yeah, exactly.

214
00:10:58,590 --> 00:11:01,800
在本例中 我们想要加1而不是减1 
In this case, we want to add one not subtract 1.

215
00:11:01,800 --> 00:11:05,460
事实上 如果你仔细想想 这两部电影的结局可能会非常糟糕 
And in fact, if you think about this, this 2 could end very poorly.

216
00:11:05,460 --> 00:11:09,630
如果你从1开始数 然后一直减1 减1 
If you start counting at 1 and you keep subtracting 1, subtracting 1,

217
00:11:09,630 --> 00:11:11,850
减去1 我想我们会发现我们自己
subtracting 1, I think we're going to find ourselves

218
00:11:11,850 --> 00:11:15,780
有同样的问题 那就是我们永远不会停止 因为我们
with the same problem, which is that we're never going to stop because we're

219
00:11:15,780 --> 00:11:19,140
会变得越来越消极 而不是站起来
going to keep getting more and more negative as opposed to ever getting up

220
00:11:19,140 --> 00:11:20,160
到数字3 
to the number 3.

221
00:11:20,160 --> 00:11:24,660
所以我认为你是对的 我需要把这个改成i等于i加1 
So I think you're right, I need to change this to be i equals i plus 1.

222
00:11:24,660 --> 00:11:27,840
现在 为了清楚起见 请注意等号
And now notice just for clarity, too, the equal sign

223
00:11:27,840 --> 00:11:30,810
也是我们从右到左的赋值运算符 
is, again, our assignment operator from right to left.

224
00:11:30,810 --> 00:11:33,150
从逻辑上讲 这可能会让你感到奇怪 
Logically, this might otherwise strike you as strange.

225
00:11:33,150 --> 00:11:35,880
比如我怎么能等于自己加1呢？
Like how can i equal itself plus 1?

226
00:11:35,880 --> 00:11:39,720
除非你从右向左执行这段代码 
Well, it doesn't until you execute this code from right to left.

227
00:11:39,720 --> 00:11:44,550
你给i加1或者i减1 然后更新i的值
You add 1 to i or you subtract 1 from i, and then you update the value of i

228
00:11:44,550 --> 00:11:45,240
左边即
on the left.

229
00:11:45,240 --> 00:11:48,400
赋值将值从右向左复制 
The assignment copies the value from the right to the left.

230
00:11:48,400 --> 00:11:49,780
我还能怎么做
Well, how else might I do this?

231
00:11:49,780 --> 00:11:55,110
好吧 我会说大多数程序员 更普遍的计算机科学家 
Well, I will say that most programmers, computer scientists more generally,

232
00:11:55,110 --> 00:11:57,180
往往从0开始计数 
tend to start counting from 0.

233
00:11:57,180 --> 00:11:59,640
这是一个惯例 它实际上有好处 
It's a convention and it actually has upsides even

234
00:11:59,640 --> 00:12:02,440
在Python和其他语言中 一般来说 
in Python and other languages where generally speaking,

235
00:12:02,440 --> 00:12:04,600
从0开始计数是件好事
it's a good thing to start counting from 0

236
00:12:04,600 --> 00:12:07,620
而不是像我们在现实世界中那样从1开始计数 
instead of counting like we might in the real world from 1.

237
00:12:07,620 --> 00:12:10,170
让我们现在就通过这项公约 
Let's go ahead and adopt that convention now.

238
00:12:10,170 --> 00:12:14,400
让我把i设为0 现在我需要做一个改变 
Let me set i equal to 0, and I need to make a change now.

239
00:12:14,400 --> 00:12:19,560
注意 如果我不改变我的逻辑 这个程序就会有bug 
Notice, if I don't change my logic, this program just became buggy.

240
00:12:19,560 --> 00:12:20,730
这只猫有一只虫子 
The cat has a bug.

241
00:12:20,730 --> 00:12:23,940
如果我照现在的样子跑 它会叫四次 
It's now meowing four times if I run it as is.

242
00:12:23,940 --> 00:12:27,660
但最简单的解决办法是改变我的不等式
But the easiest fix here would be to change my inequality

243
00:12:27,660 --> 00:12:31,810
是这个 小于而不是小于或等于 
to be this, less than instead of less than or equal to.

244
00:12:31,810 --> 00:12:36,480
现在我从0开始 但我会一直到3 
Now I'm starting at 0, but I'm going up to but not through 3.

245
00:12:36,480 --> 00:12:40,020
即使这可能 在我们目前看到的所有事情中 
And even though this might, of all the things we've seen thus far,

246
00:12:40,020 --> 00:12:44,400
似乎是最不熟悉的 我们大多数人可能从1开始 2 然后3 
seem maybe the least familiar, most of us might start at 1, 2, then 3,

247
00:12:44,400 --> 00:12:47,220
这是一个好习惯 从0开始 
it's a good habit to get into now, start at 0,

248
00:12:47,220 --> 00:12:52,110
最终达到但不是通过你所关心的价值 
and go up to but not through the value that you care about ultimately,

249
00:12:52,110 --> 00:12:53,510
3在这种情况下
3 in this case here.

250
00:12:53,510 --> 00:12:55,260
好吧 让我把这里的东西弄紧一点 
Well, let me tighten things up a bit here.

251
00:12:55,260 --> 00:12:57,630
这不仅能解决我的数数问题 
Not only will this now fix my counting problem,

252
00:12:57,630 --> 00:13:00,330
它现在的叫声是预期的3倍 
it now meows 3 times as expected, there's

253
00:13:00,330 --> 00:13:03,240
一种更简洁的方式来表示i等于i
a more succinct way to express i equals i

254
00:13:03,240 --> 00:13:06,690
加1 这是因为这是一个很流行的代码 
plus 1, and this, is because it's such a popular thing to do in code.

255
00:13:06,690 --> 00:13:11,830
你可以说i+等于1 就是这样 
You can instead just say i plus equals 1, and that's it.

256
00:13:11,830 --> 00:13:14,250
你不需要把所有东西都放在右边 
You don't need to put everything on the right-hand side.

257
00:13:14,250 --> 00:13:19,320
这是一个特殊的语法 它说的是完全相同的事情 递增i 
This is a special syntax that says the exact same thing, increment i,

258
00:13:19,320 --> 00:13:21,742
但它用的时间更少 
but it does it with a few fewer keystrokes.

259
00:13:21,742 --> 00:13:24,700
只是打字更方便 阅读速度更快 
It's just a little more pleasant to type, it's a little faster to read,

260
00:13:24,700 --> 00:13:25,830
这只是个会议而已 
it's just a convention.

261
00:13:25,830 --> 00:13:29,745
你们当中那些用C C++ Python编程的人--
Those of you who have programmed in C, C++, Python--

262
00:13:29,745 --> 00:13:30,660
不 不是巨蟒 
no, not Python.

263
00:13:30,660 --> 00:13:36,990
C、C++、Java、JavaScript可能在前面看到了加号或减号 
C, C++, Java, JavaScript might have seen plus-plus before or minus-minus.

264
00:13:36,990 --> 00:13:40,080
对不起 Python没有它 所以您不能使用它 
Sorry, Python doesn't have it, so you cannot use that.

265
00:13:40,080 --> 00:13:44,040
这是您的代码行可能获得的最简洁的代码 
This is as succinct as your line of code might get.

266
00:13:44,040 --> 00:13:44,870
好的 
All right.

267
00:13:44,870 --> 00:13:46,620
让我在这里停下来看看 如果有
Let me pause here to see, then, if there's

268
00:13:46,620 --> 00:13:53,400
关于While循环的这些实现的任何问题 
any questions about these implementations of while loops.

269
00:13:53,400 --> 00:13:55,620
观众：我们可以使用像for循环这样的东西吗
AUDIENCE: Can we use stuff like for loops

270
00:13:55,620 --> 00:14:02,760
在开始时将某个i值初始化为
which have a certain i-value initialized to it at the start

271
00:14:02,760 --> 00:14:09,300
它从你放进东西里的特定条件中运行
and it runs from the particular condition you put into the thing

272
00:14:09,300 --> 00:14:12,090
并在你前进的过程中递增？
and increment it as you go along?

273
00:14:12,090 --> 00:14:15,700
大卫·马兰：简而言之 不 你不能做你所描述的事情 
DAVID MALAN: Short answer, no, you cannot do what you're describing,

274
00:14:15,700 --> 00:14:18,790
但我们很快就会看到另一种类型的for循环 
but there is another type of for loop that we will soon see.

275
00:14:18,790 --> 00:14:20,520
不过 让我们过一会儿再来讨论这个问题 
But let's come to that in just a moment.

276
00:14:20,520 --> 00:14:26,080
关于在这里使用循环的其他问题？
Other questions on loops using while here?

277
00:14:26,080 --> 00:14:28,443
观众：所以我对这个流程图有一个问题 
AUDIENCE: So I had a question about that flowchart.

278
00:14:28,443 --> 00:14:29,110
大卫·马兰：好的 
DAVID MALAN: OK.

279
00:14:29,110 --> 00:14:30,490
观众：有--是的 
AUDIENCE: There were-- yeah.

280
00:14:30,490 --> 00:14:36,510
有一些特定的符号代表着特定的陈述--
There were certain symbols for the certain kind of the statements were--

281
00:14:36,510 --> 00:14:42,283
他们是不是真的被用来发表这样的声明--
are they certainly used for that kind of statement that they--

282
00:14:42,283 --> 00:14:43,200
大卫·马兰：是的 
DAVID MALAN: They are.

283
00:14:43,200 --> 00:14:44,790
所以我考虑了--
So I deliberate--

284
00:14:44,790 --> 00:14:47,340
我故意使用某些类型的符号 某些形状
I deliberately use certain types of symbols, certain shapes

285
00:14:47,340 --> 00:14:51,570
在这里 椭圆形是启动和停止的常规方式 
here whereby an oval is conventional for start and stop.

286
00:14:51,570 --> 00:14:56,820
我将矩形用于任何代码语句 如赋值或打印
I used rectangles for any statement of code, like an assignment or a printing

287
00:14:56,820 --> 00:14:57,630
以此类推 
and so forth.

288
00:14:57,630 --> 00:15:02,040
我用钻石来代表你可能会问的问题 
And I used diamonds to represent questions that you might ask,

289
00:15:02,040 --> 00:15:03,988
正如我们所看到的情况 
conditions as we've seen.

290
00:15:03,988 --> 00:15:06,030
如果你是为了你自己 如果你只是
If you're doing this for yourself, if you're just

291
00:15:06,030 --> 00:15:07,950
试着理解你的代码并把它写下来 
trying to make sense of your code and writing it down,

292
00:15:07,950 --> 00:15:10,158
你当然不需要使用这些正式的符号 
you certainly don't need to use these formal symbols,

293
00:15:10,158 --> 00:15:13,367
但我试图与一些最佳实践保持一致 
but I tried to be consistent with some best practices.

294
00:15:13,367 --> 00:15:15,450
事实上 让我回到同样的画面 
And in fact, let me come back to the same picture,

295
00:15:15,450 --> 00:15:17,533
因为这是我们照片的第一个版本 
because this was the first version of our picture,

296
00:15:17,533 --> 00:15:19,830
但自那以后 我们已经修改了几次代码 
but we've since modified our code a couple of times.

297
00:15:19,830 --> 00:15:22,455
回想一下 这就是我们提出问题的版本
This, recall, was the version where the question we were asking

298
00:15:22,455 --> 00:15:26,340
我是不是不等于0 现在让我继续更改这个代码
was i not equal to 0, let me go ahead and just change this code now

299
00:15:26,340 --> 00:15:29,250
来代表我们做的下一个版本 回想一下 
to represent the next version we did, which, recall,

300
00:15:29,250 --> 00:15:31,950
改变了我们的逻辑 从1开始计数 
changed our logic to start counting from 1,

301
00:15:31,950 --> 00:15:36,060
它将我们的问题改为检查 因为I小于或等于3 
it changed our question to check as i less than or equal to 3,

302
00:15:36,060 --> 00:15:39,570
但是其他的一切都是一样的 除了计数 
but then everything else was the same except for the counting, which

303
00:15:39,570 --> 00:15:41,580
现在是正数而不是负数 
is now plus instead of minus.

304
00:15:41,580 --> 00:15:47,040
然后我们把它进一步细化 从0数到
And then we refined it a little bit further by counting now from 0 up to

305
00:15:47,040 --> 00:15:48,570
但不是穿过3点 
but not through 3.

306
00:15:48,570 --> 00:15:52,170
我们在这里通过将1递增来收紧代码
And we tightened up this code here by just incrementing 1

307
00:15:52,170 --> 00:15:54,220
通过使用稍微更简洁的语法 
by using the slightly more succinct syntax.

308
00:15:54,220 --> 00:15:57,120
因此 在这一点上 这些流程图可能会变得越来越没有用处
So at this point, these flowcharts might become less and less useful

309
00:15:57,120 --> 00:16:00,690
对于我们来说 因为一旦你的思想围绕着这个概念
for us, because once you've wrapped your mind around the concept

310
00:16:00,690 --> 00:16:03,750
希望这张照片能帮助我们把这个概念变成现实 
and hopefully the picture helps bring that concept to life,

311
00:16:03,750 --> 00:16:06,600
完全专注于代码当然是很好的
it certainly fine to focus entirely on the code

312
00:16:06,600 --> 00:16:09,240
只想着甚至画出这样的东西
and only think about or even draw something like this

313
00:16:09,240 --> 00:16:12,120
如果你需要考虑一些更复杂的事情
if you need to wrap your mind around something more complicated

314
00:16:12,120 --> 00:16:13,200
比你习惯的要多 
than you're used to.

315
00:16:13,200 --> 00:16:15,240
好吧 如果可以的话 让我继续说下去 并提出建议
Well, let me go ahead, if I may, and propose

316
00:16:15,240 --> 00:16:20,490
我们使用另一种循环类型转换到另一种方法
that we transition to another approach of types of loops using another

317
00:16:20,490 --> 00:16:22,740
关键字 即for循环 
keyword here, namely a for loop.

318
00:16:22,740 --> 00:16:25,050
这个词确实存在于其他语言中 
And this is a word that does exist in other languages,

319
00:16:25,050 --> 00:16:28,290
但不一定具有其他语言可能具有的功能
but doesn't necessarily have as many features as other languages might

320
00:16:28,290 --> 00:16:29,260
用它来 
use it for.

321
00:16:29,260 --> 00:16:33,300
但是还有一种不同类型的循环--不是While循环 而是for循环 
But there is a different type of loop-- not a while loop, but a for loop.

322
00:16:33,300 --> 00:16:37,620
而for循环将允许我们以不同的方式表达自己 
And a for loop is going to allow us to express ourselves a little differently,

323
00:16:37,620 --> 00:16:40,020
但要做到这一点 我建议最简单的方法
but to do so, I propose that the easiest way

324
00:16:40,020 --> 00:16:43,890
如果我们在Python语言中引入另一个概念 那就是列表 
is if we introduce one other idea in Python, which is that of a list.

325
00:16:43,890 --> 00:16:48,120
在这里 也没有双关语的意思 我们添加到数据类型列表中
And here, too, no pun intended, we're adding to the list of data types

326
00:16:48,120 --> 00:16:49,290
Python所支持的 
that Python supports.

327
00:16:49,290 --> 00:16:51,480
我们见过STR或字符串 
We've seen strs or strings.

328
00:16:51,480 --> 00:16:53,050
整型或整型 
Ints or integers.

329
00:16:53,050 --> 00:16:54,780
浮点值或浮点值 
Floats or floating point values.

330
00:16:54,780 --> 00:16:56,670
布尔或布尔表达式 
Bools or Boolean expressions.

331
00:16:56,670 --> 00:17:00,480
Python也有列表 这是另一种数据类型 
Python also has lists, which is another type of data,

332
00:17:00,480 --> 00:17:02,730
但奇妙的是 这一次可能非常熟悉 
but wonderfully, this one is probably pretty familiar.

333
00:17:02,730 --> 00:17:06,240
现实世界中的事物列表就是用Python编写的事物列表 
A list of things in the real world is a list of things in Python.

334
00:17:06,240 --> 00:17:11,490
这是一种在同一位置包含多个值的方式
It's a way of containing multiple values all in the same place, all

335
00:17:11,490 --> 00:17:12,940
在同一个变量中 
in the same variable.

336
00:17:12,940 --> 00:17:14,319
那么我这么说是什么意思呢？
So what do I mean by this?

337
00:17:14,319 --> 00:17:18,480
让我建议我们回到我们的VS代码 
Well let me propose that we go back to our VS Code here,

338
00:17:18,480 --> 00:17:22,480
让我在这里重新开始我的代码 根本不使用While循环 
and let me start fresh with my code here and not use a while loop at all,

339
00:17:22,480 --> 00:17:24,690
但让我用这个新的关键字 
but let me use this new keyword for.

340
00:17:24,690 --> 00:17:30,363
For循环的工作方式是 它允许您迭代项目列表 
The way for loop works is that it allows you to iterate over a list of items.

341
00:17:30,363 --> 00:17:31,530
那么这看起来像什么呢？
So what does this look like?

342
00:17:31,530 --> 00:17:32,940
它可能看起来像这样--
It might look like this--

343
00:17:32,940 --> 00:17:39,030
对于i和以下项目列表 0 1 2 
for i and the following list of items, 0, 1, 2.

344
00:17:39,030 --> 00:17:41,640
这是我的起点 在每次迭代中
This is my starting point, and on each iteration

345
00:17:41,640 --> 00:17:45,450
这个循环--也就是说 在每次执行这个循环时 
of this loop-- that is, on each execution of this loop again and again,

346
00:17:45,450 --> 00:17:47,550
我想把猫咪打印出来 
I want to print out meow.

347
00:17:47,550 --> 00:17:51,360
现在我承认 我已经有点喜欢这段代码的外观了
Now I'll admit, I kind of like the look of this code already

348
00:17:51,360 --> 00:17:53,580
尽管这里有一些新的语法 
even though there's some new syntax here,

349
00:17:53,580 --> 00:17:55,770
因为它只是比While循环短 
because it's just shorter than the while loop.

350
00:17:55,770 --> 00:17:58,480
While循环刚才有多行
The while loop had multiple lines a moment ago

351
00:17:58,480 --> 00:18:01,320
我是什么 完全由我自己决定 
and it was entirely up to me to decide what i is.

352
00:18:01,320 --> 00:18:04,530
我必须检查一个条件 我必须递增或递减i 
I have to check a condition, I have to increment or decrement i.

353
00:18:04,530 --> 00:18:07,230
就像我做了很多工作 相对而言 
Like I was doing a lot of work, relatively speaking,

354
00:18:07,230 --> 00:18:10,710
让那玩意儿转起来 让那个循环走下去 
to make that thing turn, to make that loop going to go.

355
00:18:10,710 --> 00:18:12,720
从某种意义上说 这是非常机械的 
It was very mechanical in a sense.

356
00:18:12,720 --> 00:18:18,030
你可以在你的脑海中看到齿轮转动 就像所有这些变量一样
You can in your mind's eye maybe see the gears turning as all of these variables

357
00:18:18,030 --> 00:18:21,120
正在发生变化 这些问题正在被提出 
are changing and these questions are being asked.

358
00:18:21,120 --> 00:18:24,450
For循环简化了所有这一切 它只是
A for loop simplifies all of that, and it just

359
00:18:24,450 --> 00:18:27,480
也就是说 如果你想要一个像i这样的变量 一个数字 
says, if you want a variable like i, a number,

360
00:18:27,480 --> 00:18:31,770
你事先就知道这个循环要执行多少次--三次
and you know in advance how many times want this loop to execute-- three

361
00:18:31,770 --> 00:18:34,380
我们只会具体说明它是什么
times, we'll just kind of specify what it

362
00:18:34,380 --> 00:18:37,560
就是你想让我显式地接受AS值 
is you want i to take on as values explicitly.

363
00:18:37,560 --> 00:18:41,940
在这个循环中 我将被Python自动初始化为0 
In this loop, i will be automatically initialized by Python to be 0,

364
00:18:41,940 --> 00:18:43,530
然后猫咪就会被打印出来 
then meow will be printed.

365
00:18:43,530 --> 00:18:48,870
然后 Python会自动将i更新为等于1 然后将打印meow 
Then Python would automatically update i to equal 1, then meow will be printed.

366
00:18:48,870 --> 00:18:53,520
然后 Python会自动将i更新为2 并打印meow 
Then Python will automatically update i to be 2 and meow will be printed.

367
00:18:53,520 --> 00:18:57,270
因为该列表中的值就是这样 所以Python将停止
And because that's it for the values in that list, Python will stop

368
00:18:57,270 --> 00:19:00,090
而且它总共只会叫三次 
and it will only meow a total of three times.

369
00:19:00,090 --> 00:19:01,170
名单是什么？
What is the list?

370
00:19:01,170 --> 00:19:05,130
这个程序中的列表正好是 0 逗号 1 逗号 2 
The list in this program is exactly that, 0, comma, 1, comma, 2,

371
00:19:05,130 --> 00:19:07,200
注意方括号 
and notice the square brackets.

372
00:19:07,200 --> 00:19:11,350
这些不是圆括号 那些是代表列表的方括号 
Those aren't parentheses, those are square brackets that represent a list.

373
00:19:11,350 --> 00:19:15,540
作为程序员 这就是可视化的方式--这就是Python所熟知的语言
That's how visually as the programmer-- that's how Python knows as the language

374
00:19:15,540 --> 00:19:18,460
你打算把它列成一个名单 
that you intend for that to be a list.

375
00:19:18,460 --> 00:19:23,490
因此 让我继续运行cat.py的这个Python 它的工作方式是一样的 
So let me go ahead and run this Python of cat.py, and it works just the same.

376
00:19:23,490 --> 00:19:24,660
但只有两行字 
But it's only two lines.

377
00:19:24,660 --> 00:19:28,330
一旦您熟悉了该结构 它就非常容易阅读 
It's pretty readable once you have familiarity with that construct,

378
00:19:28,330 --> 00:19:33,970
但就我一贯的观点来说 正确性并不一定
but to my constant point about correctness not necessarily

379
00:19:33,970 --> 00:19:38,800
与设计一样 这个程序在什么意义上可能是
being the same as design, in what sense is this program perhaps

380
00:19:38,800 --> 00:19:40,150
设计得很差？
poorly designed?

381
00:19:40,150 --> 00:19:41,140
它似乎起作用了 
It seems to work.

382
00:19:41,140 --> 00:19:45,790
它叫了三次 但为什么这次不能
It meows three times, but why might this not

383
00:19:45,790 --> 00:19:48,130
是解决这个问题的最好办法吗？
be the best way to solve this problem?

384
00:19:48,130 --> 00:19:51,190
即使你以前从未编程过 再一次 
Even if you've never programmed before, again,

385
00:19:51,190 --> 00:19:54,310
想想角落里的情况 可能会发生也可能不会发生的事情 
think about corner cases, things that may or may not happen.

386
00:19:54,310 --> 00:19:59,168
想一想真正测试代码质量的极端情况 
Think about extreme cases that really test the quality of this code.

387
00:19:59,168 --> 00:19:59,710
观众：好的 
AUDIENCE: OK.

388
00:19:59,710 --> 00:20:06,880
我想这是因为我们说了0 1 2 3次 
I think that because we are saying 0, 1, 2 3 times.

389
00:20:06,880 --> 00:20:11,030
如果你想拿一百万 你可以说1 2 3 
And then if you want to take a million, you say 1, 2, 3.

390
00:20:11,030 --> 00:20:12,967
大卫·马兰：是的 确实如此 
DAVID MALAN: Yeah, exactly.

391
00:20:12,967 --> 00:20:15,550
这就是我思考极端情况时的意思 
And that's what I mean about thinking about the extreme cases.

392
00:20:15,550 --> 00:20:18,430
如果您试图自己决定您自己的代码是否好
If you're trying to decide for yourself if your own code is good

393
00:20:18,430 --> 00:20:22,120
或者其他人的代码很好 乍一看可能是这样的 
or someone else's code is good, it might look so at first glance,

394
00:20:22,120 --> 00:20:23,530
但想一想极端的情况 
but think about the extreme.

395
00:20:23,530 --> 00:20:26,410
如果这不是三件事 而是一百万件事呢？
Well, what if it's not three things, it's a million things?

396
00:20:26,410 --> 00:20:31,180
我是说 你真的要把0写到一百万还是0
I mean, are you really going to write out 0 through a million or 0

397
00:20:31,180 --> 00:20:33,160
至9--
through 9--

398
00:20:33,160 --> 00:20:38,090
999,999？
999,999?

399
00:20:38,090 --> 00:20:40,840
就像不 你不会在屏幕上写那么多数字
Like no, you're not going to write that many numbers on the screen

400
00:20:40,840 --> 00:20:42,500
一定有更好的办法 
there's got to be a better way.

401
00:20:42,500 --> 00:20:45,100
所以让我们从一开始就做更好的事情
So let's do the better way from the get-go

402
00:20:45,100 --> 00:20:47,980
而不是为做一些糟糕的事情铺平道路 
rather than set the stage for doing something poorly.

403
00:20:47,980 --> 00:20:52,090
我们可以解决这个问题来改进设计的一个方法
And the one way we can solve this problem to improve the design

404
00:20:52,090 --> 00:20:56,950
不仅仅是手动指定值列表 使用函数 
is don't just manually specify the list of values, use a function,

405
00:20:56,950 --> 00:20:59,140
其他人的随附于Python的函数
someone else's function that comes with Python

406
00:20:59,140 --> 00:21:00,850
这就给了你想要的名单 
that gives you the list you want.

407
00:21:00,850 --> 00:21:02,680
而在Python中实现这一点的最简单方法是
And the easiest way to do that in Python is

408
00:21:02,680 --> 00:21:07,480
若要使用名为Range的函数 该函数将返回某个范围的值 
to use a function called range that returns to a range of values.

409
00:21:07,480 --> 00:21:09,940
它需要至少一个参数作为输入 
It expects as input at least one argument,

410
00:21:09,940 --> 00:21:14,170
这个数字将是您想要取回的值的数量 
and that number is going to be the number of values you want back.

411
00:21:14,170 --> 00:21:18,620
这些值将从0开始 一直到1、2 以此类推 
Those values are going to start at 0 and go to 1, to 2, and so forth,

412
00:21:18,620 --> 00:21:22,910
但他们将增加两个 但不是通过您指定的数字 
but they will go up two but not through the number you specify.

413
00:21:22,910 --> 00:21:26,200
因此 通过指定范围3 您基本上是
So by specifying range 3, you're essentially

414
00:21:26,200 --> 00:21:29,350
返还1、2、3个值 
being handed back 1, 2, 3 values.

415
00:21:29,350 --> 00:21:33,730
默认情况下 这些值是0、1和2 仅此而已 
And by default, those values are 0, 1, and 2, and that's it.

416
00:21:33,730 --> 00:21:37,240
但这件事的精彩之处在于 霍普认为 如果我这样做
But what's brilliant about this is that now, to Hope's point, if I do

417
00:21:37,240 --> 00:21:38,950
想要叫一百万次--
want to meow a million times--

418
00:21:38,950 --> 00:21:44,320
我的意思是 那是一只愤怒的猫 我现在只需输入一百万就可以做一百万 
I mean, that is an angry cat, I can now do a million by just typing a million.

419
00:21:44,320 --> 00:21:48,910
我不需要直接输入0 逗号 1 逗号 2 逗号 3 逗号 
I don't have to literally type 0, comma, 1, comma, 2, comma, 3, comma,

420
00:21:48,910 --> 00:21:53,620
4 一直到999,999 我只是这样做 
4, all the way up to 999,999, I just do this.

421
00:21:53,620 --> 00:21:57,140
因此 从长远来看 这肯定是一种更好的方式 
So that's got to be a better way long-term.

422
00:21:57,140 --> 00:21:59,080
所以这确实是我们可以改进的一个方面
So that's indeed one improvement we can indeed

423
00:21:59,080 --> 00:22:03,050
Make Here仍然使用for循环 但现在使用此Range函数 
make here still using a for loop, but now using this range function.

424
00:22:03,050 --> 00:22:05,470
我要向你们展示的是另一件毕德式的东西--
And just to show you something else that's Pythonic--

425
00:22:05,470 --> 00:22:07,690
严格来说 这并不是必需的 但通常
this is not strictly necessary, but it's commonly

426
00:22:07,690 --> 00:22:11,560
完成了 我们可以在这里做一些小的改进 
done, there's a minor improvement we can make here,

427
00:22:11,560 --> 00:22:14,180
即使我们只猫叫了三次 
even if we're just meowing three times.

428
00:22:14,180 --> 00:22:20,710
请注意 即使我定义了一个变量i 我也从来没有使用过它 
And notice that even though I'm defining a variable i, I'm not ever using it.

429
00:22:20,710 --> 00:22:24,700
从逻辑上讲 这是必要的 因为据推测 
And it's kind of necessary logically, because Python, presumably,

430
00:22:24,700 --> 00:22:26,620
必须用一些东西来计数 
has to use something for counting.

431
00:22:26,620 --> 00:22:28,960
它必须知道它在迭代什么 
It has to know what it's iterating over.

432
00:22:28,960 --> 00:22:30,970
但在Python语言中有这样一个约定
But there's this convention in Python where

433
00:22:30,970 --> 00:22:35,320
如果您需要一个变量 仅仅因为编程功能需要
if you need a variable, just because the programming feature requires

434
00:22:35,320 --> 00:22:38,890
它需要进行某种计数或自动更新 但你 人类 
it to do some kind of counting or automatic updating, but you, the human,

435
00:22:38,890 --> 00:22:42,550
不关心它的价值 这里是一种毕脱式的改进
don't care about its value, a Pythonic improvement here

436
00:22:42,550 --> 00:22:45,520
将该变量命名为单下划线 
would be to name that variable a single underscore.

437
00:22:45,520 --> 00:22:48,280
只是因为它不是必需的 它不
Just because it's not required, it doesn't

438
00:22:48,280 --> 00:22:50,410
改变程序的正确性 但它
change the correctness of the program, but it

439
00:22:50,410 --> 00:22:54,190
它会向同事或老师发出信号 
signals to yourself later, it signals to colleagues or teachers that

440
00:22:54,190 --> 00:22:57,207
也在看你的代码 是的 它是一个变量 
are looking at your code, too, that yes, it's a variable,

441
00:22:57,207 --> 00:23:00,040
但你不在乎它的名字 因为你以后不用它 
but you don't care about its name because you're not using it later,

442
00:23:00,040 --> 00:23:04,840
它只是为了使用这个功能 这个循环在这里 
it's just necessary in order to use this feature, this loop in this case here.

443
00:23:04,840 --> 00:23:09,190
这只是一个小小的改进或改变 
So just a minor improvement or change there.

444
00:23:09,190 --> 00:23:13,510
但要真正让你对Python的可能性感兴趣 
But to really gets you intrigued by what's possible in Python,

445
00:23:13,510 --> 00:23:15,140
我们再进一步
let's take this one step further.

446
00:23:15,140 --> 00:23:19,780
所以如果我们真的想成为Python 这个 如果你以前编程过 
So if we really want to be Pythonic, this one, if you've programmed before,

447
00:23:19,780 --> 00:23:22,310
会让你大吃一惊
is kind of going to blow your mind, so to speak,

448
00:23:22,310 --> 00:23:27,820
如果我想让猫叫三次 如果我真的这么做了呢？
whereby if I want the cat to meow three times, what if I actually do this?

449
00:23:27,820 --> 00:23:34,350
print open parenthesis quote-unquote meow times 3.
print, open parenthesis, quote-unquote, meow times 3.

450
00:23:34,350 --> 00:23:37,620
你得有点极客才能觉得这很酷 但这确实有点酷 
You have to be kind of a geek to think this is cool, but this is kind of cool.

451
00:23:37,620 --> 00:23:40,620
所以你可以直接打印你想要的 
So you can literally just print what you want,

452
00:23:40,620 --> 00:23:44,070
乘以你想要的次数
multiply it by the number of times that you want it,

453
00:23:44,070 --> 00:23:47,760
你会得到完全相同的结果
and you will get back exactly that result.

454
00:23:47,760 --> 00:23:50,763
我好像犯了个错误 
Now I've kind of made a mistake here.

455
00:23:50,763 --> 00:23:51,930
让我们看看它的作用 
So let's see what this does.

456
00:23:51,930 --> 00:23:56,730
对你们中的一些人来说 它并不像这段代码看起来那么漂亮 
It's not quite as beautiful as this code might look to you-- to some of you,

457
00:23:56,730 --> 00:23:57,240
对我
to me.

458
00:23:57,240 --> 00:24:00,300
让我运行cat.py的Python 回车 
Let me run Python of cat.py, Enter.

459
00:24:00,300 --> 00:24:02,820
好吧 就像是饿猫之类的 
OK, it's a really like hungry cat or something.

460
00:24:02,820 --> 00:24:04,350
它叫得很快 
It's meowing really fast.

461
00:24:04,350 --> 00:24:06,830
但我能解决这个问题 我敢打赌 
But I can fix this, I bet.

462
00:24:06,830 --> 00:24:10,010
现在让我们来思考一下我们讨论过的一些基本组成部分 
Let's think about now some of the basic building blocks we've discussed.

463
00:24:10,010 --> 00:24:13,160
问题显然是 从字面上喵 喵 
The problem is clearly that literally meow, meow,

464
00:24:13,160 --> 00:24:16,460
喵喵叫重复了三次 但没有我想要的那么漂亮 
meow is being repeated three times, but it's not as pretty as I want it.

465
00:24:16,460 --> 00:24:19,910
我希望它是喵 喵 喵在不同的线上 
I want it to be meow, meow, meow on separate lines.

466
00:24:19,910 --> 00:24:22,850
有什么可能的解决方案
What might be a possible solution here while still

467
00:24:22,850 --> 00:24:26,780
使用这个乘法运算符？
using this multiplication operator?

468
00:24:26,780 --> 00:24:27,560
回想一下 
And think back.

469
00:24:27,560 --> 00:24:30,170
我们已经使用加号连接字符串 
We've used plus to concatenate strings.

470
00:24:30,170 --> 00:24:33,980
显然 可以使用乘法连接字符串 但不止一次
You can apparently use multiplication to concatenate strings, but more than once

471
00:24:33,980 --> 00:24:35,180
一遍又一遍
again and again and again.

472
00:24:35,180 --> 00:24:37,580
我怎么才能在不恢复
How could I clean this up without reverting

473
00:24:37,580 --> 00:24:42,240
到我的For循环或我的While循环 并且仍然以这种方式使用乘法？
to my for loop or my while loop and still use multiplication in this way?

474
00:24:42,240 --> 00:24:45,975
观众：我们可以使用转义序列 即反斜杠n 
AUDIENCE: We can use the escape sequence which would be backslash n.

475
00:24:45,975 --> 00:24:46,850
大卫·马兰：太棒了 
DAVID MALAN: Amazing.

476
00:24:46,850 --> 00:24:47,350
是 
Yes.

477
00:24:47,350 --> 00:24:50,750
回想一下反斜杠n 这是您作为程序员的方式
Think back to backslash n, which is the way you as the programmer

478
00:24:50,750 --> 00:24:52,970
可以在代码中表示新行 
can express a new line in code.

479
00:24:52,970 --> 00:24:57,560
我想 如果我听从你的建议 我会在里面加一个反斜杠
And I think, if I take your advice, I put a backslash in there inside

480
00:24:57,560 --> 00:25:02,390
所以在每一句M-E-O-W的结尾 都有一行新的 
of my quotes, so that at the end of every M-E-O-W, there's a new line,

481
00:25:02,390 --> 00:25:03,470
让我们看看这是什么样子 
let's see how this looks.

482
00:25:03,470 --> 00:25:06,650
让我清空屏幕并运行cat.py的Python 
Let me clear my screen and run Python of cat.py.

483
00:25:06,650 --> 00:25:08,270
好的 就差那么一点了 
OK, so close.

484
00:25:08,270 --> 00:25:09,030
我喜欢这个 
I like this.

485
00:25:09,030 --> 00:25:10,490
让我去找别人吧 
Let me call on someone else.

486
00:25:10,490 --> 00:25:13,670
我唯一不喜欢的是--我知道我现在真的很挑剔--
The only thing I don't like-- and I know I'm being really nitpicky now--

487
00:25:13,670 --> 00:25:15,840
它是猫叫 猫叫 猫叫在不同的线上 
is that it's meow, meow, meow on separate lines,

488
00:25:15,840 --> 00:25:20,300
但有一条额外的空白线 我只是不喜欢审美上的 
but there's this extra blank line, which I'm just not loving aesthetically.

489
00:25:20,300 --> 00:25:25,430
观众：我认为我们可以使n等于列--
AUDIENCE: I think we can make n equal to column--

490
00:25:25,430 --> 00:25:27,410
列 而不是--像斜杠n 
column, not-- like a slash n.

491
00:25:27,410 --> 00:25:28,160
大卫·马兰：是的 
DAVID MALAN: Yeah.

492
00:25:28,160 --> 00:25:31,010
所以 这里也一样 就像我们在过去几周看到的所有事情一样
So here, too, like all of these things we've seen in past weeks

493
00:25:31,010 --> 00:25:32,630
就像是走到了一起 
are kind of coming together.

494
00:25:32,630 --> 00:25:37,010
回想一下 打印函数允许您控制行尾是什么 
Recall that the print function lets you control what the line ending is.

495
00:25:37,010 --> 00:25:39,570
默认情况下 它本身就是反斜杠n 
By default, it's backslash n itself.

496
00:25:39,570 --> 00:25:41,540
这就是为什么在这张照片的最后 
Which is why at the very end of this print,

497
00:25:41,540 --> 00:25:44,300
光标将再次移动到下一行 
the cursor is being moved again to the next line.

498
00:25:44,300 --> 00:25:46,260
我们只需要推翻它就行了 
Well, we need to just override that.

499
00:25:46,260 --> 00:25:50,420
让我在这里进入我的代码 并将其更改为逗号n
So let me go into my code here and let me change this to comma n

500
00:25:50,420 --> 00:25:54,890
等于引号-非引号 因此它不再是默认的反斜杠n 
equals quote-unquote so that it's no longer the default backslash n,

501
00:25:54,890 --> 00:25:59,150
相反 现在它将什么都不是 
it's instead now going to be nothing whatsoever.

502
00:25:59,150 --> 00:26:03,890
那么 希望这应该会消除额外的空行 
That should eliminate, then, hopefully that additional blank line.

503
00:26:03,890 --> 00:26:07,220
所以让我在这里运行最后一次 cat.py的Python 回车 
So let me run this one last time here, Python of cat.py, Enter,

504
00:26:07,220 --> 00:26:08,640
现在我们就知道了 
and there we have it.

505
00:26:08,640 --> 00:26:12,200
所以现在 至少在编程过程中 它是
So now, at least as programming goes, it's

506
00:26:12,200 --> 00:26:15,530
我可以把这些提炼成一小行 这真是太酷了
kind of cool that I can distill this into a short line

507
00:26:15,530 --> 00:26:17,120
一下子表达了自己的想法 
and express myself all at once.

508
00:26:17,120 --> 00:26:19,520
现在 公平地说 它的可读性有所降低 
Now to be fair, it's a little less readable.

509
00:26:19,520 --> 00:26:21,950
就像现在我有反斜杠n 我有3倍 
Like now I've got backslash n, I've got times 3,

510
00:26:21,950 --> 00:26:23,390
我得到了n等于引号-不引号 
I've got n equals quote-unquote.

511
00:26:23,390 --> 00:26:25,400
所以你不必用这种方式做事 
So you don't have to do things this way.

512
00:26:25,400 --> 00:26:28,440
我之前使用for循环的方法 完全没问题 
My previous approach with a for loop, totally fine.

513
00:26:28,440 --> 00:26:31,940
我之前使用While循环的方法 完全可以 在某种意义上 
My previous approach with a while loop, totally fine, and in some sense,

514
00:26:31,940 --> 00:26:33,740
完美的设计 
perfectly well-designed.

515
00:26:33,740 --> 00:26:36,600
但这只是另一种方式 
But this is just yet another way to do it,

516
00:26:36,600 --> 00:26:40,250
但如果你或你的老师 你的同事 你的朋友
but it's not a good thing if you or your teacher, your colleague, your friend

517
00:26:40,250 --> 00:26:42,410
将会很难读懂你自己的代码 
are going to struggle to read your own code.

518
00:26:42,410 --> 00:26:47,870
但这是一些语言实际上没有的一个Python特性 
But this is a feature of Python that some languages do not, in fact, have.

519
00:26:47,870 --> 00:26:51,110
好吧 让我提议让事情变得更有趣
All right, well let me propose that things get more interesting still

520
00:26:51,110 --> 00:26:53,690
如果我们不只是猫叫三次 
if we're not just meowing three times only,

521
00:26:53,690 --> 00:26:56,180
但我们的猫咪叫声次数是可变的 
but we're meowing some variable number of times.

522
00:26:56,180 --> 00:26:58,940
让我们来问问用户这只猫应该叫几次 
Let's ask the user how many times this cat should meow.

523
00:26:58,940 --> 00:27:03,540
所以让我清理一下屏幕 让我想想 好吧 
So let me clear the screen here, and let me figure out, well,

524
00:27:03,540 --> 00:27:05,760
我如何从用户那里获得号码？
how do I get a number from the user?

525
00:27:05,760 --> 00:27:08,670
这里的问题是 如果我想让用户给我一个数字 
The catch here is that if I want the user to give me a number,

526
00:27:08,670 --> 00:27:12,290
我不是在做数学 本质上 我在猫叫 因此 用户
I'm not doing math, per se, I'm meowing, and therefore, the user

527
00:27:12,290 --> 00:27:14,630
必须给我一个积极的价值 
has to give me a positive value.

528
00:27:14,630 --> 00:27:17,100
用户必须给我一个正值 
The user has to give me a positive value.

529
00:27:17,100 --> 00:27:18,860
那么 我怎么能坚持这一点呢？
So how can I insist on this?

530
00:27:18,860 --> 00:27:25,800
如果我这样做 n等于输入的int 那么n是什么 问号？
Well, if I just do this, n equals int of input, what's n, question mark?

531
00:27:25,800 --> 00:27:28,040
嗯 我想确认一下--
Well, I want to check like--

532
00:27:28,040 --> 00:27:32,150
我可以说 如果n小于0-
I could say if n is less than 0--

533
00:27:32,150 --> 00:27:34,430
如果它是阴性的 那么我可以这样做 
like if it's negative, well I could do this.

534
00:27:34,430 --> 00:27:35,870
好吧 那就再问一遍 
Well, then ask again.

535
00:27:35,870 --> 00:27:40,370
INT INPUT n是什么 问号？
Int, input, what's n, question mark?

536
00:27:40,370 --> 00:27:43,312
好的 那么如果用户仍然不给我一个正数怎么办？
OK, well what if the user still doesn't give me a positive number?

537
00:27:43,312 --> 00:27:45,770
如果真的很难 他们没有注意到呢
What if being really difficult they're not paying attention

538
00:27:45,770 --> 00:27:47,395
然后他们输入了两个负数？
and they typed in two negative numbers?

539
00:27:47,395 --> 00:27:53,000
如果n小于0 那么我们再来一次 N等于--
Well, if n is less than 0, well, let's do it again. n equals--

540
00:27:53,000 --> 00:27:54,170
这不会有好的结局 
this does not end well.

541
00:27:54,170 --> 00:27:58,070
你不能无限次地不停地检查 是否定的吗 
You can't infinitely many times keep checking, is it negative,

542
00:27:58,070 --> 00:27:59,630
它是负面的 还是负面的？
is it negative, or is it negative?

543
00:27:59,630 --> 00:28:01,700
这个程序永远不会被写完 
The program would never be done written.

544
00:28:01,700 --> 00:28:05,010
所以我们可以做这件事 我想更好 也许用一个循环 
So we can do this I think better maybe with a loop.

545
00:28:05,010 --> 00:28:06,200
因此 让我提出这一点 
So let me propose this.

546
00:28:06,200 --> 00:28:09,020
在Python中有一个非常常见的范例 当您
A very common paradigm in Python, when you

547
00:28:09,020 --> 00:28:14,000
希望获得与您的特定期望相匹配的用户输入 
want to get user input that matches a certain expectation you have,

548
00:28:14,000 --> 00:28:17,570
这一切都是积极的 都是消极的 或者只是类似的东西 
that it's all positive, that it's all negative, or just something like that,

549
00:28:17,570 --> 00:28:20,840
你马上就会说虽然是真的 
you just immediately say while true.

550
00:28:20,840 --> 00:28:24,380
你故意的 有点危险 但很老套 
You deliberately, and a little dangerously but a very conventionally,

551
00:28:24,380 --> 00:28:25,962
引发无限循环 
induce an infinite loop.

552
00:28:25,962 --> 00:28:27,170
那么什么是无限循环呢？
Now what is an infinite loop?

553
00:28:27,170 --> 00:28:28,550
它只是一个永远不会消失的东西 
It's just one that goes forever.

554
00:28:28,550 --> 00:28:31,430
我们已经看到了这种情况是如何在数学上偶然发生的 
And we've seen how that can happen accidentally mathematically.

555
00:28:31,430 --> 00:28:34,700
当你说虽然是真的时 这绝对会发生 
It's absolutely going to happen when you say while true.

556
00:28:34,700 --> 00:28:35,240
为什么？
Why?

557
00:28:35,240 --> 00:28:39,180
嗯 真正问题的答案总是正确的 
Well, the answer to the true question is always true.

558
00:28:39,180 --> 00:28:41,570
因此 这是一种故意诱导循环的方式
So this is a way of deliberately inducing a loop that

559
00:28:41,570 --> 00:28:43,470
默认情况下 它将永远消失 
by default is going to go forever.

560
00:28:43,470 --> 00:28:46,940
所以我们需要一种方法来打破这个循环 当
So we're going to need a way of breaking out of this loop when

561
00:28:46,940 --> 00:28:48,350
我们有我们想要的号码 
we have the number we want.

562
00:28:48,350 --> 00:28:50,600
大会 虽然在这个会议的其他方面
The convention, though inside of this otherwise

563
00:28:50,600 --> 00:28:52,970
无限循环就是问你关心的问题 
an infinite loop is to ask the question you care about,

564
00:28:52,970 --> 00:28:55,760
比如通过提示用户输入来给我一个int 
like give me an int by prompting the user for input.

565
00:28:55,760 --> 00:28:57,800
比如n是什么 问号？
Like what's n, question mark?

566
00:28:57,800 --> 00:28:59,330
然后问你自己的问题 
And then just ask your question.

567
00:28:59,330 --> 00:29:04,580
因此 如果n小于0 那么我认为我们希望Python继续
So if n is less than 0, then I think we want Python to just continue

568
00:29:04,580 --> 00:29:05,910
以再次提示用户 
to prompt the user again.

569
00:29:05,910 --> 00:29:09,760
也就是说 我们希望代码停留在循环中 调用输入函数 
That is, we want the code to stay in the loop, recall the input function,

570
00:29:09,760 --> 00:29:11,760
并希望用户给我们一个更好的答案 
and hope that the user gives us a better answer.

571
00:29:11,760 --> 00:29:14,730
如果这一次它小于0 那么让我们按字面意思
If this time around it's less than 0, so let's just literally

572
00:29:14,730 --> 00:29:16,980
使用Python的关键字Continue 其意思是
use Python's keyword continue, which says

573
00:29:16,980 --> 00:29:20,100
就是这样--继续保持在这个循环中 
just that-- continue to stay within this loop.

574
00:29:20,100 --> 00:29:24,000
否则 如果不小于0 让我们继续前进 只需突破
Else, if it's not less than 0, let's go ahead and just break out

575
00:29:24,000 --> 00:29:27,120
使用了Python语言中的另一个关键字Break 
of the loop altogether using another keyword in Python, break.

576
00:29:27,120 --> 00:29:31,140
在这种情况下 Break将使您脱离最近开始的循环
Break will break you out of the most recently begun loop in this case

577
00:29:31,140 --> 00:29:34,080
如果不是n小于0的情况 
if it's not the case that n is less than 0.

578
00:29:34,080 --> 00:29:38,310
所以这是可行的 它将允许我们获得一个大于或等于0的值
So this will work, and it will allow us to get a value that 0 or greater

579
00:29:38,310 --> 00:29:41,340
来自用户 但我认为我们可以进一步收紧它 以免
from the user, but I think we can tighten it up further so as to not

580
00:29:41,340 --> 00:29:43,500
不厌其烦地假设 然后 等等 
bother having an if, and, and else.

581
00:29:43,500 --> 00:29:49,227
为什么我们不直接说 如果n大于0 继续并中断呢？
Why don't we instead just say, if n is greater than 0, go ahead and break?

582
00:29:49,227 --> 00:29:51,060
事实上 这并不是一个有趣的节目
In fact, it's not that interesting a program

583
00:29:51,060 --> 00:29:52,830
如果我们甚至允许用户输入0 
if we even allow the user to type in 0.

584
00:29:52,830 --> 00:29:56,430
所以让我们等到他们给我们一个大于0的整数
So let's wait until they give us an integer that is greater than 0

585
00:29:56,430 --> 00:29:59,040
然后跳出这个循环 
and then break out of this loop.

586
00:29:59,040 --> 00:30:00,960
我现在在这里能做些什么呢？
And what can I now do down here?

587
00:30:00,960 --> 00:30:07,260
对于i来说 不管n是什么值 都可以打印猫咪 
For i in range of whatever that value n is, print meow.

588
00:30:07,260 --> 00:30:10,340
老实说 我不需要我在这里 所以让我回到那个原则上
And honestly, I don't need i here, so let me come back to that principle

589
00:30:10,340 --> 00:30:10,840
在此之前 
before.

590
00:30:10,840 --> 00:30:12,590
让我把它改成下划线
And let me just change it to an underscore

591
00:30:12,590 --> 00:30:14,110
如果你愿意的话 只是想表达一下毕多德式的意思 
just to be Pythonic, if you will.

592
00:30:14,110 --> 00:30:15,360
那到底是怎么回事？
So what's going on?

593
00:30:15,360 --> 00:30:20,130
第1行到第4行故意实现无限循环
Lines 1 through 4 deliberately implement an infinite loop

594
00:30:20,130 --> 00:30:23,280
否则 默认情况下 这种情况将永远消失 
that otherwise by default is going to go forever.

595
00:30:23,280 --> 00:30:26,370
但我在问一个问题 在那个循环里 
But I'm asking a question, inside of that loop,

596
00:30:26,370 --> 00:30:30,450
在第2行上从用户那里获得一个int之后 我将检查 
after getting an int from the user on line 2, I'm then checking,

597
00:30:30,450 --> 00:30:32,310
它是否大于0？
is it greater than 0?

598
00:30:32,310 --> 00:30:33,570
还是说是0？
Or is it 0?

599
00:30:33,570 --> 00:30:34,220
是阴性的吗？
Is it negative?

600
00:30:34,220 --> 00:30:35,970
对于猫咪来说 这一切都说不通 
None of which makes sense for meowing cat.

601
00:30:35,970 --> 00:30:38,380
好像我想让那只猫至少叫一次 
Like I want the cat to meow at least one time.

602
00:30:38,380 --> 00:30:41,220
因此 如果它大于0 则中断 
So if it is greater than 0, break.

603
00:30:41,220 --> 00:30:45,030
这个Break语句 即使它是缩进的 缩进了两次 
And this break statement, even though it's indented, indented twice,

604
00:30:45,030 --> 00:30:50,140
具有中断最近开始的While循环的效果 
has the effect of breaking out of the most recently begun while loop.

605
00:30:50,140 --> 00:30:53,670
因此 一旦用户给你一个正值 
So once the user gives you a positive value,

606
00:30:53,670 --> 00:30:58,650
然后我们到了第6行 在这一点上我们猫叫了很多次 因为
then we get to line 6, at which point we meow that many times because

607
00:30:58,650 --> 00:30:59,850
6号线和7号线 
of line 6 and 7.

608
00:30:59,850 --> 00:31:03,960
所以 如果我现在运行这个cat.py的Python 输入 那么 n是什么？
So if I run this now Python of cat.py, Enter, well, what's n?

609
00:31:03,960 --> 00:31:06,895
让我们从我们开始的3开始 喵 
Let's start with 3 where we began, meow, meow, meow.

610
00:31:06,895 --> 00:31:10,020
这一次 让我继续并增加我的终端窗口的大小
Well this time, let me go ahead and increase the size of my terminal window

611
00:31:10,020 --> 00:31:11,100
只是暂时的 
just temporarily.

612
00:31:11,100 --> 00:31:16,140
让我运行Cat.py的Python 让我运行10次 现在猫咪10次
Let me run Python of cat.py, let me do it 10 times, meow 10 times now

613
00:31:16,140 --> 00:31:17,520
出现在屏幕上 
appears on the screen.

614
00:31:17,520 --> 00:31:20,640
这里要说的不仅仅是我们可以猫叫10次
And the takeaways here are not just that we can meow 10 times

615
00:31:20,640 --> 00:31:22,890
或者一次又一次地做某事 但这
or do something again and again, but this

616
00:31:22,890 --> 00:31:26,880
是在您想要再次做某事时 在Python中非常常见的范例
is a very common paradigm in Python when you want to do something again

617
00:31:26,880 --> 00:31:31,320
一次又一次 但只有在用户真正给你
and again and again, but only until the user actually gives you

618
00:31:31,320 --> 00:31:34,230
这是你在这里所关心的价值 
a value that you care about here.

619
00:31:34,230 --> 00:31:36,540
现在让我向你求婚 因为我们练习了
And let me propose actually now that we practice

620
00:31:36,540 --> 00:31:41,830
更多的是我们一直在宣扬的 特别是当涉及到 比如说--
a little more what we've been preaching, especially when it comes to, say--

621
00:31:41,830 --> 00:31:45,075
尤其是当涉及到编写您自己的函数时 
especially when it comes to say writing your own functions.

622
00:31:45,075 --> 00:31:46,950
现在我都在猫叫了 可能会
Now that I'm doing all this meowing, it might

623
00:31:46,950 --> 00:31:50,970
很高兴能真正拥有一个Monow函数 它是Python的发明者
be nice to actually have a meow function that the inventors of Python

624
00:31:50,970 --> 00:31:52,680
没想到 所以就让我来做吧 
didn't envision, so let me do this.

625
00:31:52,680 --> 00:31:56,050
让我实际删除所有这些代码 让我继续执行此操作 
Let me actually get rid of all this code and let me go ahead and do this.

626
00:31:56,050 --> 00:31:59,950
让我继续说明定义一个主函数 就像我以前做过的那样 
Let me go ahead and say define a main function, as I've done before,

627
00:31:59,950 --> 00:32:02,400
让我盲目地叫猫咪3 
and let me just blindly call meow 3.

628
00:32:02,400 --> 00:32:05,910
猫咪还不存在 但当它存在的时候 那就太好了 
Meow doesn't exist yet, but when it does, that'll be great.

629
00:32:05,910 --> 00:32:08,640
所以 现在让我来定义一下猫咪 
So let me go ahead now and define meow.

630
00:32:08,640 --> 00:32:11,850
所以我是猫咪函数应该接受的输入
So am I meow function should take as input

631
00:32:11,850 --> 00:32:16,350
一个名为n的参数 或者我想要的任何东西 这部分现在很容易了 
a parameter called n or anything I want, and this part's pretty easy now.

632
00:32:16,350 --> 00:32:17,880
你是怎么叫n次的？
How do you meow n times?

633
00:32:17,880 --> 00:32:22,470
好的 为了给n加下划线 也就是n的范围 你可以直接打印猫咪 
Well, for underscore n, the range of n, go ahead and just print meow.

634
00:32:22,470 --> 00:32:24,780
所以和以前一样的代码 这里没有什么新鲜事 
So same code as before, nothing new here,

635
00:32:24,780 --> 00:32:28,470
我只是把这个逻辑放在一个猫咪函数中
I'm just putting that logic inside of a meow function

636
00:32:28,470 --> 00:32:30,810
这将会产生打印猫咪的副作用 
that's going to have this side effect of printing meow.

637
00:32:30,810 --> 00:32:34,620
现在 像以前一样 让我到下面来 让我确保我调用Main 
And now, as before, let me go down here and let me make sure I call main.

638
00:32:34,620 --> 00:32:39,420
如果我现在运行这段代码 猫的巨蟒 喵 
And if I now run this code, Python of cat.py, meow, meow, meow.

639
00:32:39,420 --> 00:32:42,960
它总是会做3 因为我已经硬编码到3 
It's always going to do three because I've hardcoded to 3.

640
00:32:42,960 --> 00:32:44,730
好吧 让我们在这里做一个改进 
Well, let's make one improvement here.

641
00:32:44,730 --> 00:32:48,720
现在让我继续下去 也许可以这样做 
Let me go ahead now and maybe do this.

642
00:32:48,720 --> 00:32:50,350
让我向用户索要一个号码 
Let me ask the user for a number.

643
00:32:50,350 --> 00:32:54,700
让我们这样说 数字等于得到数字 
So let's say something like this, number equals get number.

644
00:32:54,700 --> 00:32:55,200
好的 
All right.

645
00:32:55,200 --> 00:32:57,210
遗憾的是 在Python中没有函数
Unfortunately, there is no function in Python

646
00:32:57,210 --> 00:32:59,940
从用户那里获得正数的被调用的GET号码 
called get number that gets a positive number from the user,

647
00:32:59,940 --> 00:33:01,080
但这是我可以发明的 
but I can invent that.

648
00:33:01,080 --> 00:33:05,070
所以定义Get Number 打开Paren 关闭Paren 
So define get number, open paren, close paren.

649
00:33:05,070 --> 00:33:07,260
然后在这个函数内部 让我这样做 
And then inside of this function, let me do this.

650
00:33:07,260 --> 00:33:11,160
如果为真 则继续并从用户那里获取一个数字 
While true, go ahead and get a number from the user,

651
00:33:11,160 --> 00:33:14,730
将其转换为整型 问他们 n是什么 问号？
converting it to an int asking them, what's n, question mark?

652
00:33:14,730 --> 00:33:19,260
如果n是我想要的 它就是一个大于0的值 
And then if n is what I want, it's a greater than 0 value,

653
00:33:19,260 --> 00:33:24,710
一个正数 我不一定要打破这一次 
a positive number, I don't want to break this time necessarily,

654
00:33:24,710 --> 00:33:26,000
虽然我可以 
although I could.

655
00:33:26,000 --> 00:33:30,750
相反 我希望返回值 这样我就可以实际执行此操作 
I instead want to return the value so I can actually do this instead.

656
00:33:30,750 --> 00:33:32,600
而这也是Python的一个特性 
And this, too, is a feature of Python.

657
00:33:32,600 --> 00:33:35,690
这种能力不仅仅是从一块代码中解脱出来 
This ability not to just break out of a block of code,

658
00:33:35,690 --> 00:33:38,750
还可以在代码中返回值 
but also to return a value in code.

659
00:33:38,750 --> 00:33:42,590
实际上 返回一个值使您最终能够 
To actually return a value gives you the ability, ultimately,

660
00:33:42,590 --> 00:33:47,030
显式返回值 以便您的函数不只有一个边
to return explicitly a value so that your function has not just a side

661
00:33:47,030 --> 00:33:51,650
效果是必然的 但它实际上是回馈 就像输入一样 
effect, necessarily, but it actually hands back, just like input does,

662
00:33:51,650 --> 00:33:56,220
就像int做的一样 就像Float做的一样 对用户来说是一个实际值 
just like int does, just like float does, an actual value to the user.

663
00:33:56,220 --> 00:33:58,790
现在澄清一下 我不需要在这里返回n 
Now to be clear, I don't have to return n here.

664
00:33:58,790 --> 00:34:02,330
我仍然可以像过去对代码所做的那样跳出循环
I can still break out of the loop as I've done in the past with code

665
00:34:02,330 --> 00:34:06,860
像这样 但在循环之后 我仍然必须返回 
like this, but then after the loop, I still have to return.

666
00:34:06,860 --> 00:34:10,969
所以这里发生的事情是 如果你使用Break来跳出循环 
And so what's happening here is that if you use break to get out of the loop,

667
00:34:10,969 --> 00:34:13,730
但您需要从函数中传回一个值 
but you need to hand back a value from a function,

668
00:34:13,730 --> 00:34:15,980
现在您仍然必须使用RETURN关键字
you still have to use the return keyword now

669
00:34:15,980 --> 00:34:20,389
显式地要么像我一样在循环中 要么现在在循环之外
explicitly either in the loop as I did or now outside of the loop

670
00:34:20,389 --> 00:34:24,110
但仍在函数内部 
but still inside of the function.

671
00:34:24,110 --> 00:34:26,420
我现在要做的最后一件事是改变
The last thing I'm going to do here now is change

672
00:34:26,420 --> 00:34:28,969
我们之前硬编码的那个3 实际上
that 3, which we hardcoded earlier, to actually

673
00:34:28,969 --> 00:34:31,590
是我们从用户那里获得的变量的值
be the value of the variable we've gotten from the user

674
00:34:31,590 --> 00:34:36,380
所以现在在这里 如果我运行cat.py的Python 输入 n是什么？
so that now down here, if I run Python of cat.py, Enter, what's n?

675
00:34:36,380 --> 00:34:40,219
我可以输入3 我可以得到我的三声 或者如果我只想要一声 
I can type in 3, I get my three meows, or if I only want one,

676
00:34:40,219 --> 00:34:43,020
我现在得到了一只猫叫 
I now get one meow instead.

677
00:34:43,020 --> 00:34:43,520
好的 
All right.

678
00:34:43,520 --> 00:34:48,230
因此 如果我们现在有能力在这些循环中一次又一次地做事情 
So if we now have this ability to do things again and again in these loops,

679
00:34:48,230 --> 00:34:51,800
让我们看看我们是否不能解决其他一些问题 通过
let's see if we can't solve some other problems via which

680
00:34:51,800 --> 00:34:55,894
周期性地表达自己 但也会得到一些有趣的答案 
to express ourselves cyclically, but get back some interesting answers as well.

681
00:34:55,894 --> 00:34:58,898
例如 让我提议 我们看起来
And let me propose, for instance, that we look

682
00:34:58,898 --> 00:35:00,440
更密切地关注这些榜单 
a little more closely at these lists.

683
00:35:00,440 --> 00:35:03,107
事实证明 在Python中 而且实际上 在一般的程序中 
It turns out that in Python, and really, in programs in general,

684
00:35:03,107 --> 00:35:05,600
有一个值列表很有用 因为我们是
it's useful to have a list of values, because we're

685
00:35:05,600 --> 00:35:10,160
将能够处理越来越多的数据、越来越大的数据集 
going to be able to work with more and more data, larger and larger data sets.

686
00:35:10,160 --> 00:35:12,530
因此 让我建议我们回到VS代码这里
So let me propose that we come back to VS Code here

687
00:35:12,530 --> 00:35:15,620
让我们来做一些可能对一些人来说有点熟悉的事情 
and let's do something that's perhaps a little familiar to some folks,

688
00:35:15,620 --> 00:35:17,030
霍格沃茨的世界 
the world of Hogwarts.

689
00:35:17,030 --> 00:35:19,850
让我继续编写一个名为霍格沃茨的文件 
And let me go ahead and code up a file called Hogwarts,

690
00:35:19,850 --> 00:35:23,840
让我们看看我们能不能列出霍格沃茨的学生名单 
and let's see if we can't have a list of students at Hogwarts here.

691
00:35:23,840 --> 00:35:26,270
因此 我有一个名为hogwarts.py的新选项卡 
So I have a new tab called hogwarts.py.

692
00:35:26,270 --> 00:35:30,710
让我继续下去 提议我在这个程序中定义
and let me go ahead and propose that I just define in this program

693
00:35:30,710 --> 00:35:32,780
一份我事先知道名字的学生名单 
a list of students whose names I know in advance.

694
00:35:32,780 --> 00:35:34,572
因此 我暂时不会让用户输入 
So I'm not going to get user input for now.

695
00:35:34,572 --> 00:35:37,250
我从一开始就知道这三个人
I'm just going to know from the get-go that the three

696
00:35:37,250 --> 00:35:39,110
我想考虑的学生是这些 
students I want to consider are these.

697
00:35:39,110 --> 00:35:41,030
我们的变量将被称为学生 
Our variable is going to be called students.

698
00:35:41,030 --> 00:35:44,540
就像我在过去做的那样 它等于一个方括号 它
It's going to equal, as I've done in the past, a square bracket, which

699
00:35:44,540 --> 00:35:46,100
意思是 嘿 这是一份清单 
means, hey, here comes a list.

700
00:35:46,100 --> 00:35:49,520
这些值将是引号中的赫敏 因为它是
And those values are going to be Hermione in quotes, because it's

701
00:35:49,520 --> 00:35:53,980
一个字符串；用引号引起来的哈里 因为它是一个字符串；然后罗恩用引号 
a string; Harry in quotes, because it's a string; and then Ron in quotes,

702
00:35:53,980 --> 00:35:55,230
因为它也是一根线 
because it's a string as well.

703
00:35:55,230 --> 00:35:57,800
这是一个长度为3的列表 
So this is a list of length 3.

704
00:35:57,800 --> 00:36:00,500
它在精神上类似于我之前列出的长度为3的列表 
It's similar in spirit to my list of length 3 earlier,

705
00:36:00,500 --> 00:36:02,960
但这有3个整数 0 1 2 
but that had 3 ints, 0, 1, 2.

706
00:36:02,960 --> 00:36:06,020
现在 我有了一个包含三个字符串的列表 
Now I have a list of three strings instead.

707
00:36:06,020 --> 00:36:08,940
而这在目前并不是很有用 
And this isn't very useful at the moment,

708
00:36:08,940 --> 00:36:11,600
但让我做点事作为我自己的支票 
but let me just do something as a check for myself.

709
00:36:11,600 --> 00:36:14,510
让我把这些学生逐一打印出来 
Let me print out each of these students.

710
00:36:14,510 --> 00:36:19,760
嗯 等一下 我怎么打印列表的内容呢？
Well wait a minute, how do I print the contents of a list?

711
00:36:19,760 --> 00:36:22,610
在过去 当我们打印变量时 
Well, in the past, when we've printed a variable,

712
00:36:22,610 --> 00:36:24,900
我们刚刚打印出了变量的名称 
we've just printed out the name of the variable.

713
00:36:24,900 --> 00:36:28,970
但我不想一下子把赫敏、哈利和罗恩都打印出来 
But I don't want to print out all of Hermione and Harry and Ron all at once.

714
00:36:28,970 --> 00:36:33,350
也许我想先打印出赫敏 然后是哈利 然后是罗恩 
Maybe I want to print out Hermione first, then Harry, then Ron.

715
00:36:33,350 --> 00:36:36,050
所以我需要一种更准确的方式来表达
So I need a way to express more precisely which

716
00:36:36,050 --> 00:36:37,790
我想要此列表中的值吗？
value do I want from this list?

717
00:36:37,790 --> 00:36:42,590
在Python中实现这一点的方法是以另一种方式使用方括号 
And the way you do this in Python is you use square brackets in another way.

718
00:36:42,590 --> 00:36:45,890
如果你有一个变量--在这个例子中 叫做学生 
If you have a variable-- in this case, called students,

719
00:36:45,890 --> 00:36:49,850
你想要进入这个变量并获得一个特定值--
and you want to go inside of that variable and get a specific value--

720
00:36:49,850 --> 00:36:52,940
也就是说 您想要索引到列表中 
that is to say, you want to index into the list,

721
00:36:52,940 --> 00:36:57,500
您可以这样使用方括号 在方括号中使用数字 
you use square brackets this way using numbers inside of the square brackets.

722
00:36:57,500 --> 00:37:02,570
这就是我们看到用0来思考和计算的有用之处
And here's where we see that it is useful to think and count in terms of 0

723
00:37:02,570 --> 00:37:04,280
上行而不是1上行 
on up instead of 1 on up.

724
00:37:04,280 --> 00:37:08,120
Python中的这些列表是零索引的 
These lists in Python are, shall we say, zero-indexed.

725
00:37:08,120 --> 00:37:13,700
列表中的第一项位于位置0 Python列表中的第二项位于位置0
The first item in a list is at location 0, the second item in a Python list

726
00:37:13,700 --> 00:37:16,760
第一个是位置1 第三个是位置2 
is that location 1, and the third is that location 2.

727
00:37:16,760 --> 00:37:19,940
所以你在精神上总是差一点 但你会习惯的 
So you're always kind of off by one mentally, but you get used to it,

728
00:37:19,940 --> 00:37:22,275
如果你从来没有编程过 随着时间的推移 
if you've never programmed before, over time.

729
00:37:22,275 --> 00:37:23,900
让我把这三个学生都打印出来 
So let me print out all three students.

730
00:37:23,900 --> 00:37:27,410
让我打印出学生括号0 然后学生括号1 
So let me print out students bracket 0, then students bracket 1.

731
00:37:27,410 --> 00:37:30,290
最后 让我打印学生括号2 
Then lastly, let me print students bracket 2,

732
00:37:30,290 --> 00:37:32,078
这是第三句也是最后一句
and this is my third and final line.

733
00:37:32,078 --> 00:37:35,120
当然 如果我运行这段代码 它可能会做你猜的事情 
And of course, if I run this code, it probably does what you would guess.

734
00:37:35,120 --> 00:37:39,500
如果我运行hogwarts.py的Python 有赫敏、哈利和罗恩
If I run Python of hogwarts.py, there's Hermione, Harry, and Ron

735
00:37:39,500 --> 00:37:41,450
每个人都有自己的路线 
each on their own lines there.

736
00:37:41,450 --> 00:37:43,443
但肯定有更好的办法尤其是
But there's got to be a better way, especially

737
00:37:43,443 --> 00:37:45,860
如果我事先不知道谁会出现在这个名单上
if I don't know in advance who's going to be in this list,

738
00:37:45,860 --> 00:37:48,230
如果明年霍格沃茨有新学生 
if next year there's some new students at Hogwarts,

739
00:37:48,230 --> 00:37:50,930
我们可以用循环来自动地做一些事情
we can use a loop to do something automatically

740
00:37:50,930 --> 00:37:54,590
而不必手动输入0 然后输入1和2 
without having to manually type out 0 and then 1 and 2.

741
00:37:54,590 --> 00:37:57,110
这是Python的另一个特性 
Well, here's another feature of Python.

742
00:37:57,110 --> 00:38:01,310
你可以使用for循环不仅仅是从0到1再到2 
You can use a for loop not just to count from 0 to 1 to 2,

743
00:38:01,310 --> 00:38:03,870
你可以用Python来覆盖任何东西 
you can use Python to just iterate over anything.

744
00:38:03,870 --> 00:38:05,420
不仅仅是数字 还有字符串 
Not just numbers, but strings.

745
00:38:05,420 --> 00:38:07,100
所以我真的可以这么做 
So I could actually do this.

746
00:38:07,100 --> 00:38:13,460
对于学生中的学生 冒号 然后在下面缩进 
For student in students, colon, and then indented underneath that,

747
00:38:13,460 --> 00:38:15,050
我可以说印刷学生 
I can say print student.

748
00:38:15,050 --> 00:38:19,700
不管我有三个学生 四个还是四百个 
Now it doesn't matter if I have 3 students or 4 or 400,

749
00:38:19,700 --> 00:38:23,930
这两行代码 这个循环会为我打印所有这些学生
these two lines of code, this loop will print all of those students for me

750
00:38:23,930 --> 00:38:24,810
一次一个
one at a time.

751
00:38:24,810 --> 00:38:28,490
所以如果我现在运行hogwarts.py的Python 有相同的列表 
So if I now run Python of hogwarts.py, there's the same list,

752
00:38:28,490 --> 00:38:32,420
但我不需要提前知道名单有多长
but I don't need to know in advance how long that actual list is.

753
00:38:32,420 --> 00:38:35,130
注意 我做了一个有意识的决定 
Now notice, I made a conscious decision here.

754
00:38:35,130 --> 00:38:39,680
我没有把这个变量叫做下划线 因为这次我
I didn't call this variable underscore, because this time I'm

755
00:38:39,680 --> 00:38:40,970
使用变量 
using the variable.

756
00:38:40,970 --> 00:38:44,210
虽然我能做到这一点 现在 不 
And while I could do this, now, no, no, no, no,

757
00:38:44,210 --> 00:38:46,130
你的代码太晦涩了
your code is getting way too cryptic.

758
00:38:46,130 --> 00:38:48,860
如果你给变量命名为下划线 
If you're naming the variable underscore and you're

759
00:38:48,860 --> 00:38:51,530
使用变量underscore 现在你帮不了任何人 
using the variable underscore, now you're helping no one.

760
00:38:51,530 --> 00:38:54,890
现在你把读者搞糊涂了 你自己也搞糊涂了 
Now you're confusing the reader, yourself down the line,

761
00:38:54,890 --> 00:38:57,370
您应该按变量的原样来命名它们 
you should call your variables what they are.

762
00:38:57,370 --> 00:39:00,470
所以这是一个非常合适的名字 虽然我相信你可以想出其他名字 
So a very appropriate name, though I'm sure you could come up with others,

763
00:39:00,470 --> 00:39:04,430
会是学生 而在这里 你可以说你也会继续当学生 
would be student, and here, you could say you would stay student as well.

764
00:39:04,430 --> 00:39:06,710
如果你想说得更简洁些 那就是
If you'd prefer to be more succinct, it's

765
00:39:06,710 --> 00:39:09,380
在这样的循环中做一些简洁的事情并不是不合理的 
not unreasonable to do something succinct in a loop like this.

766
00:39:09,380 --> 00:39:13,430
对于S来说 在学生名单中 使用的字母可能与
For s in students, using maybe the same letter that the list

767
00:39:13,430 --> 00:39:15,740
它本身就是这样开始的 但再说一次 为什么要费心呢？
itself begins with, but again, why bother?

768
00:39:15,740 --> 00:39:17,510
Python应该更具可读性 
Python is meant to be more readable.

769
00:39:17,510 --> 00:39:22,530
如果您有学生列表 请一次迭代一个学生 
If you have a list of students, iterate over them one student at a time.

770
00:39:22,530 --> 00:39:25,490
让我在这里暂停一下 看看现在是否有关于名单的问题
Let me pause here to see if there's now questions about lists

771
00:39:25,490 --> 00:39:28,220
正如我现在定义的那样 在本例中是字符串列表 
as I've now defined them, a list of strings in this case,

772
00:39:28,220 --> 00:39:33,860
或者现在使用for循环迭代并打印每个名称 
or using a for loop now to iterate over and print each of those names.

773
00:39:33,860 --> 00:39:34,550
观众：是的 
AUDIENCE: Yeah.

774
00:39:34,550 --> 00:39:38,150
那么 在这种情况下 没有必要启动学生吗？
So is it not necessary to initiate student in this case?

775
00:39:38,150 --> 00:39:40,575
或者我们可以只在循环中声明一个变量？
Or we can just declare a variable in the loop?

776
00:39:40,575 --> 00:39:41,700
大卫·马兰：问得好 
DAVID MALAN: Good question.

777
00:39:41,700 --> 00:39:43,450
您无需手动对其进行初始化 
You do not need to manually initialize it.

778
00:39:43,450 --> 00:39:47,810
Python负责将Student变量初始化为Hermione
Python takes care of initializing the student variable to Hermione

779
00:39:47,810 --> 00:39:49,960
第一 然后是哈利 然后是罗恩 第三 
first, then Harry second, then Ron third.

780
00:39:49,960 --> 00:39:53,210
与其他语言不同 您不需要自己将其初始化为某个东西 
Unlike other languages, you don't need to initialize it to something yourself,

781
00:39:53,210 --> 00:39:55,250
它只是存在 而且会奏效的 
it just exists and it will work.

782
00:39:55,250 --> 00:39:58,662
其他关于循环和列表的问题是这样的吗？
Other questions on loops and lists in this way?

783
00:39:58,662 --> 00:40:00,620
观众：既然你描述了Break 那么有没有
AUDIENCE: Since you describe break, so is there

784
00:40:00,620 --> 00:40:04,232
有没有继续的概念 这样我们就可以在循环中跳过特定的情况？
any concept of continuing so that we can skip a particular case in loops?

785
00:40:04,232 --> 00:40:04,940
大卫·马兰：是的 
DAVID MALAN: Yes.

786
00:40:04,940 --> 00:40:06,933
您也可以继续使用其他语法 
You can continue using another syntax as well.

787
00:40:06,933 --> 00:40:07,850
我们还没有证明这一点 
We haven't shown that.

788
00:40:07,850 --> 00:40:10,668
目前 我们只关注休息时间 
For now we focused only on break.

789
00:40:10,668 --> 00:40:11,210
观众：好的 
AUDIENCE: OK.

790
00:40:11,210 --> 00:40:15,770
那么这个for循环可以与哈希表或其他类型的循环一起工作吗
So can this for loop work with either hash tables or different kind

791
00:40:15,770 --> 00:40:17,607
是表还是数组？
of tables or arrays?

792
00:40:17,607 --> 00:40:18,440
大卫·马兰：确实如此 
DAVID MALAN: Indeed.

793
00:40:18,440 --> 00:40:20,190
所以我们在这一点上超前了 
So we're getting ahead of ourselves there,

794
00:40:20,190 --> 00:40:22,610
但在Python中还有其他类型的数据 
but there are yet other types of data in Python,

795
00:40:22,610 --> 00:40:26,550
实际上 您也可以使用for循环来迭代这些代码 
and indeed, you can use a for loop to iterate over those as well.

796
00:40:26,550 --> 00:40:28,940
可以说 任何可迭代的东西都是
Anything that is iterable, so to speak, is

797
00:40:28,940 --> 00:40:32,030
可以与这样的循环一起使用的数据片段 
a piece of data that can be used with a loop like this.

798
00:40:32,030 --> 00:40:34,290
但更多关于这些的--很快就会有更多的关于这些的 
But more on those-- more on those soon.

799
00:40:34,290 --> 00:40:37,967
事实上 让我过渡到这里来展示另一种解决方案
In fact, let me transition here to show just another way of solving

800
00:40:37,967 --> 00:40:40,550
同样的问题 因为到目前为止 当我们使用循环时 
this same problem, because up until now when we've used loops,

801
00:40:40,550 --> 00:40:43,040
我们真的依赖于数字 这很好
we really have relied on numbers, and that's fine

802
00:40:43,040 --> 00:40:45,620
如果你更喜欢呆在那个地方的话 
if you prefer to stay in that space.

803
00:40:45,620 --> 00:40:49,610
假设我确实想使用像I和0这样的数字进行迭代 
Suppose I did want to iterate using numbers like i and 0,

804
00:40:49,610 --> 00:40:50,910
1、2等等 
1, 2, and so forth.

805
00:40:50,910 --> 00:40:53,700
让我建议我们可以按如下方式更改此代码 
Let me propose that we could change this code as follows.

806
00:40:53,700 --> 00:40:56,930
如果您更愿意考虑 或者如果您正在进行的项目
If you would prefer to think about, or if the program you're

807
00:40:56,930 --> 00:40:59,810
尝试实施需要使用这样的数字 
trying to implement requires that you use numbers like this,

808
00:40:59,810 --> 00:41:00,830
你可能会这么做 
you might do this.

809
00:41:00,830 --> 00:41:04,820
对于我来说--嗯 我不想只说学生 
For i in-- well, I don't want to just say students,

810
00:41:04,820 --> 00:41:07,580
因为那样我就不再是一个数字了 
because then i is not going to be a number.

811
00:41:07,580 --> 00:41:13,010
我将成为赫敏 然后是哈利 然后是罗恩 
i is going to be literally Hermione, then Harry, then Ron.

812
00:41:13,010 --> 00:41:17,030
我需要从0到1再到2迭代 
I need to iterate from 0 to 1 to 2.

813
00:41:17,030 --> 00:41:21,320
如果具有三个元素的列表具有这些位置 0 1 2 
If I a list with three elements has these locations, 0, 1, 2,

814
00:41:21,320 --> 00:41:25,400
我需要以某种方式创建一个从0开始到2结束的循环 
I need to create a loop somehow that starts at 0 and ends at 2.

815
00:41:25,400 --> 00:41:28,340
以前 当我想这么做的时候 我需要射程 
Previously when I wanted to do that, I needed range,

816
00:41:28,340 --> 00:41:30,290
但这两项计划行不通 
but this 2 is not going to work.

817
00:41:30,290 --> 00:41:32,750
我不能只说在学生的范围内 
I can't just say in the range of students,

818
00:41:32,750 --> 00:41:36,030
因为学生不是数字 也不是整数 
because students is not a number, it's not an integer,

819
00:41:36,030 --> 00:41:37,640
所以你不能把球传给射程 
so you can't pass it to range.

820
00:41:37,640 --> 00:41:39,260
Range需要一个整数 
Range expects an integer.

821
00:41:39,260 --> 00:41:41,840
但这里有一个解决方案 
But there is a solution here.

822
00:41:41,840 --> 00:41:47,390
原来在Python语言中有一个名为LENGTH或LEN的函数 L-E-N 
It turns out that there is a function in Python called length or len, L-E-N,

823
00:41:47,390 --> 00:41:51,890
这会告诉你清单的长度 以及以后的其他事情 
that will tell you the length of a list and other things down the line, too.

824
00:41:51,890 --> 00:41:55,850
现在我想我可以组装这些积木 并以一种方式
And now I think I can assemble these building blocks and a way that can

825
00:41:55,850 --> 00:41:57,740
请允许我以这种方式使用数字 
allow me to use numbers in this way.

826
00:41:57,740 --> 00:42:02,870
所以Range不需要字符串列表 它需要一个数字 
So range doesn't take a list of strings, it takes a number,

827
00:42:02,870 --> 00:42:04,790
理想情况下 这个数字应该是3 
and ideally, that number is going to be 3,

828
00:42:04,790 --> 00:42:07,580
所以我得到了一个值的范围 0、1和2 
so I get a range of values, 0, 1, and 2.

829
00:42:07,580 --> 00:42:10,640
所以我想我可以像这样嵌套我的函数 
So I think I can nest my functions like this.

830
00:42:10,640 --> 00:42:15,410
如果我首先得到学生名单的长度 那将是3 
If I first get the length of the students list, that's going to be 3,

831
00:42:15,410 --> 00:42:18,620
然后 我将返回值作为参数传递
then I pass that return value as the argument

832
00:42:18,620 --> 00:42:23,840
对于Range 这将返回一个值的范围 0 然后1 然后是2 
to range, that's going to give me back a range of values, 0, then 1, then 2.

833
00:42:23,840 --> 00:42:26,570
如果我想的话 这将允许我用代码来做什么
And what that's going to allow me to do then in code if I want

834
00:42:26,570 --> 00:42:28,310
不仅仅是这样 
is not just this.

835
00:42:28,310 --> 00:42:33,650
我现在可以打印出来了 学生们 这是现在
I could do print now students bracket i, and this is now

836
00:42:33,650 --> 00:42:38,270
我们看到的语法正在变得非常有表现力--新的 也许
where the syntax we're seeing is getting very expressive-- new and perhaps

837
00:42:38,270 --> 00:42:39,200
不熟悉 
unfamiliar.

838
00:42:39,200 --> 00:42:44,090
但如果我能做左方括号 0 左方括号 或左方括号 
But if I can do open bracket, 0, close bracket, or open bracket, 1,

839
00:42:44,090 --> 00:42:47,990
左方括号 或左方括号 2 右方括号 结果是 
close bracket, or open bracket, 2, close bracket, turns out,

840
00:42:47,990 --> 00:42:49,940
我实际上可以在里面放一个变量 然后我
I can actually put a variable in there and I

841
00:42:49,940 --> 00:42:52,490
可以表示括号内的任何数字
can express any number inside of those brackets

842
00:42:52,490 --> 00:42:54,800
以便在循环中动态地打印出所有这些 
so as to print these all out dynamically in a loop.

843
00:42:54,800 --> 00:42:57,680
让我来做这件事 巨蟒of hogwarts.py 回车 
Let me do this, Python of hogwarts.py, Enter,

844
00:42:57,680 --> 00:43:00,140
这是赫敏、哈里和罗恩 
there's Hermione, Harry, and Ron.

845
00:43:00,140 --> 00:43:02,570
现在 如果我只是好奇 我只想戳
And now if I'm just curious, I just want to poke

846
00:43:02,570 --> 00:43:05,060
或许我想做个排名 比如谁
around or maybe I want to do a ranking, like who

847
00:43:05,060 --> 00:43:08,240
排名前三的学生是在学校还是在格兰芬多？
are the top three students in the school or in Gryffindor?

848
00:43:08,240 --> 00:43:11,000
嗯 我们已经看到 我可以一次打印多个东西 
Well, I can print multiple things at a time, we've seen.

849
00:43:11,000 --> 00:43:14,540
让我打印出来的不仅仅是现场的学生
Let me print out not just the students at location

850
00:43:14,540 --> 00:43:19,340
而是让我们先打印I 然后打印位置I的学生 
i, but rather, let's print i first and then the student at location i.

851
00:43:19,340 --> 00:43:22,850
所以要打印两件事 我们知道打印可以有两个论点 
So two things to print, and we know that print can take two arguments,

852
00:43:22,850 --> 00:43:25,280
我们以前见过 它们会被一个空格隔开 
we've seen that before, they'll be separated by a space.

853
00:43:25,280 --> 00:43:26,900
让我继续并重新运行这个 
Let me go ahead and rerun this.

854
00:43:26,900 --> 00:43:31,533
现在我明白了 好吧 赫敏是最好的学生 但她是第零名 
Now I see that, OK, Hermione is the top student, but she's in zeroth place.

855
00:43:31,533 --> 00:43:32,450
这有点奇怪 
That's a little weird.

856
00:43:32,450 --> 00:43:35,930
就像我们不需要向使用我的程序的人展示
Like we don't need to show the human using my program

857
00:43:35,930 --> 00:43:37,430
我们从0开始数 
that we started counting at 0.

858
00:43:37,430 --> 00:43:38,570
我可以把这里清理干净 
I can clean this up.

859
00:43:38,570 --> 00:43:41,600
我可以在这里的i上加1 现在我们
I can just add 1 to the i up here, and now we

860
00:43:41,600 --> 00:43:43,640
查看排名前三的学生名单 
see a top three list of students.

861
00:43:43,640 --> 00:43:47,540
赫敏是第一名 哈利是第二名 当然 罗恩是第三名 
Hermione is number 1, Harry's number 2, and of course, Ron is number 3.

862
00:43:47,540 --> 00:43:50,960
因此 我们也可以访问所有这些相同的值 
So we can get access to all of those same values as well.

863
00:43:50,960 --> 00:43:55,320
这些清单上现在还有什么问题吗？
Are there any questions now on these lists?

864
00:43:55,320 --> 00:43:58,320
这些清单上现在有什么问题吗？
Any questions now on these lists?

865
00:43:58,320 --> 00:44:01,050
这个长度 这个范围 还是其他？
This length, these ranges, or otherwise?

866
00:44:01,050 --> 00:44:08,350
观众：我的问题是 对于我在射程内 你能再解释一次吗？
AUDIENCE: My question is, for i in range, can you explain this once more?

867
00:44:08,350 --> 00:44:10,210
大卫·马兰：当然 
DAVID MALAN: Sure.

868
00:44:10,210 --> 00:44:12,640
所以 让我及时回顾一下 
So let me rewind in time.

869
00:44:12,640 --> 00:44:13,960
我们一开始就这么做 
We started off doing this.

870
00:44:13,960 --> 00:44:20,770
I in 0 1 2 然后我们用这种方式打印三次 
For i in 0, 1, 2, and then we print it out meow three times in that way.

871
00:44:20,770 --> 00:44:23,830
For循环的工作方式是它创建
The way that for loop works is that it creates

872
00:44:23,830 --> 00:44:27,730
一个变量 我把它叫做i 但我想叫它什么都行 
for you a variable that I've called i, but I could call it anything I want.

873
00:44:27,730 --> 00:44:31,390
然后 它将i初始赋值给列表中的第一个项 
It then assigns i initially to the first thing in the list.

874
00:44:31,390 --> 00:44:34,690
然后 它会自动将i赋给列表中的下一项 
It then automatically assigns i to the next thing in the list.

875
00:44:34,690 --> 00:44:37,210
然后它将i赋给列表中的第三个项目 
And then it assigns i to the third thing in the list.

876
00:44:37,210 --> 00:44:41,520
每次它都会执行下面的所有缩进代码 
And each time it does all of the indented code underneath.

877
00:44:41,520 --> 00:44:43,740
然而 我们意识到 这是不可能的
We realize, though, that this is not going

878
00:44:43,740 --> 00:44:46,380
如果我想做一百万次这样的事情 要有很好的伸缩性 
to scale well if I want to do something like a million times.

879
00:44:46,380 --> 00:44:48,480
因此 我们引入了Range 
So we introduced range instead.

880
00:44:48,480 --> 00:44:51,240
这产生了做同样事情的效果 
That has the effect of doing the same thing.

881
00:44:51,240 --> 00:44:55,080
它给我返回了一系列的值--实际上是三件事的清单 
It returns to me a range of values-- a list of three things, really,

882
00:44:55,080 --> 00:44:57,330
所以行为是完全一样的 
so the behavior is exactly the same.

883
00:44:57,330 --> 00:45:01,890
如果我们现在快进到霍格沃茨的例子 我正在做的是
If we now fast forward to this Hogwarts example now, though, what I'm doing

884
00:45:01,890 --> 00:45:04,500
就是把这些小点子结合起来 
is just combining these smaller ideas.

885
00:45:04,500 --> 00:45:06,330
我仍在创建一个for循环 
I'm still creating a for loop.

886
00:45:06,330 --> 00:45:08,520
我还在创建一个名为i的变量 
I'm still creating a variable called i.

887
00:45:08,520 --> 00:45:11,760
我想通过一系列的值来做这件事 但是有多少值呢？
I want to do it over a range of values, but how many values?

888
00:45:11,760 --> 00:45:15,390
如果我使用LENGTH函数并传递给LENGTH函数
Well, if I use the length function and pass to the length function

889
00:45:15,390 --> 00:45:18,300
价值清单 长度的人生目标
the list of values, length's purpose in life

890
00:45:18,300 --> 00:45:21,120
就是告诉我这张单子有多长 是3张 
is to tell me how long is this list, and it's 3.

891
00:45:21,120 --> 00:45:25,740
所以这几乎就像以前 我刚刚做了这样的事情 
So that's almost as though before, I had just done something like this,

892
00:45:25,740 --> 00:45:29,220
但我不想硬编码3 我想动态地计算出
but I don't want to hardcode 3, I want to dynamically figure out

893
00:45:29,220 --> 00:45:30,870
霍格沃茨有多少学生 
how many students are at Hogwarts.

894
00:45:30,870 --> 00:45:32,910
所以我只是作曲 
So I'm just composing, composing, composing,

895
00:45:32,910 --> 00:45:36,210
或者嵌套所有这些不同的想法 
or nesting all of these various ideas.

896
00:45:36,210 --> 00:45:38,880
好的 如果可以的话 现在让我过渡到--
All right, if I may, let me transition now to--

897
00:45:38,880 --> 00:45:42,540
在霍格沃茨仍然引入了之前的最后一种数据类型
in Hogwarts still to introduce one final type of data before

898
00:45:42,540 --> 00:45:45,690
我们把所有的东西和几个最终的节目结合在一起 
we combine everything with a few final programs.

899
00:45:45,690 --> 00:45:49,410
事实证明 在Python中 不仅仅是字符串 而不仅仅是
It turns out in Python, there's not just strings, not just

900
00:45:49,410 --> 00:45:51,600
整数 而不仅仅是浮点值 而不是
ints, not just floating point values, not

901
00:45:51,600 --> 00:45:53,790
只是无稽之谈 不只是列表 还有
just bools, not just lists there are also

902
00:45:53,790 --> 00:45:58,560
所谓的词典或词典是一种数据结构 它允许您
what are called dictionaries or dics, are a data structure that allows you

903
00:45:58,560 --> 00:46:02,250
将一个值与另一个值相关联 
to associate one value with another.

904
00:46:02,250 --> 00:46:04,380
字面意思是一本像人类世界一样的词典 
Literally a dictionary like in the human world.

905
00:46:04,380 --> 00:46:07,680
如果你打开一本词典 无论是英语还是其他人类语言 
If you were to open a dictionary, be it in English or any other human language,

906
00:46:07,680 --> 00:46:09,190
词典里有什么？
what's inside of a dictionary?

907
00:46:09,190 --> 00:46:12,480
嗯 它是一堆单词和定义 
Well, it's a bunch of words and definitions.

908
00:46:12,480 --> 00:46:14,760
不过 他是一名计算机科学家和一名程序员
A computer scientist, though, and a programmer

909
00:46:14,760 --> 00:46:19,470
会更笼统地将这些描述为键和值
would describe those more generically as keys and values, something

910
00:46:19,470 --> 00:46:21,360
与其他事物联系在一起 
associated with something else.

911
00:46:21,360 --> 00:46:22,950
词典就是这么回事 
That's all a dictionary is.

912
00:46:22,950 --> 00:46:25,930
它允许你将某物与另一物联系在一起 
It allows you to associate something with something else.

913
00:46:25,930 --> 00:46:29,160
注意 这已经比列表更强大、更有趣了 
And notice, this is already more powerful, more interesting than a list.

914
00:46:29,160 --> 00:46:32,670
列表只是由多个值组成的集合 
A list is just a set of multiple values.

915
00:46:32,670 --> 00:46:36,240
但如果你愿意的话 字典是二维的 
But a dictionary is two-dimensional, if you will.

916
00:46:36,240 --> 00:46:39,390
就像一本人类词典 一本书 它让人联想到一些东西
Just like a human dictionary, a book, it associates something

917
00:46:39,390 --> 00:46:42,210
用一些其他的东西 比如单词和它们的定义 
with something else like words with their definitions.

918
00:46:42,210 --> 00:46:44,500
那么 这实际上意味着什么呢？
Now what does this actually mean in practice?

919
00:46:44,500 --> 00:46:48,390
假设我们想要跟踪
Well suppose that we wanted to keep track

920
00:46:48,390 --> 00:46:51,810
谁在霍格沃茨的哪栋房子里 
of who is in what house at Hogwarts.

921
00:46:51,810 --> 00:46:54,240
嗯 我可以单用清单就能做到 
Well, I could do it using lists alone.

922
00:46:54,240 --> 00:46:55,950
让我回到这里的VS代码 让我
Let me go back to VS Code here and let me

923
00:46:55,950 --> 00:46:59,470
只是暂时的--但我最终不会喜欢的--
just temporarily-- but in a way that I'm not going to like ultimately--

924
00:46:59,470 --> 00:47:01,620
让我创建另一个名为house的变量 
let me create another variable called houses,

925
00:47:01,620 --> 00:47:06,750
把它设为格兰芬多 相当于赫敏的房子 
set it equal to Gryffindor, corresponding to Hermione's house,

926
00:47:06,750 --> 00:47:09,960
格兰芬多 对应于哈利的房子 格兰芬多 
Gryffindor, corresponding to Harry's house, and Gryffindor,

927
00:47:09,960 --> 00:47:11,250
与罗恩的房子相对应 
corresponding to Ron's house.

928
00:47:11,250 --> 00:47:12,730
让我们把德拉科也加进去 
And let's add Draco in there.

929
00:47:12,730 --> 00:47:14,640
所以我们现在有四个学生而不是三个
So we now have four instead of three students

930
00:47:14,640 --> 00:47:18,810
只是为了让我们有一点变化 他在斯莱特林 
just so we have a little variety, and he was in Slytherin.

931
00:47:18,810 --> 00:47:21,300
所以现在我们有两个名单 
So now we have two lists.

932
00:47:21,300 --> 00:47:24,750
我们可以在我们之间达成一致
And we could just agree amongst ourselves

933
00:47:24,750 --> 00:47:28,680
谁是第一名 谁就改变了人生
that whoever is first in the students variable lives

934
00:47:28,680 --> 00:47:31,410
在房子的第一个价值中 
in the first value in houses.

935
00:47:31,410 --> 00:47:34,770
学生中排名第二的人住在第二所房子里 
Whoever is second in students lives in the second house.

936
00:47:34,770 --> 00:47:37,680
学生中排名第三的人住在第三栋房子里 
Who's ever third in students lives in the third house.

937
00:47:37,680 --> 00:47:38,730
我们可以这么做 
We could do that.

938
00:47:38,730 --> 00:47:41,430
但老实说 这将很快瓦解
But honestly, that is going to break down quickly

939
00:47:41,430 --> 00:47:44,102
当我们有很多学生时 当我们有很多房子时 
when we have a lot of students, when we have a lot of houses,

940
00:47:44,102 --> 00:47:46,560
如果我们想要跟踪更多的东西呢？
and what if we want to keep track of more things than that?

941
00:47:46,560 --> 00:47:48,810
如果我们想要跟踪每个学生的家呢
What if we want to keep track of every student's house

942
00:47:48,810 --> 00:47:52,890
而守护神 这个他们魔术般的形象呢？
and the patronus, this image that they conjure up magically?

943
00:47:52,890 --> 00:47:55,290
那么 我们需要第三份清单 就像--这只是
Well, then we need a third list like-- this is just

944
00:47:55,290 --> 00:47:58,440
如果我们只是在荣誉系统上 很快就会变得一团糟
going to get messy quickly if we're just on the honor system

945
00:47:58,440 --> 00:48:02,640
使用多个列表 其中所有内容都在逻辑上排成一行 
using multiple lists where everything lines up logically.

946
00:48:02,640 --> 00:48:05,940
当您的代码变得更复杂时 结果不会很好 
It doesn't end up well when your code gets more complicated.

947
00:48:05,940 --> 00:48:07,740
但我确实想要实施这个想法 
But I do want to implement this idea.

948
00:48:07,740 --> 00:48:09,990
我想把某事与某事联系起来 
I want to associate something with something.

949
00:48:09,990 --> 00:48:12,960
有房子的学生 有房子的学生 有房子的学生
A student with a house, a student with a house, a student with a house

950
00:48:12,960 --> 00:48:15,970
以此类推 那么我该如何着手做这些呢？
and so forth, so how can I go about doing this?

951
00:48:15,970 --> 00:48:18,570
好的 让我回到我的代码 让
Well, let me go back to my code here and let

952
00:48:18,570 --> 00:48:22,410
我建议我们使用一本Python词典来完成这项工作 
me propose that we do this using a Python dictionary.

953
00:48:22,410 --> 00:48:25,560
这是我们将要看到的最后一种新语法 
And this is the last of the new syntax, really, that we'll see .

954
00:48:25,560 --> 00:48:26,880
下面是新的语法 
Here's the new syntax.

955
00:48:26,880 --> 00:48:29,280
我们不使用方括号 而是
Instead of using square brackets, we're going

956
00:48:29,280 --> 00:48:32,500
在词典中也使用花括号 
to use curly braces for dictionaries as well.

957
00:48:32,500 --> 00:48:37,050
我们已经在f字符串的上下文中看到了完全无关的花括号 
We've seen curly braces in the context of f strings completely unrelated.

958
00:48:37,050 --> 00:48:40,360
有时你会用完键盘上的键和语言的作者
Sometimes you run out of keys on the keyboard and the authors of a language

959
00:48:40,360 --> 00:48:43,302
需要开始以不同的方式重新使用符号 这是
need to start reusing symbols in different ways, that's

960
00:48:43,302 --> 00:48:44,260
即将发生的事情 
what's about to happen.

961
00:48:44,260 --> 00:48:46,150
我们正在以不同的方式使用花括号 
We're using curly braces in a different way.

962
00:48:46,150 --> 00:48:48,690
现在 让我创建一个名为Students的变量 
Now so let me create a variable called students.

963
00:48:48,690 --> 00:48:51,960
让我继续并将其设置为等于打开
And let me go ahead and set it equal to open

964
00:48:51,960 --> 00:48:54,030
花括号和闭合花括号 
curly brace and closed curly brace.

965
00:48:54,030 --> 00:48:56,670
这本词典目前是一本空词典 
This is an empty dictionary at the moment.

966
00:48:56,670 --> 00:48:58,590
以下是词典的工作原理 
And here's how a dictionary works.

967
00:48:58,590 --> 00:49:01,150
它允许你将一些东西与其他东西联系在一起 
It allows you to associate something with something else,

968
00:49:01,150 --> 00:49:02,400
然后你像这样做 
and you do that like this.

969
00:49:02,400 --> 00:49:07,777
赫敏 引号-不引号 冒号 然后是它的值 
Hermione, quote-unquote, colon, and then the value thereof.

970
00:49:07,777 --> 00:49:09,610
你想把赫敏和什么联系在一起？
What do you want to associate with Hermione?

971
00:49:09,610 --> 00:49:11,280
嗯 格兰芬多 
Well, Gryffindor.

972
00:49:11,280 --> 00:49:13,680
我想把哈利和什么联系在一起？
What do I want to associate Harry with?

973
00:49:13,680 --> 00:49:16,560
我想把他和格兰芬多联系起来 
Well, I want to associate him with Gryffindor.

974
00:49:16,560 --> 00:49:18,630
我想把罗恩和什么联系在一起？
What do I want to associate Ron with?

975
00:49:18,630 --> 00:49:21,240
我想把他和格兰芬多联系起来 
Well, I want to associate him with Gryffindor.

976
00:49:21,240 --> 00:49:24,600
嗯 这实际上不会--这会很快变得非常丑陋 
Well, this is actually not going to-- this is going to get very ugly quickly.

977
00:49:24,600 --> 00:49:27,502
一旦我们加上德拉科和斯莱特林 我的代码就会变得太长 
Once we add in Draco and Slytherin, my code is going to get too long,

978
00:49:27,502 --> 00:49:28,710
它要开始包装了 
it's going to start wrapping.

979
00:49:28,710 --> 00:49:30,390
所以这纯粹是审美上的 
So this is purely aesthetic.

980
00:49:30,390 --> 00:49:33,450
它在Python和其他语言中是完全可以接受的
It is perfectly acceptable in Python and other languages

981
00:49:33,450 --> 00:49:36,570
为了更容易地格式化代码 只需添加新行
to format your code a little more readily and just add new lines

982
00:49:36,570 --> 00:49:38,040
如果它让它更具可读性的话 
if it makes it more readable.

983
00:49:38,040 --> 00:49:40,480
而这样做的一种方法可能如下所示 
And one way of doing this might be as follows.

984
00:49:40,480 --> 00:49:44,920
我的花托还在这 我的花托还在下面 
I still have my curly brace up here, I still have my curly brace down here,

985
00:49:44,920 --> 00:49:47,400
但请注意 它现在的可读性更好了
but notice, it's a little more readable now

986
00:49:47,400 --> 00:49:51,743
因为我的钥匙在左边 我的东西 我的价值观
in that I have my keys on the left, my somethings, and my values

987
00:49:51,743 --> 00:49:53,160
在右边 是我的其他东西 
on the right, my other somethings.

988
00:49:53,160 --> 00:49:55,800
只是从上到下略读起来更容易一些 
It's just a little easier to skim top to bottom.

989
00:49:55,800 --> 00:49:57,480
您也可以设置不同的格式 
You could format it differently as well.

990
00:49:57,480 --> 00:50:00,690
但我现在要说的是 德拉科
But I'm going to go ahead and add in now Draco

991
00:50:00,690 --> 00:50:03,210
当然 他住在斯莱特林 
who lives, of course, in Slytherin.

992
00:50:03,210 --> 00:50:07,320
现在我把每一把钥匙都放在左边
So now I have each of these keys on the left

993
00:50:07,320 --> 00:50:09,910
和右边的价值观 这真的 再一次 
and values on the right, which is really, again,

994
00:50:09,910 --> 00:50:13,200
这只是这个想法的一个代码实现 一个小图表
just a code implementation of this idea, a little chart

995
00:50:13,200 --> 00:50:15,300
你可以用纸铅笔写出来
that you might write up with paper pencil

996
00:50:15,300 --> 00:50:17,620
当把某物与另一物联系在一起时 
when associating something with something else.

997
00:50:17,620 --> 00:50:20,680
那么 我现在如何以一种有趣的方式使用这段代码呢？
So how do I now use this code in an interesting way?

998
00:50:20,680 --> 00:50:22,230
语法几乎是相同的 
The syntax is almost the same.

999
00:50:22,230 --> 00:50:26,160
如果我想打印出第一个学生 赫敏的家 
If I want to print out the very first student, Hermione's house,

1000
00:50:26,160 --> 00:50:27,150
我能做到的 
I could do this.

1001
00:50:27,150 --> 00:50:31,960
打印出变量的名称 但我需要进入变量内部 
Print out the name of the variable, but I need to go inside of the variable.

1002
00:50:31,960 --> 00:50:33,810
我需要把它编入索引 
I need to index into it.

1003
00:50:33,810 --> 00:50:38,280
字典的巧妙之处在于 尽管列表
And what's neat about dictionaries is that whereas lists

1004
00:50:38,280 --> 00:50:41,010
有数字形式的地点--
have locations that are numeric--

1005
00:50:41,010 --> 00:50:45,270
0 1 2；赫敏 哈利 罗恩 
0, 1, 2; Hermione, Harry, Ron respectively,

1006
00:50:45,270 --> 00:50:50,520
可以说 词典允许你使用实际的单词作为你的索引 
dictionaries allow you to use actual words as your indices, so to speak,

1007
00:50:50,520 --> 00:50:52,750
您的索引以深入了解它们 
your indexes to get inside of them.

1008
00:50:52,750 --> 00:50:55,740
所以如果你想打印出赫敏的房子 
So if you want to print out Hermione's house,

1009
00:50:55,740 --> 00:50:59,160
你关心的关键是 引用-引用 赫敏 
the key you care about is, quote-unquote, Hermione,

1010
00:50:59,160 --> 00:51:04,050
这里的语法要做的是--注意 它不是数字0、1或2 
and what this syntax here will do-- notice, it's not a number 0 or 1 or 2.

1011
00:51:04,050 --> 00:51:05,970
这真的是赫敏的名字 
It's literally Hermione's name.

1012
00:51:05,970 --> 00:51:11,070
这就像早先去看图表 然后说 好吧 把赫敏给我
This is like going to the chart earlier and saying, all right, give me Hermione

1013
00:51:11,070 --> 00:51:13,628
是我的钥匙 格兰芬多是价值 
is my key, Gryffindor is the value.

1014
00:51:13,628 --> 00:51:15,420
这就是我们在这里从语法上所做的 
That's what we're doing here syntactically.

1015
00:51:15,420 --> 00:51:18,300
我们正在寻找赫敏 并得到它的价值 
We're looking up Hermione and getting the value thereof.

1016
00:51:18,300 --> 00:51:21,120
所以 如果我回到我的代码 它应该会打印出格兰芬多 
So if I go back to my code, that should print out Gryffindor.

1017
00:51:21,120 --> 00:51:24,330
如果我这样做几次 学生们 括号 引号-引号 
And if I do this a few times, students, bracket, quote-unquote,

1018
00:51:24,330 --> 00:51:26,280
哈利应该把哈利的房子给我 
Harry should give me Harry's house.

1019
00:51:26,280 --> 00:51:30,630
打印学生 打开括号 罗恩 这应该会给我罗恩的房子 
Print students, open bracket, Ron, that should give me Ron's house.

1020
00:51:30,630 --> 00:51:33,660
最后 如果我对学生们这样做 Branket Draco
And then lastly, if I do this with students, bracket, Draco,

1021
00:51:33,660 --> 00:51:35,727
这应该会给我德拉科的房子 
that should give me Draco's house.

1022
00:51:35,727 --> 00:51:38,310
现在它仍然是一个小手册 我打赌我们可以改进这个 
Now it's a little manual still, and I bet we can improve this,

1023
00:51:38,310 --> 00:51:40,620
但是让我在hogwarts.py上运行Python 我们
but let me run Python on hogwarts.py and we

1024
00:51:40,620 --> 00:51:44,790
应该去看看格兰芬多 斯莱特林 
should see Gryffindor, Gryffindor, Gryffindor, Slytherin, which

1025
00:51:44,790 --> 00:51:46,500
这正是我们所期待的 
is exactly what we'd expect.

1026
00:51:46,500 --> 00:51:48,810
现在我们所做的一切 再一次 是我们刚刚搬到
Now all we've done, again, is we've just now moved

1027
00:51:48,810 --> 00:51:52,710
从只有一个简单的名字列表到再一次 两个维度 
from having just a simple list of names to, again, two dimensions,

1028
00:51:52,710 --> 00:51:56,070
像我们在纸上那样联想--用铅笔写东西和东西
associating like we would on paper-pencil something with something

1029
00:51:56,070 --> 00:51:58,920
否则 分别为带有值的键 
else, keys with values respectively.

1030
00:51:58,920 --> 00:52:02,580
如果你愿意 请允许我 尽管我知道这有点花哨 
Allow me, if you will, even though I realize this is getting a little fancy,

1031
00:52:02,580 --> 00:52:07,200
请允许我在这里稍微升级一下 并从查看
allow me to escalate things slightly here and transition from looking

1032
00:52:07,200 --> 00:52:13,020
例如 在那里的模式中 只是对这些值进行硬编码
at just, for instance, that pattern there, just a hard coding those values

1033
00:52:13,020 --> 00:52:15,660
实际上 要更动态地打印这些内容 
there to actually printing these out more dynamically.

1034
00:52:15,660 --> 00:52:19,510
让我继续使用我们的循环 这个问题也出现在前面 
Let me go ahead and use our loop, and this question came up earlier as well,

1035
00:52:19,510 --> 00:52:25,450
让我继续说 对于学生中的每个学生 
let me go ahead and say for each student in students,

1036
00:52:25,450 --> 00:52:31,240
继续打印出来 例如 学生们在--
go ahead and print out, for instance, the students variable at--

1037
00:52:31,240 --> 00:52:32,920
好吧 让我们先说学生优先 
well, let's just say student first.

1038
00:52:32,920 --> 00:52:33,950
让我们简单点吧 
Let's keep it simple.

1039
00:52:33,950 --> 00:52:35,950
所以这还不会那么有趣 
So this is not going to be that interesting yet,

1040
00:52:35,950 --> 00:52:41,470
但是 当我运行hogwarts.py的Python并按Enter时 请注意 我应该看到什么？
but when I run Python of hogwarts.py and hit Enter, notice, what should I see?

1041
00:52:41,470 --> 00:52:44,200
让我在这里回答一个问题 看看我是什么
Let me take a question here to see what am I

1042
00:52:44,200 --> 00:52:48,910
当我在为学生做学生会的时候 我现在按回车键的时候会看到吗？
going to see when I hit Enter now when I'm doing for student in students?

1043
00:52:48,910 --> 00:52:51,305
观众：是的 我想我们只会看到钥匙 
AUDIENCE: Yeah, I think we will only see keys.

1044
00:52:51,305 --> 00:52:52,180
大卫·马兰：太好了 
DAVID MALAN: Perfect.

1045
00:52:52,180 --> 00:52:53,020
这么好的直觉 
So good intuition.

1046
00:52:53,020 --> 00:52:53,980
它可能是双向的 
It could have gone both ways.

1047
00:52:53,980 --> 00:52:55,540
可能是价值问题 房子问题 
Could have been values, the houses.

1048
00:52:55,540 --> 00:53:01,300
但是 当您在Python中使用for循环迭代字典时 
But when you use a for loop in Python to iterate over a dictionary, by design,

1049
00:53:01,300 --> 00:53:03,550
它遍历所有键 
it iterates over all of the keys.

1050
00:53:03,550 --> 00:53:07,960
所以我们应该看看 我想 赫敏、哈利、罗恩和德拉科 
So we should see, I think, Hermione, Harry, Ron, and Draco.

1051
00:53:07,960 --> 00:53:11,260
现在让我按Enter键 Enter键 确实 你说的完全正确 
Let me hit Enter now, Enter, and indeed, you're exactly right,

1052
00:53:11,260 --> 00:53:12,580
我们只看到了钥匙 
we see just the keys.

1053
00:53:12,580 --> 00:53:15,580
但如果我真正关心的是
But that's not really that useful if what I really care about

1054
00:53:15,580 --> 00:53:18,430
是谁住在哪里 我能把两个都打印出来吗？
is who lives where, can I print out both?

1055
00:53:18,430 --> 00:53:19,930
嗯 我想我可以 
Well, I think I can.

1056
00:53:19,930 --> 00:53:21,350
让我继续做这件事 
Let me go ahead and do this.

1057
00:53:21,350 --> 00:53:24,850
让我打印出的不仅仅是学生的名字 钥匙 
Let me print out not just the student's name, the key,

1058
00:53:24,850 --> 00:53:30,537
但让我使用关键字 他们的名字 来索引词典 
but let me use the key, their name, to index into the dictionary.

1059
00:53:30,537 --> 00:53:33,370
如果我在词典里知道这个词 让我查一下它的释义 
If I know the word in the dictionary, let me look up its definition.

1060
00:53:33,370 --> 00:53:35,980
如果我知道那个学生的名字 让我查一下他们的房子 
If I know the student's name, let me look up their house,

1061
00:53:35,980 --> 00:53:40,720
而这个的语法 就像一个列表一样 是学生 括号 
and the syntax for this, just like a list, is students, bracket.

1062
00:53:40,720 --> 00:53:44,480
就像过去我们在我还是数字的时候用i一样 
And just like in the past we used i when i was a number,

1063
00:53:44,480 --> 00:53:48,080
我们也可以在词典中使用字符串 
we can also with a dictionary use a string.

1064
00:53:48,080 --> 00:53:55,180
所以如果学生的名字是关键 那么这个语法 学生 
So if the student's name is the key, then this syntax, students,

1065
00:53:55,180 --> 00:54:00,340
开括号 学生 关闭括号将前往赫敏的位置
open bracket, student, close bracket will go to Hermione's location

1066
00:54:00,340 --> 00:54:01,330
然后拿回她的房子 
and get back her house.

1067
00:54:01,330 --> 00:54:04,970
会去哈利的住处 拿回他的房子 等等 
Will go to Harry's location and get back his house and so forth.

1068
00:54:04,970 --> 00:54:08,943
因此 如果我执行hogwarts.py的Python 输入 现在我
So if I do Python of hogwarts.py, Enter, now I

1069
00:54:08,943 --> 00:54:11,485
见赫敏 格兰芬多；哈利 格兰芬多；罗恩 格兰芬多；
see Hermione, Gryffindor; Harry, Gryffindor; Ron, Gryffindor;

1070
00:54:11,485 --> 00:54:12,730
还有德拉科·斯莱特林 
and Draco Slytherin.

1071
00:54:12,730 --> 00:54:14,940
现在看起来我给了他们所有人新的姓氏 
Now it looks like I've given them all new last names,

1072
00:54:14,940 --> 00:54:15,940
但我可以把它清理干净 
but I can clean that up.

1073
00:54:15,940 --> 00:54:17,170
这只是一个打印的东西 
This is just a print thing.

1074
00:54:17,170 --> 00:54:20,110
让我们继续更改默认空格中的分隔符
Let's go ahead and change our separator from the default space

1075
00:54:20,110 --> 00:54:21,790
可能是一个空格 逗号 
to maybe a space, comma.

1076
00:54:21,790 --> 00:54:26,110
现在使用打印功能 让我再次运行相同的程序 输入 
And just using print features now, let me run the same program again, Enter,

1077
00:54:26,110 --> 00:54:29,050
现在我只需要在里面加几个漂亮的逗号来说明
now I've just got some nice pretty commas in there to make clear

1078
00:54:29,050 --> 00:54:31,810
赫敏的姓氏其实不是格兰芬多 
that Hermione's last name is not, in fact, Gryffindor,

1079
00:54:31,810 --> 00:54:33,730
但这只是一个指纹细节 
but that's just a print detail.

1080
00:54:33,730 --> 00:54:37,120
那么 对这些词典还有什么问题吗？还有我刚才做了什么？
Any questions, then, on these dictionaries and what I've just done?

1081
00:54:39,650 --> 00:54:45,410
关于这些词典的问题 然后在这里循环？
Questions on these dictionaries and this looping over then here?

1082
00:54:45,410 --> 00:54:52,190
观众：我就是想不通学生中的学生 
AUDIENCE: I just can't get my head around the for student in students.

1083
00:54:52,190 --> 00:54:54,860
如果我--如果我是对的就纠正我 
If I'm-- just correct me if I'm right.

1084
00:54:54,860 --> 00:55:01,850
这是否意味着它导入了学生名单并使用了索引--
Does that mean it imports the list of students and uses the indexes--

1085
00:55:01,850 --> 00:55:09,140
或者换句话说 赫敏、哈利和罗恩作为实际中的索引--
or in other words, Hermione, Harry, and Ron as the indexes in the actual--

1086
00:55:09,140 --> 00:55:10,455
学生名单？
the list of students?

1087
00:55:10,455 --> 00:55:11,330
大卫·马兰：正确 
DAVID MALAN: Correct.

1088
00:55:11,330 --> 00:55:13,100
因此 这只是Python的一个功能 
So this is just a feature of Python.

1089
00:55:13,100 --> 00:55:17,150
当您在字典中使用for循环时 会发生这样的情况 
When you use a for loop with a dictionary, what happens is this.

1090
00:55:17,150 --> 00:55:20,513
如果这是字典 关键字在上面 值在下面 
If this is the dictionary here with the keys on top and the values on bottom,

1091
00:55:20,513 --> 00:55:22,430
您可以选择变量的名称 
you get to choose what the variable is called.

1092
00:55:22,430 --> 00:55:24,818
我给我的变量学生打电话 只是因为这有道理 
I called my variable student just because it makes sense,

1093
00:55:24,818 --> 00:55:26,360
因为我每次只想要一个学生 
because I want one student at a time.

1094
00:55:26,360 --> 00:55:29,510
For循环所做的 就像它以前对数字所做的那样 
And what for loop does, just like it did with numbers before,

1095
00:55:29,510 --> 00:55:33,060
0、1和2 它允许我 例如 
the 0, the 1, and the 2, it allows me to, for instance,

1096
00:55:33,060 --> 00:55:35,810
将学生初始设置为与赫梅林的名字相等 
set student equal initially to Hermelin's name.

1097
00:55:35,810 --> 00:55:38,990
然后循环的下一个迭代 下一个周期 
And then the next iteration of the loop, the next cycle,

1098
00:55:38,990 --> 00:55:42,800
将学生设置为哈利的名字 然后是罗恩 然后是德拉科 
sets student equal to Harry's name, then Ron, then Draco.

1099
00:55:42,800 --> 00:55:44,300
这是自然而然发生的 
It just happens automatically.

1100
00:55:44,300 --> 00:55:47,480
这就是Python解释器在以下情况下为您做的事情
Like that is what the Python interpreter does for you when

1101
00:55:47,480 --> 00:55:49,140
它看到了这样的for循环 
it sees a for loop like that.

1102
00:55:49,140 --> 00:55:53,090
因此 它在本质上非常类似于在列表上使用for循环迭代 
So it's very similar in spirit to iterating with a for loop over a list,

1103
00:55:53,090 --> 00:55:55,670
而不是迭代该数字位置 
but rather than iterate over the numeric location,

1104
00:55:55,670 --> 00:56:01,700
0 1 2 它遍历此表示形式中的粗体键
0, 1, 2, it iterates over the bold-faced keys in this representation here

1105
00:56:01,700 --> 00:56:02,930
图形化的 
graphically.

1106
00:56:02,930 --> 00:56:05,960
请允许我再给我们举一个关于霍格沃茨的例子
And allow me to give us one other example on Hogwarts

1107
00:56:05,960 --> 00:56:09,320
在我们看另一个熟悉的领域之前 
before we look at one other familiar domain.

1108
00:56:09,320 --> 00:56:11,670
冒着事态升级的风险 
At the risk of things escalating a little bit,

1109
00:56:11,670 --> 00:56:15,320
让我提议让我们用最后一位霍格沃茨来继续这个故事
let me propose that we continue the story with one final Hogwarts

1110
00:56:15,320 --> 00:56:17,100
像这样的例子 
example like this.

1111
00:56:17,100 --> 00:56:21,280
如果我们有更多关于我们每个学生的信息会怎么样？
What if we have more information about each of our students?

1112
00:56:21,280 --> 00:56:23,030
这是不可避免的 
And this is inevitable.

1113
00:56:23,030 --> 00:56:26,760
如果您正在实施一个与人或客户建立数据库的计划 
If you're implementing a program that's a database with people or customers,

1114
00:56:26,760 --> 00:56:29,060
或员工或其他任何东西 你可以想象
or employees or anything else, you can imagine

1115
00:56:29,060 --> 00:56:33,230
拥有关于您在程序中表示的任何内容的大量数据
having a lot of data about anything you're representing in your program

1116
00:56:33,230 --> 00:56:33,740
这里 
here.

1117
00:56:33,740 --> 00:56:37,470
为了便于讨论 假设霍格沃茨的每个学生 当然 
For the sake of discussion, suppose that every student at Hogwarts, of course,

1118
00:56:37,470 --> 00:56:41,480
有了名字 他们已经有了房子 但他们也有了守护神 
has a name, they have already a house, but they also have a patronus.

1119
00:56:41,480 --> 00:56:44,360
对于那些不熟悉的人来说 这是动物或实体
For those unfamiliar, this is the animal or entity

1120
00:56:44,360 --> 00:56:48,260
当他们施展某种魔法咒语时 魔杖的末端就会发出这种魔力 
that comes out of the end of their wand when they make a certain magical spell.

1121
00:56:48,260 --> 00:56:51,410
这里的重点是 我们想要将
The point here being is that we want to associate not

1122
00:56:51,410 --> 00:56:55,670
对学生只有一件事 但有多件事
just one thing with the student, but multiple things

1123
00:56:55,670 --> 00:57:00,110
还有--他们的名字 他们的房子 以及他们的赞助人 
as well-- their name, their house, and their patronus in this case.

1124
00:57:00,110 --> 00:57:02,400
那么 这样的代码可能是什么样子的呢？
Well, what might code like this look like?

1125
00:57:02,400 --> 00:57:07,100
好了 让我回到hogwarts.py 让我重新开始一小会儿 
Well, let me go back to hogwarts.py and let me start fresh for just a moment.

1126
00:57:07,100 --> 00:57:10,650
让我建议我用更多的数据来加强这一点 
And let me propose that I enhance this with a bit more data.

1127
00:57:10,650 --> 00:57:12,800
这些数据将如下所示 
And this data is going to look as follows.

1128
00:57:12,800 --> 00:57:18,360
我的学生现在变了 我建议我们把它当作一个列表 
My students variable now, I'm going to propose we think of it as a list.

1129
00:57:18,360 --> 00:57:21,320
如果我们有一份如下的词典清单 会怎么样？
What if we have a list of dictionaries as follows?

1130
00:57:21,320 --> 00:57:24,960
事实上 我想在这里真正实现这一图景 
Indeed I want to literally implement this picture here.

1131
00:57:24,960 --> 00:57:29,210
所以请注意 我之前的图片只代表了一本词典 
So notice that my previous picture just represented a single dictionary.

1132
00:57:29,210 --> 00:57:33,500
但假设我想编写一份词典列表 
But suppose I wanted to compose a list of dictionaries.

1133
00:57:33,500 --> 00:57:36,650
也就是说 对于学生来说--所以有四名学生 
That is, for students-- so a list of four students.

1134
00:57:36,650 --> 00:57:41,240
假设这些学生本身就是一本词典 
And suppose that each of those students is itself a dictionary,

1135
00:57:41,240 --> 00:57:46,130
键值对、键和值的集合 
a collection of key value pairs, keys and values,

1136
00:57:46,130 --> 00:57:48,180
一件又一件 
something and something else.

1137
00:57:48,180 --> 00:57:50,990
好的 这是我们可以用代码实现的另一种方法 
Well, here's one other way we can do this in code.

1138
00:57:50,990 --> 00:57:55,130
让我回到这里的VS代码 并定义一个名为
Let me go back to VS Code here and let me define a variable called

1139
00:57:55,130 --> 00:57:58,100
等同于列表的学生 
students that is equal to a list.

1140
00:57:58,100 --> 00:58:01,343
我会先发制人地将光标移动到不同的行上 
And I'm going to preemptively move my cursor onto separate lines,

1141
00:58:01,343 --> 00:58:03,260
因为我知道这会很漫长 而且我
because I know this is going to be long, and I

1142
00:58:03,260 --> 00:58:07,320
我想将此列表中的所有元素都放入其中 
want to fit all of the elements of this list inside of it.

1143
00:58:07,320 --> 00:58:10,555
我现在要创建一本词典 每个学生一本词典 
I'm now going to create a dictionary, one dictionary per student.

1144
00:58:10,555 --> 00:58:11,930
我如何创建一本词典？
And how do I create a dictionary?

1145
00:58:11,930 --> 00:58:13,670
我只是用那些花括号 
I just use those curly braces.

1146
00:58:13,670 --> 00:58:16,220
但这取决于我来定义那些关键是什么 
But it's up to me to define what those keys are.

1147
00:58:16,220 --> 00:58:18,500
让我提出这一次的一个关键
And let me propose that one key this time

1148
00:58:18,500 --> 00:58:20,750
不会明确是学生的名字 是吗？
won't be the student's name explicitly, it

1149
00:58:20,750 --> 00:58:24,980
字面上是单词名字 在那里 将有名字赫敏 
will literally be the word name, and there, going to have the name Hermione.

1150
00:58:24,980 --> 00:58:28,700
同一个学生将有另一把名为House的钥匙
The same student is going to have another key called house

1151
00:58:28,700 --> 00:58:31,010
价值将是格兰芬多 
and the value is going to be Gryffindor.

1152
00:58:31,010 --> 00:58:34,700
而同一个学生将拥有第三把钥匙 名为Patronus 
And the same student is going to have a third key called patronus,

1153
00:58:34,700 --> 00:58:36,620
而它的价值将是--
and the value of that is going to be--

1154
00:58:36,620 --> 00:58:39,710
我不得不去查一查--根据书上的说法 是一只水獭 
I had to look it up-- an otter, according to the book.

1155
00:58:39,710 --> 00:58:43,012
现在 我将在该列表中创建第二个词典 
Now I'm going to create a second dictionary inside of this list.

1156
00:58:43,012 --> 00:58:44,720
再说一次 词典就像字面意思
And again, a dictionary is like literally

1157
00:58:44,720 --> 00:58:46,710
就像人类的词典一样 
like the human dictionary of words.

1158
00:58:46,710 --> 00:58:50,750
这是一本包含关键和价值观、词汇和定义的书 
It's a book that contains keys and values, words and definitions.

1159
00:58:50,750 --> 00:58:53,630
我在每本词典里储存的三个单词是什么？
What are the three words I'm storing in each of my dictionaries?

1160
00:58:53,630 --> 00:58:55,640
名字 房子和守护神 
Name, house, and patronus.

1161
00:58:55,640 --> 00:58:58,940
这些词对赫敏的定义是什么？
What are the definitions of those words for Hermione?

1162
00:58:58,940 --> 00:59:01,850
分别是赫敏、格兰芬多和水獭 
Hermione, Gryffindor, and otter respectively.

1163
00:59:01,850 --> 00:59:05,840
对哈里来说 这本新词典的释义将有所不同 
For Harry, the definitions are going to be different in this new dictionary.

1164
00:59:05,840 --> 00:59:08,270
让我再给自己配一副花箍
Let me give myself another pair of curly braces

1165
00:59:08,270 --> 00:59:12,230
然后说这个 名字 引号 冒号 哈利 
and say this, name, quote-unquote, colon, Harry.

1166
00:59:12,230 --> 00:59:15,500
这里的房子又一次将是格兰芬多 
House here is, again, going to be Gryffindor.

1167
00:59:15,500 --> 00:59:21,620
而我认识的这位 他的守护神 在这种情况下 将是一只雄鹿 
And this one I knew, his patronus, is going to be, in this case, a stag.

1168
00:59:21,620 --> 00:59:23,330
接下来是第三本词典 
Next, a third dictionary.

1169
00:59:23,330 --> 00:59:25,130
这里的名字将是罗恩 
The name here will be Ron.

1170
00:59:25,130 --> 00:59:27,560
我会像这样继续做下去 
And I'm going to go ahead and do that just like this.

1171
00:59:27,560 --> 00:59:31,070
接下来 我得到了房子 他也是格兰芬多 
Next, I have the house, and he, too, was Gryffindor.

1172
00:59:31,070 --> 00:59:38,120
最后 我要查一查 罗恩的赞助人是一只杰克·罗素梗犬 
Lastly, had to look this one up, Ron's patronus was a Jack Russell terrier.

1173
00:59:38,120 --> 00:59:42,100
最后是德拉科 
Lastly is Draco.

1174
00:59:42,100 --> 00:59:45,070
在第四本词典中--又一对花括号 
In a fourth dictionary now-- so another pair of curly braces,

1175
00:59:45,070 --> 00:59:47,380
当然 这名学生的名字是德拉科 
the name of the student is, of course, Draco.

1176
00:59:47,380 --> 00:59:50,650
这个学生的房子是斯莱特林 
The house of this student is Slytherin.

1177
00:59:50,650 --> 00:59:55,630
而德拉科 有趣的是 至少根据互联网上的说法 
And Draco, interestingly enough, at least according to the internet,

1178
00:59:55,630 --> 00:59:57,010
没有守护神 
has no patronus.

1179
00:59:57,010 --> 00:59:59,230
从未在书中或电影中出现过 
Was never revealed in the books or the movies.

1180
00:59:59,230 --> 01:00:02,290
事实证明 这实际上是一个很棒的可教的时刻 
So it turns out, this is actually a wonderful teachable moment.

1181
01:00:02,290 --> 01:00:08,170
在Python中有一个特殊的关键字 字面意思是None N-O-N-E 
There is a special key word in Python that is literally None, and N-O-N-E,

1182
01:00:08,170 --> 01:00:10,360
第一个字母大写 
with the first letter capitalized.

1183
01:00:10,360 --> 01:00:14,210
这正式地代表了价值的缺失 
This represents officially the absence of a value.

1184
01:00:14,210 --> 01:00:17,440
所以我可以草率地做一些类似引用-引用的事情 
So I could a little sloppily do something like quote-unquote,

1185
01:00:17,440 --> 01:00:20,410
但这是否意味着我没有抽出时间来打字呢？
but does that mean I didn't get around to typing it or not?

1186
01:00:20,410 --> 01:00:24,880
从语义上说 字面上没有 一个特殊的关键字 这是有点清楚的
It's a little clear semantically to say literally None, a special keyword

1187
01:00:24,880 --> 01:00:29,620
我知道德拉科没有守护神 
in Python to make clear that I know Draco has no patronus,

1188
01:00:29,620 --> 01:00:32,320
这不仅仅是我的疏忽
it's not just an oversight on my part.

1189
01:00:32,320 --> 01:00:36,370
现在我有了这个 我在电脑内存里有什么？
Now that I have this, what do I have in the computer's memory?

1190
01:00:36,370 --> 01:00:37,360
我有一个名单 
I have a list.

1191
01:00:37,360 --> 01:00:38,620
我怎么知道这是名单
How do I know it's a list?

1192
01:00:38,620 --> 01:00:42,310
因为我在开头看到一个方括号 
Because I see a square bracket at the beginning and another square bracket

1193
01:00:42,310 --> 01:00:42,850
到最后
at the end.

1194
01:00:42,850 --> 01:00:45,730
这只是我的视觉线索 好吧 我不一定知道
That's just my visual clue, OK, I don't know necessarily

1195
01:00:45,730 --> 01:00:48,910
这里还有什么 但有一张清单
what else is going on here, but there's a list of something.

1196
01:00:48,910 --> 01:00:50,960
名单上有什么？
What is in that list?

1197
01:00:50,960 --> 01:00:53,560
在这里 语法也是我们的线索 
Well, here, too, the syntax is our clue.

1198
01:00:53,560 --> 01:00:57,820
因为第2行以花括号开始并以花括号结束 
Because this line 2 starts with a curly brace and ends with a curly brace,

1199
01:00:57,820 --> 01:01:02,570
我只知道 那是一个字典 一个键值对的集合 
I just know, that is a dictionary, a collection of key value pairs.

1200
01:01:02,570 --> 01:01:04,930
现在这些都完美地显示在我的屏幕上 所以我
Now this all fit on my screen perfectly, so I

1201
01:01:04,930 --> 01:01:08,020
并没有麻烦将所有的键值对移动到新的行上 
didn't bother moving all of the key value pairs onto new lines,

1202
01:01:08,020 --> 01:01:11,620
它会变得很高 所以这次我把它放在一起 
it would have made it really tall, so I kept it all together here this time.

1203
01:01:11,620 --> 01:01:15,520
但是这第一本字典有多少个键呢？
But how many keys does this first dictionary have?

1204
01:01:15,520 --> 01:01:17,897
换句话说 在赫敏的物理字典里 
Put another way, in Hermione's physical dictionary,

1205
01:01:17,897 --> 01:01:19,480
那本字典里有多少单词？
how many words are in that dictionary?

1206
01:01:19,480 --> 01:01:20,230
三.
Three.

1207
01:01:20,230 --> 01:01:22,990
这些词是名字 房子和守护神 
The words are name, house, and patronus.

1208
01:01:22,990 --> 01:01:26,140
这些词的三个定义或价值是什么
What are the three definitions or values of those words

1209
01:01:26,140 --> 01:01:27,640
在赫敏的字典里
in Hermione's dictionary?

1210
01:01:27,640 --> 01:01:31,000
赫敏 格兰芬多 水獭 
Hermione, Gryffindor, and otter respectively.

1211
01:01:31,000 --> 01:01:35,360
同样的故事也发生在哈利身上 然后是罗恩 
And the same story goes for Harry, then for Ron,

1212
01:01:35,360 --> 01:01:39,190
那么对于德拉科我特意选择了
then for Draco, I have, by design, chosen

1213
01:01:39,190 --> 01:01:44,440
给他们字典 所有相同的键 所有相同的名字 
to give them dictionaries that have all the same keys, all the same names,

1214
01:01:44,440 --> 01:01:47,200
但它们都有独特的价值 
but they all have unique values.

1215
01:01:47,200 --> 01:01:50,080
这就是我的设计 这是我作为一个程序员的特权 
And that's my design, that's my prerogative as a programmer.

1216
01:01:50,080 --> 01:01:53,200
那么 为什么这在今天结束时有用呢？
So why is this useful at the end of the day now?

1217
01:01:53,200 --> 01:01:57,130
我有一整套有趣的数据
I have access to a whole collection of interesting data about all

1218
01:01:57,130 --> 01:01:59,620
我仍然可以做循环 
of these students, and I can still do a loop.

1219
01:01:59,620 --> 01:02:02,980
我可以说 对于学生中的学生来说 
I can say for students in students, that's

1220
01:02:02,980 --> 01:02:05,590
允许我浏览一下学生名单
going to allow me to iterate over this list of students.

1221
01:02:05,590 --> 01:02:08,240
让我一次只打印一件东西 
And let me go ahead and print out just one thing at a time.

1222
01:02:08,240 --> 01:02:10,610
我把现在学生的名字打印出来 
Let me print out the current student's name.

1223
01:02:10,610 --> 01:02:14,470
尽管字典很复杂 但这应该很方便 
So as complicated as the dictionary is, this should be pretty comfortable.

1224
01:02:14,470 --> 01:02:18,490
对于学生中的学生 只需迭代列表中的每个学生 
For student in students is just going to iterate over every student in the list.

1225
01:02:18,490 --> 01:02:20,420
总计1 2 3 4 
1, 2, 3, 4 total.

1226
01:02:20,420 --> 01:02:24,580
下一行将打印NAME键的值 
The next line is just going to print out the value of the name key.

1227
01:02:24,580 --> 01:02:27,850
这就像打开物理词典 查找单词名称 
It's like opening a physical dictionary, looking up the word name,

1228
01:02:27,850 --> 01:02:30,670
给我们赫敏、哈利、罗恩和德拉科
and giving us Hermione, Harry, Ron, and Draco

1229
01:02:30,670 --> 01:02:32,480
分别来自每个词典 
respectively from each dictionary.

1230
01:02:32,480 --> 01:02:36,880
因此 如果我运行这个版本的霍格沃茨 然后按Enter键 在那里 我会得到所有三个
So if I run this version of Hogwarts and hit Enter, there, I get all three

1231
01:02:36,880 --> 01:02:37,780
他们的名字 
of their names.

1232
01:02:37,780 --> 01:02:39,790
但如果我想要更多的信息呢？
But what if I want more information than that?

1233
01:02:39,790 --> 01:02:42,040
我要他们的名字和他们的房子 
I want both their names and their houses.

1234
01:02:42,040 --> 01:02:47,650
好的 只要加上普莱特的论点 学生 左括号 房子 
Well, just add to print's arguments student, open bracket, house,

1235
01:02:47,650 --> 01:02:48,910
右方括号 
close bracket.

1236
01:02:48,910 --> 01:02:50,740
好的 让我们继续运行这个 
All right, let's go ahead and run this.

1237
01:02:50,740 --> 01:02:53,170
Python of hogwarts.py并按Enter 
Python of hogwarts.py and hit Enter.

1238
01:02:53,170 --> 01:02:56,078
所以我现在看到了赫敏 格兰芬多 哈利 格兰芬多 等等 
So I now see Hermione, Gryffindor; Harry, Gryffindor; and so forth.

1239
01:02:56,078 --> 01:02:58,120
好的 我们可以在美学上把这件事清理一下
Well, we can aesthetically clean this up a little

1240
01:02:58,120 --> 01:03:01,480
通过添加带有印刷体的分隔符 如逗号和空格 
bit by adding a separator with print, like a comma and a space,

1241
01:03:01,480 --> 01:03:03,760
这样 当我再次运行此程序时 我现在
just so that when I run this again, I now

1242
01:03:03,760 --> 01:03:05,680
请看用逗号分隔这些值 
see some comma separating these values.

1243
01:03:05,680 --> 01:03:08,290
但请记住 学生不仅有一个名字 也不仅仅是
But recall that students have not just a name, not just

1244
01:03:08,290 --> 01:03:09,910
一栋房子 还有那个守护神 
a house, but also that patronus.

1245
01:03:09,910 --> 01:03:12,700
因此 如果我们也想打印出来 我们现在
So if we want to print out that, too, we now

1246
01:03:12,700 --> 01:03:18,040
我有为每个学生编写同一本词典所使用的语法
have the syntax via which to go into that same dictionary for each student

1247
01:03:18,040 --> 01:03:22,010
并以他们的名义输出他们的赞助人和他们的房子 
and output their patronus as well as their house in their name.

1248
01:03:22,010 --> 01:03:24,520
所以如果我最后一次运行这个程序 现在我
So if I run this program one final time, now I

1249
01:03:24,520 --> 01:03:28,490
请参阅本词典中的所有数据 
see all of the data in this here dictionary.

1250
01:03:28,490 --> 01:03:31,390
因此 我相信 一下子要消化的东西很多 
So this is a lot to absorb all at once, I'm sure.

1251
01:03:31,390 --> 01:03:33,367
这是我们最后一种新的数据类型 
It's the last of our new data types.

1252
01:03:33,367 --> 01:03:35,200
在清单的顶端 我们有这些词典 
On top of lists, we have these dictionaries,

1253
01:03:35,200 --> 01:03:37,750
但同样 一本词典 在一天结束的时候 
but again, a dictionary, at the end of the day,

1254
01:03:37,750 --> 01:03:41,740
只是类似于这些值的值的集合
is just a collection of values similar to these values

1255
01:03:41,740 --> 01:03:44,780
在这里 您可以将键与值相关联 
here that allow you to associate keys with values.

1256
01:03:44,780 --> 01:03:48,520
这个程序的第一个版本从字面上看与学生的
And the first version of this program associated literally the student's

1257
01:03:48,520 --> 01:03:51,040
名字和他们的房子 但后来我意识到
names with their houses, but then I realized

1258
01:03:51,040 --> 01:03:53,920
在我的下一个版本中 等等 如果每个学生都没有
in my next version, wait a minute, what if every student has not

1259
01:03:53,920 --> 01:03:55,990
只是房子里的一个名字 但是一个守护神？
just a name in a house, but a patronus?

1260
01:03:55,990 --> 01:03:59,230
让我们真正标准化密钥的名称
Let's actually standardize the names of our keys

1261
01:03:59,230 --> 01:04:03,850
是名字、房子和守护神 然后是这些关键字的价值
to be name, house, and patronus, and then the values of those keys

1262
01:04:03,850 --> 01:04:08,530
实际上可以是数据 比如赫敏、格兰芬多、水獭等等 
can actually be the data, like Hermione, Gryffindor, otter, and so forth.

1263
01:04:08,530 --> 01:04:13,240
现在关于这些词典及其迭代的问题是什么？
Questions now on these dictionaries and iteration thereof?

1264
01:04:13,240 --> 01:04:18,710
听众：我只是在想 假设这本词典很大 
AUDIENCE: I just was wondering, suppose the dictionary is very huge,

1265
01:04:18,710 --> 01:04:22,270
如果我想找一个特定的学生 
and if I want to look up for a specific student,

1266
01:04:22,270 --> 01:04:26,650
那么我怎么知道从哪里看那个学生呢？
so how do I know where to look that student from?

1267
01:04:26,650 --> 01:04:29,470
比如我们能按字母顺序排序吗？
Like can we sort it out in alphabetical order

1268
01:04:29,470 --> 01:04:32,163
或数字顺序或类似的东西？
or numeric order or anything like that?

1269
01:04:32,163 --> 01:04:33,580
大卫·马兰：简而言之 是的 
DAVID MALAN: In short answer, yes.

1270
01:04:33,580 --> 01:04:37,570
Python的特点之一是它使这些词典非常高
One of the features of Python is that it makes these dictionaries very highly

1271
01:04:37,570 --> 01:04:38,680
为你表演的 
performant for you.

1272
01:04:38,680 --> 01:04:42,280
也就是说 即使它们非常大 因为它们将在未来几周内
That is, even if they're very large, as they will be in future weeks

1273
01:04:42,280 --> 01:04:45,910
当我们操作更多的数据时 Python会找到这些数据
when we manipulate more data, Python will find the data

1274
01:04:45,910 --> 01:04:48,520
你很快就会关心你的 
you care about quickly for you.

1275
01:04:48,520 --> 01:04:50,650
事实上 这是语言的一个特点 
And in fact, that is a feature of the language,

1276
01:04:50,650 --> 01:04:53,560
这是一本词典的一个特点 可以让你快速获得数据 
that is a feature of a dictionary to get you the data quickly.

1277
01:04:53,560 --> 01:04:55,480
还有一些你可以使用的函数 
And there are functions that you can use.

1278
01:04:55,480 --> 01:04:57,550
你可以对数据进行分类 你可以筛选它 
You can sort the data, you can sift through it,

1279
01:04:57,550 --> 01:05:01,870
你可以像我们最终所做的那样 做非常出色的手术 
you can do very performant operations as we eventually will.

1280
01:05:01,870 --> 01:05:05,800
那么 请允许我提议 当我们结束这些循环时 
Allow me, then, to propose, as we wrap up these loops,

1281
01:05:05,800 --> 01:05:08,740
我们只解决了最后几个问题 可能会
that we solve just a few final problems that will perhaps

1282
01:05:08,740 --> 01:05:11,050
至少唤起了对往年的美好回忆
evoke fond memories of yesteryear, at least

1283
01:05:11,050 --> 01:05:13,540
对我来说 在我成长过程中最喜欢的游戏之一
for me, wherein one of my favorite games growing up

1284
01:05:13,540 --> 01:05:15,850
这张是在最初的任天堂上的吗？
was this one here on the original Nintendo.

1285
01:05:15,850 --> 01:05:19,240
这是一个角色向上移动的二维世界 
And this is a two-dimensional world where the characters move up,

1286
01:05:19,240 --> 01:05:23,020
向下 向右 不是太靠左 跳过
down, and right, not so much to the left, in jumping over

1287
01:05:23,020 --> 01:05:25,060
像这样的金字塔和障碍物 
pyramids and obstructions like these.

1288
01:05:25,060 --> 01:05:27,670
请允许我提议我们用这个来启发灵感 
And allow me to propose that we use this just for inspiration,

1289
01:05:27,670 --> 01:05:31,180
不是做像这样色彩鲜艳或图形化的事情 而是
not to do something that's quite as colorful or graphical as this, but just

1290
01:05:31,180 --> 01:05:34,990
例如 要关注世界中部的这一障碍
to focus on, for instance, this barrier in the middle of the world

1291
01:05:34,990 --> 01:05:38,080
在这里 马里奥或路易吉不得不跳过 
here that Mario or Luigi had to jump over.

1292
01:05:38,080 --> 01:05:42,372
所以这里看起来就像是三块砖一块一块地踩在一起 
And so this here seems to be like three bricks stepped on top of one another.

1293
01:05:42,372 --> 01:05:44,080
我们不会把事情做得很生动 
And we won't do things quite graphically,

1294
01:05:44,080 --> 01:05:48,190
但让我们只实现一个非常简单的基于Python的文本版本
but let's just implement a very simple Python-based version of this textually

1295
01:05:48,190 --> 01:05:50,440
可能只使用散列来制作砖块 
using maybe just hashes for bricks.

1296
01:05:50,440 --> 01:05:53,500
因为这里有一个模式 一个在另一个之上 而我
Because there's a pattern here, one on top of the other, and I

1297
01:05:53,500 --> 01:05:56,170
我打赌我们可以用很多方法来解决这个问题 
bet we can solve this in any number of ways.

1298
01:05:56,170 --> 01:05:58,720
好了 让我在这里切换回VS代码
Well, let me switch back over to VS Code here

1299
01:05:58,720 --> 01:06:03,340
让我建议我们使用代码创建一个名为mario.py的程序
and let me propose that we create a program called mario.py using code

1300
01:06:03,340 --> 01:06:04,750
在终端窗口中 
in the terminal window.

1301
01:06:04,750 --> 01:06:07,630
然后在这里 让我从实现相同的图景开始
And then up here, let me start by implementing that same picture

1302
01:06:07,630 --> 01:06:11,590
尽可能简单地打印出散列 
as simply as I can, printing out just literally the hash,

1303
01:06:11,590 --> 01:06:14,830
然后是散列 然后是第三个最终散列 
and then the hash, and then a third final hash.

1304
01:06:14,830 --> 01:06:17,500
这将是一个非常文本的近似值 
This is going to be a very textual approximation of it,

1305
01:06:17,500 --> 01:06:20,440
但我认为 如果我运行Python mario.py 我已经
but I think if I run Python mario.py, I've

1306
01:06:20,440 --> 01:06:25,840
可以说 我得到了一个非常简单的相同的砖柱版本 
got a very simple version of that same column of bricks, so to speak.

1307
01:06:25,840 --> 01:06:28,150
但你可以想象在一场比赛中
But you can imagine that certainly in a game

1308
01:06:28,150 --> 01:06:31,380
可能这些柱子会变高或变低 
where maybe these columns get higher or lower,

1309
01:06:31,380 --> 01:06:33,880
如果能写出更多的代码就好了
it would be nice to write code that's actually a little more

1310
01:06:33,880 --> 01:06:37,690
而不是仅仅使用打印 这就是字面意思
dynamic than that and doesn't just use print, print, print, which is literally

1311
01:06:37,690 --> 01:06:39,340
复制和粘贴 似乎是这样的 
copy and paste, it would seem.

1312
01:06:39,340 --> 01:06:42,550
所以至少让我采纳今天的一些经验教训
So let me at least adopt some of today's lessons

1313
01:06:42,550 --> 01:06:44,650
学到了东西 然后做了这样的事情 
learned and instead do something like this.

1314
01:06:44,650 --> 01:06:50,620
为了在3的范围内加下划线 现在让我们一次只打印其中的一个 
For underscore in range of 3, let's now print out just one of these at a time.

1315
01:06:50,620 --> 01:06:53,230
但事实是 我现在用3来标示
But the fact that I've now used a 3 to range

1316
01:06:53,230 --> 01:06:55,840
意思是如果我想把它改成更大或更小的 
means if I want to change it to something bigger or smaller,

1317
01:06:55,840 --> 01:06:59,350
我在一个地方改变它 而不是在三个或更多的地方 
I change it in one place not in three or more places.

1318
01:06:59,350 --> 01:07:01,450
当然 这个代码也是如此 如果我没有弄错的话 
And this code, too, of course, if I got it right,

1319
01:07:01,450 --> 01:07:05,150
会打印出一模一样的东西 
is just going to print out the exact same thing.

1320
01:07:05,150 --> 01:07:06,610
所以我们在这里迭代 
So we're iterating here.

1321
01:07:06,610 --> 01:07:08,860
但让我们看看我们现在能不能把我们的讨论
But let's see if we can't now integrate our discussion

1322
01:07:08,860 --> 01:07:13,420
编写我们自己的函数 以开始编写一些更具动感的东西
of writing functions of our own to begin writing something a little more dynamic

1323
01:07:13,420 --> 01:07:16,180
并最终解决更复杂的问题 
and solving more complicated problems ultimately.

1324
01:07:16,180 --> 01:07:18,130
函数的优点之一是
One of the nice things about functions is

1325
01:07:18,130 --> 01:07:21,550
它们不仅允许我们编写我们可以使用和重复使用的代码 
that they allow us to not just write code that we can use and reuse,

1326
01:07:21,550 --> 01:07:24,640
它们允许我们创建抽象 如果您愿意的话 
they allow us to create abstractions, if you will.

1327
01:07:24,640 --> 01:07:28,990
抽象是对可能更复杂的概念的简化 
An abstraction is a simplification of a potentially more complicated idea.

1328
01:07:28,990 --> 01:07:31,870
在几周的时间里 我们已经看到了几次这样的情况 
And we've seen this a few times over the course of the weeks.

1329
01:07:31,870 --> 01:07:35,650
例如 我们有一个名为Hello的函数 当然 它不能
For instance, we had a function called hello, which, granted, didn't do

1330
01:07:35,650 --> 01:07:37,480
所有这些 它只是打印了问候 
all that much, it just printed hello.

1331
01:07:37,480 --> 01:07:40,960
但它让我可以准确地理解它的功能 
But it allowed me to think about the function as exactly what it does,

1332
01:07:40,960 --> 01:07:44,590
不是一般的打印东西 而是字面上的问候 
not generically printing something, but literally saying hello.

1333
01:07:44,590 --> 01:07:48,520
我已经能够使用类似的方法获得一个数字 方法是定义
I've been able to get a number using something similar by defining

1334
01:07:48,520 --> 01:07:50,320
我自己的函数 比如Get Number 
my own function like get number.

1335
01:07:50,320 --> 01:07:53,650
好吧 让我继续 举个例子 暂时假设
Well let me go ahead and, for instance, assume for the moment

1336
01:07:53,650 --> 01:07:57,160
在我的主要功能中 我已经有了先见之明 
that I've had the forethought to, in my function main,

1337
01:07:57,160 --> 01:07:59,770
使用名为Print Column的函数 
use a function called print column.

1338
01:07:59,770 --> 01:08:03,190
这似乎是一个使用一个函数的好名字
That seems as good a name as any to use a function that

1339
01:08:03,190 --> 01:08:05,290
打印一列砖 
prints a column of bricks.

1340
01:08:05,290 --> 01:08:07,660
那么 我现在该如何着手实施
Well, how can I go about now implementing

1341
01:08:07,660 --> 01:08:12,100
这种抽象 这种简单的打印列与实际代码的想法？
this abstraction, this simple idea of print column with actual code?

1342
01:08:12,100 --> 01:08:14,500
嗯 我们以前见过def 我们可以做到这一点 
Well, we've seen before with def, we can do just that.

1343
01:08:14,500 --> 01:08:16,720
让我定义一个名为Print Column函数 
Let me define a function called print column.

1344
01:08:16,720 --> 01:08:21,220
一般来说 让我接受一个名为Height的参数作为它的输入 
Let me accept as its input, generically speaking, a parameter called height.

1345
01:08:21,220 --> 01:08:25,029
我可以称它为n或h 但现在用身高表示会更清楚一些
I could call it n or h, but it would be a little more explicit now with height

1346
01:08:25,029 --> 01:08:27,250
只是为了提醒我自己它在做什么 
just so I remind myself what it's doing.

1347
01:08:27,250 --> 01:08:30,819
现在我想我可以借用以前的一些相同的代码 
And now I think I can just borrow some of that same code from before.

1348
01:08:30,819 --> 01:08:37,990
对于n个高度范围的下划线 请继续并打印出单个散列 
For underscore n range of height, go ahead and print out a single hash.

1349
01:08:37,990 --> 01:08:41,050
然后在整个程序结束时 让我们只调用main 
And then at the end of this whole program, let's just call main.

1350
01:08:41,050 --> 01:08:43,120
所以我把代码变得有点复杂了 
So I've kind of complicated the code.

1351
01:08:43,120 --> 01:08:45,580
它目前还不能做更多的事情 但它
It doesn't do anything more just yet, but it's

1352
01:08:45,580 --> 01:08:48,310
让我来解决我认为将要发生的事情
setting me up for solving what I think are going

1353
01:08:48,310 --> 01:08:50,080
更复杂的问题 
to be more sophisticated problems.

1354
01:08:50,080 --> 01:08:53,170
如果我运行Python of mario.py 我们又回到了开始的地方 
If I run Python of mario.py, we're back where we began.

1355
01:08:53,170 --> 01:08:57,520
但我现在有了一个函数 一个抽象 打印专栏 
But I now have a function, an abstraction, print column,

1356
01:08:57,520 --> 01:09:00,040
这会让我考虑打印
that's going to allow me to think about printing

1357
01:09:00,040 --> 01:09:03,432
一次是马里奥世界的一小部分 
some chunk of the world of Mario at a time.

1358
01:09:03,432 --> 01:09:05,140
我也可以用不同的方式做到这一点 
And I can do this in different ways, too.

1359
01:09:05,140 --> 01:09:09,080
请注意 如果我真的想 我可以做这样的事情 
Notice that if I really want, I could do something like this.

1360
01:09:09,080 --> 01:09:12,260
我可以用不同方式实现现在打印列 
I could implement now print column in different ways,

1361
01:09:12,260 --> 01:09:15,260
尤其是当我在代码中使用打印列时 
especially if I am using print column all over my code,

1362
01:09:15,260 --> 01:09:19,220
或者 我的一位同事 一位朋友 互联网上的其他人
or maybe still, a colleague of mine, a friend, someone else on the internet

1363
01:09:19,220 --> 01:09:21,200
正在使用我的打印栏功能 
is using my print column function.

1364
01:09:21,200 --> 01:09:23,899
您编写的函数还有什么好的地方
What's also nice about functions you've written

1365
01:09:23,899 --> 01:09:27,770
是您可以更改它们的底层实现细节 
is you can change the underlying implementation details of them,

1366
01:09:27,770 --> 01:09:31,850
但只要您不更改函数的名称或其参数
but so long as you don't change the name of the function or its parameters

1367
01:09:31,850 --> 01:09:35,870
或者它的回报是什么 如果说有什么不同的话 那就是没有人知道其中的区别 
or what it returns, if anything no one else knows the difference.

1368
01:09:35,870 --> 01:09:37,970
您可以更改内部实现
You can change the internal implementation

1369
01:09:37,970 --> 01:09:41,760
如果你想改进它或随着时间的推移进行修复 你想要多少就有多少 
as much as you want if you want to improve it or make fixes over time.

1370
01:09:41,760 --> 01:09:44,390
例如 我们可以实现打印列的另一种方式 
So for instance, another way we could implement print column,

1371
01:09:44,390 --> 01:09:46,340
回想一下 应该是这样的 
recall, would be something like this.

1372
01:09:46,340 --> 01:09:48,920
用一个散列和一个新的行有点聪明 
A bit clever with one hash and then a new line,

1373
01:09:48,920 --> 01:09:51,750
然后也许我们可以做弦的乘法 
and then maybe we could do multiplication of strings,

1374
01:09:51,750 --> 01:09:54,080
然后以引号-非引号结束此行 
and then end this line with quote-unquote.

1375
01:09:54,080 --> 01:09:57,110
同样 如果您不熟悉这种语法 也没有关系 
Again, it's OK if you're not comfortable with this syntax.

1376
01:09:57,110 --> 01:09:59,660
这是我们过去看到的一种更聪明的方法 
This was a more clever approach we saw in the past.

1377
01:09:59,660 --> 01:10:04,280
但是如果我在这里运行Python of mario.py 我仍然会看到一个包含三个元素的列 
But if I run Python of mario.py here, I'll still see a column of three.

1378
01:10:04,280 --> 01:10:07,040
但这里重要的是 Main并不
But what's important here is that main does not

1379
01:10:07,040 --> 01:10:12,110
需要知道的是Print列的底层实现
need to know that the underlying implementation of print column

1380
01:10:12,110 --> 01:10:13,980
已经改变了 
has changed.

1381
01:10:13,980 --> 01:10:15,980
好吧 让我们过渡到一个不同的维度 
Well, let's transition to a different dimension,

1382
01:10:15,980 --> 01:10:19,400
如果您愿意 与其打印出这些垂直的砖块 不如让我们
if you will, and rather than print out just these vertical bricks, let's

1383
01:10:19,400 --> 01:10:22,160
在游戏中快进到世界的这一部分 
fast forward in the game to this part of the world here.

1384
01:10:22,160 --> 01:10:25,490
在某些地方 马里奥在天空中遇到了这些砖块 
At some part, Mario encounters these bricks in the sky,

1385
01:10:25,490 --> 01:10:27,690
如果他从下面跳起来 它们就会变成硬币 
that if he jumps up underneath, they become coins.

1386
01:10:27,690 --> 01:10:29,780
因此 他获得了他的分数 
And so he gains to his score.

1387
01:10:29,780 --> 01:10:32,270
但让我们继续 只关注那些硬币 
But let's go ahead and focus only on those coins,

1388
01:10:32,270 --> 01:10:34,460
让我提议我们打印出来 哦 只是
and let me propose that we print out, oh, just

1389
01:10:34,460 --> 01:10:36,110
这里有四个问号 
these four question marks here.

1390
01:10:36,110 --> 01:10:38,150
让我回到VS Code这里 
And let me go back to VS Code here.

1391
01:10:38,150 --> 01:10:41,480
让我建议在VS代码中 就像以前一样 我们
And let me propose that within VS Code here, just like before, we

1392
01:10:41,480 --> 01:10:43,010
试着把这件事抽象出来 
try to abstract this away.

1393
01:10:43,010 --> 01:10:45,290
所以让我继续下去 去掉这个版本 
So let me go ahead and get rid of this version,

1394
01:10:45,290 --> 01:10:49,520
因为我们现在的产出是水平的 而不是垂直的 
because we're now going horizontal instead of vertical with our output.

1395
01:10:49,520 --> 01:10:53,690
让我说 好吧 打印行四次 
And let me just say, well, print row four times.

1396
01:10:53,690 --> 01:10:56,360
让我把手头的问题抽象出来 
Let me just abstract away the problem at hand.

1397
01:10:56,360 --> 01:10:59,180
我还不知道该如何打印这四个问号 
I don't know yet how I'm going to print those four question marks,

1398
01:10:59,180 --> 01:11:03,770
但让我们将其称为print row 4 我将假设我现在将解决这个问题 
but let's call it print row 4, and I'll assume I'll now solve this problem.

1399
01:11:03,770 --> 01:11:06,800
现在让我们进入解决这个问题的那个兔子洞 
Let's now go down that rabbit hole of solving the problem.

1400
01:11:06,800 --> 01:11:09,020
定义一个名为print row的函数 
Define a function called print row.

1401
01:11:09,020 --> 01:11:11,570
它将采用宽度而不是高度 
It's going to take a width instead of a height,

1402
01:11:11,570 --> 01:11:14,030
因为它是水平的而不是垂直的 
because it's horizontal instead of vertical.

1403
01:11:14,030 --> 01:11:15,750
我怎么才能做到这一点？
And how can I do this?

1404
01:11:15,750 --> 01:11:19,160
现在 我们有机会做更多的弦乘法
Well now, we have an opportunity to do string multiplication even more

1405
01:11:19,160 --> 01:11:19,760
优雅地 
elegantly.

1406
01:11:19,760 --> 01:11:23,300
我可以说引号-不引号 问号 时间宽度 
I can say quote-unquote, question mark, times width.

1407
01:11:23,300 --> 01:11:28,010
这是一种非常精美的毕德式的打印方式 否则
And this is a very pretty Pythonic way of printing what could otherwise

1408
01:11:28,010 --> 01:11:29,990
做一个循环 这很好 但这是
be a loop, and that's fine, but this is going

1409
01:11:29,990 --> 01:11:32,630
继续为我打印那些问号 
to go ahead and print those question marks for me.

1410
01:11:32,630 --> 01:11:37,130
让我们来做Python of mario.py 回车 现在我得到了四个问号 
Let's do Python of mario.py, Enter, and now I've got four question marks.

1411
01:11:37,130 --> 01:11:39,530
它远不如更图形化的版本漂亮 
It's not nearly as pretty as the more graphical version,

1412
01:11:39,530 --> 01:11:44,390
但这至少是迈向
but it is at least a building block toward having

1413
01:11:44,390 --> 01:11:47,870
现在是一个可重复使用的函数 如print row 
now a reusable function like print row.

1414
01:11:47,870 --> 01:11:49,130
我为什么要做这一切？
And why am I doing all this?

1415
01:11:49,130 --> 01:11:52,820
比如 为什么我们要过度设计这些问题的解决方案
Like why are we over engineering the solution to these problems

1416
01:11:52,820 --> 01:11:54,920
通过打印列和打印行吗？
by having print column and print row?

1417
01:11:54,920 --> 01:11:57,620
嗯 这是一种有用的解决问题的技巧 
Well, it's a useful problem-solving technique.

1418
01:11:57,620 --> 01:12:00,410
一旦你的世界看起来不是一维的
As soon as your world does not look one-dimensional

1419
01:12:00,410 --> 01:12:04,130
像这样或者用专栏的版本 但是这个呢？
like this or with the column version, but what about this?

1420
01:12:04,130 --> 01:12:08,270
后来在《超级马里奥兄弟》中 马里奥必须跳进这个世界吗？
Later in Super Mario Brothers does Mario have to jump down into this world

1421
01:12:08,270 --> 01:12:11,000
那里有很多这样的黑社会障碍 
where there's a lot of these underworld barriers.

1422
01:12:11,000 --> 01:12:13,400
例如 这里的这个看起来像一个正方形 
And this one here, for instance, looks like a square.

1423
01:12:13,400 --> 01:12:16,400
它是二维的 有一个高度和一个宽度 
It's two-dimensional there's a height and a width to it.

1424
01:12:16,400 --> 01:12:18,830
也就是说 有很多不同的方式
And that is to say there's a bunch of different ways

1425
01:12:18,830 --> 01:12:21,980
我们可以实施这件事 如果 也许是为了讨论 
we could implement this thing if, maybe for discussion,

1426
01:12:21,980 --> 01:12:26,780
这就像一个3x3的网格 一个3x3的正方形 
it's like a 3-by-3 grid, a 3-by-3 square of sorts.

1427
01:12:26,780 --> 01:12:29,570
那么 我们该如何着手解决这个问题呢？
Well, how can we go about solving this here problem?

1428
01:12:29,570 --> 01:12:32,060
好吧 让我提议我们回到VS代码
Well, let me propose we come back to VS Code

1429
01:12:32,060 --> 01:12:36,420
让我提议我们用几种不同的方式来思考这个问题 
and let me propose that we think about this in a couple of different ways.

1430
01:12:36,420 --> 01:12:39,740
我可以这样做 
I could do this like this.

1431
01:12:39,740 --> 01:12:44,450
如果我知道我要去哪里 也许我是一个经验丰富的程序员 让我继续前进
If I know where I'm going, maybe I'm a seasoned programmer, let me go ahead

1432
01:12:44,450 --> 01:12:45,060
然后这样做 
and do this.

1433
01:12:45,060 --> 01:12:48,530
让我打印一个正方形 它的宽度和高度是3 
Let me print out a square, the width, and the height of which is 3.

1434
01:12:48,530 --> 01:12:49,487
这是一个抽象的概念 
That's an abstraction.

1435
01:12:49,487 --> 01:12:52,070
我只是认为那一刻是理所当然的
I'm just taking for granted for a moment that there is already

1436
01:12:52,070 --> 01:12:56,180
一个名为打印正方形的函数 它的高度为3
a function called print square that's going to be with 3 and height 3

1437
01:12:56,180 --> 01:12:57,068
也是 
as well.

1438
01:12:57,068 --> 01:12:59,360
但总得有人来实施这一点 而目前 
But someone's got to implement this, and at the moment,

1439
01:12:59,360 --> 01:13:01,580
键盘上只有我一个人 我们继续吧
there's only me at the keyboard, so let's go ahead

1440
01:13:01,580 --> 01:13:03,020
并实施那个方块 
and implement that square.

1441
01:13:03,020 --> 01:13:05,000
让我们继续定义一个名为
Let me go ahead and define a function called

1442
01:13:05,000 --> 01:13:10,250
打印具有特定大小的正方形 包括高度和宽度 
print square that takes in a specific size, both for height and for width.

1443
01:13:10,250 --> 01:13:13,310
这是我们有机会使用其中一些循环的地方 
And here's where we have an opportunity to use some of those loops.

1444
01:13:13,310 --> 01:13:16,250
我们可以以一种我们还没有使用过的方式来使用这些循环 
And we can use those loops in a way we haven't yet.

1445
01:13:16,250 --> 01:13:21,500
如果我想打印出所有这些行 但也要打印出所有这些列 
If I want to print out all of these rows, but also, all of these columns,

1446
01:13:21,500 --> 01:13:24,620
我现在要思考的不仅仅是循环所允许的循环 
I now have to think not just cyclically like a loop allows,

1447
01:13:24,620 --> 01:13:26,960
但我需要从两个维度来思考 
but I need to think two-dimensionally.

1448
01:13:26,960 --> 01:13:30,560
如果你熟悉老式打字机甚至打印机
And if you're familiar with like an old school typewriter or even a printer

1449
01:13:30,560 --> 01:13:33,570
现在 它通常从上到下打印 
nowadays, it generally prints from top to bottom.

1450
01:13:33,570 --> 01:13:38,550
因此 即使您有多列 您也可以一次打印一行 
So even if you have multiple columns, you print out one line at a time,

1451
01:13:38,550 --> 01:13:41,360
当你在那条线上时 打印机或打字机
and while you're on that line, the printer or the typewriter

1452
01:13:41,360 --> 01:13:42,750
指纹从左到右 
prints from left to right.

1453
01:13:42,750 --> 01:13:46,550
这就是你的黑白终端窗口应该具备的心理模型 
And that's the mental model to have with your black and white terminal window.

1454
01:13:46,550 --> 01:13:50,810
到目前为止 每个示例的所有输出都是从顶部开始的
All of the output for every example thus far starts at the top

1455
01:13:50,810 --> 01:13:52,340
跌到了谷底 
and goes down to the bottom.

1456
01:13:52,340 --> 01:13:54,120
从上到下 从左到右 
From top to bottom, left to right.

1457
01:13:54,120 --> 01:13:58,770
所以我们必须以同样的方式产生我们的输出 我们的平方 
So we have to generate our output, our square in that same way.

1458
01:13:58,770 --> 01:14:01,070
所以让我提议我们这样做 
So let me propose that we do this.

1459
01:14:01,070 --> 01:14:04,790
让我建议我们知道我们需要迭代多次 3次或更多
Let me propose that we know we need to iterate this many times, 3 or more

1460
01:14:04,790 --> 01:14:05,810
一般大小 
generally size.

1461
01:14:05,810 --> 01:14:06,560
那就让我来做吧 
So let me do this.

1462
01:14:06,560 --> 01:14:12,200
对于尺码范围内的我来说 我需要做三次什么？
For i in the range of size, what do I need to do three times?

1463
01:14:12,200 --> 01:14:14,520
好吧 我想打印出什么？
Well, I want to print out what?

1464
01:14:14,520 --> 01:14:17,790
1、2、3排砖 
1, 2, 3 rows of bricks.

1465
01:14:17,790 --> 01:14:20,850
但在每一行砖块中 我想打印什么？
But within each row of bricks, what do I want to print?

1466
01:14:20,850 --> 01:14:24,220
具体是1、2、3块砖 
1, 2, 3 bricks specifically.

1467
01:14:24,220 --> 01:14:26,790
所以如果我们回到我们这里的图表 我
So if we go back to our diagram here and I

1468
01:14:26,790 --> 01:14:33,700
规定它确实应该是一个3乘3的正方形 3宽3高 
stipulate that it's indeed meant to be a 3-by-3 square, 3 wide and 3 tall,

1469
01:14:33,700 --> 01:14:35,880
要打印第一行 我想做什么？
what did I want to do to print the first row?

1470
01:14:35,880 --> 01:14:40,095
我想印砖头 砖头 
I want to print brick brick, brick.

1471
01:14:40,095 --> 01:14:42,720
我想在第二行打印什么？砖头 砖头 砖头 
What do I want to print on the second row? brick, brick, brick.

1472
01:14:42,720 --> 01:14:44,580
第三排 砖头 
And the third row, brick, brick, brick.

1473
01:14:44,580 --> 01:14:48,390
所以我做了三件事 三次 
So I'm doing three things three times.

1474
01:14:48,390 --> 01:14:50,650
必须进行大量的打印工作 
There's a lot of printing that must happen.

1475
01:14:50,650 --> 01:14:53,670
所以让我回到我的代码 现在让我求婚
So let me go back to my code here and let me propose now

1476
01:14:53,670 --> 01:14:57,540
我们想到了我刚刚开始的这个外环
that we think of this outer loop that I've just started

1477
01:14:57,540 --> 01:15:00,960
代表我们的每一排 
as representing each of our rows.

1478
01:15:00,960 --> 01:15:04,950
因为我在一定的尺寸范围内将确保 无论
For i in range of size is going to ensure, no matter

1479
01:15:04,950 --> 01:15:10,920
接下来我要做的是 我可以打印出1、2、3行 或者更一般的情况 
what I do next, that I can print out 1, 2, 3 rows, or more generally,

1480
01:15:10,920 --> 01:15:15,030
大小 其中大小可以是3 但可以更小或更大 
size, where size could be 3, but it could be smaller or larger.

1481
01:15:15,030 --> 01:15:17,520
我想在每一行上做什么？
What do I want to do on each of the rows?

1482
01:15:17,520 --> 01:15:21,270
嗯 就像一台老式打字机或打印机 每一排 
Well, just like an old school typewriter or printer, on each row,

1483
01:15:21,270 --> 01:15:24,420
我想打印出砖 砖 砖；砖 
I want to print out brick, brick, brick; brick, brick, brick; brick, brick,

1484
01:15:24,420 --> 01:15:25,470
布里克 
brick.

1485
01:15:25,470 --> 01:15:28,260
嗯 听起来像是一个循环 某种循环 
Well, that sounds like a cycle, some kind of loop.

1486
01:15:28,260 --> 01:15:31,740
所以也许我可以在一个循环中有另一个循环 
So maybe I can have inside of one loop another loop.

1487
01:15:31,740 --> 01:15:35,100
我不想再次使用i 因为我不想使用相同的变量
I don't want to use i again because I don't want to use the same variable

1488
01:15:35,100 --> 01:15:36,450
弄乱了我的计数 
and mess up my counting.

1489
01:15:36,450 --> 01:15:38,860
所以我将按照惯例使用j 
So I'm going to by convention use j.

1490
01:15:38,860 --> 01:15:41,460
非常常见的用法是先用i 然后用j--也许用k 
Very common to use i and then j-- maybe k,

1491
01:15:41,460 --> 01:15:44,800
但在那之后 你们不应该一直在彼此的身体里筑巢 
but after that, you shouldn't keep nesting inside of each other.

1492
01:15:44,800 --> 01:15:47,790
让我继续说 对于大小为2的j 
Let me go ahead and say for j in range of size 2,

1493
01:15:47,790 --> 01:15:50,940
因为它是一个正方形 然后每一排 
because it's a square, and then each of these rows,

1494
01:15:50,940 --> 01:15:57,660
让我打印出一个散列 但没有新行 但在每行之后 
let me print out a single hash, but no new line, but after each row,

1495
01:15:57,660 --> 01:16:00,750
让我只打印一行新行 
let me print only a new line.

1496
01:16:00,750 --> 01:16:03,720
所以这里发生了很多事情 特别是如果你从来没有
So there's a lot going on here, especially if you've never

1497
01:16:03,720 --> 01:16:08,220
触摸到了Python 更不用说循环了 但请注意我在这里也做了什么 
touched Python, let alone loops, but notice what I've done here, too,

1498
01:16:08,220 --> 01:16:10,800
为了清楚起见 我会补充一些评论 
and I'll add some comments for clarity.

1499
01:16:10,800 --> 01:16:22,300
对于正方形的每一行 对于每一行的每一块砖 打印砖块 
For each row in square, for each brick in row, print brick.

1500
01:16:22,300 --> 01:16:25,330
这里是评论的地方 更广泛地说 
And here is where comments, and more generally,

1501
01:16:25,330 --> 01:16:28,990
伪代码真的可以帮助你向自己和他人解释
pseudocode can really help explain to yourself and to others

1502
01:16:28,990 --> 01:16:30,820
您的代码行在做什么 
what your lines of code are doing.

1503
01:16:30,820 --> 01:16:35,410
在第8行 我从i等于0开始迭代 直到大小 
On line 8, I'm iterating from i equals 0 on up to size.

1504
01:16:35,410 --> 01:16:37,180
所以0 1 2 
So 0, 1, 2.

1505
01:16:37,180 --> 01:16:41,560
在第11行 我做了完全相同的事情 但使用了0 1 2中的j 
On line 11, I'm doing the exact same thing, but using j from 0, 1, 2.

1506
01:16:41,560 --> 01:16:45,490
但这很好 因为我代表了我的每一行 
But that's good, because i represents how each of my rows.

1507
01:16:45,490 --> 01:16:49,300
当我在这些行中的每一行 在这个外部循环内时 
And while I'm on each of those rows, inside of this outer loop,

1508
01:16:49,300 --> 01:16:53,110
我要做砖 砖 砖；1 2 3；1 2 3；1 2 3 
I'm going to do brick, brick, brick; 1, 2, 3; 1, 2, 3; 1, 2, 3.

1509
01:16:53,110 --> 01:16:56,830
但我不希望我的光标一直移动到下一行
But I don't want my cursor to keep moving to the next line

1510
01:16:56,830 --> 01:17:01,260
当我在一排的时候 所以我只是在重写那行结尾 
while I'm on a row, so I'm just overriding that line ending.

1511
01:17:01,260 --> 01:17:03,010
但让我问你一个关于这个团体的问题
But let me ask you a question of the group

1512
01:17:03,010 --> 01:17:10,160
现在 为什么我在第16行有一个单独的指纹？
now, why on line 16 do I have a print here all by itself?

1513
01:17:10,160 --> 01:17:13,820
为什么我有一个单独的指纹呢？
Why do I have a print all by itself?

1514
01:17:13,820 --> 01:17:19,180
请注意 它位于内部循环的下方 但在内部
Notice that it's below the inner loop, but inside

1515
01:17:19,180 --> 01:17:22,300
可以说是外环的 
of the outer loop, so to speak.

1516
01:17:22,300 --> 01:17:26,650
第16行上的循环最终要做什么？
What is that loop on line 16 doing ultimately?

1517
01:17:26,650 --> 01:17:29,080
观众：你每完成一行 你就会
AUDIENCE: Every time you finish a line, you

1518
01:17:29,080 --> 01:17:33,490
我得在它的末尾加一行 
have to add a new line at the end of it.

1519
01:17:33,490 --> 01:17:36,905
所以Print 它打印新的一行 
So print, it prints a new line.

1520
01:17:36,905 --> 01:17:37,780
大卫·马兰：太好了 
DAVID MALAN: Perfect.

1521
01:17:37,780 --> 01:17:40,330
我不想在每一块砖之后都换一条新的线 
I don't want a new line after every brick.

1522
01:17:40,330 --> 01:17:42,670
我只想在这一排结束时这样做 
I only want to do that at the end of the row,

1523
01:17:42,670 --> 01:17:45,460
这就是为什么我现在的评论可能是有启发性的 
and that's why my comments now are perhaps enlightening.

1524
01:17:45,460 --> 01:17:51,460
注意 这里的这个循环只是对行中的每一块砖进行迭代 
Notice that this loop here is just iterating for each brick in the row.

1525
01:17:51,460 --> 01:17:54,190
可以说 一旦我完成了内部循环 
Once I'm done with that inner loop, so to speak,

1526
01:17:54,190 --> 01:17:57,760
一旦我完成了这些突出显示的行 按照伊夫林的观点 
once I'm done with these highlighted lines here, to Evelyn's point,

1527
01:17:57,760 --> 01:17:59,927
我需要打印出一个空白的新行 
I need to print out one blank new line.

1528
01:17:59,927 --> 01:18:03,010
我们以前没有这样做过 但是当您不带参数地调用print时 
And we've not done this before, but when you call print with no arguments,

1529
01:18:03,010 --> 01:18:05,770
你得到的只是自动结束的行号 
all you get is that automatic line ending,

1530
01:18:05,770 --> 01:18:09,110
光标移动到下一行的反斜杠n 
the backslash n where the cursor moves to the next line.

1531
01:18:09,110 --> 01:18:13,540
所以如果我现在返回到我的终端窗口并运行mario.py 
So if I now go back to my terminal window and run mario.py,

1532
01:18:13,540 --> 01:18:16,653
我想我应该买一个3乘3的正方形 
I think I should get a 3-by-3 square.

1533
01:18:16,653 --> 01:18:18,820
而且它在我的屏幕上看起来不太像一个正方形
And it doesn't quite look like a square on my screen

1534
01:18:18,820 --> 01:18:22,300
因为这些散列比它们的宽度稍高一些 但事实上 
because these hashes are a little taller than they are wide, but it is, in fact,

1535
01:18:22,300 --> 01:18:23,680
3x3 
3-by-3.

1536
01:18:23,680 --> 01:18:26,140
但让我提议 就像我们在这里一贯做的那样 如何
But let me propose, as we've always done here, how

1537
01:18:26,140 --> 01:18:28,030
我们可能会进一步收紧这一代码 
we might tighten up this code further.

1538
01:18:28,030 --> 01:18:32,050
为了清楚起见 让我暂时抛开我的评论
Just for clarity's sake, let me get rid of my comments for a moment

1539
01:18:32,050 --> 01:18:35,680
这样我们就可以看到我们总共有多少行代码 
just so we can see how many lines of code we have total.

1540
01:18:35,680 --> 01:18:39,040
让我提议我们或许可以这样做 
And let me propose that we maybe do this.

1541
01:18:39,040 --> 01:18:41,737
让我提议 你知道吗 这个内部循环 
Let me propose that, you know what, this inner loop,

1542
01:18:41,737 --> 01:18:43,570
尤其是如果你在包装上有困难的话
especially if you're having trouble wrapping

1543
01:18:43,570 --> 01:18:46,360
你的思想围绕着另一个循环中的一个循环 
your mind around one loop inside of another loop,

1544
01:18:46,360 --> 01:18:47,710
你并不完全需要它 
you don't strictly need it.

1545
01:18:47,710 --> 01:18:49,270
如果我们再来一次这个把戏呢？
What if we do this trick again?

1546
01:18:49,270 --> 01:18:54,130
如果我们在外部循环中打印出来 并且只有每个循环
What if we print out inside of the outer and only loop each

1547
01:18:54,130 --> 01:18:57,910
这些散列的次数是我们想要的次数的倍数吗？
of those hashes times the number of times we want them?

1548
01:18:57,910 --> 01:19:00,400
我们从早期的方法中获得灵感
We draw inspiration from an earlier approach

1549
01:19:00,400 --> 01:19:03,980
现在我们在mario.py上运行Python 同样的结果 
and we run Python now of mario.py, same result,

1550
01:19:03,980 --> 01:19:07,480
但现在 Print Square真的很漂亮 很紧凑 
but now, print square is really nice and compact.

1551
01:19:07,480 --> 01:19:10,810
它有一个显式循环 并且仍在打印输出
It has one explicit loop, and it's still printing out

1552
01:19:10,810 --> 01:19:15,340
使用字符串乘法一次将该行上的所有散列相乘 
using string multiplication all of the hashes at once on that row.

1553
01:19:15,340 --> 01:19:19,600
如果您喜欢抽象 并且您想更多地考虑
If you like abstraction and you'd like to wrap your mind more around what

1554
01:19:19,600 --> 01:19:21,580
代码是这样做的 好吧 让我们这样做 
the code is doing, well, let's do this.

1555
01:19:21,580 --> 01:19:23,770
如果你不太清楚发生了什么事 
If you're not quite clear on what's going on,

1556
01:19:23,770 --> 01:19:25,870
让我们建议您实现一个名为
let's propose that you implement a function called

1557
01:19:25,870 --> 01:19:28,150
打印行 传入大小 
print row, passing in size.

1558
01:19:28,150 --> 01:19:33,850
让我建议这个打印行函数 它只接受这个宽度
And let me propose that this print row function, it simply take in that width

1559
01:19:33,850 --> 01:19:39,260
并多次打印出单个散列的次数 
and print out the individual hash times that many times.

1560
01:19:39,260 --> 01:19:43,870
换句话说 这是一个抽象的机会 由此 嗯 什么
In other words, here's an opportunity for abstraction, whereby, well, what

1561
01:19:43,870 --> 01:19:45,157
是指打印一行吗？
does it mean to print a row?

1562
01:19:45,157 --> 01:19:46,990
嗯 当您实现Print Square时 
Well, when you're implementing print square,

1563
01:19:46,990 --> 01:19:49,720
我真的不在乎打印一行意味着什么 
I don't really care what it means to print a row,

1564
01:19:49,720 --> 01:19:53,440
我只想知道有没有人负责打印这行 
I just need to know that someone's taking care of printing the row.

1565
01:19:53,440 --> 01:19:56,740
您完全可以将责任转嫁给另一个函数 
You can pass the buck to another function altogether.

1566
01:19:56,740 --> 01:19:58,360
打印行是如何工作的？
And how does print row work?

1567
01:19:58,360 --> 01:20:02,500
它可以使用for循环 它可以使用这个字符串乘法技巧 
Well, it could use a for loop, it could use this string multiplication trick.

1568
01:20:02,500 --> 01:20:05,980
这是一种采用更大程序的方法--这可能是
This is a way to take a larger program-- and this is probably the most

1569
01:20:05,980 --> 01:20:08,120
到目前为止我们已经看到了一个复杂的问题--
complicated one we've looked at thus far--

1570
01:20:08,120 --> 01:20:13,600
然后把它分解成这些更小的组件 一旦组装好 
and to decompose it into these smaller components, that once assembled,

1571
01:20:13,600 --> 01:20:16,390
实现你的最终想法 
achieve your final idea.

1572
01:20:16,390 --> 01:20:19,780
看不到任何问题 我们对循环的了解就到此结束
Seeing no questions, that's the end of our look at loops

1573
01:20:19,780 --> 01:20:22,900
在Python中 这种一次又一次循环地做事情的能力 
in Python, this ability to do things cyclically again and again,

1574
01:20:22,900 --> 01:20:25,480
当我们把它们和条件句结合起来时 这种能力
and when we combine those with conditionals, this ability

1575
01:20:25,480 --> 01:20:28,870
提问和回答问题 并将它们与我们的函数和变量相结合 
to ask and answer questions and combine them with our functions and variables,

1576
01:20:28,870 --> 01:20:31,450
我们现在真的拥有了大部分的构建块
we really now have most of the building blocks

1577
01:20:31,450 --> 01:20:34,060
我们需要解决更大、更有趣、更多
we need to solve much larger, much more interesting, much

1578
01:20:34,060 --> 01:20:35,260
更多的私人问题 
more personal questions.

1579
01:20:35,260 --> 01:20:39,100
因此 在接下来的几周里 我们将开始确切地看到可能会出现什么问题 
So in the weeks to come, we'll start to see exactly what could go wrong,

1580
01:20:39,100 --> 01:20:41,080
虽然 当我们这样做的时候 但我们会为你介绍
though, when we do so, but we'll introduce you

1581
01:20:41,080 --> 01:20:45,600
到所有更多的工具 您可以通过这些工具来解决这些相同的问题 
to all the more tools via which you can troubleshoot those same problems.

