1
00:00:00,000 --> 00:00:03,458
[CLASSICAL MUSIC]

2
00:00:23,875 --> 00:00:26,583
DAVID J. MALAN: All right,
this is CS50's Introduction

3
00:00:26,583 --> 00:00:27,916
to Programming with Python.

4
00:00:27,916 --> 00:00:31,541
My name is David Malan, and this is our
week on object-oriented programming,

5
00:00:31,541 --> 00:00:32,791
or OOP.

6
00:00:32,791 --> 00:00:34,750
It turns out that, in
the world of programming,

7
00:00:34,750 --> 00:00:37,583
there's different paradigms
of programming languages.

8
00:00:37,583 --> 00:00:40,208
There's different ways of
solving problems with code,

9
00:00:40,208 --> 00:00:42,000
and it's a little hard
to see this at first

10
00:00:42,000 --> 00:00:43,916
if you've only learned one language.

11
00:00:43,916 --> 00:00:47,416
But over time, if and when you learn
other languages besides Python,

12
00:00:47,416 --> 00:00:50,083
you'll start to notice certain
patterns and certain capabilities

13
00:00:50,083 --> 00:00:52,000
of some languages but not another.

14
00:00:52,000 --> 00:00:54,791
Thus far, within the
world of Python, you and I

15
00:00:54,791 --> 00:00:58,541
have largely been writing code that's
procedural in nature, whereby we're

16
00:00:58,541 --> 00:01:00,708
writing procedures;
we're writing functions;

17
00:01:00,708 --> 00:01:03,166
and we're doing things top to bottom.

18
00:01:03,166 --> 00:01:05,458
Everything is step by
step by step, as you would

19
00:01:05,458 --> 00:01:07,208
expect in general from an algorithm.

20
00:01:07,208 --> 00:01:09,250
But along the way,
we've actually dabbled

21
00:01:09,250 --> 00:01:14,083
in another paradigm known as functional
programming with Python whereby we've

22
00:01:14,083 --> 00:01:15,875
been able to pass functions around.

23
00:01:15,875 --> 00:01:18,666
We even had an anonymous
function some weeks ago.

24
00:01:18,666 --> 00:01:22,500
And that's evidence of features of
a functional programming language,

25
00:01:22,500 --> 00:01:24,708
even though we've just
scratched the surface thereof.

26
00:01:24,708 --> 00:01:28,083
Today we focus on another paradigm,
and this one in more detail--

27
00:01:28,083 --> 00:01:30,166
namely object-oriented programming.

28
00:01:30,166 --> 00:01:32,958
And now, while some of you might
have prior programming experience

29
00:01:32,958 --> 00:01:36,500
and have learned languages like Java,
which are, by design, fundamentally

30
00:01:36,500 --> 00:01:40,291
object-oriented, Python indeed
allows you a bit of flexibility

31
00:01:40,291 --> 00:01:43,250
when it comes to how you
solve problems with code.

32
00:01:43,250 --> 00:01:46,458
But it turns out
object-oriented programming

33
00:01:46,458 --> 00:01:49,000
is a pretty compelling
solution to problems

34
00:01:49,000 --> 00:01:52,666
that you invariably encounter as
your programs get longer, larger,

35
00:01:52,666 --> 00:01:54,375
and more complicated.

36
00:01:54,375 --> 00:01:56,333
So indeed, OOP, for
our purposes, is going

37
00:01:56,333 --> 00:02:00,791
to be a solution to a problem that
builds on so many of the lessons past.

38
00:02:00,791 --> 00:02:02,458
So let's go ahead and do this.

39
00:02:02,458 --> 00:02:05,833
Let's start by writing a
program very procedurally

40
00:02:05,833 --> 00:02:07,625
by opening up VS Code here.

41
00:02:07,625 --> 00:02:10,875
I'm going to go ahead and create
a program called student.py.

42
00:02:10,875 --> 00:02:14,083
And in this program, I want to
do something relatively simple

43
00:02:14,083 --> 00:02:18,375
initially, as we might have done
some weeks ago now, where I just

44
00:02:18,375 --> 00:02:22,166
ask a user for their name and, maybe
in the context of the Harry Potter

45
00:02:22,166 --> 00:02:26,291
universe, their house, and just
print out where that student is from.

46
00:02:26,291 --> 00:02:30,166
And let's gradually enhance this program
by adding more and more features to it

47
00:02:30,166 --> 00:02:33,875
and see if we don't stumble upon
problems that, up until now,

48
00:02:33,875 --> 00:02:36,958
we might not have had very elegant,
well-designed solutions to.

49
00:02:36,958 --> 00:02:40,250
But if we introduce, explicitly,
object-oriented programming

50
00:02:40,250 --> 00:02:43,250
as a programming technique, I
bet we can clean up our code

51
00:02:43,250 --> 00:02:47,208
and set the stage for writing even more
sophisticated programs, longer programs

52
00:02:47,208 --> 00:02:48,083
down the line.

53
00:02:48,083 --> 00:02:51,791
So in student.py, let me go
ahead and do a name variable,

54
00:02:51,791 --> 00:02:54,250
setting it equal to the
return value of input,

55
00:02:54,250 --> 00:02:57,041
and just prompt the user
for their name like this.

56
00:02:57,041 --> 00:02:59,791
And then let me go ahead and do
the same for a house variable

57
00:02:59,791 --> 00:03:03,041
and prompt the user for their
house, using input like this.

58
00:03:03,041 --> 00:03:05,208
And let's do something super simple now.

59
00:03:05,208 --> 00:03:07,875
Let's just go ahead and
print out an f string

60
00:03:07,875 --> 00:03:11,291
that says something
like name from house,

61
00:03:11,291 --> 00:03:13,958
just so that I can confirm that
the contents of these variables

62
00:03:13,958 --> 00:03:15,000
are indeed as I expect.

63
00:03:15,000 --> 00:03:17,083
I'm not going to do any
error checking or trimming

64
00:03:17,083 --> 00:03:18,333
or anything like that for now.

65
00:03:18,333 --> 00:03:21,416
I'm really just going to spit back
out whatever the user just typed in.

66
00:03:21,416 --> 00:03:24,375
All right, let me go ahead
and run Python of student.py.

67
00:03:24,375 --> 00:03:29,083
Let's use our go-to, like Harry, as
in Harry Potter, from Gryffindor.

68
00:03:29,083 --> 00:03:32,958
And when I hit Enter, now let's see
if I see that Harry from Gryffindor

69
00:03:32,958 --> 00:03:34,041
is indeed the case.

70
00:03:34,041 --> 00:03:37,375
All right, so I think we have a working
program at this point, but let's

71
00:03:37,375 --> 00:03:40,541
now introduce some of those lessons
learned way back from week zero

72
00:03:40,541 --> 00:03:42,583
where we started writing
our own functions,

73
00:03:42,583 --> 00:03:46,250
not necessarily because it solves
the problem more correctly--

74
00:03:46,250 --> 00:03:47,916
I daresay this is correct as is.

75
00:03:47,916 --> 00:03:52,041
But it begins to give us building
blocks that we can extend so

76
00:03:52,041 --> 00:03:54,125
as to solve more complicated programs.

77
00:03:54,125 --> 00:03:58,375
So let me go back up to student.py,
and let's go ahead now and do this.

78
00:03:58,375 --> 00:04:01,875
Let's put the entire logic I just
wrote inside of our typical method

79
00:04:01,875 --> 00:04:05,458
called main, and let me indent those
three lines so that at least they're

80
00:04:05,458 --> 00:04:07,333
now combined into one main method.

81
00:04:07,333 --> 00:04:12,208
But instead of using input
on line 2 an input on line 3,

82
00:04:12,208 --> 00:04:14,083
don't we go ahead and
assume, for the moment,

83
00:04:14,083 --> 00:04:17,000
that we've got some function
called get_name in the world,

84
00:04:17,000 --> 00:04:19,958
and let's go ahead and assume we've
got another function like get_house

85
00:04:19,958 --> 00:04:21,708
in the world that don't take parameters.

86
00:04:21,708 --> 00:04:24,166
But their purpose in
life is, by their name,

87
00:04:24,166 --> 00:04:28,458
going to be to get the user's name and
to get their users house, respectively.

88
00:04:28,458 --> 00:04:32,083
And then I'm going to print out
the exact same f string as before.

89
00:04:32,083 --> 00:04:34,333
I, of course, need to
implement these functions now.

90
00:04:34,333 --> 00:04:38,291
So let me go lower in my file and
define a function called get_name.

91
00:04:38,291 --> 00:04:41,375
Nothing in these parentheses because
it's not going to take a parameter.

92
00:04:41,375 --> 00:04:44,083
And I'm going to go ahead and do
something like name equals input

93
00:04:44,083 --> 00:04:48,750
("Name"), just like before, and then
I'm going to go ahead and return name.

94
00:04:48,750 --> 00:04:52,000
So it's a super simple function,
but it's an abstraction.

95
00:04:52,000 --> 00:04:55,458
I now have a function called
get_name whose implementation details

96
00:04:55,458 --> 00:04:56,916
I don't have to care about anymore.

97
00:04:56,916 --> 00:04:58,458
I just know that the function exists.

98
00:04:58,458 --> 00:05:00,250
And I can tighten this up, in fact, .

99
00:05:00,250 --> 00:05:02,875
Don't really need a
name variable on line 8

100
00:05:02,875 --> 00:05:05,875
if I'm immediately going to return
that same name variable on line 9.

101
00:05:05,875 --> 00:05:07,833
So let me just tighten
this up a little bit

102
00:05:07,833 --> 00:05:09,791
even though it doesn't
change the functionality

103
00:05:09,791 --> 00:05:15,750
and just immediately return the return
value of the inputs function call here.

104
00:05:15,750 --> 00:05:18,916
Let's do something very
similar now for get_house,

105
00:05:18,916 --> 00:05:20,750
which will similarly take no arguments.

106
00:05:20,750 --> 00:05:22,666
I'm going to go ahead
and return the return

107
00:05:22,666 --> 00:05:25,541
value of input, this time
prompting the user for their house.

108
00:05:25,541 --> 00:05:27,250
And I need one final detail.

109
00:05:27,250 --> 00:05:32,208
At the very bottom, let's continue our
habit of doing if the name of this file

110
00:05:32,208 --> 00:05:35,750
equals, equals, quote, unquote,
main, then let's go ahead

111
00:05:35,750 --> 00:05:38,875
and actually call main and
recall that we have that in place

112
00:05:38,875 --> 00:05:42,458
so that, if this eventually becomes
part of a module, a library of sorts,

113
00:05:42,458 --> 00:05:44,791
I don't accidentally call main blindly.

114
00:05:44,791 --> 00:05:50,250
I only do it if I mean to run main
from the command line on this file.

115
00:05:50,250 --> 00:05:53,458
All right, so if I didn't make
any mistakes here, let me go ahead

116
00:05:53,458 --> 00:05:57,416
and, in my terminal window, again,
run Python of student.py, Enter.

117
00:05:57,416 --> 00:05:59,250
Let's type in Harry, Enter.

118
00:05:59,250 --> 00:06:01,541
Let's type in Gryffindor, Enter.

119
00:06:01,541 --> 00:06:02,875
And we're set.

120
00:06:02,875 --> 00:06:05,583
Harry from Gryffindor
seems to still be working.

121
00:06:05,583 --> 00:06:09,416
So we haven't really solved
the problem any more correctly,

122
00:06:09,416 --> 00:06:11,875
but I've laid the
foundation to maybe now do

123
00:06:11,875 --> 00:06:13,583
some more interesting
things because I've

124
00:06:13,583 --> 00:06:16,875
had these building blocks in place.

125
00:06:16,875 --> 00:06:21,083
But let me propose that we could be
doing this a little bit differently.

126
00:06:21,083 --> 00:06:23,000
get_name, get_house is fine.

127
00:06:23,000 --> 00:06:26,416
But at the end of the day, I'm really
trying to get a student from the user.

128
00:06:26,416 --> 00:06:30,083
I want their name and their
house, not just one or the other.

129
00:06:30,083 --> 00:06:32,833
So maybe it would be
a little cleaner still

130
00:06:32,833 --> 00:06:36,083
to define a function
called get_student and let

131
00:06:36,083 --> 00:06:38,291
get_student do all of this work for us.

132
00:06:38,291 --> 00:06:43,000
Now, theoretically, get_student could
call get_name and could call get_house.

133
00:06:43,000 --> 00:06:44,750
But because these
functions are so short,

134
00:06:44,750 --> 00:06:48,875
I think I'm OK with just defining
one function, called get_student,

135
00:06:48,875 --> 00:06:50,666
that similarly won't take any arguments.

136
00:06:50,666 --> 00:06:52,250
But it's going to do two things.

137
00:06:52,250 --> 00:06:55,875
It's going to get the students name,
by prompting them with input as before.

138
00:06:55,875 --> 00:06:57,625
And it's going to get
the student's house,

139
00:06:57,625 --> 00:07:01,125
by also prompting them as before.

140
00:07:01,125 --> 00:07:02,416
Now, hmm.

141
00:07:02,416 --> 00:07:04,833
I want to return the
student, but I think

142
00:07:04,833 --> 00:07:06,875
I might have painted
myself into a corner

143
00:07:06,875 --> 00:07:10,125
here because I now have two
variables-- name and house.

144
00:07:10,125 --> 00:07:13,250
And yet, up until now, we've pretty
much returned one or the other.

145
00:07:13,250 --> 00:07:15,000
We've returned one value.

146
00:07:15,000 --> 00:07:17,500
So any suggestions
for how we can perhaps

147
00:07:17,500 --> 00:07:22,375
solve this problem that I just created
for myself, whereby I want to return,

148
00:07:22,375 --> 00:07:28,083
really, a student, but I currently have
a name variable and a house variable.

149
00:07:28,083 --> 00:07:30,541
I'd minimally like to
return both of those.

150
00:07:30,541 --> 00:07:33,208
AUDIENCE: I believe that,
we can return a dictionary,

151
00:07:33,208 --> 00:07:35,000
includes the name and the house.

152
00:07:35,000 --> 00:07:36,833
DAVID J. MALAN: Yeah,
so we absolutely could

153
00:07:36,833 --> 00:07:41,000
return a dictionary-- a dict object in
Python, whereby maybe one key is name;

154
00:07:41,000 --> 00:07:43,666
one key is house; and the
values thereof are exactly

155
00:07:43,666 --> 00:07:44,916
the values of these variables.

156
00:07:44,916 --> 00:07:46,791
So we could totally do that.

157
00:07:46,791 --> 00:07:49,375
I worry that that might be
getting a little complicated.

158
00:07:49,375 --> 00:07:51,916
I wonder if there's a
simpler way instead.

159
00:07:51,916 --> 00:07:55,000
Any other instincts-- even if
you're not sure it would work?

160
00:07:55,000 --> 00:07:56,541
AUDIENCE: Return both name and house?

161
00:07:56,541 --> 00:07:58,333
DAVID J. MALAN: Return
both name and house.

162
00:07:58,333 --> 00:07:59,416
I like the sound of that.

163
00:07:59,416 --> 00:08:00,250
It sounds simple.

164
00:08:00,250 --> 00:08:03,041
I don't have to figure out what a
dictionary is going to look like.

165
00:08:03,041 --> 00:08:05,750
And in fact, this, too,
would be a valid approach,

166
00:08:05,750 --> 00:08:07,250
even if you've not seen this before.

167
00:08:07,250 --> 00:08:11,625
It turns out, in Python, that
you can return multiple values,

168
00:08:11,625 --> 00:08:12,958
but that's a bit of a white lie.

169
00:08:12,958 --> 00:08:16,333
Or we could take Muhammad's approach
of actually returning a dictionary

170
00:08:16,333 --> 00:08:17,833
and putting multiple keys therein.

171
00:08:17,833 --> 00:08:19,833
So here, again, we have
yet another example

172
00:08:19,833 --> 00:08:22,375
of how you can solve the same
problem in at least two ways,

173
00:08:22,375 --> 00:08:24,708
and I daresay we're
about to see even more.

174
00:08:24,708 --> 00:08:27,916
So one way you could solve
this problem, whereby

175
00:08:27,916 --> 00:08:32,916
you want to return multiple values,
would be to do something like this.

176
00:08:32,916 --> 00:08:37,666
I could go ahead and literally return
not just name, but I could put a comma

177
00:08:37,666 --> 00:08:39,250
and also return house.

178
00:08:39,250 --> 00:08:41,958
This is not necessarily something
you can do in other languages

179
00:08:41,958 --> 00:08:44,166
if you have programmed in
other languages before.

180
00:08:44,166 --> 00:08:45,416
It depends on the language.

181
00:08:45,416 --> 00:08:49,291
But it looks like, thanks to
this comma, maybe I can, in fact,

182
00:08:49,291 --> 00:08:51,916
return two values as
[INAUDIBLE] proposed.

183
00:08:51,916 --> 00:08:55,375
Well, if I'm returning to
values in this way on line 10,

184
00:08:55,375 --> 00:08:57,916
how do I get both
values at the same time?

185
00:08:57,916 --> 00:08:59,208
Well, there's a couple of ways.

186
00:08:59,208 --> 00:09:01,833
Let me go up to my main function.

187
00:09:01,833 --> 00:09:04,416
I know, minimally, I'm going
to have to change the get_name

188
00:09:04,416 --> 00:09:05,958
and get_house to get_student.

189
00:09:05,958 --> 00:09:09,041
But what am I going to
store the return value in?

190
00:09:09,041 --> 00:09:11,500
I think I could actually do this.

191
00:09:11,500 --> 00:09:14,916
And we have seen this technique
before, where you can unpack,

192
00:09:14,916 --> 00:09:17,541
so to speak, sequences of
values that are coming back.

193
00:09:17,541 --> 00:09:21,083
And indeed, consider this
to be exactly that. name,

194
00:09:21,083 --> 00:09:25,000
house is some kind of sequence that
I'm returning of values-- name, house.

195
00:09:25,000 --> 00:09:27,291
So if I want to unpack
those and store the return

196
00:09:27,291 --> 00:09:30,000
values in two separate
variables, I can, in fact,

197
00:09:30,000 --> 00:09:34,208
use the commas on the left-hand side of
my assignment operator, the equal sign,

198
00:09:34,208 --> 00:09:35,416
to do just that.

199
00:09:35,416 --> 00:09:40,000
Now, to be clear, I don't need to call
these variables name and house here.

200
00:09:40,000 --> 00:09:43,500
I could simplify this and
use just n here and h here,

201
00:09:43,500 --> 00:09:46,583
and then I could return just n and h.

202
00:09:46,583 --> 00:09:51,208
But I would argue that's not very clear
to the reader as to what's going on.

203
00:09:51,208 --> 00:09:52,958
So I think, in this
case, even though it's

204
00:09:52,958 --> 00:09:56,000
a coincidence that I've used the
same variable names in get_student

205
00:09:56,000 --> 00:09:59,875
and get_name, and in main, it's a
little more readable to someone like me.

206
00:09:59,875 --> 00:10:01,541
So I'm going to leave it as is.

207
00:10:01,541 --> 00:10:04,041
Well, let's go ahead and
see, now, if this works.

208
00:10:04,041 --> 00:10:07,166
Let me clear my screen down here
and run Python of student.py, Enter.

209
00:10:07,166 --> 00:10:08,375
Let's again type in Harry.

210
00:10:08,375 --> 00:10:11,041
Let's again type in Gryffindor, Enter.

211
00:10:11,041 --> 00:10:14,791
And voila, we still see that
Harry is from Gryffindor.

212
00:10:14,791 --> 00:10:16,958
But what are we actually doing here?

213
00:10:16,958 --> 00:10:19,666
What are we actually doing
by returning this value?

214
00:10:19,666 --> 00:10:24,333
Well, it turns out that what
we've just done is use a tuple.

215
00:10:24,333 --> 00:10:29,791
A tuple is another type of data in
Python that's a collection of values--

216
00:10:29,791 --> 00:10:32,291
x, y or x, y, z.

217
00:10:32,291 --> 00:10:36,750
It's similar in spirit to a list,
in that sense, but it's immutable.

218
00:10:36,750 --> 00:10:37,666
It's not mutable.

219
00:10:37,666 --> 00:10:38,708
Now, what does that mean?

220
00:10:38,708 --> 00:10:41,708
A list, as we've seen it before,
is a data structure in Python

221
00:10:41,708 --> 00:10:43,458
that you can change the values of.

222
00:10:43,458 --> 00:10:47,250
You can go into bracket 0 for the first
location and change the value there.

223
00:10:47,250 --> 00:10:50,208
You can go to bracket 1, bracket
2, bracket 3 and actually change

224
00:10:50,208 --> 00:10:51,458
the values in lists.

225
00:10:51,458 --> 00:10:54,791
But if you have no intention of
changing the values of variables

226
00:10:54,791 --> 00:10:57,750
and you want to return,
effectively, multiple values,

227
00:10:57,750 --> 00:10:59,541
you don't have to even
return it as a list.

228
00:10:59,541 --> 00:11:03,416
You can return it as a tuple
instead, just by using a comma.

229
00:11:03,416 --> 00:11:07,000
And it turns out we can make
explicit that-- here's the white lie.

230
00:11:07,000 --> 00:11:10,500
I'm not actually returning
to values per se.

231
00:11:10,500 --> 00:11:13,416
Whenever you use a comma
in this way on line 9,

232
00:11:13,416 --> 00:11:17,500
you're actually returning
one value, which is a tuple.

233
00:11:17,500 --> 00:11:20,291
Inside of that tuple now are two values.

234
00:11:20,291 --> 00:11:23,791
So it's similar in spirit to
returning one list with two thing Here

235
00:11:23,791 --> 00:11:26,291
I'm returning one tuple with two things.

236
00:11:26,291 --> 00:11:28,958
And the mere fact that I've
used a comma and nothing else

237
00:11:28,958 --> 00:11:31,375
tells Python that I indeed
want to return a tuple.

238
00:11:31,375 --> 00:11:34,083
But there's more explicit
syntax that we can use instead.

239
00:11:34,083 --> 00:11:39,291
I can actually-- more verbosely-- put
explicit parentheses around the values

240
00:11:39,291 --> 00:11:42,458
of this tuple just to make
more clear to me, to the reader

241
00:11:42,458 --> 00:11:44,083
that this isn't two values per se.

242
00:11:44,083 --> 00:11:46,500
This is one value with
two things inside of it.

243
00:11:46,500 --> 00:11:48,458
And what I can actually
do then, too, is--

244
00:11:48,458 --> 00:11:51,000
I don't have to unpack
this up here, so to speak.

245
00:11:51,000 --> 00:11:54,833
I can actually go up here and maybe
give a more apt name, like student,

246
00:11:54,833 --> 00:11:58,375
and I can name the value,
or rather name the variable

247
00:11:58,375 --> 00:12:01,333
in which I'm storing the
return value of get_student as,

248
00:12:01,333 --> 00:12:02,791
quote, unquote, "student."

249
00:12:02,791 --> 00:12:05,166
So maybe this is a
little better design now

250
00:12:05,166 --> 00:12:08,625
because I'm sort of abstracting
away what a student is.

251
00:12:08,625 --> 00:12:11,666
It's implemented at the moment
as a tuple with two values.

252
00:12:11,666 --> 00:12:15,875
But at least, now I have a variable
called what I mean, a student.

253
00:12:15,875 --> 00:12:17,375
But there's going to be a catch.

254
00:12:17,375 --> 00:12:21,583
On line 3, I still want to print out
that student's name and their house.

255
00:12:21,583 --> 00:12:24,541
But I don't have a name variable
anymore, and I don't have a house.

256
00:12:24,541 --> 00:12:28,625
And I also don't have a dictionary, as
was proposed earlier, so I can't even

257
00:12:28,625 --> 00:12:31,833
go at those keys by name.

258
00:12:31,833 --> 00:12:35,166
But what a tuple is-- it's very
similar in spirit to a list,

259
00:12:35,166 --> 00:12:37,000
but it is indeed just immutable.

260
00:12:37,000 --> 00:12:39,791
And what I mean by that is
I can still index into it

261
00:12:39,791 --> 00:12:45,041
numerically by saying
student [0] for the item

262
00:12:45,041 --> 00:12:47,000
in the first location in that tuple.

263
00:12:47,000 --> 00:12:50,416
And then over here, instead of
house, I can say student [1].

264
00:12:50,416 --> 00:12:54,291
student [1] is going to give me
the second location in that tuple.

265
00:12:54,291 --> 00:12:56,166
Let me go ahead and
clear my terminal window.

266
00:12:56,166 --> 00:12:58,083
Again, run Python of student.py.

267
00:12:58,083 --> 00:12:59,250
Let's type in Harry.

268
00:12:59,250 --> 00:13:04,500
Let's type in Gryffindor, Enter,
and we still have some working code.

269
00:13:04,500 --> 00:13:07,208
Let me pause here now
and see if there are

270
00:13:07,208 --> 00:13:11,500
any questions on this
technique of returning a tuple

271
00:13:11,500 --> 00:13:14,750
and indexing into it in this way.

272
00:13:14,750 --> 00:13:17,125
AUDIENCE: I guess, what's
an actual use case where

273
00:13:17,125 --> 00:13:21,333
you would use a tuple versus a list
or something else that's similar?

274
00:13:21,333 --> 00:13:23,166
DAVID J. MALAN: It's a
really good question.

275
00:13:23,166 --> 00:13:25,291
When would you use a
tuple versus a list?

276
00:13:25,291 --> 00:13:28,208
When you want to program
defensively, or, in general,

277
00:13:28,208 --> 00:13:31,375
when you know that the values in
this variable shouldn't change,

278
00:13:31,375 --> 00:13:34,333
so why would you use a data type
that allows them to be changed?

279
00:13:34,333 --> 00:13:37,791
It just invites mistakes,
bugs down the line, either

280
00:13:37,791 --> 00:13:40,666
by you or colleagues who are
interacting with your code.

281
00:13:40,666 --> 00:13:44,083
So tuple is just another
way where you can increase

282
00:13:44,083 --> 00:13:47,708
the probability of correctness by just
not letting anyone, yourself included,

283
00:13:47,708 --> 00:13:49,750
change the contents therein.

284
00:13:49,750 --> 00:13:52,250
So it's just another
tool in your toolkit.

285
00:13:52,250 --> 00:13:55,333
But let's make clear, then,
what I mean by "immutable."

286
00:13:55,333 --> 00:13:58,833
Again, I claim that "immutable" means
that you cannot change the value.

287
00:13:58,833 --> 00:14:01,000
Well, let's go ahead and try to do this.

288
00:14:01,000 --> 00:14:03,750
Let me go ahead and run this
program once more as is--

289
00:14:03,750 --> 00:14:05,291
Python of student.py.

290
00:14:05,291 --> 00:14:09,416
Let me go ahead and
type in, for instance--

291
00:14:09,416 --> 00:14:11,375
how about Padma's name?

292
00:14:11,375 --> 00:14:13,208
And I'm going to go
ahead and say that Padma

293
00:14:13,208 --> 00:14:14,916
is in Gryffindor as in the movies.

294
00:14:14,916 --> 00:14:16,958
And we see-- Padma from Gryffindor.

295
00:14:16,958 --> 00:14:20,791
But technically, I went down this
rabbit hole in looking at Harry Potter

296
00:14:20,791 --> 00:14:21,541
more closely.

297
00:14:21,541 --> 00:14:25,000
Technically, in the books, Padma,
I believe, was from Ravenclaw.

298
00:14:25,000 --> 00:14:27,083
So this is actually a
mistake or an inconsistency

299
00:14:27,083 --> 00:14:28,750
between the movies and the books.

300
00:14:28,750 --> 00:14:31,625
Let's see if we can't fix this
inconsistency in our code.

301
00:14:31,625 --> 00:14:33,208
So how about we do this?

302
00:14:33,208 --> 00:14:36,333
If the student's name that's
inputted equals Padma,

303
00:14:36,333 --> 00:14:40,208
why don't we override
whatever the house is

304
00:14:40,208 --> 00:14:42,875
and change it to be properly Gryffindor.

305
00:14:42,875 --> 00:14:46,083
Let me go ahead and do if student--

306
00:14:46,083 --> 00:14:49,708
now, if I want to get at Padma's name,
I'm going to have to do student [0].

307
00:14:49,708 --> 00:14:52,625
I have to know what location
the name is in in this tuple.

308
00:14:52,625 --> 00:14:57,750
But if that value equals equals Padma,
let's go ahead with this if statement

309
00:14:57,750 --> 00:14:58,666
and make a change.

310
00:14:58,666 --> 00:15:02,208
Let's change the student's [1] value.

311
00:15:02,208 --> 00:15:04,625
So the second value, if
we're zero indexing--

312
00:15:04,625 --> 00:15:07,375
let's change it to be another
house in the world of Harry Potter

313
00:15:07,375 --> 00:15:08,916
called Ravenclaw.

314
00:15:08,916 --> 00:15:11,750
So I'm just fixing
maybe the user's input.

315
00:15:11,750 --> 00:15:14,166
They watched the movie so
they type in Padma Gryffindor,

316
00:15:14,166 --> 00:15:17,333
but, mm-mm, in the books,
it was Padma from Ravenclaw.

317
00:15:17,333 --> 00:15:20,250
All right, let me go ahead and
go down to my terminal window,

318
00:15:20,250 --> 00:15:24,041
clear my terminal, and do
Python of student.py, Enter.

319
00:15:24,041 --> 00:15:27,000
I'm going to do Harry as well as
Gryffindor, just to demonstrate

320
00:15:27,000 --> 00:15:29,750
that that is still working as intended.

321
00:15:29,750 --> 00:15:33,958
Let me clear my screen again, though,
and run Python of student.py on Padma,

322
00:15:33,958 --> 00:15:37,500
and I'll put her, too, in Gryffindor,
as in the movies, and hit Enter.

323
00:15:37,500 --> 00:15:40,916
And now I just see a big
mess of errors on the screen.

324
00:15:40,916 --> 00:15:42,708
Some kind of exception has been thrown.

325
00:15:42,708 --> 00:15:45,166
And indeed, a type error has happened.

326
00:15:45,166 --> 00:15:48,750
I'm using a data type wherein there's
an error, and what is that error?

327
00:15:48,750 --> 00:15:53,041
Well, 'tuple' object does
not support item assignment.

328
00:15:53,041 --> 00:15:57,375
It's a little arcanely expressed-- that
is, it's not really very user friendly.

329
00:15:57,375 --> 00:15:59,250
But if you think about
what those words mean,

330
00:15:59,250 --> 00:16:01,458
'tuple" object does not
support item assignment.

331
00:16:01,458 --> 00:16:03,458
So assignment is copying
from right to left.

332
00:16:03,458 --> 00:16:05,208
So somehow, that's invalid.

333
00:16:05,208 --> 00:16:10,250
And here is a manifestation
of the immutability of tuples.

334
00:16:10,250 --> 00:16:14,208
You cannot change location
0 or 1 or anything inside.

335
00:16:14,208 --> 00:16:15,250
That is a feature.

336
00:16:15,250 --> 00:16:17,250
That is the design of a tuple.

337
00:16:17,250 --> 00:16:20,000
So if I want to override
that, I think I'm

338
00:16:20,000 --> 00:16:23,125
going to have to use a different
type of data that we've used before--

339
00:16:23,125 --> 00:16:24,750
namely a list, and that's fine.

340
00:16:24,750 --> 00:16:28,416
If you want to enable yourself
and colleagues using your code

341
00:16:28,416 --> 00:16:31,083
to change the contents
of that container,

342
00:16:31,083 --> 00:16:34,375
well, we can go ahead and
return not a tuple using

343
00:16:34,375 --> 00:16:37,541
explicit parentheses or no
parentheses, just the comma,

344
00:16:37,541 --> 00:16:39,250
but I can use square brackets.

345
00:16:39,250 --> 00:16:41,916
And if I'm using square brackets
on the left and the right,

346
00:16:41,916 --> 00:16:44,458
this is indeed explicitly a list.

347
00:16:44,458 --> 00:16:47,041
Same idea, but it's mutable.

348
00:16:47,041 --> 00:16:50,000
That is to say you can change
the contents of a list.

349
00:16:50,000 --> 00:16:53,125
So making no other changes,
just returning a list

350
00:16:53,125 --> 00:16:57,833
with square brackets instead of a tuple
with parentheses or just the comma.

351
00:16:57,833 --> 00:17:01,041
Let me go ahead now and run
Python of student.py, Enter.

352
00:17:01,041 --> 00:17:04,000
Let me type in Harry
and Gryffindor again.

353
00:17:04,000 --> 00:17:05,458
That's still working.

354
00:17:05,458 --> 00:17:06,416
Good to see.

355
00:17:06,416 --> 00:17:11,416
Let me run this once more and type in
Padma and Gryffindor, as in the movies,

356
00:17:11,416 --> 00:17:15,333
but no, now we've corrected
it to be Padma from Ravenclaw,

357
00:17:15,333 --> 00:17:17,958
as in the books instead.

358
00:17:17,958 --> 00:17:22,541
Any questions now on tuples
versus lists or this idea

359
00:17:22,541 --> 00:17:26,541
of immutability versus mutability.

360
00:17:26,541 --> 00:17:31,833
AUDIENCE: Can we use a nested
tuple in Python, like a nest list?

361
00:17:31,833 --> 00:17:32,958
DAVID J. MALAN: Absolutely.

362
00:17:32,958 --> 00:17:35,250
You can have not only
nested lists in Python,

363
00:17:35,250 --> 00:17:38,291
where one of the elements in a
list could be another list-- so you

364
00:17:38,291 --> 00:17:41,500
have some square brackets out here; you
might have some other square brackets

365
00:17:41,500 --> 00:17:42,041
inside.

366
00:17:42,041 --> 00:17:44,833
You can absolutely do the
same with a tuple as well.

367
00:17:44,833 --> 00:17:47,833
There is no constraint on the types
of values you can put in there.

368
00:17:47,833 --> 00:17:50,125
We've not had occasion
to do that in this case.

369
00:17:50,125 --> 00:17:54,041
I'm just returning a simple
tuple with two elements.

370
00:17:54,041 --> 00:17:56,291
But yes, you could
absolutely do that, too.

371
00:17:56,291 --> 00:17:59,416
Other questions on tuples versus lists?

372
00:17:59,416 --> 00:18:03,208
AUDIENCE: OK, for example,
when I see the square brackets,

373
00:18:03,208 --> 00:18:05,250
is it mainly used for the list?

374
00:18:05,250 --> 00:18:07,041
DAVID J. MALAN: Oh, a
really good question.

375
00:18:07,041 --> 00:18:07,875
Sort of.

376
00:18:07,875 --> 00:18:12,250
So when you create a value like
a list, you use square brackets,

377
00:18:12,250 --> 00:18:14,041
and that would indeed
be a visual indicator

378
00:18:14,041 --> 00:18:16,458
that this is definitely a list.

379
00:18:16,458 --> 00:18:19,041
If you instead see parentheses,
that's a visual indicator,

380
00:18:19,041 --> 00:18:21,708
when creating a value, that
it's definitely a tuple.

381
00:18:21,708 --> 00:18:26,416
However, somewhat confusingly,
both lists and tuples

382
00:18:26,416 --> 00:18:30,375
use square brackets when you
access the contents of them.

383
00:18:30,375 --> 00:18:34,000
When you index into them
at location 0 or location 1

384
00:18:34,000 --> 00:18:36,083
you always use square brackets.

385
00:18:36,083 --> 00:18:37,500
So that's the distinction there.

386
00:18:37,500 --> 00:18:38,875
Good question.

387
00:18:38,875 --> 00:18:42,916
Allow me to propose now, if I may, that
we solve this problem yet another way,

388
00:18:42,916 --> 00:18:46,250
and let's see if we're either making
things better or for worse than us.

389
00:18:46,250 --> 00:18:49,916
Recall that dictionaries, or dict
objects, also exist in Python.

390
00:18:49,916 --> 00:18:53,250
And a dictionary is this
collection of keys and values.

391
00:18:53,250 --> 00:18:55,458
And the upside, in
particular, of a dictionary

392
00:18:55,458 --> 00:18:57,083
is that they have better semantics.

393
00:18:57,083 --> 00:18:59,625
You don't just have to
assume that a name is always

394
00:18:59,625 --> 00:19:03,291
going to be at location 0; house is
always going to be at location 1.

395
00:19:03,291 --> 00:19:06,916
That's the kind of thing, especially if
you had three, four, or more values--

396
00:19:06,916 --> 00:19:10,000
eventually you or someone is
going to get confused and forget

397
00:19:10,000 --> 00:19:12,958
what the order is and you're
going to write buggy code.

398
00:19:12,958 --> 00:19:15,333
So a dictionary is a
little more powerful

399
00:19:15,333 --> 00:19:19,000
in that you can semantically
associate keys, little descriptions,

400
00:19:19,000 --> 00:19:20,041
with the values--

401
00:19:20,041 --> 00:19:22,541
those keys and those
values, respectively.

402
00:19:22,541 --> 00:19:25,666
So let me go ahead and do this, and we
can do this in a few different ways.

403
00:19:25,666 --> 00:19:28,958
But let me propose that we
focus on get_student here .

404
00:19:28,958 --> 00:19:30,583
And let's go ahead and do this.

405
00:19:30,583 --> 00:19:35,875
Let me go ahead and delete the
implementation of get_student as is.

406
00:19:35,875 --> 00:19:40,083
Let me create a student variable and
initialize it to an empty dictionary.

407
00:19:40,083 --> 00:19:43,083
And I can do that with
just two curly braces here.

408
00:19:43,083 --> 00:19:46,958
And then let me go ahead and set
two keys inside of that dictionary.

409
00:19:46,958 --> 00:19:49,708
Inside of the student, there
will be, quote unquote, a "name"

410
00:19:49,708 --> 00:19:53,625
key, and the value of that is going to
be whatever the return value of input

411
00:19:53,625 --> 00:19:55,625
is when I prompt the
user for their name.

412
00:19:55,625 --> 00:19:59,708
And then the "house" key, inside
of that same student dictionary,

413
00:19:59,708 --> 00:20:02,750
is going to be the return value
of whatever the user types

414
00:20:02,750 --> 00:20:07,000
in for their house. , And lastly I'm
going to go ahead and return student.

415
00:20:07,000 --> 00:20:11,000
So now I am literally
returning one thing, still,

416
00:20:11,000 --> 00:20:15,291
but this time, it's a dict rather
than a tuple, rather than a list.

417
00:20:15,291 --> 00:20:18,041
But there are still two things
in it, technically four things

418
00:20:18,041 --> 00:20:19,708
if you count the keys and the values.

419
00:20:19,708 --> 00:20:22,083
But there's two key value pairs.

420
00:20:22,083 --> 00:20:24,625
Now, my code up here is going
to have to change a little bit.

421
00:20:24,625 --> 00:20:27,375
And let's simplify this and
remove, for instance, now

422
00:20:27,375 --> 00:20:31,458
the Padma if statement just to
focus on what's changing at hand.

423
00:20:31,458 --> 00:20:34,000
And let me go ahead now
and leave line 2 alone.

424
00:20:34,000 --> 00:20:37,708
I'm still going to have a student
variable that gets assigned the return

425
00:20:37,708 --> 00:20:39,166
value of get_student.

426
00:20:39,166 --> 00:20:45,375
But what I want to do here now is
actually access the keys inside of that

427
00:20:45,375 --> 00:20:49,083
dictionary-- not by numeric index,
which was for tuples and lists--

428
00:20:49,083 --> 00:20:52,541
0 and 1, but by way of the keys.

429
00:20:52,541 --> 00:20:55,291
Now, normally, I might be in
the habit, as I personally

430
00:20:55,291 --> 00:20:58,916
am, of using double quotes-- quote,
unquote, "name" inside of there

431
00:20:58,916 --> 00:21:02,166
and quote, unquote,
"house" inside of there.

432
00:21:02,166 --> 00:21:05,833
But before I even run this
code and show you a mistake--

433
00:21:05,833 --> 00:21:08,750
see an error on the screen,
does anyone want to call out

434
00:21:08,750 --> 00:21:10,666
what I have done wrong here?

435
00:21:10,666 --> 00:21:12,375
This is just an f string.

436
00:21:12,375 --> 00:21:16,708
I just want to print out the value of
the name key, the value of the house

437
00:21:16,708 --> 00:21:18,666
key in this dictionary.

438
00:21:18,666 --> 00:21:21,083
AUDIENCE: [INAUDIBLE]

439
00:21:21,333 --> 00:21:23,625
DAVID J. MALAN: Your audio
was a little garbled for us.

440
00:21:23,625 --> 00:21:26,250
But I think I heard double
quotes and single quotes.

441
00:21:26,250 --> 00:21:29,708
So I'm going to assume that, indeed,
you've identified precisely the issue.

442
00:21:29,708 --> 00:21:31,541
I'm just going to
confuse Python right now.

443
00:21:31,541 --> 00:21:35,833
Even though this is an f string inside
of double quotes, prefixed with an f,

444
00:21:35,833 --> 00:21:39,000
I can't actually use my double
quotes inside my double quotes

445
00:21:39,000 --> 00:21:41,125
because that's going to
potentially confuse Python.

446
00:21:41,125 --> 00:21:44,375
If I run this program now,
Python of student.py and hit

447
00:21:44,375 --> 00:21:46,166
Enter, I get a syntax error.

448
00:21:46,166 --> 00:21:48,000
So the program didn't even run fully.

449
00:21:48,000 --> 00:21:51,958
It just couldn't be understood because
it got confused by those double quotes.

450
00:21:51,958 --> 00:21:54,041
So the simplest fix
here would indeed just

451
00:21:54,041 --> 00:21:58,250
be to use not double quotes but
single quotes around the keys,

452
00:21:58,250 --> 00:22:02,041
or conversely, flip the double quotes
on the outside to single quotes,

453
00:22:02,041 --> 00:22:03,583
then use double quotes in the inside.

454
00:22:03,583 --> 00:22:05,125
You just want to be consistent.

455
00:22:05,125 --> 00:22:09,041
So a subtle detail, but again, this
is now specific to dictionary syntax.

456
00:22:09,041 --> 00:22:14,666
This isn't fundamental to how we're
solving this current problem at hand.

457
00:22:14,666 --> 00:22:16,083
Well, let's go ahead and try this.

458
00:22:16,083 --> 00:22:18,416
Let me go ahead now and
run Python of student.py.

459
00:22:18,416 --> 00:22:19,833
Let's go ahead and type in Harry.

460
00:22:19,833 --> 00:22:20,916
Let's type in Gryffindor.

461
00:22:20,916 --> 00:22:24,083
And hopefully, Harry is
back from Gryffindor.

462
00:22:24,083 --> 00:22:25,375
No syntax errors.

463
00:22:25,375 --> 00:22:26,250
No other errors.

464
00:22:26,250 --> 00:22:28,000
I think I'm back in business here.

465
00:22:28,000 --> 00:22:31,125
And what I do like to be
clear about using a dictionary

466
00:22:31,125 --> 00:22:34,000
is that it's allowing me
just better semantics.

467
00:22:34,000 --> 00:22:38,958
And again, I don't have to remember,
memorize, document that 0 is name;

468
00:22:38,958 --> 00:22:40,166
1 is house.

469
00:22:40,166 --> 00:22:43,291
Instead, "name" is name
and "house" is house.

470
00:22:43,291 --> 00:22:45,500
It's just a little clearer,
a little more expressive.

471
00:22:45,500 --> 00:22:49,250
So that's generally a good thing,
especially if we stored more data about

472
00:22:49,250 --> 00:22:53,000
students than just their name and their
house-- if you had three fields, four,

473
00:22:53,000 --> 00:22:54,625
five, 10 different fields--

474
00:22:54,625 --> 00:22:58,875
no one's going to want to remember or be
able to remember forever which is zero

475
00:22:58,875 --> 00:23:00,625
which is 1, which is 2, and so forth.

476
00:23:00,625 --> 00:23:04,958
Better to introduce names, like
"name" and "house" in this case.

477
00:23:04,958 --> 00:23:07,125
But let me tighten this up further.

478
00:23:07,125 --> 00:23:10,541
I'm typically in the habit of not
introducing variables unnecessarily,

479
00:23:10,541 --> 00:23:12,250
unless they make the code more readable.

480
00:23:12,250 --> 00:23:15,958
And an alternative way to format
the same code would be this.

481
00:23:15,958 --> 00:23:19,333
Strictly speaking, I don't need
to create an empty dictionary,

482
00:23:19,333 --> 00:23:23,375
then add one key to it,
then add a second key to it,

483
00:23:23,375 --> 00:23:25,375
and then return that dictionary.

484
00:23:25,375 --> 00:23:29,458
I can actually consolidate this all
into one statement, if you will.

485
00:23:29,458 --> 00:23:30,958
Let me go ahead and do this.

486
00:23:30,958 --> 00:23:35,458
Let me go ahead and say name
equals inputs return value,

487
00:23:35,458 --> 00:23:38,583
house equals inputs
return value, and then,

488
00:23:38,583 --> 00:23:41,666
instead of returning any variable name
student, which I'm going to propose

489
00:23:41,666 --> 00:23:44,208
doesn't need to exist
anymore, let me just create

490
00:23:44,208 --> 00:23:46,416
and return the dictionary all at once.

491
00:23:46,416 --> 00:23:50,458
Let me do, quote, unquote, "name" in
lowercase here, and then the variable.

492
00:23:50,458 --> 00:23:52,041
It's storing the user's name.

493
00:23:52,041 --> 00:23:55,208
Then, quote, unquote, "house," as
my second key, the value of which

494
00:23:55,208 --> 00:23:57,083
is going to be house, the variable.

495
00:23:57,083 --> 00:23:58,166
Now, is this better?

496
00:23:58,166 --> 00:23:59,000
Maybe, maybe not.

497
00:23:59,000 --> 00:24:00,958
Maybe the first way was
a little more readable,

498
00:24:00,958 --> 00:24:03,416
and that's totally fine
to create variables

499
00:24:03,416 --> 00:24:05,833
if they improve the
readability of your code.

500
00:24:05,833 --> 00:24:09,833
But just know that you can also create
and return a dictionary on the fly

501
00:24:09,833 --> 00:24:12,208
like this, so to speak,
all in one line, and I

502
00:24:12,208 --> 00:24:14,333
think it's arguably pretty
reasonable in this case.

503
00:24:14,333 --> 00:24:14,875
Why?

504
00:24:14,875 --> 00:24:16,083
It's just pretty short.

505
00:24:16,083 --> 00:24:18,875
I probably wouldn't do this if it
got longer and longer and longer.

506
00:24:18,875 --> 00:24:22,583
I might minimally then start moving
my key value pairs to separate lines.

507
00:24:22,583 --> 00:24:27,458
But this would just be a slightly more
compact way of doing this as well.

508
00:24:27,458 --> 00:24:29,375
But let me propose we
do one more change.

509
00:24:29,375 --> 00:24:32,958
Let's go ahead and introduce
that same special casing of Padma

510
00:24:32,958 --> 00:24:36,458
to fix her house from Gryffindor,
for instance, to Ravenclaw.

511
00:24:36,458 --> 00:24:38,250
How do we do this with dictionaries?

512
00:24:38,250 --> 00:24:41,625
Well, dictionaries,
like lists, are mutable.

513
00:24:41,625 --> 00:24:45,416
You can change what is in
them, just like you can lists.

514
00:24:45,416 --> 00:24:46,250
How do you do that?

515
00:24:46,250 --> 00:24:48,041
It's just a little
different syntactically.

516
00:24:48,041 --> 00:24:50,291
So let's go back into
main and do this fix.

517
00:24:50,291 --> 00:24:57,708
If the student variable has a name
key that equals equals Padma, then,

518
00:24:57,708 --> 00:25:04,375
indented, go ahead and change the value
of the house key inside of that student

519
00:25:04,375 --> 00:25:08,666
dictionary to be, quote,
unquote, "Ravenclaw" instead.

520
00:25:08,666 --> 00:25:11,416
So very similar in spirit
to what we did with a list.

521
00:25:11,416 --> 00:25:16,250
But instead of using location 0 and 1,
we're much more clearly, explicitly,

522
00:25:16,250 --> 00:25:19,375
semantically using, quote, unquote,
"name" and, quote, unquote,

523
00:25:19,375 --> 00:25:24,250
"house," because you index into lists
and tuples using numbers, but you index

524
00:25:24,250 --> 00:25:27,916
into dictionaries using
strings, as I've done here.

525
00:25:27,916 --> 00:25:31,250
All right, let me go ahead
and run Python of student.py.

526
00:25:31,250 --> 00:25:33,208
We'll again do Harry from Gryffindor.

527
00:25:33,208 --> 00:25:35,125
And I think all is well.

528
00:25:35,125 --> 00:25:38,708
Let me run it one more time this
time with Padma, who, in the movies,

529
00:25:38,708 --> 00:25:43,375
is from Gryffindor, but should
really be from Ravenclaw.

530
00:25:43,375 --> 00:25:49,250
Any questions then on this progression
from tuples to lists to dictionaries?

531
00:25:49,250 --> 00:25:53,458
We haven't necessarily introduced
anything new, other than those tuples,

532
00:25:53,458 --> 00:25:56,250
which have been available
to us all this time.

533
00:25:56,250 --> 00:26:00,000
But the goal at the moment is just
to demonstrate this distinction

534
00:26:00,000 --> 00:26:02,250
among these different
data types and how they

535
00:26:02,250 --> 00:26:04,333
each work a little bit differently.

536
00:26:04,333 --> 00:26:10,416
AUDIENCE: What if a combination
of lists is there in our tuple?

537
00:26:10,416 --> 00:26:16,125
We can change the list because are
immutable but lists are mutable?

538
00:26:16,125 --> 00:26:17,125
DAVID J. MALAN: Correct.

539
00:26:17,125 --> 00:26:19,291
You can change the
contents of lists, and you

540
00:26:19,291 --> 00:26:23,125
can put most anything you want in them--
other lists or strings, as I've done,

541
00:26:23,125 --> 00:26:24,583
integers, or anything else.

542
00:26:24,583 --> 00:26:27,916
Tuples you can do the exact same
thing, but you cannot change them once

543
00:26:27,916 --> 00:26:29,083
you've created them.

544
00:26:29,083 --> 00:26:33,041
A dictionary is more like a
list in that it is mutable.

545
00:26:33,041 --> 00:26:34,208
You can change it.

546
00:26:34,208 --> 00:26:37,583
But the way you index
into a dictionary is

547
00:26:37,583 --> 00:26:40,541
by way of these keys, these
strings, as we keep saying,

548
00:26:40,541 --> 00:26:42,250
rather than by numbers--

549
00:26:42,250 --> 00:26:45,083
those numeric indices.

550
00:26:45,083 --> 00:26:47,875
All right, well, let me
propose that there is yet

551
00:26:47,875 --> 00:26:50,458
another way of solving this problem.

552
00:26:50,458 --> 00:26:53,875
And I would argue that there's
now an opportunity at hand.

553
00:26:53,875 --> 00:26:56,750
Even though this program isn't
particularly complicated--

554
00:26:56,750 --> 00:27:01,208
all I'm doing is collecting a
name from the user and a house

555
00:27:01,208 --> 00:27:03,166
from the user-- you
could imagine wanting,

556
00:27:03,166 --> 00:27:05,291
longer term, to collect
even more information,

557
00:27:05,291 --> 00:27:07,791
like the student's
patronus or magical spell

558
00:27:07,791 --> 00:27:10,666
or a whole bunch of other information
that might belong in a student.

559
00:27:10,666 --> 00:27:15,291
And right now, we're just using
these very general purpose data

560
00:27:15,291 --> 00:27:16,458
types in Python--

561
00:27:16,458 --> 00:27:20,083
a tuple to combine some values
together; a list to do the same,

562
00:27:20,083 --> 00:27:23,625
but let us change it later; a
dictionary, which is more powerful

563
00:27:23,625 --> 00:27:25,250
because it's a little more structured.

564
00:27:25,250 --> 00:27:28,708
It does have keys, and it
has values, not just values.

565
00:27:28,708 --> 00:27:30,250
But you know what?

566
00:27:30,250 --> 00:27:33,500
We wouldn't have to be having this
conversation if the authors of Python

567
00:27:33,500 --> 00:27:37,125
had just given us a data
type called student.

568
00:27:37,125 --> 00:27:39,000
Wouldn't it have been
nice if there were just

569
00:27:39,000 --> 00:27:42,166
a type of variable I could
create in my code called student?

570
00:27:42,166 --> 00:27:43,916
Then we wouldn't have
to figure out, well,

571
00:27:43,916 --> 00:27:46,416
do we use a tuple or a
list or a dictionary?

572
00:27:46,416 --> 00:27:48,333
But that's pretty reasonable.

573
00:27:48,333 --> 00:27:52,166
You can imagine just how slippery
of a slope that is, so to speak,

574
00:27:52,166 --> 00:27:55,166
if the creators of a
language had to anticipate

575
00:27:55,166 --> 00:27:58,250
all the possible types of
data that programmers like you

576
00:27:58,250 --> 00:28:00,375
and me want to store in your programs.

577
00:28:00,375 --> 00:28:02,875
So they just gave us these
general purpose tools.

578
00:28:02,875 --> 00:28:05,750
But they gave us another
general purpose tool

579
00:28:05,750 --> 00:28:09,375
that's going to allow us to
create our own data types as well

580
00:28:09,375 --> 00:28:14,291
and actually give them names,
and that terminology is a class.

581
00:28:14,291 --> 00:28:20,125
A class is like a blueprint
for pieces of data objects.

582
00:28:20,125 --> 00:28:24,166
A class is a mold that you
can define and give a name.

583
00:28:24,166 --> 00:28:26,875
And when you use that mold
or you use that blueprint,

584
00:28:26,875 --> 00:28:31,000
you get types of data that are
designed exactly as you want.

585
00:28:31,000 --> 00:28:36,208
So in short, classes allow you to
invent your own data types in Python

586
00:28:36,208 --> 00:28:37,375
and give them a name.

587
00:28:37,375 --> 00:28:41,291
And this is a primary feature
of object oriented programming,

588
00:28:41,291 --> 00:28:44,041
to be able to create your
own objects in this way

589
00:28:44,041 --> 00:28:48,291
and, in the case of Python in classes,
even give them some custom names.

590
00:28:48,291 --> 00:28:50,333
So what does this mean in real terms?

591
00:28:50,333 --> 00:28:52,375
Well, let me go ahead
and come back to VS Code

592
00:28:52,375 --> 00:28:56,500
here, and let me propose that we
introduce a little bit of new syntax.

593
00:28:56,500 --> 00:28:58,916
I'm going to go ahead and
clear my terminal window first.

594
00:28:58,916 --> 00:29:02,791
I'm going to go to the top of my file,
and I'm just going to start a thought

595
00:29:02,791 --> 00:29:03,916
but not finish it yet.

596
00:29:03,916 --> 00:29:09,083
I'm going to use this new keyword for
classes, called, literally, class,

597
00:29:09,083 --> 00:29:11,708
so the new keyword we're
going to have here.

598
00:29:11,708 --> 00:29:13,916
And if I go back to
our slides here, this

599
00:29:13,916 --> 00:29:16,083
would be the official URL
where you can read up more

600
00:29:16,083 --> 00:29:18,000
on this particular feature of Python.

601
00:29:18,000 --> 00:29:22,083
In the official tutorial, class
is a new keyword we can use.

602
00:29:22,083 --> 00:29:25,500
Now, this is coincidentally related to
students because students take classes,

603
00:29:25,500 --> 00:29:28,500
but it has nothing to do with the
fact that we're dealing with students.

604
00:29:28,500 --> 00:29:31,791
Class is a general purpose
term in a lot of languages--

605
00:29:31,791 --> 00:29:35,500
Python among them-- that allow you
to define these custom containers

606
00:29:35,500 --> 00:29:38,625
with custom names for pieces of data.

607
00:29:38,625 --> 00:29:39,875
So let's go back to VS Code.

608
00:29:39,875 --> 00:29:41,333
Let's use this new keyword.

609
00:29:41,333 --> 00:29:44,500
And let me propose that we
create a class called Student.

610
00:29:44,500 --> 00:29:47,000
And by convention, I'm going
to use a capital S here,

611
00:29:47,000 --> 00:29:49,583
and I'm going to go
ahead, and with a colon,

612
00:29:49,583 --> 00:29:52,500
get to, later, the
implementation of this class.

613
00:29:52,500 --> 00:29:55,625
So I'm just going to use dot dot dot,
which is a valid placeholder for now,

614
00:29:55,625 --> 00:29:57,833
that just indicates to me
that I'm going to come back

615
00:29:57,833 --> 00:29:59,000
to implementing this later.

616
00:29:59,000 --> 00:30:02,125
But as of now, it does, in fact, exist.

617
00:30:02,125 --> 00:30:08,458
I now have a student class defined for
me that I can now use in my code here.

618
00:30:08,458 --> 00:30:09,875
How am I going to use it?

619
00:30:09,875 --> 00:30:13,250
Well, first of all, let
me go down to get_student,

620
00:30:13,250 --> 00:30:18,625
and let me change this code to no longer
use a dictionary but to use this class.

621
00:30:18,625 --> 00:30:19,666
I'm going to do this.

622
00:30:19,666 --> 00:30:22,791
I'm going to give myself a variable
called student, as I've done before,

623
00:30:22,791 --> 00:30:26,166
but I'm going to set it
equal to capital Student ().

624
00:30:28,916 --> 00:30:32,208
So I'm going to do what appears
to be calling a function

625
00:30:32,208 --> 00:30:35,583
and that function, Student
with a capital S, notice,

626
00:30:35,583 --> 00:30:39,500
matches the name that I gave
this class at the top of my file.

627
00:30:39,500 --> 00:30:41,166
All right, what do I next want to do?

628
00:30:41,166 --> 00:30:43,333
I'm going to go ahead and
give this student a name.

629
00:30:43,333 --> 00:30:46,041
Now, if I were still
using a dictionary, I

630
00:30:46,041 --> 00:30:50,541
would say student, quote, unquote,
"name," using square brackets.

631
00:30:50,541 --> 00:30:52,125
But this is not a dictionary.

632
00:30:52,125 --> 00:30:54,500
It turns out classes
have what, for now, we'll

633
00:30:54,500 --> 00:30:58,916
call attributes, properties of sorts
that allow you to specify values inside

634
00:30:58,916 --> 00:30:59,416
of them.

635
00:30:59,416 --> 00:31:01,708
And the syntax for that
happens to be a dot.

636
00:31:01,708 --> 00:31:03,166
We've seen dots before.

637
00:31:03,166 --> 00:31:06,333
We've used it in the context of
modules and libraries, more generally.

638
00:31:06,333 --> 00:31:08,875
This is another similar
in spirit use of a dot

639
00:31:08,875 --> 00:31:12,125
that allows you to get at
something inside of something else.

640
00:31:12,125 --> 00:31:15,208
So student.name is
going to be the syntax

641
00:31:15,208 --> 00:31:18,083
I use for giving this student a name.

642
00:31:18,083 --> 00:31:21,666
And that name is going to be whatever
the return value of "Name" is.

643
00:31:21,666 --> 00:31:24,958
And then I'm going to go ahead
and say student.house to give

644
00:31:24,958 --> 00:31:29,291
another attribute called "House" and
give that the return value of input

645
00:31:29,291 --> 00:31:30,750
here, prompting the user for house.

646
00:31:30,750 --> 00:31:33,625
And then, as before, I'm
just going to return student.

647
00:31:33,625 --> 00:31:37,166
But now what's really
powerful about class,

648
00:31:37,166 --> 00:31:39,791
and object-oriented
programming more generally,

649
00:31:39,791 --> 00:31:43,375
is that I've created this custom
data type called, literally,

650
00:31:43,375 --> 00:31:47,333
Student, capital S. I've stored
one such student in a variable

651
00:31:47,333 --> 00:31:50,833
like I can always do in a variable
called student, lowercase s.

652
00:31:50,833 --> 00:31:52,333
But I could call it anything I want.

653
00:31:52,333 --> 00:31:56,166
It just makes sense to call it student
as well, but lowercase for clarity.

654
00:31:56,166 --> 00:31:58,291
And then I'm returning that variable.

655
00:31:58,291 --> 00:32:01,666
And because of my syntax
in lines 14 and 15,

656
00:32:01,666 --> 00:32:05,083
that has the result of
putting inside of that class

657
00:32:05,083 --> 00:32:09,291
a name attribute and a house attribute.

658
00:32:09,291 --> 00:32:11,625
I just need to make one
more change up here.

659
00:32:11,625 --> 00:32:13,416
I'm going to go ahead
and remove our Padma

660
00:32:13,416 --> 00:32:15,500
code, just so we can
focus only on what's new,

661
00:32:15,500 --> 00:32:17,416
rather than fixing her house.

662
00:32:17,416 --> 00:32:20,208
And I'm going to go in here
and change the syntax that

663
00:32:20,208 --> 00:32:21,916
previously was for dictionaries.

664
00:32:21,916 --> 00:32:26,958
Again, dictionaries use square
brackets and then strings in quotes--

665
00:32:26,958 --> 00:32:29,958
either single quotes or double
quotes, depending on the context.

666
00:32:29,958 --> 00:32:33,208
Here, though, I'm going to
change this to be student.name,

667
00:32:33,208 --> 00:32:37,458
and over here, I'm going to
change it to be student.house.

668
00:32:37,458 --> 00:32:40,791
And that's just going to be my new
syntax for getting the contents of what

669
00:32:40,791 --> 00:32:43,250
appears to be a class called student.

670
00:32:43,250 --> 00:32:47,458
Let me go ahead and rerun
Python of student.py, Enter.

671
00:32:47,458 --> 00:32:49,333
Let's type in Harry's name as before.

672
00:32:49,333 --> 00:32:52,500
Let's put him in Gryffindor,
crossing our fingers as we often do,

673
00:32:52,500 --> 00:32:56,500
and Harry is indeed from Gryffindor.

674
00:32:56,500 --> 00:32:58,166
What, though, have I done?

675
00:32:58,166 --> 00:33:01,000
Let's introduce one other
bit of terminology here

676
00:33:01,000 --> 00:33:05,583
it turns out that I can create a
class, using that class keyword.

677
00:33:05,583 --> 00:33:09,958
But any time you use a class, you're
creating what are called objects.

678
00:33:09,958 --> 00:33:14,666
And here is the word objects, as an
object-oriented programming, or OOP.

679
00:33:14,666 --> 00:33:16,250
Let me go back to my code here.

680
00:33:16,250 --> 00:33:18,916
And even though I haven't really
implemented much of it at all--

681
00:33:18,916 --> 00:33:20,958
I literally just left it
with a dot, dot, dot--

682
00:33:20,958 --> 00:33:25,416
that's enough code, lines 1 and 2,
to just invent a new data type called

683
00:33:25,416 --> 00:33:29,708
Student, capital S, that may or may not
have some future functionality as well.

684
00:33:29,708 --> 00:33:31,375
That's enough to create a class.

685
00:33:31,375 --> 00:33:34,166
What, though, am I doing on line 11?

686
00:33:34,166 --> 00:33:40,083
On line 11, what I'm technically doing
is creating an object of that class.

687
00:33:40,083 --> 00:33:42,000
So this, too, is another term of art.

688
00:33:42,000 --> 00:33:44,791
You create objects from classes.

689
00:33:44,791 --> 00:33:47,000
So if we go back to that
metaphor, that a class is

690
00:33:47,000 --> 00:33:50,916
like a blueprint for a house
or a class is like a mold,

691
00:33:50,916 --> 00:33:54,750
an object is when you use that
blueprint to build a specific house

692
00:33:54,750 --> 00:33:58,458
or something that comes out of-- in
plaster, the mold, when you actually

693
00:33:58,458 --> 00:34:01,250
use that mold to create such an object.

694
00:34:01,250 --> 00:34:04,916
So a class is, again, the
definition of a new data type.

695
00:34:04,916 --> 00:34:10,125
The object is the incarnation of,
or technically instantiation of.

696
00:34:10,125 --> 00:34:13,583
And another term for objects
would actually be an instance.

697
00:34:13,583 --> 00:34:16,208
You have instances of classes as well.

698
00:34:16,208 --> 00:34:17,458
So that's a lot of vocabulary.

699
00:34:17,458 --> 00:34:19,708
But at the end of the day,
it just boils down to this.

700
00:34:19,708 --> 00:34:22,750
You can define your own class,
which is really your own data type.

701
00:34:22,750 --> 00:34:26,791
You can then store attributes inside
of it, using this dot notation here.

702
00:34:26,791 --> 00:34:31,041
And then you can access those same
attributes using code like this here.

703
00:34:31,041 --> 00:34:33,958
And now, I have a proper
"student" data type,

704
00:34:33,958 --> 00:34:36,625
and I don't have to
hack something together

705
00:34:36,625 --> 00:34:39,000
using a tuple or a list
or even a dictionary.

706
00:34:39,000 --> 00:34:43,500
I now have a proper data type called
"student" that the authors of Python

707
00:34:43,500 --> 00:34:46,041
didn't give me; I gave myself.

708
00:34:46,041 --> 00:34:50,791
Any questions now on classes, this
new keyword, class, or this idea

709
00:34:50,791 --> 00:34:53,625
of these objects or instances thereof?

710
00:34:53,625 --> 00:34:58,333
AUDIENCE: Is the class
object mutable or immutable?

711
00:34:58,333 --> 00:34:59,666
DAVID J. MALAN: A good question.

712
00:34:59,666 --> 00:35:02,208
And we've clearly laid the stage
for having that conversation

713
00:35:02,208 --> 00:35:03,541
about every data type now.

714
00:35:03,541 --> 00:35:07,958
We will see that they are mutable,
but you can make them immutable.

715
00:35:07,958 --> 00:35:10,083
So you can get the best of both worlds.

716
00:35:10,083 --> 00:35:13,416
Now, by writing some actual code-- and
we'll write more code than the dot,

717
00:35:13,416 --> 00:35:18,208
dot, dot in just a bit, other questions
on classes or these objects thereof?

718
00:35:18,208 --> 00:35:21,625
AUDIENCE: Then what would be
the properties of those classes?

719
00:35:21,625 --> 00:35:24,750
DAVID J. MALAN: So at the moment, the
properties of-- or the attributes of,

720
00:35:24,750 --> 00:35:28,250
as I've been calling them thus far--
would just be "Name" and "House."

721
00:35:28,250 --> 00:35:32,333
It turns out that there may very well
be other attributes built into classes

722
00:35:32,333 --> 00:35:33,541
that we may see before long.

723
00:35:33,541 --> 00:35:36,166
But for now, the only two
attributes that I care about

724
00:35:36,166 --> 00:35:38,333
are the ones that I myself created--

725
00:35:38,333 --> 00:35:42,208
namely "Name" and "House" or,
again, what I would call attributes.

726
00:35:42,208 --> 00:35:43,916
And in a little bit,
we're going to start

727
00:35:43,916 --> 00:35:47,541
calling those same attributes, more
technically, instance variables.

728
00:35:47,541 --> 00:35:50,708
"Name" and "House," as I
presented them here in VS Code

729
00:35:50,708 --> 00:35:55,750
are really just variables called
"name" and called "house" inside

730
00:35:55,750 --> 00:36:00,125
of an object whose type is student.

731
00:36:00,125 --> 00:36:02,583
All right, so what more can
we do with these classes?

732
00:36:02,583 --> 00:36:06,208
Well, again, on line 11 is
where we're instantiating

733
00:36:06,208 --> 00:36:11,000
an object of the student class and
assigning it to a student variable.

734
00:36:11,000 --> 00:36:12,416
We're then adding attributes--

735
00:36:12,416 --> 00:36:16,000
"Name" and "House," respectively--
on lines 12 and 13 currently.

736
00:36:16,000 --> 00:36:17,958
Both of those have values
that are technically

737
00:36:17,958 --> 00:36:21,208
strings or strs, because that's what
the return value of the input is.

738
00:36:21,208 --> 00:36:24,000
But those attributes values
could actually be any data type.

739
00:36:24,000 --> 00:36:27,000
We're just keeping things simple
and focusing on defining students

740
00:36:27,000 --> 00:36:28,333
in terms of two strings--

741
00:36:28,333 --> 00:36:29,375
"Name" and "House."

742
00:36:29,375 --> 00:36:32,125
And then, on line 14, we're
returning that variable.

743
00:36:32,125 --> 00:36:35,333
We're returning that object to
main so that we can actually

744
00:36:35,333 --> 00:36:37,708
print out who is from what house.

745
00:36:37,708 --> 00:36:40,958
Well, let's go ahead and add a bit more
functionality here because, right now,

746
00:36:40,958 --> 00:36:44,166
on lines 12 and 13,
this is a little manual.

747
00:36:44,166 --> 00:36:47,333
And it's a little reckless of
me to just be putting anything

748
00:36:47,333 --> 00:36:50,333
I want inside of this student object.

749
00:36:50,333 --> 00:36:53,041
It turns out with classes,
unlike with dictionaries,

750
00:36:53,041 --> 00:36:57,625
we can actually standardize, all the
more, what those attributes can be

751
00:36:57,625 --> 00:37:00,291
and what kinds of values
you can set them to.

752
00:37:00,291 --> 00:37:02,375
So let me go ahead and do this.

753
00:37:02,375 --> 00:37:04,375
Let me propose that it
would actually be really

754
00:37:04,375 --> 00:37:08,875
nice if, instead of doing
this here, let me go ahead

755
00:37:08,875 --> 00:37:10,833
and simplify my code as follows.

756
00:37:10,833 --> 00:37:13,708
Let me go ahead and give myself
a local variable called name

757
00:37:13,708 --> 00:37:17,208
and set it equal to the return value of
input, like we've done many times now

758
00:37:17,208 --> 00:37:17,791
already.

759
00:37:17,791 --> 00:37:20,333
Let me give myself one other
variable for now, called house,

760
00:37:20,333 --> 00:37:23,333
and set it equal to the
return value of input

761
00:37:23,333 --> 00:37:25,291
as well, prompting the
user for their house.

762
00:37:25,291 --> 00:37:30,416
And now, instead of creating a
student object from my student class

763
00:37:30,416 --> 00:37:34,500
and then manually putting the
name attribute inside of it

764
00:37:34,500 --> 00:37:37,166
and the house attribute
inside of it, let

765
00:37:37,166 --> 00:37:39,458
me actually do something more powerful.

766
00:37:39,458 --> 00:37:40,583
Let me do this.

767
00:37:40,583 --> 00:37:45,333
Let me call that Student function,
which is identical to the class name--

768
00:37:45,333 --> 00:37:48,125
just by defining a
class, you get a function

769
00:37:48,125 --> 00:37:52,583
whose name is identical to the class
name, with the capital letter included.

770
00:37:52,583 --> 00:37:54,625
But instead of just
doing open parenthesis,

771
00:37:54,625 --> 00:37:58,166
closed parenthesis, let
me pass in the name that I

772
00:37:58,166 --> 00:38:02,791
want to fill this object with and the
house that I want to put in that object

773
00:38:02,791 --> 00:38:03,375
as well.

774
00:38:03,375 --> 00:38:09,375
And now let me set the return value as
before to be student equals like this.

775
00:38:09,375 --> 00:38:11,083
So what have I done that's different?

776
00:38:11,083 --> 00:38:13,583
Fundamentally, I'm still getting
user input in the same way.

777
00:38:13,583 --> 00:38:16,750
I'm using input on line
11 and input on line 12.

778
00:38:16,750 --> 00:38:21,125
And I just so happen to be storing
those return values in local variables.

779
00:38:21,125 --> 00:38:24,875
And now we're setting the stage for
the more powerful features of classes

780
00:38:24,875 --> 00:38:27,208
and object-oriented
programming more generally.

781
00:38:27,208 --> 00:38:31,500
Notice that I'm deliberately
passing to this capital S Student

782
00:38:31,500 --> 00:38:33,875
function, name, house--

783
00:38:33,875 --> 00:38:36,291
I'm passing in arguments
to the function.

784
00:38:36,291 --> 00:38:39,750
Now, the student class is not going
to know what to do with those yet,

785
00:38:39,750 --> 00:38:44,791
but now I'm standardizing how I'm
passing data into this student class.

786
00:38:44,791 --> 00:38:47,833
And ultimately, it's going to
give me an opportunity to error

787
00:38:47,833 --> 00:38:51,166
check those inputs, to make sure that
the name is valid, that it has a value

788
00:38:51,166 --> 00:38:52,875
and it's not just the
user hitting Enter.

789
00:38:52,875 --> 00:38:56,041
It's going to allow me to ensure
that it's a valid house, that it's

790
00:38:56,041 --> 00:38:59,208
Gryffindor or Hufflepuff
or Ravenclaw or Slytherin

791
00:38:59,208 --> 00:39:02,916
or not just hitting Enter or some
random value that the user types in.

792
00:39:02,916 --> 00:39:05,916
Because I'm passing "Name"
and "House" to the student

793
00:39:05,916 --> 00:39:08,791
class, this particular
function, I'm going

794
00:39:08,791 --> 00:39:11,416
to have more control over
the correctness of my data.

795
00:39:11,416 --> 00:39:14,541
So let's now go up to the student
class, which, up until now,

796
00:39:14,541 --> 00:39:16,125
I left as just dot, dot, dot.

797
00:39:16,125 --> 00:39:19,625
It turns out that, in
the context of classes,

798
00:39:19,625 --> 00:39:23,916
there are a number of not
just attributes or instance

799
00:39:23,916 --> 00:39:27,041
variables that you can put
inside, but also methods.

800
00:39:27,041 --> 00:39:32,083
Classes come with certain methods,
or functions inside of them,

801
00:39:32,083 --> 00:39:35,708
that you can define, and they
just behave in a special way,

802
00:39:35,708 --> 00:39:37,875
by nature of how Python works.

803
00:39:37,875 --> 00:39:42,625
These functions allow you to
determine behavior in a standard way.

804
00:39:42,625 --> 00:39:45,083
They are special methods in that sense.

805
00:39:45,083 --> 00:39:46,333
Now, what do I mean by this.

806
00:39:46,333 --> 00:39:48,083
Well, let me go back to VS Code here.

807
00:39:48,083 --> 00:39:53,000
And let me propose that I start
to define a standard function

808
00:39:53,000 --> 00:39:56,916
called underscore underscore,
or Dunder, as it's

809
00:39:56,916 --> 00:39:59,916
abbreviated, init,
underscore underscore,

810
00:39:59,916 --> 00:40:02,916
and then I'm going to go
ahead and do open parentheses,

811
00:40:02,916 --> 00:40:06,875
and then I'm going to put in
here, literally, the word self.

812
00:40:06,875 --> 00:40:08,416
More on that in just a moment.

813
00:40:08,416 --> 00:40:11,791
But now, inside of this function,
I'm going to have an opportunity

814
00:40:11,791 --> 00:40:16,791
to customize this class's objects.

815
00:40:16,791 --> 00:40:20,333
That is to say this underscore,
underscore init method,

816
00:40:20,333 --> 00:40:25,208
or Dunder init method is specifically
known as an instance method,

817
00:40:25,208 --> 00:40:26,708
and it's called exactly this.

818
00:40:26,708 --> 00:40:28,875
This is designed by
the authors of Python.

819
00:40:28,875 --> 00:40:34,291
And if you want to initialize the
contents of an object from a class,

820
00:40:34,291 --> 00:40:37,875
you define this method, and we'll
see what it's about to do here.

821
00:40:37,875 --> 00:40:41,250
Let me go back to VS Code, and
let me do something like this.

822
00:40:41,250 --> 00:40:47,750
self.name = name, and
self.house = house.

823
00:40:47,750 --> 00:40:51,250
But I don't want to just init
this object very generically.

824
00:40:51,250 --> 00:40:56,166
I want this method, called init,
to take in not just self but name,

825
00:40:56,166 --> 00:40:58,375
house as well.

826
00:40:58,375 --> 00:40:59,916
Now, what in the world is going on?

827
00:40:59,916 --> 00:41:01,708
Because there's a lot
of weird syntax here.

828
00:41:01,708 --> 00:41:03,375
There's this Dunder init method--

829
00:41:03,375 --> 00:41:05,791
double underscore,
init, double underscore.

830
00:41:05,791 --> 00:41:08,750
There's, all of a sudden,
this parameter called self.

831
00:41:08,750 --> 00:41:12,458
And then there's this new
syntax-- self.name and self.house.

832
00:41:12,458 --> 00:41:16,541
Now you're seeing really a manifestation
of object-oriented programming.

833
00:41:16,541 --> 00:41:18,250
It's not all that
different fundamentally

834
00:41:18,250 --> 00:41:20,541
from what we've been doing
for weeks with dictionaries,

835
00:41:20,541 --> 00:41:23,125
by adding keys to dictionaries.

836
00:41:23,125 --> 00:41:28,333
But in this case, we're adding
variables to objects, a.k.a.

837
00:41:28,333 --> 00:41:30,500
instance variables to objects.

838
00:41:30,500 --> 00:41:31,458
Now, what's going on?

839
00:41:31,458 --> 00:41:32,541
Let's do this in reverse.

840
00:41:32,541 --> 00:41:34,750
Let's go back to the line
of code we wrote earlier.

841
00:41:34,750 --> 00:41:38,708
On line 15, I am treating
the name of this class--

842
00:41:38,708 --> 00:41:41,916
Student with a capital
S-- as a function.

843
00:41:41,916 --> 00:41:44,583
And I am passing in two values--

844
00:41:44,583 --> 00:41:45,916
"Name" and "House."

845
00:41:45,916 --> 00:41:48,708
What I've highlighted here
on the screen, on line 15,

846
00:41:48,708 --> 00:41:51,250
is generally known as
a constructor call.

847
00:41:51,250 --> 00:41:56,875
This is a line of code that is going
to construct a student object for me.

848
00:41:56,875 --> 00:42:02,791
Using synonyms, it is going to
instantiate a student object for me.

849
00:42:02,791 --> 00:42:05,583
And again, how is it going
to create that object?

850
00:42:05,583 --> 00:42:09,458
It's going to use the student class
as a template, as a mold of sorts

851
00:42:09,458 --> 00:42:12,291
so that every student
is structured the same.

852
00:42:12,291 --> 00:42:13,875
Every student is going to have a name.

853
00:42:13,875 --> 00:42:15,458
Every student's going to have a house.

854
00:42:15,458 --> 00:42:20,916
But because I can pass in arguments
to this Student function, capital S,

855
00:42:20,916 --> 00:42:26,666
I'm going to be able to customize
the contents of that object.

856
00:42:26,666 --> 00:42:29,666
So if you think about the real world--
if you've ever been on a street

857
00:42:29,666 --> 00:42:34,666
or a neighborhood where all of the
houses look the same but they might be

858
00:42:34,666 --> 00:42:37,541
painted differently; they might be
decorated a little bit differently

859
00:42:37,541 --> 00:42:40,958
on the outside, all of those houses
might have been built using the exact

860
00:42:40,958 --> 00:42:42,541
same blueprint--

861
00:42:42,541 --> 00:42:43,875
a mold, if you will.

862
00:42:43,875 --> 00:42:48,083
But then you can specialize exactly
the finer points of those houses.

863
00:42:48,083 --> 00:42:51,000
By painting the outside a different
color or planting different trees,

864
00:42:51,000 --> 00:42:52,500
you can style them differently.

865
00:42:52,500 --> 00:42:57,750
Similar in spirit here, we
have a Student blueprint

866
00:42:57,750 --> 00:43:01,583
that's always going to have now a name
and a house, but it's up to you and me

867
00:43:01,583 --> 00:43:04,166
to pass in any name and
any house that we want.

868
00:43:04,166 --> 00:43:06,041
Now, where is this function?

869
00:43:06,041 --> 00:43:09,125
The fact that I'm calling Student,
capital, S and then a parenthesis

870
00:43:09,125 --> 00:43:11,250
and a closed parenthesis
with arguments inside

871
00:43:11,250 --> 00:43:12,958
suggest that there's
a function somewhere

872
00:43:12,958 --> 00:43:17,500
in the world that has been defined,
with def, that's going to be called.

873
00:43:17,500 --> 00:43:20,416
Well, as you might have
guessed by now, the function

874
00:43:20,416 --> 00:43:25,500
that will always be called, by
definition of how Python classes work,

875
00:43:25,500 --> 00:43:30,000
is a function called double
underscore, init, double underscore.

876
00:43:30,000 --> 00:43:30,500
Why?

877
00:43:30,500 --> 00:43:33,333
It's a crazy name, but it's
what the authors of Python

878
00:43:33,333 --> 00:43:38,750
chose to just implement the
initialization of an object in Python.

879
00:43:38,750 --> 00:43:40,916
Now, the only weird thing--

880
00:43:40,916 --> 00:43:43,125
especially weird thing,
I will admit, is this.

881
00:43:43,125 --> 00:43:49,125
It would be way clearer, to me, too, if
the only two parameters for init we're

882
00:43:49,125 --> 00:43:50,666
just name, house.

883
00:43:50,666 --> 00:43:53,541
That's how we've defined every
function thus far in the class.

884
00:43:53,541 --> 00:43:57,291
You just specify the parameters that
you want the function to accept.

885
00:43:57,291 --> 00:44:00,333
And that lines up with
what I'm doing on line 15.

886
00:44:00,333 --> 00:44:04,541
I am only passing in two
things to the student function.

887
00:44:04,541 --> 00:44:07,833
But it turns out that
the authors of Python

888
00:44:07,833 --> 00:44:09,541
need to give us a
little bit of help here

889
00:44:09,541 --> 00:44:14,458
because suppose that you pass in
"Name" and "House" to this init method.

890
00:44:14,458 --> 00:44:17,833
And a method is just a
function inside of a class.

891
00:44:17,833 --> 00:44:20,291
What are you going to do
with the name and the house?

892
00:44:20,291 --> 00:44:22,333
Literally, where are
you going to put them?

893
00:44:22,333 --> 00:44:26,500
If you want to remember the name
and the house for this student,

894
00:44:26,500 --> 00:44:29,166
you've got to be able to
store those values somewhere.

895
00:44:29,166 --> 00:44:32,416
And how do you store them
in the current object

896
00:44:32,416 --> 00:44:34,833
that has just been "instantiated?"

897
00:44:34,833 --> 00:44:37,625
Well, the authors of Python
decided that the convention

898
00:44:37,625 --> 00:44:41,958
is going to be that this init
method also, semi secretly, takes

899
00:44:41,958 --> 00:44:44,625
a third argument, that
has to come first.

900
00:44:44,625 --> 00:44:46,666
By convention, it's
called self, but you could

901
00:44:46,666 --> 00:44:48,250
call it technically anything you want.

902
00:44:48,250 --> 00:44:50,208
But the convention is
to always call it self.

903
00:44:50,208 --> 00:44:53,500
And self, as its name
implies, gives you access

904
00:44:53,500 --> 00:44:56,791
to the current object
that was just created.

905
00:44:56,791 --> 00:44:58,000
What does that mean?

906
00:44:58,000 --> 00:45:02,166
Again, now, on line 14, now that
it's moved down a little bit,

907
00:45:02,166 --> 00:45:04,083
this line here is a constructor.

908
00:45:04,083 --> 00:45:06,166
It constructs a student object.

909
00:45:06,166 --> 00:45:08,291
But there's nothing in
that object initially.

910
00:45:08,291 --> 00:45:09,750
There's no name; there's no house.

911
00:45:09,750 --> 00:45:12,791
But the object exists in
the computer's memory.

912
00:45:12,791 --> 00:45:16,541
It's up to, now, you to store the name
and the house inside of that object.

913
00:45:16,541 --> 00:45:17,500
How do you do that?

914
00:45:17,500 --> 00:45:21,500
Well, Python will just automatically
call this init method for you,

915
00:45:21,500 --> 00:45:27,500
and it's going to automatically pass
in a reference to an argument that

916
00:45:27,500 --> 00:45:32,375
represents the current object that it
just constructed in memory for you,

917
00:45:32,375 --> 00:45:34,708
and it's up to you to
populate it with values.

918
00:45:34,708 --> 00:45:37,666
And what this means is that,
inside of your init method,

919
00:45:37,666 --> 00:45:42,875
you can literally do self.name
to create a new attribute, a.k.a.

920
00:45:42,875 --> 00:45:46,166
an instance variable, inside
of that otherwise empty

921
00:45:46,166 --> 00:45:48,416
object and put this name inside of it.

922
00:45:48,416 --> 00:45:51,875
It allows you to do self.house
and store that value of house.

923
00:45:51,875 --> 00:45:54,000
Now, you could call these
things anything you want.

924
00:45:54,000 --> 00:45:54,750
They could be n.

925
00:45:54,750 --> 00:45:56,416
They could be h, as before.

926
00:45:56,416 --> 00:46:00,250
But that's really not
very self-explanatory.

927
00:46:00,250 --> 00:46:04,250
Much better to do this kind of
convention. self.name equals name.

928
00:46:04,250 --> 00:46:06,333
self.house equals house.

929
00:46:06,333 --> 00:46:11,708
And this is like installing into the
otherwise empty object the value name

930
00:46:11,708 --> 00:46:16,083
and house and storing them in,
really, identically named instance

931
00:46:16,083 --> 00:46:17,708
variables in the object.

932
00:46:17,708 --> 00:46:20,833
And again, an object is
just an instance of a class.

933
00:46:20,833 --> 00:46:23,208
Now, I know that was
a lot of vocabulary.

934
00:46:23,208 --> 00:46:24,875
That's a lot of weird syntax.

935
00:46:24,875 --> 00:46:28,625
So any questions on this init
method, whose purpose in life,

936
00:46:28,625 --> 00:46:33,541
again, is to initialize an otherwise
empty object when you first create it?

937
00:46:33,541 --> 00:46:36,791
AUDIENCE: So what is the difference
between the init method and default

938
00:46:36,791 --> 00:46:37,500
constructor?

939
00:46:37,500 --> 00:46:38,833
DAVID J. MALAN: A good question.

940
00:46:38,833 --> 00:46:41,583
So in other languages--
if you programmed before.

941
00:46:41,583 --> 00:46:45,166
For instance, Java-- there are
functions that are explicitly called

942
00:46:45,166 --> 00:46:47,916
constructors that construct an object.

943
00:46:47,916 --> 00:46:49,416
They initialize it with values.

944
00:46:49,416 --> 00:46:53,291
Python technically calls this init
method the initialization method.

945
00:46:53,291 --> 00:46:54,958
It initializes the value.

946
00:46:54,958 --> 00:47:00,875
It's on line 15 now of my code, if I
scroll back down, that I'm technically

947
00:47:00,875 --> 00:47:02,416
constructing the object.

948
00:47:02,416 --> 00:47:05,333
It turns out there's another
special method in Python,

949
00:47:05,333 --> 00:47:07,291
that we won't talk
about in detail today,

950
00:47:07,291 --> 00:47:11,125
called underscore underscore,
new, underscore underscore

951
00:47:11,125 --> 00:47:13,375
that actually handles
the process of creating

952
00:47:13,375 --> 00:47:15,458
an empty object in memory for us.

953
00:47:15,458 --> 00:47:17,833
But, generally speaking,
you, the programmer,

954
00:47:17,833 --> 00:47:19,916
don't need to manipulate
the new function.

955
00:47:19,916 --> 00:47:20,916
It just works for you.

956
00:47:20,916 --> 00:47:23,750
Instead, you define your
own init method here

957
00:47:23,750 --> 00:47:27,041
and init function inside of
your class, and that method

958
00:47:27,041 --> 00:47:29,916
initializes the contents of the object.

959
00:47:29,916 --> 00:47:32,750
So there's technically a distinction
between constructing the object

960
00:47:32,750 --> 00:47:35,250
with new and initializing it with init.

961
00:47:35,250 --> 00:47:39,250
But in the world of Python, you pretty
much only worry about the init method.

962
00:47:39,250 --> 00:47:42,250
Python generally does
the other part for you.

963
00:47:42,250 --> 00:47:43,000
A good question.

964
00:47:43,000 --> 00:47:44,333
Others?

965
00:47:44,333 --> 00:47:48,166
AUDIENCE: What about if you want
to store more than one name or more

966
00:47:48,166 --> 00:47:49,083
than one house?

967
00:47:49,083 --> 00:47:49,750
DAVID J. MALAN: A good question.

968
00:47:49,750 --> 00:47:52,666
If you want to store more than
one name or more than one house,

969
00:47:52,666 --> 00:47:54,083
you can do this in different ways.

970
00:47:54,083 --> 00:47:57,916
You could create other attributes--
technically called instance variables--

971
00:47:57,916 --> 00:48:01,708
like self.name1, self.name2.

972
00:48:01,708 --> 00:48:03,708
But we've seen, in the
past, that that is not

973
00:48:03,708 --> 00:48:06,291
a very good design, just to
have multiple variables to store

974
00:48:06,291 --> 00:48:07,250
multiple things.

975
00:48:07,250 --> 00:48:12,625
Maybe, instead, you have an instance
variable called self.names, plural,

976
00:48:12,625 --> 00:48:15,958
and you set it equal to a list
of names or a list of houses.

977
00:48:15,958 --> 00:48:19,000
Now, in this case, I don't think that
really solves a problem because I'm

978
00:48:19,000 --> 00:48:22,958
trying to implement a student, singular,
so it doesn't really make sense

979
00:48:22,958 --> 00:48:24,250
to have multiple first names.

980
00:48:24,250 --> 00:48:27,166
Maybe a nickname, maybe a last
name, so we could add those, too.

981
00:48:27,166 --> 00:48:29,375
But I don't think we need
multiple names per se

982
00:48:29,375 --> 00:48:31,333
and, in this case, multiple houses.

983
00:48:31,333 --> 00:48:34,500
But absolutely, you could do that using
some of our familiar building blocks

984
00:48:34,500 --> 00:48:35,916
like lists.

985
00:48:35,916 --> 00:48:37,541
Other questions?

986
00:48:37,541 --> 00:48:40,291
AUDIENCE: How are classes or
objects represented in memory?

987
00:48:40,291 --> 00:48:43,041
DAVID J. MALAN: How are classes
and objects represented in memory?

988
00:48:43,041 --> 00:48:44,958
So the class is technically just code.

989
00:48:44,958 --> 00:48:48,333
It is the code on the top of my
file-- lines 1 through fou4--

990
00:48:48,333 --> 00:48:52,250
that defines that blueprint,
that template, if you will.

991
00:48:52,250 --> 00:48:54,833
Objects are stored in
the computer's memory

992
00:48:54,833 --> 00:48:56,333
by taking up some number of bytes.

993
00:48:56,333 --> 00:48:59,125
So you're probably familiar with
bytes or kilobytes or megabytes.

994
00:48:59,125 --> 00:49:01,750
There's some chunk of
bytes, probably all

995
00:49:01,750 --> 00:49:03,708
in the same location in
the computer's memory

996
00:49:03,708 --> 00:49:07,916
or RAM, where those objects are stored.

997
00:49:07,916 --> 00:49:11,500
But that's what Python, the
program, handles for you.

998
00:49:11,500 --> 00:49:14,958
Python the interpreter figures out where
in the computer's memory to put it.

999
00:49:14,958 --> 00:49:18,041
You and I, the programmers, get to
think and solve problems at this level.

1000
00:49:18,041 --> 00:49:21,916
Python, the interpreter, handles
those lower level details for you.

1001
00:49:21,916 --> 00:49:25,166
How about one final question
on classes and objects?

1002
00:49:25,166 --> 00:49:28,125
AUDIENCE: So my question
is if we can the same do

1003
00:49:28,125 --> 00:49:31,625
the same thing with the
dictionaries, so why to use classes?

1004
00:49:31,625 --> 00:49:32,875
DAVID J. MALAN: Good question.

1005
00:49:32,875 --> 00:49:34,750
If you can do the same things
as you can with dictionaries,

1006
00:49:34,750 --> 00:49:35,958
why should you use classes?

1007
00:49:35,958 --> 00:49:38,416
Because we are just scratching
the surface now of what

1008
00:49:38,416 --> 00:49:39,833
you can do with classes.

1009
00:49:39,833 --> 00:49:42,666
Allow me to go back, now,
to my keyboard and show you

1010
00:49:42,666 --> 00:49:44,375
more of what you can do with classes.

1011
00:49:44,375 --> 00:49:47,750
But in short, you can do
much more with classes.

1012
00:49:47,750 --> 00:49:51,791
You can ensure the correctness of
your data much more with classes.

1013
00:49:51,791 --> 00:49:53,166
You can error-check things.

1014
00:49:53,166 --> 00:49:57,375
And generally, you can design more
complicated software more effectively.

1015
00:49:57,375 --> 00:49:59,458
And we'll continue to
see, today, features

1016
00:49:59,458 --> 00:50:02,416
of Python and object-oriented
programming more generally

1017
00:50:02,416 --> 00:50:04,875
that allows us to do just that.

1018
00:50:04,875 --> 00:50:09,333
So let me propose, in fact, that first,
let's just tighten up this current

1019
00:50:09,333 --> 00:50:13,916
implementation, which again has us with
an init method that just declares two

1020
00:50:13,916 --> 00:50:16,875
instance variables-- self.name and
self.house, house, which, again,

1021
00:50:16,875 --> 00:50:21,416
just creates those variables inside of
the otherwise empty object and assigns

1022
00:50:21,416 --> 00:50:22,125
them values--

1023
00:50:22,125 --> 00:50:23,708
name and house, respectively.

1024
00:50:23,708 --> 00:50:26,000
Let me go ahead and just
do one little thing here.

1025
00:50:26,000 --> 00:50:27,791
I don't really need
this student variable.

1026
00:50:27,791 --> 00:50:31,750
Let me just tighten this up so that
each time we improve or change the code,

1027
00:50:31,750 --> 00:50:35,000
we're focusing, really, on
just the minimal changes alone.

1028
00:50:35,000 --> 00:50:37,250
So I've not fundamentally
done anything different.

1029
00:50:37,250 --> 00:50:39,291
I just got rid of the
variable name, and I'm just

1030
00:50:39,291 --> 00:50:43,125
returning the return value
of this student function

1031
00:50:43,125 --> 00:50:45,125
that's constructing
my new object for me.

1032
00:50:45,125 --> 00:50:48,833
So I'm just tightening things up as
we've done many times in the past.

1033
00:50:48,833 --> 00:50:53,291
Well, what if something goes
wrong in creating this student?

1034
00:50:53,291 --> 00:50:56,791
For instance, what if the user does
not give us a name, and they just hit

1035
00:50:56,791 --> 00:50:58,791
Enter when prompted for name.

1036
00:50:58,791 --> 00:51:01,250
I don't want to put in
my computer's memory

1037
00:51:01,250 --> 00:51:04,375
a bogus student object that has no name.

1038
00:51:04,375 --> 00:51:07,833
I'd ideally like to check for
errors before I even create it

1039
00:51:07,833 --> 00:51:09,583
so I don't create a nameless student.

1040
00:51:09,583 --> 00:51:13,791
It would just be weird and probably a
bug to have an object that has no name.

1041
00:51:13,791 --> 00:51:16,208
Similarly, I don't want
the user to be able to type

1042
00:51:16,208 --> 00:51:18,708
in something random as their house.

1043
00:51:18,708 --> 00:51:21,375
At least in the world of
Harry Potter, there's really

1044
00:51:21,375 --> 00:51:23,791
only four houses, at Hogwarts at least.

1045
00:51:23,791 --> 00:51:25,666
There's, again,
Gryffindor and Hufflepuff

1046
00:51:25,666 --> 00:51:29,625
and Ravenclaw and Slytherin--
a list of four valid houses.

1047
00:51:29,625 --> 00:51:34,291
It would be nice if I somehow validated
that the user's input is indeed

1048
00:51:34,291 --> 00:51:35,541
in that list.

1049
00:51:35,541 --> 00:51:39,916
Now, I could do all of that
validation in my get_student function.

1050
00:51:39,916 --> 00:51:41,750
I could check, is the name empty?

1051
00:51:41,750 --> 00:51:44,416
If so, don't create the student object.

1052
00:51:44,416 --> 00:51:46,666
Is the house one of those four houses?

1053
00:51:46,666 --> 00:51:49,083
If not, don't create the student object.

1054
00:51:49,083 --> 00:51:52,750
But that would be rather
decoupled from the student itself.

1055
00:51:52,750 --> 00:51:57,625
get_student currently exists as just
my own function in my student.py file.

1056
00:51:57,625 --> 00:52:01,125
But classes-- and really,
object-oriented programming-- more

1057
00:52:01,125 --> 00:52:05,291
generally encourages you
to encapsulate, inside

1058
00:52:05,291 --> 00:52:09,750
of a class, all functionality
related to that class.

1059
00:52:09,750 --> 00:52:12,375
So if you want to validate
that a name exists--

1060
00:52:12,375 --> 00:52:14,750
if you want to validate
that a house is correct,

1061
00:52:14,750 --> 00:52:20,041
that belongs just fundamentally in
the class called student itself,

1062
00:52:20,041 --> 00:52:22,583
not in some random function
that you wrote elsewhere.

1063
00:52:22,583 --> 00:52:24,875
Again, this is just
methodology because, again,

1064
00:52:24,875 --> 00:52:28,541
if we think about writing code that
gets longer and longer, more and more

1065
00:52:28,541 --> 00:52:31,250
complicated, it should make
just intuitive sense that,

1066
00:52:31,250 --> 00:52:34,250
if you keep all the house--

1067
00:52:34,250 --> 00:52:37,208
all of the name and all of the
house-related code in the student,

1068
00:52:37,208 --> 00:52:38,708
it's just better organization.

1069
00:52:38,708 --> 00:52:41,583
Keep all of the related code
together, and that's probably

1070
00:52:41,583 --> 00:52:43,125
going to set you up for more success.

1071
00:52:43,125 --> 00:52:45,166
And indeed, that's part
of this methodology

1072
00:52:45,166 --> 00:52:47,125
of object-oriented programming.

1073
00:52:47,125 --> 00:52:51,916
Let me go ahead now and
change my students classes

1074
00:52:51,916 --> 00:52:53,875
init method to do this.

1075
00:52:53,875 --> 00:52:56,375
If the name is blank--

1076
00:52:56,375 --> 00:52:59,333
so if not name-- and we've seen
this kind of syntax before.

1077
00:52:59,333 --> 00:53:02,666
If you say in Python,
Pythonically, if not name,

1078
00:53:02,666 --> 00:53:04,500
that's doing something like this.

1079
00:53:04,500 --> 00:53:07,291
If name equals, equals, quote, unquote--

1080
00:53:07,291 --> 00:53:09,041
but I can do this a
little more elegantly.

1081
00:53:09,041 --> 00:53:11,958
Just say, if not name,
would be the more Pythonic.

1082
00:53:11,958 --> 00:53:15,583
Well, I want to return an error.

1083
00:53:15,583 --> 00:53:17,208
I might want to do something like this.

1084
00:53:17,208 --> 00:53:18,916
Print missing name.

1085
00:53:18,916 --> 00:53:20,541
But this is not good enough.

1086
00:53:20,541 --> 00:53:24,000
It does not suffice to
just print out missing name

1087
00:53:24,000 --> 00:53:26,083
and then let the rest
of the code go through.

1088
00:53:26,083 --> 00:53:27,791
All right, well, what
could I do instead?

1089
00:53:27,791 --> 00:53:30,791
In the past, we've seen another
technique I could do sys.exit,

1090
00:53:30,791 --> 00:53:33,583
and I could say something like
missing name, and I could go up here

1091
00:53:33,583 --> 00:53:34,750
and I could import sys.

1092
00:53:34,750 --> 00:53:37,958
But this is a really obnoxious
solution to the problem.

1093
00:53:37,958 --> 00:53:41,250
Just because you or maybe
a colleague messed up

1094
00:53:41,250 --> 00:53:43,750
and called a function
with an invalid name,

1095
00:53:43,750 --> 00:53:45,666
you're going to quit my whole program?

1096
00:53:45,666 --> 00:53:49,750
That's really, really
extreme of a response,

1097
00:53:49,750 --> 00:53:52,125
and you probably don't want
to do that if your program is

1098
00:53:52,125 --> 00:53:53,041
in the middle of running.

1099
00:53:53,041 --> 00:53:54,625
You might want to clean some stuff up.

1100
00:53:54,625 --> 00:53:57,958
You might want to save files you don't
want to just exit a program sometimes

1101
00:53:57,958 --> 00:54:01,208
in some arbitrary line, just
because input was invalid.

1102
00:54:01,208 --> 00:54:03,333
So I don't think we
want to do that either.

1103
00:54:03,333 --> 00:54:07,375
But we do, now, have a
mechanism for signaling errors.

1104
00:54:07,375 --> 00:54:09,500
Unfortunately, I can't
do something like this.

1105
00:54:09,500 --> 00:54:13,625
I could try returning none and say,
uh-uh, this student does not exist.

1106
00:54:13,625 --> 00:54:15,666
I'm going to hand you back none instead.

1107
00:54:15,666 --> 00:54:16,916
But it's too late.

1108
00:54:16,916 --> 00:54:21,416
If we scroll back down to where I'm
creating the student, it's on line 17

1109
00:54:21,416 --> 00:54:23,083
now where I've highlighted this code.

1110
00:54:23,083 --> 00:54:25,541
The student has already been created.

1111
00:54:25,541 --> 00:54:28,750
There is an object somewhere
in the computer's memory

1112
00:54:28,750 --> 00:54:30,375
that's structured as a student.

1113
00:54:30,375 --> 00:54:32,708
It just doesn't have
any values inside of it.

1114
00:54:32,708 --> 00:54:35,541
But it's too late,
therefore, to return none.

1115
00:54:35,541 --> 00:54:36,666
That ship has sailed.

1116
00:54:36,666 --> 00:54:37,958
The object exists.

1117
00:54:37,958 --> 00:54:40,458
You can't just suddenly say,
nope, nope, there is no object.

1118
00:54:40,458 --> 00:54:41,625
There is an object.

1119
00:54:41,625 --> 00:54:43,583
It's up to you to signal an error.

1120
00:54:43,583 --> 00:54:45,333
And how do you signal an error?

1121
00:54:45,333 --> 00:54:48,083
Well, we've actually seen this
before, but we haven't had occasion

1122
00:54:48,083 --> 00:54:49,583
to create our own errors.

1123
00:54:49,583 --> 00:54:54,750
It turns out, in Python, there's
another keyword related to exceptions

1124
00:54:54,750 --> 00:54:58,583
that Python itself uses to raise
all of those exceptions we've

1125
00:54:58,583 --> 00:54:59,750
talked about in the past.

1126
00:54:59,750 --> 00:55:04,500
When you've caught things like value
errors or other such exceptions that

1127
00:55:04,500 --> 00:55:09,083
come with Python, well, it turns
out you, the programmer can raise--

1128
00:55:09,083 --> 00:55:12,875
that is create your own exceptions
when something just really goes wrong--

1129
00:55:12,875 --> 00:55:15,750
not wrong enough that you want to
quit and exit the whole program,

1130
00:55:15,750 --> 00:55:18,958
but enough that you need to
somehow alert the programmer

1131
00:55:18,958 --> 00:55:20,583
that there has been an error.

1132
00:55:20,583 --> 00:55:23,583
Something exceptional, in
a very bad way-- something

1133
00:55:23,583 --> 00:55:29,250
exceptional has happened, and let them
try to catch that exception as needed.

1134
00:55:29,250 --> 00:55:32,250
So let me go back to VS
Code here and propose

1135
00:55:32,250 --> 00:55:36,500
that, if the user passes in an
invalid name-- it's just empty,

1136
00:55:36,500 --> 00:55:37,833
so there's not a name.

1137
00:55:37,833 --> 00:55:39,875
Well, what I really want to do is this.

1138
00:55:39,875 --> 00:55:43,041
I want to raise a value error.

1139
00:55:43,041 --> 00:55:45,208
And we've seen the value errors before.

1140
00:55:45,208 --> 00:55:47,833
We've created value errors
accidentally before.

1141
00:55:47,833 --> 00:55:51,416
And generally, you and I have
tried to catch them if they happen.

1142
00:55:51,416 --> 00:55:55,375
Well, the flip side of this feature of
exceptions in a language like Python

1143
00:55:55,375 --> 00:55:58,125
is that you, the programmer,
can also raise exceptions

1144
00:55:58,125 --> 00:56:00,000
when something exceptional happens.

1145
00:56:00,000 --> 00:56:01,791
And you can even be more precise.

1146
00:56:01,791 --> 00:56:05,250
You don't have to raise a generic value
error and let the programmer figure out

1147
00:56:05,250 --> 00:56:06,083
what went wrong.

1148
00:56:06,083 --> 00:56:10,291
You can treat value error and all
exceptions in Python like functions

1149
00:56:10,291 --> 00:56:14,583
and actually pass to them an explanatory
message like, quote, unquote,

1150
00:56:14,583 --> 00:56:17,875
"Missing name," so that at least
the programmer, when they encounter

1151
00:56:17,875 --> 00:56:19,458
this error, knows, oh, I messed up.

1152
00:56:19,458 --> 00:56:22,833
I didn't make sure that
the user has a name.

1153
00:56:22,833 --> 00:56:25,125
And now, what do you want to do instead?

1154
00:56:25,125 --> 00:56:28,708
Well, now, if you're the programmer,
you could do something like this.

1155
00:56:28,708 --> 00:56:34,708
You could try to create a student
except if there's a value error.

1156
00:56:34,708 --> 00:56:37,208
Then you could handle it in some way.

1157
00:56:37,208 --> 00:56:39,500
And I'm going to wave my
hand with a dot, dot, dot,

1158
00:56:39,500 --> 00:56:40,791
at how you would handle it.

1159
00:56:40,791 --> 00:56:44,666
But you would handle it using try and
accept, just like we have in the past,

1160
00:56:44,666 --> 00:56:46,666
and that would allow
you, the programmer,

1161
00:56:46,666 --> 00:56:48,166
to try to create the student.

1162
00:56:48,166 --> 00:56:52,291
But if something goes wrong,
OK, I'll handle it nonetheless.

1163
00:56:52,291 --> 00:56:54,958
So what's new here, again,
is this raise keyword,

1164
00:56:54,958 --> 00:56:59,250
that just lets you and I
actually raise our own exceptions

1165
00:56:59,250 --> 00:57:00,458
to signal these errors.

1166
00:57:00,458 --> 00:57:03,000
Well, let me go back to
my code here, and I'm just

1167
00:57:03,000 --> 00:57:06,208
going to go ahead and not bother
trying or catching this error.

1168
00:57:06,208 --> 00:57:09,083
For now, we'll just focus
on raising it and assume

1169
00:57:09,083 --> 00:57:12,375
that, from our recon exceptions,
you could add try and accept

1170
00:57:12,375 --> 00:57:13,833
as needed in places.

1171
00:57:13,833 --> 00:57:16,916
Let me go back to the code here and
propose that something else could

1172
00:57:16,916 --> 00:57:18,416
go wrong with house.

1173
00:57:18,416 --> 00:57:19,791
If there is a name, we're good.

1174
00:57:19,791 --> 00:57:22,083
But if we're given a
house but it's invalid,

1175
00:57:22,083 --> 00:57:24,958
we should probably raise
an exception for that, too.

1176
00:57:24,958 --> 00:57:26,208
So what if we do this?

1177
00:57:26,208 --> 00:57:32,208
If house is not in the list containing
"Gryffindor," quote, unquote,

1178
00:57:32,208 --> 00:57:34,708
"Hufflepuff," quote, unquote--

1179
00:57:34,708 --> 00:57:38,875
let's see, "Ravenclaw," quote,
unquote, or "Slytherin,"

1180
00:57:38,875 --> 00:57:41,833
quote, unquote, then,
with my colon, let's

1181
00:57:41,833 --> 00:57:43,416
raise another type of value error.

1182
00:57:43,416 --> 00:57:45,458
But rather than raise
a generic value error,

1183
00:57:45,458 --> 00:57:49,750
let's pass in an argument,
quote, unquote, "Invalid house."

1184
00:57:49,750 --> 00:57:52,708
And so here we now see
a capability that we

1185
00:57:52,708 --> 00:57:55,916
can do with classes that
we can't with dictionaries.

1186
00:57:55,916 --> 00:58:00,541
If you add an attribute to a
dictionary, a key to a dictionary,

1187
00:58:00,541 --> 00:58:02,083
it's going in no matter what.

1188
00:58:02,083 --> 00:58:06,000
Even if the name is empty, even if the
house is a completely random string

1189
00:58:06,000 --> 00:58:07,833
of text that's not one
of these four houses,

1190
00:58:07,833 --> 00:58:09,333
it's going into that dictionary.

1191
00:58:09,333 --> 00:58:12,708
But with a class, and by
way of this init method,

1192
00:58:12,708 --> 00:58:17,750
you and I can now control exactly what's
going to be installed, if you will,

1193
00:58:17,750 --> 00:58:19,041
inside of this object.

1194
00:58:19,041 --> 00:58:22,458
You have a little more
control now over correctness.

1195
00:58:22,458 --> 00:58:26,583
And so now let me go ahead and scroll
back down to my terminal window

1196
00:58:26,583 --> 00:58:27,291
and clear it.

1197
00:58:27,291 --> 00:58:29,500
Let me run Python of student.py.

1198
00:58:29,500 --> 00:58:31,250
Let me type in something like Harry.

1199
00:58:31,250 --> 00:58:33,958
Let me type in Gryffindor,
Enter, and we see

1200
00:58:33,958 --> 00:58:35,666
that, indeed, Harry is from Gryffindor.

1201
00:58:35,666 --> 00:58:37,666
What if I made a mistake, though?

1202
00:58:37,666 --> 00:58:40,750
What if I ran Python of student.py
and typed Harry as the name,

1203
00:58:40,750 --> 00:58:44,416
but this time typed in Number
Four, Privet Drive, which

1204
00:58:44,416 --> 00:58:47,500
is where he grew up, instead
of his proper Hogwarts house.

1205
00:58:47,500 --> 00:58:51,333
Let me hit Enter now, and
now you see a value error.

1206
00:58:51,333 --> 00:58:54,458
But this isn't one that Python
generated for us, per se.

1207
00:58:54,458 --> 00:58:56,166
I raised this error.

1208
00:58:56,166 --> 00:58:59,666
And therefore, if I went in and wrote
more code in my get_student function,

1209
00:58:59,666 --> 00:59:04,666
I could also catch this error
with our usual try except syntax.

1210
00:59:04,666 --> 00:59:09,250
So all we have now is not just classes
in our toolkit, but even more powers

1211
00:59:09,250 --> 00:59:12,583
when it comes to exceptions, and
not just catching them ourselves

1212
00:59:12,583 --> 00:59:15,333
but raising them ourselves, too.

1213
00:59:15,333 --> 00:59:21,708
Any questions now on this use of
classes and init and now this ability

1214
00:59:21,708 --> 00:59:26,000
to raise exceptions when something goes
wrong inside of the initialization?

1215
00:59:26,000 --> 00:59:29,416
AUDIENCE: So what if the
user has a middle name--

1216
00:59:29,416 --> 00:59:31,291
name, middle name, and last name?

1217
00:59:31,291 --> 00:59:32,750
How would you fix that?

1218
00:59:32,750 --> 00:59:35,250
DAVID J. MALAN: Good question.

1219
00:59:35,250 --> 00:59:38,916
If you wanted the student to have a
first name, middle name, and last name,

1220
00:59:38,916 --> 00:59:41,041
we could do this in a
bunch of different ways.

1221
00:59:41,041 --> 00:59:44,458
The simplest, though, if-- let
me clear my screen here, and let

1222
00:59:44,458 --> 00:59:46,041
me just temporarily do this.

1223
00:59:46,041 --> 00:59:51,333
Let me propose that the init method take
in a first argument, a middle argument,

1224
00:59:51,333 --> 00:59:53,000
and a last argument.

1225
00:59:53,000 --> 00:59:57,833
And then what I think I would do down
here is ultimately have first = first,

1226
00:59:57,833 --> 01:00:00,916
and then I would do the same
thing for middle and last.

1227
01:00:00,916 --> 01:00:05,541
So middle and middle,
and then last and last.

1228
01:00:05,541 --> 01:00:08,583
And then what I would
have to do here is,

1229
01:00:08,583 --> 01:00:11,208
when I actually ask the
user for their name,

1230
01:00:11,208 --> 01:00:12,750
I might need to really go all out.

1231
01:00:12,750 --> 01:00:15,166
I might need to ask them
first for their first name

1232
01:00:15,166 --> 01:00:18,916
and store that in a variable called
first, and therefore pass in first.

1233
01:00:18,916 --> 01:00:21,833
I might similarly need to ask
them for their middle name

1234
01:00:21,833 --> 01:00:25,500
and store that in a variable and then
pass in a second argument, middle.

1235
01:00:25,500 --> 01:00:28,375
And then lastly, if you will,
let me go ahead and create

1236
01:00:28,375 --> 01:00:31,916
a third variable called last, get
the input for their last name,

1237
01:00:31,916 --> 01:00:34,041
and pass that in as well.

1238
01:00:34,041 --> 01:00:38,125
I could instead just use one input and
just ask them for their whole name.

1239
01:00:38,125 --> 01:00:42,583
So type in David Malan, Enter, or
David J. Malan-- all three of them,

1240
01:00:42,583 --> 01:00:45,666
and maybe I could use
Python's split function,

1241
01:00:45,666 --> 01:00:47,583
maybe a regular expression
to tease it apart.

1242
01:00:47,583 --> 01:00:49,625
That's probably going to
be messy because there's

1243
01:00:49,625 --> 01:00:52,083
going to be people who don't
have just two or three names.

1244
01:00:52,083 --> 01:00:53,458
They might have four or five.

1245
01:00:53,458 --> 01:00:55,958
So maybe sometimes it's better
to have multiple prompts.

1246
01:00:55,958 --> 01:00:58,291
But that's not a problem
because, with a class,

1247
01:00:58,291 --> 01:01:02,291
we have the expressiveness to
take in more arguments if we want.

1248
01:01:02,291 --> 01:01:04,041
We could even take a list if we wanted.

1249
01:01:04,041 --> 01:01:06,916
But I think we'd probably want to
have even more error checking then,

1250
01:01:06,916 --> 01:01:11,458
not just for name but for first,
and then maybe for middle, and then

1251
01:01:11,458 --> 01:01:12,208
maybe for last.

1252
01:01:12,208 --> 01:01:14,541
So it just is more and more
code, though there would be

1253
01:01:14,541 --> 01:01:17,041
ways to perhaps consolidate that, too.

1254
01:01:17,041 --> 01:01:22,500
Let me undo all of that and see if there
are other questions now on classes.

1255
01:01:22,500 --> 01:01:24,291
AUDIENCE: I assume
classes are something I

1256
01:01:24,291 --> 01:01:25,916
might do at the beginning of a project.

1257
01:01:25,916 --> 01:01:28,583
Can I just put them in a
different file and import them

1258
01:01:28,583 --> 01:01:32,083
into my project, or my
main code as needed?

1259
01:01:32,083 --> 01:01:33,208
DAVID J. MALAN: Absolutely.

1260
01:01:33,208 --> 01:01:34,208
A really good question.

1261
01:01:34,208 --> 01:01:36,083
You could imagine wanting
to use this student

1262
01:01:36,083 --> 01:01:40,666
class, not just in student.py but in
other files or other projects of yours.

1263
01:01:40,666 --> 01:01:44,458
And absolutely, you can create
your own library of classes

1264
01:01:44,458 --> 01:01:48,000
by putting the student class
in your own module or package,

1265
01:01:48,000 --> 01:01:50,583
per our discussion in the past
about libraries more generally.

1266
01:01:50,583 --> 01:01:52,250
And absolutely, you can do that.

1267
01:01:52,250 --> 01:01:54,833
And later today, what
we see is we've actually

1268
01:01:54,833 --> 01:01:58,166
been using classes-- you and I--
before, in third party libraries.

1269
01:01:58,166 --> 01:02:00,416
So you, too, can absolutely do the same.

1270
01:02:00,416 --> 01:02:03,666
How about one more question on classes?

1271
01:02:03,666 --> 01:02:06,541
AUDIENCE: Can you have
optional variables in classes?

1272
01:02:06,541 --> 01:02:09,666
And two, can you have your
own error names, like--

1273
01:02:09,666 --> 01:02:13,250
let's be egotistical and say
I want to raise Eric error?

1274
01:02:13,250 --> 01:02:16,166
DAVID J. MALAN: Short answer, yes.

1275
01:02:16,166 --> 01:02:18,750
These init functions are just
like Python functions more

1276
01:02:18,750 --> 01:02:21,000
generally, even though they're
special in that they're

1277
01:02:21,000 --> 01:02:23,666
going to get called
automatically by Python for you.

1278
01:02:23,666 --> 01:02:25,375
But if you wanted to
make house optional,

1279
01:02:25,375 --> 01:02:26,750
you could do something like this.

1280
01:02:26,750 --> 01:02:31,791
You could give it a default value
in the init function's signature

1281
01:02:31,791 --> 01:02:34,250
so to speak-- in that first
line of code on line two.

1282
01:02:34,250 --> 01:02:36,875
And that would allow me to
not have to pass in house.

1283
01:02:36,875 --> 01:02:39,750
In this case, I'm going to continue
to always pass in name and house,

1284
01:02:39,750 --> 01:02:41,500
but you could make things optional.

1285
01:02:41,500 --> 01:02:45,458
And yes, to your second question, if you
wanted to have your own error message,

1286
01:02:45,458 --> 01:02:50,791
like an Eric error, you could actually
create your own Eric error exception.

1287
01:02:50,791 --> 01:02:53,000
And we'll see, in a little
bit, that there's actually

1288
01:02:53,000 --> 01:02:58,041
a whole suite of exceptions that exist,
and you, too, can invent those as well.

1289
01:02:58,041 --> 01:03:01,375
Let me propose, though,
that we now introduce

1290
01:03:01,375 --> 01:03:06,250
one other aspect of this whereby we try
printing out what a student looks like.

1291
01:03:06,250 --> 01:03:08,916
At the moment, if I scroll
back down to my main function,

1292
01:03:08,916 --> 01:03:11,791
I'm still printing the student's
name and house very manually.

1293
01:03:11,791 --> 01:03:14,833
I'm going inside of the
object, doing student.name,

1294
01:03:14,833 --> 01:03:17,708
and I'm going inside of the object
again and getting student.house,

1295
01:03:17,708 --> 01:03:20,750
just to see where the student is from.

1296
01:03:20,750 --> 01:03:23,666
But wouldn't it be nice if I
could just print the student,

1297
01:03:23,666 --> 01:03:25,583
like I've been printing for weeks--

1298
01:03:25,583 --> 01:03:29,458
any, int, or float, or str,
or any other data type?

1299
01:03:29,458 --> 01:03:32,500
Well, let's see what happens if
I just try printing the student,

1300
01:03:32,500 --> 01:03:36,166
instead of manually going inside and
trying to create that sentence myself.

1301
01:03:36,166 --> 01:03:39,250
Well, in my terminal window-- let me
go ahead and run Python of student.py

1302
01:03:39,250 --> 01:03:40,166
again.

1303
01:03:40,166 --> 01:03:41,250
Let me type in Harry.

1304
01:03:41,250 --> 01:03:42,541
Let me type in Gryffindor.

1305
01:03:42,541 --> 01:03:50,333
And voila, Harry-- whoa, OK, main
student object at 0x102733e80.

1306
01:03:50,333 --> 01:03:51,916
Well, what is going on?

1307
01:03:51,916 --> 01:03:53,708
Well, if you were to
run the same code, you

1308
01:03:53,708 --> 01:03:56,000
might actually see something
different on your computer

1309
01:03:56,000 --> 01:03:57,208
in terms of that number.

1310
01:03:57,208 --> 01:04:01,958
But what you're really seeing is the
underlying representation, as a string,

1311
01:04:01,958 --> 01:04:03,625
of this specific object.

1312
01:04:03,625 --> 01:04:06,875
In particular, you're seeing where
in the computer's memory it is.

1313
01:04:06,875 --> 01:04:12,750
This number, 30x102733e80, refers
to, essentially, a specific location

1314
01:04:12,750 --> 01:04:14,541
in the computer's memory or RAM.

1315
01:04:14,541 --> 01:04:19,166
That's not really that interesting
for me or you or, generally speaking,

1316
01:04:19,166 --> 01:04:22,250
programmers, but it's just
the default way of describing,

1317
01:04:22,250 --> 01:04:25,791
via print, what this thing is.

1318
01:04:25,791 --> 01:04:28,250
But I can override this as well.

1319
01:04:28,250 --> 01:04:31,791
It turns out that there are
other special methods in Python

1320
01:04:31,791 --> 01:04:32,958
when it comes to classes--

1321
01:04:32,958 --> 01:04:36,375
not just underscore underscore,
init, underscore underscore,

1322
01:04:36,375 --> 01:04:40,541
but, continuing in that same
pattern, underscore underscore, str,

1323
01:04:40,541 --> 01:04:42,041
underscore underscore.

1324
01:04:42,041 --> 01:04:47,000
So this, too, is a special method that,
if you define it inside of your class,

1325
01:04:47,000 --> 01:04:50,541
Python will just automatically
call this function

1326
01:04:50,541 --> 01:04:56,541
for you any time some other function
wants to see your object as a string.

1327
01:04:56,541 --> 01:04:59,750
Print wants to see your
object as a string.

1328
01:04:59,750 --> 01:05:02,958
But by default, if you don't have
this method defined in your class,

1329
01:05:02,958 --> 01:05:06,416
it's going to print out that very
ugly esoteric incarnation thereof,

1330
01:05:06,416 --> 01:05:10,416
where it says main__.Student
object at 0x, dot, dot, dot.

1331
01:05:10,416 --> 01:05:13,250
Well, how can I then
define my own str function?

1332
01:05:13,250 --> 01:05:17,041
Well, here, back in VS Code,
let me propose that I go in

1333
01:05:17,041 --> 01:05:23,416
and define not just __ init, but let me
define a second function in this class

1334
01:05:23,416 --> 01:05:25,041
here, as follows--

1335
01:05:25,041 --> 01:05:28,416
def __ str __.

1336
01:05:28,416 --> 01:05:29,333
There are two.

1337
01:05:29,333 --> 01:05:32,541
Even though the font in VS Code is
putting the two underscore so close,

1338
01:05:32,541 --> 01:05:34,375
it just looks like a longer underscore.

1339
01:05:34,375 --> 01:05:37,583
There are indeed two there, on the
left and the right just like for init.

1340
01:05:37,583 --> 01:05:42,791
This one only takes one argument that,
by convention, is always called self

1341
01:05:42,791 --> 01:05:44,500
so that you have access to it.

1342
01:05:44,500 --> 01:05:47,708
And then, indented below
that after a colon,

1343
01:05:47,708 --> 01:05:51,125
I'm going to go ahead and create
a format string and return it.

1344
01:05:51,125 --> 01:05:53,500
So let me go ahead and return--

1345
01:05:53,500 --> 01:05:56,375
how about something generic
first like "a student."

1346
01:05:56,375 --> 01:05:58,916
So I'm not going to bother
even trying to figure out

1347
01:05:58,916 --> 01:06:00,625
what this student's name or house is.

1348
01:06:00,625 --> 01:06:02,875
I'm just going to always
return "a student."

1349
01:06:02,875 --> 01:06:08,666
Let me go back now to my earlier code,
which has print (student) on line 16.

1350
01:06:08,666 --> 01:06:13,041
Let me clear my terminal window and
rerun Python of student.py, Enter.

1351
01:06:13,041 --> 01:06:14,958
Type in Harry, type in Gryffindor.

1352
01:06:14,958 --> 01:06:17,333
Last time, I saw that
very cryptic output.

1353
01:06:17,333 --> 01:06:20,958
This time, I see, more
generically, "a student."

1354
01:06:20,958 --> 01:06:23,375
More readable but not very enlightening.

1355
01:06:23,375 --> 01:06:24,541
Which student is this?

1356
01:06:24,541 --> 01:06:31,791
Well, notice that the double underscore
str method takes in this self argument

1357
01:06:31,791 --> 01:06:36,708
by default. It's just the way the
Python authors designed this method.

1358
01:06:36,708 --> 01:06:41,833
It will always be passed a reference
to the current student object.

1359
01:06:41,833 --> 01:06:43,000
What do I mean by that?

1360
01:06:43,000 --> 01:06:45,916
When this line of code
on line 6 is called,

1361
01:06:45,916 --> 01:06:48,666
print, because it's hoping
it's going to get a string,

1362
01:06:48,666 --> 01:06:52,750
is going to trigger the underscore
underscore, str, underscore

1363
01:06:52,750 --> 01:06:54,458
underscore method to be called.

1364
01:06:54,458 --> 01:06:58,416
And Python, for you, automatically
is going to pass into that method

1365
01:06:58,416 --> 01:07:01,208
a reference to the object
that's trying to be

1366
01:07:01,208 --> 01:07:05,291
printed so that you, the programmer,
can do something like this.

1367
01:07:05,291 --> 01:07:08,000
Here's an f string with
double quotes as usual.

1368
01:07:08,000 --> 01:07:10,458
I'm going to use some curly
braces and say print out

1369
01:07:10,458 --> 01:07:14,250
self.name from self.house.

1370
01:07:14,250 --> 01:07:17,458
So there's nothing new
in what I've just done.

1371
01:07:17,458 --> 01:07:19,958
It's just an f string--
an f on the beginning,

1372
01:07:19,958 --> 01:07:22,708
two double quotes, a couple
of pairs of curly braces.

1373
01:07:22,708 --> 01:07:28,750
But because, automatically, this str
method gets passed self, so to speak,

1374
01:07:28,750 --> 01:07:32,333
a reference to the current object,
I can go inside of that object

1375
01:07:32,333 --> 01:07:33,083
and grab the name.

1376
01:07:33,083 --> 01:07:36,000
I can go inside that object
again and grab the house.

1377
01:07:36,000 --> 01:07:38,791
So now, when I go back
to my terminal window--

1378
01:07:38,791 --> 01:07:41,041
previously it just
printed out a student.

1379
01:07:41,041 --> 01:07:44,416
But now, if I run Python
of student.py, Enter--

1380
01:07:44,416 --> 01:07:48,083
type in Harry, type in Gryffindor,
and one more time hit Enter,

1381
01:07:48,083 --> 01:07:50,750
Harry is again from Gryffindor.

1382
01:07:50,750 --> 01:07:52,500
But if I run this yet again--

1383
01:07:52,500 --> 01:07:57,125
let's, for instance, do Draco
is from Slytherin, Enter.

1384
01:07:57,125 --> 01:07:58,625
Draco's from Slytherin.

1385
01:07:58,625 --> 01:08:04,291
Now it's customized to the specific
object that we're trying to print.

1386
01:08:04,291 --> 01:08:08,250
Questions on this function here--

1387
01:08:08,250 --> 01:08:11,666
this Dunder str method.

1388
01:08:11,666 --> 01:08:14,541
AUDIENCE: Is there anything else
that the underscore underscore,

1389
01:08:14,541 --> 01:08:16,666
str method can do?

1390
01:08:16,666 --> 01:08:19,416
The other question is, what's the
difference between str and repr.

1391
01:08:19,416 --> 01:08:20,750
DAVID J. MALAN: A good question.

1392
01:08:20,750 --> 01:08:24,458
So there are many other methods
that come with Python classes

1393
01:08:24,458 --> 01:08:26,041
that start with underscore underscore.

1394
01:08:26,041 --> 01:08:27,958
We're just scratching the
surface, and we'll pretty much

1395
01:08:27,958 --> 01:08:29,083
focus primarily on these.

1396
01:08:29,083 --> 01:08:30,833
But yes, there are
many others, and we'll

1397
01:08:30,833 --> 01:08:33,666
see at least one other
in just a little bit.

1398
01:08:33,666 --> 01:08:37,375
Among the others is one
called repr, which is

1399
01:08:37,375 --> 01:08:39,583
a representation of the Python object.

1400
01:08:39,583 --> 01:08:43,000
Generally speaking, the
underscore underscore, repr,

1401
01:08:43,000 --> 01:08:45,791
underscore underscore method
is meant for developers' eyes.

1402
01:08:45,791 --> 01:08:49,166
It typically has more information
than "Harry from Gryffindor."

1403
01:08:49,166 --> 01:08:53,083
It would also say what type of
object it is, like a student, capital

1404
01:08:53,083 --> 01:08:56,583
S, whereas underscore underscore, str,
underscore underscore is generally

1405
01:08:56,583 --> 01:08:58,125
meant for users--

1406
01:08:58,125 --> 01:09:01,500
the users of the program, and it's
meant to be even more user-friendly.

1407
01:09:01,500 --> 01:09:04,208
But both of those can be
overridden as you see fit.

1408
01:09:04,208 --> 01:09:08,041
Well, let me propose now that we pick
up where we've left off on student

1409
01:09:08,041 --> 01:09:11,958
and just add even more functionality,
but not just these special methods

1410
01:09:11,958 --> 01:09:15,166
like double underscore init
and double underscore str.

1411
01:09:15,166 --> 01:09:18,750
Let's create our own methods
because therein lies the real power

1412
01:09:18,750 --> 01:09:21,875
and flexibility of classes if
you and I as the programmers

1413
01:09:21,875 --> 01:09:25,291
can invent new functionality
that's specific to students.

1414
01:09:25,291 --> 01:09:29,125
For instance, students at
Hogwarts, over the time in school,

1415
01:09:29,125 --> 01:09:31,500
learn how to cast a
certain type of spell.

1416
01:09:31,500 --> 01:09:34,083
So when they say, Expecto
Patronum, something

1417
01:09:34,083 --> 01:09:36,083
comes out of their wand
that typically resembles

1418
01:09:36,083 --> 01:09:37,458
an animal or something like that.

1419
01:09:37,458 --> 01:09:40,000
It's a special spell that they
have to practice and practice.

1420
01:09:40,000 --> 01:09:44,041
So let's see if we can't store, not
just the student's name and their house,

1421
01:09:44,041 --> 01:09:47,041
but also their "patronus,"
what, actually, they

1422
01:09:47,041 --> 01:09:48,625
conjure when using this spell.

1423
01:09:48,625 --> 01:09:50,750
Well, let me go ahead and
clear my terminal window.

1424
01:09:50,750 --> 01:09:56,583
And in the top of my code here, in the
init method of Student, let me go ahead

1425
01:09:56,583 --> 01:10:00,875
and start expecting a third argument,
in addition to self, which automatically

1426
01:10:00,875 --> 01:10:02,833
gets passed in, called patronus.

1427
01:10:02,833 --> 01:10:06,125
And I'm not going to worry,
for now, on validating

1428
01:10:06,125 --> 01:10:10,041
the patronus from an official list
of valid patronuses, or patroni.

1429
01:10:10,041 --> 01:10:13,041
I'm instead going to go
ahead and just blindly assign

1430
01:10:13,041 --> 01:10:16,458
it to self.patronus
= patronus, and we're

1431
01:10:16,458 --> 01:10:19,083
going to let the user type
whatever they want for now.

1432
01:10:19,083 --> 01:10:21,333
But I could certainly
add more error checking

1433
01:10:21,333 --> 01:10:25,583
if I wanted to limit the patronus
to a specific list of them here.

1434
01:10:25,583 --> 01:10:29,000
Let me go ahead now and prompt
the user for this patronus,

1435
01:10:29,000 --> 01:10:33,666
as by-- in my get_student
function-- defining a variable

1436
01:10:33,666 --> 01:10:36,375
called patronus or anything
else, prompting the user

1437
01:10:36,375 --> 01:10:38,333
for input for their patronus.

1438
01:10:38,333 --> 01:10:42,708
And now I'm going to go ahead and
pass in that third variable here.

1439
01:10:42,708 --> 01:10:46,041
So again, similar in spirit to just
adding more and more attributes

1440
01:10:46,041 --> 01:10:47,875
to the class, I'm going
to pass in all three

1441
01:10:47,875 --> 01:10:49,791
of these values instead of just two.

1442
01:10:49,791 --> 01:10:52,333
I'm not going to do anything
interesting with that value yet.

1443
01:10:52,333 --> 01:10:55,583
But just to make sure I haven't made
things worse by breaking my code,

1444
01:10:55,583 --> 01:10:57,875
let me run Python of student.py.

1445
01:10:57,875 --> 01:10:59,083
I'll type in Harry.

1446
01:10:59,083 --> 01:11:00,416
I'll type in Gryffindor.

1447
01:11:00,416 --> 01:11:02,500
And it turns out his
patronus was a stag, .

1448
01:11:02,500 --> 01:11:06,125
And hit Enter I haven't seen
what his patronus is in my output

1449
01:11:06,125 --> 01:11:08,708
because I didn't change
my str method yet.

1450
01:11:08,708 --> 01:11:10,625
But at least I don't
have any syntax errors.

1451
01:11:10,625 --> 01:11:12,958
So at least I've not
made anything worse.

1452
01:11:12,958 --> 01:11:16,416
But suppose, now, I want to
have functionality, not just

1453
01:11:16,416 --> 01:11:19,708
for initializing a student
and printing out a student.

1454
01:11:19,708 --> 01:11:23,666
If my class is really meant
to be a student, what I can do

1455
01:11:23,666 --> 01:11:27,416
is not just remember information
about data about students.

1456
01:11:27,416 --> 01:11:31,291
What's powerful about classes,
unlike dictionaries alone,

1457
01:11:31,291 --> 01:11:36,708
is that classes can have, not just
variables or instance variables--

1458
01:11:36,708 --> 01:11:38,625
those attributes we keep creating.

1459
01:11:38,625 --> 01:11:42,458
They can also have
functions built in, a.k.a.

1460
01:11:42,458 --> 01:11:43,083
methods.

1461
01:11:43,083 --> 01:11:45,958
When a function is inside of a
class, it's called a "method,"

1462
01:11:45,958 --> 01:11:47,666
but it's still just a function.

1463
01:11:47,666 --> 01:11:51,000
At this point, we've seen two
functions already-- two methods--

1464
01:11:51,000 --> 01:11:54,958
called a double underscore
init and double underscore str,

1465
01:11:54,958 --> 01:11:57,958
but those are special methods
in that they just work.

1466
01:11:57,958 --> 01:12:01,416
If you define them, Python calls
them automatically for you.

1467
01:12:01,416 --> 01:12:04,958
But what if you wanted to create
more functionality for a student

1468
01:12:04,958 --> 01:12:09,000
so that your class really represents
this real world, or maybe "fantasy"

1469
01:12:09,000 --> 01:12:13,375
world notion of a student, where
students not only have names and houses

1470
01:12:13,375 --> 01:12:16,375
and patronuses; they
also have functionality.

1471
01:12:16,375 --> 01:12:22,541
They have actions they can perform like
casting a charm, a spell, magically.

1472
01:12:22,541 --> 01:12:26,333
Could we implement, therefore,
a function called charm, that

1473
01:12:26,333 --> 01:12:30,291
actually uses their magical knowledge?

1474
01:12:30,291 --> 01:12:33,791
Well, let's go ahead and define
our very own function as follows.

1475
01:12:33,791 --> 01:12:37,583
Let me clear my terminal window,
scroll back up to my student class.

1476
01:12:37,583 --> 01:12:40,916
And instead of creating yet
another function that's special,

1477
01:12:40,916 --> 01:12:45,416
with double underscores, I'm going
to invent my own function, or method,

1478
01:12:45,416 --> 01:12:46,916
inside of this class.

1479
01:12:46,916 --> 01:12:51,500
I want to give Harry and Hermione
and all of the other students

1480
01:12:51,500 --> 01:12:55,000
the ability to cast charms, so I'm
going to define a function that I

1481
01:12:55,000 --> 01:12:57,291
can completely, on my own, call charm.

1482
01:12:57,291 --> 01:12:59,125
I could call this
function anything I want.

1483
01:12:59,125 --> 01:13:01,708
But because it's a
method inside of a class,

1484
01:13:01,708 --> 01:13:06,083
the convention is that it's always going
to take at least one argument, called

1485
01:13:06,083 --> 01:13:11,000
self, by convention so that you
have access to the current object,

1486
01:13:11,000 --> 01:13:13,083
even if you don't plan
to use it, per se.

1487
01:13:13,083 --> 01:13:16,708
All right, let me go ahead and propose
that we implement charm in such a way

1488
01:13:16,708 --> 01:13:21,750
that the method returns an emoji
that's appropriate for each student's

1489
01:13:21,750 --> 01:13:23,125
patronus.

1490
01:13:23,125 --> 01:13:25,750
How to implement this-- well,
inside of the charm method,

1491
01:13:25,750 --> 01:13:29,041
let's go ahead and
match on self.patronus,

1492
01:13:29,041 --> 01:13:31,416
which is the instance variable
containing a string that

1493
01:13:31,416 --> 01:13:33,458
represents each student's patronus.

1494
01:13:33,458 --> 01:13:38,208
And in the case that it matches a stag,
for instance, for Harry, let's go ahead

1495
01:13:38,208 --> 01:13:40,333
and return maybe the closest emoji--

1496
01:13:40,333 --> 01:13:41,750
this horse here.

1497
01:13:41,750 --> 01:13:44,625
How about in the case of an otter?

1498
01:13:44,625 --> 01:13:49,708
Well, in that case, let's go ahead and
return, oh, maybe the closest match

1499
01:13:49,708 --> 01:13:52,583
to the otter, which
might be this emoji here.

1500
01:13:52,583 --> 01:13:57,000
And let's see, in the case of a--
for Ron, rather than Hermione--

1501
01:13:57,000 --> 01:14:02,791
a Jack Russell terrier,
let's go ahead and return--

1502
01:14:02,791 --> 01:14:04,625
don't have as many options here.

1503
01:14:04,625 --> 01:14:08,750
Why don't we go ahead and return the
cutest available dog in that case.

1504
01:14:08,750 --> 01:14:14,250
And in the case of no
patronus recognized,

1505
01:14:14,250 --> 01:14:16,375
as might cover someone
like Draco, let's go ahead

1506
01:14:16,375 --> 01:14:19,750
and use a default case using
the underscore as in the past,

1507
01:14:19,750 --> 01:14:22,791
and let's go ahead and return
for this-- oh, what should happen

1508
01:14:22,791 --> 01:14:24,250
if someone doesn't have a patronus?

1509
01:14:24,250 --> 01:14:26,541
Why don't we just see
a magical wand that

1510
01:14:26,541 --> 01:14:28,958
seems to fizzle out, as in this case?

1511
01:14:28,958 --> 01:14:31,333
All right, well, now, rather
than just print the student,

1512
01:14:31,333 --> 01:14:33,375
let's go about printing
their actual patronus.

1513
01:14:33,375 --> 01:14:36,000
So I'm going to go down
to my main function here.

1514
01:14:36,000 --> 01:14:39,250
I'm going to still get a student,
using the get_student function.

1515
01:14:39,250 --> 01:14:44,208
But rather than print student, let's go
ahead and declare "Expecto Patronum!"

1516
01:14:44,208 --> 01:14:46,791
printing out just that as pure text.

1517
01:14:46,791 --> 01:14:50,750
And now let's go ahead and print
out, not the student but, rather,

1518
01:14:50,750 --> 01:14:54,416
the return value of
their own charm method.

1519
01:14:54,416 --> 01:14:58,583
So let me go back down to my terminal
window and run Python of student.py

1520
01:14:58,583 --> 01:14:59,708
and Enter.

1521
01:14:59,708 --> 01:15:01,250
Name-- let's start with Harry.

1522
01:15:01,250 --> 01:15:03,500
He lives in Gryffindor.

1523
01:15:03,500 --> 01:15:05,083
Patronus is a stag.

1524
01:15:05,083 --> 01:15:06,291
And let's see--

1525
01:15:06,291 --> 01:15:08,125
Expecto Patronum!

1526
01:15:08,125 --> 01:15:10,708
And of course, we'd see the stag emoji.

1527
01:15:10,708 --> 01:15:13,333
What about someone like Draco,
who, at least in the books,

1528
01:15:13,333 --> 01:15:15,333
doesn't have a known patronus?

1529
01:15:15,333 --> 01:15:17,416
Well, let's go ahead and
clear my terminal window,

1530
01:15:17,416 --> 01:15:22,625
rerun Python of student.py, and this
time, let's type in Draco for name,

1531
01:15:22,625 --> 01:15:25,750
Slytherin for house,
and Patronus is unknown.

1532
01:15:25,750 --> 01:15:27,583
So I'm just going to
go ahead and hit Enter.

1533
01:15:27,583 --> 01:15:29,666
And now, Expecto Patronum!

1534
01:15:29,666 --> 01:15:32,916
And it just of sizzles instead.

1535
01:15:32,916 --> 01:15:38,208
Well, let me propose, now, that
we remove this patronus code just

1536
01:15:38,208 --> 01:15:41,833
to simplify our world and
focus on some of the other core

1537
01:15:41,833 --> 01:15:43,208
capabilities of classes.

1538
01:15:43,208 --> 01:15:44,958
So at the risk of
disappointing, I'm going

1539
01:15:44,958 --> 01:15:47,916
to get rid of all of these
beautiful emoji and charms,

1540
01:15:47,916 --> 01:15:51,875
and I'm going to go ahead and stop
asking the user now for their patronus.

1541
01:15:51,875 --> 01:15:54,708
And I'm going to stop
passing it into init here.

1542
01:15:54,708 --> 01:15:57,541
And I'm going to stop doing this here.

1543
01:15:57,541 --> 01:16:03,333
And I'm going to instead just go ahead
and restore our use of print student

1544
01:16:03,333 --> 01:16:06,541
here, and I'm going to go ahead
and get rid of patronus down here.

1545
01:16:06,541 --> 01:16:10,541
So just essentially undo all of
the fun charms we just created.

1546
01:16:10,541 --> 01:16:16,291
So we're now back at the point in the
story where we have a student class,

1547
01:16:16,291 --> 01:16:18,041
with only two methods--

1548
01:16:18,041 --> 01:16:19,416
init and str.

1549
01:16:19,416 --> 01:16:21,375
The first of those
takes, of course, self

1550
01:16:21,375 --> 01:16:25,125
as the first argument as it always will,
plus two more now-- name and house,

1551
01:16:25,125 --> 01:16:26,208
no more patronus.

1552
01:16:26,208 --> 01:16:28,041
We're validating name up here.

1553
01:16:28,041 --> 01:16:29,833
We're validating house down here.

1554
01:16:29,833 --> 01:16:32,375
And then we're assigning
name and house, respectively,

1555
01:16:32,375 --> 01:16:35,625
to two instance variables
called name and house also.

1556
01:16:35,625 --> 01:16:38,875
But we use self to get
access to the current object,

1557
01:16:38,875 --> 01:16:40,750
to store those values therein.

1558
01:16:40,750 --> 01:16:44,583
We then still have our str method
here, which takes one argument--

1559
01:16:44,583 --> 01:16:46,208
by default, self, and that's it.

1560
01:16:46,208 --> 01:16:49,750
And that function is going to
be called automatically any time

1561
01:16:49,750 --> 01:16:52,625
you want to convert a
student object to a string,

1562
01:16:52,625 --> 01:16:55,125
just like print might want to do here.

1563
01:16:55,125 --> 01:16:57,791
So let me go ahead and just make
sure I haven't broken anything.

1564
01:16:57,791 --> 01:16:59,750
Let me run Python of student.py.

1565
01:16:59,750 --> 01:17:00,916
I'll type in Harry.

1566
01:17:00,916 --> 01:17:03,041
I'll type in Gryffindor, Enter.

1567
01:17:03,041 --> 01:17:04,416
OK, we're back in business.

1568
01:17:04,416 --> 01:17:08,166
Gone are the charms and patronus,
but at least I'm back to a situation

1569
01:17:08,166 --> 01:17:10,250
where I have names and houses.

1570
01:17:10,250 --> 01:17:14,416
But it turns out, at the
moment, our use of classes

1571
01:17:14,416 --> 01:17:20,083
is not very robust, even though we
have this mechanism, very cleverly,

1572
01:17:20,083 --> 01:17:23,041
if I may, in our init
method of making sure

1573
01:17:23,041 --> 01:17:27,125
that we're validating name and house,
making sure that name is not blank,

1574
01:17:27,125 --> 01:17:32,625
and making sure that house is a valid
house among those four Hogwarts houses.

1575
01:17:32,625 --> 01:17:35,208
It turns out that
classes will still let me

1576
01:17:35,208 --> 01:17:38,541
get at those attributes, those
so-called instance variables,

1577
01:17:38,541 --> 01:17:40,750
using dot notation anyway.

1578
01:17:40,750 --> 01:17:44,500
Let me scroll down then and try
to do this a little adversarially.

1579
01:17:44,500 --> 01:17:48,500
Suppose that online 16 I go
ahead and call get_student,

1580
01:17:48,500 --> 01:17:52,541
which exists as before, and then I
store the return value in a student

1581
01:17:52,541 --> 01:17:54,791
variable-- again, on line 16.

1582
01:17:54,791 --> 01:18:00,291
That will ensure that get_student gets
called, which calls input and input.

1583
01:18:00,291 --> 01:18:02,916
And then it calls the
student constructor,

1584
01:18:02,916 --> 01:18:05,541
which invokes, automatically,
this init method.

1585
01:18:05,541 --> 01:18:08,458
So by way of how we've
laid out my code, we're

1586
01:18:08,458 --> 01:18:11,750
going to ensure that name is not
blank and house is definitely

1587
01:18:11,750 --> 01:18:12,916
one of those four values.

1588
01:18:12,916 --> 01:18:16,541
My error correction-- or
error checking is in place.

1589
01:18:16,541 --> 01:18:20,708
But if I'm a little adversarial,
I can still circumvent it.

1590
01:18:20,708 --> 01:18:25,541
Suppose that-- fine, going to require
me to type in Harry and Gryffindor?

1591
01:18:25,541 --> 01:18:28,083
I'm going to go ahead
and type in student.house

1592
01:18:28,083 --> 01:18:31,541
equals, quote, unquote,
"Number Four, Privet Drive,"

1593
01:18:31,541 --> 01:18:33,333
and you're not going
to be able to stop me.

1594
01:18:33,333 --> 01:18:34,083
Why?

1595
01:18:34,083 --> 01:18:36,708
Well, it turns out,
with classes and objects

1596
01:18:36,708 --> 01:18:40,375
thereof, you and I can still
access those instance variables

1597
01:18:40,375 --> 01:18:42,083
using this familiar dot notation.

1598
01:18:42,083 --> 01:18:45,125
That's how we began the story of
classes-- just setting these attributes

1599
01:18:45,125 --> 01:18:45,875
ourselves.

1600
01:18:45,875 --> 01:18:48,541
But you can also read
these attributes themselves

1601
01:18:48,541 --> 01:18:50,750
and change them later if you want.

1602
01:18:50,750 --> 01:18:55,833
And this will effectively circumvent the
if condition and the other if condition

1603
01:18:55,833 --> 01:19:00,000
in our init method because that
is only called when you first

1604
01:19:00,000 --> 01:19:02,125
create the student object.

1605
01:19:02,125 --> 01:19:04,541
There's nothing stopping
me, at the moment,

1606
01:19:04,541 --> 01:19:08,291
from just changing the
house or the name after.

1607
01:19:08,291 --> 01:19:12,541
So if I now clear my terminal
window and run Python of student.py,

1608
01:19:12,541 --> 01:19:16,208
I'll still type in Harry and
Gryffindor to meet my requirements

1609
01:19:16,208 --> 01:19:17,916
that the house be one of those four.

1610
01:19:17,916 --> 01:19:21,375
But when it's printed, notice,
I've still overridden it.

1611
01:19:21,375 --> 01:19:26,083
So it seems that, while classes do allow
us a little more control over the data

1612
01:19:26,083 --> 01:19:30,250
we're storing, it doesn't
necessarily prevent the user--

1613
01:19:30,250 --> 01:19:33,625
or rather the programmer-- be
it myself or maybe a colleague,

1614
01:19:33,625 --> 01:19:35,791
from still messing things up.

1615
01:19:35,791 --> 01:19:39,083
So here, too, in the spirit
of programming a little more

1616
01:19:39,083 --> 01:19:43,916
defensively, allow me to introduce
another feature of Python as well--

1617
01:19:43,916 --> 01:19:46,208
namely properties.

1618
01:19:46,208 --> 01:19:49,375
So a property is really
just an attribute

1619
01:19:49,375 --> 01:19:52,750
that has even more defense
mechanisms put into place,

1620
01:19:52,750 --> 01:19:58,208
a little more functionality implemented
by you to prevent programmers, like me

1621
01:19:58,208 --> 01:20:01,083
and you, from messing things
up like these attributes.

1622
01:20:01,083 --> 01:20:04,375
So again, a property is going to
be an attribute that you and I just

1623
01:20:04,375 --> 01:20:06,083
have more control over.

1624
01:20:06,083 --> 01:20:06,750
How?

1625
01:20:06,750 --> 01:20:09,791
We just write a little more code,
using some Python conventions.

1626
01:20:09,791 --> 01:20:14,333
And how we're going to do that is going
to use, in just a moment, a feature--

1627
01:20:14,333 --> 01:20:18,083
a keyword known as @property,
which is technically a function.

1628
01:20:18,083 --> 01:20:19,916
Property is a function in Python.

1629
01:20:19,916 --> 01:20:24,791
But we're about to see some new @ syntax
that allows you to decorate functions.

1630
01:20:24,791 --> 01:20:26,125
And this, too, is a term of art.

1631
01:20:26,125 --> 01:20:28,916
In the world of Python,
you can have decorators,

1632
01:20:28,916 --> 01:20:33,166
which are functions that modify
the behavior of other functions,

1633
01:20:33,166 --> 01:20:36,708
if you will, and we'll leave it at that
without going too much into the weeds.

1634
01:20:36,708 --> 01:20:39,291
And we'll see, by, example how
you can use these decorators,

1635
01:20:39,291 --> 01:20:41,541
specifically to define properties.

1636
01:20:41,541 --> 01:20:43,708
So let me go back to VS Code here.

1637
01:20:43,708 --> 01:20:46,791
And let me propose that I do this.

1638
01:20:46,791 --> 01:20:49,375
I'm going to go ahead and create--

1639
01:20:49,375 --> 01:20:54,291
how about a property
called house as follows.

1640
01:20:54,291 --> 01:21:00,833
Inside of my student class, I'm going
to go ahead-- and below my init method

1641
01:21:00,833 --> 01:21:03,958
and below my str method, I'm
going to go ahead and define

1642
01:21:03,958 --> 01:21:09,000
a function called house that takes, as
it always must, one argument at least,

1643
01:21:09,000 --> 01:21:10,041
called self.

1644
01:21:10,041 --> 01:21:15,458
And what I'm going to do
now is return self.house.

1645
01:21:15,458 --> 01:21:17,625
So I'm just going to
define a method called

1646
01:21:17,625 --> 01:21:23,375
house, whose sole purpose in life
is to return the value of house.

1647
01:21:23,375 --> 01:21:27,375
But I'm going to define one other
method, curiously also called house,

1648
01:21:27,375 --> 01:21:31,375
but that's going to take into,
as arguments, two values--

1649
01:21:31,375 --> 01:21:35,625
self as always and also
a value called house.

1650
01:21:35,625 --> 01:21:37,291
And I'm going to now do this.

1651
01:21:40,375 --> 01:21:43,958
I'm going to do self.house = house.

1652
01:21:43,958 --> 01:21:45,250
Now, what have I done?

1653
01:21:45,250 --> 01:21:47,625
Well, let me just temporarily
add some comments here.

1654
01:21:47,625 --> 01:21:50,166
In a moment, we're going to
start referring to this generally

1655
01:21:50,166 --> 01:21:51,083
as a getter.

1656
01:21:51,083 --> 01:21:54,083
And down here, I'm going to
refer to this as a setter.

1657
01:21:54,083 --> 01:21:56,875
And this is terminology frequently
see in the world of Java.

1658
01:21:56,875 --> 01:21:58,791
Some of you have
programmed in Java before.

1659
01:21:58,791 --> 01:22:01,875
But as the names imply,
a getter is a function

1660
01:22:01,875 --> 01:22:05,333
for a class that gets some attributes.

1661
01:22:05,333 --> 01:22:10,291
A setter is a function in some
class that sets some value.

1662
01:22:10,291 --> 01:22:14,125
And now, even though we're not done, and
there's a bit of a mistake in the code

1663
01:22:14,125 --> 01:22:17,916
I've already written, intuitively,
what we're going to do is this.

1664
01:22:17,916 --> 01:22:21,000
We're trying to prevent
programmers, myself included,

1665
01:22:21,000 --> 01:22:23,541
from circumventing my
error checking that I

1666
01:22:23,541 --> 01:22:25,666
put into place for name and house.

1667
01:22:25,666 --> 01:22:26,958
How can I do that?

1668
01:22:26,958 --> 01:22:29,500
Well, we don't have that many
building blocks in programming.

1669
01:22:29,500 --> 01:22:33,541
We have things like variables for data,
and we have functions for actions.

1670
01:22:33,541 --> 01:22:35,000
Well, why don't we do this?

1671
01:22:35,000 --> 01:22:39,958
Why don't we somehow require that,
in order to access an attribute,

1672
01:22:39,958 --> 01:22:41,375
you go through some function.

1673
01:22:41,375 --> 01:22:44,583
And let's require that, in
order to set some attribute,

1674
01:22:44,583 --> 01:22:46,291
you go through some function.

1675
01:22:46,291 --> 01:22:51,958
And conventionally, those functions are
called a getter function and a setter

1676
01:22:51,958 --> 01:22:52,708
function.

1677
01:22:52,708 --> 01:22:56,541
And why are we using functions or, in
this case, methods inside of a class?

1678
01:22:56,541 --> 01:23:00,000
Well, once you have functions,
those are just actions or verbs

1679
01:23:00,000 --> 01:23:01,583
that you and I can create ourselves.

1680
01:23:01,583 --> 01:23:05,208
We can put any error correction
I want in these functions

1681
01:23:05,208 --> 01:23:08,416
because it's code that's going
to get executed top to bottom.

1682
01:23:08,416 --> 01:23:15,541
So how can I now prevent the user from
setting the house to an invalid value?

1683
01:23:15,541 --> 01:23:20,500
Let me borrow some logic from before
rather than blindly do this-- just set

1684
01:23:20,500 --> 01:23:25,291
self.house equal to the house value
that's passed in-- let's add our error

1685
01:23:25,291 --> 01:23:26,166
checking there.

1686
01:23:26,166 --> 01:23:34,791
So if house is not in the following
list of Gryffindor or Hufflepuff

1687
01:23:34,791 --> 01:23:40,708
or Ravenclaw or
Slytherin, just as before,

1688
01:23:40,708 --> 01:23:44,541
let's go ahead and raise a value error,
just to signify that, uh-uh, something

1689
01:23:44,541 --> 01:23:45,291
has gone wrong.

1690
01:23:45,291 --> 01:23:46,333
I'll be more explicit.

1691
01:23:46,333 --> 01:23:50,541
I'll include a message like,
"invalid house," quote, unquote.

1692
01:23:50,541 --> 01:23:56,166
Otherwise, I'm going to proceed on,
now, line 21 to set self.house to house.

1693
01:23:56,166 --> 01:24:00,416
So I've just copied, if you will,
or retyped my error checking inside

1694
01:24:00,416 --> 01:24:02,333
of this so-called setter function.

1695
01:24:02,333 --> 01:24:03,666
Now, why have I done that?

1696
01:24:03,666 --> 01:24:07,458
Well, to be clear, whenever
the user or the programmer

1697
01:24:07,458 --> 01:24:12,375
writes code like this,
student.house equals, what's

1698
01:24:12,375 --> 01:24:16,166
about to happen magically
is Python will not just

1699
01:24:16,166 --> 01:24:19,916
let the programmer access student
house directly-- that attribute,

1700
01:24:19,916 --> 01:24:21,750
that instance variable, a.k.a.

1701
01:24:21,750 --> 01:24:22,875
self house.

1702
01:24:22,875 --> 01:24:26,833
It's instead going to
magically automatically call

1703
01:24:26,833 --> 01:24:28,791
this setter function for me.

1704
01:24:28,791 --> 01:24:30,708
How does Python know to do that?

1705
01:24:30,708 --> 01:24:35,666
Well, if it's see that, on the
left-hand side, there is self.house,

1706
01:24:35,666 --> 01:24:42,125
where house is the name of the getter or
setter, and then it sees an equal sign,

1707
01:24:42,125 --> 01:24:45,625
indicating assignment, that's just
enough of a visual clue to say,

1708
01:24:45,625 --> 01:24:46,208
wait a minute.

1709
01:24:46,208 --> 01:24:49,250
I'm not going to let you
access that attribute directly.

1710
01:24:49,250 --> 01:24:51,791
I'm going to use the setter instead.

1711
01:24:51,791 --> 01:24:52,291
Why?

1712
01:24:52,291 --> 01:24:54,291
Because the equal sign
means I'm trying to set.

1713
01:24:54,291 --> 01:24:58,250
I'm trying to assign a value from
right to left into that attribute.

1714
01:24:58,250 --> 01:25:00,500
So what Python's is
going to do automatically

1715
01:25:00,500 --> 01:25:02,083
is call this function for me.

1716
01:25:02,083 --> 01:25:06,708
And that's amazing because now I can
execute code-- an algorithm to check,

1717
01:25:06,708 --> 01:25:08,625
do I want to let the user--

1718
01:25:08,625 --> 01:25:12,041
the programmer set that
attribute to that value?

1719
01:25:12,041 --> 01:25:13,916
If not, I'm going to
raise a value error,

1720
01:25:13,916 --> 01:25:15,833
and you're just not going
to be able to do it.

1721
01:25:15,833 --> 01:25:17,500
If so fine.

1722
01:25:17,500 --> 01:25:19,416
I'll go ahead and set it for you.

1723
01:25:19,416 --> 01:25:21,958
But in order to do this, we
need a little more syntax.

1724
01:25:21,958 --> 01:25:25,375
And I'm going to get rid of my comment,
and I'm going to use that decorator.

1725
01:25:25,375 --> 01:25:29,583
I need to tell Python to
treat this method as a getter.

1726
01:25:29,583 --> 01:25:32,083
And then the syntax for the
setter is a little different.

1727
01:25:32,083 --> 01:25:34,500
You now say house.setter.

1728
01:25:34,500 --> 01:25:37,500
I wish one was getter
and the other was setter.

1729
01:25:37,500 --> 01:25:39,458
That's not the way they designed it.

1730
01:25:39,458 --> 01:25:44,291
When you want to define a getter, you
just say @property above the function.

1731
01:25:44,291 --> 01:25:48,833
And you name the function exactly
like you would like the property

1732
01:25:48,833 --> 01:25:51,000
to be called-- quote, unquote, "house."

1733
01:25:51,000 --> 01:25:54,416
Once you do that, you can
now use a new decorator

1734
01:25:54,416 --> 01:25:57,625
that's automatically created
for you called @house,

1735
01:25:57,625 --> 01:25:58,750
because I called it house.

1736
01:25:58,750 --> 01:26:01,416
And then you literally
say, @house.setter.

1737
01:26:01,416 --> 01:26:05,333
And this whole line, on
line 17, is a clue to Python

1738
01:26:05,333 --> 01:26:08,750
that here comes a function,
whose name is identical--

1739
01:26:08,750 --> 01:26:12,541
but notice that it takes two arguments--
both self, so you have access

1740
01:26:12,541 --> 01:26:15,208
to the contents of the object,
and house, which is just

1741
01:26:15,208 --> 01:26:20,041
going to be a str that comes from the
programmer from the human input return

1742
01:26:20,041 --> 01:26:23,958
value so that you can
set that value as well.

1743
01:26:23,958 --> 01:26:27,375
But there's one fix I
need to make now, here.

1744
01:26:27,375 --> 01:26:29,625
Everything else, I think, is still good.

1745
01:26:29,625 --> 01:26:31,250
However watch this.

1746
01:26:31,250 --> 01:26:34,500
I no longer need this error check here.

1747
01:26:34,500 --> 01:26:35,333
Why?

1748
01:26:35,333 --> 01:26:39,375
Because, if I scroll back
down to my code here,

1749
01:26:39,375 --> 01:26:46,250
I claimed a moment ago that code
like this, with student.house equals,

1750
01:26:46,250 --> 01:26:49,666
is going to automatically get
Python to call my setter for me.

1751
01:26:49,666 --> 01:26:50,666
Guess what?

1752
01:26:50,666 --> 01:26:55,875
Even up here, in my init method,
calling self.house equals

1753
01:26:55,875 --> 01:27:00,208
is also going to call my
setter method, which is amazing

1754
01:27:00,208 --> 01:27:06,083
because now I can keep all of my error
checking in one place in the setter,

1755
01:27:06,083 --> 01:27:10,833
and it will now get called either when
I create the object for the first time,

1756
01:27:10,833 --> 01:27:14,541
because of init, or
even if the programmer

1757
01:27:14,541 --> 01:27:19,375
tries to circumvent that init method
and change the value of this attribute,

1758
01:27:19,375 --> 01:27:21,041
my setter will also get called.

1759
01:27:21,041 --> 01:27:26,000
My setter will get called
any time I access .house.

1760
01:27:26,000 --> 01:27:28,458
But there's one fix I need to make.

1761
01:27:28,458 --> 01:27:32,958
Unfortunately, I have collided names.

1762
01:27:32,958 --> 01:27:38,458
Right now, if we go up here, on line
5, this is an instance variable.

1763
01:27:38,458 --> 01:27:42,333
It's a string inside of my self,
inside of the current student object,

1764
01:27:42,333 --> 01:27:43,083
called name.

1765
01:27:43,083 --> 01:27:46,958
And this is another instance
variable called house.

1766
01:27:46,958 --> 01:27:51,291
Unfortunately, if I have an instance
variable called name and house,

1767
01:27:51,291 --> 01:27:54,750
I cannot also have
functions called house.

1768
01:27:54,750 --> 01:27:55,916
They're going to collide.

1769
01:27:55,916 --> 01:27:57,041
You've got to decide.

1770
01:27:57,041 --> 01:27:59,250
Do you want the variable
to be called house?

1771
01:27:59,250 --> 01:28:01,708
Or do you want the function
to be called house?

1772
01:28:01,708 --> 01:28:04,208
Unfortunately, you can't
have both because now Python

1773
01:28:04,208 --> 01:28:06,041
is going to confuse one for the other.

1774
01:28:06,041 --> 01:28:09,291
So the conventional fix
for this is to do this--

1775
01:28:09,291 --> 01:28:15,250
to have the setter not store the
value that's passed in self.house,

1776
01:28:15,250 --> 01:28:19,125
but to use an almost identical name,
but to use a little indicator that

1777
01:28:19,125 --> 01:28:21,208
means you know doing this correctly.

1778
01:28:21,208 --> 01:28:23,666
You typically, by
convention, put an underscore

1779
01:28:23,666 --> 01:28:27,041
in front of the instance
variable's name.

1780
01:28:27,041 --> 01:28:31,208
And when you return it up here,
you similarly put an underscore.

1781
01:28:31,208 --> 01:28:36,541
So now, technically, my instance
variable is called _house,

1782
01:28:36,541 --> 01:28:41,791
but my property, which is a
fancier attribute, if you will,

1783
01:28:41,791 --> 01:28:44,916
is called house alone.

1784
01:28:44,916 --> 01:28:48,666
Huge amount of syntax, I know,
but it's a very powerful feature.

1785
01:28:48,666 --> 01:28:52,708
And again, this is why you can graduate
from dictionaries alone and have

1786
01:28:52,708 --> 01:28:55,500
so much more functionality
at your disposal.

1787
01:28:55,500 --> 01:28:58,916
Let me go ahead and clear my terminal
window and run Python of student.py,

1788
01:28:58,916 --> 01:29:00,458
Enter, name.

1789
01:29:00,458 --> 01:29:02,708
All right, let's go
ahead and type in Harry.

1790
01:29:02,708 --> 01:29:04,625
Let's go ahead and type in Gryffindor.

1791
01:29:04,625 --> 01:29:06,416
Crossing my fingers as always.

1792
01:29:06,416 --> 01:29:09,083
And now, look, "Invalid house."

1793
01:29:09,083 --> 01:29:10,250
This is a good thing.

1794
01:29:10,250 --> 01:29:10,750
Why?

1795
01:29:10,750 --> 01:29:13,958
Because, notice, in
my main function, I'm

1796
01:29:13,958 --> 01:29:19,125
still trying, maliciously, if
you will, to change Harry's house

1797
01:29:19,125 --> 01:29:21,000
to not be one of the four valid ones.

1798
01:29:21,000 --> 01:29:24,833
I'm trying to change it to his childhood
home of Number Four, Privet Drive.

1799
01:29:24,833 --> 01:29:29,208
But because Python knows that, wait
a minute, you're trying to assign--

1800
01:29:29,208 --> 01:29:30,708
that is, set a value--

1801
01:29:30,708 --> 01:29:34,208
and that value, a.k.a.
house, is now defined

1802
01:29:34,208 --> 01:29:38,333
as a property you're going to have to
go through the setter function instead

1803
01:29:38,333 --> 01:29:40,958
to even let you change that value.

1804
01:29:40,958 --> 01:29:44,208
And because I have
this raise ValueError.

1805
01:29:44,208 --> 01:29:46,916
If the house is not as
intended, you're not

1806
01:29:46,916 --> 01:29:49,458
going to be allowed to change
it to an invalid value.

1807
01:29:49,458 --> 01:29:52,458
So I'm protecting the data on the
way in, through the init method,

1808
01:29:52,458 --> 01:29:56,708
and I'm even defending the data
if you try to override it there.

1809
01:29:56,708 --> 01:29:59,208
So I think the only solution
for me, the programmer,

1810
01:29:59,208 --> 01:30:01,250
is, don't try to break my own code.

1811
01:30:01,250 --> 01:30:04,083
Let me remove that line because
it's just not going to work.

1812
01:30:04,083 --> 01:30:07,250
Let me run Python of student.py
and, again, type in Harry;

1813
01:30:07,250 --> 01:30:10,916
type in Gryffindor, Enter, and
Harry's indeed from Gryffindor.

1814
01:30:10,916 --> 01:30:15,708
If I did something incorrect,
like Harry from Number Four,

1815
01:30:15,708 --> 01:30:20,541
Privet Drive, Enter, we're again
going to see the value error

1816
01:30:20,541 --> 01:30:25,083
because my code just doesn't let
that value in via manual input now

1817
01:30:25,083 --> 01:30:28,541
or via that adversarial change.

1818
01:30:28,541 --> 01:30:29,958
All right, that was a lot.

1819
01:30:29,958 --> 01:30:35,208
But any question on properties?

1820
01:30:35,208 --> 01:30:37,125
AUDIENCE: Why we are
using getter then setter?

1821
01:30:37,125 --> 01:30:41,541
It's just for the purpose
so that we can find

1822
01:30:41,541 --> 01:30:43,791
that method, that function in our code.

1823
01:30:43,791 --> 01:30:46,833
DAVID J. MALAN: The reason that I'm
going through the trouble of defining

1824
01:30:46,833 --> 01:30:52,375
this getter or setter is because I want
to make sure that programmers cannot do

1825
01:30:52,375 --> 01:30:53,250
things like this.

1826
01:30:53,250 --> 01:30:55,500
If I'm going through the
trouble of validating

1827
01:30:55,500 --> 01:30:58,708
the attributes for
these student objects,

1828
01:30:58,708 --> 01:31:02,041
I don't want you to be able to go in
there and just change them at will.

1829
01:31:02,041 --> 01:31:04,625
I want to have some
control over that object

1830
01:31:04,625 --> 01:31:07,708
so that you can just trust that it's
going to be correct as designed.

1831
01:31:07,708 --> 01:31:11,041
So using a getter and
setter really just enables

1832
01:31:11,041 --> 01:31:15,416
Python to automatically detect when
you're trying to manually set a value.

1833
01:31:15,416 --> 01:31:18,333
The equal sign and the dot,
as I've highlighted here,

1834
01:31:18,333 --> 01:31:20,666
is enough of a clue to Python
to realize, wait a minute,

1835
01:31:20,666 --> 01:31:21,916
you're trying to set a value.

1836
01:31:21,916 --> 01:31:24,750
Let me see if this class
has a setter defined.

1837
01:31:24,750 --> 01:31:26,875
And if so, I'm going to
call that, and I'm not just

1838
01:31:26,875 --> 01:31:30,125
going to blindly assign the
value from right to left.

1839
01:31:30,125 --> 01:31:32,541
So it's just giving me more control.

1840
01:31:32,541 --> 01:31:35,041
Other questions on properties.

1841
01:31:35,041 --> 01:31:39,458
AUDIENCE: When we use getters,
we just have just one argument.

1842
01:31:39,458 --> 01:31:43,291
And if we use setters, it's
always going to be two arguments?

1843
01:31:43,291 --> 01:31:44,291
Is that normal?

1844
01:31:44,291 --> 01:31:45,291
DAVID J. MALAN: Correct.

1845
01:31:45,291 --> 01:31:47,833
It's always going to
be one argument-- self

1846
01:31:47,833 --> 01:31:52,625
for the getter, two arguments for
the setter-- self and something else.

1847
01:31:52,625 --> 01:31:55,375
And the intuition for that
is, if you're getting a value,

1848
01:31:55,375 --> 01:31:58,875
you don't need to pass anything else
in because you already know the object.

1849
01:31:58,875 --> 01:32:00,291
It's called student in this case.

1850
01:32:00,291 --> 01:32:02,791
So you're just going to get
the value of that property.

1851
01:32:02,791 --> 01:32:05,458
But if you want to set the
property to something else,

1852
01:32:05,458 --> 01:32:07,125
you've got to pass in that argument.

1853
01:32:07,125 --> 01:32:09,625
You've got to pass in the value
to which you want to set it.

1854
01:32:09,625 --> 01:32:11,291
So it's always 0 or 1.

1855
01:32:11,291 --> 01:32:17,541
However, you see it as 1 or 2 because,
again, any function inside of a class,

1856
01:32:17,541 --> 01:32:18,041
a.k.a.

1857
01:32:18,041 --> 01:32:22,291
a method, is going to be automatically
passed self so that you have access

1858
01:32:22,291 --> 01:32:25,208
to that current object in memory.

1859
01:32:25,208 --> 01:32:27,708
How about one other
question on properties?

1860
01:32:27,708 --> 01:32:31,791
AUDIENCE: Why didn't we use the
same underscore house init method?

1861
01:32:31,791 --> 01:32:33,125
DAVID J. MALAN: A good question.

1862
01:32:33,125 --> 01:32:36,750
So even though I'm using the
underscore house here, in my setter,

1863
01:32:36,750 --> 01:32:39,125
and the underscore house
here, in my getter,

1864
01:32:39,125 --> 01:32:41,958
I deliberately did not use it up here.

1865
01:32:41,958 --> 01:32:47,333
The reason for that is that, by
using self.house and this equal sign,

1866
01:32:47,333 --> 01:32:50,375
that's the same pattern that
I want Python to recognize.

1867
01:32:50,375 --> 01:32:53,208
I want Python to
automatically call the setter,

1868
01:32:53,208 --> 01:32:56,791
even when I'm passing in the
house via the init method.

1869
01:32:56,791 --> 01:33:01,458
If I were to change this to do this,
that would circumvent the setter,

1870
01:33:01,458 --> 01:33:05,041
and now there's no error
checking in init whatsoever.

1871
01:33:05,041 --> 01:33:06,333
So it's such a fine line.

1872
01:33:06,333 --> 01:33:10,041
The only thing standing between us and
error checking or no error checking

1873
01:33:10,041 --> 01:33:12,750
is the presence or absence
of this underscore.

1874
01:33:12,750 --> 01:33:14,625
But that's typically the convention.

1875
01:33:14,625 --> 01:33:17,375
By not using the
underscore there, make sure

1876
01:33:17,375 --> 01:33:19,708
that even that assignment
goes through the setter

1877
01:33:19,708 --> 01:33:22,416
so that, honestly, I, don't have
to copy paste the same error

1878
01:33:22,416 --> 01:33:23,583
checking in two places.

1879
01:33:23,583 --> 01:33:25,375
I can put it just in the setter.

1880
01:33:25,375 --> 01:33:28,791
So it's a better design, and that's
why I manually retyped it at first,

1881
01:33:28,791 --> 01:33:31,166
but then I deleted it from init.

1882
01:33:31,166 --> 01:33:34,625
Well, allow me to propose that we
make one other change to this file.

1883
01:33:34,625 --> 01:33:38,708
Might as well go ahead and define
a property for name as well.

1884
01:33:38,708 --> 01:33:41,458
And let me go ahead and do this--
maybe above the house property

1885
01:33:41,458 --> 01:33:45,041
just to keep things in the same
order as I defined them earlier.

1886
01:33:45,041 --> 01:33:47,375
Let me give myself another property.

1887
01:33:47,375 --> 01:33:49,125
This one is going to be called name.

1888
01:33:49,125 --> 01:33:51,583
It's going to take one argument
called self, as always.

1889
01:33:51,583 --> 01:33:55,625
And this one, very similarly, is
just going to return self._name.

1890
01:33:55,625 --> 01:33:57,333
So I'm going to
anticipate that I'm going

1891
01:33:57,333 --> 01:34:01,166
to have to rename name also so that
I don't have that same collision as

1892
01:34:01,166 --> 01:34:01,875
before.

1893
01:34:01,875 --> 01:34:05,541
But now let me go ahead
and define another setter--

1894
01:34:05,541 --> 01:34:06,750
this one for name.

1895
01:34:06,750 --> 01:34:09,416
So the convention is @name.setter.

1896
01:34:09,416 --> 01:34:10,375
Why name?

1897
01:34:10,375 --> 01:34:13,916
Because the property I just
created is called name.

1898
01:34:13,916 --> 01:34:18,833
So the getter and setter work in
conjunction in this way, if you will.

1899
01:34:18,833 --> 01:34:22,291
Let me go down under that name
setter and define another function,

1900
01:34:22,291 --> 01:34:23,375
also called name.

1901
01:34:23,375 --> 01:34:25,791
But the key thing here is
that it's not identical.

1902
01:34:25,791 --> 01:34:30,000
It's not the exact same function name
and the exact same number of arguments.

1903
01:34:30,000 --> 01:34:32,500
The setter, again,
takes a second argument.

1904
01:34:32,500 --> 01:34:34,250
And I can call it
anything I want, but I'm

1905
01:34:34,250 --> 01:34:36,750
going to call it name because
that's what's being passed in.

1906
01:34:36,750 --> 01:34:39,041
And I'm going to put
my error checking here.

1907
01:34:39,041 --> 01:34:43,541
If not name, just like we used to do,
let's go ahead and raise a value error,

1908
01:34:43,541 --> 01:34:48,750
and let's put an explanatory message
like "Missing name," quote, unquote.

1909
01:34:48,750 --> 01:34:55,250
Otherwise, let's go ahead and
update self._name to equal name.

1910
01:34:55,250 --> 01:34:58,500
And I don't have to change
init except to get rid

1911
01:34:58,500 --> 01:35:02,333
of this duplicate error
checking now because, again,

1912
01:35:02,333 --> 01:35:07,166
if I use self.name equals here
and self.house equals here

1913
01:35:07,166 --> 01:35:09,916
with no underscore, both
of those assignments

1914
01:35:09,916 --> 01:35:13,375
are going to go through my
two setter functions now.

1915
01:35:13,375 --> 01:35:15,416
Before we run this, let
me go ahead and remove

1916
01:35:15,416 --> 01:35:18,791
this adversarial code, which we know
won't work because we're catching it.

1917
01:35:18,791 --> 01:35:22,375
Let me go back down to my terminal
window and run Python of student.py,

1918
01:35:22,375 --> 01:35:22,916
Enter.

1919
01:35:22,916 --> 01:35:23,958
Let's type in Harry.

1920
01:35:23,958 --> 01:35:25,125
Let's type in Gryffindor.

1921
01:35:25,125 --> 01:35:26,708
And that seems to work.

1922
01:35:26,708 --> 01:35:29,458
Let's try though, again,
to run Python of student.py

1923
01:35:29,458 --> 01:35:32,708
with Harry from Number
Four, Privet Drive.

1924
01:35:32,708 --> 01:35:34,416
This will not work.

1925
01:35:34,416 --> 01:35:37,291
A value error with invalid
house, because that's not

1926
01:35:37,291 --> 01:35:38,791
one of the four Hogwarts houses.

1927
01:35:38,791 --> 01:35:41,041
And now, for good measure,
let's run it one more time.

1928
01:35:41,041 --> 01:35:42,583
And let's not even give it a name.

1929
01:35:42,583 --> 01:35:44,375
Let's just hit Enter when prompted.

1930
01:35:44,375 --> 01:35:45,875
I can type anything for the house.

1931
01:35:45,875 --> 01:35:47,958
I'll go ahead and still
give it Gryffindor, Enter.

1932
01:35:47,958 --> 01:35:52,958
And now we get another value error,
but this one is for missing name.

1933
01:35:52,958 --> 01:35:56,500
So we seem, now, to have all the
more of a defense mechanism in place

1934
01:35:56,500 --> 01:35:58,833
to ensure that name is as we expect.

1935
01:35:58,833 --> 01:36:01,000
It's got to have some
value that's not blank.

1936
01:36:01,000 --> 01:36:02,500
And house is as we expect.

1937
01:36:02,500 --> 01:36:05,000
It's got to have one
of those four values.

1938
01:36:05,000 --> 01:36:08,000
But at the risk of
bursting everyone's bubble

1939
01:36:08,000 --> 01:36:11,958
and making you wonder, why did
we just go through all of that,

1940
01:36:11,958 --> 01:36:18,875
unfortunately Python really focuses
on conventions, not hard constraints.

1941
01:36:18,875 --> 01:36:20,291
And by that, I mean this.

1942
01:36:20,291 --> 01:36:25,208
If I go back into my main function
after I've gotten a student on line 30

1943
01:36:25,208 --> 01:36:30,375
and I try to adversarially do something
like this-- student.house equals

1944
01:36:30,375 --> 01:36:33,625
"Number Four, Privet
Drive," we know this

1945
01:36:33,625 --> 01:36:37,416
won't work because my setter for
house is going to catch this.

1946
01:36:37,416 --> 01:36:38,333
Watch again.

1947
01:36:38,333 --> 01:36:40,833
Python of student.py.

1948
01:36:40,833 --> 01:36:42,041
Let's type in Harry.

1949
01:36:42,041 --> 01:36:44,541
Let's type in Gryffindor,
which will at least pass

1950
01:36:44,541 --> 01:36:46,958
our check that's induced by init.

1951
01:36:46,958 --> 01:36:52,041
But line 31 is going to trigger
the same setter to be called,

1952
01:36:52,041 --> 01:36:55,583
and we're going to raise a value
error saying "Invalid house."

1953
01:36:55,583 --> 01:36:58,250
Unfortunately, and if
some of you are already

1954
01:36:58,250 --> 01:37:02,375
thinking a little adversarially,
tragically, look what you can do.

1955
01:37:02,375 --> 01:37:05,500
You can change .house to be ._house.

1956
01:37:05,500 --> 01:37:06,041
Why?

1957
01:37:06,041 --> 01:37:10,416
Well, the instance variable
is now called _house.

1958
01:37:10,416 --> 01:37:13,125
The property is called
house, no underscore.

1959
01:37:13,125 --> 01:37:19,041
But the underlying attribute implemented
as an instance variable is still called

1960
01:37:19,041 --> 01:37:19,791
_house.

1961
01:37:19,791 --> 01:37:23,541
And tragically, Python of student.py.

1962
01:37:23,541 --> 01:37:25,000
Let's type in Harry.

1963
01:37:25,000 --> 01:37:27,375
Let's type in Gryffindor,
which is correct.

1964
01:37:27,375 --> 01:37:28,958
But watch what happens now.

1965
01:37:28,958 --> 01:37:30,333
Oh, my God.

1966
01:37:30,333 --> 01:37:32,000
We slip through.

1967
01:37:32,000 --> 01:37:35,708
So what was the point of
all of this emphasis from me

1968
01:37:35,708 --> 01:37:39,541
on doing things the "right way," the
Python quick way by having this getter

1969
01:37:39,541 --> 01:37:40,291
and setter?

1970
01:37:40,291 --> 01:37:43,208
Well, unlike languages
like Java, that just

1971
01:37:43,208 --> 01:37:46,208
prevent you from doing
things like this, Python

1972
01:37:46,208 --> 01:37:49,041
itself allows you to specify that
certain instance variables can

1973
01:37:49,041 --> 01:37:52,666
be public and accessible to
anyone's code, or protected,

1974
01:37:52,666 --> 01:37:56,791
or private, which means that no one else
should be able to change these values.

1975
01:37:56,791 --> 01:38:00,125
In the world of Python,
it's just the honor system.

1976
01:38:00,125 --> 01:38:02,416
It's not baked into the
language itself that there's

1977
01:38:02,416 --> 01:38:05,500
a notion of visibility, public or
private or even somewhere in between

1978
01:38:05,500 --> 01:38:06,250
protected.

1979
01:38:06,250 --> 01:38:08,208
Instead, you're on the honor system.

1980
01:38:08,208 --> 01:38:11,666
And the convention
generally is, if an instance

1981
01:38:11,666 --> 01:38:15,750
variable starts with an
underscore, please don't touch it.

1982
01:38:15,750 --> 01:38:16,708
Just don't.

1983
01:38:16,708 --> 01:38:19,750
That's on you if you touch
that variable and break things.

1984
01:38:19,750 --> 01:38:22,000
The underscore is meant
to signify a convention

1985
01:38:22,000 --> 01:38:24,583
that this is meant to be
"private," but it really just

1986
01:38:24,583 --> 01:38:25,875
means, please don't touch this.

1987
01:38:25,875 --> 01:38:27,958
Sometimes, if there's two
underscores, which you can use,

1988
01:38:27,958 --> 01:38:30,541
too, that's an even greater
effort by programmers to say,

1989
01:38:30,541 --> 01:38:32,000
really don't touch this.

1990
01:38:32,000 --> 01:38:35,166
But technically speaking, there's
nothing stopping you or me

1991
01:38:35,166 --> 01:38:38,875
from circumventing all of these
mechanisms, these properties,

1992
01:38:38,875 --> 01:38:40,125
these getters and setters.

1993
01:38:40,125 --> 01:38:42,250
We're ultimately just
on the honor system

1994
01:38:42,250 --> 01:38:46,291
not to do so when we see instance
variables prefixed with one,

1995
01:38:46,291 --> 01:38:48,041
or perhaps even two underscores.

1996
01:38:48,041 --> 01:38:50,583
All right, so this is
a lot all at once--

1997
01:38:50,583 --> 01:38:52,875
this Introduction to
object-oriented programming.

1998
01:38:52,875 --> 01:38:56,166
But it might come as quite a
surprise that, even though we

1999
01:38:56,166 --> 01:39:00,458
might have identified OOP
by name in weeks past,

2000
01:39:00,458 --> 01:39:05,458
we've all been using classes and
objects for weeks now in this class.

2001
01:39:05,458 --> 01:39:08,791
In fact, if you think back on one of the
very first things we did in this class,

2002
01:39:08,791 --> 01:39:12,083
we used integers and just
got integers from the user.

2003
01:39:12,083 --> 01:39:13,791
But if you haven't already--

2004
01:39:13,791 --> 01:39:17,500
if you go and dig into the
documentation for integers,

2005
01:39:17,500 --> 01:39:19,916
which, again, lives
at this URL here, you

2006
01:39:19,916 --> 01:39:26,166
would actually find that int itself
is and has been for weeks a class.

2007
01:39:26,166 --> 01:39:30,541
And in fact, this is the signature
of the constructor call for an int,

2008
01:39:30,541 --> 01:39:35,125
whereby you pass in x, like a number,
quote, unquote, "50" or, quote,

2009
01:39:35,125 --> 01:39:38,458
unquote, something else-- you
pass in optionally the base--

2010
01:39:38,458 --> 01:39:41,750
10 for decimal, 2 for
binary or anything else.

2011
01:39:41,750 --> 01:39:46,208
And that int function will actually
return to you, all this time,

2012
01:39:46,208 --> 01:39:49,625
an object of type int.

2013
01:39:49,625 --> 01:39:52,083
That is to say int is a class.

2014
01:39:52,083 --> 01:39:55,250
It is a template, a blueprint
for creating integers in memory.

2015
01:39:55,250 --> 01:39:59,125
And any time you and I have converted
a string, for, instance to an int,

2016
01:39:59,125 --> 01:40:03,958
you and I have been creating an
object of type int that was calling,

2017
01:40:03,958 --> 01:40:07,875
apparently, the underscore underscore,
init, underscore underscore method,

2018
01:40:07,875 --> 01:40:09,666
that someone else--
the authors of Python--

2019
01:40:09,666 --> 01:40:12,500
wrote to give us back
that proper integer.

2020
01:40:12,500 --> 01:40:16,541
Besides that, if you can believe
it, strs, strings in Python

2021
01:40:16,541 --> 01:40:20,000
have been classes since the
first week of this class as well.

2022
01:40:20,000 --> 01:40:22,000
If you look up the
documentation for a str,

2023
01:40:22,000 --> 01:40:26,541
which lives at a similar URL there, you
will find that, when you instantiate--

2024
01:40:26,541 --> 01:40:28,083
that is, create a str--

2025
01:40:28,083 --> 01:40:32,166
it takes, optionally, a
parameter called object here,

2026
01:40:32,166 --> 01:40:34,666
the default value of which
is just, quote, unquote,

2027
01:40:34,666 --> 01:40:38,000
which allows you to create, in effect,
an empty string, a blank string,

2028
01:40:38,000 --> 01:40:38,500
if you will.

2029
01:40:38,500 --> 01:40:42,541
But any time you and I have created
strs or even used explicitly

2030
01:40:42,541 --> 01:40:47,333
the str function, you are getting
back an object of type str.

2031
01:40:47,333 --> 01:40:52,375
Any time you and I have forced a string
to lowercase per the documentation,

2032
01:40:52,375 --> 01:40:58,041
using syntax like this, you and I
have been taking an object of type str

2033
01:40:58,041 --> 01:41:03,125
and forcing it all to lowercase
by calling a method called lower,

2034
01:41:03,125 --> 01:41:07,958
a method that the authors of
Python built into the str class,

2035
01:41:07,958 --> 01:41:11,041
but it's been there from the get-go,
so this notion of methods is not

2036
01:41:11,041 --> 01:41:11,833
even new today.

2037
01:41:11,833 --> 01:41:13,750
You wouldn't have been
doing it for this long.

2038
01:41:13,750 --> 01:41:17,416
If you've ever called strip to remove
the leading and the trailing whitespace

2039
01:41:17,416 --> 01:41:22,166
from a string in Python, you are calling
another method that came with Python--

2040
01:41:22,166 --> 01:41:23,750
written by the authors of Python.

2041
01:41:23,750 --> 01:41:26,000
And even though we didn't
call it a class at the time,

2042
01:41:26,000 --> 01:41:29,708
a str, all this time, has been a class.

2043
01:41:29,708 --> 01:41:33,541
And instances of strings
are, themselves, objects.

2044
01:41:33,541 --> 01:41:36,291
And those objects come
therefore with these functions

2045
01:41:36,291 --> 01:41:39,458
built in-- a.k.a. methods that
allow us to do things like force

2046
01:41:39,458 --> 01:41:42,791
to lowercase and strip whitespace
from the beginning and end.

2047
01:41:42,791 --> 01:41:43,958
Let's do another.

2048
01:41:43,958 --> 01:41:49,541
list-- any time you've created a
list, either syntactically with square

2049
01:41:49,541 --> 01:41:53,541
brackets or literally with L-I-S-T,
open parentheses, closed parentheses,

2050
01:41:53,541 --> 01:41:56,375
which is also possible, you
have been using a class.

2051
01:41:56,375 --> 01:41:59,833
If you go to the documentation
for list, at this similar URL

2052
01:41:59,833 --> 01:42:04,083
here, or more specifically, the
tutorial on lists here in Python,

2053
01:42:04,083 --> 01:42:07,208
you will see that a
list is and has been,

2054
01:42:07,208 --> 01:42:10,958
since the early weeks of
this class, a class itself.

2055
01:42:10,958 --> 01:42:16,166
And that list class takes, as
part of its initialization,

2056
01:42:16,166 --> 01:42:21,000
an optional iterable, something that
can be iterated over-- like 1, 2, 3,

2057
01:42:21,000 --> 01:42:24,125
or some list of values,
and you can then get back

2058
01:42:24,125 --> 01:42:27,416
a list containing those
same iterable values.

2059
01:42:27,416 --> 01:42:30,666
If you've ever appended something
to a list in this class,

2060
01:42:30,666 --> 01:42:32,583
as I have myself in
the past, you've been

2061
01:42:32,583 --> 01:42:37,416
using a method called append that comes
with the list class that, per the x

2062
01:42:37,416 --> 01:42:40,541
here, takes an argument that
allows you to append something

2063
01:42:40,541 --> 01:42:42,833
to the current list, a.k.a.

2064
01:42:42,833 --> 01:42:45,125
Self in the context of that method.

2065
01:42:45,125 --> 01:42:46,416
We can do this all day long.

2066
01:42:46,416 --> 01:42:49,625
If you've used a dictionary
or a dict in Python--

2067
01:42:49,625 --> 01:42:53,125
I've actually, all this time,
been calling them dict objects,

2068
01:42:53,125 --> 01:42:54,500
and that's for a reason.

2069
01:42:54,500 --> 01:42:57,250
dict itself is a class
in Python, if you pull up

2070
01:42:57,250 --> 01:42:59,166
its official documentation here.

2071
01:42:59,166 --> 01:43:03,375
And you'll see that it is defined,
indeed, as itself a class.

2072
01:43:03,375 --> 01:43:05,333
And that class comes
with methods as well.

2073
01:43:05,333 --> 01:43:07,291
And so any time we've
manipulated dictionaries,

2074
01:43:07,291 --> 01:43:11,916
we've been underneath the hood,
using all of those same methods.

2075
01:43:11,916 --> 01:43:14,208
And in fact, we can see this
if we're really curious.

2076
01:43:14,208 --> 01:43:17,375
Let me go back over here to VS Code.

2077
01:43:17,375 --> 01:43:20,250
And let me go ahead and create a
new file that, very simply, does

2078
01:43:20,250 --> 01:43:22,500
something play around with data types.

2079
01:43:22,500 --> 01:43:24,833
And let me go ahead and create
a new file, for instance,

2080
01:43:24,833 --> 01:43:30,666
called, say, type.py, just so that I
can poke around inside of some values.

2081
01:43:30,666 --> 01:43:34,333
And in type.py, I'm just
going to go ahead and do this.

2082
01:43:34,333 --> 01:43:38,375
I'm going to print out whatever
the type is of, say, the number 50.

2083
01:43:38,375 --> 01:43:41,500
And This is a function you've not
necessarily seen me use already,

2084
01:43:41,500 --> 01:43:44,500
and it's not one you would
frequently use in your own code.

2085
01:43:44,500 --> 01:43:46,958
There are other ways to
detect, if you need to,

2086
01:43:46,958 --> 01:43:48,625
what the type is of a variable.

2087
01:43:48,625 --> 01:43:53,791
But in this case, type of 50 is just
going to tell me and then print out

2088
01:43:53,791 --> 01:43:55,833
what the data type is of that value.

2089
01:43:55,833 --> 01:43:58,416
Now, hopefully, all of us
could guess that 50 is indeed

2090
01:43:58,416 --> 01:43:59,458
going to be an integer--

2091
01:43:59,458 --> 01:44:01,666
that is, an int, but we
can see it in this way.

2092
01:44:01,666 --> 01:44:04,541
And this, too, is what's powerful
about knowing a bit of programming.

2093
01:44:04,541 --> 01:44:06,416
If you want to know the
answer to a question,

2094
01:44:06,416 --> 01:44:08,208
just try it out, like I am here.

2095
01:44:08,208 --> 01:44:11,125
So let me go ahead and run
Python of type.py, Enter.

2096
01:44:11,125 --> 01:44:12,208
And there it is.

2097
01:44:12,208 --> 01:44:17,458
When you print out the type of the
number 50, you'll see on the screen,

2098
01:44:17,458 --> 01:44:20,625
in this cryptic syntax, class 'int.'

2099
01:44:20,625 --> 01:44:23,541
This is not something that you
probably want to show to the user.

2100
01:44:23,541 --> 01:44:26,625
But if you yourself just want to
poke around and see what's going on

2101
01:44:26,625 --> 01:44:29,166
or maybe use that
information somehow, it's

2102
01:44:29,166 --> 01:44:32,833
certainly at your disposal to
use this type function for that.

2103
01:44:32,833 --> 01:44:34,583
Let's change it around a little bit.

2104
01:44:34,583 --> 01:44:38,375
Instead of passing as the
argument to type 50, as an int,

2105
01:44:38,375 --> 01:44:41,291
let's type something also
familiar, like "hello, world,"

2106
01:44:41,291 --> 01:44:43,166
in double or single quotes.

2107
01:44:43,166 --> 01:44:45,541
Let me go back to my terminal
window, clear the screen,

2108
01:44:45,541 --> 01:44:47,208
and run Python of type.py again.

2109
01:44:47,208 --> 01:44:49,333
And now, voila, there it is.

2110
01:44:49,333 --> 01:44:52,750
All this time, a str is also a class.

2111
01:44:52,750 --> 01:44:54,333
We can do this a few more times, For.

2112
01:44:54,333 --> 01:44:54,833
Instance.

2113
01:44:54,833 --> 01:44:58,875
Let's go ahead and change "hello,
world" to just an empty list--

2114
01:44:58,875 --> 01:45:01,291
open square bracket,
closed square bracket.

2115
01:45:01,291 --> 01:45:03,375
And this is starting to
look a little cryptic,

2116
01:45:03,375 --> 01:45:04,791
but, again, notice what I'm doing.

2117
01:45:04,791 --> 01:45:06,708
In square brackets is an empty list.

2118
01:45:06,708 --> 01:45:08,083
We've done that before.

2119
01:45:08,083 --> 01:45:11,583
That is the sole argument
to this new type function.

2120
01:45:11,583 --> 01:45:14,666
And that's just being
passed to the print function

2121
01:45:14,666 --> 01:45:18,458
so that the return value of
type is the argument to print.

2122
01:45:18,458 --> 01:45:22,541
So if I now run this code,
Python of type.py, there it is.

2123
01:45:22,541 --> 01:45:24,458
A list is a class, too.

2124
01:45:24,458 --> 01:45:28,000
You might recall that I said that
you can also create an empty list

2125
01:45:28,000 --> 01:45:31,541
by literally doing list ().

2126
01:45:31,541 --> 01:45:34,375
This is a bit of an
inconsistency, as we can now

2127
01:45:34,375 --> 01:45:39,958
identify that int and str and now list--
they're technically all lowercase.

2128
01:45:39,958 --> 01:45:44,708
And I went to great lengths of creating
my student class to have that capital

2129
01:45:44,708 --> 01:45:46,583
S. That's a convention.

2130
01:45:46,583 --> 01:45:51,250
Because int and stir and list
and others come with Python,

2131
01:45:51,250 --> 01:45:55,416
they decided to make their built-in data
types-- even though they're classes--

2132
01:45:55,416 --> 01:45:56,375
all lowercase.

2133
01:45:56,375 --> 01:45:59,750
But the convention, the recommendation
in the Python community when creating

2134
01:45:59,750 --> 01:46:03,541
your classes is to capitalize
the first letter, as I did,

2135
01:46:03,541 --> 01:46:10,541
in something like Student, capital S.
But list () is identical to really just

2136
01:46:10,541 --> 01:46:12,041
two empty square brackets.

2137
01:46:12,041 --> 01:46:16,416
If I clear my screen and run type.py
again, you see the exact same thing.

2138
01:46:16,416 --> 01:46:17,750
The class is called list.

2139
01:46:17,750 --> 01:46:19,041
Let's do one more.

2140
01:46:19,041 --> 01:46:23,041
Let me change the list to be not
square brackets but curly braces.

2141
01:46:23,041 --> 01:46:24,125
We've done this before.

2142
01:46:24,125 --> 01:46:27,916
Any time I've done two curly braces with
nothing in between, this, of course,

2143
01:46:27,916 --> 01:46:31,458
is an empty dictionary, or
a dict object in Python.

2144
01:46:31,458 --> 01:46:32,750
Well, we can see that now.

2145
01:46:32,750 --> 01:46:35,500
Let me clear my screen, run
Python of type.py, Enter,

2146
01:46:35,500 --> 01:46:37,666
and there it is-- class 'dict."

2147
01:46:37,666 --> 01:46:39,458
It's been there this whole time.

2148
01:46:39,458 --> 01:46:42,333
We just didn't call it
a class until today.

2149
01:46:42,333 --> 01:46:44,625
I can similarly do this one explicitly.

2150
01:46:44,625 --> 01:46:48,500
Instead of two curly braces, let's
write out dict with two parentheses.

2151
01:46:48,500 --> 01:46:51,541
Now we have a lot of parentheses
again, like with list.

2152
01:46:51,541 --> 01:46:55,250
But this is just making even more
clear that the type of a dict object

2153
01:46:55,250 --> 01:46:58,333
is indeed the class, dict, itself.

2154
01:46:58,333 --> 01:47:02,375
So this is to say that, as new as
a lot of today's idea and syntax,

2155
01:47:02,375 --> 01:47:05,708
might be you've actually been using
it, perhaps unbeknownst to you,

2156
01:47:05,708 --> 01:47:06,750
for weeks now.

2157
01:47:06,750 --> 01:47:09,416
We now just have
terminology to describe what

2158
01:47:09,416 --> 01:47:10,958
it is we've been doing all this time.

2159
01:47:10,958 --> 01:47:14,166
And you now have the
expressiveness, with some practice,

2160
01:47:14,166 --> 01:47:18,791
to create your own classes, inside of
which are your own instance variables,

2161
01:47:18,791 --> 01:47:23,708
perhaps wrapped with those properties
and your own instance methods.

2162
01:47:23,708 --> 01:47:27,125
But it turns out there's other
types of methods in the world.

2163
01:47:27,125 --> 01:47:29,375
Thus far, I've been
deliberate in calling

2164
01:47:29,375 --> 01:47:34,375
all of our variables instance variables
and all of our methods instance

2165
01:47:34,375 --> 01:47:35,125
methods.

2166
01:47:35,125 --> 01:47:40,333
It turns out there's other types
of variables and methods out there,

2167
01:47:40,333 --> 01:47:42,875
and one of those is
called class methods.

2168
01:47:42,875 --> 01:47:48,333
It turns out that sometimes it's
not really necessary or sensible

2169
01:47:48,333 --> 01:47:52,333
to associate a function
with objects of a class,

2170
01:47:52,333 --> 01:47:55,000
but rather with the class itself.

2171
01:47:55,000 --> 01:47:59,833
An instance, or an object of a class,
is a very specific incarnation thereof.

2172
01:47:59,833 --> 01:48:03,333
Again, on that neighborhood that has
a lot of identical looking buildings,

2173
01:48:03,333 --> 01:48:06,458
but they're all a little bit different
because of different paint and such,

2174
01:48:06,458 --> 01:48:09,666
sometimes you might have
functionality related

2175
01:48:09,666 --> 01:48:13,541
to each of those houses that
isn't distinct or unique for any

2176
01:48:13,541 --> 01:48:14,333
of the houses.

2177
01:48:14,333 --> 01:48:17,375
It's functionality that's
going to be exactly the same no

2178
01:48:17,375 --> 01:48:19,208
matter the house in question.

2179
01:48:19,208 --> 01:48:21,541
Same in the world of
object-oriented programming.

2180
01:48:21,541 --> 01:48:24,375
Sometimes you want some
functionality, some action

2181
01:48:24,375 --> 01:48:29,500
to be associated with the class itself,
no matter what the specific object's

2182
01:48:29,500 --> 01:48:32,333
own values or instance variables are.

2183
01:48:32,333 --> 01:48:36,125
And for that, we have a
keyword called @classmethod.

2184
01:48:36,125 --> 01:48:38,458
This is another
decorator-- really, another

2185
01:48:38,458 --> 01:48:43,416
function-- that you can use to
specify that this method is not,

2186
01:48:43,416 --> 01:48:46,208
by default, implicitly
an instance method that

2187
01:48:46,208 --> 01:48:48,791
has access to self, the object itself.

2188
01:48:48,791 --> 01:48:51,750
This is a class method that's
not going to have access to self,

2189
01:48:51,750 --> 01:48:54,166
but it does know what class it's inside.

2190
01:48:54,166 --> 01:48:55,625
So what do I mean by this?

2191
01:48:55,625 --> 01:48:57,416
Well, let me go back to VS Code here.

2192
01:48:57,416 --> 01:49:01,291
And let me propose that we create
a new file this time implementing

2193
01:49:01,291 --> 01:49:04,958
the notion of a-- the sorting hat,
from the world of Harry Potter as well,

2194
01:49:04,958 --> 01:49:06,041
to stay on theme.

2195
01:49:06,041 --> 01:49:08,666
I'm going to go ahead
and run code of hat.py.

2196
01:49:08,666 --> 01:49:12,041
And in hat.py, let's implement
the notion of the sorting hat.

2197
01:49:12,041 --> 01:49:14,583
If unfamiliar in the
books and in the films

2198
01:49:14,583 --> 01:49:17,333
there is literally a
pointy hat that, when

2199
01:49:17,333 --> 01:49:20,916
a student put it's on their head,
that sorting hat, so to speak,

2200
01:49:20,916 --> 01:49:23,708
decides what house the
student is in-- whether it's

2201
01:49:23,708 --> 01:49:25,416
Gryffindor or something else.

2202
01:49:25,416 --> 01:49:29,500
So let's implement, in code, this
notion of a sorting hat such that,

2203
01:49:29,500 --> 01:49:33,250
when we pass to the sorting hat the
name of a student, like, quote, unquote,

2204
01:49:33,250 --> 01:49:36,083
"Harry" this sorting
hat, implemented in code,

2205
01:49:36,083 --> 01:49:40,041
will tell us what house
that student should be in.

2206
01:49:40,041 --> 01:49:41,750
Well, let's go ahead and do this.

2207
01:49:41,750 --> 01:49:46,708
In hat.py, first, let's go ahead
and define a class called hat,

2208
01:49:46,708 --> 01:49:49,333
and then let's get back
to implementing it itself.

2209
01:49:49,333 --> 01:49:52,041
And I find this to be a helpful
technique, not just with teaching

2210
01:49:52,041 --> 01:49:53,375
but when writing code.

2211
01:49:53,375 --> 01:49:55,291
I know I want a hat class.

2212
01:49:55,291 --> 01:49:57,541
I don't necessarily know
what I want it to do yet,

2213
01:49:57,541 --> 01:50:00,083
so I'm going to create this
placeholder, dot, dot, dot,

2214
01:50:00,083 --> 01:50:01,791
so I'll come back to that.

2215
01:50:01,791 --> 01:50:05,000
Let's now try to use this
class as though it existed.

2216
01:50:05,000 --> 01:50:08,250
And from there, I perhaps
can realize exactly what

2217
01:50:08,250 --> 01:50:11,625
functionality that class needs
to have to support my use case.

2218
01:50:11,625 --> 01:50:14,708
Let me go ahead and create a
variable called hat in all lowercase

2219
01:50:14,708 --> 01:50:17,500
and instantiate a hat object.

2220
01:50:17,500 --> 01:50:21,041
So no matter what the hat
class ends up looking like,

2221
01:50:21,041 --> 01:50:24,125
this is the common
syntax for instantiating

2222
01:50:24,125 --> 01:50:25,916
an object of a certain class.

2223
01:50:25,916 --> 01:50:28,958
In the past, we saw
student, all lowercase,

2224
01:50:28,958 --> 01:50:32,708
equals capital Student, open
parenthesis, close parentheses,

2225
01:50:32,708 --> 01:50:35,375
and then eventually, we added
in things like name and house.

2226
01:50:35,375 --> 01:50:39,375
For now, let's assume that the hat
is much simpler than a student,

2227
01:50:39,375 --> 01:50:41,500
and it only has sorting capabilities.

2228
01:50:41,500 --> 01:50:44,791
So I'm not going to even pass
any arguments there, too.

2229
01:50:44,791 --> 01:50:50,708
Let me assume that the sorting hat has
one function-- one method inside of it

2230
01:50:50,708 --> 01:50:51,583
called, sort.

2231
01:50:51,583 --> 01:50:59,666
And so if I do hat.sort ("Harry"), let's
propose that that prints out what house

2232
01:50:59,666 --> 01:51:01,458
that student should be in.

2233
01:51:01,458 --> 01:51:02,541
So that's it.

2234
01:51:02,541 --> 01:51:04,541
I'm going to encapsulate--

2235
01:51:04,541 --> 01:51:06,916
that is tuck away
inside of a hat class--

2236
01:51:06,916 --> 01:51:11,250
all of this requisite functionality, and
I'm going to print out onto the screen

2237
01:51:11,250 --> 01:51:12,458
what hat--

2238
01:51:12,458 --> 01:51:15,208
what house Harry belongs in.

2239
01:51:15,208 --> 01:51:20,166
Now I think I need to get into the weeds
of actually initializing this class.

2240
01:51:20,166 --> 01:51:22,041
Well, let me go ahead and do this.

2241
01:51:22,041 --> 01:51:24,791
If I don't care to parameterize hat--

2242
01:51:24,791 --> 01:51:29,083
I just want to, for
instance sort values,

2243
01:51:29,083 --> 01:51:31,916
let's go ahead and define
this function, sort, first.

2244
01:51:31,916 --> 01:51:35,291
So let's define sort, as
taking a first argument, self,

2245
01:51:35,291 --> 01:51:39,125
which is always going to be the case
when defining an instance method as

2246
01:51:39,125 --> 01:51:39,750
before.

2247
01:51:39,750 --> 01:51:43,750
But the sort method clearly takes one
argument from the programmer, me--

2248
01:51:43,750 --> 01:51:45,583
namely the student's name.

2249
01:51:45,583 --> 01:51:47,708
And again, we've seen
this dichotomy before.

2250
01:51:47,708 --> 01:51:52,083
Even though I'm trying to pass in one
argument, when I define the method,

2251
01:51:52,083 --> 01:51:55,166
it's got to take that many
arguments, plus one more--

2252
01:51:55,166 --> 01:51:58,208
self which is always going to be
automatically passed in by Python

2253
01:51:58,208 --> 01:51:59,583
first.

2254
01:51:59,583 --> 01:52:01,291
What do I want to do?

2255
01:52:01,291 --> 01:52:03,291
Well, let's go ahead and
do something like this.

2256
01:52:06,166 --> 01:52:12,375
Print, this name-- how
about "is in," "some house."

2257
01:52:12,375 --> 01:52:14,291
I'm going to, again, use
some placeholder code

2258
01:52:14,291 --> 01:52:18,000
for myself because I'm not quite sure
how to finish implementing this sorting

2259
01:52:18,000 --> 01:52:18,583
hat.

2260
01:52:18,583 --> 01:52:21,708
But I think that's enough to just
test where my code is at now.

2261
01:52:21,708 --> 01:52:25,625
Let me go ahead and run Python
of hat.py and hit Enter.

2262
01:52:25,625 --> 01:52:28,250
And it looks like, indeed,
Harry is in some house.

2263
01:52:28,250 --> 01:52:31,958
We're not done yet because it's
clearly not doing anything interesting,

2264
01:52:31,958 --> 01:52:35,791
but it at least is running
correctly with no errors.

2265
01:52:35,791 --> 01:52:40,125
Well, let's go ahead
now and decide where--

2266
01:52:40,125 --> 01:52:43,541
what house Harry should actually be
in by introducing a bit of randomness

2267
01:52:43,541 --> 01:52:45,625
and choosing a house randomly.

2268
01:52:45,625 --> 01:52:47,500
While I can do this in a few ways, Let.

2269
01:52:47,500 --> 01:52:48,875
Me go ahead and do this.

2270
01:52:48,875 --> 01:52:51,541
I need to have a list
of houses somewhere.

2271
01:52:51,541 --> 01:52:52,833
So where can I put that?

2272
01:52:52,833 --> 01:52:54,708
I could solve this
problem in different ways.

2273
01:52:54,708 --> 01:52:56,000
Let me propose that I do this.

2274
01:52:56,000 --> 01:52:58,833
Let me define a method called
init, as I've done before,

2275
01:52:58,833 --> 01:53:01,250
that takes in self,
but no other arguments.

2276
01:53:01,250 --> 01:53:04,583
And whenever the sorting hat
is instantiated, let's do this.

2277
01:53:04,583 --> 01:53:09,958
Let's create a houses instance variable,
plural, that equals this list--

2278
01:53:09,958 --> 01:53:16,958
Gryffindor, Hufflepuff,
Ravenclaw, Slytherin,

2279
01:53:16,958 --> 01:53:19,416
so the exact same list
that we've used before,

2280
01:53:19,416 --> 01:53:23,333
and I'm storing it in an instance
variable inside of this class.

2281
01:53:23,333 --> 01:53:26,708
I'm not taking any arguments
beyond self to init,

2282
01:53:26,708 --> 01:53:30,625
but I just need this list of
values somewhere, for instance.

2283
01:53:30,625 --> 01:53:32,250
So what can I do here?

2284
01:53:32,250 --> 01:53:36,416
Well, let me go ahead and replace
some house with the actual house.

2285
01:53:36,416 --> 01:53:37,541
Well, what could I do here?

2286
01:53:37,541 --> 01:53:39,583
Well, I want to put a house there.

2287
01:53:39,583 --> 01:53:42,083
Well, let's go ahead and
create a variable called house.

2288
01:53:42,083 --> 01:53:46,291
And if you think back to our discussion
of libraries, in the random module,

2289
01:53:46,291 --> 01:53:51,791
there is a function called choice
that, if you pass in a list of choices,

2290
01:53:51,791 --> 01:53:56,333
like self.houses, that will pick
a random house out of those four.

2291
01:53:56,333 --> 01:53:58,750
And then on line 7, I can pass it in.

2292
01:53:58,750 --> 01:54:01,916
If I want to tighten this up, let me
just go ahead and highlight that code,

2293
01:54:01,916 --> 01:54:03,125
get rid of the variable.

2294
01:54:03,125 --> 01:54:04,541
It's technically unnecessary.

2295
01:54:04,541 --> 01:54:06,666
And because the line of
code is still pretty short,

2296
01:54:06,666 --> 01:54:09,458
I'm OK with just putting
it all in one line.

2297
01:54:09,458 --> 01:54:13,000
But I could certainly use the
variable like I did a moment ago.

2298
01:54:13,000 --> 01:54:14,041
So what have I done?

2299
01:54:14,041 --> 01:54:20,708
In my init function, I have defined
a initialization of the object

2300
01:54:20,708 --> 01:54:23,875
that stores in self.houses
the list of four houses.

2301
01:54:23,875 --> 01:54:26,583
And then, in sort, I'm
accessing that same list,

2302
01:54:26,583 --> 01:54:30,041
but I'm randomly choosing
the set of houses there.

2303
01:54:30,041 --> 01:54:31,791
Now, why have I done it in this way?

2304
01:54:31,791 --> 01:54:33,750
This, too, is general convention.

2305
01:54:33,750 --> 01:54:35,916
Any time you have a list
of things that-- who knows?

2306
01:54:35,916 --> 01:54:38,000
Maybe will change over time.

2307
01:54:38,000 --> 01:54:41,541
Places like Harvard have constructed
new houses over the years,

2308
01:54:41,541 --> 01:54:43,958
so you might have to change
the list of available houses.

2309
01:54:43,958 --> 01:54:47,083
It didn't happen in seven books
or eight films of Harry Potter.

2310
01:54:47,083 --> 01:54:49,208
But you could imagine
maybe Hogwarts eventually

2311
01:54:49,208 --> 01:54:54,291
has a fifth house, so there's generally
some value in putting list of constants

2312
01:54:54,291 --> 01:54:57,333
toward the top of your file, toward
the top of the class so it's just

2313
01:54:57,333 --> 01:54:59,875
obvious what the list of values is.

2314
01:54:59,875 --> 01:55:02,750
You don't want to necessarily
tuck it away in some function,

2315
01:55:02,750 --> 01:55:06,375
like sort, especially if you
might want to use that function--

2316
01:55:06,375 --> 01:55:10,166
sorry, especially if you want to use
that list in multiple functions, not

2317
01:55:10,166 --> 01:55:10,708
just sort.

2318
01:55:10,708 --> 01:55:12,583
But if I kept adding to
this class, you might

2319
01:55:12,583 --> 01:55:15,083
want to use that same list of
houses in multiple functions.

2320
01:55:15,083 --> 01:55:20,541
So let's keep it in the object
itself by storing it in self.houses.

2321
01:55:20,541 --> 01:55:23,625
All right, well, we're about to change
the course of history here perhaps.

2322
01:55:23,625 --> 01:55:27,666
Let me do Python of hat.py, and I
think we're about to assign Harry

2323
01:55:27,666 --> 01:55:30,833
to one of those four houses randomly.

2324
01:55:30,833 --> 01:55:33,041
Huh, NameError.

2325
01:55:33,041 --> 01:55:35,041
Name 'random' is not defined.

2326
01:55:35,041 --> 01:55:38,416
Well, wait a minute,
where did I go wrong here?

2327
01:55:38,416 --> 01:55:43,541
Thinking back to our class on libraries,
why did my code break and not tell me

2328
01:55:43,541 --> 01:55:45,625
where Harry is to be?

2329
01:55:45,625 --> 01:55:48,708
AUDIENCE: You did not
import the random library.

2330
01:55:48,708 --> 01:55:49,708
DAVID J. MALAN: Exactly.

2331
01:55:49,708 --> 01:55:52,541
If the random library or module
is something I want to use,

2332
01:55:52,541 --> 01:55:55,583
I need to tell Python that
at the top of my file.

2333
01:55:55,583 --> 01:55:58,958
So let me go up here
and do import random.

2334
01:55:58,958 --> 01:56:01,708
And then, below that, let me go
ahead and clear my terminal window

2335
01:56:01,708 --> 01:56:02,416
and try again.

2336
01:56:02,416 --> 01:56:08,041
Python of hat.py, crossing my fingers,
seeing where Harry is going to end up.

2337
01:56:08,041 --> 01:56:12,041
And, OK, Harry as of now is
officially in Hufflepuff,

2338
01:56:12,041 --> 01:56:14,500
despite everything you've read or seen.

2339
01:56:14,500 --> 01:56:15,875
Well, let's run this again.

2340
01:56:15,875 --> 01:56:19,833
Let me clear my window and run Python
of hat.py, and now he's in Ravenclaw.

2341
01:56:19,833 --> 01:56:21,541
That's consistent with using random.

2342
01:56:21,541 --> 01:56:23,375
Let's clear that and run it again.

2343
01:56:23,375 --> 01:56:25,458
He's still in Ravenclaw,
but that could happen,

2344
01:56:25,458 --> 01:56:26,833
even though there's four choices.

2345
01:56:26,833 --> 01:56:27,625
Let's do it again.

2346
01:56:27,625 --> 01:56:29,250
Hufflepuff-- back in Hufflepuff.

2347
01:56:29,250 --> 01:56:31,666
We can't seem to get the right answer.

2348
01:56:31,666 --> 01:56:34,375
Now he's in Gryffindor, albeit randomly.

2349
01:56:34,375 --> 01:56:37,208
So we seem to have a program that,
based on these limited tests,

2350
01:56:37,208 --> 01:56:41,166
seems to be assigning
Harry to a house randomly.

2351
01:56:41,166 --> 01:56:45,416
Now I'm somewhat lazily just
letting sort print out this value.

2352
01:56:45,416 --> 01:56:50,375
I could do something else, like return
a string, and then let me, on line 13,

2353
01:56:50,375 --> 01:56:51,916
do the printing for me.

2354
01:56:51,916 --> 01:56:57,000
But for now, I think we have an
example of a class called hat that,

2355
01:56:57,000 --> 01:57:00,125
nonetheless, applies some of our
lessons learned thus far today,

2356
01:57:00,125 --> 01:57:03,333
where I've created a class--
because a sorting hat is, frankly--

2357
01:57:03,333 --> 01:57:06,250
well, I was about to say
real world entity, but really

2358
01:57:06,250 --> 01:57:07,875
a fantasy world entity.

2359
01:57:07,875 --> 01:57:11,791
And indeed, that's a, perhaps, common
heuristic or mental model to have.

2360
01:57:11,791 --> 01:57:16,041
When should you use a class to
represent something in your code?

2361
01:57:16,041 --> 01:57:20,625
Very often, when you're trying to
represent some real world entity

2362
01:57:20,625 --> 01:57:25,791
or fantasy world entity, like a student,
which is something in the real world,

2363
01:57:25,791 --> 01:57:28,625
like a sorting hat,
which, OK, doesn't exist,

2364
01:57:28,625 --> 01:57:32,166
but hat's certainly do, so quite
reasonable to have a class for hat.

2365
01:57:32,166 --> 01:57:36,500
And that's not always the case that
classes represent real world entities.

2366
01:57:36,500 --> 01:57:42,291
But we've seen thus far that int
and stir and list and dict-- these

2367
01:57:42,291 --> 01:57:44,666
are all structures that you
might have in the real world.

2368
01:57:44,666 --> 01:57:47,416
We have integers and strings
of text and other things.

2369
01:57:47,416 --> 01:57:50,833
So it rather makes sense to represent
even those things, more technically,

2370
01:57:50,833 --> 01:57:52,625
using a class as well.

2371
01:57:52,625 --> 01:57:56,291
You could use just a dictionary
to represent a student or a hat.

2372
01:57:56,291 --> 01:58:00,875
But again, with classes come all
this and even more functionality.

2373
01:58:00,875 --> 01:58:06,791
But I honestly am not using classes
in, really, the "right way" here.

2374
01:58:06,791 --> 01:58:07,416
Why?

2375
01:58:07,416 --> 01:58:10,625
Well, in the world of Harry
Potter there really is only,

2376
01:58:10,625 --> 01:58:12,791
to my knowledge, one sorting hat.

2377
01:58:12,791 --> 01:58:17,000
And yet, here I have gone and
implemented a class called hat.

2378
01:58:17,000 --> 01:58:20,333
And again, a class is like
a blueprint, a template,

2379
01:58:20,333 --> 01:58:24,625
a mold that allows you to create
one or more objects thereof.

2380
01:58:24,625 --> 01:58:27,041
Now, most of my programs Thus
far have been pretty simple,

2381
01:58:27,041 --> 01:58:28,750
and I've just created one student.

2382
01:58:28,750 --> 01:58:31,208
But certainly, if I spent
more time and wrote more code,

2383
01:58:31,208 --> 01:58:33,583
you could imagine
writing one program that

2384
01:58:33,583 --> 01:58:36,208
has a list of students--
many more students

2385
01:58:36,208 --> 01:58:38,708
than just the one we keep demonstrating.

2386
01:58:38,708 --> 01:58:40,625
Yet it would be a little weird--

2387
01:58:40,625 --> 01:58:43,291
it's a little inconsistent
with the real or the fantasy

2388
01:58:43,291 --> 01:58:48,041
world of Harry Potter to instantiate
one, two, three or more sorting hats.

2389
01:58:48,041 --> 01:58:49,708
There really is just one.

2390
01:58:49,708 --> 01:58:51,875
Really one singleton,
if you will, which is

2391
01:58:51,875 --> 01:58:54,458
a term of art in a lot of
contexts of programming.

2392
01:58:54,458 --> 01:58:58,125
So let me propose that we actually
improve the design of the sorting hat

2393
01:58:58,125 --> 01:59:03,083
so that we don't have to instantiate
a sorting hat because right now this

2394
01:59:03,083 --> 01:59:08,791
is kind of allowing me to do something
like hat 1 = hat, hat 2 = hat, hat 3 =,

2395
01:59:08,791 --> 01:59:09,458
and so forth.

2396
01:59:09,458 --> 01:59:11,291
I don't really need that capability.

2397
01:59:11,291 --> 01:59:15,250
I really just need to represent
the sorting hat with a class,

2398
01:59:15,250 --> 01:59:17,125
but I don't really
need to instantiate it.

2399
01:59:17,125 --> 01:59:17,625
Why?

2400
01:59:17,625 --> 01:59:18,708
Because it already exists.

2401
01:59:18,708 --> 01:59:19,625
I need just one.

2402
01:59:19,625 --> 01:59:23,041
So it turns out, in
Python, that, up until now,

2403
01:59:23,041 --> 01:59:25,833
we've been using, as I keep
calling them, instance methods--

2404
01:59:25,833 --> 01:59:30,416
writing functions inside of classes that
are automatically passed a reference

2405
01:59:30,416 --> 01:59:32,375
to self, the current object.

2406
01:59:32,375 --> 01:59:34,375
But sometimes you just don't need that.

2407
01:59:34,375 --> 01:59:37,083
Sometimes it suffices to
just know what the class is

2408
01:59:37,083 --> 01:59:40,875
and assume that there might not
even be any objects of that class.

2409
01:59:40,875 --> 01:59:45,666
So in this sense, you can use a
class really as a container for data

2410
01:59:45,666 --> 01:59:50,291
and/or functionality that is just
somehow conceptually related--

2411
01:59:50,291 --> 01:59:52,791
things related to a sorting hat.

2412
01:59:52,791 --> 01:59:56,083
And there's this other decorator
or function called @classmethod

2413
01:59:56,083 --> 01:59:57,750
that allows us to do just this.

2414
01:59:57,750 --> 01:59:59,375
So let me go back to my code here.

2415
01:59:59,375 --> 02:00:05,041
And let me propose that, if I'm not
going to instantiate multiple houses,

2416
02:00:05,041 --> 02:00:07,916
I don't really need this init
method because that's really

2417
02:00:07,916 --> 02:00:12,250
meant to initialize specific objects
from that blueprint, that template,

2418
02:00:12,250 --> 02:00:13,083
that mold.

2419
02:00:13,083 --> 02:00:14,708
So let me get rid of this.

2420
02:00:14,708 --> 02:00:17,791
But if I get rid of this, I
no longer have access to self.

2421
02:00:17,791 --> 02:00:22,750
But that's OK because it turns out,
in addition to their existing class

2422
02:00:22,750 --> 02:00:26,416
methods, there are also what
we might call class variables.

2423
02:00:26,416 --> 02:00:30,791
And class variables exist
within the class itself.

2424
02:00:30,791 --> 02:00:33,833
And there's just one
copy of that variable

2425
02:00:33,833 --> 02:00:35,958
for all of the objects thereof.

2426
02:00:35,958 --> 02:00:40,291
They all share, if you will, the
same variable-- be it an int or str

2427
02:00:40,291 --> 02:00:41,750
or, in this case, a list.

2428
02:00:41,750 --> 02:00:49,041
So what I've done here is define, inside
of my hat class, in a class variable

2429
02:00:49,041 --> 02:00:50,208
called houses--

2430
02:00:50,208 --> 02:00:53,083
I don't say self because
self is no longer relevant.

2431
02:00:53,083 --> 02:00:54,791
Self refers to specific objects.

2432
02:00:54,791 --> 02:00:58,166
I want a variable inside
of this class, a.k.a.

2433
02:00:58,166 --> 02:01:00,791
A class variable that equals that list.

2434
02:01:00,791 --> 02:01:03,708
Because it's inside of
this hat, now, class,

2435
02:01:03,708 --> 02:01:07,208
I can use that list in
any of my functions.

2436
02:01:07,208 --> 02:01:08,958
I've only got one now, called sort.

2437
02:01:08,958 --> 02:01:11,791
But if I had more, it would be
accessible to all of those methods

2438
02:01:11,791 --> 02:01:12,666
as well.

2439
02:01:12,666 --> 02:01:15,791
And with sort, it also
doesn't really make sense

2440
02:01:15,791 --> 02:01:19,250
to sort within a specific
sorting hat because, again, I

2441
02:01:19,250 --> 02:01:20,500
only want there to be one.

2442
02:01:20,500 --> 02:01:25,875
So I can actually specify that this is
class method by saying @classmethod.

2443
02:01:25,875 --> 02:01:28,083
And I don't pass in self anymore.

2444
02:01:28,083 --> 02:01:33,250
I actually, by convention, pass in
a reference to the class itself.

2445
02:01:33,250 --> 02:01:35,250
It's typically written as cls.

2446
02:01:35,250 --> 02:01:35,791
Why?

2447
02:01:35,791 --> 02:01:40,916
Well, if you wrote C-L-A-S-S, that
would actually conflict with the keyword

2448
02:01:40,916 --> 02:01:42,791
"class" that we keep using up here.

2449
02:01:42,791 --> 02:01:47,125
So the world realized that, oops, we
can't reuse that same phrase here.

2450
02:01:47,125 --> 02:01:48,833
So let's just call this class.

2451
02:01:48,833 --> 02:01:51,541
This is useful in some
contexts including this one.

2452
02:01:51,541 --> 02:01:52,041
Why?

2453
02:01:52,041 --> 02:01:54,125
Well, notice what I can now do.

2454
02:01:54,125 --> 02:01:56,916
I can now change self to be just class.

2455
02:01:56,916 --> 02:01:57,541
Why?

2456
02:01:57,541 --> 02:02:02,708
Because houses now-- not an instance
variable, accessible via self.houses.

2457
02:02:02,708 --> 02:02:07,041
It is now a class variable,
accessible via class.houses,

2458
02:02:07,041 --> 02:02:10,375
or technically cls.houses in this case.

2459
02:02:10,375 --> 02:02:12,666
But now the final flourish is this.

2460
02:02:12,666 --> 02:02:19,208
Now, I don't have to instantiate any hat
objects as I used to on here, line 13.

2461
02:02:19,208 --> 02:02:22,833
I can just use functionality
that comes with this class.

2462
02:02:22,833 --> 02:02:24,791
So I'm going to delete
that line altogether.

2463
02:02:24,791 --> 02:02:32,416
I'm going to capitalize the hat on
this new line 13 and just say hat.sort,

2464
02:02:32,416 --> 02:02:33,333
("Harry").

2465
02:02:33,333 --> 02:02:34,750
So what have I done?

2466
02:02:34,750 --> 02:02:38,541
I've not bothered instantiating
an object of type, hat.

2467
02:02:38,541 --> 02:02:42,791
I am just accessing a class
method inside of the hat class

2468
02:02:42,791 --> 02:02:43,666
that-- you know what?

2469
02:02:43,666 --> 02:02:45,208
Is just going to work.

2470
02:02:45,208 --> 02:02:46,708
This is how class methods work.

2471
02:02:46,708 --> 02:02:51,041
You use the name of the class, capital
letter and all, dot method name,

2472
02:02:51,041 --> 02:02:53,041
passing in any arguments you want.

2473
02:02:53,041 --> 02:02:57,000
Python is going to automatically
pass in some variable via which

2474
02:02:57,000 --> 02:03:00,625
you can refer to that
class in that function

2475
02:03:00,625 --> 02:03:02,458
that you've implemented
inside of that class

2476
02:03:02,458 --> 02:03:04,125
so that I can do something like this.

2477
02:03:04,125 --> 02:03:07,833
It's not that I want a variable called
houses locally in this function,

2478
02:03:07,833 --> 02:03:12,541
I want the variable called houses that's
associated with this current class

2479
02:03:12,541 --> 02:03:17,166
so I can still access this same
list that I defined on line 6.

2480
02:03:17,166 --> 02:03:21,500
And now, if I go back down here to
my terminal and run Python of hat.py,

2481
02:03:21,500 --> 02:03:24,875
Enter, Harry is still
in Hufflepuff once more.

2482
02:03:24,875 --> 02:03:27,041
Harry is still in Hufflepuff once more.

2483
02:03:27,041 --> 02:03:31,250
Harry is back in Gryffindor,
at least randomly.

2484
02:03:31,250 --> 02:03:36,333
Questions, now, on these class
variables or these class methods,

2485
02:03:36,333 --> 02:03:41,416
which are in contrast with instance
variables and instance methods.

2486
02:03:41,416 --> 02:03:43,875
And the one thing, at least,
that's a little strange

2487
02:03:43,875 --> 02:03:47,666
here is that, even though there's
a decorator called @classmethod,

2488
02:03:47,666 --> 02:03:51,291
there is not one called @instancemethod.

2489
02:03:51,291 --> 02:03:55,666
A method is just automatically a
so-called "instant method" when

2490
02:03:55,666 --> 02:03:57,541
you define it without any decorator.

2491
02:03:57,541 --> 02:04:00,291
AUDIENCE: Can you have a
class inside another class?

2492
02:04:00,291 --> 02:04:01,291
DAVID J. MALAN: You can.

2493
02:04:01,291 --> 02:04:03,666
You can define one
class inside of another.

2494
02:04:03,666 --> 02:04:06,041
Generally speaking, this
isn't done, but there

2495
02:04:06,041 --> 02:04:08,416
are cases where it can
be helpful, especially

2496
02:04:08,416 --> 02:04:10,625
for larger, more sophisticated programs.

2497
02:04:10,625 --> 02:04:13,541
So yes, it is possible.

2498
02:04:13,541 --> 02:04:14,750
Other questions.

2499
02:04:14,750 --> 02:04:17,958
AUDIENCE: The question
was about the self.houses.

2500
02:04:17,958 --> 02:04:25,083
When we remove it and we pass
data, variable is created itself,

2501
02:04:25,083 --> 02:04:27,458
s why we remove the self?

2502
02:04:27,458 --> 02:04:29,625
DAVID J. MALAN: So in
the previous examples--

2503
02:04:29,625 --> 02:04:32,625
both of the hat demonstration
and also all of the student

2504
02:04:32,625 --> 02:04:36,708
demonstrations-- we
were creating a student

2505
02:04:36,708 --> 02:04:40,625
object by calling Student, capital S,
open parenthesis, close parenthesis,

2506
02:04:40,625 --> 02:04:43,125
with, eventually, name
and a house passed in.

2507
02:04:43,125 --> 02:04:46,833
And then we were using the
double underscore init method

2508
02:04:46,833 --> 02:04:52,708
to initialize the self.name and
the self.house instance variables

2509
02:04:52,708 --> 02:04:55,333
therein to those respective values.

2510
02:04:55,333 --> 02:04:57,750
In this latest version
of the sorting hat,

2511
02:04:57,750 --> 02:05:02,166
I haven't bothered with self anywhere,
only because, conceptually, I

2512
02:05:02,166 --> 02:05:05,708
don't need or want there to
be multiple hats in the world.

2513
02:05:05,708 --> 02:05:11,041
I'm just using the class as a container
to bundle up this list of houses,

2514
02:05:11,041 --> 02:05:12,500
this sorting functionality.

2515
02:05:12,500 --> 02:05:14,875
Maybe eventually all add
more functionality to it.

2516
02:05:14,875 --> 02:05:15,875
But that's it.

2517
02:05:15,875 --> 02:05:18,833
And so sometimes you can use
object-oriented programming

2518
02:05:18,833 --> 02:05:22,458
in this somewhat different way when
you want there to be functionality

2519
02:05:22,458 --> 02:05:25,333
but it's not specific
to any one specific hat.

2520
02:05:25,333 --> 02:05:29,416
It's specific to the sorting hat itself.

2521
02:05:29,416 --> 02:05:33,958
How about one other question now, on
these class variables or methods-- just

2522
02:05:33,958 --> 02:05:37,000
another way of using object-oriented
programming but to solve

2523
02:05:37,000 --> 02:05:38,541
a somewhat different problem?

2524
02:05:38,541 --> 02:05:40,916
AUDIENCE: Well, what's the
difference between the class

2525
02:05:40,916 --> 02:05:44,833
hat and a function of hat?

2526
02:05:44,833 --> 02:05:46,166
DAVID J. MALAN: A good question.

2527
02:05:46,166 --> 02:05:48,500
So why are we using a
class at all and not just

2528
02:05:48,500 --> 02:05:51,916
having a file called hat.py
with a variable called

2529
02:05:51,916 --> 02:05:54,500
houses and a function called sort?

2530
02:05:54,500 --> 02:05:56,166
Why are we adding this complexity?

2531
02:05:56,166 --> 02:05:58,958
In this particular case, we
don't necessarily need to.

2532
02:05:58,958 --> 02:06:01,166
I could absolutely go in here.

2533
02:06:01,166 --> 02:06:02,833
I could get rid of the class.

2534
02:06:02,833 --> 02:06:05,625
I could undo this indentation.

2535
02:06:05,625 --> 02:06:07,666
I could get rid of this decorator.

2536
02:06:07,666 --> 02:06:09,541
And I could get rid of hat dot.

2537
02:06:09,541 --> 02:06:12,291
And I could just do
this and additionally

2538
02:06:12,291 --> 02:06:14,208
let's say, let's get rid of class here.

2539
02:06:14,208 --> 02:06:15,833
Let's get rid of class here.

2540
02:06:15,833 --> 02:06:19,833
And now run Python of hat.py,
Enter, and it still works.

2541
02:06:19,833 --> 02:06:22,125
Put Harry in the wrong house,
but that's what we have--

2542
02:06:22,125 --> 02:06:23,208
what happens randomly.

2543
02:06:23,208 --> 02:06:24,500
That's fine, too.

2544
02:06:24,500 --> 02:06:27,750
What we're introducing today, by
way of object-oriented programming,

2545
02:06:27,750 --> 02:06:30,208
is just a different way
of modeling the world.

2546
02:06:30,208 --> 02:06:32,916
It's not really compelling
with an example like this,

2547
02:06:32,916 --> 02:06:35,125
frankly, that's relatively simple.

2548
02:06:35,125 --> 02:06:36,125
It's not very complex.

2549
02:06:36,125 --> 02:06:37,416
There's not much functionality.

2550
02:06:37,416 --> 02:06:40,875
Honestly, the version that we just typed
up-- these 10 lines-- this is fine.

2551
02:06:40,875 --> 02:06:42,208
This solves this problem.

2552
02:06:42,208 --> 02:06:45,708
But as our code gets longer, as we
start collaborating with other people,

2553
02:06:45,708 --> 02:06:48,666
as the problems we're trying to solve
with code get more sophisticated,

2554
02:06:48,666 --> 02:06:52,125
you're going to find that
your code gets messy quickly.

2555
02:06:52,125 --> 02:06:55,458
And you're going to find that you have a
huge number of functions, for instance,

2556
02:06:55,458 --> 02:06:56,500
in one file.

2557
02:06:56,500 --> 02:06:59,958
And some of them are related to each
other, but some of them are not.

2558
02:06:59,958 --> 02:07:02,625
Well, at that point, wouldn't
it be nice to just organize them

2559
02:07:02,625 --> 02:07:03,500
a little differently?

2560
02:07:03,500 --> 02:07:06,500
And in the world of Harry Potter,
let's have a class for student;

2561
02:07:06,500 --> 02:07:09,916
let's have a class for Professor;
let's have a class for the sorting hat;

2562
02:07:09,916 --> 02:07:11,708
let's have a class for something else.

2563
02:07:11,708 --> 02:07:14,625
And so once your world gets
much more complicated than some

2564
02:07:14,625 --> 02:07:17,791
of the demonstrations we do here
in class when we want to focus

2565
02:07:17,791 --> 02:07:21,500
on individual ideas, object-oriented
programming is just a way

2566
02:07:21,500 --> 02:07:24,083
of encapsulating related data--

2567
02:07:24,083 --> 02:07:27,291
that is, variables-- related
functionality-- that is, methods--

2568
02:07:27,291 --> 02:07:29,583
inside of things that have names.

2569
02:07:29,583 --> 02:07:31,625
These things are called classes.

2570
02:07:31,625 --> 02:07:33,750
So it's just another
way to solve problems.

2571
02:07:33,750 --> 02:07:36,125
And when we focused on libraries
a couple of weeks back,

2572
02:07:36,125 --> 02:07:38,791
that, too, was another
solution to the same problem.

2573
02:07:38,791 --> 02:07:42,291
You could define your own modules
or packages, put some of your data

2574
02:07:42,291 --> 02:07:44,708
and/or functionality in
there, and that's fine, too.

2575
02:07:44,708 --> 02:07:48,000
And sometimes which one
you should use overlaps.

2576
02:07:48,000 --> 02:07:51,333
If you're familiar with Venn
diagrams, the overlapping region

2577
02:07:51,333 --> 02:07:54,791
might mean that you could use a class;
you could use a module or a package;

2578
02:07:54,791 --> 02:07:57,500
you could just use a single local file.

2579
02:07:57,500 --> 02:07:59,916
Over time, you'll develop
an instinct and maybe even

2580
02:07:59,916 --> 02:08:04,291
a personal preference
for which tool to use.

2581
02:08:04,291 --> 02:08:08,416
All right, let me propose, now, that we
apply this same idea of a class method

2582
02:08:08,416 --> 02:08:10,583
to clean up one other thing as well.

2583
02:08:10,583 --> 02:08:16,041
Let me close that hat.py and reopen
student.py as we left it earlier,

2584
02:08:16,041 --> 02:08:19,500
and let me go ahead and
simplify it just a little bit.

2585
02:08:19,500 --> 02:08:22,750
I'm going to go ahead and
get rid of the properties,

2586
02:08:22,750 --> 02:08:24,666
not because there's
anything, wrong with them,

2587
02:08:24,666 --> 02:08:27,416
but just because I want us to
focus on some of the key ideas

2588
02:08:27,416 --> 02:08:29,333
when we began with this program.

2589
02:08:29,333 --> 02:08:31,750
So I'm going to go ahead
and keep main as well.

2590
02:08:31,750 --> 02:08:35,583
I'm not going to adversarially try
to change Henry's address there.

2591
02:08:35,583 --> 02:08:38,666
I'm going to instead go ahead,
though, and just print the student.

2592
02:08:38,666 --> 02:08:41,750
But this is the thing I
want to focus on here.

2593
02:08:41,750 --> 02:08:46,541
This, in our previous student
examples, was a missed opportunity

2594
02:08:46,541 --> 02:08:48,125
to clean up my code.

2595
02:08:48,125 --> 02:08:49,708
Well, what do I mean by that?

2596
02:08:49,708 --> 02:08:51,750
Well, up here at the
top of this file-- even

2597
02:08:51,750 --> 02:08:53,958
though I've simplified it, but
getting rid of the properties

2598
02:08:53,958 --> 02:08:55,708
and all of that error
checking-- because I

2599
02:08:55,708 --> 02:08:58,708
want to focus on the essence of this
class now-- just the student's name

2600
02:08:58,708 --> 02:09:00,875
and the house and the printing thereof.

2601
02:09:00,875 --> 02:09:05,000
This is, by nature of classes
in object-oriented programming,

2602
02:09:05,000 --> 02:09:09,666
theoretically, all of my
student-specific functionality.

2603
02:09:09,666 --> 02:09:14,083
That is to say, if I have functionality
and data related to a student, you,

2604
02:09:14,083 --> 02:09:16,583
the programmer, my
colleague, would assume

2605
02:09:16,583 --> 02:09:18,875
that it's all bundled
up, encapsulated, so

2606
02:09:18,875 --> 02:09:20,791
to speak, inside of the student class.

2607
02:09:20,791 --> 02:09:24,208
And yet, if you scroll
down further, what is this?

2608
02:09:24,208 --> 02:09:27,458
There's a function called get_student
that just exists elsewhere

2609
02:09:27,458 --> 02:09:31,166
in this file that prompts the user for
a name, prompts the user for a house,

2610
02:09:31,166 --> 02:09:34,083
creates the student
object, and then returns.

2611
02:09:34,083 --> 02:09:35,500
That's not wrong.

2612
02:09:35,500 --> 02:09:36,208
It works.

2613
02:09:36,208 --> 02:09:39,041
And we saw many, many
times it kept working.

2614
02:09:39,041 --> 02:09:42,208
But this is a little
weird because, if this

2615
02:09:42,208 --> 02:09:45,208
is a function that
helps you get a student,

2616
02:09:45,208 --> 02:09:48,916
helps you get the name of a student
and the house of a student, why isn't

2617
02:09:48,916 --> 02:09:51,125
that functionality in the class itself?

2618
02:09:51,125 --> 02:09:54,291
After all, as my code gets more and
more complicated and does more things,

2619
02:09:54,291 --> 02:09:56,125
I'm going to be looking
at the student class

2620
02:09:56,125 --> 02:09:57,750
for all student-related functionality.

2621
02:09:57,750 --> 02:10:00,625
I'm not going to be scrolling down,
expecting that, oh, maybe there's

2622
02:10:00,625 --> 02:10:04,708
some other student functionality
just randomly later in this file.

2623
02:10:04,708 --> 02:10:05,958
So it's not wrong.

2624
02:10:05,958 --> 02:10:09,625
But this is, again, evidence
of maybe bad design--

2625
02:10:09,625 --> 02:10:11,541
not so much with this small program.

2626
02:10:11,541 --> 02:10:14,458
But this is an example,
again, of code smell.

2627
02:10:14,458 --> 02:10:16,000
Something smells a little off here.

2628
02:10:16,000 --> 02:10:17,791
This is probably going
to get us in trouble

2629
02:10:17,791 --> 02:10:20,791
by separating related functionality.

2630
02:10:20,791 --> 02:10:24,541
So again it's a design principle,
not a correctness concern.

2631
02:10:24,541 --> 02:10:27,958
But class methods allow
us to address this, too.

2632
02:10:27,958 --> 02:10:29,791
Let me go ahead and do this.

2633
02:10:29,791 --> 02:10:32,666
I'm going to delete get_student
all together, leaving

2634
02:10:32,666 --> 02:10:35,458
only main as my other function here.

2635
02:10:35,458 --> 02:10:38,541
And inside of my student
class, I'm going to do this.

2636
02:10:38,541 --> 02:10:42,375
I'm going to define a function,
even more simply called, get.

2637
02:10:42,375 --> 02:10:45,291
And by nature of how
class methods work, it's

2638
02:10:45,291 --> 02:10:47,625
going to take in the
name of the class itself

2639
02:10:47,625 --> 02:10:49,833
or a reference thereto as an argument.

2640
02:10:49,833 --> 02:10:53,083
And I'm going to move the functionality
from get_student into the student

2641
02:10:53,083 --> 02:10:53,583
class.

2642
02:10:53,583 --> 02:10:58,750
And I'm going to do this-- name equals
input, quote, unquote, name, house

2643
02:10:58,750 --> 02:11:01,708
equals input, quote, unquote, house.

2644
02:11:01,708 --> 02:11:04,291
And then what this
function is going to do

2645
02:11:04,291 --> 02:11:11,333
is return a new student object by
calling class, which, again, is just

2646
02:11:11,333 --> 02:11:14,250
an automatically passed-in
reference to the class

2647
02:11:14,250 --> 02:11:17,666
itself, passing in name and house.

2648
02:11:17,666 --> 02:11:22,916
And I will admit this syntax seems a
little strange that now I'm calling cls

2649
02:11:22,916 --> 02:11:24,375
and I'm passing in these arguments.

2650
02:11:24,375 --> 02:11:26,125
But let me do one final fix here.

2651
02:11:26,125 --> 02:11:28,041
Let me go to the top of
this function and more

2652
02:11:28,041 --> 02:11:31,125
explicitly say this is a class method.

2653
02:11:31,125 --> 02:11:34,541
This solves a potential chicken
and the egg problem, so to speak,

2654
02:11:34,541 --> 02:11:37,291
whereby one needs to come
before the other, potentially.

2655
02:11:37,291 --> 02:11:39,250
So what am I doing here?

2656
02:11:39,250 --> 02:11:43,916
Inside of my student class, I
now have a function called get.

2657
02:11:43,916 --> 02:11:47,333
It is, I shall claim, a class
method what does that mean.

2658
02:11:47,333 --> 02:11:53,000
It just means I can call this method
without instantiating a student

2659
02:11:53,000 --> 02:11:54,125
object first.

2660
02:11:54,125 --> 02:11:57,333
Therein lies the potential
chicken and the egg problem.

2661
02:11:57,333 --> 02:12:00,375
And if unfamiliar, that's an expression,
meaning, well, and did the world

2662
02:12:00,375 --> 02:12:03,291
have chickens first that laid
eggs, or was there an egg

2663
02:12:03,291 --> 02:12:06,958
that then yielded the chickens,
but how did the egg get there?

2664
02:12:06,958 --> 02:12:08,791
It's this weird, circular problem.

2665
02:12:08,791 --> 02:12:10,208
And that's what we're facing here.

2666
02:12:10,208 --> 02:12:16,375
It would be weird if you had to create
a student object in order to call get,

2667
02:12:16,375 --> 02:12:19,791
in order to get another student object.

2668
02:12:19,791 --> 02:12:20,875
That sounds messy.

2669
02:12:20,875 --> 02:12:24,833
Let's just get a student
via a class method

2670
02:12:24,833 --> 02:12:29,125
that, by definition, does not require
you to create a student object first.

2671
02:12:29,125 --> 02:12:33,166
Just like the hat, in its final
form, we use the hat class

2672
02:12:33,166 --> 02:12:35,833
to just say Hat, capital H, dot sort.

2673
02:12:35,833 --> 02:12:37,458
We didn't need to create a hat first.

2674
02:12:37,458 --> 02:12:39,708
We just used the class itself.

2675
02:12:39,708 --> 02:12:41,791
So what am I going to do here now?

2676
02:12:41,791 --> 02:12:43,041
Let me go down to main.

2677
02:12:43,041 --> 02:12:46,791
And instead of saying get_student,
notice what I can now do.

2678
02:12:46,791 --> 02:12:51,625
Student.get, and everything
else can stay the same.

2679
02:12:51,625 --> 02:12:55,416
All I've done now is I've
migrated all of my logic

2680
02:12:55,416 --> 02:12:58,541
from get_student, which was
this own standalone function,

2681
02:12:58,541 --> 02:13:01,291
but clearly related to students by name.

2682
02:13:01,291 --> 02:13:05,458
I've moved the same
code, really, to inside

2683
02:13:05,458 --> 02:13:09,458
of the student class in a more
simply named function called get.

2684
02:13:09,458 --> 02:13:11,541
But I could still call
it get_student if I want.

2685
02:13:11,541 --> 02:13:14,791
It just seems a little redundant to
call it get_student in a student class,

2686
02:13:14,791 --> 02:13:16,291
so I'm simplifying.

2687
02:13:16,291 --> 02:13:20,208
So I have a method called get,
but I'm calling it a class method

2688
02:13:20,208 --> 02:13:22,333
to avoid that chicken
and the egg problem.

2689
02:13:22,333 --> 02:13:27,958
I want to be able to call a get without
having a student object in my universe

2690
02:13:27,958 --> 02:13:28,791
already.

2691
02:13:28,791 --> 02:13:32,041
And the syntax for that is @classmethod.

2692
02:13:32,041 --> 02:13:35,333
The convention is to give this
method at least one argument,

2693
02:13:35,333 --> 02:13:38,291
by convention called cls for
class, which is just going

2694
02:13:38,291 --> 02:13:40,125
to be a reference to the class itself.

2695
02:13:40,125 --> 02:13:43,500
Lines 11 and 12 are identical
to what they've always been.

2696
02:13:43,500 --> 02:13:46,666
And get_student-- the only
new syntax here is this,

2697
02:13:46,666 --> 02:13:50,500
but this, again, is one of the features
of object-oriented programming.

2698
02:13:50,500 --> 02:13:57,791
You can now instantiate a student object
by just using cls that's passed in.

2699
02:13:57,791 --> 02:14:00,583
I technically could
use Student, capital S,

2700
02:14:00,583 --> 02:14:03,333
but it turns out I'm doing what's
more conventional because this

2701
02:14:03,333 --> 02:14:07,458
will both solve and avoid problems down
the line with more complicated code.

2702
02:14:07,458 --> 02:14:11,916
This line here, on line 13, just means
create an object of the current class.

2703
02:14:11,916 --> 02:14:12,708
What class is that?

2704
02:14:12,708 --> 02:14:13,791
Well, whatever cls is.

2705
02:14:13,791 --> 02:14:17,458
Well, that, by definition of how it
all works, is going to be student.

2706
02:14:17,458 --> 02:14:22,250
And I want you to initialize it,
as always, with name and house.

2707
02:14:22,250 --> 02:14:25,666
So now, scrolling down, my code is this.

2708
02:14:25,666 --> 02:14:27,875
And this is just nice to read.

2709
02:14:27,875 --> 02:14:31,791
You perhaps have to acquire a taste for
this-- and I sound a little odd saying,

2710
02:14:31,791 --> 02:14:32,750
this is nice to read.

2711
02:14:32,750 --> 02:14:36,125
But indeed, student.get just
tells me what's going on.

2712
02:14:36,125 --> 02:14:37,375
I'm going to get a student.

2713
02:14:37,375 --> 02:14:40,958
I don't need a separate function written
by me called get_student in the file

2714
02:14:40,958 --> 02:14:41,750
itself.

2715
02:14:41,750 --> 02:14:44,875
The get functionality
is built into the class.

2716
02:14:44,875 --> 02:14:47,416
All my student-related
code now is together.

2717
02:14:47,416 --> 02:14:51,041
So let me go down to my terminal window
and run Python of student.py, Enter.

2718
02:14:51,041 --> 02:14:52,083
Let's type in Harry.

2719
02:14:52,083 --> 02:14:53,416
Let's type in Gryffindor.

2720
02:14:53,416 --> 02:14:54,958
And we're back to where we began.

2721
02:14:54,958 --> 02:15:00,541
But, but, but everything related to
students, now, is in this here class.

2722
02:15:00,541 --> 02:15:04,500
The only other thing in the file
is main and this conditional

2723
02:15:04,500 --> 02:15:08,458
that we always use to avoid accidentally
executing main when we're making

2724
02:15:08,458 --> 02:15:10,833
a module or a package or the like.

2725
02:15:10,833 --> 02:15:13,541
So again, a solution to a problem--

2726
02:15:13,541 --> 02:15:16,875
not a big one in the case of a
relatively small program, but one

2727
02:15:16,875 --> 02:15:19,041
that you will eventually
encounter as your programs

2728
02:15:19,041 --> 02:15:24,083
get longer and longer, with more
and more entities to represent.

2729
02:15:24,083 --> 02:15:29,000
Questions now on this
use of a class method.

2730
02:15:29,000 --> 02:15:32,291
MICHAEL: Does the class have to be
defined before the main function,

2731
02:15:32,291 --> 02:15:34,458
in terms of the order of the program?

2732
02:15:34,458 --> 02:15:36,083
DAVID J. MALAN: A really good question.

2733
02:15:36,083 --> 02:15:37,291
So when in doubt, let's try this.

2734
02:15:37,291 --> 02:15:38,666
So let's try to change the order.

2735
02:15:38,666 --> 02:15:41,208
Let's move main to the top,
which I've often encouraged.

2736
02:15:41,208 --> 02:15:44,208
So let's go ahead and,
above the class, do this.

2737
02:15:44,208 --> 02:15:47,000
And notice now that,
technically, line two

2738
02:15:47,000 --> 02:15:51,458
is mentioning student, which does
not exist until line 6 and below.

2739
02:15:51,458 --> 02:15:54,666
Let me go ahead and clear my terminal
and run Python of student.py.

2740
02:15:54,666 --> 02:15:55,875
So far, so good.

2741
02:15:55,875 --> 02:15:58,750
Harry-- Gryffindor, OK.

2742
02:15:58,750 --> 02:16:00,458
Indeed, Harry's from Gryffindor.

2743
02:16:00,458 --> 02:16:03,541
The reason, Michael, it
does not matter in this case

2744
02:16:03,541 --> 02:16:06,791
is because we're not actually
calling main until the very end.

2745
02:16:06,791 --> 02:16:10,375
And just as in the past, that means that
Python has a chance to read everything,

2746
02:16:10,375 --> 02:16:11,625
top to bottom, left to right.

2747
02:16:11,625 --> 02:16:13,083
So everything exists.

2748
02:16:13,083 --> 02:16:17,458
I would say, generally classes are
defined at the top of the file.

2749
02:16:17,458 --> 02:16:21,916
However, it would be even maybe
cleaner to move the Classes definition

2750
02:16:21,916 --> 02:16:25,083
to its own file and then
import it, so essentially

2751
02:16:25,083 --> 02:16:28,750
to make reusable code by putting
it into your own module or package

2752
02:16:28,750 --> 02:16:31,083
so that not just this
program but many others

2753
02:16:31,083 --> 02:16:33,541
can use that definition
of student as well.

2754
02:16:33,541 --> 02:16:37,750
Other questions now on classes,
class methods, or the like.

2755
02:16:37,750 --> 02:16:44,833
AUDIENCE: I wanted to ask, is there
a way to declare all the possible--

2756
02:16:44,833 --> 02:16:47,583
all the possible
attributes of the class?

2757
02:16:47,583 --> 02:16:51,000
Because it looks so inconsistent.

2758
02:16:51,000 --> 02:16:52,750
DAVID J. MALAN: Well,
so my takeaway there

2759
02:16:52,750 --> 02:16:55,208
is this is Python's approach
to these principles.

2760
02:16:55,208 --> 02:16:57,791
Different languages, like Java,
just take a different approach

2761
02:16:57,791 --> 02:16:59,666
but have very similar features.

2762
02:16:59,666 --> 02:17:01,500
The syntax just tends to vary.

2763
02:17:01,500 --> 02:17:05,208
And this is how the Python community
chose to implement this idea.

2764
02:17:05,208 --> 02:17:08,750
The right mental model, ultimately,
is that these instance variables,

2765
02:17:08,750 --> 02:17:14,958
instant methods belong to or
operate on specific objects--

2766
02:17:14,958 --> 02:17:17,750
a specific student, a specific hat.

2767
02:17:17,750 --> 02:17:22,500
Class variables and class methods
operate on the entire class

2768
02:17:22,500 --> 02:17:26,125
itself or, in turn, all
objects of that class, which

2769
02:17:26,125 --> 02:17:30,000
we've not seen a demonstration of,
but it's a higher level concept.

2770
02:17:30,000 --> 02:17:32,583
So it turns out, besides
these class methods,

2771
02:17:32,583 --> 02:17:35,625
which are distinct from those
instance methods, which, to be fair,

2772
02:17:35,625 --> 02:17:39,375
do not have their own decorator-- they
just are, by default, instance method,

2773
02:17:39,375 --> 02:17:42,458
there's yet other types of Methods
You can have in classes in Python.

2774
02:17:42,458 --> 02:17:44,875
They tend to be called static
methods, and they, too,

2775
02:17:44,875 --> 02:17:48,041
come with another decorator
called @static method, which

2776
02:17:48,041 --> 02:17:49,666
is a rabbit hole we won't go down.

2777
02:17:49,666 --> 02:17:52,125
But realize that there is
yet other functionality

2778
02:17:52,125 --> 02:17:54,750
that you can leverage within
object-oriented programming.

2779
02:17:54,750 --> 02:17:59,041
But what we thought we'd do is focus
really on some final core features

2780
02:17:59,041 --> 02:18:02,166
that you see not just in Python
but other languages as well.

2781
02:18:02,166 --> 02:18:05,750
And perhaps one of the most compelling
features of object-oriented programming

2782
02:18:05,750 --> 02:18:09,375
that we haven't yet used explicitly--
though it turns out we've seen

2783
02:18:09,375 --> 02:18:11,458
implicitly over the past weeks--

2784
02:18:11,458 --> 02:18:13,625
is this notion of inheritance.

2785
02:18:13,625 --> 02:18:16,250
It turns out, via
object-oriented programming,

2786
02:18:16,250 --> 02:18:19,666
there's actually an opportunity
to design your classes

2787
02:18:19,666 --> 02:18:25,125
in a hierarchical fashion, whereby
you can have one class inherit from

2788
02:18:25,125 --> 02:18:30,833
or borrow attributes-- that is,
methods or variables from another class

2789
02:18:30,833 --> 02:18:33,291
if they all have those in common.

2790
02:18:33,291 --> 02:18:35,083
So what do I mean by this here?

2791
02:18:35,083 --> 02:18:39,708
Well, let me propose that we
implement, over in VS Code here,

2792
02:18:39,708 --> 02:18:42,250
a brand new file called wizard.py.

2793
02:18:42,250 --> 02:18:45,583
Let me go ahead and
run code of wizard.py.

2794
02:18:45,583 --> 02:18:50,333
And then let's start as before,
defining a class called student.

2795
02:18:50,333 --> 02:18:54,416
And let's go ahead and first define
the underscore underscore, init method,

2796
02:18:54,416 --> 02:18:57,291
which of course, is minimally going
to take an argument traditionally

2797
02:18:57,291 --> 02:18:58,000
called self.

2798
02:18:58,000 --> 02:19:01,375
And in this case, let's also have it
take as before a name and a house.

2799
02:19:01,375 --> 02:19:03,875
And then in this init
method, let's go ahead

2800
02:19:03,875 --> 02:19:08,208
and assign the instance
variables-- self.name = name,

2801
02:19:08,208 --> 02:19:11,208
and self.house = house.

2802
02:19:11,208 --> 02:19:13,375
Let's assume that there's
some other functionality

2803
02:19:13,375 --> 02:19:15,083
in this class as well-- dot, dot, dot.

2804
02:19:15,083 --> 02:19:18,416
But let's move on now to implementing
the notion of a professor

2805
02:19:18,416 --> 02:19:20,208
in the wizarding world as well.

2806
02:19:20,208 --> 02:19:24,625
So for this class,
let's call it Professor.

2807
02:19:24,625 --> 02:19:26,958
And a professor, let's
say, is also going

2808
02:19:26,958 --> 02:19:29,416
to have its own initialization method.

2809
02:19:29,416 --> 02:19:30,708
So __ init.

2810
02:19:30,708 --> 02:19:32,000
It's going to take self--

2811
02:19:32,000 --> 02:19:33,791
always as the first argument.

2812
02:19:33,791 --> 02:19:35,500
A professor also has a name.

2813
02:19:35,500 --> 02:19:37,166
So we'll pass that in second, too.

2814
02:19:37,166 --> 02:19:39,958
And even though some
professors are heads of houses,

2815
02:19:39,958 --> 02:19:42,041
let's assume that a professor
is really identified

2816
02:19:42,041 --> 02:19:45,500
by their name and their subject
area-- the class that they teach.

2817
02:19:45,500 --> 02:19:48,041
So we'll call this
third argument, subject.

2818
02:19:48,041 --> 02:19:51,791
Now, as before, let's go ahead
and assign self.name = name,

2819
02:19:51,791 --> 02:19:56,083
and let's assign
self.subject = subject here.

2820
02:19:56,083 --> 02:19:59,541
And as before, let's assume that there's
some more functionality associated

2821
02:19:59,541 --> 02:20:01,083
with professors as well.

2822
02:20:01,083 --> 02:20:05,625
Well, what do you notice already
here in my definitions of students

2823
02:20:05,625 --> 02:20:07,333
and professors?

2824
02:20:07,333 --> 02:20:11,750
Typically, we're a bit reluctant to
allow for any redundancy in our code.

2825
02:20:11,750 --> 02:20:16,041
And here, I feel like my init method
is taking a name for students;

2826
02:20:16,041 --> 02:20:18,625
my init method is also taking
a name for a professor;

2827
02:20:18,625 --> 02:20:22,458
and I have these identical lines
of code, like self.name = name.

2828
02:20:22,458 --> 02:20:25,208
And this is only going to get
exacerbated if I now go and add

2829
02:20:25,208 --> 02:20:26,083
some error checking.

2830
02:20:26,083 --> 02:20:29,916
So for instance, how
about if not name, we

2831
02:20:29,916 --> 02:20:32,083
should probably be in the
habit of raising something

2832
02:20:32,083 --> 02:20:36,208
like a value error in an explanatory
message, like "Missing name."

2833
02:20:36,208 --> 02:20:37,166
And you know what?

2834
02:20:37,166 --> 02:20:39,750
If a professor is missing
their name, I should probably

2835
02:20:39,750 --> 02:20:41,291
copy, paste that code down here.

2836
02:20:41,291 --> 02:20:43,666
And that's where red
flags should be going off,

2837
02:20:43,666 --> 02:20:45,916
whereby, as soon as you
start copy pasting code,

2838
02:20:45,916 --> 02:20:50,208
there's probably a better way so that
we can write the code once and perhaps

2839
02:20:50,208 --> 02:20:51,500
reuse it in some way.

2840
02:20:51,500 --> 02:20:54,916
And here, too, object-oriented
programming offers a solution.

2841
02:20:54,916 --> 02:20:58,041
It turns out that object-oriented
programming in Python

2842
02:20:58,041 --> 02:21:03,458
also supports inheritance, whereby
you can define multiple classes that

2843
02:21:03,458 --> 02:21:05,125
somehow relate to one another.

2844
02:21:05,125 --> 02:21:07,833
They don't need to exist
in parallel in this way.

2845
02:21:07,833 --> 02:21:10,375
There could actually be
some hierarchy between them.

2846
02:21:10,375 --> 02:21:12,333
So for instance, in
the wizarding world, we

2847
02:21:12,333 --> 02:21:15,583
could argue that both a student and a
professor are, at the end of the day,

2848
02:21:15,583 --> 02:21:16,291
Wizards.

2849
02:21:16,291 --> 02:21:19,666
So maybe what we should really
define is a third class,

2850
02:21:19,666 --> 02:21:21,958
for instance, called
wizard, that has any

2851
02:21:21,958 --> 02:21:25,916
of the common attributes for
students and professors alike.

2852
02:21:25,916 --> 02:21:27,791
And for now, we've kept
it relatively simple.

2853
02:21:27,791 --> 02:21:30,666
The only thing they have in
common is a name and a name,

2854
02:21:30,666 --> 02:21:32,458
in student and professor, respectively.

2855
02:21:32,458 --> 02:21:35,416
So why don't we minimally
factor that out first?

2856
02:21:35,416 --> 02:21:37,083
All right, so let me go ahead here.

2857
02:21:37,083 --> 02:21:39,708
And just to keep things organized,
at the top of my file, let's

2858
02:21:39,708 --> 02:21:41,833
define a third class called Wizard.

2859
02:21:41,833 --> 02:21:45,208
And a wizard will have its
own initialization method.

2860
02:21:45,208 --> 02:21:49,541
So def __init__(self), as always.

2861
02:21:49,541 --> 02:21:52,333
And a wizard, let's say
for now, is only going

2862
02:21:52,333 --> 02:21:55,625
to be initialized with
their name in this way.

2863
02:21:55,625 --> 02:21:58,791
And now, I'm going to go ahead and
do some of that error checking.

2864
02:21:58,791 --> 02:22:02,708
So if not name will raise a
value error in the wizard class.

2865
02:22:02,708 --> 02:22:06,041
Otherwise, we'll go ahead
and do self name equals name,

2866
02:22:06,041 --> 02:22:09,666
and, heck, dot, dot, dot, maybe
some other functionality as well.

2867
02:22:09,666 --> 02:22:13,041
But not a subject, which is specific
to professors, and not a house,

2868
02:22:13,041 --> 02:22:15,166
which I've claimed is
specific to students.

2869
02:22:15,166 --> 02:22:18,375
Now, I think we can
begin to maybe remove

2870
02:22:18,375 --> 02:22:20,833
some of the redundancies
in our other classes here.

2871
02:22:20,833 --> 02:22:24,416
So for instance, down
with student, why don't I

2872
02:22:24,416 --> 02:22:28,750
go ahead and remove this error
checking here and remove this error--

2873
02:22:28,750 --> 02:22:32,166
this assignment of self.name
= name because I'm already

2874
02:22:32,166 --> 02:22:33,291
doing that in Wizard.

2875
02:22:33,291 --> 02:22:35,958
And similarly, down here, in
Professor, why don't I do the same?

2876
02:22:35,958 --> 02:22:37,583
Let's get rid of the error checking.

2877
02:22:37,583 --> 02:22:41,083
Let's get rid of self.name = name
because, again, I'm doing that already

2878
02:22:41,083 --> 02:22:43,041
up there for Wizard as well.

2879
02:22:43,041 --> 02:22:45,916
But at the moment, even though
they're all in the same file,

2880
02:22:45,916 --> 02:22:50,666
I haven't told Python that a student is
a wizard and a professor is a wizard.

2881
02:22:50,666 --> 02:22:53,000
So I really need to
link these two together.

2882
02:22:53,000 --> 02:22:57,500
And the way you can prescribe
inheritance, whereby one class should

2883
02:22:57,500 --> 02:23:00,041
inherit from another,
or conversely, one class

2884
02:23:00,041 --> 02:23:03,541
should descend from
another-- we can do this.

2885
02:23:03,541 --> 02:23:05,125
I can say class Student.

2886
02:23:05,125 --> 02:23:08,416
But before the colon, I can
go in and say in parentheses,

2887
02:23:08,416 --> 02:23:13,916
a student inherits from, or is a
subclass of wizard, which, conversely,

2888
02:23:13,916 --> 02:23:16,666
is the superclass of the student class.

2889
02:23:16,666 --> 02:23:19,583
So this just means that, when
I define a student class,

2890
02:23:19,583 --> 02:23:23,958
go ahead and inherit all of the
characteristics of a wizard as well.

2891
02:23:23,958 --> 02:23:26,875
And I'm going to do the
same thing for Professor.

2892
02:23:26,875 --> 02:23:30,166
So (Wizard) after the
class name Professor,

2893
02:23:30,166 --> 02:23:33,833
and that's going to give me access
to some of that same functionality.

2894
02:23:33,833 --> 02:23:37,458
But because my student
class and my professor class

2895
02:23:37,458 --> 02:23:39,416
still have their same
init methods, those

2896
02:23:39,416 --> 02:23:41,291
are the methods that
are going to get called.

2897
02:23:41,291 --> 02:23:44,916
Whenever I create a student in code
or I create a professor in code,

2898
02:23:44,916 --> 02:23:47,625
I need to somehow
explicitly say that I also

2899
02:23:47,625 --> 02:23:51,916
want to use the functionality in
the Wizard class's init method.

2900
02:23:51,916 --> 02:23:54,916
And the way to do this
in Python is as follows.

2901
02:23:54,916 --> 02:23:56,958
Let me go into my init
method for Student,

2902
02:23:56,958 --> 02:23:59,958
and let me call super,
with no arguments, which

2903
02:23:59,958 --> 02:24:03,333
is a reference to the
superclass of this class.

2904
02:24:03,333 --> 02:24:05,916
So if this class is Student,
the superclass-- that is,

2905
02:24:05,916 --> 02:24:07,791
the parent class-- is Wizard.

2906
02:24:07,791 --> 02:24:13,875
So super() will have the effect
of accessing the superclass.

2907
02:24:13,875 --> 02:24:17,750
And then I'm going to go ahead and
explicitly call its init method,

2908
02:24:17,750 --> 02:24:21,416
and I'm going to pass to
the Wizard's init method

2909
02:24:21,416 --> 02:24:24,958
the name that the student's
init method was passed.

2910
02:24:24,958 --> 02:24:28,000
And I'm going to go ahead and
do the same down here in Wizard.

2911
02:24:28,000 --> 02:24:29,666
This is one line of copy, paste.

2912
02:24:29,666 --> 02:24:32,375
But I think I'm OK with
it here because it's still

2913
02:24:32,375 --> 02:24:34,291
allowing me to do all
of the name assignment

2914
02:24:34,291 --> 02:24:37,000
and the error checking up
in the Wizard class instead.

2915
02:24:37,000 --> 02:24:42,250
I think we're OK now by just
calling super.init for both student

2916
02:24:42,250 --> 02:24:43,416
and Professor alike.

2917
02:24:43,416 --> 02:24:47,208
Now, admittedly, this syntax is
definitely out there-- the fact

2918
02:24:47,208 --> 02:24:49,541
that we're calling super
in parentheses and dots

2919
02:24:49,541 --> 02:24:52,458
and underscore underscore on the
left and the right of init here,

2920
02:24:52,458 --> 02:24:54,875
but it's just a combination
of these two ideas.

2921
02:24:54,875 --> 02:25:00,916
super() is a way of programmatically
accessing a current class's parent

2922
02:25:00,916 --> 02:25:05,291
class, or superclass, and __init, of
course, is just referring to, now,

2923
02:25:05,291 --> 02:25:08,041
that class's own initialization method.

2924
02:25:08,041 --> 02:25:09,958
Now, per the dot, dot,
dot-- so there could be

2925
02:25:09,958 --> 02:25:11,500
a lot more going on in these classes.

2926
02:25:11,500 --> 02:25:15,208
But what's nice now is
that Wizard as a class

2927
02:25:15,208 --> 02:25:18,291
is taking care of all of the
assignment of a wizard's name,

2928
02:25:18,291 --> 02:25:20,458
whether that wizard is a
student or a professor.

2929
02:25:20,458 --> 02:25:22,416
And it's even doing some
error checking to make

2930
02:25:22,416 --> 02:25:25,125
sure the name was actually passed in.

2931
02:25:25,125 --> 02:25:29,166
Meanwhile, student is inheriting
all of that functionality

2932
02:25:29,166 --> 02:25:32,333
and using it by calling the
superclass's own init method.

2933
02:25:32,333 --> 02:25:35,041
But it's additionally taking
the house, that's presumably

2934
02:25:35,041 --> 02:25:37,375
passed into the student
constructor function,

2935
02:25:37,375 --> 02:25:40,833
and assigning it to its own
instance variable-- self.house,

2936
02:25:40,833 --> 02:25:44,458
and similarly, professor,
or restoring in self.subject

2937
02:25:44,458 --> 02:25:47,875
the subject that was passed
into that one as well.

2938
02:25:47,875 --> 02:25:49,916
Now, how might we use these classes?

2939
02:25:49,916 --> 02:25:53,500
Well, we'll continue to wave our hands
with a little bit of detail here.

2940
02:25:53,500 --> 02:25:56,750
But at the bottom of this file, or
any other file that imports this one,

2941
02:25:56,750 --> 02:25:58,833
I could now write code like this.

2942
02:25:58,833 --> 02:26:01,208
I could create a student
variable and assign

2943
02:26:01,208 --> 02:26:03,458
it the return value of the
student constructor call.

2944
02:26:03,458 --> 02:26:07,625
and maybe that student is named
Harry and that student's house,

2945
02:26:07,625 --> 02:26:10,041
for instance, might be Gryffindor.

2946
02:26:10,041 --> 02:26:14,750
And meanwhile, I might do something like
this. professor = Professor over here.

2947
02:26:14,750 --> 02:26:18,541
And notice, the lowercase S on
the left, capital S on the right.

2948
02:26:18,541 --> 02:26:21,875
Same for professor on the left--
lowercase and uppercase on the right

2949
02:26:21,875 --> 02:26:22,750
respectively.

2950
02:26:22,750 --> 02:26:25,625
Professor, quote, unquote,
"Severus," and how

2951
02:26:25,625 --> 02:26:30,500
about Defense Against the
Dark Arts will be his subject?

2952
02:26:30,500 --> 02:26:32,791
And meanwhile, if we
want, more generically,

2953
02:26:32,791 --> 02:26:37,291
just a wizard, who, at the moment
is neither student nor professor

2954
02:26:37,291 --> 02:26:39,375
teaching classes actively,
we could even do that.

2955
02:26:39,375 --> 02:26:43,458
We could do wizard = Wizard in
capital W on the right-hand side

2956
02:26:43,458 --> 02:26:45,708
of the equal sign, because
it's the name of the class.

2957
02:26:45,708 --> 02:26:47,166
And someone like Albus--

2958
02:26:47,166 --> 02:26:49,958
passing in only Albus's name--

2959
02:26:49,958 --> 02:26:55,708
not a house, not a subject, because, in
this case, he's known only as a wizard.

2960
02:26:55,708 --> 02:26:58,750
Meanwhile, with each of these
calls, this line of code

2961
02:26:58,750 --> 02:27:01,833
here will ensure that the init method
for the wizard class is called.

2962
02:27:01,833 --> 02:27:05,583
This line of code here will ensure
that the init method of the student

2963
02:27:05,583 --> 02:27:09,250
class and, in turn, the init method
of the superclass wizard is called.

2964
02:27:09,250 --> 02:27:11,541
And then lastly, on
this final line of code,

2965
02:27:11,541 --> 02:27:15,625
will this syntax ensure that the
init method of the professor class

2966
02:27:15,625 --> 02:27:20,375
is called, which, in turn, calls the
init method of the superclass as well.

2967
02:27:20,375 --> 02:27:24,083
Any questions now on
this idea of inheritance,

2968
02:27:24,083 --> 02:27:29,125
which is a key feature of a lot of
object-oriented programming languages?

2969
02:27:33,458 --> 02:27:36,708
MICHAEL: From what I've seen so far, a
lot of times, there's a lot of nesting.

2970
02:27:36,708 --> 02:27:38,375
If you do super, does it go one up?

2971
02:27:38,375 --> 02:27:44,375
Is there any situation where it's nested
in another class as well, above Wizard,

2972
02:27:44,375 --> 02:27:44,875
let's say?

2973
02:27:44,875 --> 02:27:46,500
DAVID J. MALAN: A really good question.

2974
02:27:46,500 --> 02:27:48,375
If you were to have a
super superclass-- so

2975
02:27:48,375 --> 02:27:52,833
your hierarchy is even taller
than the two levels of hierarchy

2976
02:27:52,833 --> 02:27:56,625
that we currently have, absolutely.

2977
02:27:56,625 --> 02:27:59,250
What's nice about inheritance,
as the name implies, is,

2978
02:27:59,250 --> 02:28:02,583
just as you might have inherited
certain traits as a human

2979
02:28:02,583 --> 02:28:06,000
from your grandfather and
grandmother or your great-grandfather

2980
02:28:06,000 --> 02:28:08,333
or great-grandmother,
some of those properties

2981
02:28:08,333 --> 02:28:13,083
can actually trickle down to you
in the context of code as well.

2982
02:28:13,083 --> 02:28:17,291
So when you descend from another class--

2983
02:28:17,291 --> 02:28:21,541
that is, when you subclass a
superclass or a super superclass,

2984
02:28:21,541 --> 02:28:23,958
you actually do inherit
all of the functionality,

2985
02:28:23,958 --> 02:28:26,625
not just from one level above
you but from two or three,

2986
02:28:26,625 --> 02:28:29,583
so you can indeed access some
of that functionality as well.

2987
02:28:29,583 --> 02:28:32,666
And you can even override it if
you want some of these classes

2988
02:28:32,666 --> 02:28:35,750
to behave a little bit
differently than others.

2989
02:28:35,750 --> 02:28:38,125
Other questions on inheritance.

2990
02:28:38,125 --> 02:28:39,875
AUDIENCE: So it's
similar to the last one,

2991
02:28:39,875 --> 02:28:43,125
but can you have two
parents on the same level?

2992
02:28:43,125 --> 02:28:44,750
DAVID J. MALAN: A really good question.

2993
02:28:44,750 --> 02:28:49,875
So there are ways to implement
descendants from multiple parents.

2994
02:28:49,875 --> 02:28:53,125
And there's different ways to do this,
not just in Python but other languages.

2995
02:28:53,125 --> 02:28:57,916
We've kept things simple here, though,
by having a single inheritance path.

2996
02:28:57,916 --> 02:28:58,666
A good question.

2997
02:28:58,666 --> 02:29:01,291
How about one more
question on inheritance?

2998
02:29:01,291 --> 02:29:07,208
AUDIENCE: Can we have multiple
arguments in super.__init?

2999
02:29:07,208 --> 02:29:11,000
DAVID J. MALAN: Yes, but in this case,
I'm only passing a name on line 18,

3000
02:29:11,000 --> 02:29:13,666
and I'm only passing in name on line 10.

3001
02:29:13,666 --> 02:29:14,166
Why?

3002
02:29:14,166 --> 02:29:18,208
Because, on line 2, when I define
the init method for the Wizard class,

3003
02:29:18,208 --> 02:29:20,375
I only expect a single argument.

3004
02:29:20,375 --> 02:29:23,583
But I could absolutely have
other common functionality.

3005
02:29:23,583 --> 02:29:24,750
I could add in a patronus.

3006
02:29:24,750 --> 02:29:27,125
If both students and
professors have patronuses

3007
02:29:27,125 --> 02:29:30,958
that can come out of their wands,
I could have two arguments instead.

3008
02:29:30,958 --> 02:29:33,708
We've been using this feature
of object-oriented programming

3009
02:29:33,708 --> 02:29:37,000
now for quite some time
in the form of exceptions.

3010
02:29:37,000 --> 02:29:40,625
Indeed, if you look at the official
documentation for exceptions in Python,

3011
02:29:40,625 --> 02:29:43,208
you'll see that there's not even
the ones we've seen in class,

3012
02:29:43,208 --> 02:29:44,541
like value error and others.

3013
02:29:44,541 --> 02:29:48,666
There's any number of others as
well, but they are all, themselves,

3014
02:29:48,666 --> 02:29:50,125
hierarchical in nature.

3015
02:29:50,125 --> 02:29:54,416
This is just a subset of the available
exceptions that come built into Python.

3016
02:29:54,416 --> 02:29:58,125
And you can actually, as a programmer,
create your own exceptions as well.

3017
02:29:58,125 --> 02:30:01,916
But as this chart here
captures hierarchically,

3018
02:30:01,916 --> 02:30:06,125
all exceptions we've seen
thus far actually descend from

3019
02:30:06,125 --> 02:30:09,041
or inherit from superclasses already.

3020
02:30:09,041 --> 02:30:10,833
So for instance, at
the bottom of this list

3021
02:30:10,833 --> 02:30:13,250
here is ValueError, which
we've seen quite a bit.

3022
02:30:13,250 --> 02:30:17,583
And if you follow the line straight up
on this ascii rendition of this chart,

3023
02:30:17,583 --> 02:30:22,083
you'll see that ValueError has a parent,
class, or superclass, called exception.

3024
02:30:22,083 --> 02:30:25,958
And the exception class, meanwhile, has
a parent class called base exception.

3025
02:30:25,958 --> 02:30:28,125
Why did the authors of Python do this?

3026
02:30:28,125 --> 02:30:32,958
Well, it turns out that, whether you
have a value error or a key error

3027
02:30:32,958 --> 02:30:35,416
or an assertion error
or any number of others,

3028
02:30:35,416 --> 02:30:40,250
there's a lot of functionality common
to all of those types of errors

3029
02:30:40,250 --> 02:30:42,458
that you want--

3030
02:30:42,458 --> 02:30:44,958
that you want a programmer
to be able to use.

3031
02:30:44,958 --> 02:30:48,375
And so it turns out that the authors
of Python decided, you know what?

3032
02:30:48,375 --> 02:30:51,791
Let's not have a dozen
or more different classes

3033
02:30:51,791 --> 02:30:55,166
that all just have copy,
pasted similar functionality.

3034
02:30:55,166 --> 02:30:57,250
Let's create this
hierarchy so that, even

3035
02:30:57,250 --> 02:31:00,875
though the exceptions toward the
bottom of this list are very precise,

3036
02:31:00,875 --> 02:31:02,291
they at least inherit--

3037
02:31:02,291 --> 02:31:05,583
that is, borrow some very
common functionality up above.

3038
02:31:05,583 --> 02:31:09,541
So it turns out that, when you use the
Try and the Accept keyword in Python,

3039
02:31:09,541 --> 02:31:13,291
generally speaking, we've tried
to catch very specific exceptions,

3040
02:31:13,291 --> 02:31:14,291
like ValueError.

3041
02:31:14,291 --> 02:31:17,458
But technically, you could
capture the parents or even

3042
02:31:17,458 --> 02:31:20,375
the grandparent exception
for a given exception,

3043
02:31:20,375 --> 02:31:23,500
especially if you're not necessarily
sure which one is going to get raised.

3044
02:31:23,500 --> 02:31:27,041
Or, better yet, there could be
many exceptions that get raised,

3045
02:31:27,041 --> 02:31:28,958
but you want to handle
them all the same,

3046
02:31:28,958 --> 02:31:31,000
and you don't want to
necessarily enumerate them

3047
02:31:31,000 --> 02:31:33,041
in parentheses, separated by commas.

3048
02:31:33,041 --> 02:31:36,625
You want to say you want to handle
all exceptions of a certain superclass

3049
02:31:36,625 --> 02:31:38,416
in much the same way.

3050
02:31:38,416 --> 02:31:40,833
So this has been latent this
whole time, any time we've

3051
02:31:40,833 --> 02:31:45,166
seen or used or caught or, now, raised
exceptions, and built into Python

3052
02:31:45,166 --> 02:31:46,041
is this hierarchy.

3053
02:31:46,041 --> 02:31:47,916
And if you were to invent
your own exception,

3054
02:31:47,916 --> 02:31:50,250
generally, you wouldn't
want to start from scratch.

3055
02:31:50,250 --> 02:31:54,041
You would want to descend from-- that
is, subclass, one of these existing

3056
02:31:54,041 --> 02:31:58,958
exceptions and add your own twist on
it, your own functionality as well.

3057
02:31:58,958 --> 02:32:02,208
Well, there's one final feature
of object oriented programming

3058
02:32:02,208 --> 02:32:04,750
that we'd like to share
with you today, and then it

3059
02:32:04,750 --> 02:32:08,291
will perhaps be quite the eye opener
as to what you can really do now

3060
02:32:08,291 --> 02:32:10,208
that you have classes at your disposal.

3061
02:32:10,208 --> 02:32:12,791
And this, too, surprise,
has been a feature

3062
02:32:12,791 --> 02:32:15,458
you and I have been taking
for granted for weeks now.

3063
02:32:15,458 --> 02:32:18,250
This has just worked, but
it's been implemented in a way

3064
02:32:18,250 --> 02:32:20,208
that you can now leverage yourself.

3065
02:32:20,208 --> 02:32:23,166
It turns out that Python, and
some other languages, too,

3066
02:32:23,166 --> 02:32:27,041
support this notion of
operator overloading, whereby

3067
02:32:27,041 --> 02:32:32,250
you can take very common symbols, like
plus or minus or other such syntax

3068
02:32:32,250 --> 02:32:37,416
on the keyboard, and you can implement
your own interpretation thereof.

3069
02:32:37,416 --> 02:32:40,791
Plus does not have to equal addition.

3070
02:32:40,791 --> 02:32:43,291
And minus does not have
to equal subtraction.

3071
02:32:43,291 --> 02:32:45,708
And in fact, you and I have
already seen another context

3072
02:32:45,708 --> 02:32:48,541
in which plus means something else.

3073
02:32:48,541 --> 02:32:52,750
Plus has not always, in
Python, meant addition, per se.

3074
02:32:52,750 --> 02:32:56,458
What else has Python used plus for?

3075
02:32:56,458 --> 02:32:57,458
AUDIENCE: Concatenation?

3076
02:32:57,458 --> 02:32:58,875
DAVID J. MALAN: For concatenation.

3077
02:32:58,875 --> 02:33:02,875
For joining two strings, for adding
to a list can you use plus as well.

3078
02:33:02,875 --> 02:33:07,666
So plus has actually been, funny enough,
overloaded by the authors of Python

3079
02:33:07,666 --> 02:33:08,541
for us.

3080
02:33:08,541 --> 02:33:12,000
And so we can use the same symbol
in much the same way as addition

3081
02:33:12,000 --> 02:33:15,250
but with different data types to
solve slightly different problems.

3082
02:33:15,250 --> 02:33:18,250
Well, let me propose that we
go back over to VS Code here,

3083
02:33:18,250 --> 02:33:22,250
and let me go ahead and create a
new final file called vault.py.

3084
02:33:22,250 --> 02:33:24,000
So code of vault.py.

3085
02:33:24,000 --> 02:33:27,416
And let me propose that we
implement the idea of a vault

3086
02:33:27,416 --> 02:33:30,541
at Gringotts, keeping on
theme, wherein there's

3087
02:33:30,541 --> 02:33:32,291
a bank in the world of Harry Potter.

3088
02:33:32,291 --> 02:33:35,083
And within this bank,
families and individuals

3089
02:33:35,083 --> 02:33:38,958
have vaults containing all sorts
of money in the wizarding world.

3090
02:33:38,958 --> 02:33:41,583
And the type of money that exists
in the world of Harry Potter

3091
02:33:41,583 --> 02:33:44,791
are coins called galleons
and sickles and Knuts,

3092
02:33:44,791 --> 02:33:47,083
and those are in
descending order of value.

3093
02:33:47,083 --> 02:33:49,750
And so inside of a vault might
be a whole bunch of coins--

3094
02:33:49,750 --> 02:33:53,000
gold, silver, and bronze, essentially,
each in those denominations,

3095
02:33:53,000 --> 02:33:53,833
tucked away.

3096
02:33:53,833 --> 02:33:58,083
So how can I go about implementing,
first of all, the idea of a vault

3097
02:33:58,083 --> 02:34:02,375
so that I can store, for instance,
for Harry Potter, how much coinage

3098
02:34:02,375 --> 02:34:05,916
is in his family's vault,
or for Ron Weasley the same?

3099
02:34:05,916 --> 02:34:08,291
Well, let me go ahead
and vault.py and first

3100
02:34:08,291 --> 02:34:12,291
create a class called Vault, essentially
meant to represent a bank vault.

3101
02:34:12,291 --> 02:34:15,000
Perfect, another real
world, or fantasy world,

3102
02:34:15,000 --> 02:34:17,500
entity that I want to
represent with code.

3103
02:34:17,500 --> 02:34:19,958
I could use a tuple or
a list or a dictionary.

3104
02:34:19,958 --> 02:34:23,083
But again, I'm going to get a lot
more functionality with classes,

3105
02:34:23,083 --> 02:34:26,125
and we'll see one final
flourish with operators.

3106
02:34:26,125 --> 02:34:28,875
Inside of this vault class,
let's go ahead and do this.

3107
02:34:28,875 --> 02:34:32,625
Let me define my init method,
taking its first argument of self.

3108
02:34:32,625 --> 02:34:35,625
And let me define three
arguments to this.

3109
02:34:35,625 --> 02:34:38,541
When you create a
vault, in my code here,

3110
02:34:38,541 --> 02:34:41,750
I want to be able to initialize it with
some number of galleons, some number

3111
02:34:41,750 --> 02:34:43,375
of sickles and, some number of Knuts.

3112
02:34:43,375 --> 02:34:46,791
I want the user, the programmer,
to be able to pass in one or more

3113
02:34:46,791 --> 02:34:47,833
of those values ideally.

3114
02:34:47,833 --> 02:34:50,083
But they can be optional,
so I'll give them defaults.

3115
02:34:50,083 --> 02:34:53,000
So let's go ahead and define
a parameter called galleons,

3116
02:34:53,000 --> 02:34:57,041
whose default value will be 0; sickles,
whose default value will also be 0;

3117
02:34:57,041 --> 02:35:00,083
and knuts, whose default
value will be 0 as well.

3118
02:35:00,083 --> 02:35:04,541
So the programmer can pass in one or
two or three or even none of those,

3119
02:35:04,541 --> 02:35:07,125
and they'll all have
some implied defaults.

3120
02:35:07,125 --> 02:35:10,500
How do I want to remember those
values that are passed in?

3121
02:35:10,500 --> 02:35:11,541
Well, let me do this.

3122
02:35:11,541 --> 02:35:14,583
self.galleons = galleons.

3123
02:35:14,583 --> 02:35:17,416
And self.sickles = sickles.

3124
02:35:17,416 --> 02:35:20,708
And self.knuts = knuts.

3125
02:35:20,708 --> 02:35:24,541
And so I could add some error checking,
especially if you don't pass in.

3126
02:35:24,541 --> 02:35:27,708
A number I could turn these into
properties to do even more validation.

3127
02:35:27,708 --> 02:35:30,791
But let's keep it simple and, as
always, focus only on the new ideas.

3128
02:35:30,791 --> 02:35:33,291
So I'm just going to trust that
these values were passed in,

3129
02:35:33,291 --> 02:35:36,708
and I'm going to immediately assign
them to these instance variables.

3130
02:35:36,708 --> 02:35:38,416
What, now, do I want to do?

3131
02:35:38,416 --> 02:35:41,208
Well, let's come up with
a way of printing out

3132
02:35:41,208 --> 02:35:44,000
what is in someone's vault, ultimately.

3133
02:35:44,000 --> 02:35:45,291
But first let's do this.

3134
02:35:45,291 --> 02:35:50,083
Let's create a vault for the Potters by
creating, via assignment, a new vault.

3135
02:35:50,083 --> 02:35:55,125
And let's say that the potters have
100 galleons, 50 sickles, and 24 knuts.

3136
02:35:55,125 --> 02:35:58,541
And that's in that vault. And let's
print out, for instance, potter.

3137
02:35:58,541 --> 02:36:00,916
All right, let's run this
code and see how it works now.

3138
02:36:00,916 --> 02:36:05,083
Let me go ahead and run
Python of vault.py, Enter.

3139
02:36:05,083 --> 02:36:06,083
Seems to work.

3140
02:36:06,083 --> 02:36:08,041
No syntax errors or anything else.

3141
02:36:08,041 --> 02:36:10,791
But this is not very enlightening.

3142
02:36:10,791 --> 02:36:15,291
How do I fix this, thinking
back to what we've done before?

3143
02:36:15,291 --> 02:36:17,958
AUDIENCE: You have to use the __str.

3144
02:36:17,958 --> 02:36:18,958
DAVID J. MALAN: Exactly.

3145
02:36:18,958 --> 02:36:22,291
I need to use one of those special
methods that comes with classes

3146
02:36:22,291 --> 02:36:26,625
and define for myself how I want
a vault to be printed as a string.

3147
02:36:26,625 --> 02:36:27,916
So let me go ahead and do that.

3148
02:36:27,916 --> 02:36:32,541
Let me define the str method taking
in self as its sole argument here.

3149
02:36:32,541 --> 02:36:34,500
And let's just return
a very simple string

3150
02:36:34,500 --> 02:36:36,833
that just reveals what's in the vault.

3151
02:36:36,833 --> 02:36:39,958
So I'm going to return
a formatted f string,

3152
02:36:39,958 --> 02:36:44,166
inside of which is self.galleons
and then the word galleon,

3153
02:36:44,166 --> 02:36:45,875
so I know which those are.

3154
02:36:45,875 --> 02:36:49,458
Then let's do self.sickles, and
let's output the word, sickles.

3155
02:36:49,458 --> 02:36:53,083
And then lastly let's output
self.knuts, and then knuts here.

3156
02:36:53,083 --> 02:36:58,041
So I know, in this string, just
how many of each of those coins

3157
02:36:58,041 --> 02:37:01,666
I have in this particular family's
vault. All right, let me go ahead

3158
02:37:01,666 --> 02:37:06,166
and run Python of vault.py, changing
nothing else except the str method.

3159
02:37:06,166 --> 02:37:11,625
And now, , we, see indeed that Harry has
100 galleons, 50 sickles, and 25 knuts.

3160
02:37:11,625 --> 02:37:13,541
All right, well, let's
do one thing more here.

3161
02:37:13,541 --> 02:37:16,875
Below that, let's go ahead
and define a Weasley variable.

3162
02:37:16,875 --> 02:37:20,583
And Ron never seemed to have quite as
much money in the vault as did Harry.

3163
02:37:20,583 --> 02:37:24,541
So let's say that the Weasley
vault will have 25, 50, and 100.

3164
02:37:24,541 --> 02:37:27,041
So I'll just reverse the
order of those denominations,

3165
02:37:27,041 --> 02:37:29,541
rather than Harry's 100, 50, 25.

3166
02:37:29,541 --> 02:37:33,125
And now let me go ahead and
print Weasley like this.

3167
02:37:33,125 --> 02:37:37,291
And let's go ahead and clear my
terminal window, run Python of vault.py.

3168
02:37:37,291 --> 02:37:40,541
This time, that str method
will be invoked twice, once

3169
02:37:40,541 --> 02:37:42,416
for each of those vault objects.

3170
02:37:42,416 --> 02:37:44,666
And we'll see, indeed, that
the first one for Harry

3171
02:37:44,666 --> 02:37:48,125
has got 100, 50, and 25,
respectively, versus Ron's 25, 50,

3172
02:37:48,125 --> 02:37:50,583
and 100, respectively.

3173
02:37:50,583 --> 02:37:52,458
But now let's do something interesting.

3174
02:37:52,458 --> 02:37:56,333
Suppose that you wanted to combine
the contents of two vaults,

3175
02:37:56,333 --> 02:37:58,875
be it Harry's and Ron's
or any other two people.

3176
02:37:58,875 --> 02:38:02,083
How would you go about
doing this in code?

3177
02:38:02,083 --> 02:38:06,000
Well, if I wanted to combine the
vaults for someone, I could do this.

3178
02:38:06,000 --> 02:38:08,333
Well, I could do galleons equals--

3179
02:38:08,333 --> 02:38:13,958
let's do potter.galleons
+ weasley.galleons.

3180
02:38:13,958 --> 02:38:16,250
That gives me a variable
called galleons that has

3181
02:38:16,250 --> 02:38:19,041
the sum of Harry and Ron's galleons.

3182
02:38:19,041 --> 02:38:25,333
Let's next do sickles =
potter.sickles + weasley.sickles.

3183
02:38:25,333 --> 02:38:31,916
And then lastly, let's do knuts
= potter.knuts + weasley.knuts.

3184
02:38:31,916 --> 02:38:32,958
I've got three variables.

3185
02:38:32,958 --> 02:38:34,666
What can I now do with these values?

3186
02:38:34,666 --> 02:38:37,833
Well, let's create a third--
a new vault. Total will

3187
02:38:37,833 --> 02:38:41,416
be the name of this variable equals
a new vault, Capital V, notice.

3188
02:38:41,416 --> 02:38:43,916
And now, let's pass in
those three new variables--

3189
02:38:43,916 --> 02:38:47,000
galleons, sickles, and knuts.

3190
02:38:47,000 --> 02:38:49,625
And that's it, and let's
print out this total vault.

3191
02:38:49,625 --> 02:38:52,750
So we should now see three
vaults-- one for Harry, for Ron,

3192
02:38:52,750 --> 02:38:55,208
and the combination--
the addition of the two.

3193
02:38:55,208 --> 02:38:58,875
Let me go ahead and rerun Python
of vault.py, and there we have it.

3194
02:38:58,875 --> 02:39:04,875
What was 100, 50, 25 and 25, 50, and
100, combined through addition now,

3195
02:39:04,875 --> 02:39:08,250
is 125, 100, 125.

3196
02:39:08,250 --> 02:39:10,541
So pretty straightforward,
using techniques from weeks

3197
02:39:10,541 --> 02:39:14,541
ago, where we're just declaring a few
new variables and doing some addition.

3198
02:39:14,541 --> 02:39:18,208
But wouldn't it be cool if I
could do something like this?

3199
02:39:18,208 --> 02:39:20,541
Wouldn't it be cool if
I could just somehow,

3200
02:39:20,541 --> 02:39:24,541
not manually create my own vault and
do all of this annoying math up here--

3201
02:39:24,541 --> 02:39:30,541
what if I could just do potter + weasley
and get rid of all of this logic here?

3202
02:39:30,541 --> 02:39:34,750
Wouldn't it be nice if I
overload the operator--

3203
02:39:34,750 --> 02:39:37,666
we know as plus, just
like str does, just

3204
02:39:37,666 --> 02:39:42,041
like list does-- to allow me
to add two vaults together

3205
02:39:42,041 --> 02:39:43,875
on the left and the right.

3206
02:39:43,875 --> 02:39:48,250
Well, it turns out in Python and
through operator overloading,

3207
02:39:48,250 --> 02:39:50,250
there is a way to do just this.

3208
02:39:50,250 --> 02:39:52,708
If you consult the
documentation, there's

3209
02:39:52,708 --> 02:39:56,750
this and so many other special
methods that come with classes.

3210
02:39:56,750 --> 02:39:59,916
The third one we'll see
here is this one here--

3211
02:39:59,916 --> 02:40:03,291
__add__.

3212
02:40:03,291 --> 02:40:05,458
And you'll see that it very
generically is described

3213
02:40:05,458 --> 02:40:09,333
in the documentation is working for
any object, be it a vault or str

3214
02:40:09,333 --> 02:40:10,791
or a list or something else.

3215
02:40:10,791 --> 02:40:13,458
By convention, it's going to take
a first argument called self,

3216
02:40:13,458 --> 02:40:17,083
and then it's going to take some other
argument, by convention, called other.

3217
02:40:17,083 --> 02:40:20,083
self, in effect, is going
to be referring to whatever

3218
02:40:20,083 --> 02:40:22,250
object is on the left of a plus sign.

3219
02:40:22,250 --> 02:40:24,166
other is going to be
referring to whatever

3220
02:40:24,166 --> 02:40:26,291
is on the right-hand
side of a plus sign,

3221
02:40:26,291 --> 02:40:30,333
thereby giving us a way of
describing, in code, the operand

3222
02:40:30,333 --> 02:40:35,416
on the left and the operand on the
right of the operator, plus, in between.

3223
02:40:35,416 --> 02:40:37,958
That is to say, if I go
back to VS Code here,

3224
02:40:37,958 --> 02:40:42,083
what I'm trying to do is
implement support for this.

3225
02:40:42,083 --> 02:40:45,041
Well, let me try, without
writing any other code just yet--

3226
02:40:45,041 --> 02:40:47,541
Python of vault.py, Enter--

3227
02:40:47,541 --> 02:40:53,541
TypeError: unsupported operand
type(s) for +: 'Vault' and 'vault.'

3228
02:40:53,541 --> 02:40:56,750
That is to say Python, at this
moment, does not know what

3229
02:40:56,750 --> 02:40:59,083
it means to add two vaults together.

3230
02:40:59,083 --> 02:41:00,500
You and I might have an instinct.

3231
02:41:00,500 --> 02:41:03,958
Probably want to combine the galleons
and the sickles and the knuts

3232
02:41:03,958 --> 02:41:04,791
respectively.

3233
02:41:04,791 --> 02:41:05,958
Python doesn't know that.

3234
02:41:05,958 --> 02:41:08,291
It just knows that you have
a new class called Vault.

3235
02:41:08,291 --> 02:41:10,250
But let's teach Python to do this.

3236
02:41:10,250 --> 02:41:12,166
Let me clear my terminal window.

3237
02:41:12,166 --> 02:41:15,208
Let me scroll back up to the class
itself, where, at the moment,

3238
02:41:15,208 --> 02:41:18,250
I only have two special
methods-- init and str.

3239
02:41:18,250 --> 02:41:20,458
But let's add this third.

3240
02:41:20,458 --> 02:41:26,625
Let me go into the class here and define
__add__ and then specify its first

3241
02:41:26,625 --> 02:41:30,791
parameter as self, as before, and then
a second parameter for this particular

3242
02:41:30,791 --> 02:41:32,583
method called, by convention, other.

3243
02:41:32,583 --> 02:41:34,833
Now, as always, I could name
those parameters anything

3244
02:41:34,833 --> 02:41:37,000
I want, but I'm going to
stick with convention here.

3245
02:41:37,000 --> 02:41:39,041
And now, inside of
this method, am I going

3246
02:41:39,041 --> 02:41:42,375
to have to now add together
the contents of two vaults?

3247
02:41:42,375 --> 02:41:43,333
Well, what two vaults?

3248
02:41:43,333 --> 02:41:46,291
Well, if we scroll down to our
goal at hand, the goal, of course,

3249
02:41:46,291 --> 02:41:48,583
is to add this vault plus
this other vault-- potter

3250
02:41:48,583 --> 02:41:50,208
plus weasley, respectively.

3251
02:41:50,208 --> 02:41:53,958
Well, it turns out, in Python, that,
when you do overload an operator like

3252
02:41:53,958 --> 02:41:56,291
plus, what's going to
happen automatically,

3253
02:41:56,291 --> 02:42:01,666
as soon as Python sees that, is it's
going to call that __add__ method,

3254
02:42:01,666 --> 02:42:04,041
and it's going to pass
into it to arguments--

3255
02:42:04,041 --> 02:42:07,333
whatever the operand is on the
left-- potter, in this case--

3256
02:42:07,333 --> 02:42:10,666
and whatever the operand is on
the right-- weasley, in this case.

3257
02:42:10,666 --> 02:42:15,500
And those values are going to get passed
in as self and other, respectively.

3258
02:42:15,500 --> 02:42:18,375
What that means is that we can
access their contents up here

3259
02:42:18,375 --> 02:42:20,458
in our implementation of add as follows.

3260
02:42:20,458 --> 02:42:24,125
Let me go ahead and define a local
variable called galleons and set that

3261
02:42:24,125 --> 02:42:27,500
equal to, for instance,
the sum of self.galleons--

3262
02:42:27,500 --> 02:42:30,125
whatever's in Potter's
vault in this case,

3263
02:42:30,125 --> 02:42:33,041
plus whatever is in Wesley's
vault in this case, which

3264
02:42:33,041 --> 02:42:35,000
would be other.galleons.

3265
02:42:35,000 --> 02:42:36,708
Let me do the same for sickles.

3266
02:42:36,708 --> 02:42:40,125
self.sickles + other.sickles.

3267
02:42:40,125 --> 02:42:41,958
And let me lastly do that for knuts.

3268
02:42:41,958 --> 02:42:45,791
So self.knuts + other.knuts.

3269
02:42:45,791 --> 02:42:47,625
But at the end of the
day, I'm going to need

3270
02:42:47,625 --> 02:42:51,500
to return a brand new bigger vault
that contains all of those contents

3271
02:42:51,500 --> 02:42:52,250
together.

3272
02:42:52,250 --> 02:42:56,791
And if we ultimately want to assign that
bigger vault to a variable like total

3273
02:42:56,791 --> 02:43:01,083
here, on the left, we'd better
return a value from this add method.

3274
02:43:01,083 --> 02:43:04,791
So I'm going to go ahead and give myself
a brand new vault, as by returning

3275
02:43:04,791 --> 02:43:08,916
capital Vault, which of course, is going
to call my vault function into which

3276
02:43:08,916 --> 02:43:11,750
I can now pass some of those
initialization arguments.

3277
02:43:11,750 --> 02:43:13,625
Well, how many galleon,
sickles, and knuts do

3278
02:43:13,625 --> 02:43:15,541
I want this brand new vault to contain?

3279
02:43:15,541 --> 02:43:19,666
Well, I want it to contain this
many galleons this many sickles,

3280
02:43:19,666 --> 02:43:21,291
and this many knuts.

3281
02:43:21,291 --> 02:43:23,708
So ultimately, what we're
doing in this implementation

3282
02:43:23,708 --> 02:43:27,791
of add is adding together those
galleons, sickles, and knuts, passing

3283
02:43:27,791 --> 02:43:30,958
them to the vault function so that
we get a brand new bigger vault,

3284
02:43:30,958 --> 02:43:33,833
and return that altogether.

3285
02:43:33,833 --> 02:43:36,041
So now I've defined
this new special method

3286
02:43:36,041 --> 02:43:42,250
called add that should now just
make plus work for two vaults.

3287
02:43:42,250 --> 02:43:42,833
Let's see.

3288
02:43:42,833 --> 02:43:46,750
Let me run down to my terminal window,
Python of vault.py and hit Enter.

3289
02:43:46,750 --> 02:43:51,958
And voila, and now we've implemented
an overloaded operator, plus,

3290
02:43:51,958 --> 02:43:54,166
to do what you and I
as humans would hope

3291
02:43:54,166 --> 02:43:56,458
would be the case when you
add two vaults together.

3292
02:43:56,458 --> 02:43:58,916
But I've now written the
code more specifically

3293
02:43:58,916 --> 02:44:04,500
to teach Python what it means
concretely to add two vaults together.

3294
02:44:04,500 --> 02:44:06,708
And it's with very
similar code in effect,

3295
02:44:06,708 --> 02:44:09,541
underneath the hood, that Python
is doing this for two strings,

3296
02:44:09,541 --> 02:44:13,875
to concatenate them together, to joining
two lists into a new list with list,

3297
02:44:13,875 --> 02:44:16,875
and so many other classes as well.

3298
02:44:16,875 --> 02:44:22,166
Any questions now on operator
overloading or this example here.

3299
02:44:22,166 --> 02:44:23,875
AUDIENCE: How would
you go about creating

3300
02:44:23,875 --> 02:44:31,833
a function for adding a student and
a vault for two separate classes?

3301
02:44:31,833 --> 02:44:33,250
Would that be possible?

3302
02:44:33,250 --> 02:44:35,125
DAVID J. MALAN: Let me
see what happens here.

3303
02:44:35,125 --> 02:44:36,041
I don't know offhand.

3304
02:44:36,041 --> 02:44:36,875
Let's do this.

3305
02:44:36,875 --> 02:44:38,541
Let's create a str and see what happens.

3306
02:44:38,541 --> 02:44:40,875
If I add Potter plus a str--

3307
02:44:40,875 --> 02:44:41,500
str object.

3308
02:44:41,500 --> 02:44:42,666
Yeah, so it would work.

3309
02:44:42,666 --> 02:44:44,708
I'm just figuring this
out as I go here, Eric.

3310
02:44:44,708 --> 02:44:47,000
So just to be clear,
what I did was I just

3311
02:44:47,000 --> 02:44:48,958
changed weasley to str
just to see what would

3312
02:44:48,958 --> 02:44:54,166
happen when I add a vault plus a
str, and it will work, theoretically.

3313
02:44:54,166 --> 02:44:54,791
Why?

3314
02:44:54,791 --> 02:45:01,541
Because so long as the type of value on
the left has an add method implemented,

3315
02:45:01,541 --> 02:45:04,291
other can be any type that you want.

3316
02:45:04,291 --> 02:45:06,583
You just have to decide
and code what it's

3317
02:45:06,583 --> 02:45:09,625
going to mean conceptually to
add a vault plus a string, which,

3318
02:45:09,625 --> 02:45:13,458
in this case, probably doesn't make
any sense at all, but it's possible.

3319
02:45:13,458 --> 02:45:15,208
It's going to be the
operand on the left.

3320
02:45:15,208 --> 02:45:16,250
And I'm inferring that.

3321
02:45:16,250 --> 02:45:17,958
I did not know the answer a moment ago.

3322
02:45:17,958 --> 02:45:22,916
I'm inferring that because what I got
was an attribute error here on line 11

3323
02:45:22,916 --> 02:45:27,125
because Python did not like
this. other.galleons didn't work,

3324
02:45:27,125 --> 02:45:29,666
but I could make it work
by figuring something out.

3325
02:45:29,666 --> 02:45:30,791
Really good question.

3326
02:45:30,791 --> 02:45:32,291
Didn't know that one myself.

3327
02:45:32,291 --> 02:45:35,916
Other questions on operator overloading?

3328
02:45:35,916 --> 02:45:38,291
AUDIENCE: Can you define
new operators in Python?

3329
02:45:38,291 --> 02:45:39,666
DAVID J. MALAN: I don't think so.

3330
02:45:39,666 --> 02:45:44,583
There is a very long but precise list
of operators that you can overload.

3331
02:45:44,583 --> 02:45:48,500
I do not believe you can
assign arbitrary characters

3332
02:45:48,500 --> 02:45:50,541
to be operators in Python.

3333
02:45:50,541 --> 02:45:52,458
Let me defer to Carter in the chat to--

3334
02:45:52,458 --> 02:45:55,166
OK, I'm seeing two of my colleagues
are saying, no, not possible.

3335
02:45:55,166 --> 02:45:57,166
So I'm going to go with
my first instinct, no.

3336
02:45:57,166 --> 02:45:58,583
Otherwise, that'd be kind of cool.

3337
02:45:58,583 --> 02:46:00,875
You could make emoji do
whatever you want to.

3338
02:46:00,875 --> 02:46:04,000
How about one final question
on operator overloading?

3339
02:46:04,000 --> 02:46:08,416
AUDIENCE: Is that the only
operation you can do as far as--

3340
02:46:08,416 --> 02:46:10,041
can you do a subtraction as well?

3341
02:46:10,041 --> 02:46:11,041
DAVID J. MALAN: You can.

3342
02:46:11,041 --> 02:46:13,583
You can do so many others let me.

3343
02:46:13,583 --> 02:46:16,583
If, Carter, you don't mind
pulling up this URL here--

3344
02:46:16,583 --> 02:46:19,750
so this link here-- special
method names and today's slides,

3345
02:46:19,750 --> 02:46:23,208
you'll see a long list of all of
the operators that you can overload.

3346
02:46:23,208 --> 02:46:26,583
You can do less than, equals
than, plus equals, minus equals.

3347
02:46:26,583 --> 02:46:29,291
Pretty much any symbol you've
seen me type on the screen

3348
02:46:29,291 --> 02:46:33,166
can be overloaded in
the context of classes.

3349
02:46:33,166 --> 02:46:35,541
So even though, today,
we focused entirely

3350
02:46:35,541 --> 02:46:38,625
on object-oriented programming, this
is a technique that we've been using,

3351
02:46:38,625 --> 02:46:41,791
really, since the first week of
the class because those ints,

3352
02:46:41,791 --> 02:46:45,291
those strs, those floats, those
lists, those dictionaries,

3353
02:46:45,291 --> 02:46:49,083
and so much more were already underneath
the hood this whole time-- classes

3354
02:46:49,083 --> 02:46:50,125
and objects thereof.

3355
02:46:50,125 --> 02:46:52,041
But you now, as a
programmer, have the ability

3356
02:46:52,041 --> 02:46:55,583
to create your own classes with your
own instance or class variables,

3357
02:46:55,583 --> 02:46:58,875
with your own instance or class
methods, with your own properties,

3358
02:46:58,875 --> 02:47:01,958
and even with your own custom
behavior for operators.

3359
02:47:01,958 --> 02:47:04,625
So ultimately, you can
absolutely continue

3360
02:47:04,625 --> 02:47:09,291
using those simple tuples or lists or
those dictionaries or other structures

3361
02:47:09,291 --> 02:47:09,791
as well.

3362
02:47:09,791 --> 02:47:13,416
But object-oriented programming, and
with it, classes and now these objects

3363
02:47:13,416 --> 02:47:15,208
is just another tool in your toolkit.

3364
02:47:15,208 --> 02:47:18,041
And daresay, as your code
gets more sophisticated

3365
02:47:18,041 --> 02:47:20,041
and your problems get
bigger, you'll find

3366
02:47:20,041 --> 02:47:23,708
that being able to model these real
world or even fantasy world entities

3367
02:47:23,708 --> 02:47:26,458
with classes and related
data and functionality

3368
02:47:26,458 --> 02:47:30,583
will ultimately just allow you to define
code that's not just correct but ever

3369
02:47:30,583 --> 02:47:32,833
well-designed as well.

3370
02:47:32,833 --> 02:47:35,541
This was CS50.


