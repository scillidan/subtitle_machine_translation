1
00:00:00,000 --> 00:00:03,960
[交响乐调音]

2
00:00:14,850 --> 00:00:18,315
[音乐播放]

3
00:00:24,270 --> 00:00:25,470
大卫·马兰：好的 

4
00:00:25,470 --> 00:00:28,680
这是CS50的Python编程入门 

5
00:00:28,680 --> 00:00:32,350
我的名字是David Malan 这是我们关于正则表达式的一周 

6
00:00:32,350 --> 00:00:37,170
因此 正则表达式 也称为正则表达式 实际上只是一种模式 

7
00:00:37,170 --> 00:00:39,120
实际上 在编程中 

8
00:00:39,120 --> 00:00:43,620
想要使用模式来匹配某种数据 通常是用户输入 

9
00:00:43,620 --> 00:00:47,190
例如 如果用户输入一个电子邮件地址 无论是您的程序 

10
00:00:47,190 --> 00:00:49,200
或者网站 或者手机上的应用程序 

11
00:00:49,200 --> 00:00:50,940
理想情况下 可能希望能够验证

12
00:00:50,940 --> 00:00:53,130
他们确实输入了一个电子邮件地址

13
00:00:53,130 --> 00:00:54,790
而不是完全不同的东西

14
00:00:54,790 --> 00:00:58,080
所以使用正则表达式 我们将拥有新发现的能力 

15
00:00:58,080 --> 00:01:02,280
在我们的代码中定义模式 将它们与我们正在使用的数据进行比较 

16
00:01:02,280 --> 00:01:04,920
从别人那里接收信息 无论是为了验证它 

17
00:01:04,920 --> 00:01:07,470
或者 即使我们想清理大量的数据 

18
00:01:07,470 --> 00:01:11,220
它本身可能是混乱的 因为它也来自我们人类 

19
00:01:11,220 --> 00:01:14,010
在此之前 我们使用这些正则表达式 

20
00:01:14,010 --> 00:01:19,620
我建议我们用一些简单的语法来解决一些问题

21
00:01:19,620 --> 00:01:22,140
看看我们遇到了什么样的限制 

22
00:01:22,140 --> 00:01:24,720
我建议在这里打开VS Code 

23
00:01:24,720 --> 00:01:27,900
让我创建一个名为validate.py的文件 

24
00:01:27,900 --> 00:01:30,768
验证用户的电子邮件地址 

25
00:01:30,768 --> 00:01:33,060
他们来到你的应用程序 他们来到你的网站 

26
00:01:33,060 --> 00:01:34,935
他们输入他们的电子邮件地址 

27
00:01:34,935 --> 00:01:38,380
回答是或否 此电子邮件地址看起来有效 

28
00:01:38,380 --> 00:01:38,880
好吧

29
00:01:38,880 --> 00:01:43,980
让我继续输入代码validate.py来创建一个新的标签 

30
00:01:43,980 --> 00:01:47,850
然后在这个选项卡中 让我继续并开始编写一些代码 

31
00:01:47,850 --> 00:01:50,010
怎么样 这让事情简单的开始 

32
00:01:50,010 --> 00:01:53,130
首先 让我继续并提示用户输入他们的电子邮件地址 

33
00:01:53,130 --> 00:01:57,510
我将把输入的返回值存储在一个名为email的变量中 

34
00:01:57,510 --> 00:01:59,940
问他们“你的邮箱是什么？“

35
00:01:59,940 --> 00:02:00,742
问号 

36
00:02:00,742 --> 00:02:02,700
我将继续至少先发制人地

37
00:02:02,700 --> 00:02:06,780
通过最小限度地只调用strie来清理用户的输入

38
00:02:06,780 --> 00:02:10,020
在我对输入的调用结束时 因为回想

39
00:02:10,020 --> 00:02:12,240
该输入返回一个或多个字符串 

40
00:02:12,240 --> 00:02:16,200
STR带有一些内置的方法或函数 其中之一

41
00:02:16,200 --> 00:02:18,390
是条状的 具有剥离的效果

42
00:02:18,390 --> 00:02:22,395
左边的任何前导空白或右边的任何尾随空白 

43
00:02:22,395 --> 00:02:24,270
所以这一切都会继续下去 至少

44
00:02:24,270 --> 00:02:27,480
避免人不小心输入了空格字符 

45
00:02:27,480 --> 00:02:29,860
我们要把它扔掉以防万一 

46
00:02:29,860 --> 00:02:31,500
现在我要做一些简单的事情 

47
00:02:31,500 --> 00:02:35,165
对于用户的输入是电子邮件地址 

48
00:02:35,165 --> 00:02:37,290
我想我们都同意 它有一个最低限度的

49
00:02:37,290 --> 00:02:39,130
在里面的某个地方放一个“符号” 

50
00:02:39,130 --> 00:02:40,140
所以 让我们从简单的开始 

51
00:02:40,140 --> 00:02:43,230
如果用户输入了带有@符号的内容 让我们

52
00:02:43,230 --> 00:02:46,800
非常慷慨地说 好的 有效的 看起来像一个电子邮件地址 

53
00:02:46,800 --> 00:02:50,940
如果我们遗漏了@符号 我们就说它无效 因为它显然是

54
00:02:50,940 --> 00:02:51,870
不是电子邮件地址 

55
00:02:51,870 --> 00:02:55,078
这还不是我的代码的最好版本 但我们将从简单开始 

56
00:02:55,078 --> 00:02:59,700
所以我要问这个问题 如果用户的

57
00:02:59,700 --> 00:03:03,570
电子邮件地址 继续并打印出来 例如 引号 不引号 “有效” 

58
00:03:03,570 --> 00:03:06,750
否则 如果没有 我现在很有信心

59
00:03:06,750 --> 00:03:09,250
事实上 地址是无效的 

60
00:03:09,250 --> 00:03:10,650
现在 这段代码在做什么？

61
00:03:10,650 --> 00:03:16,320
好吧 如果@Sign in Email是一种毕德式的方式 问这个字符串引号 

62
00:03:16,320 --> 00:03:20,762
在这封不带引号的电子邮件中 无论它在哪里--

63
00:03:20,762 --> 00:03:22,470
在开头、中间或结尾 

64
00:03:22,470 --> 00:03:25,470
它将自动搜索整个字符串为您

65
00:03:25,470 --> 00:03:26,220
自动的 

66
00:03:26,220 --> 00:03:27,660
我可以更详细地做这件事 

67
00:03:27,660 --> 00:03:29,670
我可以使用For循环或While循环

68
00:03:29,670 --> 00:03:32,640
并查看用户电子邮件地址中的每个字符 

69
00:03:32,640 --> 00:03:34,128
想看看这是不是@手势 

70
00:03:34,128 --> 00:03:36,420
但这是Python的优点之一 

71
00:03:36,420 --> 00:03:38,020
你可以用更少的钱做更多的事情 

72
00:03:38,020 --> 00:03:41,190
所以只要说如果“@”在电子邮件中引用 不引用 

73
00:03:41,190 --> 00:03:43,800
我们正在实现同样的结果 我们要找回真我

74
00:03:43,800 --> 00:03:47,670
如果它在那里的某个地方 那么它是有效的 否则就是假的 

75
00:03:47,670 --> 00:03:50,970
现在 让我继续在我的终端窗口中运行这个程序

76
00:03:50,970 --> 00:03:53,100
使用valiate.py的python 

77
00:03:53,100 --> 00:03:56,730
接下来 我会给它提供我的电子邮件地址--Malan@Gaveard.edu 

78
00:03:56,730 --> 00:03:57,570
进来吧 

79
00:03:57,570 --> 00:03:58,770
事实上 它是有效的 

80
00:03:58,770 --> 00:04:00,210
看起来是有效的 是有效的 

81
00:04:00,210 --> 00:04:03,480
但当然 从技术上讲 这个计划是失败的 

82
00:04:03,480 --> 00:04:04,410
这是一辆破车 

83
00:04:04,410 --> 00:04:07,110
如果有人输入 会是什么示例输入

84
00:04:07,110 --> 00:04:10,770
可能想在这里自愿回答 这将被认为是有效的

85
00:04:10,770 --> 00:04:13,197
但你我都知道这真的是无效的？

86
00:04:13,197 --> 00:04:14,280
观众：是的 谢谢 

87
00:04:14,280 --> 00:04:17,880
举个例子 你只需要输入两个符号就行了 

88
00:04:17,880 --> 00:04:20,760
而且它仍然有效--

89
00:04:20,760 --> 00:04:23,815
根据你的程序仍然有效 但遗漏了一些东西 

90
00:04:23,815 --> 00:04:24,690
大卫·马兰：没错 

91
00:04:24,690 --> 00:04:26,680
我们在这里设定了一个很低的标准 

92
00:04:26,680 --> 00:04:29,430
事实上 如果我继续并重新运行valiate.py的python 

93
00:04:29,430 --> 00:04:33,512
我只需输入一个@符号 就这样--没有用户名 没有域名 

94
00:04:33,512 --> 00:04:35,470
这看起来不像是电子邮件地址 

95
00:04:35,470 --> 00:04:38,790
但不幸的是 我的代码认为它实际上是 因为它显然是

96
00:04:38,790 --> 00:04:40,710
我只是在寻找一个单独的“标志” 

97
00:04:40,710 --> 00:04:42,250
那么 我们如何才能改进这一点呢？

98
00:04:42,250 --> 00:04:45,500
嗯 至少一个电子邮件地址 我想 往往会有 

99
00:04:45,500 --> 00:04:47,250
虽然这实际上不是一个要求 

100
00:04:47,250 --> 00:04:51,600
倾向于至少有一个@符号和一个点 可能在域中的某个地方

101
00:04:51,600 --> 00:04:54,240
姓名--So Malan@atherard.edu 

102
00:04:54,240 --> 00:04:55,960
那么让我们也来检查一下那个点 

103
00:04:55,960 --> 00:04:59,040
但再说一次 严格来说 情况甚至不一定是这样的 

104
00:04:59,040 --> 00:05:02,190
但我会选择我自己的电子邮件地址 至少目前是这样 作为我们的测试案例 

105
00:05:02,190 --> 00:05:06,450
所以让我继续更改我的代码 并说 不仅@在电子邮件中 

106
00:05:06,450 --> 00:05:11,050
但Dot也在电子邮件中 

107
00:05:11,050 --> 00:05:12,690
所以我现在问你两个问题 

108
00:05:12,690 --> 00:05:16,050
我有两个布尔表达式--If@in Email 

109
00:05:16,050 --> 00:05:20,650
我把它们逻辑地进行AND运算--可以说 这是一个逻辑AND运算 

110
00:05:20,650 --> 00:05:24,600
因此 如果@在电子邮件中 Dot在电子邮件中 

111
00:05:24,600 --> 00:05:26,470
现在我要继续说有效 

112
00:05:26,470 --> 00:05:26,970
好的 

113
00:05:26,970 --> 00:05:29,460
这似乎仍然适用于我的电子邮件地址 

114
00:05:29,460 --> 00:05:34,500
让我继续运行pythonvaliate.py Malan@atherard.edu 回车 

115
00:05:34,500 --> 00:05:36,390
当然 这是合理的 这是预料之中的 

116
00:05:36,390 --> 00:05:39,870
但在这里 我们也可以有点敌意 输入一些东西

117
00:05:39,870 --> 00:05:41,505
像“@”这样的无稽之谈 

118
00:05:41,505 --> 00:05:45,180
不幸的是 这也会被误认为是正确的 

119
00:05:45,180 --> 00:05:48,820
即使仍然没有用户名、域名或类似的东西 

120
00:05:48,820 --> 00:05:51,180
所以我认为我们在这方面需要更有条理一些 

121
00:05:51,180 --> 00:05:57,660
事实上 请注意 如果我这样做 @符号可以在任何地方 

122
00:05:57,660 --> 00:05:59,250
圆点可以在任何地方 

123
00:05:59,250 --> 00:06:02,190
但是如果我假设用户将拥有一个传统域名

124
00:06:02,190 --> 00:06:05,880
收割网或gmail.com之类的名字 我真的

125
00:06:05,880 --> 00:06:10,110
只想在域名中寻找圆点 不一定

126
00:06:10,110 --> 00:06:11,580
只有用户名 

127
00:06:11,580 --> 00:06:13,510
所以让我继续做这件事 

128
00:06:13,510 --> 00:06:18,250
让我继续在这里介绍一些更多的逻辑 而不是这样做 

129
00:06:18,250 --> 00:06:24,060
让我继续发送电子邮件 分开引用 不引用@sign 

130
00:06:24,060 --> 00:06:26,460
因此 电子邮件同样是一个字符串或字符串 

131
00:06:26,460 --> 00:06:29,550
STR有各种方法 不仅是脱衣 还包括

132
00:06:29,550 --> 00:06:32,190
另一种叫Split 顾名思义 

133
00:06:32,190 --> 00:06:36,570
如果指定一个或多个字符 则会将一个字符串拆分为多个字符

134
00:06:36,570 --> 00:06:37,950
在上面分开 

135
00:06:37,950 --> 00:06:42,390
希望这封邮件能从传统电子邮件中返回给我两个部分

136
00:06:42,390 --> 00:06:44,880
地址、用户名和域名 

137
00:06:44,880 --> 00:06:47,850
事实证明 我可以解开这一系列的回答

138
00:06:47,850 --> 00:06:52,410
通过这样做--用户名逗号域等于这个 

139
00:06:52,410 --> 00:06:55,060
我可以将其存储在列表或其他结构中 

140
00:06:55,060 --> 00:06:58,530
但如果我事先已经知道我期待什么样的价值 

141
00:06:58,530 --> 00:07:00,510
一个用户名和一个域名 我要

142
00:07:00,510 --> 00:07:04,050
要继续这样做 只需同时定义两个变量

143
00:07:04,050 --> 00:07:05,310
在一行代码上 

144
00:07:05,310 --> 00:07:07,290
现在我要说得更准确一点 

145
00:07:07,290 --> 00:07:13,230
如果用户名--如果用户名 那么我将继续

146
00:07:13,230 --> 00:07:15,370
说 打印“有效” 

147
00:07:15,370 --> 00:07:18,820
否则 我将继续说打印“无效” 

148
00:07:18,820 --> 00:07:20,040
现在 这还不够好 

149
00:07:20,040 --> 00:07:22,800
但我现在至少在检查用户名是否存在 

150
00:07:22,800 --> 00:07:25,217
你可能以前没见过 但如果你简单地

151
00:07:25,217 --> 00:07:28,680
问一个类似“如果用户名是字符串”这样的问题 

152
00:07:28,680 --> 00:07:31,320
好的 用户名--“如果用户名”能给我

153
00:07:31,320 --> 00:07:35,730
如果用户名不是NONE或QUOTE 则回答正确 

154
00:07:35,730 --> 00:07:36,840
不引用“什么都没有 ”

155
00:07:36,840 --> 00:07:41,820
因此这里有一个真实的值 即如果用户名至少有一个字符 

156
00:07:41,820 --> 00:07:43,350
这将被认为是真的 

157
00:07:43,350 --> 00:07:46,170
但如果用户名没有字符 它将

158
00:07:46,170 --> 00:07:49,245
有效地被认为是错误的价值 

159
00:07:49,245 --> 00:07:50,370
但这还不够好 

160
00:07:50,370 --> 00:07:52,037
我不想只检查用户名 

161
00:07:52,037 --> 00:07:57,160
我还想检查一下 点是否也在域名中 

162
00:07:57,160 --> 00:08:00,180
请注意 这里有一点潜在的混乱

163
00:08:00,180 --> 00:08:01,830
会说英语 

164
00:08:01,830 --> 00:08:04,620
在这里 我似乎是在说“如果用户名和点

165
00:08:04,620 --> 00:08:09,660
在域中 “就像我在问问题” 如果用户名和点

166
00:08:09,660 --> 00:08:12,270
但这并不是这个意思 

167
00:08:12,270 --> 00:08:15,540
这是两个不同的布尔表达式--“如果用户名 ”

168
00:08:15,540 --> 00:08:19,690
和单独的 “如果点在领域 ”

169
00:08:19,690 --> 00:08:23,100
如果我把这个放在括号里 我们可以通过把

170
00:08:23,100 --> 00:08:25,000
圆括号在那里 圆括号在这里 

171
00:08:25,000 --> 00:08:27,390
为了清楚起见 它实际上是两个布尔表达式

172
00:08:27,390 --> 00:08:30,840
我们是在一起做AND 而不是一个更长的英语句子 

173
00:08:30,840 --> 00:08:35,580
现在 如果我继续运行这个 python valiate.py回车 

174
00:08:35,580 --> 00:08:39,809
我会再做一次我自己的电子邮件地址 Malan@atherard.edu 这是有效的 

175
00:08:39,809 --> 00:08:43,710
看起来我可以忍受这样的事情 

176
00:08:43,710 --> 00:08:47,970
如果我做马兰 就说 哈佛 我认为目前

177
00:08:47,970 --> 00:08:49,480
这将是无效的 

178
00:08:49,480 --> 00:08:52,150
现在 也许顶级域名哈佛存在 

179
00:08:52,150 --> 00:08:54,900
但目前 我们似乎在寻找更多的东西 

180
00:08:54,900 --> 00:08:58,380
我们也在寻找顶级域名 比如.edu 

181
00:08:58,380 --> 00:09:01,540
目前 我们只认为这是无效的 

182
00:09:01,540 --> 00:09:04,510
但这不仅仅是我们想要做的--

183
00:09:04,510 --> 00:09:07,260
这不仅仅是因为我们想要检查用户名是否存在

184
00:09:07,260 --> 00:09:08,370
和一个圆点的存在 

185
00:09:08,370 --> 00:09:09,520
让我们说得更具体些 

186
00:09:09,520 --> 00:09:11,687
让我们现在开始缩小这个项目的范围 

187
00:09:11,687 --> 00:09:15,600
不仅仅是关于一般的电子邮件 还有关于EDU地址 

188
00:09:15,600 --> 00:09:18,780
例如 对于美国大学里的一些人来说 

189
00:09:18,780 --> 00:09:21,450
其电子邮件地址往往以.edu结尾 

190
00:09:21,450 --> 00:09:23,310
我可以说得更准确一点 

191
00:09:23,310 --> 00:09:25,350
你可能已经回想起这个函数了 

192
00:09:25,350 --> 00:09:28,590
而不是简单地说 在域中的某个地方有一个点 

193
00:09:28,590 --> 00:09:34,740
让我说 域名以引号结尾 非引号“.edu” 

194
00:09:34,740 --> 00:09:36,420
现在我们更加精确了 

195
00:09:36,420 --> 00:09:40,200
我们希望至少有一个不为空的用户名--不仅仅是引号 

196
00:09:40,200 --> 00:09:45,190
不引用“Nothing”--我们希望域名实际上以.edu结尾 

197
00:09:45,190 --> 00:09:47,448
让我继续运行valiate.py的python 

198
00:09:47,448 --> 00:09:49,740
为了确保我没有把事情搞得更糟 

199
00:09:49,740 --> 00:09:53,470
至少让我测试一下我自己的电子邮件地址 它看起来确实有效 

200
00:09:53,470 --> 00:09:56,070
现在 我似乎至少需要提供一个用户名 

201
00:09:56,070 --> 00:09:58,380
因为我们确实有这张支票 

202
00:09:58,380 --> 00:10:00,210
所以我要继续说 马兰 

203
00:10:00,210 --> 00:10:02,790
现在我要继续说“ 

204
00:10:02,790 --> 00:10:05,880
而且看起来我可能有点恶毒 

205
00:10:05,880 --> 00:10:09,030
只需说Malan@.edu 就像是最小限度的会面

206
00:10:09,030 --> 00:10:11,340
此模式的要求 

207
00:10:11,340 --> 00:10:13,200
当然 这被认为是有效的 

208
00:10:13,200 --> 00:10:17,010
但我非常肯定 在Malan@.edu上没有人 

209
00:10:17,010 --> 00:10:19,350
我们需要在那里有一些域名 

210
00:10:19,350 --> 00:10:21,360
因此 我们仍然没有那么慷慨 

211
00:10:21,360 --> 00:10:24,510
现在 我们完全可以继续迭代这个程序 

212
00:10:24,510 --> 00:10:26,640
我们可以添加更多的布尔表达式 

213
00:10:26,640 --> 00:10:28,590
我们也许可以使用一些其他的Python方法

214
00:10:28,590 --> 00:10:31,530
为了更精确地检查点的左边是否有东西 

215
00:10:31,530 --> 00:10:32,550
点的右边 

216
00:10:32,550 --> 00:10:34,320
我们可以多次使用split 

217
00:10:34,320 --> 00:10:36,180
但老实说 这只是迅速升级 

218
00:10:36,180 --> 00:10:39,450
就像 你最终不得不写很多代码 

219
00:10:39,450 --> 00:10:42,360
来表达一些相对简单的东西--

220
00:10:42,360 --> 00:10:45,550
就像电子邮件地址一样格式化它 

221
00:10:45,550 --> 00:10:47,920
那么 我们如何才能改善这一点呢？

222
00:10:47,920 --> 00:10:52,350
Python中有一个正则表达式库 

223
00:10:52,350 --> 00:10:55,620
它被称为简洁的R-E 在图书馆里 

224
00:10:55,620 --> 00:11:00,510
你有很多能力来定义和检查 甚至取代

225
00:11:00,510 --> 00:11:01,440
模式.

226
00:11:01,440 --> 00:11:03,630
同样 正则表达式也是一种模式 

227
00:11:03,630 --> 00:11:05,998
这个库 Python中的re库 

228
00:11:05,998 --> 00:11:08,040
会让我们定义其中的一些模式

229
00:11:08,040 --> 00:11:09,915
比如电子邮件地址的模式 然后

230
00:11:09,915 --> 00:11:12,720
使用一些内置函数来验证

231
00:11:12,720 --> 00:11:14,820
用户的输入与该模式相对应 

232
00:11:14,820 --> 00:11:17,250
使用这些模式来更改用户的输入

233
00:11:17,250 --> 00:11:19,650
或者从中提取部分信息 

234
00:11:19,650 --> 00:11:22,030
我们将看到所有这些和更多的例子 

235
00:11:22,030 --> 00:11:24,045
那么 我可以和应该如何使用这个图书馆呢？

236
00:11:24,045 --> 00:11:26,670
首先 它有很多功能 

237
00:11:26,670 --> 00:11:29,760
例如 这里是官方文档的URL 

238
00:11:29,760 --> 00:11:31,710
我建议我们集中精力

239
00:11:31,710 --> 00:11:36,600
图书馆里最通用的功能之一 就是这个--搜索 

240
00:11:36,600 --> 00:11:40,440
re.search是函数的名称 re模块

241
00:11:40,440 --> 00:11:42,910
它允许你传入一些参数

242
00:11:42,910 --> 00:11:46,620
第一个是你想要搜索的模式 

243
00:11:46,620 --> 00:11:48,900
例如 来自用户的字符串 

244
00:11:48,900 --> 00:11:51,977
这里的字符串参数将是实际的字符串 

245
00:11:51,977 --> 00:11:53,310
我想寻找这种模式 

246
00:11:53,310 --> 00:11:55,410
还有第三个参数可选

247
00:11:55,410 --> 00:11:56,790
那可是一大堆旗子

248
00:11:56,790 --> 00:11:59,880
一般来说 标志就像是可以传入的参数

249
00:11:59,880 --> 00:12:01,510
修改函数的行为 

250
00:12:01,510 --> 00:12:03,510
但一开始 我们甚至不打算用这个 

251
00:12:03,510 --> 00:12:06,610
我们只需要传递几个参数 

252
00:12:06,610 --> 00:12:11,700
所以让我继续使用这个Re库 这个正则表达式

253
00:12:11,700 --> 00:12:15,162
库 并在此设计基础上逐步改进 

254
00:12:15,162 --> 00:12:17,370
所以我们不会一下子解决这个问题 

255
00:12:17,370 --> 00:12:19,590
但我们将采取一些渐进的步骤 

256
00:12:19,590 --> 00:12:21,840
我将回到这里的VS代码 

257
00:12:21,840 --> 00:12:25,050
现在我要继续下去 去掉大部分代码 

258
00:12:25,050 --> 00:12:28,230
但我要进入我的文件顶部 在秋季的第一天 

259
00:12:28,230 --> 00:12:30,030
导入此Re库 

260
00:12:30,030 --> 00:12:33,030
因此 导入环使我可以访问该功能以及更多功能 

261
00:12:33,030 --> 00:12:36,150
现在 在我以与以前相同的方式获得用户输入之后 

262
00:12:36,150 --> 00:12:38,790
去掉任何前导或尾随空格 

263
00:12:38,790 --> 00:12:42,250
现在 我只是简单地使用这个函数 

264
00:12:42,250 --> 00:12:44,460
尽管这并不是真正向前迈出的一大步 

265
00:12:44,460 --> 00:12:50,190
我要说的是 如果re.earch包含引号 请取消引号“@”

266
00:12:50,190 --> 00:12:53,700
在电子邮件地址中 然后让我们继续打印“有效” 

267
00:12:53,700 --> 00:12:55,740
否则 让我们继续打印“无效” 

268
00:12:55,740 --> 00:12:59,730
目前 这真的不比我的第一个版本好多少

269
00:12:59,730 --> 00:13:04,150
我刚才问的是 如果@在电子邮件地址签名的话 

270
00:13:04,150 --> 00:13:08,880
但现在我至少开始通过使用自己的re.earch来使用这个库了

271
00:13:08,880 --> 00:13:13,740
函数 目前您可以假定该函数有效地返回真值 

272
00:13:13,740 --> 00:13:16,440
如果@符号确实是一封电子邮件的话 

273
00:13:16,440 --> 00:13:19,800
为了确保这个版本能像我预期的那样工作 让我继续

274
00:13:19,800 --> 00:13:22,590
然后运行validate.py的python并回车 

275
00:13:22,590 --> 00:13:26,220
我会输入我的实际电子邮件地址 然后我们就可以继续营业了 

276
00:13:26,220 --> 00:13:29,370
但当然 这并不是很好 因为如果我同样

277
00:13:29,370 --> 00:13:32,400
运行这个版本的程序 只需输入@符号 

278
00:13:32,400 --> 00:13:35,860
不是电子邮件地址 但我的代码当然认为它是有效的 

279
00:13:35,860 --> 00:13:37,980
那么 我怎么才能做得比这更好呢？

280
00:13:37,980 --> 00:13:42,330
在正则表达式领域 我们需要更多的词汇 

281
00:13:42,330 --> 00:13:46,290
为了能够更准确地表达我们自己 

282
00:13:46,290 --> 00:13:48,900
真的 我想最终定义的模式

283
00:13:48,900 --> 00:13:52,410
我希望左边有个东西

284
00:13:52,410 --> 00:13:55,320
然后是一个@符号 然后是右边的东西 

285
00:13:55,320 --> 00:13:59,310
右边的东西应该以.edu结尾 但也应该有

286
00:13:59,310 --> 00:14:02,160
在.edu之前 比如哈佛 耶鲁 

287
00:14:02,160 --> 00:14:04,680
美国的其他学校也是如此 

288
00:14:04,680 --> 00:14:06,550
我该怎么做呢？

289
00:14:06,550 --> 00:14:11,040
事实证明 在正则表达式的世界中 无论是在Python中 

290
00:14:11,040 --> 00:14:14,220
或者其他语言中 有一些特定的符号

291
00:14:14,220 --> 00:14:16,140
可以用来定义模式 

292
00:14:16,140 --> 00:14:19,030
目前 我只使用了字面上的原始文本 

293
00:14:19,030 --> 00:14:21,600
如果我回到我的代码这里 这在技术上

294
00:14:21,600 --> 00:14:23,940
正则表达式是一个正则表达式 

295
00:14:23,940 --> 00:14:28,290
我传入了一个带引号的字符串 里面有一个@符号 

296
00:14:28,290 --> 00:14:30,550
现在 这不是一个非常有趣的模式 

297
00:14:30,550 --> 00:14:31,500
只是一个@符号 

298
00:14:31,500 --> 00:14:34,290
但事实证明 一旦你有机会访问正则表达式 

299
00:14:34,290 --> 00:14:37,350
或者提供该功能的库 您可以

300
00:14:37,350 --> 00:14:40,360
你可以像下面这样有力地表达自己 

301
00:14:40,360 --> 00:14:43,770
让我来揭示一下 你传递给re.search的模式

302
00:14:43,770 --> 00:14:45,690
可以用一大堆特殊的符号

303
00:14:45,690 --> 00:14:47,160
这只是其中的一部分 

304
00:14:47,160 --> 00:14:51,630
在我们将要看到的例子中 在我们将要定义的模式中 

305
00:14:51,630 --> 00:14:53,040
这是特殊符号 

306
00:14:53,040 --> 00:14:56,280
你可以用一个句号 一个点 

307
00:14:56,280 --> 00:14:59,040
除了换行符和空行以外的任何字符 

308
00:14:59,040 --> 00:15:02,190
也就是说 如果我不在乎字母表中的哪个字母

309
00:15:02,190 --> 00:15:04,200
在用户的用户名中 我只希望有

310
00:15:04,200 --> 00:15:07,410
是用户名中的一个或多个字符 

311
00:15:07,410 --> 00:15:11,340
dot可以让我用z 和来表示A 

312
00:15:11,340 --> 00:15:13,560
还有其他一些字母

313
00:15:13,560 --> 00:15:18,850
* 表示--一个星号--零次或多次重复 

314
00:15:18,850 --> 00:15:21,630
所以如果我说了什么 那就意味着

315
00:15:21,630 --> 00:15:24,450
愿意接受零重复 即 

316
00:15:24,450 --> 00:15:27,510
什么都没有 或者更多的重复

317
00:15:27,510 --> 00:15:29,580
1或2或3或300 

318
00:15:29,580 --> 00:15:31,950
如果你在我的模式中看到一个加号 

319
00:15:31,950 --> 00:15:34,135
这意味着一次或多次重复 

320
00:15:34,135 --> 00:15:37,260
也就是说 至少要有一个字符 一个符号 

321
00:15:37,260 --> 00:15:40,180
然后 在那之后还有更多的可选的 

322
00:15:40,180 --> 00:15:43,110
然后你可以说零或一次重复 

323
00:15:43,110 --> 00:15:46,590
您可以在符号后使用单个问号 这将表示 

324
00:15:46,590 --> 00:15:51,260
我不想要这个角色或一个角色 但这就是我所期望的 

325
00:15:51,260 --> 00:15:53,010
最后 会有一种方法

326
00:15:53,010 --> 00:15:55,140
要指定特定数量的符号 请执行以下操作 

327
00:15:55,140 --> 00:15:57,330
如果你使用这些花括号和一个数字 

328
00:15:57,330 --> 00:15:59,610
在这里符号表示为m 您可以

329
00:15:59,610 --> 00:16:03,720
指定需要m次重复 可以是1次、2次、3次或300次 

330
00:16:03,720 --> 00:16:06,190
您可以自己指定重复次数 

331
00:16:06,190 --> 00:16:08,280
如果你想要一系列的重复 就像你

332
00:16:08,280 --> 00:16:11,100
想要这几个字或者这么多字 

333
00:16:11,100 --> 00:16:13,770
您可以在里面使用花括号和两个数字 

334
00:16:13,770 --> 00:16:18,760
在这里称为m和n 这将是m到n个重复的范围 

335
00:16:18,760 --> 00:16:20,140
那么 这一切意味着什么呢？

336
00:16:20,140 --> 00:16:22,380
好吧 让我回到VS代码这里 让我们

337
00:16:22,380 --> 00:16:25,650
我建议我们进一步迭代这个解决方案 

338
00:16:25,650 --> 00:16:27,985
仅仅检查@符号是不够的 

339
00:16:27,985 --> 00:16:28,860
我们已经知道了这一点 

340
00:16:28,860 --> 00:16:31,600
我们最低限度地想要一些东西放在左边和右边 

341
00:16:31,600 --> 00:16:33,210
那么 我该如何代表这一点呢？

342
00:16:33,210 --> 00:16:35,910
我并不真正关心用户的用户名是什么 

343
00:16:35,910 --> 00:16:40,020
或者是字母表中的什么字母 无论是马兰还是其他任何人的 

344
00:16:40,020 --> 00:16:42,600
所以我要做的是在等号的左边

345
00:16:42,600 --> 00:16:44,410
我将用一个句号--

346
00:16:44,410 --> 00:16:49,600
同样表示除换行符以外的任何字符的圆点 

347
00:16:49,600 --> 00:16:51,630
但我不只想要一个角色 

348
00:16:51,630 --> 00:16:55,900
否则 该人的用户名只能是某某 

349
00:16:55,900 --> 00:16:57,450
或者b某某 

350
00:16:57,450 --> 00:17:00,130
我希望是多个这样的角色 

351
00:17:00,130 --> 00:17:01,680
所以我将首先使用* 

352
00:17:01,680 --> 00:17:05,550
所以点*的意思是给我一些左边的东西 我要做另一个 

353
00:17:05,550 --> 00:17:07,619
点*右边的东西 

354
00:17:07,619 --> 00:17:10,589
现在 这并不完美 但至少是向前迈进了一步 

355
00:17:10,589 --> 00:17:12,871
因为现在我要做的就是这样 

356
00:17:12,871 --> 00:17:14,579
我将重新运行valiate.py的python 

357
00:17:14,579 --> 00:17:17,040
我将继续测试我自己的电子邮件地址 只是为了

358
00:17:17,040 --> 00:17:18,415
当然 我没有让事情变得更糟 

359
00:17:18,415 --> 00:17:19,800
现在一切都好了 

360
00:17:19,800 --> 00:17:22,530
现在我要继续输入一些其他的内容 

361
00:17:22,530 --> 00:17:28,380
就像没有域名的马兰@怎么样 

362
00:17:28,380 --> 00:17:30,640
你可能会认为这将是无效的 

363
00:17:30,640 --> 00:17:34,680
但是 但是 但是它仍然被认为是有效的 

364
00:17:34,680 --> 00:17:35,850
但为什么会这样呢？

365
00:17:35,850 --> 00:17:42,120
如果我回到这张图表 为什么现在没有域名的情况下会考虑Malan@

366
00:17:42,120 --> 00:17:43,260
有效吗？

367
00:17:43,260 --> 00:17:50,010
我在这里使用.*@.*作为正则表达式 这有什么错误

368
00:17:50,010 --> 00:17:50,670
还是正则表达式？

369
00:17:50,670 --> 00:17:54,355
观众：因为你用的是* 而不是加号 

370
00:17:54,355 --> 00:17:55,230
大卫·马兰：没错 

371
00:17:55,230 --> 00:17:58,090
再说一次 *表示零次或多次重复 

372
00:17:58,090 --> 00:18:03,120
所以re.earch非常乐意在@符号之后什么都不接受 

373
00:18:03,120 --> 00:18:05,230
因为这将是零重复 

374
00:18:05,230 --> 00:18:09,000
所以我认为我至少需要改进这一点 然后回到我这里的代码 

375
00:18:09,000 --> 00:18:12,990
让我继续 把这个从点*改为点+ 

376
00:18:12,990 --> 00:18:16,620
让我把结尾从点*改成点+

377
00:18:16,620 --> 00:18:18,900
所以现在当我在这里运行代码时--

378
00:18:18,900 --> 00:18:21,510
让我继续运行valiate.py的python 

379
00:18:21,510 --> 00:18:23,490
我要像往常一样测试我的电子邮件地址 

380
00:18:23,490 --> 00:18:24,600
还在工作 

381
00:18:24,600 --> 00:18:27,690
现在让我继续输入之前的相同内容

382
00:18:27,690 --> 00:18:29,820
意外地被认为是有效的 

383
00:18:29,820 --> 00:18:32,590
现在我按了回车 最后它是无效的 

384
00:18:32,590 --> 00:18:35,460
所以现在我们正在取得一些进展 在多一点

385
00:18:35,460 --> 00:18:37,560
准确地知道我们在做什么 

386
00:18:37,560 --> 00:18:40,920
现在 我要在这里指出 就像编程中的几乎所有事情一样 

387
00:18:40,920 --> 00:18:45,090
包括Python在内 通常有多种方法来解决相同的问题 

388
00:18:45,090 --> 00:18:49,410
有没有人在我的代码中发现了什么

389
00:18:49,410 --> 00:18:54,360
如果我忘记了加号运算符的存在 我可以稍作调整

390
00:18:54,360 --> 00:18:56,880
然后重新使用*？

391
00:18:56,880 --> 00:19:00,570
如果我只允许你使用圆点和星号 

392
00:19:00,570 --> 00:19:03,570
你能再创造一个加号的概念吗？

393
00:19:03,570 --> 00:19:04,890
观众：是的 

394
00:19:04,890 --> 00:19:06,930
使用另一个点 点点* 

395
00:19:06,930 --> 00:19:07,680
大卫·马兰：是的 

396
00:19:07,680 --> 00:19:10,290
因为如果圆点表示任何字符 我们将只使用圆点 

397
00:19:10,290 --> 00:19:14,040
然后当你想说“or more”时 用另一个点 然后用* 

398
00:19:14,040 --> 00:19:18,300
所以等同于点+的应该是点* 

399
00:19:18,300 --> 00:19:21,870
因为第一个点表示任何字符 而第二对点表示任何字符

400
00:19:21,870 --> 00:19:25,050
在字符中 点*表示零个或多个其他字符 

401
00:19:25,050 --> 00:19:27,600
需要明确的是 它不一定是同一个角色 

402
00:19:27,600 --> 00:19:31,830
只做点或点*并不意味着您的整个用户名需要

403
00:19:31,830 --> 00:19:35,310
A 或AA 或AAA 或AAAA 

404
00:19:35,310 --> 00:19:37,230
它可以随每个符号而不同 

405
00:19:37,230 --> 00:19:41,790
它只是指背靠背的任何字符的零个或多个 

406
00:19:41,790 --> 00:19:44,050
所以我可以在左边和右边做这件事 

407
00:19:44,050 --> 00:19:45,120
哪一个更好？

408
00:19:45,120 --> 00:19:46,110
你知道 这要看情况 

409
00:19:46,110 --> 00:19:49,860
我认为可以提出一个论点 这一点甚至更清楚 因为它

410
00:19:49,860 --> 00:19:52,380
很明显 现在有一个圆点 意思是任何字符 

411
00:19:52,380 --> 00:19:53,910
然后是圆点* 

412
00:19:53,910 --> 00:19:56,250
但如果你习惯于经常这样做 

413
00:19:56,250 --> 00:19:58,500
像加号这样的东西存在的原因之一

414
00:19:58,500 --> 00:20:01,750
只是将您的代码合并到更简洁的内容中 

415
00:20:01,750 --> 00:20:03,750
如果你对现在看到的好处很熟悉 

416
00:20:03,750 --> 00:20:05,470
也许这对你来说更具可读性 

417
00:20:05,470 --> 00:20:07,590
所以再一次 就像更一般的Python一样 

418
00:20:07,590 --> 00:20:10,590
你会经常看到不同的方式来表达相同的模式 

419
00:20:10,590 --> 00:20:12,750
理性的人可能会同意 也可能不同意

420
00:20:12,750 --> 00:20:15,810
哪种方式比另一种方式更好 

421
00:20:15,810 --> 00:20:18,030
好吧 让我向你提议 我们可以认为

422
00:20:18,030 --> 00:20:20,520
关于这两个模型的更多一点图形化 

423
00:20:20,520 --> 00:20:22,770
如果你觉得这有点神秘 让我继续说下去

424
00:20:22,770 --> 00:20:26,610
并回溯到此正则表达式的前一个实例 该正则表达式

425
00:20:26,610 --> 00:20:28,830
只有一个点* 

426
00:20:28,830 --> 00:20:32,910
这个正则表达式.*@.*又意味着什么？

427
00:20:32,910 --> 00:20:36,690
它表示零个或多个字符 后跟文字符号@

428
00:20:36,690 --> 00:20:38,580
零个或多个其他字符 

429
00:20:38,580 --> 00:20:41,850
现在 当您将此模式作为参数传递给re.earch时 

430
00:20:41,850 --> 00:20:45,030
它将从左到右读取它 然后使用

431
00:20:45,030 --> 00:20:48,750
它尝试与输入进行匹配 在本例中为电子邮件 

432
00:20:48,750 --> 00:20:50,100
用户输入的 

433
00:20:50,100 --> 00:20:53,070
现在 你的电脑怎么样了 re.earch怎么样了

434
00:20:53,070 --> 00:20:57,760
要跟踪用户的电子邮件是否与此模式匹配？

435
00:20:57,760 --> 00:21:01,230
嗯 结果是它将使用一种实现的机器

436
00:21:01,230 --> 00:21:03,540
在被称为有限状态机或更多的软件中

437
00:21:03,540 --> 00:21:06,750
形式上 一个不确定的有限自动机 

438
00:21:06,750 --> 00:21:09,930
如果我们用图形来描述它 它的工作方式如下所示 

439
00:21:09,930 --> 00:21:14,940
Re.earch函数从这里开始 处于所谓的开始状态 

440
00:21:14,940 --> 00:21:16,980
这就是它开始时的那种情况 

441
00:21:16,980 --> 00:21:20,730
然后它将从左到右读取用户的电子邮件地址 

442
00:21:20,730 --> 00:21:24,030
它将决定是否留在第一个状态

443
00:21:24,030 --> 00:21:26,170
或者转换到下一个状态 

444
00:21:26,170 --> 00:21:29,970
例如 在第一个状态中 当用户正在阅读我的电子邮件地址时 

445
00:21:29,970 --> 00:21:35,130
它将沿着这个弯曲的边缘向上和向四周移动

446
00:21:35,130 --> 00:21:36,870
对它本身来说 是一种反身性的优势 

447
00:21:36,870 --> 00:21:40,030
它被标记为点 因为点 再一次 只是指任何字符 

448
00:21:40,030 --> 00:21:43,840
因此 由于该函数正在读取我的电子邮件地址 即Malan@atherard.edu 

449
00:21:43,840 --> 00:21:48,270
从左到右 它将遵循如下的转变 

450
00:21:48,270 --> 00:21:53,070
并购-并购-L-A-N

451
00:21:53,070 --> 00:21:56,040
然后 它有望在这种过渡之后

452
00:21:56,040 --> 00:22:00,000
转到第二个状态 因为这台机器中有一个字面符号@

453
00:22:00,000 --> 00:22:01,630
以及在我的电子邮件地址中 

454
00:22:01,630 --> 00:22:10,070
然后它将尝试读取我地址的其余部分 H-A-R-V-A-R-D点E-D-U 

455
00:22:10,070 --> 00:22:11,190
就是这样 

456
00:22:11,190 --> 00:22:12,870
然后电脑就会进行检查 

457
00:22:12,870 --> 00:22:16,260
它最终是以接受状态 最终状态 

458
00:22:16,260 --> 00:22:18,120
它实际上在这里被生动地描绘出来

459
00:22:18,120 --> 00:22:21,150
两个圆圈 一个在另一个里面 有一点不同吗？

460
00:22:21,150 --> 00:22:25,410
这就意味着 如果计算机发现自己在那一秒

461
00:22:25,410 --> 00:22:29,130
在已经读取所有用户输入之后的接受状态 

462
00:22:29,130 --> 00:22:31,560
这确实是一个有效的电子邮件地址 

463
00:22:31,560 --> 00:22:34,350
如果碰巧 机器以某种方式结束了

464
00:22:34,350 --> 00:22:37,020
停留在第一种状态 它没有双圈

465
00:22:37,020 --> 00:22:39,300
并且因此不是接受状态 则计算机

466
00:22:39,300 --> 00:22:42,810
这是一个无效的电子邮件地址 

467
00:22:42,810 --> 00:22:45,630
相比之下 如果我们回到我的另一个版本 

468
00:22:45,630 --> 00:22:49,800
我在代码的左右两边都用了点+ 

469
00:22:49,800 --> 00:22:53,130
回想一下 re.search将使用其中一个状态机

470
00:22:53,130 --> 00:22:57,030
为了从左到右决定是否接受用户的

471
00:22:57,030 --> 00:22:59,310
输入 如malan@harvard.edu 

472
00:22:59,310 --> 00:23:02,850
我们能从开始状态 到接受状态吗

473
00:23:02,850 --> 00:23:05,940
来决定 对 这其实是符合规律的 

474
00:23:05,940 --> 00:23:09,900
好吧 让我们假设这个不确定的有限自动机

475
00:23:09,900 --> 00:23:11,430
看起来像这样

476
00:23:11,430 --> 00:23:14,310
我们将从最左边的开始状态开始 

477
00:23:14,310 --> 00:23:18,180
我们必须在第一条边上使用一个字符 

478
00:23:18,180 --> 00:23:21,480
它用一个点标记 表示我们可以使用任何一个字符 

479
00:23:21,480 --> 00:23:24,411
比如malan@harvard.edu中的m 

480
00:23:24,411 --> 00:23:27,960
然后我们可以花一些时间在@符号之前消耗更多的字符 

481
00:23:27,960 --> 00:23:31,290
所以A-L-A-N

482
00:23:31,290 --> 00:23:33,340
然后我们可以使用@符号 

483
00:23:33,340 --> 00:23:36,270
那么我们至少可以多消耗一个角色 因为回忆一下

484
00:23:36,270 --> 00:23:38,760
正则表达式这次有点加号

485
00:23:38,760 --> 00:23:42,190
如果我们愿意的话 我们可以使用更多的字符 

486
00:23:42,190 --> 00:23:45,900
所以如果我们首先在harvard.edu中使用H 

487
00:23:45,900 --> 00:23:53,885
然后留下A-R-V-A-R-D 然后点E-D-U

488
00:23:53,885 --> 00:23:56,560
现在我们也到了故事的结尾

489
00:23:56,560 --> 00:23:59,760
但我们处于接受状态 因为最后的圆圈

490
00:23:59,760 --> 00:24:03,840
一共有两个圆 这意味着如果计算机 如果这个函数 

491
00:24:03,840 --> 00:24:07,830
在读取了用户的全部

492
00:24:07,830 --> 00:24:11,580
实际上 它也是一个有效的电子邮件地址 

493
00:24:11,580 --> 00:24:15,390
如果相反 我们被困在另一个州 

494
00:24:15,390 --> 00:24:18,180
无法跟随一个过渡 其中一个边缘 

495
00:24:18,180 --> 00:24:22,440
并且因此不能在用户的输入中从左到右取得进展 

496
00:24:22,440 --> 00:24:26,670
那么我们将不得不得出结论 电子邮件地址实际上是无效的 

497
00:24:26,670 --> 00:24:29,490
那么 我们如何才能进一步批准这个代码呢？

498
00:24:29,490 --> 00:24:33,660
现在让我提议 我们不仅要检查用户名 还要检查一些

499
00:24:33,660 --> 00:24:37,320
在用户名之后 类似于域名 但最低要求字符串

500
00:24:37,320 --> 00:24:39,600
也以.edu结尾 

501
00:24:39,600 --> 00:24:41,970
嗯 我想我可以很直接地这样做 

502
00:24:41,970 --> 00:24:44,940
我不仅希望在@符号之后有一些东西 

503
00:24:44,940 --> 00:24:49,818
就像哈佛这样的域名一样 我希望整件事以.edu结尾 

504
00:24:49,818 --> 00:24:52,320
但这里有一点危险 

505
00:24:52,320 --> 00:24:57,660
现在以这种方式实现我的正则表达式 我做错了什么

506
00:24:57,660 --> 00:24:59,110
通过使用.+@.+.edu？

507
00:25:01,938 --> 00:25:06,080
这个版本可能会出什么问题？

508
00:25:06,080 --> 00:25:08,360
观众：这个圆点--这个圆点意味着什么

509
00:25:08,360 --> 00:25:11,510
否则在本文中 它意味着三次或三次以上的重复

510
00:25:11,510 --> 00:25:14,630
这就是为什么它会解释它[INAUDIBLE]..

511
00:25:14,630 --> 00:25:15,570
大卫·马兰：没错 

512
00:25:15,570 --> 00:25:19,340
尽管我的意思是字面意思是.edu 一个句号 

513
00:25:19,340 --> 00:25:22,560
然后是.edu 不幸的是 在正则表达式世界中 

514
00:25:22,560 --> 00:25:26,720
点表示任何字符 这意味着从技术上讲 该字符串可以结束

515
00:25:26,720 --> 00:25:34,080
在埃杜 或贝杜 或雪松 等等 但这并不是 事实上 我想要的 

516
00:25:34,080 --> 00:25:37,670
那么 我现在对如何解决这个问题有什么直觉吗？

517
00:25:37,670 --> 00:25:39,770
让我更清楚地说明这个问题 

518
00:25:39,770 --> 00:25:41,900
让我继续在这里运行这段代码 

519
00:25:41,900 --> 00:25:45,050
让我继续输入Malan@greavard.edu 

520
00:25:45,050 --> 00:25:47,240
而且一如既往 这确实奏效了 

521
00:25:47,240 --> 00:25:48,680
但看看这里会发生什么 

522
00:25:48,680 --> 00:25:52,520
让我继续做马兰@哈佛 然后--

523
00:25:52,520 --> 00:25:57,992
马兰@哈佛？埃杜 输入 这也是有效的 

524
00:25:57,992 --> 00:26:00,950
所以我可以把任何角色放在那里 它仍然会被接受 

525
00:26:00,950 --> 00:26:02,420
但我不想要？埃杜 

526
00:26:02,420 --> 00:26:04,670
我想要.EDU字面意思 

527
00:26:04,670 --> 00:26:08,700
那么 对于我们如何在这里解决这个问题 你有什么直觉吗？

528
00:26:08,700 --> 00:26:12,770
我如何才能获得这个新函数re.earch和正则表达式

529
00:26:12,770 --> 00:26:16,160
更笼统地说 字面意思是一个点 你觉得呢？

530
00:26:16,160 --> 00:26:19,257
观众：你可以用转义字符 反斜杠？

531
00:26:19,257 --> 00:26:20,090
大卫·马兰：确实如此 

532
00:26:20,090 --> 00:26:22,927
所谓的逃逸角色 我们以前在外面见过

533
00:26:22,927 --> 00:26:25,760
正则表达式的上下文 当我们讨论换行符时 

534
00:26:25,760 --> 00:26:29,640
反斜杠n是一种告诉计算机我需要换行符的方式 

535
00:26:29,640 --> 00:26:32,810
但实际上并没有真正地按下Enter键并亲自移动光标 

536
00:26:32,810 --> 00:26:35,090
你不会想在屏幕上出现文字n的 

537
00:26:35,090 --> 00:26:39,350
因此 反斜杠n是转义n并表示您需要换行符的一种方式 

538
00:26:39,350 --> 00:26:41,900
事实证明 正则表达式使用类似的技术

539
00:26:41,900 --> 00:26:43,640
在这里解决这个问题 

540
00:26:43,640 --> 00:26:45,770
事实上 让我来看看我的正则表达式 

541
00:26:45,770 --> 00:26:49,370
在最后一个点之前 让我加一个反斜杠 

542
00:26:49,370 --> 00:26:52,880
在正则表达式的世界中 这是一个所谓的特殊序列 

543
00:26:52,880 --> 00:26:55,940
它表明 根据这个反斜杠和一个单点 

544
00:26:55,940 --> 00:26:58,290
我真的想要在一个点上匹配 

545
00:26:58,290 --> 00:27:02,180
这并不是说我想要匹配任何角色 然后就是edu 

546
00:27:02,180 --> 00:27:05,300
我想匹配一个点 或一个句点 edu 

547
00:27:05,300 --> 00:27:09,050
但是我们不希望Python曲解这个反斜杠

548
00:27:09,050 --> 00:27:12,710
作为转义序列的开始 一些特殊的东西 如反斜杠

549
00:27:12,710 --> 00:27:15,590
N 即使我们作为程序员可能会键入两个字符

550
00:27:15,590 --> 00:27:20,090
反斜杠n 它实际上被Python解释为一个换行符 

551
00:27:20,090 --> 00:27:22,833
我们不希望在这里出现任何类似的误解 

552
00:27:22,833 --> 00:27:26,000
因此 对于正则表达式 我们还应该做另一件事

553
00:27:26,000 --> 00:27:29,180
像这样有一个反斜杠是这样用的 

554
00:27:29,180 --> 00:27:33,440
我想向Python指定我想要这个字符串、这个正则表达式

555
00:27:33,440 --> 00:27:36,200
在双引号中 将被视为原始字符串 

556
00:27:36,200 --> 00:27:38,510
字面意思是将r放在字符串的开头

557
00:27:38,510 --> 00:27:41,240
向Python指示您不应尝试解释

558
00:27:41,240 --> 00:27:43,550
以常规方式添加任何反斜杠 

559
00:27:43,550 --> 00:27:46,850
我想按字面意思传递反斜杠、点和edu

560
00:27:46,850 --> 00:27:50,030
进入这个特殊的功能 搜索 在本例中 

561
00:27:50,030 --> 00:27:53,750
因此它在本质上类似于在格式开头使用f

562
00:27:53,750 --> 00:27:57,170
字符串 当然 它告诉Python以某种方式格式化字符串 

563
00:27:57,170 --> 00:27:59,720
插入可能在大括号之间的变量 

564
00:27:59,720 --> 00:28:02,900
但在本例中 r表示原始字符串

565
00:28:02,900 --> 00:28:05,570
我想要完全按照原样传递 

566
00:28:05,570 --> 00:28:09,380
现在 只有在使用反斜杠的情况下 才有必要这样做

567
00:28:09,380 --> 00:28:12,860
表示您需要一些特殊的序列 如反斜杠圆点 

568
00:28:12,860 --> 00:28:14,750
但总的来说 这可能是一个好习惯

569
00:28:14,750 --> 00:28:18,540
了解如何只对所有正则表达式使用原始字符串

570
00:28:18,540 --> 00:28:21,480
所以如果你最终回到里面 做一些改变 增加一些东西 

571
00:28:21,480 --> 00:28:23,600
您不会意外地引入反斜杠

572
00:28:23,600 --> 00:28:28,113
然后忘记这可能有一些特殊的或被误解的意思 

573
00:28:28,113 --> 00:28:30,530
好了 让我们继续尝试这个新的正则表达式 

574
00:28:30,530 --> 00:28:34,430
我将清除我的终端窗口 运行VALIDATE--

575
00:28:34,430 --> 00:28:36,800
运行valiate.py的python 

576
00:28:36,800 --> 00:28:40,496
然后我会正确地输入我的电子邮件地址：Malan@atherard.edu 

577
00:28:40,496 --> 00:28:42,710
幸运的是 这一点仍然有效 

578
00:28:42,710 --> 00:28:46,490
让我清空屏幕并再次运行一次 即valiate.py的python 

579
00:28:46,490 --> 00:28:50,930
这一次 让我们把它错误地输入为Malan@Harvard？Edu 

580
00:28:50,930 --> 00:28:53,540
很明显那里没有一个圆点 

581
00:28:53,540 --> 00:28:57,710
但上一次还有其他一些单字被曲解了

582
00:28:57,710 --> 00:28:58,430
是有效的 

583
00:28:58,430 --> 00:29:01,970
但这一次 既然我已经改进了正则表达式 

584
00:29:01,970 --> 00:29:05,270
它被发现确实是无效的 

585
00:29:05,270 --> 00:29:10,850
现在对@左边的匹配技巧有什么疑问吗？

586
00:29:10,850 --> 00:29:15,320
签名 右边的东西 现在明确地以.edu结尾？

587
00:29:15,320 --> 00:29:18,582
观众：当用户插入多个@符号时会发生什么？

588
00:29:18,582 --> 00:29:19,790
大卫·马兰：问得好 

589
00:29:19,790 --> 00:29:21,320
你把我叫到了这里 

590
00:29:21,320 --> 00:29:22,910
好吧 如果有疑问 让我们试一试 

591
00:29:22,910 --> 00:29:29,340
让我继续执行validate.py、Malan@atherard.edu、

592
00:29:29,340 --> 00:29:34,020
这也是不正确的 不幸的是 我的代码认为它是有效的 

593
00:29:34,020 --> 00:29:37,490
因此 这是另一个需要解决的问题 但目前还存在不足 

594
00:29:37,490 --> 00:29:41,510
到目前为止 关于这些正则表达式还有其他问题吗？

595
00:29:41,510 --> 00:29:46,108
观众：你能用大括号m代替反斜杠吗？

596
00:29:46,108 --> 00:29:48,650
大卫·马兰：你能用大括号代替反斜杠吗？

597
00:29:48,650 --> 00:29:49,490
在这种情况下不是这样 

598
00:29:49,490 --> 00:29:53,750
如果你想要一个字面点 反斜线点是字面上的方法 

599
00:29:53,750 --> 00:29:56,660
关于正则表达式的另一个问题如何？

600
00:29:56,660 --> 00:30:00,620
观众：这和Google Forms用来订购的东西是一样的吗

601
00:30:00,620 --> 00:30:06,590
为了将数据分类 假设是一些--如果您有多个人发送

602
00:30:06,590 --> 00:30:09,380
关于一些反馈的请求？

603
00:30:09,380 --> 00:30:12,170
他们是否对他们获得的数据进行分类

604
00:30:12,170 --> 00:30:14,247
使用这个特殊的正则表达式吗？

605
00:30:14,247 --> 00:30:15,080
大卫·马兰：确实如此 

606
00:30:15,080 --> 00:30:17,450
如果你曾经使用过谷歌表格 而不仅仅是提交它

607
00:30:17,450 --> 00:30:20,900
但要创建Google表单 菜单选项之一

608
00:30:20,900 --> 00:30:23,570
是为了响应验证 至少在英语中是这样 

609
00:30:23,570 --> 00:30:25,340
这样做的目的是指定

610
00:30:25,340 --> 00:30:29,060
用户必须输入电子邮件地址或URL 

611
00:30:29,060 --> 00:30:31,400
或者一根有一定长度的绳子 

612
00:30:31,400 --> 00:30:33,830
但还有一个更强大的功能 你们中的一些人

613
00:30:33,830 --> 00:30:35,150
可能从来没有注意到 

614
00:30:35,150 --> 00:30:37,340
事实上 如果你想打开谷歌表格 

615
00:30:37,340 --> 00:30:41,180
临时创建一个新的表单 然后四处查看 您将真正看到 

616
00:30:41,180 --> 00:30:44,270
至少在英语中 引号 不引号“Regular Expression”

617
00:30:44,270 --> 00:30:46,070
提到的一种机制 您可以

618
00:30:46,070 --> 00:30:49,520
用于验证用户对您的Google表单的输入 

619
00:30:49,520 --> 00:30:53,690
因此 事实上 从今天开始 您可以开始避免特定的下拉列表

620
00:30:53,690 --> 00:30:55,610
类似的电子邮件地址或URL等 

621
00:30:55,610 --> 00:30:59,540
你也可以准确地表达你自己的模式 

622
00:30:59,540 --> 00:31:02,900
正则表达式甚至可以在VS代码本身中使用 

623
00:31:02,900 --> 00:31:06,440
如果您在VS代码中查找或执行查找和替换 

624
00:31:06,440 --> 00:31:08,690
当然 您可以像您所能做的那样 只需输入单词

625
00:31:08,690 --> 00:31:10,880
到Microsoft Word或Google Docs 

626
00:31:10,880 --> 00:31:14,990
如果选中正确的框 您还可以键入正则表达式

627
00:31:14,990 --> 00:31:19,670
并开始寻找模式 而不是字面上的具体值 

628
00:31:19,670 --> 00:31:24,080
好吧 让我建议我们现在进一步加强这个实现

629
00:31:24,080 --> 00:31:28,010
通过引入一些其他的符号 因为现在我的代码 

630
00:31:28,010 --> 00:31:32,540
我一直说我希望我的电子邮件地址以.edu结尾 以.edu开头 

631
00:31:32,540 --> 00:31:35,780
一个用户名但我有点太慷慨了

632
00:31:35,780 --> 00:31:38,690
事实上 这对我自己的电子邮件地址来说是正常的 

633
00:31:38,690 --> 00:31:40,928
malan@harvard.edu.

634
00:31:40,928 --> 00:31:45,350
但是如果我输入一个句子 比如“我的电子邮件地址

635
00:31:45,350 --> 00:31:50,180
是malan@harvard.edu ”假设我已经把它输入到程序中 

636
00:31:50,180 --> 00:31:52,310
或者我已经把它输入到谷歌表单里了

637
00:31:52,310 --> 00:31:57,680
这将被视为有效或无效？

638
00:31:57,680 --> 00:31:59,390
好吧 让我们考虑一下 

639
00:31:59,390 --> 00:32:01,970
它有@符号 所以我们很好 

640
00:32:01,970 --> 00:32:05,570
它在@符号的左边有一个或多个字符 

641
00:32:05,570 --> 00:32:09,050
它在@符号的右边有一个或多个字符 

642
00:32:09,050 --> 00:32:14,390
在@符号的右边有一个文字.edu 

643
00:32:14,390 --> 00:32:16,460
当然 右边有更多的东西 

644
00:32:16,460 --> 00:32:19,700
在我的英语句子的末尾有一个句号 

645
00:32:19,700 --> 00:32:23,600
但这没关系 因为目前 我的正则表达式不是那么精确

646
00:32:23,600 --> 00:32:29,156
也就是说 模式必须以用户名开始 以. edu结束 

647
00:32:29,156 --> 00:32:32,573
从技术上讲 它的左可以说什么更多

648
00:32:32,573 --> 00:32:33,990
还有什么可以向右 

649
00:32:33,990 --> 00:32:37,970
所以当我按回车键的时候 你会看到整个英文句子

650
00:32:37,970 --> 00:32:40,500
是有效的 这显然不是你想要的

651
00:32:40,500 --> 00:32:43,430
事实上 考虑使用Google Forms或Office的情况

652
00:32:43,430 --> 00:32:45,620
365收集用户的数据 

653
00:32:45,620 --> 00:32:48,320
如果不验证输入 用户

654
00:32:48,320 --> 00:32:51,170
可能会输入一个完整的句子或其他东西

655
00:32:51,170 --> 00:32:53,550
只是一个印刷错误而不是一封真正的邮件

656
00:32:53,550 --> 00:32:55,993
所以如果你只是想复制所有的结果

657
00:32:55,993 --> 00:32:58,160
已输入到您的表单中 以便您可以粘贴它们

658
00:32:58,160 --> 00:33:00,767
Gmail或其他电子邮件程序 它会崩溃 

659
00:33:00,767 --> 00:33:04,100
因为你会不小心把一整句英语

660
00:33:04,100 --> 00:33:07,010
而不仅仅是一个电子邮件地址 

661
00:33:07,010 --> 00:33:08,690
这是你的邮件期望 

662
00:33:08,690 --> 00:33:10,280
我怎么才能更精确呢？

663
00:33:10,280 --> 00:33:13,550
好吧 让我提议我们再引入一些符号 

664
00:33:13,550 --> 00:33:17,540
在正则表达式的上下文中 这些模式之一 

665
00:33:17,540 --> 00:33:21,170
你可以用这个插入符号 这个小三角形标记 

666
00:33:21,170 --> 00:33:24,080
来表示你想让这个图案

667
00:33:24,080 --> 00:33:27,110
字符串的开头--不是任何地方

668
00:33:27,110 --> 00:33:29,330
而是用户字符串的开头 

669
00:33:29,330 --> 00:33:34,040
相比之下 您可以在正则表达式中使用$符号表示您

670
00:33:34,040 --> 00:33:37,790
我想匹配字符串的结尾 或者技术上来说就在换行符之前

671
00:33:37,790 --> 00:33:38,910
在字符串的末尾 

672
00:33:38,910 --> 00:33:41,810
但出于所有意图和目的 请将插入符号视为“开始”的意思

673
00:33:41,810 --> 00:33:45,650
字符串”和$符号表示“字符串结束” “

674
00:33:45,650 --> 00:33:49,310
这是一个奇怪的事情 一个是插入符号 一个是$符号 

675
00:33:49,310 --> 00:33:51,710
这些并不是我认为是对立的东西 

676
00:33:51,710 --> 00:33:53,670
比如括号之类的

677
00:33:53,670 --> 00:33:56,430
但这些是世界多年前选择的象征 

678
00:33:56,430 --> 00:33:58,370
现在让我们回到VS Code 

679
00:33:58,370 --> 00:34:01,460
让我把这个特性添加到我的代码中 

680
00:34:01,460 --> 00:34:04,790
让我指定 是的 我确实想搜索这个模式 

681
00:34:04,790 --> 00:34:08,480
但我希望用户的输入以这种模式开始

682
00:34:08,480 --> 00:34:09,860
以这种模式结束 

683
00:34:09,860 --> 00:34:12,440
所以即使它开始看起来更加神秘 

684
00:34:12,440 --> 00:34:14,690
我在开头放了一个插入符号 

685
00:34:14,690 --> 00:34:17,270
我在最后放了个$

686
00:34:17,270 --> 00:34:21,199
这并不意味着我希望用户键入插入符号或$符号 

687
00:34:21,199 --> 00:34:25,130
这是一种特殊的符号系统 表示re.search

688
00:34:25,130 --> 00:34:29,280
它现在应该只寻找与这个模式完全匹配的 

689
00:34:29,280 --> 00:34:31,699
如果我现在回到终端窗口

690
00:34:31,699 --> 00:34:33,920
我会把之前的结果留在屏幕上

691
00:34:33,920 --> 00:34:35,540
让我输入同样的内容

692
00:34:35,540 --> 00:34:39,610
“我的电子邮件地址malan@harvard.edu” 输入--

693
00:34:39,610 --> 00:34:41,000
抱歉 句号 

694
00:34:41,000 --> 00:34:43,070
现在我要按回车键了

695
00:34:43,070 --> 00:34:45,770
现在这被认为是无效的 

696
00:34:45,770 --> 00:34:47,090
但让我把屏幕清空 

697
00:34:47,090 --> 00:34:48,923
为了确保我没有弄坏东西 

698
00:34:48,923 --> 00:34:53,330
让我只输入我的电子邮件地址 这也是有效的 

699
00:34:53,330 --> 00:34:58,250
现在关于我的正则表达式的这个版本的任何问题 请注意 

700
00:34:58,250 --> 00:35:01,670
更进一步 甚至更精确地指定

701
00:35:01,670 --> 00:35:06,120
我希望它在开始和结束时都是匹配的？

702
00:35:06,120 --> 00:35:08,568
对这个有什么问题吗？

703
00:35:08,568 --> 00:35:09,110
观众：好的 

704
00:35:09,110 --> 00:35:13,160
你有斜杠 .edu 然后是$符号 

705
00:35:13,160 --> 00:35:18,170
但是点是正则表达式中的一个 对吗？

706
00:35:18,170 --> 00:35:19,460
大卫·马兰：通常是这样的 

707
00:35:19,460 --> 00:35:24,590
但我在这里之前故意加的这个反斜杠

708
00:35:24,590 --> 00:35:26,180
是一个逃逸的角色 

709
00:35:26,180 --> 00:35:30,710
这是一种告诉re.earch我不想要任何字符的方式 

710
00:35:30,710 --> 00:35:33,140
我真的想在那里待上一段时间 

711
00:35:33,140 --> 00:35:36,080
这是你区分它们的唯一方法 

712
00:35:36,080 --> 00:35:40,550
如果我去掉那个斜杠 这将意味着电子邮件地址

713
00:35:40,550 --> 00:35:43,610
必须以任何字符结尾 然后是E 然后是D 

714
00:35:43,610 --> 00:35:45,180
而不是U 我不想那样 

715
00:35:45,180 --> 00:35:49,730
我想要一个句点 然后是E 然后是D 然后是U 

716
00:35:49,730 --> 00:35:53,780
这实际上是一般编程和技术中的常见约定 

717
00:35:53,780 --> 00:35:55,820
如果你和我决定一个大会 

718
00:35:55,820 --> 00:35:59,180
我们正在使用键盘上的一些字符来表示一些特殊的东西 

719
00:35:59,180 --> 00:36:02,060
我们总是给自己制造未来的问题

720
00:36:02,060 --> 00:36:04,820
当我们想要字面上使用相同的字符 

721
00:36:04,820 --> 00:36:07,190
因此 这个问题的总体解决方案

722
00:36:07,190 --> 00:36:10,790
就是以某种方式逃避角色 这样计算机就能清楚地看到

723
00:36:10,790 --> 00:36:14,510
它不是那个特殊的符号 而是它所看到的符号 

724
00:36:14,510 --> 00:36:19,700
观众：所以我们甚至不知道--我们不需要在美元之前再进行一次削减

725
00:36:19,700 --> 00:36:20,930
签字？

726
00:36:20,930 --> 00:36:22,150
大卫·马兰：没有 

727
00:36:22,150 --> 00:36:25,550
因为在这种情况下 $sign意味着一些特别的东西 

728
00:36:25,550 --> 00:36:30,590
根据这张图表 $符号本身并不意味着美元或货币 

729
00:36:30,590 --> 00:36:33,420
字面意思是“匹配字符串的末尾” 

730
00:36:33,420 --> 00:36:38,600
但是 如果我想让用户直接在结尾处键入$sign

731
00:36:38,600 --> 00:36:40,910
对于他们的投入 解决方案将是相同的 

732
00:36:40,910 --> 00:36:43,700
我会在$符号前加一个反斜杠 

733
00:36:43,700 --> 00:36:48,242
也就是说 我的电子邮件地址必须是类似maran@atherard.edu的地址

734
00:36:48,242 --> 00:36:50,850
$符号 这显然也是不正确的 

735
00:36:50,850 --> 00:36:55,280
所以反斜杠只是允许你告诉计算机不要处理

736
00:36:55,280 --> 00:36:58,310
特别是那些符号 喜欢表达特殊的意思 

737
00:36:58,310 --> 00:37:00,950
而是逐字逐句地对待他们 

738
00:37:00,950 --> 00:37:04,550
这里还有一个关于正则表达式的问题怎么样？

739
00:37:04,550 --> 00:37:09,010
观众：你说过一代表加一 

740
00:37:09,010 --> 00:37:11,095
然后你说一个是让它一无所有 

741
00:37:11,095 --> 00:37:11,845
大卫·马兰：当然 

742
00:37:11,845 --> 00:37:13,220
观众：那你为什么要加上加号呢？

743
00:37:13,220 --> 00:37:14,360
大卫·马兰：让我时光倒流 

744
00:37:14,360 --> 00:37:17,027
我想你指的是我们早期的一个版本

745
00:37:17,027 --> 00:37:20,360
这最初看起来是这样的 这只是意味着零或更多

746
00:37:20,360 --> 00:37:24,710
字符 而不是@符号 然后是零个或多个其他字符 

747
00:37:24,710 --> 00:37:29,090
然后我们进化成这样 两边都有点加 这

748
00:37:29,090 --> 00:37:31,340
表示左侧的一个或多个字符 则

749
00:37:31,340 --> 00:37:34,320
@符号 然后是右侧的一个或多个字符 

750
00:37:34,320 --> 00:37:36,560
如果我对你的问题的理解正确的话 

751
00:37:36,560 --> 00:37:40,370
我之前提到的一点是 如果不使用加号或忘记

752
00:37:40,370 --> 00:37:44,510
它的存在 你可以用两个相同的结果

753
00:37:44,510 --> 00:37:48,380
点和* 因为第一个点表示任何字符--

754
00:37:48,380 --> 00:37:49,550
它肯定在那里--

755
00:37:49,550 --> 00:37:54,170
第二个点*表示零个或多个其他字符 

756
00:37:54,170 --> 00:37:55,380
右边也一样 

757
00:37:55,380 --> 00:37:57,950
所以这只是表达相同观点的另一种方式 

758
00:37:57,950 --> 00:38:01,970
“一个或多个”可以这样用点*表示 

759
00:38:01,970 --> 00:38:06,840
或者 您可以使用更方便的点+语法 它的意思是相同的 

760
00:38:06,840 --> 00:38:07,340
好的 

761
00:38:07,340 --> 00:38:10,507
所以我敢说 这个正则表达式仍然存在一些问题

762
00:38:10,507 --> 00:38:13,790
当前表单 因为即使现在我们开始寻找用户

763
00:38:13,790 --> 00:38:16,010
来自用户的字符串开头的名称 

764
00:38:16,010 --> 00:38:20,390
我们要从字面上寻找用户字符串末尾的.edu 

765
00:38:20,390 --> 00:38:23,780
这些点现在有点太笼统了 

766
00:38:23,780 --> 00:38:26,450
我被允许输入不止一个@符号 

767
00:38:26,450 --> 00:38:27,020
为什么？

768
00:38:27,020 --> 00:38:30,720
因为@是一个字符 点表示任何字符 

769
00:38:30,720 --> 00:38:34,650
所以老实说 我现在可以在这件事上想要多少@符号就有多少 

770
00:38:34,650 --> 00:38:37,280
例如 如果我运行valiate.py的python 

771
00:38:37,280 --> 00:38:40,500
Maran@atherard.edu仍然像预期的那样工作 

772
00:38:40,500 --> 00:38:44,270
但是 如果我还运行validate.py的python 并且不正确地这样做

773
00:38:44,270 --> 00:38:51,030
应该是无效的 但它被认为是有效的 

774
00:38:51,030 --> 00:38:55,670
因此 我认为当涉及到那个点时 我们需要更多地限制 

775
00:38:55,670 --> 00:38:59,180
我们不能只说 哦 任何一个老角色都很好 

776
00:38:59,180 --> 00:39:00,950
我们需要更具体一些 

777
00:39:00,950 --> 00:39:05,390
事实证明 正则表达式也支持这种语法 

778
00:39:05,390 --> 00:39:08,990
您可以在图案内使用方括号 

779
00:39:08,990 --> 00:39:14,210
在这些方括号内包括一个或多个字符

780
00:39:14,210 --> 00:39:17,000
你想要特别寻找的东西 

781
00:39:17,000 --> 00:39:20,510
或者 您可以在这些方括号内

782
00:39:20,510 --> 00:39:23,660
加一个插入符号 不幸的是 在这里 

783
00:39:23,660 --> 00:39:27,150
意思与“匹配字符串的开头”完全不同 

784
00:39:27,150 --> 00:39:30,870
但这将是方括号内的补码运算符 

785
00:39:30,870 --> 00:39:34,320
这意味着“你不能匹配这些字符中的任何一个 ”

786
00:39:34,320 --> 00:39:36,980
因此 事情现在看起来更神秘了 

787
00:39:36,980 --> 00:39:41,000
但这就是为什么我们在这里关注正则表达式本身的原因 

788
00:39:41,000 --> 00:39:46,850
如果我不想允许任何字符 这就是点 让我继续

789
00:39:46,850 --> 00:39:52,610
我可以说 我只想支持A、B、C或D 

790
00:39:52,610 --> 00:39:54,200
或者ES 或者F 或者Gs 

791
00:39:54,200 --> 00:39:56,750
我可以在这里输入整个字母表 外加一些数字

792
00:39:56,750 --> 00:40:00,110
将我想要允许的所有字母都包括在内 

793
00:40:00,110 --> 00:40:02,570
但老实说 这样会更简单一些 

794
00:40:02,570 --> 00:40:09,020
我可以使用^符号 然后使用@符号 这样做的效果是 

795
00:40:09,020 --> 00:40:14,270
这是一组字符 除了@符号外 其他字符都有 

796
00:40:14,270 --> 00:40:16,130
我在这里也可以做同样的事情 

797
00:40:16,130 --> 00:40:23,270
我可以做左方括号^ @符号 而不是@符号右边的圆点 

798
00:40:23,270 --> 00:40:26,390
我承认 这里的局势开始迅速升级 

799
00:40:26,390 --> 00:40:28,940
但让我们从左边开始 再到右边

800
00:40:28,940 --> 00:40:33,020
在字符串开头的方括号外 

801
00:40:33,020 --> 00:40:35,810
与前面一样 表示“从字符串的开头匹配” “

802
00:40:35,810 --> 00:40:36,890
让我们跳到前面 

803
00:40:36,890 --> 00:40:40,580
正则表达式末尾的$符号表示“匹配

804
00:40:40,580 --> 00:40:42,180
在字符串的末尾 “

805
00:40:42,180 --> 00:40:45,290
所以如果我们能在心里把这些简单明了地勾出来 

806
00:40:45,290 --> 00:40:47,630
现在把注意力集中在中间的其他东西上 

807
00:40:47,630 --> 00:40:50,510
左边是新的语法

808
00:40:50,510 --> 00:40:56,840
一个方括号 另一个^ 一个@符号和一个封闭的方括号 然后

809
00:40:56,840 --> 00:40:57,560
a +.

810
00:40:57,560 --> 00:40:59,780
“+”的意思和往常一样 

811
00:40:59,780 --> 00:41:03,110
意思是“左边的一个或多个东西 “

812
00:41:03,110 --> 00:41:04,830
左边的是什么？

813
00:41:04,830 --> 00:41:06,650
这是新的语法

814
00:41:06,650 --> 00:41:10,880
在方括号里 我有一个^符号和一个@符号 

815
00:41:10,880 --> 00:41:14,990
这意味着除了@符号之外的任何字符 

816
00:41:14,990 --> 00:41:18,890
这是一个奇怪的语法 但这就是我们如何表达这个简单的想法--

817
00:41:18,890 --> 00:41:23,022
键盘上除@符号以外的任何字符 

818
00:41:23,022 --> 00:41:25,980
而且 即使是那些不在你键盘上的字符

819
00:41:25,980 --> 00:41:28,020
但仍然存在

820
00:41:28,020 --> 00:41:32,120
然后我们有一个字面上的@符号 然后我们有另一个同样的东西--

821
00:41:32,120 --> 00:41:36,950
方括号 ^@闭括号 表示除@符号以外的任何字符 

822
00:41:36,950 --> 00:41:42,710
然后是其中的一个或多个 后面跟着一个句号edu 

823
00:41:42,710 --> 00:41:45,960
现在让我再做一次 

824
00:41:45,960 --> 00:41:49,280
让我试试validate.py的python并测试我自己的电子邮件地址

825
00:41:49,280 --> 00:41:51,595
确保我没有把事情搞得更糟

826
00:41:51,595 --> 00:41:52,220
我们很好 

827
00:41:52,220 --> 00:41:55,250
现在让我继续清理屏幕 运行validate.py的python

828
00:41:55,250 --> 00:42:00,750
再次做harvard.edu 这次我交叉手指 

829
00:42:00,750 --> 00:42:03,020
最后 这是无效的 

830
00:42:03,020 --> 00:42:03,830
为什么要这样？

831
00:42:03,830 --> 00:42:08,600
我允许自己在用户输入的中间有一个@符号 

832
00:42:08,600 --> 00:42:13,220
但是按照这个新语法 左边的所有东西都不能是@符号 

833
00:42:13,220 --> 00:42:15,950
它可以是任何东西 但一次或多次 

834
00:42:15,950 --> 00:42:20,570
符号右边的任何东西都可以不是符号

835
00:42:20,570 --> 00:42:25,430
或者更多次 最后是字面上的.edu 

836
00:42:25,430 --> 00:42:27,590
所以 新的语法很简单 就是--

837
00:42:27,590 --> 00:42:31,985
方括号允许您指定一组您按字面意思

838
00:42:31,985 --> 00:42:33,110
在键盘上打字--

839
00:42:33,110 --> 00:42:36,410
A B C D E F 或补语 相反 

840
00:42:36,410 --> 00:42:40,550
^符号 意思是“不” 然后一个或多个符号

841
00:42:40,550 --> 00:42:42,520
想要排除 

842
00:42:42,520 --> 00:42:45,230
这里有关于这个语法的问题吗？

843
00:42:45,230 --> 00:42:49,450
观众：那么 在@sign之后 我们可以用花括号来表示吗

844
00:42:49,450 --> 00:42:52,770
这样我们就只能重复一次@符号了？

845
00:42:52,770 --> 00:42:53,770
大卫·马兰：当然 

846
00:42:53,770 --> 00:42:54,800
所以我们可以这么做 

847
00:42:54,800 --> 00:42:56,680
让我继续下去 开始VS Code 

848
00:42:56,680 --> 00:42:59,680
让我删除正则表达式的当前形式

849
00:42:59,680 --> 00:43:03,580
回到我们开始的地方 那只是点*@和点* 

850
00:43:03,580 --> 00:43:06,130
我完全可以做这样的事

851
00:43:06,130 --> 00:43:10,480
并要求我在这里至少要有一个角色 

852
00:43:10,480 --> 00:43:13,760
然后我可以做更多的事情来拥有更多的东西 

853
00:43:13,760 --> 00:43:16,710
我们在前面的幻灯片中看到了花括号的语法

854
00:43:16,710 --> 00:43:18,460
但还没用过 绝对可以用

855
00:43:18,460 --> 00:43:21,400
若要指定特定的字符数 请执行以下操作 

856
00:43:21,400 --> 00:43:24,160
但老实说 这比必要的更冗长 

857
00:43:24,160 --> 00:43:27,130
最好的解决方案 可以说 或者至少是最简单的 

858
00:43:27,130 --> 00:43:29,500
归根结底 就是点+ 

859
00:43:29,500 --> 00:43:32,650
但是 还有另一个你可以解决同样问题的例子

860
00:43:32,650 --> 00:43:34,010
多方面的 

861
00:43:34,010 --> 00:43:36,340
让我们回到刚才正则表达式所在的位置

862
00:43:36,340 --> 00:43:39,170
并回答其他问题 

863
00:43:39,170 --> 00:43:44,790
关于角色集的问题还是补充集的问题？

864
00:43:44,790 --> 00:43:47,370
观众：那么你能用同样的语法吗？

865
00:43:47,370 --> 00:43:51,780
说你不想让某个特定的字符贯穿整个字符串？

866
00:43:51,780 --> 00:43:52,740
大卫·马兰：你可以 

867
00:43:52,740 --> 00:43:54,600
这将会是--

868
00:43:54,600 --> 00:43:58,530
你完全可以使用相同的字符来排除--

869
00:43:58,530 --> 00:44:01,830
您完全可以使用此语法来排除某个字符

870
00:44:01,830 --> 00:44:03,210
从整个字符串中 

871
00:44:03,210 --> 00:44:05,130
但现在就有点难了 

872
00:44:05,130 --> 00:44:07,530
因为我们仍然需要.edu结尾 

873
00:44:07,530 --> 00:44:10,770
但是 是的 绝对的 

874
00:44:10,770 --> 00:44:12,220
其他问题？

875
00:44:12,220 --> 00:44:16,620
观众：如果用户在开始时输入.edu会发生什么

876
00:44:16,620 --> 00:44:17,632
的字符串？

877
00:44:17,632 --> 00:44:18,840
大卫·马兰：问得好 

878
00:44:18,840 --> 00:44:22,000
如果用户在字符串的开头输入.edu 会发生什么？

879
00:44:22,000 --> 00:44:23,577
让我们回到VS Code 

880
00:44:23,577 --> 00:44:25,660
让我们试着用两种不同的方法来解决这个问题 

881
00:44:25,660 --> 00:44:27,452
首先 让我们看看正则表达式

882
00:44:27,452 --> 00:44:31,080
看看我们是否能推断出这是否是可以容忍的 

883
00:44:31,080 --> 00:44:34,950
根据当前的神秘正则表达式 

884
00:44:34,950 --> 00:44:38,730
我是说你可以有任何字符除了@符号 

885
00:44:38,730 --> 00:44:41,910
所以我可以 可能是教育部的点 

886
00:44:41,910 --> 00:44:44,490
但是我必须有一个@符号 

887
00:44:44,490 --> 00:44:48,940
所以这是行不通的 因为如果我只是输入.edu 

888
00:44:48,940 --> 00:44:51,010
我们不会越过这个限制 

889
00:44:51,010 --> 00:44:53,710
现在让我运行这个程序 

890
00:44:53,710 --> 00:44:55,810
让我按字面意思输入. edu 

891
00:44:55,810 --> 00:44:57,090
这不管用

892
00:44:57,090 --> 00:45:02,505
但是 但是 但是我可以这样做 .edu@. edu 

893
00:45:02,505 --> 00:45:04,140
这也是无效的 

894
00:45:04,140 --> 00:45:07,581
但让我这样做 . edu@something.edu 

895
00:45:10,365 --> 00:45:11,490
那就过去了 

896
00:45:11,490 --> 00:45:13,470
所以现在开始有点奇怪了 

897
00:45:13,470 --> 00:45:15,030
可能有效 也可能无效 

898
00:45:15,030 --> 00:45:18,120
但我认为我们最终也会更精确 

899
00:45:18,120 --> 00:45:21,570
再问一个关于这个正则表达式的问题怎么样

900
00:45:21,570 --> 00:45:23,310
这些集合的互补呢？

901
00:45:23,310 --> 00:45:27,765
观众：我们可以用另一个域名 字符串输入吗？

902
00:45:27,765 --> 00:45:29,640
大卫·马兰：你能用别的域名吗？

903
00:45:29,640 --> 00:45:30,240
当然了

904
00:45:30,240 --> 00:45:32,460
我用我自己的只是为了演示 

905
00:45:32,460 --> 00:45:35,970
但你绝对可以使用任何域或顶级域 

906
00:45:35,970 --> 00:45:38,520
我使用的是.edu 它非常以美国为中心 

907
00:45:38,520 --> 00:45:43,330
但这对任何顶级域都是完全一样的 

908
00:45:43,330 --> 00:45:43,830
好吧

909
00:45:43,830 --> 00:45:47,700
现在让我继续下去 并建议我们改进这个正则表达式

910
00:45:47,700 --> 00:45:50,880
因为如果我在VS Code中再次调用它 

911
00:45:50,880 --> 00:45:53,790
你会发现我还是有点太宽容了

912
00:45:53,790 --> 00:45:58,140
原来对某人的用户名是有一定要求的

913
00:45:58,140 --> 00:46:00,240
和电子邮件地址中的域名 

914
00:46:00,240 --> 00:46:03,840
电子邮件地址可以是什么在世界上有一个官方标准

915
00:46:03,840 --> 00:46:05,670
以及里面可以有哪些角色 

916
00:46:05,670 --> 00:46:09,480
这对所有的角色来说都太过通融了

917
00:46:09,480 --> 00:46:11,710
在这个世界上除了@符号 

918
00:46:11,710 --> 00:46:14,190
所以让我们来缩小一下定义

919
00:46:14,190 --> 00:46:16,110
我们将容忍用户名 

920
00:46:16,110 --> 00:46:19,200
像Gmail这样的公司当然也可以做到这一点 

921
00:46:19,200 --> 00:46:22,200
假设不只是我想要排除@sign 

922
00:46:22,200 --> 00:46:25,470
假设我只想考虑 比方说 

923
00:46:25,470 --> 00:46:27,600
通常出现在单词中的字符 

924
00:46:27,600 --> 00:46:31,500
就像字母表中的字母 从A到Z 无论是大写还是小写 

925
00:46:31,500 --> 00:46:35,520
也许有些数字 见鬼 甚至下划线也可以被允许 

926
00:46:35,520 --> 00:46:38,550
我们可以使用相同的方括号语法

927
00:46:38,550 --> 00:46:41,340
要指定一组字符 请如下所示 

928
00:46:41,340 --> 00:46:44,860
我可以做abc定义--

929
00:46:44,860 --> 00:46:45,360
天哪 

930
00:46:45,360 --> 00:46:46,290
这将耗费很长时间 

931
00:46:46,290 --> 00:46:49,140
我要把字母表中的26个字母全部打出来 

932
00:46:49,140 --> 00:46:50,940
小写和大写都是 

933
00:46:50,940 --> 00:46:52,260
所以让我别再这么做了 

934
00:46:52,260 --> 00:46:53,700
已经有更好的办法了 

935
00:46:53,700 --> 00:46:58,180
如果要在这些方括号中指定字母范围 

936
00:46:58,180 --> 00:47:00,550
实际上 您可以只使用连字符 

937
00:47:00,550 --> 00:47:04,920
如果你真的在这些方括号里做a-z 

938
00:47:04,920 --> 00:47:07,470
计算机会知道你的意思是从a到z 

939
00:47:07,470 --> 00:47:10,620
你不需要打字母表中的26个字母 

940
00:47:10,620 --> 00:47:14,190
如果您还想包含大写字母 只需执行相同的操作 

941
00:47:14,190 --> 00:47:19,440
没有空格 没有逗号 你只需通过大写Z输入a即可 

942
00:47:19,440 --> 00:47:23,880
所以我有一个小连字符 小z 大A连字符

943
00:47:23,880 --> 00:47:26,640
大Z 没有空格 没有逗号 没有分隔符 

944
00:47:26,640 --> 00:47:28,830
您只需不断指定这些范围即可 

945
00:47:28,830 --> 00:47:32,350
如果我还想要数字 我可以做01234--

946
00:47:32,350 --> 00:47:32,850
没有 

947
00:47:32,850 --> 00:47:35,070
您不需要输入所有10位十进制数字 

948
00:47:35,070 --> 00:47:39,070
您也可以使用连字符来表示0到9 

949
00:47:39,070 --> 00:47:41,280
如果您现在想要支持下划线

950
00:47:41,280 --> 00:47:44,280
同样 这在电子邮件地址的用户名中也很常见 

951
00:47:44,280 --> 00:47:48,160
从字面上看 你只需在结尾处输入下划线 

952
00:47:48,160 --> 00:47:51,180
请注意 所有这些字符都在里面

953
00:47:51,180 --> 00:47:55,860
的方括号 这再次意味着这里是一组字符

954
00:47:55,860 --> 00:47:57,180
这是我想允许的 

955
00:47:57,180 --> 00:48:02,100
我没有在整件事的开头使用^符号 

956
00:48:02,100 --> 00:48:05,370
因为我不想补充它--用E来补充它 

957
00:48:05,370 --> 00:48:07,230
而不是用我来恭维--

958
00:48:07,230 --> 00:48:09,940
我不想通过把它变成相反的东西来补充它 

959
00:48:09,940 --> 00:48:13,225
我真的只想接受这些角色 

960
00:48:13,225 --> 00:48:15,600
我将继续在右边做同样的事情 

961
00:48:15,600 --> 00:48:19,530
如果我想要求域名类似

962
00:48:19,530 --> 00:48:22,800
来自这组人物 诚然有点太窄了 

963
00:48:22,800 --> 00:48:25,210
但它现在很熟悉 所以我们就简单点 

964
00:48:25,210 --> 00:48:29,490
我将继续在那里粘贴完全相同的一组字符

965
00:48:29,490 --> 00:48:30,490
往右走 

966
00:48:30,490 --> 00:48:33,600
因此 现在 它的限制要严格得多 

967
00:48:33,600 --> 00:48:36,660
现在 我将继续运行valiate.py的python 

968
00:48:36,660 --> 00:48:39,420
我要测试一下我自己的电子邮件地址 我们还是可以的 

969
00:48:39,420 --> 00:48:42,180
我要清空屏幕 再运行一次 

970
00:48:42,180 --> 00:48:44,520
这一次 它试图打破它 

971
00:48:44,520 --> 00:48:51,270
让我继续做一些事情 比如 david_maran@atherard.edu 

972
00:48:51,270 --> 00:48:54,790
进入 但这也将是有效的 

973
00:48:54,790 --> 00:48:57,330
但如果我再做一件完全错误的事 

974
00:48:57,330 --> 00:49:02,790
就像Malan@atherard.edu一样 这仍然是无效的 

975
00:49:02,790 --> 00:49:03,330
为什么？

976
00:49:03,330 --> 00:49:06,090
因为我的正则表达式当前只允许

977
00:49:06,090 --> 00:49:09,480
对于中间的一个@ 因为所有东西都在左边

978
00:49:09,480 --> 00:49:11,530
必须是字母数字--

979
00:49:11,530 --> 00:49:14,420
字母或数字--或下划线 

980
00:49:14,420 --> 00:49:18,301
同样的东西在右边 后面跟着.edu 

981
00:49:18,301 --> 00:49:20,770
老实说 这是一个正则表达式

982
00:49:20,770 --> 00:49:23,890
你可能养成了在现实世界打字的习惯 

983
00:49:23,890 --> 00:49:27,860
尽管这看起来很神秘 但这是正则表达式的世界 

984
00:49:27,860 --> 00:49:30,560
因此 随着时间的推移 您会越来越熟悉这种语法 

985
00:49:30,560 --> 00:49:32,890
但值得庆幸的是 其中一些模式是

986
00:49:32,890 --> 00:49:36,910
如此常见 以至于有内置的快捷键来表示

987
00:49:36,910 --> 00:49:38,680
一些相同的信息 

988
00:49:38,680 --> 00:49:42,373
这就是说 您不必不断地输入所有的符号

989
00:49:42,373 --> 00:49:45,040
你想要包括的 因为很有可能是其他程序员

990
00:49:45,040 --> 00:49:46,280
也遇到了同样的问题 

991
00:49:46,280 --> 00:49:49,030
因此内置到正则表达式本身

992
00:49:49,030 --> 00:49:51,250
下面是一些您可以使用的其他模式 

993
00:49:51,250 --> 00:49:56,170
事实上 我可以继续下去 去掉这一整套 从a到z

994
00:49:56,170 --> 00:49:59,830
小写 A到Z大写 0到9和一个下划线 

995
00:49:59,830 --> 00:50:03,640
只需将其替换为单个反斜杠w 

996
00:50:03,640 --> 00:50:07,210
在这种情况下 反斜杠w表示“单词字符” 

997
00:50:07,210 --> 00:50:13,330
通常称为字母数字符号或下划线

998
00:50:13,330 --> 00:50:14,052
也是 

999
00:50:14,052 --> 00:50:15,760
我要在这里做同样的事情 

1000
00:50:15,760 --> 00:50:18,310
我将突出显示整组方括号 

1001
00:50:18,310 --> 00:50:21,430
删除它 并将其替换为一个反斜杠w 

1002
00:50:21,430 --> 00:50:23,720
现在我觉得我们正在取得进展 

1003
00:50:23,720 --> 00:50:25,720
因为即使它是神秘的 而且会

1004
00:50:25,720 --> 00:50:29,320
看起来有点神秘--

1005
00:50:29,320 --> 00:50:32,680
尽管现在它看起来会更神秘一点

1006
00:50:32,680 --> 00:50:35,470
它至少开始读起来更友好了一点 

1007
00:50:35,470 --> 00:50:39,160
左边的^表示“从字符串的开头开始匹配” 

1008
00:50:39,160 --> 00:50:42,100
反斜杠w表示“任何单词字符” 

1009
00:50:42,100 --> 00:50:44,140
+的意思是“一个或多个” 

1010
00:50:44,140 --> 00:50:45,370
@字面上的符号 

1011
00:50:45,370 --> 00:50:49,720
然后是另一个单词字符 一个或多个 然后是字面点 然后是

1012
00:50:49,720 --> 00:50:54,200
字面意思是edu 然后在字符串的最末端进行匹配 就是这样 

1013
00:50:54,200 --> 00:50:55,660
因此 还有更多这样的东西 

1014
00:50:55,660 --> 00:50:57,910
我们不会在这里全部使用它们 但这里是

1015
00:50:57,910 --> 00:51:02,950
可以在正则表达式中使用的模式的部分列表 

1016
00:51:02,950 --> 00:51:07,060
第一 任何十进制数字都有反斜杠d “十进制数字”的意思是

1017
00:51:07,060 --> 00:51:08,590
0到9 

1018
00:51:08,590 --> 00:51:12,550
在这里 通常也会这样做 如果你想做相反的事情 

1019
00:51:12,550 --> 00:51:17,020
补码 可以说 你可以做反斜杠大写D 这是

1020
00:51:17,020 --> 00:51:19,480
不是十进制数字的任何数字 

1021
00:51:19,480 --> 00:51:23,990
所以它可能是字母、标点符号 也可能是其他符号 

1022
00:51:23,990 --> 00:51:27,280
同时 反斜杠S表示空格字符 

1023
00:51:27,280 --> 00:51:30,490
比如按一下空格键 或者按键盘上的Tab键 

1024
00:51:30,490 --> 00:51:31,720
那是空格 

1025
00:51:31,720 --> 00:51:35,110
反斜杠大写S是反义词或补语

1026
00:51:35,110 --> 00:51:38,080
任何不是空格的字符 

1027
00:51:38,080 --> 00:51:41,680
我们已经看到 反斜杠w是一个单词字符 以及

1028
00:51:41,680 --> 00:51:43,390
数字和下划线 

1029
00:51:43,390 --> 00:51:45,970
如果你想要与之互补或相反的 

1030
00:51:45,970 --> 00:51:50,950
您可以使用反斜杠大写W来表示除单词字符以外的所有字符 

1031
00:51:50,950 --> 00:51:54,130
再说一次 这些都是常见的模式 想必很多人都是

1032
00:51:54,130 --> 00:51:58,520
使用在过去 它现在被烘焙到正则表达式语法

1033
00:51:58,520 --> 00:52:02,710
这样你就可以更简洁地表达你同样的想法 

1034
00:52:02,710 --> 00:52:05,320
那么 对这种方法有什么问题吗 

1035
00:52:05,320 --> 00:52:12,340
我们现在用反斜杠w来表示我的单词字符？

1036
00:52:12,340 --> 00:52:14,230
观众：所以我想问的是

1037
00:52:14,230 --> 00:52:17,590
这个--实际上是前面的方法 就像方括号的方法 

1038
00:52:17,590 --> 00:52:19,792
我们可以在那里收单子吗？

1039
00:52:19,792 --> 00:52:20,500
大卫·马兰：是的 

1040
00:52:20,500 --> 00:52:21,730
我们很快就会看到这一点 

1041
00:52:21,730 --> 00:52:27,460
但假设你不仅想容忍.edu 而且还想容忍.edu或.com 

1042
00:52:27,460 --> 00:52:28,450
你可以做到的 

1043
00:52:28,450 --> 00:52:32,500
你可以引入圆括号 然后你可以把它们放在一起 

1044
00:52:32,500 --> 00:52:35,470
我可以说com或edu 

1045
00:52:35,470 --> 00:52:40,180
也可以添加一些东西 如在美国 或政府 或网络 

1046
00:52:40,180 --> 00:52:42,670
或其他任何东西 或组织 或诸如此类 

1047
00:52:42,670 --> 00:52:45,190
这里的每一条竖线都意味着一些特别的东西 

1048
00:52:45,190 --> 00:52:46,180
意思是“或”

1049
00:52:46,180 --> 00:52:48,610
而圆括号只是简单地将事物组合在一起 

1050
00:52:48,610 --> 00:52:50,920
形式上 你在这里有这样的语法--

1051
00:52:50,920 --> 00:52:56,530
A或B A或竖线B 意思是“A必须匹配或B必须匹配 ”

1052
00:52:56,530 --> 00:52:59,080
其中A和B可以是您想要的任何其他图案 

1053
00:52:59,080 --> 00:53:01,520
在括号中 您可以将这些内容组合在一起 

1054
00:53:01,520 --> 00:53:05,710
因此 就像数学一样 你可以把想法组合成一个短语

1055
00:53:05,710 --> 00:53:07,600
做这件事或做那件事 

1056
00:53:07,600 --> 00:53:09,970
还有其他语法 我们很快就会看到 

1057
00:53:09,970 --> 00:53:14,750
这里还有关于这些正则表达式和此语法的其他问题吗？

1058
00:53:14,750 --> 00:53:16,990
观众：如果我们在表达式中加入空格呢？

1059
00:53:16,990 --> 00:53:17,740
大卫·马兰：当然 

1060
00:53:17,740 --> 00:53:21,910
所以如果你想在里面加空格 你不能只用反斜杠w 

1061
00:53:21,910 --> 00:53:25,690
因为这只是一个单词字符 它是字母 数字 

1062
00:53:25,690 --> 00:53:27,100
或下划线 

1063
00:53:27,100 --> 00:53:28,580
但你能做到的 

1064
00:53:28,580 --> 00:53:32,170
您可以回到使用方括号的这种方法 

1065
00:53:32,170 --> 00:53:37,120
你可以说a到z 或者A到Z 或者0到9 

1066
00:53:37,120 --> 00:53:40,693
或者下划线 或者我按空格键 一个空格 

1067
00:53:40,693 --> 00:53:43,360
你可以在方括号内放一个空格 

1068
00:53:43,360 --> 00:53:45,700
会让你发现一个空间 

1069
00:53:45,700 --> 00:53:49,420
或者 我仍然可以使用反斜杠w 

1070
00:53:49,420 --> 00:53:51,280
但我可以把它结合起来 

1071
00:53:51,280 --> 00:53:54,700
我可以说 给我一个反斜杠W或反斜杠S 

1072
00:53:54,700 --> 00:53:57,287
因为回想一下 反斜杠s是空格 

1073
00:53:57,287 --> 00:53:58,870
所以它不仅仅是一个空间 

1074
00:53:58,870 --> 00:53:59,770
可能是账单 

1075
00:53:59,770 --> 00:54:02,140
但是把这些放在括号里 

1076
00:54:02,140 --> 00:54:04,060
你可以把左边的东西

1077
00:54:04,060 --> 00:54:07,400
或右边的东西一次或多次 

1078
00:54:07,400 --> 00:54:12,290
关于这些正则表达式的另一个问题怎么样？

1079
00:54:12,290 --> 00:54:13,040
观众：完美 

1080
00:54:13,040 --> 00:54:19,070
所以我想问 反斜杠w中是否包含一个点？

1081
00:54:19,070 --> 00:54:20,730
因为-不 好吧 

1082
00:54:20,730 --> 00:54:24,230
大卫·马兰：不 它只包括字母、数字和下划线 

1083
00:54:24,230 --> 00:54:25,387
到此为止

1084
00:54:25,387 --> 00:54:27,470
观众：我想知道 你举了一个例子 

1085
00:54:27,470 --> 00:54:33,140
开始的时候有空格 比如这是我的邮箱 某某 

1086
00:54:33,140 --> 00:54:35,420
我不认为我们现在的版本

1087
00:54:35,420 --> 00:54:39,110
甚至很久以前就不再接受它了

1088
00:54:39,110 --> 00:54:43,915
这是因为^还是因为别的什么？

1089
00:54:43,915 --> 00:54:47,960
大卫·马兰：不 我之所以在其他英语单词中处理空格 

1090
00:54:47,960 --> 00:54:51,425
当我输入我的电子邮件地址malan@harvard.edu时 

1091
00:54:51,425 --> 00:54:57,380
是因为我们最初使用的是点 * 或点+ 这是任何字符 

1092
00:54:57,380 --> 00:55:01,340
即使在那之后 我们也说了除了“标志”之外的任何话 

1093
00:55:01,340 --> 00:55:02,870
其中包括空格 

1094
00:55:02,870 --> 00:55:08,000
只有一次我开始使用方括号和a到z和

1095
00:55:08,000 --> 00:55:11,210
到9和下划线 我们终于说到重点了吗？

1096
00:55:11,210 --> 00:55:13,040
在那里我们会拒绝空白 

1097
00:55:13,040 --> 00:55:14,970
事实上 我可以在这里运行这个 

1098
00:55:14,970 --> 00:55:18,980
让我来看看VS Code中我的代码的当前版本 它再次使用

1099
00:55:18,980 --> 00:55:21,620
反斜杠w代表单词字符 让

1100
00:55:21,620 --> 00:55:24,860
我运行了valiate.py的python 并错误地键入了一些内容

1101
00:55:24,860 --> 00:55:30,020
就像“我的电子邮件地址是maran@atherard.edu”一样 句号

1102
00:55:30,020 --> 00:55:34,250
我的用户名左侧有空格 现在无效 

1103
00:55:34,250 --> 00:55:36,590
因为空格不是一个单词字符 

1104
00:55:36,590 --> 00:55:39,860
你也会注意到 从技术上讲 我不允许使用圆点 

1105
00:55:39,860 --> 00:55:41,902
你们中的一些人可能会想 等一下 

1106
00:55:41,902 --> 00:55:43,880
我的Gmail地址里有一个圆点 

1107
00:55:43,880 --> 00:55:46,280
这是我们仍然需要解决的问题 

1108
00:55:46,280 --> 00:55:49,160
反斜杠w不是这里的结束 

1109
00:55:49,160 --> 00:55:52,520
它只是让我们表达我们之前的解决方案

1110
00:55:52,520 --> 00:55:54,020
简明扼要一点 

1111
00:55:54,020 --> 00:55:57,260
现在 有一件事我们还没有处理好

1112
00:55:57,260 --> 00:55:59,180
是大写还是小写 

1113
00:55:59,180 --> 00:56:03,200
从技术上讲 反斜杠w可以处理小写字母和大写字母 

1114
00:56:03,200 --> 00:56:06,450
因为它和之前的场景一模一样 

1115
00:56:06,450 --> 00:56:11,670
从小A到小Z 从大A到大Z 但看这个 

1116
00:56:11,670 --> 00:56:14,960
让我继续以我当前的形式运行valiate.py的python 

1117
00:56:14,960 --> 00:56:19,376
就因为我的大写锁钥匙掉了 maran@atherard.edu 

1118
00:56:19,376 --> 00:56:21,080
喊着我的电子邮件地址 

1119
00:56:21,080 --> 00:56:23,640
就马兰而言 一切都会好起来的 

1120
00:56:23,640 --> 00:56:25,940
就哈佛大学而言 一切都会好起来的 

1121
00:56:25,940 --> 00:56:28,790
因为这些字符与反斜杠w匹配 

1122
00:56:28,790 --> 00:56:31,490
不包括小写和大写 

1123
00:56:31,490 --> 00:56:34,310
但我要看到的是残废 

1124
00:56:34,310 --> 00:56:35,210
为什么？

1125
00:56:35,210 --> 00:56:41,670
为什么在这里全部大写的时候 maran@greavard.edu是无效的 

1126
00:56:41,670 --> 00:56:44,195
即使我用的是反斜杠w？

1127
00:56:44,195 --> 00:56:44,820
观众：是的 

1128
00:56:44,820 --> 00:56:50,010
所以您要求的是小写的domain.edu 

1129
00:56:50,010 --> 00:56:52,105
而且你是用大写字母打字的 

1130
00:56:52,105 --> 00:56:52,980
大卫·马兰：没错 

1131
00:56:52,980 --> 00:56:55,980
我用大写字母输入我的电子邮件地址 

1132
00:56:55,980 --> 00:56:57,892
但我在找字面上的“.edu”

1133
00:56:57,892 --> 00:57:00,600
当我看到你们戴着AirPods和你们中的许多人戴着耳机 

1134
00:57:00,600 --> 00:57:03,810
我很抱歉刚才对着我的麦克风大喊大叫来表达这一点 

1135
00:57:03,810 --> 00:57:05,770
但让我们看看我们是否能解决这个问题 

1136
00:57:05,770 --> 00:57:11,925
好吧 如果我在第5行的模式是希望它是小写的 

1137
00:57:11,925 --> 00:57:13,800
事实上 我有几种方法可以解决这个问题 

1138
00:57:13,800 --> 00:57:15,840
一种是我们以前见过的东西 

1139
00:57:15,840 --> 00:57:19,050
我可以强制用户的输入全部为小写 

1140
00:57:19,050 --> 00:57:23,610
我可以把我的第一行的末尾 更低 并实际上强制它

1141
00:57:23,610 --> 00:57:24,480
转换为小写 

1142
00:57:24,480 --> 00:57:26,880
或者 我可以稍晚一点再这样做 

1143
00:57:26,880 --> 00:57:31,050
我可以不传递电子邮件 而是传递电子邮件的小写版本 

1144
00:57:31,050 --> 00:57:33,810
因为电子邮件地址实际上应该不区分大小写 

1145
00:57:33,810 --> 00:57:34,980
因此 这也会奏效 

1146
00:57:34,980 --> 00:57:37,590
但这里还有另一种机制 值得一看 

1147
00:57:37,590 --> 00:57:43,890
事实证明 调用re.earch之前的函数支持、调用

1148
00:57:43,890 --> 00:57:46,800
第三个论点也是 这些所谓的旗帜 

1149
00:57:46,800 --> 00:57:49,170
标志是配置选项 通常

1150
00:57:49,170 --> 00:57:52,290
对于一个函数 这允许您对其进行稍微不同的配置 

1151
00:57:52,290 --> 00:57:55,290
我应该如何开始配置此呼叫

1152
00:57:55,290 --> 00:57:59,910
重新搜索稍微有些不同 因为我目前只通过

1153
00:57:59,910 --> 00:58:00,900
在两次争论中？

1154
00:58:00,900 --> 00:58:04,650
事实证明 您可以传递给此函数的一些标志

1155
00:58:04,650 --> 00:58:05,790
是这些吗 

1156
00:58:05,790 --> 00:58:10,110
事实证明 Python中的正则表达式库 也就是 

1157
00:58:10,110 --> 00:58:14,040
Re 带有一些内置变量 可以说 

1158
00:58:14,040 --> 00:58:16,110
你可以认为是常量的东西 

1159
00:58:16,110 --> 00:58:19,920
有意义的东西重新搜索 

1160
00:58:19,920 --> 00:58:21,760
他们这样做的方式如下 

1161
00:58:21,760 --> 00:58:26,220
如果作为标志re.IGNORECASE传递 re.earch将执行什么操作

1162
00:58:26,220 --> 00:58:28,530
忽略用户输入的大小写 

1163
00:58:28,530 --> 00:58:30,880
它可以是大写、小写、它们的组合 

1164
00:58:30,880 --> 00:58:32,470
这起案件将被忽视 

1165
00:58:32,470 --> 00:58:34,327
它将被冷淡地对待 

1166
00:58:34,327 --> 00:58:36,660
你还可以做其他我们在这里做不到的事情 

1167
00:58:36,660 --> 00:58:40,650
但是 如果您想要处理可能跨越多行的用户输入--

1168
00:58:40,650 --> 00:58:44,040
也许他们输入的不仅仅是一个电子邮件地址 而是一整段

1169
00:58:44,040 --> 00:58:46,410
如果你想匹配不同的行 

1170
00:58:46,410 --> 00:58:48,210
有多行的文本 

1171
00:58:48,210 --> 00:58:52,950
另一个标志是re.MULTILINE 或者re.DOTALL 

1172
00:58:52,950 --> 00:58:57,990
你可以配置这个点 

1173
00:58:57,990 --> 00:59:02,830
除了换行符之外的任何字符 但也可以是任何字符加换行符 

1174
00:59:02,830 --> 00:59:05,850
但现在 让我继续 只是利用这第一个 

1175
00:59:05,850 --> 00:59:13,170
让我向re.search传递第三个参数 即re. IGNORECASE 

1176
00:59:13,170 --> 00:59:15,330
现在让我在不清除

1177
00:59:15,330 --> 00:59:17,670
我的屏幕 python的validate.py 

1178
00:59:17,670 --> 00:59:20,850
让我再次输入所有大写字母 有效地大喊 

1179
00:59:20,850 --> 00:59:25,200
MALAN@HARVARD.EDU 输入 现在它被认为是有效的 

1180
00:59:25,200 --> 00:59:27,690
因为我特别告诉re.search

1181
00:59:27,690 --> 00:59:29,460
忽略输入的大小写 

1182
00:59:29,460 --> 00:59:30,960
在这里也可以 

1183
00:59:30,960 --> 00:59:34,500
为什么我可以使用这种方法而不是调用.lower

1184
00:59:34,500 --> 00:59:35,280
地点？

1185
00:59:35,280 --> 00:59:39,000
呃 如果我不想改变用户的输入 

1186
00:59:39,000 --> 00:59:43,290
我仍然可以不加区分地对待它 

1187
00:59:43,290 --> 00:59:46,140
这个变量本身的值 

1188
00:59:46,140 --> 00:59:51,970
好了 关于电子邮件地址的验证 现在还有什么问题吗？

1189
00:59:51,970 --> 00:59:54,600
观众：所以模式是一个字符串 对吗？

1190
00:59:54,600 --> 00:59:55,800
大卫·马兰：嗯 

1191
00:59:55,800 --> 00:59:57,390
观众：我们可以使用fstring吗？

1192
00:59:57,390 --> 00:59:58,440
大卫·马兰：你可以 

1193
00:59:58,440 --> 01:00:01,780
是的 你可以使用一个fstring 这样你就可以插入 例如 

1194
01:00:01,780 --> 01:00:04,830
变量的值并将其传递给函数 

1195
01:00:04,830 --> 01:00:06,000
其他问题？

1196
01:00:06,000 --> 01:00:10,342
观众：反斜杠w字符 我们可以把它作为用户的输入吗？

1197
01:00:10,342 --> 01:00:11,550
David Malan：技术上是的 

1198
01:00:11,550 --> 01:00:13,440
这不是我们现在要解决的问题

1199
01:00:13,440 --> 01:00:16,530
我们希望用户提供文字输入 比如他们的电子邮件地址 

1200
01:00:16,530 --> 01:00:18,750
不一定是正则表达式 

1201
01:00:18,750 --> 01:00:22,230
但是你可以想象构建一个软件 

1202
01:00:22,230 --> 01:00:25,800
如果他们是更高级的用户 出于某种原因 

1203
01:00:25,800 --> 01:00:27,722
来验证其他的东西

1204
01:00:27,722 --> 01:00:29,430
事实上 这就是Google正在做的事情 

1205
01:00:29,430 --> 01:00:33,630
如果您尝试使用Google Forms并创建一个带有响应验证的表单

1206
01:00:33,630 --> 01:00:37,590
并选择正则表达式 谷歌允许你和我输入

1207
01:00:37,590 --> 01:00:41,530
在我们自己的正则表达式中 这将是一个很好的例子 

1208
01:00:41,530 --> 01:00:42,030
好的 

1209
01:00:42,030 --> 01:00:45,900
好吧 让我提议我们试着解决另一个问题 

1210
01:00:45,900 --> 01:00:51,480
因此 如果我进入与之前相同的版本 现在忽略大小写 

1211
01:00:51,480 --> 01:00:54,100
但我输入了我的另一个电子邮件地址 

1212
01:00:54,100 --> 01:00:56,280
让我继续运行valiate.py的python 

1213
01:00:56,280 --> 01:00:59,580
这一次 让我输入的不是maran@atherard.edu 它

1214
01:00:59,580 --> 01:01:01,920
我主要使用的是另一个电子邮件地址

1215
01:01:01,920 --> 01:01:06,030
我的 maran@cs50.atherard.edu 它转发到相同的 

1216
01:01:06,030 --> 01:01:07,920
现在让我继续按Enter键 

1217
01:01:07,920 --> 01:01:11,940
嗯 无效 尽管我很确定

1218
01:01:11,940 --> 01:01:13,380
实际上 是我的电子邮件地址 

1219
01:01:13,380 --> 01:01:15,920
好吧 让我们来找出原因吧 

1220
01:01:15,920 --> 01:01:20,400
为什么现在是maran@cs50.atherard.edu

1221
01:01:20,400 --> 01:01:25,890
被认为是无效的 即使我很确定我发送和接收

1222
01:01:25,890 --> 01:01:27,330
也是从那个地址发的电子邮件吗？

1223
01:01:30,470 --> 01:01:32,000
为什么会这样呢？

1224
01:01:32,000 --> 01:01:38,475
观众：因为在@符号后面有一个圆点 

1225
01:01:38,475 --> 01:01:39,350
大卫·马兰：没错 

1226
01:01:39,350 --> 01:01:42,230
我的CS50后面有一个圆点 

1227
01:01:42,230 --> 01:01:45,080
我并不期待那里有任何圆点 我只是期待 

1228
01:01:45,080 --> 01:01:50,240
同样是单词字符 从A到z、0到9和下划线 

1229
01:01:50,240 --> 01:01:52,130
所以我得在这里重新装备一下 

1230
01:01:52,130 --> 01:01:54,090
但我怎么能着手做这件事呢？

1231
01:01:54,090 --> 01:01:57,613
从理论上讲 可能还有其他电子邮件地址 

1232
01:01:57,613 --> 01:02:00,530
例如 尽管它们会变得有点过长 

1233
01:02:00,530 --> 01:02:05,210
Maran@omething.cs50.atherard.edu 技术上并不存在 

1234
01:02:05,210 --> 01:02:06,125
但这是可能的 

1235
01:02:06,125 --> 01:02:09,950
当然 你可以像我们在这里看到的那样 在一个域名中有多个圆点 

1236
01:02:09,950 --> 01:02:12,500
如果我们也能处理好那不是很好吗？

1237
01:02:12,500 --> 01:02:16,670
好吧 让我提议如下修改我的正则表达式 

1238
01:02:16,670 --> 01:02:20,240
事实证明 你可以把想法组合在一起 

1239
01:02:20,240 --> 01:02:24,050
您不仅可以询问此模式是否匹配

1240
01:02:24,050 --> 01:02:29,780
或者这个使用类似A竖线B的语法 意思是“A或B” 

1241
01:02:29,780 --> 01:02:34,280
您还可以将对象组合在一起 然后对其应用其他运算符

1242
01:02:34,280 --> 01:02:35,100
也是 

1243
01:02:35,100 --> 01:02:37,160
事实上 让我回到这里的代码 

1244
01:02:37,160 --> 01:02:42,260
让我提议 如果我想容忍像cs50这样的子域 

1245
01:02:42,260 --> 01:02:46,700
这可能在那里 也可能不在那里 让我继续进行更改 如下所示 

1246
01:02:46,700 --> 01:02:48,320
我可以天真地做这件事 

1247
01:02:48,320 --> 01:02:51,210
如果我想支持子域 我可以说 好吧 

1248
01:02:51,210 --> 01:02:55,640
让我们考虑其他单词字符加号 然后是字面点 

1249
01:02:55,640 --> 01:02:58,970
请注意 我将在这里用蓝色突出显示我刚刚添加的内容 

1250
01:02:58,970 --> 01:03:04,190
其他一切都是一样的 但我现在要为另一个序列添加空间

1251
01:03:04,190 --> 01:03:07,650
或更多单词字符 然后是字面点 

1252
01:03:07,650 --> 01:03:12,380
所以现在 我想 如果我重新运行valiate.py的python 

1253
01:03:12,380 --> 01:03:16,310
将适用于Malan@cs50.atherard.edu 输入 

1254
01:03:16,310 --> 01:03:19,610
不幸的是 有没有人知道这是怎么回事？

1255
01:03:19,610 --> 01:03:22,310
让我重新运行valiate.py的python 然后输入

1256
01:03:22,310 --> 01:03:25,010
在我一直在做的事情中 到目前为止 Malan@atherard.edu

1257
01:03:25,010 --> 01:03:27,290
尽管我做了这么多改变 我还是继续工作 

1258
01:03:27,290 --> 01:03:33,110
但现在 呃 我终于破解了我自己的电子邮件地址 

1259
01:03:33,110 --> 01:03:35,540
那么 从逻辑上讲 这里的解决方案是什么？

1260
01:03:35,540 --> 01:03:37,730
好吧 我们有很多办法可以解决这个问题 

1261
01:03:37,730 --> 01:03:40,430
我也许可以开始使用两个正则表达式

1262
01:03:40,430 --> 01:03:46,370
并支持以下形式的电子邮件地址：username@domain.tld 

1263
01:03:46,370 --> 01:03:51,350
或用户名@subdomain.domain.tld 其中TLD只是

1264
01:03:51,350 --> 01:03:53,917
指顶级域名 如EDU 

1265
01:03:53,917 --> 01:03:56,000
或者我可以修改这个 因为我会

1266
01:03:56,000 --> 01:04:00,920
不希望有两个正则表达式或一个两倍大的正则表达式 

1267
01:04:00,920 --> 01:04:06,470
为什么我不指定re.earch这个模式的部分是可选的呢？

1268
01:04:06,470 --> 01:04:10,400
我们之前看到的那个符号是什么？

1269
01:04:10,400 --> 01:04:15,440
你想具体说明之前的事情在技术上是可选的吗？

1270
01:04:15,440 --> 01:04:16,610
观众：异性恋吧？

1271
01:04:16,610 --> 01:04:19,790
我们把直杆当做--

1272
01:04:19,790 --> 01:04:22,678
可选 则将参数设置为可选 

1273
01:04:22,678 --> 01:04:23,720
大卫·马兰：所以我们可以 

1274
01:04:23,720 --> 01:04:26,210
我们可以使用竖线和一些圆括号

1275
01:04:26,210 --> 01:04:29,480
然后说 “要么这里有东西 要么什么都没有 ”

1276
01:04:29,480 --> 01:04:31,010
我们可以在括号中这样做 

1277
01:04:31,010 --> 01:04:33,860
但我认为实际上还有一种更简单的方法 

1278
01:04:33,860 --> 01:04:36,332
观众：事实上 这是一个问号 

1279
01:04:36,332 --> 01:04:37,790
大卫·马兰：的确 这是个问号 

1280
01:04:37,790 --> 01:04:41,240
回想一下我们第一组符号的总结 

1281
01:04:41,240 --> 01:04:46,130
因此我们不仅有点和*和+ 而且还有一个问号 其中

1282
01:04:46,130 --> 01:04:49,370
字面意思是“零或一次重复” 

1283
01:04:49,370 --> 01:04:50,810
实际上意味着可选 

1284
01:04:50,810 --> 01:04:54,740
它要么在那里 一个 要么不是 零 

1285
01:04:54,740 --> 01:04:57,650
现在 我该如何将它翻译成这里的代码呢？

1286
01:04:57,650 --> 01:05:03,150
好 让我继续 用括号将我的模式的这一部分括起来 

1287
01:05:03,150 --> 01:05:06,740
这并不意味着我想在用户的输入中使用括号 

1288
01:05:06,740 --> 01:05:09,410
我只是想把这些角色组合在一起 

1289
01:05:09,410 --> 01:05:11,480
事实上 这一点现在仍然有效 

1290
01:05:11,480 --> 01:05:14,960
我只是在子域的新部分周围添加了圆括号 

1291
01:05:14,960 --> 01:05:17,000
让我运行valiate.py的python 

1292
01:05:17,000 --> 01:05:20,060
让我运行maran@cs50.atherard.edu 回车 

1293
01:05:20,060 --> 01:05:21,110
这一点仍然有效 

1294
01:05:21,110 --> 01:05:25,730
但需要明确的是 如果我再次为maran@atherard.edu运行它 它仍然是

1295
01:05:25,730 --> 01:05:31,310
无效 但如果我进入这里 在括号后面说 这不是无效的

1296
01:05:31,310 --> 01:05:36,410
现在是一个逻辑单元 它是一大组想法在一起 

1297
01:05:36,410 --> 01:05:38,690
我在那里加了一个问号 

1298
01:05:38,690 --> 01:05:43,910
现在 这将告诉re.earch 括号中的整个内容

1299
01:05:43,910 --> 01:05:49,020
要么只在那里一次 要么根本不在那里 零次 

1300
01:05:49,020 --> 01:05:51,530
那么 当我运行它时 这意味着什么？

1301
01:05:51,530 --> 01:05:56,030
好的 让我继续使用maran@cs50重新运行它 

1302
01:05:56,030 --> 01:05:57,770
所以子域就在那里 

1303
01:05:57,770 --> 01:05:59,720
这和以前一样管用 

1304
01:05:59,720 --> 01:06:01,860
让我清空屏幕 然后再运行一次 蟒蛇

1305
01:06:01,860 --> 01:06:06,830
用Malan@atherard.edu创建的validate.py 它曾经很有效 但后来崩溃了 

1306
01:06:06,830 --> 01:06:08,330
我们现在又开业了吗？

1307
01:06:08,330 --> 01:06:09,260
我们是 

1308
01:06:09,260 --> 01:06:11,810
这现在又是有效的了 

1309
01:06:11,810 --> 01:06:14,540
关于这种方法的问题 我们在哪里使用了

1310
01:06:14,540 --> 01:06:18,655
不仅是问号 还有括号？

1311
01:06:18,655 --> 01:06:19,280
观众：是的 

1312
01:06:19,280 --> 01:06:22,130
你说过它可以重复0次或1次 

1313
01:06:22,130 --> 01:06:23,912
如果你有更多呢？

1314
01:06:23,912 --> 01:06:25,370
大卫·马兰：如果你有更多呢？

1315
01:06:25,370 --> 01:06:26,220
没关系 

1316
01:06:26,220 --> 01:06:28,610
这就是你可以做的* 

1317
01:06:28,610 --> 01:06:33,835
*为零或更多 这为您提供了世界上所有的灵活性 

1318
01:06:33,835 --> 01:06:34,460
观众：是的 

1319
01:06:34,460 --> 01:06:37,050
所以我只是在问--

1320
01:06:37,050 --> 01:06:40,670
使用问号时 只允许重复一次 

1321
01:06:40,670 --> 01:06:42,810
大卫·马兰：这意味着零或一次重复 

1322
01:06:42,810 --> 01:06:45,630
所以它要么不在那里 要么就在那里 

1323
01:06:45,630 --> 01:06:49,940
这就是为什么现在这个模式 如果我回到我的代码 即使再一次 

1324
01:06:49,940 --> 01:06:54,650
诚然 它看起来很神秘 让我突出显示@符号之后的所有内容

1325
01:06:54,650 --> 01:06:56,060
在$符号之前 

1326
01:06:56,060 --> 01:07:01,001
这现在代表了一个域名 如获得者.edu 

1327
01:07:01,001 --> 01:07:03,920
或域名内的子域 

1328
01:07:03,920 --> 01:07:04,700
为什么？

1329
01:07:04,700 --> 01:07:07,700
好的 右边的这部分和往常一样 

1330
01:07:07,700 --> 01:07:11,330
反斜杠w+的意思类似于哈佛或耶鲁 

1331
01:07:11,330 --> 01:07:14,810
反斜杠.edu的字面意思是“.edu” 

1332
01:07:14,810 --> 01:07:16,430
所以新的部分是这样的 

1333
01:07:16,430 --> 01:07:22,370
在圆括号中 我现在有了另一组反斜杠w+反斜杠圆点 

1334
01:07:22,370 --> 01:07:24,080
但这一切都在括号中 

1335
01:07:24,080 --> 01:07:26,870
在那之后我现在有一个问号 

1336
01:07:26,870 --> 01:07:30,710
这意味着括号中的整个东西也可以在那里 

1337
01:07:30,710 --> 01:07:31,850
或者它不可能在那里 

1338
01:07:31,850 --> 01:07:34,010
这两个都是可以接受的 

1339
01:07:34,010 --> 01:07:37,880
因此 一个问号实际上使一些东西成为可选的 

1340
01:07:37,880 --> 01:07:40,670
去掉括号是不正确的 

1341
01:07:40,670 --> 01:07:42,150
因为这意味着什么？

1342
01:07:42,150 --> 01:07:44,690
如果我去掉括号 那就意味着

1343
01:07:44,690 --> 01:07:49,580
只有这个点是可选的 这并不是我们想要表达的 

1344
01:07:49,580 --> 01:07:54,050
我想要子域名 如CS50和附加点

1345
01:07:54,050 --> 01:07:56,060
在那里或不在那里的东西 

1346
01:07:56,060 --> 01:07:59,270
这里还有一个关于正则表达式的问题怎么样？

1347
01:07:59,270 --> 01:08:01,530
观众：我们可以用这个作为用户名吗？

1348
01:08:01,530 --> 01:08:02,530
大卫·马兰：当然 

1349
01:08:02,530 --> 01:08:04,000
我们还有其他问题 

1350
01:08:04,000 --> 01:08:06,280
我们目前还没有解决所有的问题 

1351
01:08:06,280 --> 01:08:07,330
但绝对是这样 

1352
01:08:07,330 --> 01:08:11,380
目前 我们不允许您的用户名中有句点 

1353
01:08:11,380 --> 01:08:14,088
再一次 你们中的一些人拥有Gmail账户或其他账户 你

1354
01:08:14,088 --> 01:08:16,463
可能不仅仅是下划线、数字和字母 

1355
01:08:16,463 --> 01:08:17,740
你可能也会来月经 

1356
01:08:17,740 --> 01:08:21,790
嗯 我们可以解决这个问题 而不是在这里使用问号本身 

1357
01:08:21,790 --> 01:08:25,630
但现在我们有了这些括号 我能做的是

1358
01:08:25,630 --> 01:08:26,350
是这个吗 

1359
01:08:26,350 --> 01:08:30,399
我可以用圆括号将反斜杠w括起来 

1360
01:08:30,399 --> 01:08:33,819
说“任何单词字符” 也就是说 就像字母一样 

1361
01:08:33,819 --> 01:08:35,529
或数字 或下划线 

1362
01:08:35,529 --> 01:08:40,120
但我也可以用竖条或其他的东西 

1363
01:08:40,120 --> 01:08:41,800
就像一个字面点 

1364
01:08:41,800 --> 01:08:44,770
现在 需要转义一个文字点 否则它

1365
01:08:44,770 --> 01:08:47,859
代表任何角色 这将是一种倒退 是一种倒退 

1366
01:08:47,859 --> 01:08:49,540
但现在请注意我做了什么 

1367
01:08:49,540 --> 01:08:54,370
在括号中 我告诉re.earch前几个字符

1368
01:08:54,370 --> 01:08:56,800
在您的电子邮件地址中 这是您的用户名 

1369
01:08:56,800 --> 01:09:02,049
必须是单词字符 如A到z、大写或小写或0

1370
01:09:02,049 --> 01:09:05,290
到9、下划线或直接点 

1371
01:09:05,290 --> 01:09:06,760
我们也可以用不同的方式来做这件事 

1372
01:09:06,760 --> 01:09:09,220
我可以去掉括号和

1373
01:09:09,220 --> 01:09:12,010
或者 我可以只使用一组字符 

1374
01:09:12,010 --> 01:09:17,890
我可以再一次手动说a到z A到Z 0到9 

1375
01:09:17,890 --> 01:09:22,540
下划线 然后我可以做一个带反斜杠句点的直接点 

1376
01:09:22,540 --> 01:09:25,029
现在技术上我甚至不需要大写字母 

1377
01:09:25,029 --> 01:09:27,590
因为我已经告诉电脑忽略这个案子了 

1378
01:09:27,590 --> 01:09:29,359
我可以随便挑一个 

1379
01:09:29,359 --> 01:09:31,120
哪个更好 真的由你自己决定 

1380
01:09:31,120 --> 01:09:35,600
您认为可读性更好的版本通常是更好的设计 

1381
01:09:35,600 --> 01:09:36,100
好的 

1382
01:09:36,100 --> 01:09:38,979
让我提议我及时倒回这篇文章

1383
01:09:38,979 --> 01:09:42,819
回到我们停下来的地方 也就是这里 

1384
01:09:42,819 --> 01:09:44,800
让我提议 确实有 

1385
01:09:44,800 --> 01:09:48,935
此解决方案仍有局限性 不仅仅是用户名 也不仅仅是

1386
01:09:48,935 --> 01:09:49,810
使用域名 

1387
01:09:49,810 --> 01:09:51,700
我们还是有点太严格了 

1388
01:09:51,700 --> 01:09:54,910
那么 您是否希望看到正式的正则表达式

1389
01:09:54,910 --> 01:09:58,720
至少现在的浏览器在你输入电子邮件地址的时候都在使用

1390
01:09:58,720 --> 01:10:01,450
到Web表单 并且该Web表单、浏览器

1391
01:10:01,450 --> 01:10:05,680
告诉你是或否 你的电子邮件地址在句法上是有效的？

1392
01:10:05,680 --> 01:10:06,670
准备好的?

1393
01:10:06,670 --> 01:10:07,810
准备好的?

1394
01:10:07,810 --> 01:10:12,730
这就是--这甚至不是正式的正则表达式 

1395
01:10:12,730 --> 01:10:15,670
它是浏览器使用的简化版本 因为它

1396
01:10:15,670 --> 01:10:18,100
抓住大多数错误 但不是全部 

1397
01:10:18,100 --> 01:10:19,460
我们开始吧 

1398
01:10:19,460 --> 01:10:23,710
这是有效电子邮件地址的正则表达式 

1399
01:10:23,710 --> 01:10:27,550
至少作为现在的浏览器来实现它们 

1400
01:10:27,550 --> 01:10:30,610
现在乍一看 这件事非常神秘 

1401
01:10:30,610 --> 01:10:34,930
但请注意--它包裹在许多行上 但它只是一种模式 

1402
01:10:34,930 --> 01:10:37,930
但只要注意一下现在熟悉的符号就知道了 

1403
01:10:37,930 --> 01:10:40,540
在最上面有^符号 

1404
01:10:40,540 --> 01:10:43,280
在最后有一个$符号 

1405
01:10:43,280 --> 01:10:45,730
这里有一个方括号 然后还有一些

1406
01:10:45,730 --> 01:10:47,860
这些范围加上其他字符 

1407
01:10:47,860 --> 01:10:51,280
事实证明 你通常不会在电子邮件地址中看到这些字符 

1408
01:10:51,280 --> 01:10:53,770
看起来你是在用某人的用户名咒骂他们 

1409
01:10:53,770 --> 01:10:55,450
但他们是合法的角色 

1410
01:10:55,450 --> 01:10:56,680
它们是正式有效的 

1411
01:10:56,680 --> 01:11:00,670
这并不意味着Gmail将允许你放置$符号和其他

1412
01:11:00,670 --> 01:11:02,260
用户名中的标点符号 

1413
01:11:02,260 --> 01:11:04,850
但从官方角度来看 一些服务器可能会允许这样做 

1414
01:11:04,850 --> 01:11:08,080
因此 如果您真的想验证用户的电子邮件地址 

1415
01:11:08,080 --> 01:11:12,250
你实际上会想出或复制粘贴类似这样的东西 

1416
01:11:12,250 --> 01:11:14,680
但老实说 这看起来很神秘 

1417
01:11:14,680 --> 01:11:18,680
如果你手动打字 你很可能会犯错误 

1418
01:11:18,680 --> 01:11:21,040
这里有什么更好的解决方案呢？

1419
01:11:21,040 --> 01:11:24,820
在过去的几周里 图书馆就是你的朋友 

1420
01:11:24,820 --> 01:11:28,360
当然 互联网上的其他人 一个程序员

1421
01:11:28,360 --> 01:11:31,360
比你更有经验的人 甚至已经想出了代码

1422
01:11:31,360 --> 01:11:35,830
使用这个正则表达式 甚至可以正确验证电子邮件地址

1423
01:11:35,830 --> 01:11:37,580
比那更复杂的东西 

1424
01:11:37,580 --> 01:11:40,030
因此 一般来说 如果手头的问题是验证

1425
01:11:40,030 --> 01:11:43,060
非常常规的输入--电子邮件地址 

1426
01:11:43,060 --> 01:11:46,570
URL 其中有官方定义的东西

1427
01:11:46,570 --> 01:11:50,710
独立于你自己--找一个你喜欢的图书馆

1428
01:11:50,710 --> 01:11:55,130
在您的代码中轻松使用并使用它来验证电子邮件地址 

1429
01:11:55,130 --> 01:11:58,750
这不一定是你自己应该发明的轮子 

1430
01:11:58,750 --> 01:12:01,870
不过 我们已经使用电子邮件地址反复开始

1431
01:12:01,870 --> 01:12:05,300
从简单、过于简单的东西开始 并在此基础上建立起来 

1432
01:12:05,300 --> 01:12:07,960
因此 您当然可以想象仍然使用正则表达式

1433
01:12:07,960 --> 01:12:10,210
要验证不是电子邮件地址但却是

1434
01:12:10,210 --> 01:12:12,230
对您很重要的数据 

1435
01:12:12,230 --> 01:12:14,980
所以至少我们现在有了这些积木 

1436
01:12:14,980 --> 01:12:17,380
现在 除了正则表达式本身 

1437
01:12:17,380 --> 01:12:20,290
原来 在PythonRe中还有其他函数

1438
01:12:20,290 --> 01:12:22,030
正则表达式的库 

1439
01:12:22,030 --> 01:12:24,280
其中有这样一个函数 re.Match 

1440
01:12:24,280 --> 01:12:26,980
这实际上与re.earch非常相似 

1441
01:12:26,980 --> 01:12:29,462
除非您不必指定^符号

1442
01:12:29,462 --> 01:12:31,420
在您的正则表达式的最开始处 如果您愿意

1443
01:12:31,420 --> 01:12:33,400
从字符串的开头开始匹配 

1444
01:12:33,400 --> 01:12:36,958
按设计重新匹配将自动开始匹配

1445
01:12:36,958 --> 01:12:38,500
从琴弦的开头给你 

1446
01:12:38,500 --> 01:12:42,580
在精神上相似的是re.fullMatch 它做同样的事情 但不仅仅是

1447
01:12:42,580 --> 01:12:45,730
匹配字符串的开头但字符串的结尾 因此 

1448
01:12:45,730 --> 01:12:50,240
同样 也不需要同时输入^符号或$符号 

1449
01:12:50,240 --> 01:12:53,170
但现在让我们继续转换回一些实际的代码 

1450
01:12:53,170 --> 01:12:55,420
借此我们在精神上解决一个不同的问题 

1451
01:12:55,420 --> 01:12:57,920
而不是仅仅验证用户的输入

1452
01:12:57,920 --> 01:13:00,290
并确保它看起来像我们想要的 让我们

1453
01:13:00,290 --> 01:13:04,020
假设用户不会完全按照我们的要求键入数据 

1454
01:13:04,020 --> 01:13:06,290
因此 我们将不得不清理他们的投入 

1455
01:13:06,290 --> 01:13:10,580
当您使用Google Form或Office 365 Form时 这种情况经常发生 

1456
01:13:10,580 --> 01:13:12,800
或任何其他用于收集用户输入的内容 

1457
01:13:12,800 --> 01:13:15,800
无论您的表单问题是什么 您的用户

1458
01:13:15,800 --> 01:13:18,225
不一定要遵循这些方向 

1459
01:13:18,225 --> 01:13:20,600
他们可能会继续输入一些

1460
01:13:20,600 --> 01:13:22,910
格式与您可能喜欢的不同 

1461
01:13:22,910 --> 01:13:26,810
现在 你当然可以浏览结果并下载CSV 

1462
01:13:26,810 --> 01:13:29,720
或者打开Google电子表格 或类似的Excel 

1463
01:13:29,720 --> 01:13:31,980
然后手动清理所有数据

1464
01:13:31,980 --> 01:13:34,250
但是如果你有很多的意见书--几十个 

1465
01:13:34,250 --> 01:13:37,070
成百上千的数据行--

1466
01:13:37,070 --> 01:13:39,170
手动操作可能不是很有趣 

1467
01:13:39,170 --> 01:13:42,680
写代码可能会更有效 比如Python 

1468
01:13:42,680 --> 01:13:47,220
这可以让您清理数据以及任何未来的数据 

1469
01:13:47,220 --> 01:13:51,620
所以我建议我们继续关闭validate.py 

1470
01:13:51,620 --> 01:13:55,460
让我们继续创建一个新的程序 叫做format.py 

1471
01:13:55,460 --> 01:13:59,990
其目标是将用户的输入重新格式化为我们期望的格式 

1472
01:13:59,990 --> 01:14:03,080
我将继续运行format.py代码 

1473
01:14:03,080 --> 01:14:06,170
假设我们要重新格式化的数据

1474
01:14:06,170 --> 01:14:09,703
是用户的名字--所以这次不是电子邮件地址而是名字 

1475
01:14:09,703 --> 01:14:11,870
我们希望他们输入自己的名字

1476
01:14:11,870 --> 01:14:14,270
像大卫·马兰一样

1477
01:14:14,270 --> 01:14:16,610
但有些用户可能已经习惯了 

1478
01:14:16,610 --> 01:14:19,020
如果你愿意的话 倒着打他们的名字 

1479
01:14:19,020 --> 01:14:23,030
用一个逗号 如马兰逗号大卫代替 

1480
01:14:23,030 --> 01:14:27,740
现在 这很好 因为两者对人类来说都是可读的 

1481
01:14:27,740 --> 01:14:30,530
但如果你想标准化这些名字的存储方式

1482
01:14:30,530 --> 01:14:34,250
在您系统中 可能是数据库、CSV文件或其他文件 

1483
01:14:34,250 --> 01:14:37,970
如果能至少标准化或规范化格式 

1484
01:14:37,970 --> 01:14:41,060
你在存储你的数据 这样如果你打印出用户的名字 

1485
01:14:41,060 --> 01:14:43,250
都是一样的格式 大卫·马兰

1486
01:14:43,250 --> 01:14:46,410
没有逗号也没有落后

1487
01:14:46,410 --> 01:14:48,650
让我们继续做一些熟悉的事情 

1488
01:14:48,650 --> 01:14:50,990
让我们给自己一个变量name

1489
01:14:50,990 --> 01:14:53,120
并将其设置为等于input的返回值 

1490
01:14:53,120 --> 01:14:56,300
问用户 就像我们做过很多次的那样 “你叫什么名字 ”

1491
01:14:56,300 --> 01:14:57,170
问号

1492
01:14:57,170 --> 01:15:00,290
我要继续前进 至少主动清理一些混乱 

1493
01:15:00,290 --> 01:15:03,950
就像我们在这里一直做的那样 去掉所有的前导或尾随空格 

1494
01:15:03,950 --> 01:15:06,470
以防用户不小心按到空格键 

1495
01:15:06,470 --> 01:15:09,720
我们不希望最终在我们的数据集中出现这种情况 

1496
01:15:09,720 --> 01:15:12,260
现在让我继续 就像我们以前做过的那样 

1497
01:15:12,260 --> 01:15:14,900
让我快速地继续并打印出来 只是为了确保

1498
01:15:14,900 --> 01:15:18,650
我的开头是正确的 “你好 ”然后用花括号命名 

1499
01:15:18,650 --> 01:15:22,010
因此 创建一个fstring来格式化“Hello”、“Comma”、“name” 

1500
01:15:22,010 --> 01:15:25,730
现在 让我继续清理屏幕并运行格式为.py的python 

1501
01:15:25,730 --> 01:15:29,510
让我像往常一样输入我的名字 大卫 空格 马兰 

1502
01:15:29,510 --> 01:15:30,170
进来吧 

1503
01:15:30,170 --> 01:15:32,270
我认为产出看起来相当不错 

1504
01:15:32,270 --> 01:15:34,490
从语法上看 这与预期不谋而合 

1505
01:15:34,490 --> 01:15:37,283
不过 现在让我继续 再玩一次这个游戏 

1506
01:15:37,283 --> 01:15:39,200
但这一次 也许是因为我没在想 

1507
01:15:39,200 --> 01:15:41,600
或者我只是习惯了先用姓氏逗号 

1508
01:15:41,600 --> 01:15:44,700
我执行马兰、逗号、大卫 然后按回车键 

1509
01:15:44,700 --> 01:15:45,200
好的 

1510
01:15:45,200 --> 01:15:47,270
好吧 现在这太奇怪了 

1511
01:15:47,270 --> 01:15:51,020
即使程序只是吐出我输入的内容 

1512
01:15:51,020 --> 01:15:54,020
可以说 这并不接近正确 至少在语法上是这样 

1513
01:15:54,020 --> 01:15:56,810
它真的应该说“你好 大卫·马兰 ”

1514
01:15:56,810 --> 01:15:58,820
现在 也许我可以有一些如果条件

1515
01:15:58,820 --> 01:16:01,910
如果用户输入逗号 我可以拒绝用户的输入

1516
01:16:01,910 --> 01:16:03,800
或者以某种方式把他们的名字倒过来 

1517
01:16:03,800 --> 01:16:07,190
但如果用户已经有了 那就太少了 太迟了

1518
01:16:07,190 --> 01:16:10,580
在网上提交了一份表格 我已经有了数据 

1519
01:16:10,580 --> 01:16:12,600
现在我要进去把它清理干净 

1520
01:16:12,600 --> 01:16:14,750
而且手动检查也不会很有趣

1521
01:16:14,750 --> 01:16:17,900
在Google电子表格、Apple Numbers或Microsoft Excel中

1522
01:16:17,900 --> 01:16:21,650
并手动修改许多人的名字以去掉逗号

1523
01:16:21,650 --> 01:16:25,700
按照美国的惯例 把名字移到最后一个名字之前 

1524
01:16:25,700 --> 01:16:27,080
那就让我们开始吧 

1525
01:16:27,080 --> 01:16:29,780
它可能有点脆弱 但让我们开始

1526
01:16:29,780 --> 01:16:32,990
在这里以编程的方式来表达我们自己 并提出这个问题 

1527
01:16:32,990 --> 01:16:37,940
如果这个人的名字里有一个逗号 这是毕多德式的--

1528
01:16:37,940 --> 01:16:41,960
我只是在问 这根更短的绳子是不是在这根更长的绳子上？

1529
01:16:41,960 --> 01:16:43,650
那就让我继续做这件事 

1530
01:16:43,650 --> 01:16:46,340
让我们继续在变量中获取该名称 

1531
01:16:46,340 --> 01:16:50,840
不仅在逗号上拆分 还在后面的空格上拆分 

1532
01:16:50,840 --> 01:16:53,480
假设人类在他们的名字后面输入了一个空格 

1533
01:16:53,480 --> 01:16:57,080
让我继续存储拆分Malan、逗号、

1534
01:16:57,080 --> 01:16:58,860
大卫分为两个变量 

1535
01:16:58,860 --> 01:17:02,000
让我们最后做一次 逗号 首先 再打开包装

1536
01:17:02,000 --> 01:17:04,310
返回的值序列 

1537
01:17:04,310 --> 01:17:07,170
现在让我继续并重新设置名称的格式 

1538
01:17:07,170 --> 01:17:10,160
因此 我将强制将用户名更改为我所期望的名称 

1539
01:17:10,160 --> 01:17:13,580
因此名称实际上将是这样的格式字符串--

1540
01:17:13,580 --> 01:17:18,830
先是名 然后是姓 两者都用大括号括起来 但格式在一起

1541
01:17:18,830 --> 01:17:22,580
只有一个空格 所以我会覆盖用户的输入

1542
01:17:22,580 --> 01:17:25,280
并相应地更新我的名字变量 

1543
01:17:25,280 --> 01:17:27,770
目前 需要明确的是 这个项目是互动的 

1544
01:17:27,770 --> 01:17:31,250
就像 用户 像我一样 在程序中输入他们的名字 

1545
01:17:31,250 --> 01:17:34,340
但是假设数据已经在CSV文件中 

1546
01:17:34,340 --> 01:17:37,730
它来自某个过程 比如谷歌表格或其他在线工具 

1547
01:17:37,730 --> 01:17:40,370
您可以想象编写类似于下面这样的代码 

1548
01:17:40,370 --> 01:17:43,550
但它可能会先将该文件读入内存 

1549
01:17:43,550 --> 01:17:46,640
也许它是通过CSV阅读器或DictReader的CSV 

1550
01:17:46,640 --> 01:17:48,860
然后对每一个名字进行迭代 

1551
01:17:48,860 --> 01:17:51,630
但我们会保持简单 一次只做一个名字 

1552
01:17:51,630 --> 01:17:55,070
但现在有趣的是 如果我回到我的终端窗口

1553
01:17:55,070 --> 01:17:57,940
并将其清除 然后运行格式为.py的python 

1554
01:17:57,940 --> 01:18:01,240
然后按Enter键 我将像以前一样输入David space Malan 

1555
01:18:01,240 --> 01:18:03,130
我觉得我们还是不错的 

1556
01:18:03,130 --> 01:18:05,290
但我也要继续这样做--

1557
01:18:05,290 --> 01:18:10,630
格式为.py Malan、逗号、David的巨蟒 中间有空格 

1558
01:18:10,630 --> 01:18:13,960
祈祷我的手指并按回车键 瞧 

1559
01:18:13,960 --> 01:18:15,640
现在 这一点已经得到解决 

1560
01:18:15,640 --> 01:18:18,400
可以肯定的是 这是一件非常简单的事情 

1561
01:18:18,400 --> 01:18:22,300
但清理用户输入是如此普遍的必要 

1562
01:18:22,300 --> 01:18:25,870
在这里 我们至少看到了一种非常容易做到这一点的方法 

1563
01:18:25,870 --> 01:18:28,480
现在 公平地说 这里有一些问题 

1564
01:18:28,480 --> 01:18:32,500
事实上 有人能想象这样一种场景吗？在这种情况下 

1565
01:18:32,500 --> 01:18:34,570
不能修复用户的输入？

1566
01:18:34,570 --> 01:18:39,760
即使在我的代码中修复了这个问题 还会出什么问题？

1567
01:18:39,760 --> 01:18:40,810
有什么想法吗？

1568
01:18:40,810 --> 01:18:44,322
观众：如果他们输入他们的名字逗号 然后[INAUDIBLE]..

1569
01:18:44,322 --> 01:18:46,030
大卫·马兰：哦 还有一件事 

1570
01:18:46,030 --> 01:18:46,530
嗯 

1571
01:18:46,530 --> 01:18:48,730
举个例子 让我试试这个 

1572
01:18:48,730 --> 01:18:50,410
让我继续运行一个程序 

1573
01:18:50,410 --> 01:18:53,350
我是我认识的唯一的大卫·马兰 

1574
01:18:53,350 --> 01:18:57,850
但假设我是 比如说 像这样的初级学生 

1575
01:18:57,850 --> 01:19:00,850
而且 至少在英语中 有时在那里加一个逗号是很常见的 

1576
01:19:00,850 --> 01:19:02,350
你不一定需要逗号 但我

1577
01:19:02,350 --> 01:19:04,120
那些使用逗号的人中的一个 

1578
01:19:04,120 --> 01:19:06,730
那现在真的 真的坏了 

1579
01:19:06,730 --> 01:19:08,830
所以我打破了一些假设 

1580
01:19:08,830 --> 01:19:10,970
因此 这在这里肯定会出问题 

1581
01:19:10,970 --> 01:19:11,470
还有什么？

1582
01:19:11,470 --> 01:19:13,178
好吧 让我继续 再运行一次 

1583
01:19:13,178 --> 01:19:15,540
如果我用马兰 逗号 大卫 没有空格 

1584
01:19:15,540 --> 01:19:17,290
因为我有点草率 我没有

1585
01:19:17,290 --> 01:19:20,500
注意 当你有很多用户时 就会发生这种情况

1586
01:19:20,500 --> 01:19:22,750
最终 好吧 这件事现在真的坏了 

1587
01:19:22,750 --> 01:19:25,870
注意 我有一个ValueError 这是一个实际的异常 

1588
01:19:25,870 --> 01:19:26,410
为什么？

1589
01:19:26,410 --> 01:19:31,330
因为Split应该将字符串分割成两个字符串

1590
01:19:31,330 --> 01:19:34,000
通过寻找逗号和空格 

1591
01:19:34,000 --> 01:19:37,720
但如果没有逗号和空格 它就不能将其分成两部分 

1592
01:19:37,720 --> 01:19:40,900
事实上 左边有两个变量 

1593
01:19:40,900 --> 01:19:44,290
但我只能拿回右边的一样东西 

1594
01:19:44,290 --> 01:19:47,030
这意味着我不能像这样做这段代码 

1595
01:19:47,030 --> 01:19:48,467
因此 可以肯定的是 它是脆弱的 

1596
01:19:48,467 --> 01:19:50,800
但是 如果我们至少能改进它 那不是很好吗？

1597
01:19:50,800 --> 01:19:53,710
例如 我们现在知道一些正则表达式语法 

1598
01:19:53,710 --> 01:19:56,920
如果我至少想让这个空间成为可选空间呢？

1599
01:19:56,920 --> 01:20:00,010
嗯 我可以使用我新发现的正则表达式语法

1600
01:20:00,010 --> 01:20:04,330
然后打个问号 问号的意思是零或一件事

1601
01:20:04,330 --> 01:20:05,080
往左走 

1602
01:20:05,080 --> 01:20:06,490
左边的是什么？

1603
01:20:06,490 --> 01:20:07,850
从字面上看 这是一个空间 

1604
01:20:07,850 --> 01:20:10,760
如果只有一样东西 我甚至不需要括号 

1605
01:20:10,760 --> 01:20:15,040
所以这将是一个模式的开始 它说 我必须有一个逗号 

1606
01:20:15,040 --> 01:20:19,240
然后我可能有一个空格 也可能没有空格 之后是零个空格或一个空格 

1607
01:20:19,240 --> 01:20:25,810
不幸的是 内置到str变量中的Split版本 

1608
01:20:25,810 --> 01:20:28,600
如本例所示 不支持正则表达式 

1609
01:20:28,600 --> 01:20:32,120
如果我们想要我们的正则表达式 我们需要在这里使用该库 

1610
01:20:32,120 --> 01:20:33,650
所以让我继续做这件事 

1611
01:20:33,650 --> 01:20:37,550
让我进去 让这个代码保持原样 但要放在最上面

1612
01:20:37,550 --> 01:20:41,650
现在 导入re以导入正则表达式的库 

1613
01:20:41,650 --> 01:20:46,000
现在让我继续 开始改变我的方法 

1614
01:20:46,000 --> 01:20:47,630
我要继续做这件事 

1615
01:20:47,630 --> 01:20:50,890
我将使用名为re.earch的相同函数 

1616
01:20:50,890 --> 01:20:54,370
我要去寻找一种模式

1617
01:20:54,370 --> 01:20:56,650
思考将是最后的 逗号 首先 

1618
01:20:56,650 --> 01:20:59,050
因此 让我使用我新发现的正则表达式语法

1619
01:20:59,050 --> 01:21:04,390
代表一种模式 如马兰、逗号、空格、大卫 

1620
01:21:04,390 --> 01:21:05,660
我怎么能这样做呢？

1621
01:21:05,660 --> 01:21:10,570
好吧 在我对re.earch的引用中 我会有一些东西--

1622
01:21:10,570 --> 01:21:11,950
所以点+--

1623
01:21:11,950 --> 01:21:12,610
抱歉的 

1624
01:21:12,610 --> 01:21:14,980
我要吃点东西 所以点+ 

1625
01:21:14,980 --> 01:21:16,540
然后我会有一个逗号 

1626
01:21:16,540 --> 01:21:17,890
然后我会有一个空间 

1627
01:21:17,890 --> 01:21:20,440
然后我要点+的东西 

1628
01:21:20,440 --> 01:21:23,200
现在 我将先发制人地改进一下这一点 

1629
01:21:23,200 --> 01:21:25,288
我想让这整个模式开始匹配

1630
01:21:25,288 --> 01:21:26,830
在用户输入的开始处 

1631
01:21:26,830 --> 01:21:28,960
所以我现在要把^加起来 

1632
01:21:28,960 --> 01:21:33,070
我还希望用户输入的末尾也匹配 这样我就

1633
01:21:33,070 --> 01:21:37,720
从字面上看 任何字符都需要一次或多次 然后是逗号 然后是空格 

1634
01:21:37,720 --> 01:21:40,180
然后是任何其他字符一次或多次 

1635
01:21:40,180 --> 01:21:42,280
然后就是这样了 

1636
01:21:42,280 --> 01:21:46,430
我将像以前一样传递name变量 

1637
01:21:46,430 --> 01:21:50,300
现在 当我们在过去使用re.earch时 

1638
01:21:50,300 --> 01:21:52,900
我们真的只是用它来回答一个问题 

1639
01:21:52,900 --> 01:21:57,040
用户的输入是否与以下模式匹配 

1640
01:21:57,040 --> 01:21:59,140
对或错 有效地 

1641
01:21:59,140 --> 01:22:02,600
但re.search实际上比这更强大 

1642
01:22:02,600 --> 01:22:05,110
你实际上可以得到更多的信息 

1643
01:22:05,110 --> 01:22:06,430
你可以做到这一点 

1644
01:22:06,430 --> 01:22:10,000
您可以指定一个变量 然后指定一个赋值运算符 

1645
01:22:10,000 --> 01:22:15,250
并在搜索时得到关于所发现内容的更准确的答案 

1646
01:22:15,250 --> 01:22:17,500
但你想要拿回什么呢？

1647
01:22:17,500 --> 01:22:21,260
事实证明 正则表达式还有另一个特性

1648
01:22:21,260 --> 01:22:25,330
它允许你使用括号 而不仅仅是把东西组合在一起 

1649
01:22:25,330 --> 01:22:27,070
而是为了抓住他们 

1650
01:22:27,070 --> 01:22:31,750
结果是 当您在正则表达式中指定括号时

1651
01:22:31,750 --> 01:22:35,140
到目前为止我们还不知道 括号里的一切

1652
01:22:35,140 --> 01:22:41,350
将作为re.earch函数的返回值返回给您 

1653
01:22:41,350 --> 01:22:45,700
它将允许你提取特定数量的信息

1654
01:22:45,700 --> 01:22:47,530
来自用户自己的输入 

1655
01:22:47,530 --> 01:22:51,730
您也可以通过使用非捕获版本来逆转此过程

1656
01:22:51,730 --> 01:22:52,340
也是 

1657
01:22:52,340 --> 01:22:55,507
你可以使用圆括号 然后是一个问号和一个冒号 

1658
01:22:55,507 --> 01:22:56,590
然后还有一些其他的东西 

1659
01:22:56,590 --> 01:22:58,400
也就是说 不要捕捉到这一点 

1660
01:22:58,400 --> 01:22:59,567
我只是想把东西组合起来 

1661
01:22:59,567 --> 01:23:02,850
但现在 我们将只使用括号本身 

1662
01:23:02,850 --> 01:23:04,200
那么我该怎么做呢？

1663
01:23:04,200 --> 01:23:08,780
好吧 如果我想拿回用户的姓和名 

1664
01:23:08,780 --> 01:23:16,190
我想我要捕捉的是这里的点+和这里的点+ 

1665
01:23:16,190 --> 01:23:19,190
所以我特意用括号括起来

1666
01:23:19,190 --> 01:23:22,160
逗号左右两边的点+ 

1667
01:23:22,160 --> 01:23:24,660
不是因为我把它们归类在一起--

1668
01:23:24,660 --> 01:23:28,190
我没有加问号 我没有加另一个+或*--

1669
01:23:28,190 --> 01:23:32,420
我现在使用圆括号来进行捕获 

1670
01:23:32,420 --> 01:23:33,200
为什么？

1671
01:23:33,200 --> 01:23:34,820
好的 接下来我要做这个 

1672
01:23:34,820 --> 01:23:38,690
我仍然会问一个布尔问题 比如 “如果有匹配的话 

1673
01:23:38,690 --> 01:23:40,320
那就这样做吧 

1674
01:23:40,320 --> 01:23:44,360
因此 如果匹配不是有效的假 就像没有匹配 

1675
01:23:44,360 --> 01:23:47,720
我希望我能拿回几根火柴 

1676
01:23:47,720 --> 01:23:49,400
看看我现在能做什么 

1677
01:23:49,400 --> 01:23:54,170
我可以做最后一个 逗号 第一个等于

1678
01:23:54,170 --> 01:23:56,930
并取回所有的火柴组 

1679
01:23:56,930 --> 01:24:00,020
然后继续使用格式字符串更新名称 就像前面一样

1680
01:24:00,020 --> 01:24:03,770
先做 然后用大括号做最后一次

1681
01:24:03,770 --> 01:24:06,770
同样 然后在最底部 就像以前一样 打印出来 

1682
01:24:06,770 --> 01:24:09,830
例如 “你好”、“逗号”、“名字” 

1683
01:24:09,830 --> 01:24:13,970
因此 新代码现在是这里突出显示的所有内容 

1684
01:24:13,970 --> 01:24:19,700
我使用re.earch来搜索用户是否输入了他们的名字

1685
01:24:19,700 --> 01:24:21,620
最后 逗号 第一种格式 

1686
01:24:21,620 --> 01:24:27,440
但我更强大的是使用re.earch来捕获用户的一些输入 

1687
01:24:27,440 --> 01:24:28,850
什么会被抓获？

1688
01:24:28,850 --> 01:24:31,400
我用括号括起来的任何东西都会

1689
01:24:31,400 --> 01:24:34,250
作为返回值返回给我 

1690
01:24:34,250 --> 01:24:36,650
如何获得这些返回值？

1691
01:24:36,650 --> 01:24:40,490
你问你为所有组赋值的变量 

1692
01:24:40,490 --> 01:24:44,250
捕获的所有括号组 

1693
01:24:44,250 --> 01:24:46,020
所以让我继续做这件事 

1694
01:24:46,020 --> 01:24:49,970
现在让我继续运行格式为.py的python 回车 

1695
01:24:49,970 --> 01:24:51,950
我要像往常一样输入我的名字 

1696
01:24:51,950 --> 01:24:56,900
在本例中 此If条件不会发生任何事情 

1697
01:24:56,900 --> 01:24:57,500
为什么？

1698
01:24:57,500 --> 01:25:03,270
因为我没有键入逗号 所以此搜索没有找到逗号 

1699
01:25:03,270 --> 01:25:04,632
所以没有火柴 

1700
01:25:04,632 --> 01:25:06,590
所以我们立刻打印出“你好 名字” 

1701
01:25:06,590 --> 01:25:08,370
那里没有什么有趣或新鲜的东西 

1702
01:25:08,370 --> 01:25:12,920
但如果我现在继续 并清除屏幕 并运行格式为.py的python 

1703
01:25:12,920 --> 01:25:18,740
然后做马兰语 逗号 空格 大卫 回车 我们重新格式化了我的名字 

1704
01:25:18,740 --> 01:25:19,940
好吧 这是怎么回事？

1705
01:25:19,940 --> 01:25:22,100
现在让我说得更清楚一些 

1706
01:25:22,100 --> 01:25:24,560
事实证明 我不需要只说匹配 团体 

1707
01:25:24,560 --> 01:25:28,020
我可以让我想要的特定群体回来 

1708
01:25:28,020 --> 01:25:30,290
所以让我稍微修改一下我的代码 

1709
01:25:30,290 --> 01:25:33,470
让我现在继续 只说这一点 

1710
01:25:33,470 --> 01:25:36,620
让我们将名字更新为--

1711
01:25:36,620 --> 01:25:37,980
实际上 让我们开始吧 

1712
01:25:37,980 --> 01:25:42,530
假设最后一个名字将出现在比赛中

1713
01:25:42,530 --> 01:25:44,330
但具体来说是第一组 

1714
01:25:44,330 --> 01:25:48,020
第一个名字将出现在比赛中 但特别是第二组 

1715
01:25:48,020 --> 01:25:49,100
为什么是1和2？

1716
01:25:49,100 --> 01:25:52,490
因为这是逗号左边的第一组括号 

1717
01:25:52,490 --> 01:25:55,520
这是逗号右侧的第二组括号 

1718
01:25:55,520 --> 01:25:58,700
根据输入 这将是用户的姓氏

1719
01:25:58,700 --> 01:26:00,140
在这种情况下 马兰 

1720
01:26:00,140 --> 01:26:03,560
在此场景中 这将是用户的名字David 

1721
01:26:03,560 --> 01:26:07,340
这就是我使用组1作为姓氏的原因

1722
01:26:07,340 --> 01:26:09,720
名为组2 

1723
01:26:09,720 --> 01:26:16,100
现在我要继续说名字等于fstring 再一次 首先

1724
01:26:16,100 --> 01:26:18,980
然后 最后 完成 

1725
01:26:18,980 --> 01:26:23,340
在我们回答问题之前 让我来完善这最后一步 

1726
01:26:23,340 --> 01:26:26,090
如果我立即使用这些变量 我实际上并不需要它们 

1727
01:26:26,090 --> 01:26:28,423
让我们继续前进 进一步加强这一点 就像我们已经

1728
01:26:28,423 --> 01:26:29,990
过去是为了设计而做的 

1729
01:26:29,990 --> 01:26:32,722
如果我想要将该名称作为串联

1730
01:26:32,722 --> 01:26:34,430
这个人的名字和姓氏 

1731
01:26:34,430 --> 01:26:37,970
我们就这么做吧 匹配 首先是第2组 

1732
01:26:37,970 --> 01:26:43,400
加一个空格 加火柴 第一组 

1733
01:26:43,400 --> 01:26:46,910
所以从左到右由我决定 这是第一组 

1734
01:26:46,910 --> 01:26:47,630
这是第二组 

1735
01:26:47,630 --> 01:26:51,000
所以第一组是最后 第二组是第一 

1736
01:26:51,000 --> 01:26:54,860
因此 如果我想反转它们并更新名称的值 

1737
01:26:54,860 --> 01:27:00,290
我可以首先显式地获取组2 使用+、单个空格

1738
01:27:00,290 --> 01:27:03,540
然后在组1上串连 

1739
01:27:03,540 --> 01:27:04,170
好的 

1740
01:27:04,170 --> 01:27:05,280
那真是太多了 

1741
01:27:05,280 --> 01:27:07,620
让我暂停一下 看看是否有问题 

1742
01:27:07,620 --> 01:27:11,670
这里的关键不同之处在于 我们仍然使用完全相同的re.search 

1743
01:27:11,670 --> 01:27:15,090
但现在我使用它的返回值 而不仅仅是回答

1744
01:27:15,090 --> 01:27:17,400
一个问题是对还是错 但实际上

1745
01:27:17,400 --> 01:27:21,750
找回我捕捉到的任何匹配的东西 可以这么说 

1746
01:27:21,750 --> 01:27:23,190
加上圆括号 

1747
01:27:23,190 --> 01:27:26,270
观众：为什么我们用的是1和2而不是0和1

1748
01:27:26,270 --> 01:27:27,270
因为抓到了第一个？

1749
01:27:27,270 --> 01:27:29,010
大卫·马兰：这个问题问得很好 

1750
01:27:29,010 --> 01:27:30,060
观察得很好 

1751
01:27:30,060 --> 01:27:32,070
在几乎所有其他背景下 我们已经开始

1752
01:27:32,070 --> 01:27:35,250
数到0和1 而不是1和2 

1753
01:27:35,250 --> 01:27:38,190
原来在0号位置还有其他东西

1754
01:27:38,190 --> 01:27:41,530
当它从re.earch返回时 它与字符串本身相关 

1755
01:27:41,530 --> 01:27:45,000
因此 仅根据此函数的文档 

1756
01:27:45,000 --> 01:27:49,110
1是第一组括号 2是第二组括号 

1757
01:27:49,110 --> 01:27:50,460
从那以后 

1758
01:27:50,460 --> 01:27:52,540
只是这里有一个不同的会议 

1759
01:27:52,540 --> 01:27:53,580
还有其他问题吗？

1760
01:27:53,580 --> 01:27:59,820
观众：如果我们什么都不写呢 比如空格、逗号、空格？

1761
01:27:59,820 --> 01:28:03,317
我们如何检查条件的真实性？

1762
01:28:03,317 --> 01:28:05,400
David Malan：在我直接回答之前 让我

1763
01:28:05,400 --> 01:28:07,733
运行这个 并确保我没有进一步打破任何东西 

1764
01:28:07,733 --> 01:28:09,360
让我运行格式为.py的python 

1765
01:28:09,360 --> 01:28:12,060
让我以正确的方式输入大卫、空格、马兰 

1766
01:28:12,060 --> 01:28:13,200
让我再运行一次 

1767
01:28:13,200 --> 01:28:16,650
让我输入Malan 逗号 David 这是我们正在修复的错误方式 

1768
01:28:16,650 --> 01:28:17,850
我们还是很棒的 

1769
01:28:17,850 --> 01:28:19,410
但我认为它还是会破裂的 

1770
01:28:19,410 --> 01:28:23,610
让我用马兰 逗号 大卫第三次运行它 没有空格 

1771
01:28:23,610 --> 01:28:26,190
现在它还是坏了 

1772
01:28:26,190 --> 01:28:26,790
为什么？

1773
01:28:26,790 --> 01:28:30,930
因为我还在找逗号空格 

1774
01:28:30,930 --> 01:28:32,220
现在 我怎么才能解决这个问题呢？

1775
01:28:32,220 --> 01:28:35,070
我可以这样做的一种方法是在这里加一个问号 这又一次 

1776
01:28:35,070 --> 01:28:37,510
是零个或多个以前的东西 

1777
01:28:37,510 --> 01:28:40,950
所以如果我有一个空格 然后是一个问号 不需要任何

1778
01:28:40,950 --> 01:28:46,290
括号 那么我完全可以容忍马兰语、逗号、空格、

1779
01:28:46,290 --> 01:28:48,610
大卫或马兰 逗号 大卫 

1780
01:28:48,610 --> 01:28:49,680
所以让我们再试一次 

1781
01:28:49,680 --> 01:28:51,120
以前 这是行不通的 

1782
01:28:51,120 --> 01:28:53,310
让我们做马兰 逗号 大卫 没有空格 

1783
01:28:53,310 --> 01:28:55,990
现在它确实起作用了 

1784
01:28:55,990 --> 01:28:58,740
所以我们可以容忍不同数量的空格

1785
01:28:58,740 --> 01:29:01,890
如果我用我的公式更精确一点的话 

1786
01:29:01,890 --> 01:29:03,420
让我继续 再试一次 

1787
01:29:03,420 --> 01:29:07,260
让我很奇怪 但可能会按空格键太多次

1788
01:29:07,260 --> 01:29:08,850
所以现在他们真的分开了 

1789
01:29:08,850 --> 01:29:13,020
这又一次不会有很好的效果 因为它

1790
01:29:13,020 --> 01:29:15,160
来消耗所有的空格 

1791
01:29:15,160 --> 01:29:18,420
所以现在我可能想要脱光衣服 左右 任何

1792
01:29:18,420 --> 01:29:21,720
结果上的前导空格 或者我能在这里做些什么

1793
01:29:21,720 --> 01:29:22,930
就是这么说 

1794
01:29:22,930 --> 01:29:29,670
我可以在这里使用* 所以空格* 而不是0或1 

1795
01:29:29,670 --> 01:29:33,000
现在如果我用马兰、逗号、空格再运行一次 

1796
01:29:33,000 --> 01:29:35,920
大卫 进来 现在我们已经把东西收拾得更干净了 

1797
01:29:35,920 --> 01:29:39,510
所以你可以想象 取决于你的数据有多混乱

1798
01:29:39,510 --> 01:29:41,550
清理后 您的正则表达式可能需要

1799
01:29:41,550 --> 01:29:43,500
变得越来越复杂 

1800
01:29:43,500 --> 01:29:46,830
这真的取决于我们想一次解决多少问题 

1801
01:29:46,830 --> 01:29:51,900
好吧 请允许我提议我们继续前进 只是为了把这件事清理干净

1802
01:29:51,900 --> 01:29:53,940
更重要的是 使用一种实际上

1803
01:29:53,940 --> 01:29:56,430
对Python本身来说是相对较新的 

1804
01:29:56,430 --> 01:29:59,220
这在使用正则表达式时非常常见

1805
01:29:59,220 --> 01:30:03,210
来做我在这里所做的事情--调用一个像re.earch这样的函数

1806
01:30:03,210 --> 01:30:07,300
在里面捕获圆括号 这样您就可以返回一个

1807
01:30:07,300 --> 01:30:10,050
我称之为匹配的价值--你可以叫它其他的东西 

1808
01:30:10,050 --> 01:30:12,090
但我默认将其称为匹配 

1809
01:30:12,090 --> 01:30:15,690
然后注意下一行 我说的是“如果匹配” 

1810
01:30:15,690 --> 01:30:19,080
如果我能把事情做得更紧一些 做这些不是很好吗？

1811
01:30:19,080 --> 01:30:20,700
都在同一条线上？

1812
01:30:20,700 --> 01:30:23,070
嗯 你可以这么说 

1813
01:30:23,070 --> 01:30:24,850
让我继续做这件事 

1814
01:30:24,850 --> 01:30:26,340
让我把这个If处理掉 

1815
01:30:26,340 --> 01:30:28,500
让我试着说这样的话 

1816
01:30:28,500 --> 01:30:32,370
如果匹配等于re.earch 然后是冒号--

1817
01:30:32,370 --> 01:30:39,090
因此 将我的if条件合并到一行中 而不是这两行 

1818
01:30:39,090 --> 01:30:43,455
在C、C++或Java中 您实际上会这样做 

1819
01:30:43,455 --> 01:30:45,330
把整件事用括号括起来 

1820
01:30:45,330 --> 01:30:47,550
有时设置双倍以抑制任何警告 

1821
01:30:47,550 --> 01:30:49,980
如果你想同时做两件事 

1822
01:30:49,980 --> 01:30:55,530
如果您不仅希望将re.earch的返回值

1823
01:30:55,530 --> 01:30:58,080
设置为名为Matches的变量 但您希望

1824
01:30:58,080 --> 01:31:03,408
接下来要问一个布尔问题 这实际上是对的还是错的 

1825
01:31:03,408 --> 01:31:04,950
这就是我刚才正在做的 

1826
01:31:04,950 --> 01:31:06,060
让我来解开这一切 

1827
01:31:06,060 --> 01:31:08,430
刚才 我正在取回返回值

1828
01:31:08,430 --> 01:31:12,090
然后把它分配给火柴 然后我就问了这个问题 

1829
01:31:12,090 --> 01:31:16,530
好的 结果是这两行代码可能需要擦除

1830
01:31:16,530 --> 01:31:18,840
人们在Python中犯错误的时间太长了 

1831
01:31:18,840 --> 01:31:22,170
所以你现在可以把这两种线结合成一条线 

1832
01:31:22,170 --> 01:31:24,450
但你需要一个新的接线员 

1833
01:31:24,450 --> 01:31:27,720
你不能只说 “如果匹配等于re.earch”

1834
01:31:27,720 --> 01:31:29,580
然后放在结尾处的冒号里 

1835
01:31:29,580 --> 01:31:32,170
相反 您需要这样做 

1836
01:31:32,170 --> 01:31:38,130
如果且仅当您想要赋值某项时 才需要执行冒号等于

1837
01:31:38,130 --> 01:31:42,390
从右到左 你想问一个if或elif

1838
01:31:42,390 --> 01:31:44,820
问题在同一条线上 

1839
01:31:44,820 --> 01:31:48,870
正如这里所看到的 这被亲切地称为海象操作员 

1840
01:31:48,870 --> 01:31:51,480
而且这是近几年来对Python来说的新事物 

1841
01:31:51,480 --> 01:31:56,280
它既允许您像我从右到左所做的那样赋值 

1842
01:31:56,280 --> 01:32:00,180
问一个布尔式的问题 就像我

1843
01:32:00,180 --> 01:32:02,960
用If或等效的Elif做什么 

1844
01:32:02,960 --> 01:32:06,650
有人知道为什么这个叫海象操作员吗？

1845
01:32:06,650 --> 01:32:09,920
如果你这样看它 也许 

1846
01:32:09,920 --> 01:32:14,040
如果你熟悉海象 它看起来有点像海象 

1847
01:32:14,040 --> 01:32:17,720
因此 这是一个次要的细节 但相对较新的功能 说实话 您将

1848
01:32:17,720 --> 01:32:21,170
可能会继续在网上、源代码和教科书中看到 

1849
01:32:21,170 --> 01:32:24,300
以此类推 现在它确实存在了 越来越多地如此 

1850
01:32:24,300 --> 01:32:25,910
这根本不会改变逻辑 

1851
01:32:25,910 --> 01:32:29,660
如果我运行格式为.py的python并输入Malan、逗号、空格、David 

1852
01:32:29,660 --> 01:32:33,750
它仍然可以修复一些问题 但它只是稍微加强了我的代码 

1853
01:32:33,750 --> 01:32:34,250
好的 

1854
01:32:34,250 --> 01:32:37,010
让我们继续看最后一个问题

1855
01:32:37,010 --> 01:32:40,470
要解决的问题是 现在也要提取信息 

1856
01:32:40,470 --> 01:32:43,460
现在 我们已经验证了用户的输入

1857
01:32:43,460 --> 01:32:46,160
通过检查它是否符合特定的模式 

1858
01:32:46,160 --> 01:32:49,100
我们已经通过检查清理了用户的输入

1859
01:32:49,100 --> 01:32:51,470
根据一个模式 无论它是否匹配 如果它

1860
01:32:51,470 --> 01:32:54,350
确实匹配 我们可以重新组织一些用户的信息

1861
01:32:54,350 --> 01:32:57,800
这样我们就可以清理他们的输入 并标准化我们

1862
01:32:57,800 --> 01:32:59,540
在这种情况下 存储或打印它 

1863
01:32:59,540 --> 01:33:03,350
让我们来做最后一个例子 其中我们非常明确地提取

1864
01:33:03,350 --> 01:33:06,440
信息 以回答一些问题 

1865
01:33:06,440 --> 01:33:07,830
因此 让我提出这一点 

1866
01:33:07,830 --> 01:33:12,650
让我们继续关闭Format.py并创建一个名为twitter.py的新文件 

1867
01:33:12,650 --> 01:33:17,690
它的目标是提示用户输入他们的Twitter个人资料的URL

1868
01:33:17,690 --> 01:33:23,562
并从中提取 从该URL推断出用户的用户名 

1869
01:33:23,562 --> 01:33:25,020
现在 你为什么要这么做呢？

1870
01:33:25,020 --> 01:33:28,228
首先 您可能希望用户能够非常轻松地复制和粘贴

1871
01:33:28,228 --> 01:33:32,330
从他们自己的Twitter个人资料到您的表单、到您的应用程序的URL 

1872
01:33:32,330 --> 01:33:36,140
这样你就可以知道他们的用户名是什么 

1873
01:33:36,140 --> 01:33:40,430
或者你可能有一个表单 要求用户输入他们的Twitter用户名 

1874
01:33:40,430 --> 01:33:43,400
因为人们不一定会非常密切地关注 

1875
01:33:43,400 --> 01:33:45,530
有些人会输入他们的用户名 

1876
01:33:45,530 --> 01:33:49,340
有些人会打出他们的整个URL或其他东西 

1877
01:33:49,340 --> 01:33:51,350
现在你是一名程序员 那就太好了

1878
01:33:51,350 --> 01:33:53,780
只是更能容忍不同类型的输入

1879
01:33:53,780 --> 01:33:58,100
承担起规范化、标准化数据的重担 

1880
01:33:58,100 --> 01:34:00,140
而是灵活地对待用户 

1881
01:34:00,140 --> 01:34:03,500
如果你只是让我复制粘贴 它可以说是更好的用户体验

1882
01:34:03,500 --> 01:34:05,660
或者输入我想要的东西 你就把它清理干净 

1883
01:34:05,660 --> 01:34:07,550
你是程序员 不是我 

1884
01:34:07,550 --> 01:34:09,920
可能会带来更好的体验 

1885
01:34:09,920 --> 01:34:12,620
那么 让我继续使用twitter.py来做这件事 

1886
01:34:12,620 --> 01:34:17,120
让我首先在这里提示用户输入变量的值

1887
01:34:17,120 --> 01:34:21,702
我会调用url 让他们输入他们Twitter个人资料的URL 

1888
01:34:21,702 --> 01:34:23,660
我要脱掉所有的主角

1889
01:34:23,660 --> 01:34:26,810
或尾随空格 以防用户不小心按下空格键 

1890
01:34:26,810 --> 01:34:29,940
从字面上说 这是我能很容易做到的最低限度 

1891
01:34:29,940 --> 01:34:32,100
但现在让我们继续做这件事 

1892
01:34:32,100 --> 01:34:37,185
假设用户的地址如下 

1893
01:34:37,185 --> 01:34:38,810
让我把他们输入的内容打印出来 

1894
01:34:38,810 --> 01:34:41,190
让我清空屏幕并运行twitter.py的python 

1895
01:34:41,190 --> 01:34:43,190
例如 我将继续输入 

1896
01:34:43,190 --> 01:34:50,240
Https://twitter.com/davidjmalan  恰好是我自己的推特用户名 

1897
01:34:50,240 --> 01:34:53,090
现在 我们只需将其打印回屏幕

1898
01:34:53,090 --> 01:34:54,640
以确保我还没有搞砸 

1899
01:34:54,640 --> 01:34:55,140
好的 

1900
01:34:55,140 --> 01:34:57,260
所以我打印回了完全相同的URL 

1901
01:34:57,260 --> 01:35:01,310
但手头的目标是只提取用户名 

1902
01:35:01,310 --> 01:35:05,060
现在 让我问一个直截了当的问题 

1903
01:35:05,060 --> 01:35:09,830
从逻辑上讲 我需要做什么才能获得用户的用户名？

1904
01:35:09,830 --> 01:35:13,880
观众：嗯 我们只是忽略用户名之前的内容

1905
01:35:13,880 --> 01:35:16,065
然后直接提取用户名？

1906
01:35:16,065 --> 01:35:16,940
大卫·马兰：太好了 

1907
01:35:16,940 --> 01:35:18,380
是的 我是说 就这么简单 

1908
01:35:18,380 --> 01:35:20,720
如果您知道用户名在末尾 那么让我们

1909
01:35:20,720 --> 01:35:22,920
不知何故 从一开始就忽略了一切 

1910
01:35:22,920 --> 01:35:24,170
那么 开头是什么？

1911
01:35:24,170 --> 01:35:25,130
嗯 这是个网址 

1912
01:35:25,130 --> 01:35:30,890
所以我们可能需要忽略HTTPS a：// twitter.com 

1913
01:35:30,890 --> 01:35:31,910
和a/ 

1914
01:35:31,910 --> 01:35:33,840
所以我们只想把这一切都扔掉 

1915
01:35:33,840 --> 01:35:34,340
为什么？

1916
01:35:34,340 --> 01:35:37,400
因为如果它是一个URL 我们可以通过Twitter的工作原理来了解

1917
01:35:37,400 --> 01:35:39,240
用户名位于末尾 

1918
01:35:39,240 --> 01:35:43,418
因此 让我们使用这个非常简单的想法来获取我们想要的信息 

1919
01:35:43,418 --> 01:35:45,210
我将尝试几种不同的方法 

1920
01:35:45,210 --> 01:35:46,620
让我在这里回到我的程序 

1921
01:35:46,620 --> 01:35:49,820
而不是仅仅打印出来 这只是为了看看发生了什么 

1922
01:35:49,820 --> 01:35:50,880
让我来做吧 

1923
01:35:50,880 --> 01:35:53,180
让我创建一个名为UserName的新变量 

1924
01:35:53,180 --> 01:35:56,810
让我打电话给url.place 

1925
01:35:56,810 --> 01:36:01,340
结果是 如果URL是一个字符串或在Python中是一个字符串 

1926
01:36:01,340 --> 01:36:05,840
它又一次提供了多种方法 如剥离和分割 

1927
01:36:05,840 --> 01:36:08,750
还有其他的 其中一个被称为Replace 

1928
01:36:08,750 --> 01:36:10,400
而Replace将会做到这一点 

1929
01:36:10,400 --> 01:36:14,360
您向它传递两个参数 第一个参数是 您想要替换什么？

1930
01:36:14,360 --> 01:36:17,640
第二个论点是 你想用什么来取代它？

1931
01:36:17,640 --> 01:36:19,940
所以如果我想摆脱 就像我提议的那样 

1932
01:36:19,940 --> 01:36:21,740
实际上就是用户名之前的所有内容 

1933
01:36:21,740 --> 01:36:26,090
也就是说 Twitter URL或其开头 让我们这样说吧 

1934
01:36:26,090 --> 01:36:31,520
继续并替换“https://twitter.com/” “

1935
01:36:31,520 --> 01:36:34,340
结束引用 这就是我想要取代的 

1936
01:36:34,340 --> 01:36:37,160
逗号 第二个参数 你想用什么来代替它？

1937
01:36:37,160 --> 01:36:37,880
没什么 

1938
01:36:37,880 --> 01:36:40,100
所以我真的要用双引号引用

1939
01:36:40,100 --> 01:36:42,190
以有效地进行查找和替换 

1940
01:36:42,190 --> 01:36:44,690
这就是Replace方法所做的 就像您可以做的那样

1941
01:36:44,690 --> 01:36:46,100
在Microsoft Word或Google Docs中 

1942
01:36:46,100 --> 01:36:49,280
这是程序员执行查找和替换的方式 

1943
01:36:49,280 --> 01:36:52,940
现在 让我继续并打印出用户名 

1944
01:36:52,940 --> 01:36:54,780
因此 我将使用这样的fstring 

1945
01:36:54,780 --> 01:36:57,590
我会说用户名、冒号 然后用大括号括起来 

1946
01:36:57,590 --> 01:36:59,700
用户名 只是为了更好地格式化它 

1947
01:36:59,700 --> 01:37:00,200
好的 

1948
01:37:00,200 --> 01:37:04,410
让我继续清理我的屏幕并运行twitter.py Enter URL的python 

1949
01:37:04,410 --> 01:37:12,580
我们开始吧 Https://twitter.com/davidjmalan Enter 

1950
01:37:12,580 --> 01:37:13,300
好的 

1951
01:37:13,300 --> 01:37:15,040
现在我们已经取得了一些进展 

1952
01:37:15,040 --> 01:37:17,360
今天结束了 对吧？

1953
01:37:17,360 --> 01:37:19,580
那么 这有什么不是最优的呢？

1954
01:37:19,580 --> 01:37:24,150
有人可以批评我的程序或对我的程序吹毛求疵吗？

1955
01:37:24,150 --> 01:37:27,950
它现在起作用了 但它有点脆弱 

1956
01:37:27,950 --> 01:37:31,880
我敢打赌 我们可以设计一些我认为它有效但它不起作用的场景 

1957
01:37:31,880 --> 01:37:33,890
观众：事实上 我有几个想法 

1958
01:37:33,890 --> 01:37:39,980
那么 首先 如果我们不指定HTTPS 它就会被破坏 

1959
01:37:39,980 --> 01:37:44,760
其次 如果我们在最后有一个斜杠 它也会被打破 

1960
01:37:44,760 --> 01:37:48,320
如果我们在问号之后有一个问号或别的什么 

1961
01:37:48,320 --> 01:37:49,590
它也不会起作用 

1962
01:37:49,590 --> 01:37:51,160
所以实际上有很多场景 

1963
01:37:51,160 --> 01:37:52,160
大卫·马兰：哦 我的天 

1964
01:37:52,160 --> 01:37:52,993
我是说 我们来了 

1965
01:37:52,993 --> 01:37:54,650
我假装以为我完蛋了 

1966
01:37:54,650 --> 01:37:57,920
但天哪 亚历克斯给了我们一大堆问题 

1967
01:37:57,920 --> 01:38:01,700
简单地说 如果它不是HTTPS 而是HTTP呢？

1968
01:38:01,700 --> 01:38:03,590
稍微不那么安全 但我还是应该

1969
01:38:03,590 --> 01:38:05,713
能够以编程方式容忍这一点 

1970
01:38:05,713 --> 01:38:07,130
如果协议不在那里怎么办？

1971
01:38:07,130 --> 01:38:09,740
如果用户只需输入twitter.com/davidjmaran怎么办？

1972
01:38:09,740 --> 01:38:12,680
如果能容忍这一点而不是表现出错误 那就好了

1973
01:38:12,680 --> 01:38:14,150
让我输入协议 

1974
01:38:14,150 --> 01:38:14,660
为什么？

1975
01:38:14,660 --> 01:38:16,050
它的用户体验并不好 

1976
01:38:16,050 --> 01:38:20,030
如果它在用户名的末尾有一个斜杠或一个问号怎么办？

1977
01:38:20,030 --> 01:38:22,500
如果你想一想你在网上看到的URL 

1978
01:38:22,500 --> 01:38:24,920
通常会有更多的信息 特别是

1979
01:38:24,920 --> 01:38:26,540
如果它被分享在社交媒体上 

1980
01:38:26,540 --> 01:38:28,640
可能有一个HTTP参数 可以这么说 

1981
01:38:28,640 --> 01:38:30,230
只是我们不想要的东西 

1982
01:38:30,230 --> 01:38:34,880
可能会有一个www.twitter.com 我也没有预料到 但确实是这样

1983
01:38:34,880 --> 01:38:37,360
如果您也转到该URL 就可以了 

1984
01:38:37,360 --> 01:38:39,540
因此 有太多事情可能会出错 

1985
01:38:39,540 --> 01:38:43,010
即使我回到前面那个假想的例子 

1986
01:38:43,010 --> 01:38:45,350
如果我运行这个程序 然后说--

1987
01:38:45,350 --> 01:38:52,610
“我的用户名是https://twitter.com/davidjmalan ”

1988
01:38:52,610 --> 01:38:53,540
进来吧 

1989
01:38:53,540 --> 01:38:58,570
嗯 这也不是真的起作用--它消除了--实际上--

1990
01:38:58,570 --> 01:39:01,730
[笑]好的 实际上这种方法奏效了 

1991
01:39:01,730 --> 01:39:05,390
但这里的目标是实际获取用户的用户名 

1992
01:39:05,390 --> 01:39:08,210
不是描述用户用户名的英文句子 

1993
01:39:08,210 --> 01:39:11,150
所以我会争辩说 即使我只是意外地创造了

1994
01:39:11,150 --> 01:39:13,670
完全正确的英语语法 我没有

1995
01:39:13,670 --> 01:39:15,860
正确提取Twitter用户名 

1996
01:39:15,860 --> 01:39:19,890
我不希望像“我的用户名是”这样的词作为我输入的一部分 

1997
01:39:19,890 --> 01:39:22,940
那么 我们如何着手改善这一点 或许还能逐步减少

1998
01:39:22,940 --> 01:39:24,530
在这些问题中一个接一个地解决？

1999
01:39:24,530 --> 01:39:26,280
好吧 让我把我的屏幕清理一下 

2000
01:39:26,280 --> 01:39:27,780
让我回到我的准则上来 

2001
01:39:27,780 --> 01:39:31,640
让我不只是替换它 而是让我做一些其他的事情 

2002
01:39:31,640 --> 01:39:34,040
我将继续 而不是使用替换 

2003
01:39:34,040 --> 01:39:36,950
我将使用另一个名为emovePrefix的函数 

2004
01:39:36,950 --> 01:39:42,060
前缀是一个字符串或子字符串 位于另一个字符串的开头 

2005
01:39:42,060 --> 01:39:45,320
所以如果我删除前缀 这个函数就不需要第二个参数了 

2006
01:39:45,320 --> 01:39:46,220
我只需要一个 

2007
01:39:46,220 --> 01:39:48,540
您要删除什么前缀？

2008
01:39:48,540 --> 01:39:51,680
所以这至少现在可以解决这个问题了

2009
01:39:51,680 --> 01:39:54,860
描述了像输入一个完整的句子一样 URL在那里 

2010
01:39:54,860 --> 01:39:57,600
但这并不是在开始 只是在结束 

2011
01:39:57,600 --> 01:39:59,930
所以在这里 这仍然是不正确的 

2012
01:39:59,930 --> 01:40:04,100
但是我们不会创建这个看起来很奇怪的输出 只删除URL部分

2013
01:40:04,100 --> 01:40:05,360
输入的--

2014
01:40:05,360 --> 01:40:11,330
“我的用户名是https://twitter.com/davidjmalan.”

2015
01:40:11,330 --> 01:40:16,700
不久前 它确实删除了URL 只留下了davidjmaran 

2016
01:40:16,700 --> 01:40:17,990
这仍然不是完美的 

2017
01:40:17,990 --> 01:40:21,830
但至少现在 它没有奇怪地删除URL

2018
01:40:21,830 --> 01:40:23,030
然后离开英国人 

2019
01:40:23,030 --> 01:40:24,420
它只是让它自生自灭 

2020
01:40:24,420 --> 01:40:26,600
所以也许我能更好地处理这件事 但至少

2021
01:40:26,600 --> 01:40:30,710
它把它从我可能预料到的那部分绳子上去掉了 

2022
01:40:30,710 --> 01:40:32,550
那我们在这里还能做什么呢？

2023
01:40:32,550 --> 01:40:35,180
事实证明 正则表达式只是

2024
01:40:35,180 --> 01:40:37,940
让我们更准确地表达模式 

2025
01:40:37,940 --> 01:40:41,180
我们可以花一整天的时间使用一大堆不同的Python函数

2026
01:40:41,180 --> 01:40:44,810
比如RemvePrefix 或Remove and strial 以及其他 还有一些

2027
01:40:44,810 --> 01:40:47,240
让我们找到正确的解决方案 

2028
01:40:47,240 --> 01:40:50,310
但正则表达式只是允许您更简洁地 

2029
01:40:50,310 --> 01:40:55,040
诚然 更隐晦地表达这些模式和目标 

2030
01:40:55,040 --> 01:40:57,260
我们已经从括号中看到 它可以

2031
01:40:57,260 --> 01:41:00,170
不仅用于将符号组合在一起作为集合

2032
01:41:00,170 --> 01:41:05,180
但为了捕捉信息 我们现在有一个非常强大的工具

2033
01:41:05,180 --> 01:41:06,630
在我们的工具包里 

2034
01:41:06,630 --> 01:41:07,800
那就让我来做吧 

2035
01:41:07,800 --> 01:41:12,530
让我继续在这里重新开始 并导入Re库

2036
01:41:12,530 --> 01:41:14,450
就像以前一样 在我节目的顶端 

2037
01:41:14,450 --> 01:41:17,900
我仍然将通过相同的代码行获取用户的URL 

2038
01:41:17,900 --> 01:41:20,970
但我现在还将使用另一个函数 

2039
01:41:20,970 --> 01:41:24,950
事实证明 不只是re.earch或re.Match 

2040
01:41:24,950 --> 01:41:26,060
或者重新进行完全匹配 

2041
01:41:26,060 --> 01:41:30,860
正则表达式库中也有re.sub. 这里的“sub.”

2042
01:41:30,860 --> 01:41:32,000
意思是“替身”

2043
01:41:32,000 --> 01:41:35,220
这需要更多的论点 但它们相当直截了当 

2044
01:41:35,220 --> 01:41:38,990
Re.Sub的第一个参数是模式 即正则表达式

2045
01:41:38,990 --> 01:41:40,280
你想要找的东西 

2046
01:41:40,280 --> 01:41:43,160
然后你有一个替换的字符串--你要做什么

2047
01:41:43,160 --> 01:41:45,470
你想把那个图案换成吗？

2048
01:41:45,470 --> 01:41:47,390
你想在哪里做这一切？

2049
01:41:47,390 --> 01:41:51,265
好的 您传入要对其进行替换的字符串 

2050
01:41:51,265 --> 01:41:54,140
然后还有一些其他的论点 我现在会对此挥手致意 

2051
01:41:54,140 --> 01:41:56,240
其中有同样的旗帜和一位伯爵 

2052
01:41:56,240 --> 01:41:58,970
比如 你想做多少次查找和替换？

2053
01:41:58,970 --> 01:42:01,670
你想让它做所有的事吗？你想只做一件吗 

2054
01:42:01,670 --> 01:42:04,070
诸如此类 你也可以在那里有更多的控制权 

2055
01:42:04,070 --> 01:42:06,770
就像你在谷歌文档或Microsoft Word中所做的那样 

2056
01:42:06,770 --> 01:42:10,160
好吧 让我回到我的代码 让我来做这件事 

2057
01:42:10,160 --> 01:42:15,020
我将继续下去 不是搜索 而是re.sub.替换 

2058
01:42:15,020 --> 01:42:18,320
我将传递以下正则表达式 

2059
01:42:18,320 --> 01:42:25,610
Https://twitter.com/“ 然后我将结束我的引述 

2060
01:42:25,610 --> 01:42:27,860
现在我想用什么来取代它呢？

2061
01:42:27,860 --> 01:42:31,460
嗯 就像前面使用简单的字符串替换函数一样 

2062
01:42:31,460 --> 01:42:34,380
我想用什么都不用来取代它 只是干脆把它去掉 

2063
01:42:34,380 --> 01:42:37,730
但我想传入什么字符串才能完成此操作呢？

2064
01:42:37,730 --> 01:42:39,810
来自用户的URL 

2065
01:42:39,810 --> 01:42:44,360
现在 让我继续赋值reo的返回值

2066
01:42:44,360 --> 01:42:46,100
设置为一个名为UserName的变量 

2067
01:42:46,100 --> 01:42:49,460
因此 Resub.的人生目标 再一次 是用

2068
01:42:49,460 --> 01:42:52,490
某个正则表达式的一些值的一些次数 

2069
01:42:52,490 --> 01:42:56,360
它本质上是使用正则表达式查找和替换 

2070
01:42:56,360 --> 01:42:59,090
并将结果字符串返回给您

2071
01:42:59,090 --> 01:43:01,400
一旦你完成了所有这些替换 

2072
01:43:01,400 --> 01:43:04,850
所以现在我的代码的最后一行可以和以前一样 打印--

2073
01:43:04,850 --> 01:43:08,960
我将使用fstring、用户名、冒号 然后用大括号括起来 

2074
01:43:08,960 --> 01:43:09,590
用户名 

2075
01:43:09,590 --> 01:43:12,300
这样我就可以打印出来了 

2076
01:43:12,300 --> 01:43:12,800
好的 

2077
01:43:12,800 --> 01:43:14,300
让我们试一试 看看会发生什么 

2078
01:43:14,300 --> 01:43:17,390
我将清除我的终端窗口 运行twitter.py的python 

2079
01:43:17,390 --> 01:43:23,690
我们来了 https://twitter.com/davidjmalan.

2080
01:43:23,690 --> 01:43:25,940
祈祷我的手指 然后按回车键 

2081
01:43:25,940 --> 01:43:28,580
好了 现在我们开业了 

2082
01:43:28,580 --> 01:43:30,560
但它仍然有点脆弱 

2083
01:43:30,560 --> 01:43:34,730
所以让我问问大家 我现在应该有什么问题

2084
01:43:34,730 --> 01:43:36,125
更进一步的打击？

2085
01:43:36,125 --> 01:43:38,000
以前也有人这么说过 但让我们明确一点 

2086
01:43:38,000 --> 01:43:40,460
还有什么一个或多个问题仍然存在？

2087
01:43:40,460 --> 01:43:44,690
观众：协议和域名前缀[INAUDIBLE]..

2088
01:43:44,690 --> 01:43:45,440
大卫·马兰：很好 

2089
01:43:45,440 --> 01:43:48,020
协议 所以HTTP与HTTPS 

2090
01:43:48,020 --> 01:43:51,980
也许子域名 www 它应该在那里还是不在那里？

2091
01:43:51,980 --> 01:43:54,200
这里还有其他几个错误 

2092
01:43:54,200 --> 01:43:55,770
让我真的留在这个团体里 

2093
01:43:55,770 --> 01:43:59,600
目前的解决方案还有哪些其他缺点？

2094
01:43:59,600 --> 01:44:03,590
听众：如果我们像你以前那样使用一句话 

2095
01:44:03,590 --> 01:44:07,940
我们将面临同样的问题 因为它没有考虑到

2096
01:44:07,940 --> 01:44:11,150
在文本示例的第一部分中 

2097
01:44:11,150 --> 01:44:11,900
大卫·马兰：很好 

2098
01:44:11,900 --> 01:44:16,220
我可能仍然允许URL左边的一些单词 一些英语

2099
01:44:16,220 --> 01:44:17,810
因为我没有用我的^符号 

2100
01:44:17,810 --> 01:44:18,770
所以我会解决这个问题的 

2101
01:44:18,770 --> 01:44:22,450
对这里的不足之处有什么最后的看法吗？

2102
01:44:22,450 --> 01:44:26,993
观众：嗯 它可能是一个HTTP 也可能有不到两个斜杠 

2103
01:44:26,993 --> 01:44:27,660
大卫·马兰：好的 

2104
01:44:27,660 --> 01:44:28,493
所以它可能是HTTP 

2105
01:44:28,493 --> 01:44:30,910
我认为在礼仪方面也提到了这一点 

2106
01:44:30,910 --> 01:44:32,570
削减幅度可能不到两次 

2107
01:44:32,570 --> 01:44:34,550
我不会担心的 

2108
01:44:34,550 --> 01:44:38,720
如果用户给了我 而不是两个 那就是用户的错误 

2109
01:44:38,720 --> 01:44:41,420
我可以容忍 但你知道吗 在这一点上

2110
01:44:41,420 --> 01:44:45,570
我可以用一条错误消息对他们大喊大叫 说：请修改您的输入 

2111
01:44:45,570 --> 01:44:48,890
否则 我们可能会整天呆在这里 试图处理所有可能的打字错误 

2112
01:44:48,890 --> 01:44:51,740
目前 我认为从可用性的角度来看 

2113
01:44:51,740 --> 01:44:54,560
或用户体验 UX 至少让我们

2114
01:44:54,560 --> 01:44:59,130
容忍所有可能的有效输入或合理输入(如果您愿意) 

2115
01:44:59,130 --> 01:45:01,940
所以让我说到这里 让我开始在这里慢慢地分析这些东西 

2116
01:45:01,940 --> 01:45:03,530
我们可以解决哪些问题？

2117
01:45:03,530 --> 01:45:08,735
好吧 让我提议我们首先解决匹配的问题

2118
01:45:08,735 --> 01:45:10,110
从字符串的开头开始 

2119
01:45:10,110 --> 01:45:11,900
所以让我在开头加上^ 

2120
01:45:11,900 --> 01:45:15,362
不过 让我在结尾处不加$符号 对吗？

2121
01:45:15,362 --> 01:45:17,570
因为我不想一直匹配到最后 

2122
01:45:17,570 --> 01:45:19,950
因为我想容忍那里的用户名 

2123
01:45:19,950 --> 01:45:23,210
所以我想我们只需要那里有^符号 

2124
01:45:23,210 --> 01:45:26,000
有一个微妙的漏洞 但还没有人提到 

2125
01:45:26,000 --> 01:45:30,860
让我来强调一下 看看你现在会不会想到它 

2126
01:45:30,860 --> 01:45:32,730
在我的屏幕上有一点微妙 

2127
01:45:32,730 --> 01:45:37,610
我在这里用蓝色突出显示了最后一个错误--

2128
01:45:37,610 --> 01:45:39,860
也许屏幕上会有一些微笑 对吧？

2129
01:45:39,860 --> 01:45:41,400
我们能在这里牵一只手吗？

2130
01:45:41,400 --> 01:45:46,730
为什么我要在twitter.com上突出显示这个点 尽管它肯定是

2131
01:45:46,730 --> 01:45:47,900
应该在那里吗？

2132
01:45:47,900 --> 01:45:52,610
观众：不带反斜杠的圆点表示除换行符以外的任何字符 

2133
01:45:52,610 --> 01:45:53,990
大卫·马兰：是的 确实如此 

2134
01:45:53,990 --> 01:45:55,500
它指的是任何角色 

2135
01:45:55,500 --> 01:46:01,555
所以我可以输入类似推特的东西 或者推特上的任何东西 

2136
01:46:01,555 --> 01:46:03,660
而这实际上是可以容忍的 

2137
01:46:03,660 --> 01:46:07,230
这并不是很糟糕 因为用户为什么要这样做？

2138
01:46:07,230 --> 01:46:09,410
但如果我想要正确 我想要正确

2139
01:46:09,410 --> 01:46:13,280
能够正确地测试我自己的代码 我真的应该正确地完成这个细节 

2140
01:46:13,280 --> 01:46:16,040
所以这也是一个很容易解决的问题 但这是一个常见的错误 

2141
01:46:16,040 --> 01:46:19,190
任何时候 当您编写的正则表达式恰好涉及

2142
01:46:19,190 --> 01:46:23,210
特殊符号 如URL或域名中的圆点 

2143
01:46:23,210 --> 01:46:27,230
在涉及货币的东西中有一个$符号 记住你可能 确实 

2144
01:46:27,230 --> 01:46:30,390
需要用这里这样的反斜杠来转义 

2145
01:46:30,390 --> 01:46:30,890
好的 

2146
01:46:30,890 --> 01:46:34,040
让我具体问一下小组关于协议的问题 

2147
01:46:34,040 --> 01:46:36,690
因此 HTTPS在世界上是一件好事 

2148
01:46:36,690 --> 01:46:37,860
意思是安全 

2149
01:46:37,860 --> 01:46:39,360
正在使用加密 

2150
01:46:39,360 --> 01:46:41,840
因此 一般而言 您喜欢看到HTTPS 

2151
01:46:41,840 --> 01:46:46,370
但你仍然可以看到人们打字或复制粘贴HTTP 

2152
01:46:46,370 --> 01:46:50,960
最简单的解决办法是什么 就像已经提出的那样 

2153
01:46:50,960 --> 01:46:54,380
是否同时使用HTTP和HTTPS？

2154
01:46:54,380 --> 01:46:56,600
我要提议我能做到这一点 

2155
01:46:56,600 --> 01:47:02,630
我可以使用HTTP垂直条形图或HTTPS 也就是A或B 

2156
01:47:02,630 --> 01:47:04,490
但我想我可以比这更聪明 

2157
01:47:04,490 --> 01:47:06,770
我可以让我的代码更简洁一些 

2158
01:47:06,770 --> 01:47:13,400
这里有什么关于容忍HTTP或HTTPS的建议吗？

2159
01:47:13,400 --> 01:47:16,845
观众：我们可以试着在S后面加个问号 

2160
01:47:16,845 --> 01:47:17,720
大卫·马兰：太好了 

2161
01:47:17,720 --> 01:47:19,340
只需使用问号即可 

2162
01:47:19,340 --> 01:47:21,110
这两个都是可行的解决方案 

2163
01:47:21,110 --> 01:47:23,330
如果你想在你的代码中表现得非常明确 那没问题 

2164
01:47:23,330 --> 01:47:28,730
使用括号 并使用HTTP或HTTPS 这样您 读者 您的老板 

2165
01:47:28,730 --> 01:47:31,410
你的老师完全知道你在做什么 

2166
01:47:31,410 --> 01:47:35,090
但如果你一直采取更冗长的方法 

2167
01:47:35,090 --> 01:47:37,760
当然 它实际上可能会变得不那么可读性

2168
01:47:37,760 --> 01:47:40,580
一旦您的正则表达式变得这么大 而不是这么大 

2169
01:47:40,580 --> 01:47:42,290
所以 让我们尽我们所能节省空间 

2170
01:47:42,290 --> 01:47:45,030
我认为这是非常合理的 所以

2171
01:47:45,030 --> 01:47:47,640
只要您有阅读正则表达式的习惯

2172
01:47:47,640 --> 01:47:50,390
并知道问号并不意味着字面上的问号 

2173
01:47:50,390 --> 01:47:52,970
但它的意思是零或之前的一件事 

2174
01:47:52,970 --> 01:47:56,510
我认为我们实际上已经将S设置为可选的 

2175
01:47:56,510 --> 01:47:58,410
现在 我还能做什么？

2176
01:47:58,410 --> 01:48:03,860
好吧 假设我们想要容忍WWW点 它可能存在也可能不存在 

2177
01:48:03,860 --> 01:48:06,050
但如果你打开浏览器 它就会起作用 

2178
01:48:06,050 --> 01:48:07,220
我可以做到这一点

2179
01:48:07,220 --> 01:48:11,720
WWW点--等等 我想要一个反斜杠 这样我就不会

2180
01:48:11,720 --> 01:48:13,310
重复和以前一样的错误 

2181
01:48:13,310 --> 01:48:19,220
但这也不好 因为我想忍受在那里或不在

2182
01:48:19,220 --> 01:48:19,760
在那里 

2183
01:48:19,760 --> 01:48:21,890
现在我只是要求它在那里 

2184
01:48:21,890 --> 01:48:24,290
但我认为我可以采取同样的方法 

2185
01:48:24,290 --> 01:48:25,550
有什么建议吗？

2186
01:48:25,550 --> 01:48:27,200
我怎么做才能让WWW 

2187
01:48:27,200 --> 01:48:30,230
可有可无 就为了敲打这个家？

2188
01:48:30,230 --> 01:48:32,480
观众：我们可以分组--

2189
01:48:32,480 --> 01:48:35,835
画一个正方形和一个问号 

2190
01:48:35,835 --> 01:48:36,710
大卫·马兰：太好了 

2191
01:48:36,710 --> 01:48:38,825
因此 问号又是一个简短的答案 

2192
01:48:38,825 --> 01:48:40,700
但这一次我们必须更聪明一点 

2193
01:48:40,700 --> 01:48:43,130
正如玛丽亚所指出的 我们现在需要括号 

2194
01:48:43,130 --> 01:48:46,160
因为如果我在圆点后面加一个问号 

2195
01:48:46,160 --> 01:48:48,147
这只意味着点是可选的 

2196
01:48:48,147 --> 01:48:50,480
这是错误的 因为我们不希望用户输入

2197
01:48:50,480 --> 01:48:56,690
在W-T-W-I-T-T-E-R 我们希望圆点在那里 或者根本不存在

2198
01:48:56,690 --> 01:48:57,490
www.w.

2199
01:48:57,490 --> 01:49:00,080
所以我们需要把这整件事归类在一起 

2200
01:49:00,080 --> 01:49:04,160
在那里放一个括号 然后放一个括号 而不是在第三个W之后 

2201
01:49:04,160 --> 01:49:09,920
在点之后 所以整个东西要么在那里 要么不在那里 

2202
01:49:09,920 --> 01:49:12,338
我们还能在这里做些什么呢？

2203
01:49:12,338 --> 01:49:14,630
还有一件事是我们应该容忍的 

2204
01:49:14,630 --> 01:49:16,922
以前已经说过了 我会把这一条摘掉 

2205
01:49:16,922 --> 01:49:18,260
协议是怎么回事？

2206
01:49:18,260 --> 01:49:23,805
例如 如果用户只是不键入或不复制粘贴http：//

2207
01:49:23,805 --> 01:49:26,660
或https://？

2208
01:49:26,660 --> 01:49:28,460
老实说 你和我都没有这个习惯 

2209
01:49:28,460 --> 01:49:31,730
总体而言 现在甚至不再打字了 

2210
01:49:31,730 --> 01:49:34,010
你只要让浏览器帮你找出来 

2211
01:49:34,010 --> 01:49:36,590
并自动添加它 

2212
01:49:36,590 --> 01:49:38,900
所以这张看起来更像一张嘴 

2213
01:49:38,900 --> 01:49:43,520
但如果我想让蓝色的这整件事是可选的 

2214
01:49:43,520 --> 01:49:46,880
这实际上与玛丽亚刚才提出的解决方案相同 

2215
01:49:46,880 --> 01:49:49,550
接下来我要在这里加上一个括号 

2216
01:49:49,550 --> 01:49:53,960
在两个斜杠后面加上一个括号 然后是一个问题

2217
01:49:53,960 --> 01:49:57,120
标记 以使整个操作也成为可选的 

2218
01:49:57,120 --> 01:49:58,320
这样就可以了 

2219
01:49:58,320 --> 01:50:00,920
把这整件事做成这件事完全没问题

2220
01:50:00,920 --> 01:50:06,480
可选的 或者说里面 这个小东西 就是S的可选的 

2221
01:50:06,480 --> 01:50:09,350
只要我一次又一次地应用同样的原则 

2222
01:50:09,350 --> 01:50:11,390
无论是小规模的还是大规模的 

2223
01:50:11,390 --> 01:50:16,680
将其中一个嵌套在另一个中是完全没有问题的 

2224
01:50:16,680 --> 01:50:20,730
现在对这些改进中的任何一个提出问题

2225
01:50:20,730 --> 01:50:23,730
对于这个解析 这个对推特的分析？

2226
01:50:23,730 --> 01:50:29,850
观众：如果我们在这个WWW点旁边加一个竖线 会怎么样？

2227
01:50:29,850 --> 01:50:31,930
大卫·马兰：如果我们在那里用竖条呢？

2228
01:50:31,930 --> 01:50:34,110
所以我们也可以做类似的事情 

2229
01:50:34,110 --> 01:50:36,690
我们可以做这样的事情 

2230
01:50:36,690 --> 01:50:41,370
我可以用www.来代替问号 或者什么都不做

2231
01:50:41,370 --> 01:50:43,680
只留下那个和圆括号 

2232
01:50:43,680 --> 01:50:45,160
这也很好 

2233
01:50:45,160 --> 01:50:47,743
我个人倾向于不喜欢它 因为它稍微少了一点

2234
01:50:47,743 --> 01:50:49,035
对我来说很明显--等一下 

2235
01:50:49,035 --> 01:50:52,260
这是故意的吗 还是我忘了把我的想法

2236
01:50:52,260 --> 01:50:53,460
在垂直横杆之后？

2237
01:50:53,460 --> 01:50:57,630
但这也是允许的 如果你是这个意思的话 

2238
01:50:57,630 --> 01:50:59,790
关于我们把东西放在哪里的其他问题 

2239
01:50:59,790 --> 01:51:03,090
我们把协议也设为可选的吗？

2240
01:51:03,090 --> 01:51:07,260
观众：如果我们有括号 会怎么样？

2241
01:51:07,260 --> 01:51:10,173
在里面我们有另一个括号 还有另一个括号？

2242
01:51:10,173 --> 01:51:11,590
会不会互相干扰？

2243
01:51:11,590 --> 01:51:14,298
大卫·马兰：如果你把括号放在括号里 

2244
01:51:14,298 --> 01:51:15,660
太好了 完全没问题 

2245
01:51:15,660 --> 01:51:19,680
事实上 这应该是今天令人放心的教训之一 

2246
01:51:19,680 --> 01:51:23,670
诚然 这些正则表达式中的每一个都很复杂 

2247
01:51:23,670 --> 01:51:27,570
我只是应用了完全相同的原则和语法

2248
01:51:27,570 --> 01:51:29,110
再三 

2249
01:51:29,110 --> 01:51:31,988
所以把括号放在括号里是完全可以的

2250
01:51:31,988 --> 01:51:33,780
如果他们各自解决不同的问题 

2251
01:51:33,780 --> 01:51:37,200
事实上 我今天最强调的一课

2252
01:51:37,200 --> 01:51:41,250
如果你试着写出来你不会高兴的

2253
01:51:41,250 --> 01:51:44,820
一次完成整个复杂的正则表达式 

2254
01:51:44,820 --> 01:51:47,310
如果你像我一样 你会失败的 

2255
01:51:47,310 --> 01:51:49,428
你将很难找到这个错误 

2256
01:51:49,428 --> 01:51:50,970
因为我的天 看看这些东西 

2257
01:51:50,970 --> 01:51:53,880
即使在这么多年后的我看来 它们也是神秘的 

2258
01:51:53,880 --> 01:51:57,240
我认为 更好的方法是 无论你是编程新手

2259
01:51:57,240 --> 01:52:01,110
或者像我这样老了 就是带着这些孩子

2260
01:52:01,110 --> 01:52:03,750
步骤 这些渐进的步骤 你可以做一些简单的事情 

2261
01:52:03,750 --> 01:52:04,710
你要确保它起作用 

2262
01:52:04,710 --> 01:52:07,080
你再增加一项功能 确保它能正常工作 

2263
01:52:07,080 --> 01:52:09,120
再添加一项功能 确保其正常工作 

2264
01:52:09,120 --> 01:52:12,360
希望到最后 因为你已经完成了其中的每一步

2265
01:52:12,360 --> 01:52:15,490
在某个时候 整件事对你来说都会有意义的 

2266
01:52:15,490 --> 01:52:20,310
但你也会在每一次转弯时都正确地完成每一步 

2267
01:52:20,310 --> 01:52:23,970
所以 请务必避免尝试的倾向

2268
01:52:23,970 --> 01:52:26,550
想出又长又复杂的正则表达式

2269
01:52:26,550 --> 01:52:29,580
一下子 因为这不是很好地利用时间

2270
01:52:29,580 --> 01:52:32,100
如果你盯着它 试图找到你认为的错误

2271
01:52:32,100 --> 01:52:35,230
如果你做的事情更循序渐进 你可能会发现 

2272
01:52:35,230 --> 01:52:35,730
好的 

2273
01:52:35,730 --> 01:52:38,160
可以说 仍然存在至少一个问题

2274
01:52:38,160 --> 01:52:40,050
有了这个解决方案 即使我是

2275
01:52:40,050 --> 01:52:44,040
调用re.Sub以不使用任何内容替换URL 

2276
01:52:44,040 --> 01:52:47,410
引用 不引用 然后在我的最后一行代码中 第6行 

2277
01:52:47,410 --> 01:52:49,590
我只是盲目地假设这一切都奏效了 

2278
01:52:49,590 --> 01:52:52,200
接下来 我将打印出用户名 

2279
01:52:52,200 --> 01:52:53,520
但如果用户--

2280
01:52:53,520 --> 01:52:56,310
如果我在这里清空屏幕并运行twitter.py的python--

2281
01:52:56,310 --> 01:52:58,110
甚至连Twitter URL都不输入？

2282
01:52:58,110 --> 01:53:02,805
如果他们做了像https://google.com/ 这样的事情怎么办

2283
01:53:02,805 --> 01:53:06,090
就像完全无关 不管是什么原因 

2284
01:53:06,090 --> 01:53:08,970
输入 这不是他们的Twitter用户名 

2285
01:53:08,970 --> 01:53:12,300
所以我们需要一些条件逻辑 我认为 

2286
01:53:12,300 --> 01:53:15,690
所以为了这个程序 我们只打印出

2287
01:53:15,690 --> 01:53:19,920
或者 在后端系统中 我们只保存到数据库或CSV中

2288
01:53:19,920 --> 01:53:24,090
如果我们确实匹配了正确的模式 请将用户名归档 

2289
01:53:24,090 --> 01:53:29,010
因此 与其使用对清理数据有用的re.sub. 

2290
01:53:29,010 --> 01:53:32,340
就像我们在这里做的那样 处理掉我们不想要的东西 

2291
01:53:32,340 --> 01:53:37,080
为什么我们不回到我们今天开始的地方去重新搜索 

2292
01:53:37,080 --> 01:53:41,100
并用它来解决同样的问题 但以一种有条件的方式 

2293
01:53:41,100 --> 01:53:44,490
因此我可以自信地说 是或不是 在我的节目结束时 

2294
01:53:44,490 --> 01:53:47,260
这里是用户名 还是这里不是？

2295
01:53:47,260 --> 01:53:48,300
所以现在让我继续下去 

2296
01:53:48,300 --> 01:53:50,340
我会在这里清理我的终端窗口 

2297
01:53:50,340 --> 01:53:52,560
我要保留大部分--

2298
01:53:52,560 --> 01:53:55,800
我将保持前两行 与我导入Re的位置相同 

2299
01:53:55,800 --> 01:53:57,520
然后我从用户那里获得URL 

2300
01:53:57,520 --> 01:53:59,010
但这一次 让我们开始吧 

2301
01:53:59,010 --> 01:54:03,630
这一次让我们搜索 使用re.earch而不是re.sub.

2302
01:54:03,630 --> 01:54:04,470
以下是 

2303
01:54:04,470 --> 01:54:09,510
我将从字符串的开头开始匹配 

2304
01:54:09,510 --> 01:54:13,380
问号使S成为可选的 冒号 斜杠 斜杠 

2305
01:54:13,380 --> 01:54:19,710
我将把我的www设置为可选 在那里打上问号 

2306
01:54:19,710 --> 01:54:24,000
然后是一个带有文字圆点的twitter.com 这样我就可以在这个问题上保持领先 

2307
01:54:24,000 --> 01:54:26,640
也是 然后是一条斜线 

2308
01:54:26,640 --> 01:54:30,330
然后 这就是Davidjmaran应该去的地方 

2309
01:54:30,330 --> 01:54:31,710
我如何检测到这一点？

2310
01:54:31,710 --> 01:54:35,580
好吧 我想我可以容忍URL末尾的任何内容 

2311
01:54:35,580 --> 01:54:38,532
好的 最后的$符号 结束引号 

2312
01:54:38,532 --> 01:54:40,740
目前 我要规定我们不能

2313
01:54:40,740 --> 01:54:43,830
我会担心结尾处的问号或散列 

2314
01:54:43,830 --> 01:54:45,600
就像URL中的片段ID一样 

2315
01:54:45,600 --> 01:54:48,630
为了简单起见 我们现在假设URL只是

2316
01:54:48,630 --> 01:54:50,610
仅以用户名结尾 

2317
01:54:50,610 --> 01:54:52,110
现在我该怎么办呢？

2318
01:54:52,110 --> 01:54:54,330
嗯 我想特别搜索这个URL 

2319
01:54:54,330 --> 01:54:58,230
我要忽略凯斯 所以请再说一遍 

2320
01:54:58,230 --> 01:55:00,840
应用从以前学到的同样的教训 

2321
01:55:00,840 --> 01:55:05,717
Re.search、recall将向您返回您捕获的匹配项 

2322
01:55:05,717 --> 01:55:07,050
那么 我想捕捉什么呢？

2323
01:55:07,050 --> 01:55:12,420
好的 我想在这里捕获twitter.com URL右侧的所有内容 

2324
01:55:12,420 --> 01:55:17,560
因此 让我用括号将应该是用户用户名的内容括起来 

2325
01:55:17,560 --> 01:55:21,580
不是为了让它们成为可选的 而是说 “捕捉这组字符 ”

2326
01:55:21,580 --> 01:55:24,730
现在 re.earch recall 返回一个答案 

2327
01:55:24,730 --> 01:55:28,600
Matches将再次成为我的变量名 但我可以随心所欲地命名它 

2328
01:55:28,600 --> 01:55:29,950
然后我就能做到这一点 

2329
01:55:29,950 --> 01:55:33,680
如果匹配 现在我知道我能做到 

2330
01:55:33,680 --> 01:55:36,370
让我们打印出格式字符串用户名冒号 

2331
01:55:36,370 --> 01:55:40,190
然后我想打印出什么呢？

2332
01:55:40,190 --> 01:55:44,440
嗯 我想我想把比赛打印出来 第一组是我的比赛

2333
01:55:44,440 --> 01:55:45,700
用户名 

2334
01:55:45,700 --> 01:55:46,210
好的 

2335
01:55:46,210 --> 01:55:47,980
那么 我在做什么 只是为了回顾一下？

2336
01:55:47,980 --> 01:55:49,960
第1行 我正在导入库 

2337
01:55:49,960 --> 01:55:52,280
第2行 我从用户那里获取URL 

2338
01:55:52,280 --> 01:55:53,230
因此 这并不是什么新鲜事 

2339
01:55:53,230 --> 01:55:59,740
第5行 我正在搜索用户的URL 如这里的第二个参数所示 

2340
01:55:59,740 --> 01:56:03,220
对于此正则表达式 此模式 

2341
01:56:03,220 --> 01:56:07,720
我用圆括号将圆点+括起来 

2342
01:56:07,720 --> 01:56:11,380
所以他们最终会被捕获 所以我可以提取 

2343
01:56:11,380 --> 01:56:14,320
在最后一个场景中 是指用户的用户名 

2344
01:56:14,320 --> 01:56:18,580
如果我真的找到了匹配项 而匹配项不是零 

2345
01:56:18,580 --> 01:56:23,470
它实际上包含一些匹配项 然后且仅在那时 打印出用户名 

2346
01:56:23,470 --> 01:56:25,420
这样的话 现在让我试试这个 

2347
01:56:25,420 --> 01:56:31,110
如果我运行twitter.py的PYTHON并输入https://www.google.com/ 

2348
01:56:31,110 --> 01:56:33,370
现在什么都不打印了 

2349
01:56:33,370 --> 01:56:36,010
所以我至少解决了我们刚才看到的错误 

2350
01:56:36,010 --> 01:56:38,050
我只是假设我的代码起作用了 

2351
01:56:38,050 --> 01:56:44,000
现在 我正在确保我已经搜索并找到了Twitter URL前缀 

2352
01:56:44,000 --> 01:56:44,500
好的 

2353
01:56:44,500 --> 01:56:45,917
好了 现在让我们来真的来吧 

2354
01:56:45,917 --> 01:56:51,730
Twitter.py https://twitter.com/davidjmalan.的巨蟒

2355
01:56:51,730 --> 01:56:55,420
但请注意 我可以使用HTTP 我可以使用WWW 

2356
01:56:55,420 --> 01:56:58,430
我只需要在这里继续 然后按Enter键 

2357
01:56:58,430 --> 01:57:01,730
呃 没有 

2358
01:57:01,730 --> 01:57:05,480
到底出了什么问题？

2359
01:57:05,480 --> 01:57:08,060
这个更微妙一些 

2360
01:57:08,060 --> 01:57:13,027
但是为什么Matchs.Group 1什么都不包含呢？

2361
01:57:13,027 --> 01:57:13,610
等一下 

2362
01:57:13,610 --> 01:57:15,450
让我--也许我做错了 

2363
01:57:15,450 --> 01:57:17,707
也许--也许我们需要万维网？

2364
01:57:17,707 --> 01:57:18,540
让我再运行一次 

2365
01:57:18,540 --> 01:57:24,740
我们开始吧https：// 让我们添加一个www.twitter.com/davidjmalan 

2366
01:57:24,740 --> 01:57:25,500
好吧

2367
01:57:25,500 --> 01:57:26,470
输入.

2368
01:57:26,470 --> 01:57:28,550
吼 吼 吼 

2369
01:57:28,550 --> 01:57:31,170
怎么回事？

2370
01:57:31,170 --> 01:57:32,720
观众：你必须说第二组 

2371
01:57:32,720 --> 01:57:34,520
大卫·马兰：我不得不说第二组？

2372
01:57:34,520 --> 01:57:39,140
好吧 等等--哦 对了 因为我们的子域是可选的 

2373
01:57:39,140 --> 01:57:42,560
为了使它成为可选的 我需要在这里使用括号 

2374
01:57:42,560 --> 01:57:44,070
所以我说零或上 

2375
01:57:44,070 --> 01:57:44,570
好的.

2376
01:57:44,570 --> 01:57:49,910
所以这意味着实际上 我是无意的 但通过设计

2377
01:57:49,910 --> 01:57:54,710
捕获www点 或者如果它之前不存在 

2378
01:57:54,710 --> 01:57:56,645
但我这里还有第二个匹配因为我

2379
01:57:56,645 --> 01:57:58,020
还有第二个括号

2380
01:57:58,020 --> 01:58:00,350
所以我想 是的 让我改变matches.group 1

2381
01:58:00,350 --> 01:58:02,300
到matches.group 2 让我们运行这个 

2382
01:58:02,300 --> 01:58:07,460
Python of twitter.py https://www.twitter--

2383
01:58:07,460 --> 01:58:13,070
让我们这样做 twitter.com/davidjmalan 输入 

2384
01:58:13,070 --> 01:58:15,920
现在我们拿到了用户名

2385
01:58:15,920 --> 01:58:19,040
让我再把它收紧一点 

2386
01:58:19,040 --> 01:58:21,513
如果你喜欢我们的新朋友

2387
01:58:21,513 --> 01:58:22,430
很难不喜欢 

2388
01:58:22,430 --> 01:58:26,060
如果我们喜欢我们的老朋友海象操作员 让我们继续

2389
01:58:26,060 --> 01:58:27,740
再加上这个让事情更紧密

2390
01:58:27,740 --> 01:58:31,460
让我们回到VS代码 让我们去掉不必要的条件

2391
01:58:31,460 --> 01:58:34,580
然后在这里合并 如果匹配等于这个的话

2392
01:58:34,580 --> 01:58:38,090
但是让我们将单个赋值运算符改为海象运算符 

2393
01:58:38,090 --> 01:58:40,040
现在我把事情弄得更紧了 

2394
01:58:40,040 --> 01:58:43,940
但我敢打赌 这里可能有另一个解决方案 

2395
01:58:43,940 --> 01:58:50,630
事实上 我们可以回到这最后一组语法 

2396
01:58:50,630 --> 01:58:52,940
回想一下 当我们引入这些括号时 

2397
01:58:52,940 --> 01:58:56,720
我们这样做是为了我们可以做A或B 比如 用竖条 

2398
01:58:56,720 --> 01:58:59,060
然后你甚至可以组合不止一个酒吧 

2399
01:58:59,060 --> 01:59:02,900
我们使用组来组合想法 如 www.

2400
01:59:02,900 --> 01:59:07,760
然后在底部这里有一个公认的奇怪语法 直到现在

2401
01:59:07,760 --> 01:59:08,690
未使用 

2402
01:59:08,690 --> 01:59:12,230
有一个非捕获版本的圆括号

2403
01:59:12,230 --> 01:59:15,050
如果你想逻辑地使用圆括号 

2404
01:59:15,050 --> 01:59:18,080
但你不想费心去捕捉结果 

2405
01:59:18,080 --> 01:59:20,450
这可能是一个更好的解决方案

2406
01:59:20,450 --> 01:59:23,630
因为 是的 如果我回到VS Code 

2407
01:59:23,630 --> 01:59:27,560
至少需要用括号将www点括起来

2408
01:59:27,560 --> 01:59:30,170
就像我在这里写正则表达式一样 因为我想

2409
01:59:30,170 --> 01:59:31,910
在后面加上问号

2410
01:59:31,910 --> 01:59:35,120
但我不需要那个www点回来 

2411
01:59:35,120 --> 01:59:37,580
实际上 我们只提取我们关心的数据 

2412
01:59:37,580 --> 01:59:40,280
这样我以后就不会有困惑了

2413
01:59:40,280 --> 01:59:42,120
或者我的同事 或者我的老师

2414
01:59:42,120 --> 01:59:43,860
我能怎么办？

2415
01:59:43,860 --> 01:59:48,800
这张幻灯片的语法是使用问号和冒号

2416
01:59:48,800 --> 01:59:51,410
紧接着左括号 

2417
01:59:51,410 --> 01:59:52,910
不可否认 它看起来很奇怪 

2418
01:59:52,910 --> 01:59:55,040
如果你们有编程经验

2419
01:59:55,040 --> 01:59:59,300
我可能会从三元运算符中识别语法 执行if else all in one

2420
01:59:59,300 --> 01:59:59,960
线

2421
01:59:59,960 --> 02:00:04,190
在插入语的开头加上一个问号冒号

2422
02:00:04,190 --> 02:00:08,160
意思是 我用括号把这些东西组合在一起 

2423
02:00:08,160 --> 02:00:11,640
但不 你不需要去捕捉它们

2424
02:00:11,640 --> 02:00:15,500
所以我现在可以把代码改回matches.group 1.

2425
02:00:15,500 --> 02:00:18,260
我会在这里清空屏幕 运行twitter.py的python 

2426
02:00:18,260 --> 02:00:24,350
我将再次运行https://twitter.com/davidjmalan

2427
02:00:24,350 --> 02:00:26,480
不管有没有www

2428
02:00:26,480 --> 02:00:30,590
现在 我真的找回了那个用户名 

2429
02:00:30,590 --> 02:00:37,280
对这些最后的技巧有什么问题吗？

2430
02:00:37,280 --> 02:00:40,940
观众：首先 我们能不能把

2431
02:00:40,940 --> 02:00:44,270
在Twitter的开头 然后从那里开始阅读 

2432
02:00:44,270 --> 02:00:49,700
然后在此之前摆脱所有其他的东西 

2433
02:00:49,700 --> 02:00:50,930
我们拥有的

2434
02:00:50,930 --> 02:00:56,240
然后我的第二个问题是 我想 

2435
02:00:56,240 --> 02:01:01,640
一个列表或者一个字典来对.com之类的东西进行排序 

2436
02:01:01,640 --> 02:01:05,120
因为我们有. co.uk 和类似的东西 

2437
02:01:05,120 --> 02:01:08,330
我们如何将其带入re函数？

2438
02:01:08,330 --> 02:01:09,830
大卫·马兰：一个很好的问题 但不是 

2439
02:01:09,830 --> 02:01:15,560
如果我把^移到twitter.com之前 并扔掉协议和www 

2440
02:01:15,560 --> 02:01:20,960
那么用户将不得不按字面意思键入twitter.com/username 

2441
02:01:20,960 --> 02:01:23,040
他们甚至不能输入其他东西 

2442
02:01:23,040 --> 02:01:25,170
因此 这将是一种倒退 是一种倒退 

2443
02:01:25,170 --> 02:01:29,120
至于.com、.org和.edu等等 

2444
02:01:29,120 --> 02:01:31,970
简短的答案是 这里有许多不同的解决方案 

2445
02:01:31,970 --> 02:01:37,190
如果我想严格对待.com--假设Twitter可能拥有

2446
02:01:37,190 --> 02:01:40,620
多个域名 尽管他们倾向于只使用这个域名 

2447
02:01:40,620 --> 02:01:43,800
假设他们也有像.org这样的网站 

2448
02:01:43,800 --> 02:01:47,810
您可以在这里使用更多的括号 并执行类似这样的操作--com或org 

2449
02:01:47,810 --> 02:01:50,270
我可能想进去加一个问号

2450
02:01:50,270 --> 02:01:53,060
冒号将其设置为非捕获 因为我不在乎

2451
02:01:53,060 --> 02:01:55,100
是的 我只想容忍这两种情况 

2452
02:01:55,100 --> 02:01:58,220
或者 我们可以抓住这一点 

2453
02:01:58,220 --> 02:02:01,850
我们可以做这样的事情 我们做点+ 所以

2454
02:02:01,850 --> 02:02:03,410
才能真正捕捉到这一点 

2455
02:02:03,410 --> 02:02:05,570
然后我们可以做这样的事情 

2456
02:02:05,570 --> 02:02:13,640
如果matches.group 1现在等于com 那么我们可以支持这一点 

2457
02:02:13,640 --> 02:02:18,020
因此 您可以想象仅通过提取顶层

2458
02:02:18,020 --> 02:02:21,410
域 或TLD 然后只需使用Python代码 也许是列表 也许

2459
02:02:21,410 --> 02:02:24,860
一本词典 在正则表达式之外的其他地方进行验证 

2460
02:02:24,860 --> 02:02:26,780
如果这真的是你所期待的 

2461
02:02:26,780 --> 02:02:28,700
不过 就目前而言 我们让事情变得简单 

2462
02:02:28,700 --> 02:02:31,860
在这种情况下 我们只关注.com 

2463
02:02:31,860 --> 02:02:33,767
让我们对这个程序做最后一次更改

2464
02:02:33,767 --> 02:02:36,350
所以我们的定义更具体一点

2465
02:02:36,350 --> 02:02:37,640
推特用户名的 

2466
02:02:37,640 --> 02:02:41,000
事实证明 我们在这里有点太慷慨了 因此我们

2467
02:02:41,000 --> 02:02:43,280
接受一个或多个任何字符 

2468
02:02:43,280 --> 02:02:45,050
我查看了Twitter的文档 

2469
02:02:45,050 --> 02:02:48,890
推特只支持字母表中的字母a到Z 

2470
02:02:48,890 --> 02:02:53,370
数字0到9 或下划线 所以不只是点 

2471
02:02:53,370 --> 02:02:55,020
从字面上看 它是任何东西 

2472
02:02:55,020 --> 02:02:57,230
所以让我继续下去 在这里更准确地说 

2473
02:02:57,230 --> 02:02:59,870
在我最后 让我继续说 

2474
02:02:59,870 --> 02:03:03,510
方括号中的这组符号 

2475
02:03:03,510 --> 02:03:08,058
接下来我会说a到Z 0到9 还有一个下划线 

2476
02:03:08,058 --> 02:03:10,100
因为 再说一次 这些是唯一有效的符号 

2477
02:03:10,100 --> 02:03:12,740
我不需要麻烦大写的A或小写的z 

2478
02:03:12,740 --> 02:03:16,140
因为我们这里用的是RE.IGNORECASE 

2479
02:03:16,140 --> 02:03:19,760
但我想确保我现在不仅能容忍一个或多个

2480
02:03:19,760 --> 02:03:24,260
这些符号在这里 但也可能是URL末尾的一些其他东西 

2481
02:03:24,260 --> 02:03:27,710
我现在不介意有一个斜杠或一个问号 

2482
02:03:27,710 --> 02:03:31,730
或URL结尾处的散列 所有这些都是URL中的有效符号 

2483
02:03:31,730 --> 02:03:34,130
但我从推特的文件中得知 

2484
02:03:34,130 --> 02:03:36,390
不是用户名的一部分 

2485
02:03:36,390 --> 02:03:36,890
好的 

2486
02:03:36,890 --> 02:03:39,770
现在 我将继续运行twitter.py one的蟒蛇

2487
02:03:39,770 --> 02:03:46,610
最后一次 也许输入https://twitter.com/davidjmalan 

2488
02:03:46,610 --> 02:03:48,320
有 也许没有尾部的斜杠 

2489
02:03:48,320 --> 02:03:52,070
但希望 在我最大的手指交叉在这里 我现在要继续

2490
02:03:52,070 --> 02:03:56,630
然后按回车键 谢天谢地 我的用户名确实是davidjmaran 

2491
02:03:56,630 --> 02:03:59,300
那么 在正则表达式的世界里还有什么呢

2492
02:03:59,300 --> 02:04:00,320
那这个自己的图书馆呢？

2493
02:04:00,320 --> 02:04:04,340
不只是re.earch和re.sub. 还有其他功能 

2494
02:04:04,340 --> 02:04:07,850
有re.plit 你可以通过它来拆分字符串 而不是

2495
02:04:07,850 --> 02:04:11,480
使用一个或多个特定字符 如逗号和空格 

2496
02:04:11,480 --> 02:04:14,010
但也有多个角色 

2497
02:04:14,010 --> 02:04:16,550
甚至还有像re.findall这样的功能 

2498
02:04:16,550 --> 02:04:20,540
它可以让您搜索同一图案的多个副本

2499
02:04:20,540 --> 02:04:23,120
在字符串中的不同位置 这样您可能可以

2500
02:04:23,120 --> 02:04:25,200
操控不止一个人 

2501
02:04:25,200 --> 02:04:28,820
所以在一天结束的时候 你真的学会了一门完全不同的语言 

2502
02:04:28,820 --> 02:04:31,700
就像正则表达式一样 我们已经在Python中使用了它们 

2503
02:04:31,700 --> 02:04:35,670
但这些正则表达式实际上也存在于许多语言中 

2504
02:04:35,670 --> 02:04:38,930
其中包括Java、Java和Ruby等等 

2505
02:04:38,930 --> 02:04:42,300
所以有了这种新的语言 尽管它确实是神秘的

2506
02:04:42,300 --> 02:04:45,050
当你第一次使用它时 你就拥有了这种新发现的能力

2507
02:04:45,050 --> 02:04:48,800
为了表达这些模式 同样 您可以使用它们来验证数据 

2508
02:04:48,800 --> 02:04:53,310
清理数据 甚至从任何数据集中提取数据

2509
02:04:53,310 --> 02:04:54,470
你可能已经想好了 

2510
02:04:54,470 --> 02:04:55,830
本周就到这里吧 

2511
02:04:55,830 --> 02:04:58,570
我们下次再见 

