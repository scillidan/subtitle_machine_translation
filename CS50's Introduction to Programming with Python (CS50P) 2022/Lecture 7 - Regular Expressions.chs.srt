
1
00:00:00,000 --> 00:00:03,960
[交响乐调音]
[ORCHESTRA TUNING]

2
00:00:14,850 --> 00:00:18,315
[音乐播放]
[MUSIC PLAYING]

3
00:00:24,270 --> 00:00:25,470
大卫·马兰：好的 
DAVID MALAN: All right.

4
00:00:25,470 --> 00:00:28,680
这是CS50的Python编程入门 
This is CS50's Introduction to Programming with Python.

5
00:00:28,680 --> 00:00:32,350
我的名字是David Malan 这是我们关于正则表达式的一周 
My name is David Malan, and this is our week on regular expressions.

6
00:00:32,350 --> 00:00:37,170
因此 正则表达式 也称为正则表达式 实际上只是一种模式 
So a regular expression, otherwise known as a regex, is really just a pattern.

7
00:00:37,170 --> 00:00:39,120
实际上 在编程中 
And indeed, it's quite common in programming

8
00:00:39,120 --> 00:00:43,620
想要使用模式来匹配某种数据 通常是用户输入 
to want to use patterns to match on some kind of data, often user input.

9
00:00:43,620 --> 00:00:47,190
例如 如果用户输入一个电子邮件地址 无论是您的程序 
For instance, if the user types in an email address, whether to your program,

10
00:00:47,190 --> 00:00:49,200
或者网站 或者手机上的应用程序 
or a website, or an app on your phone, you

11
00:00:49,200 --> 00:00:50,940
理想情况下 可能希望能够验证
might ideally want to be able to validate

12
00:00:50,940 --> 00:00:53,130
他们确实输入了一个电子邮件地址
that they did indeed type in an email address

13
00:00:53,130 --> 00:00:54,790
而不是完全不同的东西
and not something completely different.

14
00:00:54,790 --> 00:00:58,080
所以使用正则表达式 我们将拥有新发现的能力 
So using regular expressions, we're going to have the newfound capability

15
00:00:58,080 --> 00:01:02,280
在我们的代码中定义模式 将它们与我们正在使用的数据进行比较 
to define patterns in our code to compare them against data that we're

16
00:01:02,280 --> 00:01:04,920
从别人那里接收信息 无论是为了验证它 
receiving from someone else, whether it's just to validate it,

17
00:01:04,920 --> 00:01:07,470
或者 即使我们想清理大量的数据 
or, heck, even if we want to clean up a whole lot of data

18
00:01:07,470 --> 00:01:11,220
它本身可能是混乱的 因为它也来自我们人类 
that itself might be messy because it, too, came from us humans.

19
00:01:11,220 --> 00:01:14,010
在此之前 我们使用这些正则表达式 
Before, though, we use these regular expressions,

20
00:01:14,010 --> 00:01:19,620
我建议我们用一些简单的语法来解决一些问题
let me propose that we solve a few problems using just some simpler syntax

21
00:01:19,620 --> 00:01:22,140
看看我们遇到了什么样的限制 
and see what kind of limitations we run up against.

22
00:01:22,140 --> 00:01:24,720
我建议在这里打开VS Code 
Let me propose that I open up VS Code here,

23
00:01:24,720 --> 00:01:27,900
让我创建一个名为validate.py的文件 
and let me create a file called validate.py, the goal at hand

24
00:01:27,900 --> 00:01:30,768
验证用户的电子邮件地址 
being to validate, how about just that, a user's email address.

25
00:01:30,768 --> 00:01:33,060
他们来到你的应用程序 他们来到你的网站 
They've come to your app, they've come to your website,

26
00:01:33,060 --> 00:01:34,935
他们输入他们的电子邮件地址 
they type in their email address, and we want

27
00:01:34,935 --> 00:01:38,380
回答是或否 此电子邮件地址看起来有效 
to say yes or no, this email address looks valid.

28
00:01:38,380 --> 00:01:38,880
好吧
All right.

29
00:01:38,880 --> 00:01:43,980
让我继续输入代码validate.py来创建一个新的标签 
Let me go ahead and type code of validate.py to create a new tab here.

30
00:01:43,980 --> 00:01:47,850
然后在这个选项卡中 让我继续并开始编写一些代码 
And then within this tab, let me go ahead and start writing some code,

31
00:01:47,850 --> 00:01:50,010
怎么样 这让事情简单的开始 
how about, that keeps things simple initially.

32
00:01:50,010 --> 00:01:53,130
首先 让我继续并提示用户输入他们的电子邮件地址 
First, let me go ahead and prompt the user for their email address.

33
00:01:53,130 --> 00:01:57,510
我将把输入的返回值存储在一个名为email的变量中 
And I'll store the return value of input in a variable called email,

34
00:01:57,510 --> 00:01:59,940
问他们“你的邮箱是什么？“
asking them "what's your email?"

35
00:01:59,940 --> 00:02:00,742
问号 
question mark.

36
00:02:00,742 --> 00:02:02,700
我将继续至少先发制人地
I'm going to go ahead and preemptively at least

37
00:02:02,700 --> 00:02:06,780
通过最小限度地只调用strie来清理用户的输入
clean up the user's input a little bit by minimally just calling strip

38
00:02:06,780 --> 00:02:10,020
在我对输入的调用结束时 因为回想
at the end of my call to input, because recall

39
00:02:10,020 --> 00:02:12,240
该输入返回一个或多个字符串 
that input returns a string or a str.

40
00:02:12,240 --> 00:02:16,200
STR带有一些内置的方法或函数 其中之一
strs come with some built-in methods or functions, one of which

41
00:02:16,200 --> 00:02:18,390
是条状的 具有剥离的效果
is strip, which has the effect of stripping off

42
00:02:18,390 --> 00:02:22,395
左边的任何前导空白或右边的任何尾随空白 
any leading whitespace to the left or any trailing whitespace to the right.

43
00:02:22,395 --> 00:02:24,270
所以这一切都会继续下去 至少
So that's just going to go ahead and at least

44
00:02:24,270 --> 00:02:27,480
避免人不小心输入了空格字符 
avoid the human having accidentally typed in a space character.

45
00:02:27,480 --> 00:02:29,860
我们要把它扔掉以防万一 
We're going to throw it away just in case.

46
00:02:29,860 --> 00:02:31,500
现在我要做一些简单的事情 
Now I'm going to do something simple.

47
00:02:31,500 --> 00:02:35,165
对于用户的输入是电子邮件地址 
For a user's input to be an email address,

48
00:02:35,165 --> 00:02:37,290
我想我们都同意 它有一个最低限度的
I think we can all agree that it's got a minimal we

49
00:02:37,290 --> 00:02:39,130
在里面的某个地方放一个“符号” 
have an @ sign somewhere in it.

50
00:02:39,130 --> 00:02:40,140
所以 让我们从简单的开始 
So let's start simple.

51
00:02:40,140 --> 00:02:43,230
如果用户输入了带有@符号的内容 让我们
If the user has typed in something with an @ sign, let's

52
00:02:43,230 --> 00:02:46,800
非常慷慨地说 好的 有效的 看起来像一个电子邮件地址 
very generously just say, OK, valid, looks like an email address.

53
00:02:46,800 --> 00:02:50,940
如果我们遗漏了@符号 我们就说它无效 因为它显然是
And if we're missing that @ sign, let's say invalid, because clearly it's

54
00:02:50,940 --> 00:02:51,870
不是电子邮件地址 
not an email address.

55
00:02:51,870 --> 00:02:55,078
这还不是我的代码的最好版本 但我们将从简单开始 
It's not going to be the best version of my code yet, but we'll start simple.

56
00:02:55,078 --> 00:02:59,700
所以我要问这个问题 如果用户的
So I'm going to ask the question, if there is an @ symbol in the user's

57
00:02:59,700 --> 00:03:03,570
电子邮件地址 继续并打印出来 例如 引号 不引号 “有效” 
email address, go ahead and print out, for instance, quote, unquote, "valid."

58
00:03:03,570 --> 00:03:06,750
否则 如果没有 我现在很有信心
Else, if there's not, now I'm pretty confident that the email

59
00:03:06,750 --> 00:03:09,250
事实上 地址是无效的 
address is, in fact, invalid.

60
00:03:09,250 --> 00:03:10,650
现在 这段代码在做什么？
Now, what is this code doing?

61
00:03:10,650 --> 00:03:16,320
好吧 如果@Sign in Email是一种毕德式的方式 问这个字符串引号 
Well, if @ sign in email is a Pythonic way of asking is this string quote,

62
00:03:16,320 --> 00:03:20,762
在这封不带引号的电子邮件中 无论它在哪里--
unquote "@" in this other string email, no matter where it is--

63
00:03:20,762 --> 00:03:22,470
在开头、中间或结尾 
at the beginning, the middle, or the end.

64
00:03:22,470 --> 00:03:25,470
它将自动搜索整个字符串为您
It's going to automatically search through the entire string for you

65
00:03:25,470 --> 00:03:26,220
自动的 
automatically.

66
00:03:26,220 --> 00:03:27,660
我可以更详细地做这件事 
I could do this more verbosely.

67
00:03:27,660 --> 00:03:29,670
我可以使用For循环或While循环
And I could use a for loop or a while loop

68
00:03:29,670 --> 00:03:32,640
并查看用户电子邮件地址中的每个字符 
and look at every character in the user's email address,

69
00:03:32,640 --> 00:03:34,128
想看看这是不是@手势 
looking to see if it's an @ sign.

70
00:03:34,128 --> 00:03:36,420
但这是Python的优点之一 
But this is one of the things that's nice about Python.

71
00:03:36,420 --> 00:03:38,020
你可以用更少的钱做更多的事情 
You can do more with less.

72
00:03:38,020 --> 00:03:41,190
所以只要说如果“@”在电子邮件中引用 不引用 
So just by saying if "@" quote, unquote in email,

73
00:03:41,190 --> 00:03:43,800
我们正在实现同样的结果 我们要找回真我
we're achieving that same result. We're going to get back true

74
00:03:43,800 --> 00:03:47,670
如果它在那里的某个地方 那么它是有效的 否则就是假的 
if it's somewhere in there, thus valid, or false if it is not.

75
00:03:47,670 --> 00:03:50,970
现在 让我继续在我的终端窗口中运行这个程序
Well, let me go ahead now and run this program in my terminal window

76
00:03:50,970 --> 00:03:53,100
使用valiate.py的python 
with python of validate.py.

77
00:03:53,100 --> 00:03:56,730
接下来 我会给它提供我的电子邮件地址--Malan@Gaveard.edu 
And I'm going to go ahead and give it my email address-- malan@harvard.edu,

78
00:03:56,730 --> 00:03:57,570
进来吧 
Enter.

79
00:03:57,570 --> 00:03:58,770
事实上 它是有效的 
And indeed, it's valid.

80
00:03:58,770 --> 00:04:00,210
看起来是有效的 是有效的 
Looks valid, is valid.

81
00:04:00,210 --> 00:04:03,480
但当然 从技术上讲 这个计划是失败的 
But of course, this program is technically broken.

82
00:04:03,480 --> 00:04:04,410
这是一辆破车 
It's buggy.

83
00:04:04,410 --> 00:04:07,110
如果有人输入 会是什么示例输入
What would be an example input, if someone

84
00:04:07,110 --> 00:04:10,770
可能想在这里自愿回答 这将被认为是有效的
might like to volunteer an answer here, that would be considered valid

85
00:04:10,770 --> 00:04:13,197
但你我都知道这真的是无效的？
but you and I know it really isn't valid?

86
00:04:13,197 --> 00:04:14,280
观众：是的 谢谢 
AUDIENCE: Yeah, thank you.

87
00:04:14,280 --> 00:04:17,880
举个例子 你只需要输入两个符号就行了 
Well, for instance, you can type just two signs and that's it,

88
00:04:17,880 --> 00:04:20,760
而且它仍然有效--
and it'll still be valid--

89
00:04:20,760 --> 00:04:23,815
根据你的程序仍然有效 但遗漏了一些东西 
still be valid according to your program, but missing something.

90
00:04:23,815 --> 00:04:24,690
大卫·马兰：没错 
DAVID MALAN: Exactly.

91
00:04:24,690 --> 00:04:26,680
我们在这里设定了一个很低的标准 
We've set a very low bar here.

92
00:04:26,680 --> 00:04:29,430
事实上 如果我继续并重新运行valiate.py的python 
In fact, if I go ahead and rerun python of validate.py,

93
00:04:29,430 --> 00:04:33,512
我只需输入一个@符号 就这样--没有用户名 没有域名 
and I'll just type in one @ sign, that's it-- no username, no domain name,

94
00:04:33,512 --> 00:04:35,470
这看起来不像是电子邮件地址 
this doesn't really look like an email address.

95
00:04:35,470 --> 00:04:38,790
但不幸的是 我的代码认为它实际上是 因为它显然是
But unfortunately, my code thinks it, in fact, is, because it's obviously

96
00:04:38,790 --> 00:04:40,710
我只是在寻找一个单独的“标志” 
just looking for an @ sign alone.

97
00:04:40,710 --> 00:04:42,250
那么 我们如何才能改进这一点呢？
Well, how could we improve this?

98
00:04:42,250 --> 00:04:45,500
嗯 至少一个电子邮件地址 我想 往往会有 
Well, minimally an email address, I think, tends to have,

99
00:04:45,500 --> 00:04:47,250
虽然这实际上不是一个要求 
though this is not actually a requirement,

100
00:04:47,250 --> 00:04:51,600
倾向于至少有一个@符号和一个点 可能在域中的某个地方
tends to have an @ sign and a single dot at least, maybe somewhere in the domain

101
00:04:51,600 --> 00:04:54,240
姓名--So Malan@atherard.edu 
name-- so malan@harvard.edu.

102
00:04:54,240 --> 00:04:55,960
那么让我们也来检查一下那个点 
So let's check for that dot as well.

103
00:04:55,960 --> 00:04:59,040
但再说一次 严格来说 情况甚至不一定是这样的 
But again, strictly speaking it doesn't even have to be that case.

104
00:04:59,040 --> 00:05:02,190
但我会选择我自己的电子邮件地址 至少目前是这样 作为我们的测试案例 
But I'm going for my own email address, at least for now, as our test case.

105
00:05:02,190 --> 00:05:06,450
所以让我继续更改我的代码 并说 不仅@在电子邮件中 
So let me go ahead and change my code now and say, not only if @ is in email,

106
00:05:06,450 --> 00:05:11,050
但Dot也在电子邮件中 
but also dot is in email as well.

107
00:05:11,050 --> 00:05:12,690
所以我现在问你两个问题 
So I'm asking now two questions.

108
00:05:12,690 --> 00:05:16,050
我有两个布尔表达式--If@in Email 
I have two Boolean expressions-- if @ in email,

109
00:05:16,050 --> 00:05:20,650
我把它们逻辑地进行AND运算--可以说 这是一个逻辑AND运算 
and I'm anding them together logically-- this is a logical and, so to speak.

110
00:05:20,650 --> 00:05:24,600
因此 如果@在电子邮件中 Dot在电子邮件中 
So if it's the case that @ is in email and dot is in email, OK,

111
00:05:24,600 --> 00:05:26,470
现在我要继续说有效 
now I'm going to go ahead and say valid.

112
00:05:26,470 --> 00:05:26,970
好的 
All right.

113
00:05:26,970 --> 00:05:29,460
这似乎仍然适用于我的电子邮件地址 
This would still seem to work for my email address.

114
00:05:29,460 --> 00:05:34,500
让我继续运行pythonvaliate.py Malan@atherard.edu 回车 
Let me go ahead and run python validate.py, malan@harvard.edu, Enter,

115
00:05:34,500 --> 00:05:36,390
当然 这是合理的 这是预料之中的 
and that, of course, is valid is expected.

116
00:05:36,390 --> 00:05:39,870
但在这里 我们也可以有点敌意 输入一些东西
But here, too, we can be a little adversarial and type in something

117
00:05:39,870 --> 00:05:41,505
像“@”这样的无稽之谈 
nonsensical like "@."

118
00:05:41,505 --> 00:05:45,180
不幸的是 这也会被误认为是正确的 
and unfortunately, that, too, is going to be mistaken as valid,

119
00:05:45,180 --> 00:05:48,820
即使仍然没有用户名、域名或类似的东西 
even though there's still no username, domain name, or anything like that.

120
00:05:48,820 --> 00:05:51,180
所以我认为我们在这方面需要更有条理一些 
So I think we need to be a little more methodical here.

121
00:05:51,180 --> 00:05:57,660
事实上 请注意 如果我这样做 @符号可以在任何地方 
In fact, notice that if I do this like this, the @ sign can be anywhere,

122
00:05:57,660 --> 00:05:59,250
圆点可以在任何地方 
and the dot can be anywhere.

123
00:05:59,250 --> 00:06:02,190
但是如果我假设用户将拥有一个传统域名
But if I'm assuming the user is going to have a traditional domain

124
00:06:02,190 --> 00:06:05,880
收割网或gmail.com之类的名字 我真的
name like harvard.edu or gmail.com, I really

125
00:06:05,880 --> 00:06:10,110
只想在域名中寻找圆点 不一定
want to look for the dot in the domain name only, not necessarily

126
00:06:10,110 --> 00:06:11,580
只有用户名 
just the username.

127
00:06:11,580 --> 00:06:13,510
所以让我继续做这件事 
So let me go ahead and do this.

128
00:06:13,510 --> 00:06:18,250
让我继续在这里介绍一些更多的逻辑 而不是这样做 
Let me go ahead and introduce a bit more logic here, and instead do this.

129
00:06:18,250 --> 00:06:24,060
让我继续发送电子邮件 分开引用 不引用@sign 
Let me go ahead and do email.split of quote, unquote @ sign.

130
00:06:24,060 --> 00:06:26,460
因此 电子邮件同样是一个字符串或字符串 
So email, again, is a string or a str.

131
00:06:26,460 --> 00:06:29,550
STR有各种方法 不仅是脱衣 还包括
strs come with methods, not just strip but also

132
00:06:29,550 --> 00:06:32,190
另一种叫Split 顾名思义 
another one called split that, as the name implies,

133
00:06:32,190 --> 00:06:36,570
如果指定一个或多个字符 则会将一个字符串拆分为多个字符
will split one str into multiple ones if you give it a character or more

134
00:06:36,570 --> 00:06:37,950
在上面分开 
to split on.

135
00:06:37,950 --> 00:06:42,390
希望这封邮件能从传统电子邮件中返回给我两个部分
So this is hopefully going to return to me two parts from a traditional email

136
00:06:42,390 --> 00:06:44,880
地址、用户名和域名 
address, the username and the domain name.

137
00:06:44,880 --> 00:06:47,850
事实证明 我可以解开这一系列的回答
And it turns out I can unpack that sequence of responses

138
00:06:47,850 --> 00:06:52,410
通过这样做--用户名逗号域等于这个 
by doing this-- username comma domain equals this.

139
00:06:52,410 --> 00:06:55,060
我可以将其存储在列表或其他结构中 
I could store it in a list or some other structure,

140
00:06:55,060 --> 00:06:58,530
但如果我事先已经知道我期待什么样的价值 
but if I already know in advance what kinds of values I'm expecting,

141
00:06:58,530 --> 00:07:00,510
一个用户名和一个域名 我要
a username and hopefully a domain, I'm going

142
00:07:00,510 --> 00:07:04,050
要继续这样做 只需同时定义两个变量
to go ahead and do it like this instead and just define two variables at once

143
00:07:04,050 --> 00:07:05,310
在一行代码上 
on one line of code.

144
00:07:05,310 --> 00:07:07,290
现在我要说得更准确一点 
And now I'm going to be a little more precise.

145
00:07:07,290 --> 00:07:13,230
如果用户名--如果用户名 那么我将继续
If username-- if username, then I'm going to go ahead

146
00:07:13,230 --> 00:07:15,370
说 打印“有效” 
and say, print "valid."

147
00:07:15,370 --> 00:07:18,820
否则 我将继续说打印“无效” 
Else, I'm going to go ahead and say print "invalid."

148
00:07:18,820 --> 00:07:20,040
现在 这还不够好 
Now, this isn't good enough.

149
00:07:20,040 --> 00:07:22,800
但我现在至少在检查用户名是否存在 
But I'm at least checking for the presence of a username now.

150
00:07:22,800 --> 00:07:25,217
你可能以前没见过 但如果你简单地
And you might not have seen this before, but if you simply

151
00:07:25,217 --> 00:07:28,680
问一个类似“如果用户名是字符串”这样的问题 
ask a question like "if username," and username is a string,

152
00:07:28,680 --> 00:07:31,320
好的 用户名--“如果用户名”能给我
well, username-- "if username" is going to give me

153
00:07:31,320 --> 00:07:35,730
如果用户名不是NONE或QUOTE 则回答正确 
a true answer if username is anything except none or quote,

154
00:07:35,730 --> 00:07:36,840
不引用“什么都没有 ”
unquote "nothing."

155
00:07:36,840 --> 00:07:41,820
因此这里有一个真实的值 即如果用户名至少有一个字符 
So there's a truthy value here, whereby if username has at least one character,

156
00:07:41,820 --> 00:07:43,350
这将被认为是真的 
that's going to be considered true.

157
00:07:43,350 --> 00:07:46,170
但如果用户名没有字符 它将
But if username has no characters, it's going

158
00:07:46,170 --> 00:07:49,245
有效地被认为是错误的价值 
to be considered a false value effectively.

159
00:07:49,245 --> 00:07:50,370
但这还不够好 
But this isn't good enough.

160
00:07:50,370 --> 00:07:52,037
我不想只检查用户名 
I don't want to just check for username.

161
00:07:52,037 --> 00:07:57,160
我还想检查一下 点是否也在域名中 
I want to also check that it's the case that dot is in the domain name as well.

162
00:07:57,160 --> 00:08:00,180
请注意 这里有一点潜在的混乱
So notice here there's a bit of potential confusion

163
00:08:00,180 --> 00:08:01,830
会说英语 
with the English language.

164
00:08:01,830 --> 00:08:04,620
在这里 我似乎是在说“如果用户名和点
Here, I seem to be saying "if username and dot

165
00:08:04,620 --> 00:08:09,660
在域中 “就像我在问问题” 如果用户名和点
in domain," as though I'm asking the question, "if the username and the dot

166
00:08:09,660 --> 00:08:12,270
但这并不是这个意思 
are in the domain," but that's not what this means.

167
00:08:12,270 --> 00:08:15,540
这是两个不同的布尔表达式--“如果用户名 ”
These are two separate Boolean expressions-- "if username,"

168
00:08:15,540 --> 00:08:19,690
和单独的 “如果点在领域 ”
and separately, "if dot in domain."

169
00:08:19,690 --> 00:08:23,100
如果我把这个放在括号里 我们可以通过把
And if I parenthesis this, we could make that even more clear by putting

170
00:08:23,100 --> 00:08:25,000
圆括号在那里 圆括号在这里 
parentheses there, parentheses here.

171
00:08:25,000 --> 00:08:27,390
为了清楚起见 它实际上是两个布尔表达式
So just to be clear, it's really two Boolean expressions

172
00:08:27,390 --> 00:08:30,840
我们是在一起做AND 而不是一个更长的英语句子 
that we're anding together, not one longer English-like sentence.

173
00:08:30,840 --> 00:08:35,580
现在 如果我继续运行这个 python valiate.py回车 
Now, if I go ahead and run this, python validate.py Enter,

174
00:08:35,580 --> 00:08:39,809
我会再做一次我自己的电子邮件地址 Malan@atherard.edu 这是有效的 
I'll do my own email address again, malan@harvard.edu, and that's valid.

175
00:08:39,809 --> 00:08:43,710
看起来我可以忍受这样的事情 
And it looks like I could tolerate something like this.

176
00:08:43,710 --> 00:08:47,970
如果我做马兰 就说 哈佛 我认为目前
If I do malan@, just say, harvard, I think at the moment

177
00:08:47,970 --> 00:08:49,480
这将是无效的 
this is going to be invalid.

178
00:08:49,480 --> 00:08:52,150
现在 也许顶级域名哈佛存在 
Now, maybe the top-level domain harvard exists.

179
00:08:52,150 --> 00:08:54,900
但目前 我们似乎在寻找更多的东西 
But at the moment, it looks like we're looking for something more.

180
00:08:54,900 --> 00:08:58,380
我们也在寻找顶级域名 比如.edu 
We're looking for a top-level domain too, like .edu.

181
00:08:58,380 --> 00:09:01,540
目前 我们只认为这是无效的 
For now, we'll just consider this to be invalid.

182
00:09:01,540 --> 00:09:04,510
但这不仅仅是我们想要做的--
But it's not just that we want to do--

183
00:09:04,510 --> 00:09:07,260
这不仅仅是因为我们想要检查用户名是否存在
it's not just that we want to check for the presence of a username

184
00:09:07,260 --> 00:09:08,370
和一个圆点的存在 
and the presence of a dot.

185
00:09:08,370 --> 00:09:09,520
让我们说得更具体些 
Let's be more specific.

186
00:09:09,520 --> 00:09:11,687
让我们现在开始缩小这个项目的范围 
Let's start to now narrow the scope of this program,

187
00:09:11,687 --> 00:09:15,600
不仅仅是关于一般的电子邮件 还有关于EDU地址 
not just to be about generic emails more generally, but about edu addresses,

188
00:09:15,600 --> 00:09:18,780
例如 对于美国大学里的一些人来说 
so specifically for someone in a US university, for instance,

189
00:09:18,780 --> 00:09:21,450
其电子邮件地址往往以.edu结尾 
whose email address tends to end with .edu.

190
00:09:21,450 --> 00:09:23,310
我可以说得更准确一点 
I can be a little more precise.

191
00:09:23,310 --> 00:09:25,350
你可能已经回想起这个函数了 
And you might recall this function already.

192
00:09:25,350 --> 00:09:28,590
而不是简单地说 在域中的某个地方有一个点 
Instead of just saying, is there a dot somewhere in domain,

193
00:09:28,590 --> 00:09:34,740
让我说 域名以引号结尾 非引号“.edu” 
let me instead say, and the domain ends with quote, unquote ".edu."

194
00:09:34,740 --> 00:09:36,420
现在我们更加精确了 
Now we're being even more precise.

195
00:09:36,420 --> 00:09:40,200
我们希望至少有一个不为空的用户名--不仅仅是引号 
We want there to be minimally a username that's not empty-- it's not just quote,

196
00:09:40,200 --> 00:09:45,190
不引用“Nothing”--我们希望域名实际上以.edu结尾 
unquote "nothing"-- and we want the domain name to actually end with .edu.

197
00:09:45,190 --> 00:09:47,448
让我继续运行valiate.py的python 
Let me go ahead and run python of validate.py.

198
00:09:47,448 --> 00:09:49,740
为了确保我没有把事情搞得更糟 
And just to make sure I haven't made things even worse,

199
00:09:49,740 --> 00:09:53,470
至少让我测试一下我自己的电子邮件地址 它看起来确实有效 
let me at least test my own email address, which does seem to be valid.

200
00:09:53,470 --> 00:09:56,070
现在 我似乎至少需要提供一个用户名 
Now, it seems that I minimally need to provide a username,

201
00:09:56,070 --> 00:09:58,380
因为我们确实有这张支票 
because we definitely do have that check in place.

202
00:09:58,380 --> 00:10:00,210
所以我要继续说 马兰 
So I'm going to go ahead and say malan.

203
00:10:00,210 --> 00:10:02,790
现在我要继续说“ 
And now I'm going to go ahead and say @.

204
00:10:02,790 --> 00:10:05,880
而且看起来我可能有点恶毒 
And it looks like I could be a little malicious here,

205
00:10:05,880 --> 00:10:09,030
只需说Malan@.edu 就像是最小限度的会面
just say malan@.edu, as though minimally meeting

206
00:10:09,030 --> 00:10:11,340
此模式的要求 
the requirements of this pattern.

207
00:10:11,340 --> 00:10:13,200
当然 这被认为是有效的 
And that, of course, is considered valid,

208
00:10:13,200 --> 00:10:17,010
但我非常肯定 在Malan@.edu上没有人 
but I'm pretty sure there's no one at malan@.edu.

209
00:10:17,010 --> 00:10:19,350
我们需要在那里有一些域名 
We need to have some domain name in there.

210
00:10:19,350 --> 00:10:21,360
因此 我们仍然没有那么慷慨 
So we're still not being quite as generous.

211
00:10:21,360 --> 00:10:24,510
现在 我们完全可以继续迭代这个程序 
Now, we could absolutely continue to iterate on this program,

212
00:10:24,510 --> 00:10:26,640
我们可以添加更多的布尔表达式 
and we could add some more Boolean expressions.

213
00:10:26,640 --> 00:10:28,590
我们也许可以使用一些其他的Python方法
We could maybe use some other Python methods

214
00:10:28,590 --> 00:10:31,530
为了更精确地检查点的左边是否有东西 
for checking more precisely is there something to the left of the dot,

215
00:10:31,530 --> 00:10:32,550
点的右边 
to the right of the dot.

216
00:10:32,550 --> 00:10:34,320
我们可以多次使用split 
We could use split multiple times.

217
00:10:34,320 --> 00:10:36,180
但老实说 这只是迅速升级 
But honestly, this just escalates quickly.

218
00:10:36,180 --> 00:10:39,450
就像 你最终不得不写很多代码 
Like, you end up having to write a lot of code just

219
00:10:39,450 --> 00:10:42,360
来表达一些相对简单的东西--
to express something that's relatively simple in spirit--

220
00:10:42,360 --> 00:10:45,550
就像电子邮件地址一样格式化它 
just format this like an email address.

221
00:10:45,550 --> 00:10:47,920
那么 我们如何才能改善这一点呢？
So how can we go about improving this?

222
00:10:47,920 --> 00:10:52,350
Python中有一个正则表达式库 
Well, it turns out in Python there's a library for regular expressions.

223
00:10:52,350 --> 00:10:55,620
它被称为简洁的R-E 在图书馆里 
It's called succinctly R-E. And in the re library,

224
00:10:55,620 --> 00:11:00,510
你有很多能力来定义和检查 甚至取代
you have a lot of capabilities to define and check for and even replace

225
00:11:00,510 --> 00:11:01,440
模式.
patterns.

226
00:11:01,440 --> 00:11:03,630
同样 正则表达式也是一种模式 
Again, a regular expression is a pattern.

227
00:11:03,630 --> 00:11:05,998
这个库 Python中的re库 
And this library, the re library in Python,

228
00:11:05,998 --> 00:11:08,040
会让我们定义其中的一些模式
is going to let us define some of these patterns,

229
00:11:08,040 --> 00:11:09,915
比如电子邮件地址的模式 然后
like a pattern for an email address, and then

230
00:11:09,915 --> 00:11:12,720
使用一些内置函数来验证
use some built-in functions to actually validate

231
00:11:12,720 --> 00:11:14,820
用户的输入与该模式相对应 
a user's input against that pattern or even

232
00:11:14,820 --> 00:11:17,250
使用这些模式来更改用户的输入
use these patterns to change the user's input

233
00:11:17,250 --> 00:11:19,650
或者从中提取部分信息 
or extract partial information therefrom.

234
00:11:19,650 --> 00:11:22,030
我们将看到所有这些和更多的例子 
We'll see examples of all this and more.

235
00:11:22,030 --> 00:11:24,045
那么 我可以和应该如何使用这个图书馆呢？
So what can and should I do with this library?

236
00:11:24,045 --> 00:11:26,670
首先 它有很多功能 
Well, first and foremost, it comes with a lot of functionality.

237
00:11:26,670 --> 00:11:29,760
例如 这里是官方文档的URL 
Here is the URL, for instance, to the official documentation.

238
00:11:29,760 --> 00:11:31,710
我建议我们集中精力
And let me propose that we focus on using

239
00:11:31,710 --> 00:11:36,600
图书馆里最通用的功能之一 就是这个--搜索 
one of the most versatile functions in the library, namely this-- search.

240
00:11:36,600 --> 00:11:40,440
re.search是函数的名称 re模块
re.search is the name of the function and the re module

241
00:11:40,440 --> 00:11:42,910
它允许你传入一些参数
that allows you to pass in a few arguments.

242
00:11:42,910 --> 00:11:46,620
第一个是你想要搜索的模式 
The first is going to be a pattern that you want to search for in,

243
00:11:46,620 --> 00:11:48,900
例如 来自用户的字符串 
for instance, a string that came from a user.

244
00:11:48,900 --> 00:11:51,977
这里的字符串参数将是实际的字符串 
The string argument here is going to be the actual string that you

245
00:11:51,977 --> 00:11:53,310
我想寻找这种模式 
want to search for that pattern.

246
00:11:53,310 --> 00:11:55,410
还有第三个参数可选
And then there's a third argument optionally

247
00:11:55,410 --> 00:11:56,790
那可是一大堆旗子
that's a whole bunch of flags.

248
00:11:56,790 --> 00:11:59,880
一般来说 标志就像是可以传入的参数
A flag in general is like a parameter you can pass in

249
00:11:59,880 --> 00:12:01,510
修改函数的行为 
to modify the behavior of the function.

250
00:12:01,510 --> 00:12:03,510
但一开始 我们甚至不打算用这个 
But initially, we're not even going to use this.

251
00:12:03,510 --> 00:12:06,610
我们只需要传递几个参数 
We're just going to pass in a couple of arguments instead.

252
00:12:06,610 --> 00:12:11,700
所以让我继续使用这个Re库 这个正则表达式
So let me go ahead and employ this re library, this regular expression

253
00:12:11,700 --> 00:12:15,162
库 并在此设计基础上逐步改进 
library, and just improve on this design incrementally.

254
00:12:15,162 --> 00:12:17,370
所以我们不会一下子解决这个问题 
So we're not going to solve this problem all at once,

255
00:12:17,370 --> 00:12:19,590
但我们将采取一些渐进的步骤 
but we'll take some incremental steps.

256
00:12:19,590 --> 00:12:21,840
我将回到这里的VS代码 
I'm going to go back to VS Code here.

257
00:12:21,840 --> 00:12:25,050
现在我要继续下去 去掉大部分代码 
And I'm going to go ahead now and get rid of most of this code.

258
00:12:25,050 --> 00:12:28,230
但我要进入我的文件顶部 在秋季的第一天 
But I'm going to go into the top of my file and first of fall,

259
00:12:28,230 --> 00:12:30,030
导入此Re库 
import this re library.

260
00:12:30,030 --> 00:12:33,030
因此 导入环使我可以访问该功能以及更多功能 
So import re gives me access to that function and more.

261
00:12:33,030 --> 00:12:36,150
现在 在我以与以前相同的方式获得用户输入之后 
Now, after I've gotten the user's input in the same way as before,

262
00:12:36,150 --> 00:12:38,790
去掉任何前导或尾随空格 
stripping off any leading or trailing whitespace,

263
00:12:38,790 --> 00:12:42,250
现在 我只是简单地使用这个函数 
I'm just going to use this function super trivially for now,

264
00:12:42,250 --> 00:12:44,460
尽管这并不是真正向前迈出的一大步 
even though this isn't really a big step forward.

265
00:12:44,460 --> 00:12:50,190
我要说的是 如果re.earch包含引号 请取消引号“@”
I'm going to say, if re.search contains quote, unquote "@"

266
00:12:50,190 --> 00:12:53,700
在电子邮件地址中 然后让我们继续打印“有效” 
in the email address, then let's go ahead and print "valid."

267
00:12:53,700 --> 00:12:55,740
否则 让我们继续打印“无效” 
Else, let's go ahead and print "invalid."

268
00:12:55,740 --> 00:12:59,730
目前 这真的不比我的第一个版本好多少
At the moment, this is really no better than my very first version

269
00:12:59,730 --> 00:13:04,150
我刚才问的是 如果@在电子邮件地址签名的话 
where I was just asking Python, if @ sign in the email address.

270
00:13:04,150 --> 00:13:08,880
但现在我至少开始通过使用自己的re.earch来使用这个库了
But now I'm at least beginning to use this library by using its own re.search

271
00:13:08,880 --> 00:13:13,740
函数 目前您可以假定该函数有效地返回真值 
function, which for now you can assume returns a true value effectively

272
00:13:13,740 --> 00:13:16,440
如果@符号确实是一封电子邮件的话 
if, indeed, the @ sign is an email.

273
00:13:16,440 --> 00:13:19,800
为了确保这个版本能像我预期的那样工作 让我继续
Just to make sure that this version does work as I expect, let me go ahead

274
00:13:19,800 --> 00:13:22,590
然后运行validate.py的python并回车 
and run python of validate.py and Enter.

275
00:13:22,590 --> 00:13:26,220
我会输入我的实际电子邮件地址 然后我们就可以继续营业了 
I'll type in my actual email address, and we're back in business.

276
00:13:26,220 --> 00:13:29,370
但当然 这并不是很好 因为如果我同样
But of course, this is not great, because if I similarly

277
00:13:29,370 --> 00:13:32,400
运行这个版本的程序 只需输入@符号 
run this version of the program and just type in an @ sign,

278
00:13:32,400 --> 00:13:35,860
不是电子邮件地址 但我的代码当然认为它是有效的 
not an email address, and yet my code, of course, thinks it is valid.

279
00:13:35,860 --> 00:13:37,980
那么 我怎么才能做得比这更好呢？
So how can I do better than this?

280
00:13:37,980 --> 00:13:42,330
在正则表达式领域 我们需要更多的词汇 
Well, we need a bit more vocabulary in the realm of regular expressions,

281
00:13:42,330 --> 00:13:46,290
为了能够更准确地表达我们自己 
in order to be able to express ourselves a little more precisely.

282
00:13:46,290 --> 00:13:48,900
真的 我想最终定义的模式
Really, the pattern I want to ultimately define

283
00:13:48,900 --> 00:13:52,410
我希望左边有个东西
is going to be something like, I want there to be something to the left,

284
00:13:52,410 --> 00:13:55,320
然后是一个@符号 然后是右边的东西 
then an @ sign, then something to the right.

285
00:13:55,320 --> 00:13:59,310
右边的东西应该以.edu结尾 但也应该有
And that something to the right should end with .edu but should also have

286
00:13:59,310 --> 00:14:02,160
在.edu之前 比如哈佛 耶鲁 
something before the .edu, like Harvard, or Yale,

287
00:14:02,160 --> 00:14:04,680
美国的其他学校也是如此 
or any other school in the US as well.

288
00:14:04,680 --> 00:14:06,550
我该怎么做呢？
Well, how can I go about doing this?

289
00:14:06,550 --> 00:14:11,040
事实证明 在正则表达式的世界中 无论是在Python中 
Well, it turns out that in the world of regular expressions, whether in Python

290
00:14:11,040 --> 00:14:14,220
或者其他语言中 有一些特定的符号
or a lot of other languages as well, there are certain symbols

291
00:14:14,220 --> 00:14:16,140
可以用来定义模式 
that you can use to define patterns.

292
00:14:16,140 --> 00:14:19,030
目前 我只使用了字面上的原始文本 
At the moment, I've just used literal raw text.

293
00:14:19,030 --> 00:14:21,600
如果我回到我的代码这里 这在技术上
If I go back to my code here, this technically

294
00:14:21,600 --> 00:14:23,940
正则表达式是一个正则表达式 
qualifies as a regular expression.

295
00:14:23,940 --> 00:14:28,290
我传入了一个带引号的字符串 里面有一个@符号 
I've passed in a quoted string inside of which is an @ sign.

296
00:14:28,290 --> 00:14:30,550
现在 这不是一个非常有趣的模式 
Now, that's not a very interesting pattern.

297
00:14:30,550 --> 00:14:31,500
只是一个@符号 
It's just an @ sign.

298
00:14:31,500 --> 00:14:34,290
但事实证明 一旦你有机会访问正则表达式 
But it turns out that once you have access to regular expressions

299
00:14:34,290 --> 00:14:37,350
或者提供该功能的库 您可以
or a library that offers that feature, you can more

300
00:14:37,350 --> 00:14:40,360
你可以像下面这样有力地表达自己 
powerfully express yourself as follows.

301
00:14:40,360 --> 00:14:43,770
让我来揭示一下 你传递给re.search的模式
Let me reveal that the pattern that you pass to re.search

302
00:14:43,770 --> 00:14:45,690
可以用一大堆特殊的符号
can take a whole bunch of special symbols.

303
00:14:45,690 --> 00:14:47,160
这只是其中的一部分 
And here's just some of them.

304
00:14:47,160 --> 00:14:51,630
在我们将要看到的例子中 在我们将要定义的模式中 
In the examples we're about to see, in the patterns we're about to define,

305
00:14:51,630 --> 00:14:53,040
这是特殊符号 
here are the special symbols.

306
00:14:53,040 --> 00:14:56,280
你可以用一个句号 一个点 
You can use a single period, a dot, to just represent

307
00:14:56,280 --> 00:14:59,040
除了换行符和空行以外的任何字符 
any character except a newline, a blank line.

308
00:14:59,040 --> 00:15:02,190
也就是说 如果我不在乎字母表中的哪个字母
So that is to say, if I don't really care what letters of the alphabet

309
00:15:02,190 --> 00:15:04,200
在用户的用户名中 我只希望有
are in the user's username, I just want there

310
00:15:04,200 --> 00:15:07,410
是用户名中的一个或多个字符 
to be one or more characters in the user's name,

311
00:15:07,410 --> 00:15:11,340
dot可以让我用z 和来表示A 
dot allows me to express A through z, uppercase and lowercase,

312
00:15:11,340 --> 00:15:13,560
还有其他一些字母
and a bunch of other letters as well.

313
00:15:13,560 --> 00:15:18,850
* 表示--一个星号--零次或多次重复 
* is going to mean-- a single asterisk-- zero or more repetitions.

314
00:15:18,850 --> 00:15:21,630
所以如果我说了什么 那就意味着
So if I say something *, that means that I'm

315
00:15:21,630 --> 00:15:24,450
愿意接受零重复 即 
willing to accept either zero repetitions, that is,

316
00:15:24,450 --> 00:15:27,510
什么都没有 或者更多的重复
nothing at all, or more repetitions--

317
00:15:27,510 --> 00:15:29,580
1或2或3或300 
1, or 2, or 3, or 300.

318
00:15:29,580 --> 00:15:31,950
如果你在我的模式中看到一个加号 
If you see a plus in my pattern, so that's

319
00:15:31,950 --> 00:15:34,135
这意味着一次或多次重复 
going to mean one or more repetitions.

320
00:15:34,135 --> 00:15:37,260
也就是说 至少要有一个字符 一个符号 
That is to say, there's got to be at least one character there, one symbol,

321
00:15:37,260 --> 00:15:40,180
然后 在那之后还有更多的可选的 
and then there's optionally more after that.

322
00:15:40,180 --> 00:15:43,110
然后你可以说零或一次重复 
And then you can say zero or one repetition.

323
00:15:43,110 --> 00:15:46,590
您可以在符号后使用单个问号 这将表示 
You can use a single question mark after a symbol, and that will say,

324
00:15:46,590 --> 00:15:51,260
我不想要这个角色或一个角色 但这就是我所期望的 
I want zero of this character or one, but that's all I'll expect.

325
00:15:51,260 --> 00:15:53,010
最后 会有一种方法
And then lastly, there's going to be a way

326
00:15:53,010 --> 00:15:55,140
要指定特定数量的符号 请执行以下操作 
to specify a specific number of symbols.

327
00:15:55,140 --> 00:15:57,330
如果你使用这些花括号和一个数字 
If you use these curly braces and a number,

328
00:15:57,330 --> 00:15:59,610
在这里符号表示为m 您可以
represented here symbolically as m, you can

329
00:15:59,610 --> 00:16:03,720
指定需要m次重复 可以是1次、2次、3次或300次 
specify that you want m repetitions, be it 1, or 2, or 3, or 300.

330
00:16:03,720 --> 00:16:06,190
您可以自己指定重复次数 
You can specify the number of repetitions yourself.

331
00:16:06,190 --> 00:16:08,280
如果你想要一系列的重复 就像你
And if you want a range of repetitions, like you

332
00:16:08,280 --> 00:16:11,100
想要这几个字或者这么多字 
want this few characters or this many characters,

333
00:16:11,100 --> 00:16:13,770
您可以在里面使用花括号和两个数字 
you can use curly braces and two numbers inside,

334
00:16:13,770 --> 00:16:18,760
在这里称为m和n 这将是m到n个重复的范围 
called here m and n, which would be a range of m through n repetitions.

335
00:16:18,760 --> 00:16:20,140
那么 这一切意味着什么呢？
Now, what does all of this mean?

336
00:16:20,140 --> 00:16:22,380
好吧 让我回到VS代码这里 让我们
Well, let me go back to VS Code here, and let

337
00:16:22,380 --> 00:16:25,650
我建议我们进一步迭代这个解决方案 
me propose that we iterate on this solution further.

338
00:16:25,650 --> 00:16:27,985
仅仅检查@符号是不够的 
It's not sufficient to just check for the @ sign.

339
00:16:27,985 --> 00:16:28,860
我们已经知道了这一点 
We know that already.

340
00:16:28,860 --> 00:16:31,600
我们最低限度地想要一些东西放在左边和右边 
We minimally want something to the left and to the right.

341
00:16:31,600 --> 00:16:33,210
那么 我该如何代表这一点呢？
So how can I represent that?

342
00:16:33,210 --> 00:16:35,910
我并不真正关心用户的用户名是什么 
I don't really care what the user's username is,

343
00:16:35,910 --> 00:16:40,020
或者是字母表中的什么字母 无论是马兰还是其他任何人的 
or what letters of the alphabet are in it, be it malan or anyone else's.

344
00:16:40,020 --> 00:16:42,600
所以我要做的是在等号的左边
So what I'm going to do to the left of this equal sign

345
00:16:42,600 --> 00:16:44,410
我将用一个句号--
is I'm going to use a single period--

346
00:16:44,410 --> 00:16:49,600
同样表示除换行符以外的任何字符的圆点 
the dot that, again, indicates any character except for a newline.

347
00:16:49,600 --> 00:16:51,630
但我不只想要一个角色 
But I don't just want a single character.

348
00:16:51,630 --> 00:16:55,900
否则 该人的用户名只能是某某 
Otherwise, the person's username could only a at such and such,

349
00:16:55,900 --> 00:16:57,450
或者b某某 
or b at such and such.

350
00:16:57,450 --> 00:17:00,130
我希望是多个这样的角色 
I want it to be multiple such characters.

351
00:17:00,130 --> 00:17:01,680
所以我将首先使用* 
So I'm going to initially use a *.

352
00:17:01,680 --> 00:17:05,550
所以点*的意思是给我一些左边的东西 我要做另一个 
So dot * means give me something to the left, and I'm going to do another one,

353
00:17:05,550 --> 00:17:07,619
点*右边的东西 
dot * something to the right.

354
00:17:07,619 --> 00:17:10,589
现在 这并不完美 但至少是向前迈进了一步 
Now, this isn't perfect, but it's at least a step forward.

355
00:17:10,589 --> 00:17:12,871
因为现在我要做的就是这样 
Because now what I'm going to go ahead and do is this.

356
00:17:12,871 --> 00:17:14,579
我将重新运行valiate.py的python 
I'm going to rerun python of validate.py.

357
00:17:14,579 --> 00:17:17,040
我将继续测试我自己的电子邮件地址 只是为了
And I'm going to keep testing my own email address just to make

358
00:17:17,040 --> 00:17:18,415
当然 我没有让事情变得更糟 
sure I haven't made things worse.

359
00:17:18,415 --> 00:17:19,800
现在一切都好了 
And that's now OK.

360
00:17:19,800 --> 00:17:22,530
现在我要继续输入一些其他的内容 
I'm now going to go ahead and type in some other input,

361
00:17:22,530 --> 00:17:28,380
就像没有域名的马兰@怎么样 
like how about just malan@ with no domain name whatsoever.

362
00:17:28,380 --> 00:17:30,640
你可能会认为这将是无效的 
And you would think this is going to be invalid.

363
00:17:30,640 --> 00:17:34,680
但是 但是 但是它仍然被认为是有效的 
But, but, but it's still considered valid.

364
00:17:34,680 --> 00:17:35,850
但为什么会这样呢？
But why is that?

365
00:17:35,850 --> 00:17:42,120
如果我回到这张图表 为什么现在没有域名的情况下会考虑Malan@
If I go back to this chart, why is malan@ with no domain now considered

366
00:17:42,120 --> 00:17:43,260
有效吗？
valid?

367
00:17:43,260 --> 00:17:50,010
我在这里使用.*@.*作为正则表达式 这有什么错误
What's my mistake here by having used .*@.* as my regular expression

368
00:17:50,010 --> 00:17:50,670
还是正则表达式？
or regex?

369
00:17:50,670 --> 00:17:54,355
观众：因为你用的是* 而不是加号 
AUDIENCE: Because you're using the * instead of the plus sign.

370
00:17:54,355 --> 00:17:55,230
大卫·马兰：没错 
DAVID MALAN: Exactly.

371
00:17:55,230 --> 00:17:58,090
再说一次 *表示零次或多次重复 
The *, again, means zero or more repetitions.

372
00:17:58,090 --> 00:18:03,120
所以re.earch非常乐意在@符号之后什么都不接受 
So re.search is perfectly happy to accept nothing after the @ sign,

373
00:18:03,120 --> 00:18:05,230
因为这将是零重复 
because that would be zero repetitions.

374
00:18:05,230 --> 00:18:09,000
所以我认为我至少需要改进这一点 然后回到我这里的代码 
So I think I minimally need to evolve this and go back to my code here.

375
00:18:09,000 --> 00:18:12,990
让我继续 把这个从点*改为点+ 
And let me go ahead and change this from dot * to dot +.

376
00:18:12,990 --> 00:18:16,620
让我把结尾从点*改成点+
And let me change the ending from dot * to dot +

377
00:18:16,620 --> 00:18:18,900
所以现在当我在这里运行代码时--
so that now when I run my code here--

378
00:18:18,900 --> 00:18:21,510
让我继续运行valiate.py的python 
let me go ahead and run python of validate.py.

379
00:18:21,510 --> 00:18:23,490
我要像往常一样测试我的电子邮件地址 
I'm going to test my email address as always.

380
00:18:23,490 --> 00:18:24,600
还在工作 
Still working.

381
00:18:24,600 --> 00:18:27,690
现在让我继续输入之前的相同内容
Now let me go ahead and type in that same thing from before that

382
00:18:27,690 --> 00:18:29,820
意外地被认为是有效的 
was accidentally considered valid.

383
00:18:29,820 --> 00:18:32,590
现在我按了回车 最后它是无效的 
Now I hit Enter, finally it's invalid.

384
00:18:32,590 --> 00:18:35,460
所以现在我们正在取得一些进展 在多一点
So now we're making some progress on being a little more

385
00:18:35,460 --> 00:18:37,560
准确地知道我们在做什么 
precise as to what it is we're doing.

386
00:18:37,560 --> 00:18:40,920
现在 我要在这里指出 就像编程中的几乎所有事情一样 
Now, I'll note here, like with almost everything in programming,

387
00:18:40,920 --> 00:18:45,090
包括Python在内 通常有多种方法来解决相同的问题 
Python included, there's often multiple ways to solve the same problem.

388
00:18:45,090 --> 00:18:49,410
有没有人在我的代码中发现了什么
And does anyone see a way in my code here

389
00:18:49,410 --> 00:18:54,360
如果我忘记了加号运算符的存在 我可以稍作调整
that I can make a slight tweak if I forgot that the plus operator exists

390
00:18:54,360 --> 00:18:56,880
然后重新使用*？
and go back to using a *?

391
00:18:56,880 --> 00:19:00,570
如果我只允许你使用圆点和星号 
If I allowed you only to use dots and only stars,

392
00:19:00,570 --> 00:19:03,570
你能再创造一个加号的概念吗？
could you recreate the notion of plus?

393
00:19:03,570 --> 00:19:04,890
观众：是的 
AUDIENCE: Yes.

394
00:19:04,890 --> 00:19:06,930
使用另一个点 点点* 
Use another dot, dot dot *.

395
00:19:06,930 --> 00:19:07,680
大卫·马兰：是的 
DAVID MALAN: Yeah.

396
00:19:07,680 --> 00:19:10,290
因为如果圆点表示任何字符 我们将只使用圆点 
Because if a dot means any character, we'll just use a dot.

397
00:19:10,290 --> 00:19:14,040
然后当你想说“or more”时 用另一个点 然后用* 
And then when you want to say "or more," use another dot and then the *.

398
00:19:14,040 --> 00:19:18,300
所以等同于点+的应该是点* 
So equivalent to dot + would have been dot dot *,

399
00:19:18,300 --> 00:19:21,870
因为第一个点表示任何字符 而第二对点表示任何字符
because the first dot means any character, and the second pair

400
00:19:21,870 --> 00:19:25,050
在字符中 点*表示零个或多个其他字符 
of characters, dot *, means zero or more other characters.

401
00:19:25,050 --> 00:19:27,600
需要明确的是 它不一定是同一个角色 
And to be clear, it doesn't have to be the same character.

402
00:19:27,600 --> 00:19:31,830
只做点或点*并不意味着您的整个用户名需要
Just by doing dot or dot * does not mean your whole username needs to be

403
00:19:31,830 --> 00:19:35,310
A 或AA 或AAA 或AAAA 
a, or aa, or aaa, or aaaa.

404
00:19:35,310 --> 00:19:37,230
它可以随每个符号而不同 
It can vary with each symbol.

405
00:19:37,230 --> 00:19:41,790
它只是指背靠背的任何字符的零个或多个 
It just means zero or more of any character back to back.

406
00:19:41,790 --> 00:19:44,050
所以我可以在左边和右边做这件事 
So I could do this on both the left and the right.

407
00:19:44,050 --> 00:19:45,120
哪一个更好？
Which one is better?

408
00:19:45,120 --> 00:19:46,110
你知道 这要看情况 
You know, it depends.

409
00:19:46,110 --> 00:19:49,860
我认为可以提出一个论点 这一点甚至更清楚 因为它
I think an argument could be made that this is even more clear, because it's

410
00:19:49,860 --> 00:19:52,380
很明显 现在有一个圆点 意思是任何字符 
obvious now that there's a dot, which means any character,

411
00:19:52,380 --> 00:19:53,910
然后是圆点* 
and then there's the dot *.

412
00:19:53,910 --> 00:19:56,250
但如果你习惯于经常这样做 
But if you're in the habit of doing this frequently,

413
00:19:56,250 --> 00:19:58,500
像加号这样的东西存在的原因之一
one of the reasons things like the plus exist

414
00:19:58,500 --> 00:20:01,750
只是将您的代码合并到更简洁的内容中 
is just to consolidate your code into something a little more succinct.

415
00:20:01,750 --> 00:20:03,750
如果你对现在看到的好处很熟悉 
And if you're familiar with seeing the plus now,

416
00:20:03,750 --> 00:20:05,470
也许这对你来说更具可读性 
maybe this is more readable to you.

417
00:20:05,470 --> 00:20:07,590
所以再一次 就像更一般的Python一样 
So again, just like with Python more generally,

418
00:20:07,590 --> 00:20:10,590
你会经常看到不同的方式来表达相同的模式 
you're going to often see different ways to express the same patterns,

419
00:20:10,590 --> 00:20:12,750
理性的人可能会同意 也可能不同意
and reasonable people might agree or disagree

420
00:20:12,750 --> 00:20:15,810
哪种方式比另一种方式更好 
as to which way is better than another.

421
00:20:15,810 --> 00:20:18,030
好吧 让我向你提议 我们可以认为
Well, let me propose to you that we can think

422
00:20:18,030 --> 00:20:20,520
关于这两个模型的更多一点图形化 
about both of these models a little more graphically.

423
00:20:20,520 --> 00:20:22,770
如果你觉得这有点神秘 让我继续说下去
If this looks a little cryptic to you, let me go ahead

424
00:20:22,770 --> 00:20:26,610
并回溯到此正则表达式的前一个实例 该正则表达式
and rewind to the previous incarnation of this regular expression, which

425
00:20:26,610 --> 00:20:28,830
只有一个点* 
was just a single dot *.

426
00:20:28,830 --> 00:20:32,910
这个正则表达式.*@.*又意味着什么？
This regular expression, .*@.* means what again?

427
00:20:32,910 --> 00:20:36,690
它表示零个或多个字符 后跟文字符号@
It means zero or more characters followed by a literal @ sign followed

428
00:20:36,690 --> 00:20:38,580
零个或多个其他字符 
by zero or more other characters.

429
00:20:38,580 --> 00:20:41,850
现在 当您将此模式作为参数传递给re.earch时 
Now when you pass this pattern in as an argument to re.search,

430
00:20:41,850 --> 00:20:45,030
它将从左到右读取它 然后使用
it's going to read it from left to right and then use

431
00:20:45,030 --> 00:20:48,750
它尝试与输入进行匹配 在本例中为电子邮件 
it to try to match against the input, email, in this case,

432
00:20:48,750 --> 00:20:50,100
用户输入的 
that the user typed in.

433
00:20:50,100 --> 00:20:53,070
现在 你的电脑怎么样了 re.earch怎么样了
Now, how is the computer, how is re.search

434
00:20:53,070 --> 00:20:57,760
要跟踪用户的电子邮件是否与此模式匹配？
going to keep track of whether or not the user's email matches this pattern?

435
00:20:57,760 --> 00:21:01,230
嗯 结果是它将使用一种实现的机器
Well, it turns out that it's going to be using a machine of sorts implemented

436
00:21:01,230 --> 00:21:03,540
在被称为有限状态机或更多的软件中
in software known as a finite state machine, or more

437
00:21:03,540 --> 00:21:06,750
形式上 一个不确定的有限自动机 
formally, a nondeterministic finite automaton.

438
00:21:06,750 --> 00:21:09,930
如果我们用图形来描述它 它的工作方式如下所示 
And the way it works, if we depict this graphically, is as follows.

439
00:21:09,930 --> 00:21:14,940
Re.earch函数从这里开始 处于所谓的开始状态 
The re.search function starts over here in a so-called start state.

440
00:21:14,940 --> 00:21:16,980
这就是它开始时的那种情况 
That's the sort of condition in which it begins.

441
00:21:16,980 --> 00:21:20,730
然后它将从左到右读取用户的电子邮件地址 
And then it's going to read the user's email address from left to right.

442
00:21:20,730 --> 00:21:24,030
它将决定是否留在第一个状态
And it's going to decide whether or not to stay in this first state

443
00:21:24,030 --> 00:21:26,170
或者转换到下一个状态 
or transition to the next state.

444
00:21:26,170 --> 00:21:29,970
例如 在第一个状态中 当用户正在阅读我的电子邮件地址时 
So for instance, in this first state, as the user is reading my email address,

445
00:21:29,970 --> 00:21:35,130
它将沿着这个弯曲的边缘向上和向四周移动
malan@harvard.edu, it's going to follow this curved edge up and around

446
00:21:35,130 --> 00:21:36,870
对它本身来说 是一种反身性的优势 
to itself, a reflexive edge.

447
00:21:36,870 --> 00:21:40,030
它被标记为点 因为点 再一次 只是指任何字符 
And it's labeled dot, because dot, again, just means any character.

448
00:21:40,030 --> 00:21:43,840
因此 由于该函数正在读取我的电子邮件地址 即Malan@atherard.edu 
So as the function is reading my email address, malan@harvard.edu,

449
00:21:43,840 --> 00:21:48,270
从左到右 它将遵循如下的转变 
from left to right, it's going to follow these transitions as follows,

450
00:21:48,270 --> 00:21:53,070
并购-并购-L-A-N
M-A-L-A-N.

451
00:21:53,070 --> 00:21:56,040
然后 它有望在这种过渡之后
And then it's hopefully going to follow this transition

452
00:21:56,040 --> 00:22:00,000
转到第二个状态 因为这台机器中有一个字面符号@
to the second state, because there's a literal @ sign both in this machine

453
00:22:00,000 --> 00:22:01,630
以及在我的电子邮件地址中 
as well as in my email address.

454
00:22:01,630 --> 00:22:10,070
然后它将尝试读取我地址的其余部分 H-A-R-V-A-R-D点E-D-U 
Then it's going to try to read the rest of my address, H-A-R-V-A-R-D dot E-D-U,

455
00:22:10,070 --> 00:22:11,190
就是这样 
and that's it.

456
00:22:11,190 --> 00:22:12,870
然后电脑就会进行检查 
And then the computer is going to check.

457
00:22:12,870 --> 00:22:16,260
它最终是以接受状态 最终状态 
Did it end up in an accept state, a final state,

458
00:22:16,260 --> 00:22:18,120
它实际上在这里被生动地描绘出来
that's actually depicted here pictorially

459
00:22:18,120 --> 00:22:21,150
两个圆圈 一个在另一个里面 有一点不同吗？
a little differently with double circles, one inside of the other?

460
00:22:21,150 --> 00:22:25,410
这就意味着 如果计算机发现自己在那一秒
And that just means that if the computer finds itself in that second

461
00:22:25,410 --> 00:22:29,130
在已经读取所有用户输入之后的接受状态 
accept state after having read all of the user's input,

462
00:22:29,130 --> 00:22:31,560
这确实是一个有效的电子邮件地址 
it is, indeed, a valid email address.

463
00:22:31,560 --> 00:22:34,350
如果碰巧 机器以某种方式结束了
If by some chance, the machine somehow ended up

464
00:22:34,350 --> 00:22:37,020
停留在第一种状态 它没有双圈
stuck in that first state, which does not have double circles

465
00:22:37,020 --> 00:22:39,300
并且因此不是接受状态 则计算机
and is therefore not an accept state, the computer

466
00:22:39,300 --> 00:22:42,810
这是一个无效的电子邮件地址 
would conclude this is an invalid email address instead.

467
00:22:42,810 --> 00:22:45,630
相比之下 如果我们回到我的另一个版本 
By contrast, if we go back to my other your version

468
00:22:45,630 --> 00:22:49,800
我在代码的左右两边都用了点+ 
of the code where I instead had dot plus on both the left and the right,

469
00:22:49,800 --> 00:22:53,130
回想一下 re.search将使用其中一个状态机
recall that re.search is going to use one of these state machines

470
00:22:53,130 --> 00:22:57,030
为了从左到右决定是否接受用户的
in order to decide from left to right whether or not to accept the user's

471
00:22:57,030 --> 00:22:59,310
输入 如malan@harvard.edu 
input, like malan@harvard.edu.

472
00:22:59,310 --> 00:23:02,850
我们能从开始状态 到接受状态吗
Can we get from the start state, so to speak, to an accept state

473
00:23:02,850 --> 00:23:05,940
来决定 对 这其实是符合规律的 
to decide, yep, this was, in fact, meeting the pattern?

474
00:23:05,940 --> 00:23:09,900
好吧 让我们假设这个不确定的有限自动机
Well, let's propose that this nondeterministic finite automaton

475
00:23:09,900 --> 00:23:11,430
看起来像这样
looked like this instead.

476
00:23:11,430 --> 00:23:14,310
我们将从最左边的开始状态开始 
We're going to start as before in the leftmost start state,

477
00:23:14,310 --> 00:23:18,180
我们必须在第一条边上使用一个字符 
and we're going to necessarily consume one character per this first edge,

478
00:23:18,180 --> 00:23:21,480
它用一个点标记 表示我们可以使用任何一个字符 
which is labeled with a dot to indicate that we can consume any one character,

479
00:23:21,480 --> 00:23:24,411
比如malan@harvard.edu中的m 
like the m in malan@harvard.edu.

480
00:23:24,411 --> 00:23:27,960
然后我们可以花一些时间在@符号之前消耗更多的字符 
Then we can spend some time consuming more characters before the @ sign,

481
00:23:27,960 --> 00:23:31,290
所以A-L-A-N
so the A-L-A-N.

482
00:23:31,290 --> 00:23:33,340
然后我们可以使用@符号 
Then we can consume the @ sign.

483
00:23:33,340 --> 00:23:36,270
那么我们至少可以多消耗一个角色 因为回忆一下
Then we can consume at least one more character, because recall

484
00:23:36,270 --> 00:23:38,760
正则表达式这次有点加号
that the regex has dot plus this time.

485
00:23:38,760 --> 00:23:42,190
如果我们愿意的话 我们可以使用更多的字符 
And then we can consume even more characters if we want.

486
00:23:42,190 --> 00:23:45,900
所以如果我们首先在harvard.edu中使用H 
So if we first consume the H in harvard.edu,

487
00:23:45,900 --> 00:23:53,885
然后留下A-R-V-A-R-D 然后点E-D-U
then leaves the A-R-V-A-R-D, and then dot E-D-U.

488
00:23:53,885 --> 00:23:56,560
现在我们也到了故事的结尾
And now here, too, we're at the end of the story,

489
00:23:56,560 --> 00:23:59,760
但我们处于接受状态 因为最后的圆圈
but we're in an accept state, because that circle at the end

490
00:23:59,760 --> 00:24:03,840
一共有两个圆 这意味着如果计算机 如果这个函数 
has two circles total, which means that if the computer, if this function,

491
00:24:03,840 --> 00:24:07,830
在读取了用户的全部
finds itself in that accept state after reading the entirety of the user's

492
00:24:07,830 --> 00:24:11,580
实际上 它也是一个有效的电子邮件地址 
input, it is, too, in fact, a valid email address.

493
00:24:11,580 --> 00:24:15,390
如果相反 我们被困在另一个州 
If by contrast, we had gotten stuck in one of those other states,

494
00:24:15,390 --> 00:24:18,180
无法跟随一个过渡 其中一个边缘 
unable to follow a transition, one of those edges,

495
00:24:18,180 --> 00:24:22,440
并且因此不能在用户的输入中从左到右取得进展 
and therefore unable to make progress in the user's input from left to right,

496
00:24:22,440 --> 00:24:26,670
那么我们将不得不得出结论 电子邮件地址实际上是无效的 
then we would have to conclude that email address is, in fact, invalid.

497
00:24:26,670 --> 00:24:29,490
那么 我们如何才能进一步批准这个代码呢？
Well, how can we go upon approving this code further?

498
00:24:29,490 --> 00:24:33,660
现在让我提议 我们不仅要检查用户名 还要检查一些
Let me propose now that we check not only for a username and also something

499
00:24:33,660 --> 00:24:37,320
在用户名之后 类似于域名 但最低要求字符串
after the username, like a domain name, but minimally require that the string

500
00:24:37,320 --> 00:24:39,600
也以.edu结尾 
ends with .edu as well.

501
00:24:39,600 --> 00:24:41,970
嗯 我想我可以很直接地这样做 
Well, I think I could do this fairly straightforward.

502
00:24:41,970 --> 00:24:44,940
我不仅希望在@符号之后有一些东西 
Not only do I want there to be something after the @ sign,

503
00:24:44,940 --> 00:24:49,818
就像哈佛这样的域名一样 我希望整件事以.edu结尾 
like the domain like Harvard, I want the whole thing to end with .edu.

504
00:24:49,818 --> 00:24:52,320
但这里有一点危险 
But there's a little bit of danger here.

505
00:24:52,320 --> 00:24:57,660
现在以这种方式实现我的正则表达式 我做错了什么
What have I done wrong by implementing my regular expression now in this way,

506
00:24:57,660 --> 00:24:59,110
通过使用.+@.+.edu？
by using .+@.+.edu?

507
00:25:01,938 --> 00:25:06,080
这个版本可能会出什么问题？
What could go wrong with this version?

508
00:25:06,080 --> 00:25:08,360
观众：这个圆点--这个圆点意味着什么
AUDIENCE: The dot is-- the dot means something

509
00:25:08,360 --> 00:25:11,510
否则在本文中 它意味着三次或三次以上的重复
else in this context, where it means three or more repetitions

510
00:25:11,510 --> 00:25:14,630
这就是为什么它会解释它[INAUDIBLE]..
of a character, which is why it will interpret it [INAUDIBLE]..

511
00:25:14,630 --> 00:25:15,570
大卫·马兰：没错 
DAVID MALAN: Exactly.

512
00:25:15,570 --> 00:25:19,340
尽管我的意思是字面意思是.edu 一个句号 
Even though I mean for it to mean literally .edu, a period,

513
00:25:19,340 --> 00:25:22,560
然后是.edu 不幸的是 在正则表达式世界中 
and then .edu, unfortunately in the world of regular expressions,

514
00:25:22,560 --> 00:25:26,720
点表示任何字符 这意味着从技术上讲 该字符串可以结束
dot means any character, which means that this string could technically end

515
00:25:26,720 --> 00:25:34,080
在埃杜 或贝杜 或雪松 等等 但这并不是 事实上 我想要的 
in aedu, or bedu, or cedu, and so forth, but that's not, in fact, that I want.

516
00:25:34,080 --> 00:25:37,670
那么 我现在对如何解决这个问题有什么直觉吗？
So any instincts now as to how I could fix this problem?

517
00:25:37,670 --> 00:25:39,770
让我更清楚地说明这个问题 
And let me demonstrate the problem more clearly.

518
00:25:39,770 --> 00:25:41,900
让我继续在这里运行这段代码 
Let me go ahead and run this code here.

519
00:25:41,900 --> 00:25:45,050
让我继续输入Malan@greavard.edu 
Let me go ahead and type in malan@harvard.edu.

520
00:25:45,050 --> 00:25:47,240
而且一如既往 这确实奏效了 
And as always, this does, in fact, work.

521
00:25:47,240 --> 00:25:48,680
但看看这里会发生什么 
But watch what happens here.

522
00:25:48,680 --> 00:25:52,520
让我继续做马兰@哈佛 然后--
Let me go ahead and do malan@harvard and then--

523
00:25:52,520 --> 00:25:57,992
马兰@哈佛？埃杜 输入 这也是有效的 
malan@harvard?edu, Enter, that, too, is valid.

524
00:25:57,992 --> 00:26:00,950
所以我可以把任何角色放在那里 它仍然会被接受 
So I could put any character there and it's still going to be accepted.

525
00:26:00,950 --> 00:26:02,420
但我不想要？埃杜 
But I don't want ?edu.

526
00:26:02,420 --> 00:26:04,670
我想要.EDU字面意思 
I want .edu literally.

527
00:26:04,670 --> 00:26:08,700
那么 对于我们如何在这里解决这个问题 你有什么直觉吗？
Any instincts, then, for how we can solve this problem here?

528
00:26:08,700 --> 00:26:12,770
我如何才能获得这个新函数re.earch和正则表达式
How can I get this new function, re.search, and a regular expression

529
00:26:12,770 --> 00:26:16,160
更笼统地说 字面意思是一个点 你觉得呢？
more generally, to literally mean a dot, might you think?

530
00:26:16,160 --> 00:26:19,257
观众：你可以用转义字符 反斜杠？
AUDIENCE: You can use the escape character, the backslash?

531
00:26:19,257 --> 00:26:20,090
大卫·马兰：确实如此 
DAVID MALAN: Indeed.

532
00:26:20,090 --> 00:26:22,927
所谓的逃逸角色 我们以前在外面见过
The so-called escape character, which we've seen before outside

533
00:26:22,927 --> 00:26:25,760
正则表达式的上下文 当我们讨论换行符时 
of the context of regular expressions when we talked about newlines.

534
00:26:25,760 --> 00:26:29,640
反斜杠n是一种告诉计算机我需要换行符的方式 
Backslash n was a way of telling the computer I want a newline,

535
00:26:29,640 --> 00:26:32,810
但实际上并没有真正地按下Enter键并亲自移动光标 
but without actually literally hitting Enter and moving the cursor yourself.

536
00:26:32,810 --> 00:26:35,090
你不会想在屏幕上出现文字n的 
And you don't want a literal n on the screen.

537
00:26:35,090 --> 00:26:39,350
因此 反斜杠n是转义n并表示您需要换行符的一种方式 
So backslash n was a way to escape n and convey that you want a newline.

538
00:26:39,350 --> 00:26:41,900
事实证明 正则表达式使用类似的技术
It turns out regular expressions use a similar technique

539
00:26:41,900 --> 00:26:43,640
在这里解决这个问题 
to solve this problem here.

540
00:26:43,640 --> 00:26:45,770
事实上 让我来看看我的正则表达式 
In fact, let me go into my regular expression.

541
00:26:45,770 --> 00:26:49,370
在最后一个点之前 让我加一个反斜杠 
And before that final dot, let me put a single backslash.

542
00:26:49,370 --> 00:26:52,880
在正则表达式的世界中 这是一个所谓的特殊序列 
In the world of regular expressions, this is a so-called special sequence.

543
00:26:52,880 --> 00:26:55,940
它表明 根据这个反斜杠和一个单点 
And it indicates, per this backslash and a single dot,

544
00:26:55,940 --> 00:26:58,290
我真的想要在一个点上匹配 
that I literally want to match on a dot.

545
00:26:58,290 --> 00:27:02,180
这并不是说我想要匹配任何角色 然后就是edu 
It's not that I want to match on any character and then edu.

546
00:27:02,180 --> 00:27:05,300
我想匹配一个点 或一个句点 edu 
I want to match on a dot, or a period, edu.

547
00:27:05,300 --> 00:27:09,050
但是我们不希望Python曲解这个反斜杠
But we don't want Python to misinterpret this backslash

548
00:27:09,050 --> 00:27:12,710
作为转义序列的开始 一些特殊的东西 如反斜杠
as beginning an escape sequence, something special like backslash

549
00:27:12,710 --> 00:27:15,590
N 即使我们作为程序员可能会键入两个字符
n, which even though we as the programmer might type two characters

550
00:27:15,590 --> 00:27:20,090
反斜杠n 它实际上被Python解释为一个换行符 
backslash n, it really is interpreted by Python as a single newline.

551
00:27:20,090 --> 00:27:22,833
我们不希望在这里出现任何类似的误解 
We don't want any kind of misinterpretation like that here.

552
00:27:22,833 --> 00:27:26,000
因此 对于正则表达式 我们还应该做另一件事
So it turns out there's one other thing we should do for regular expressions

553
00:27:26,000 --> 00:27:29,180
像这样有一个反斜杠是这样用的 
like this that have a backslash used in this way.

554
00:27:29,180 --> 00:27:33,440
我想向Python指定我想要这个字符串、这个正则表达式
I want to specify to Python that I want this string, this regular expression

555
00:27:33,440 --> 00:27:36,200
在双引号中 将被视为原始字符串 
in double quotes, to be treated as a raw string,

556
00:27:36,200 --> 00:27:38,510
字面意思是将r放在字符串的开头
literally putting an r at the beginning of the string

557
00:27:38,510 --> 00:27:41,240
向Python指示您不应尝试解释
to indicate to Python that you should not try to interpret

558
00:27:41,240 --> 00:27:43,550
以常规方式添加任何反斜杠 
any backslashes in the usual way.

559
00:27:43,550 --> 00:27:46,850
我想按字面意思传递反斜杠、点和edu
I want to literally pass the backslash and the dot and the edu

560
00:27:46,850 --> 00:27:50,030
进入这个特殊的功能 搜索 在本例中 
into this particular function, search, in this case.

561
00:27:50,030 --> 00:27:53,750
因此它在本质上类似于在格式开头使用f
So it's similar in spirit to using that f at the beginning of a format

562
00:27:53,750 --> 00:27:57,170
字符串 当然 它告诉Python以某种方式格式化字符串 
string, which, of course, tells Python to format the string in a certain way,

563
00:27:57,170 --> 00:27:59,720
插入可能在大括号之间的变量 
plugging in variables that might be between curly braces.

564
00:27:59,720 --> 00:28:02,900
但在本例中 r表示原始字符串
But in this case, r indicates a raw string

565
00:28:02,900 --> 00:28:05,570
我想要完全按照原样传递 
that I want passed in exactly as is.

566
00:28:05,570 --> 00:28:09,380
现在 只有在使用反斜杠的情况下 才有必要这样做
Now, it's only strictly necessary if you are, in fact, using backslashes

567
00:28:09,380 --> 00:28:12,860
表示您需要一些特殊的序列 如反斜杠圆点 
to indicate that you want some special sequence, like backslash dot.

568
00:28:12,860 --> 00:28:14,750
但总的来说 这可能是一个好习惯
But in general, it's probably a good habit

569
00:28:14,750 --> 00:28:18,540
了解如何只对所有正则表达式使用原始字符串
to get into to just use raw strings for all of your regular expressions

570
00:28:18,540 --> 00:28:21,480
所以如果你最终回到里面 做一些改变 增加一些东西 
so that if you eventually go back in, make a change, make an addition,

571
00:28:21,480 --> 00:28:23,600
您不会意外地引入反斜杠
you don't accidentally introduce a backslash

572
00:28:23,600 --> 00:28:28,113
然后忘记这可能有一些特殊的或被误解的意思 
and then forget that that might have some special or misinterpreted meaning.

573
00:28:28,113 --> 00:28:30,530
好了 让我们继续尝试这个新的正则表达式 
Well, let me go ahead and try this new regular expression.

574
00:28:30,530 --> 00:28:34,430
我将清除我的终端窗口 运行VALIDATE--
I'll clear my terminal window, run python of validate--

575
00:28:34,430 --> 00:28:36,800
运行valiate.py的python 
run python of validate.py.

576
00:28:36,800 --> 00:28:40,496
然后我会正确地输入我的电子邮件地址：Malan@atherard.edu 
And then I'll type in my email address correctly, malan@harvard.edu.

577
00:28:40,496 --> 00:28:42,710
幸运的是 这一点仍然有效 
And that's, fortunately, still valid.

578
00:28:42,710 --> 00:28:46,490
让我清空屏幕并再次运行一次 即valiate.py的python 
Let me clear my screen and run it one more time, python of validate.py.

579
00:28:46,490 --> 00:28:50,930
这一次 让我们把它错误地输入为Malan@Harvard？Edu 
And this time, let's mistype it as malan@harvard?edu,

580
00:28:50,930 --> 00:28:53,540
很明显那里没有一个圆点 
whereby there's obviously not a dot there,

581
00:28:53,540 --> 00:28:57,710
但上一次还有其他一些单字被曲解了
but there is some other single character that last time was misinterpreted

582
00:28:57,710 --> 00:28:58,430
是有效的 
as valid.

583
00:28:58,430 --> 00:29:01,970
但这一次 既然我已经改进了正则表达式 
But this time, now that I've improved my regular expression,

584
00:29:01,970 --> 00:29:05,270
它被发现确实是无效的 
it's discovered as, indeed, invalid.

585
00:29:05,270 --> 00:29:10,850
现在对@左边的匹配技巧有什么疑问吗？
Any questions now on this technique for matching something to the left of the @

586
00:29:10,850 --> 00:29:15,320
签名 右边的东西 现在明确地以.edu结尾？
sign, something to the right, and now ending with .edu explicitly?

587
00:29:15,320 --> 00:29:18,582
观众：当用户插入多个@符号时会发生什么？
AUDIENCE: What happens when user inserts multiple @ signs?

588
00:29:18,582 --> 00:29:19,790
大卫·马兰：问得好 
DAVID MALAN: A good question.

589
00:29:19,790 --> 00:29:21,320
你把我叫到了这里 
And you kind of called me out here.

590
00:29:21,320 --> 00:29:22,910
好吧 如果有疑问 让我们试一试 
Well, when in doubt, let's try.

591
00:29:22,910 --> 00:29:29,340
让我继续执行validate.py、Malan@atherard.edu、
Let me go ahead and do python of validate.py, malan@@@harvard.edu,

592
00:29:29,340 --> 00:29:34,020
这也是不正确的 不幸的是 我的代码认为它是有效的 
which also is incorrect, unfortunately, my code thinks it's valid.

593
00:29:34,020 --> 00:29:37,490
因此 这是另一个需要解决的问题 但目前还存在不足 
So another problem to solve, but a shortcoming for now.

594
00:29:37,490 --> 00:29:41,510
到目前为止 关于这些正则表达式还有其他问题吗？
Other questions on these regular expressions thus far?

595
00:29:41,510 --> 00:29:46,108
观众：你能用大括号m代替反斜杠吗？
AUDIENCE: Can you use curly brackets m instead of backslash?

596
00:29:46,108 --> 00:29:48,650
大卫·马兰：你能用大括号代替反斜杠吗？
DAVID MALAN: Can you use curly brackets instead of backslash?

597
00:29:48,650 --> 00:29:49,490
在这种情况下不是这样 
Not in this case.

598
00:29:49,490 --> 00:29:53,750
如果你想要一个字面点 反斜线点是字面上的方法 
If you want a literal dot, backslash dot is the way to do it literally.

599
00:29:53,750 --> 00:29:56,660
关于正则表达式的另一个问题如何？
How about one other question on regular expressions?

600
00:29:56,660 --> 00:30:00,620
观众：这和Google Forms用来订购的东西是一样的吗
AUDIENCE: Is this the same thing that Google Forms uses in order

601
00:30:00,620 --> 00:30:06,590
为了将数据分类 假设是一些--如果您有多个人发送
to categorize data in, let's say, some-- if you've got multiple people sending

602
00:30:06,590 --> 00:30:09,380
关于一些反馈的请求？
in requests about some feedback?

603
00:30:09,380 --> 00:30:12,170
他们是否对他们获得的数据进行分类
Do they categorize the data that they get

604
00:30:12,170 --> 00:30:14,247
使用这个特殊的正则表达式吗？
using this particular regular expression thing?

605
00:30:14,247 --> 00:30:15,080
大卫·马兰：确实如此 
DAVID MALAN: Indeed.

606
00:30:15,080 --> 00:30:17,450
如果你曾经使用过谷歌表格 而不仅仅是提交它
If you've ever used Google Forms to not just submit it

607
00:30:17,450 --> 00:30:20,900
但要创建Google表单 菜单选项之一
but to create a Google Form, one of the menu options

608
00:30:20,900 --> 00:30:23,570
是为了响应验证 至少在英语中是这样 
is for response validation, in English at least.

609
00:30:23,570 --> 00:30:25,340
这样做的目的是指定
And what that allows you to do is specify

610
00:30:25,340 --> 00:30:29,060
用户必须输入电子邮件地址或URL 
that the user has to input an email address, or a URL,

611
00:30:29,060 --> 00:30:31,400
或者一根有一定长度的绳子 
or a string of some length.

612
00:30:31,400 --> 00:30:33,830
但还有一个更强大的功能 你们中的一些人
But there's an even more powerful feature that some of you

613
00:30:33,830 --> 00:30:35,150
可能从来没有注意到 
may not have ever noticed.

614
00:30:35,150 --> 00:30:37,340
事实上 如果你想打开谷歌表格 
And indeed, if you'd like to open up Google Forms,

615
00:30:37,340 --> 00:30:41,180
临时创建一个新的表单 然后四处查看 您将真正看到 
create a new form temporarily, and poke around, you will actually see,

616
00:30:41,180 --> 00:30:44,270
至少在英语中 引号 不引号“Regular Expression”
in English at least, quote, unquote "regular expression"

617
00:30:44,270 --> 00:30:46,070
提到的一种机制 您可以
mentioned as one of the mechanisms you can

618
00:30:46,070 --> 00:30:49,520
用于验证用户对您的Google表单的输入 
use to validate your users' input into your Google Form.

619
00:30:49,520 --> 00:30:53,690
因此 事实上 从今天开始 您可以开始避免特定的下拉列表
So in fact, after today you can start avoiding the specific dropdowns

620
00:30:53,690 --> 00:30:55,610
类似的电子邮件地址或URL等 
of like email address, or URL, or the like,

621
00:30:55,610 --> 00:30:59,540
你也可以准确地表达你自己的模式 
and you can express your own patterns precisely as well.

622
00:30:59,540 --> 00:31:02,900
正则表达式甚至可以在VS代码本身中使用 
Regular expressions can even be used in VS Code itself.

623
00:31:02,900 --> 00:31:06,440
如果您在VS代码中查找或执行查找和替换 
If you go and find, or do a find and replace in VS Code,

624
00:31:06,440 --> 00:31:08,690
当然 您可以像您所能做的那样 只需输入单词
you can, of course, just type in words, like you could

625
00:31:08,690 --> 00:31:10,880
到Microsoft Word或Google Docs 
into Microsoft Word or Google Docs.

626
00:31:10,880 --> 00:31:14,990
如果选中正确的框 您还可以键入正则表达式
You can also type, if you check the right box, regular expressions

627
00:31:14,990 --> 00:31:19,670
并开始寻找模式 而不是字面上的具体值 
and start searching for patterns, not literally specific values.

628
00:31:19,670 --> 00:31:24,080
好吧 让我建议我们现在进一步加强这个实现
Well, let me propose that we now enhance this implementation further

629
00:31:24,080 --> 00:31:28,010
通过引入一些其他的符号 因为现在我的代码 
by introducing a few other symbols, because right now with my code,

630
00:31:28,010 --> 00:31:32,540
我一直说我希望我的电子邮件地址以.edu结尾 以.edu开头 
I keep saying that I want my email address to end with .edu and start with

631
00:31:32,540 --> 00:31:35,780
一个用户名但我有点太慷慨了
a username, but I'm being a little too generous.

632
00:31:35,780 --> 00:31:38,690
事实上 这对我自己的电子邮件地址来说是正常的 
This does, in fact, work as expected for my own email address,

633
00:31:38,690 --> 00:31:40,928
malan@harvard.edu.
malan@harvard.edu.

634
00:31:40,928 --> 00:31:45,350
但是如果我输入一个句子 比如“我的电子邮件地址
But what if I type in a sentence like, "my email address

635
00:31:45,350 --> 00:31:50,180
是malan@harvard.edu ”假设我已经把它输入到程序中 
is malan@harvard.edu," and suppose I've typed that into the program

636
00:31:50,180 --> 00:31:52,310
或者我已经把它输入到谷歌表单里了
or I've typed that into a Google Form?

637
00:31:52,310 --> 00:31:57,680
这将被视为有效或无效？
Is this going to be considered valid or invalid?

638
00:31:57,680 --> 00:31:59,390
好吧 让我们考虑一下 
Well, let's consider.

639
00:31:59,390 --> 00:32:01,970
它有@符号 所以我们很好 
It's got @ sign, so we're good there.

640
00:32:01,970 --> 00:32:05,570
它在@符号的左边有一个或多个字符 
It's got one or more characters to the left of the @ sign.

641
00:32:05,570 --> 00:32:09,050
它在@符号的右边有一个或多个字符 
It's got one or more characters to the right of the @ sign.

642
00:32:09,050 --> 00:32:14,390
在@符号的右边有一个文字.edu 
It's got a literal .edu somewhere in there to the right of the @ sign.

643
00:32:14,390 --> 00:32:16,460
当然 右边有更多的东西 
And granted, there's more stuff to the right.

644
00:32:16,460 --> 00:32:19,700
在我的英语句子的末尾有一个句号 
There's literally this period at the end of my English sentence.

645
00:32:19,700 --> 00:32:23,600
但这没关系 因为目前 我的正则表达式不是那么精确
But that's OK, because at the moment, my regular expression is not so precise

646
00:32:23,600 --> 00:32:29,156
也就是说 模式必须以用户名开始 以. edu结束 
as to say, the pattern must start with the username and end with the .edu.

647
00:32:29,156 --> 00:32:32,573
从技术上讲 它的左可以说什么更多
Technically, it's left unsaid what more can be to the left

648
00:32:32,573 --> 00:32:33,990
还有什么可以向右 
and what more can be to the right.

649
00:32:33,990 --> 00:32:37,970
所以当我按回车键的时候 你会看到整个英文句子
So when I hit Enter now, you'll see that that whole sentence in English

650
00:32:37,970 --> 00:32:40,500
是有效的 这显然不是你想要的
is valid, and that's obviously not what you want.

651
00:32:40,500 --> 00:32:43,430
事实上 考虑使用Google Forms或Office的情况
In fact, consider the case of using Google Forms or Office

652
00:32:43,430 --> 00:32:45,620
365收集用户的数据 
365 to collect data from users.

653
00:32:45,620 --> 00:32:48,320
如果不验证输入 用户
If you don't validate your input, your users

654
00:32:48,320 --> 00:32:51,170
可能会输入一个完整的句子或其他东西
might very well type in a full sentence or something else

655
00:32:51,170 --> 00:32:53,550
只是一个印刷错误而不是一封真正的邮件
with a typographical error, not an actual email.

656
00:32:53,550 --> 00:32:55,993
所以如果你只是想复制所有的结果
So if you're just trying to copy all of the results that

657
00:32:55,993 --> 00:32:58,160
已输入到您的表单中 以便您可以粘贴它们
have been typed into your form so you can paste them

658
00:32:58,160 --> 00:33:00,767
Gmail或其他电子邮件程序 它会崩溃 
into Gmail or some email program, it's going to break,

659
00:33:00,767 --> 00:33:04,100
因为你会不小心把一整句英语
because you're going to accidentally pay something like a whole English sentence

660
00:33:04,100 --> 00:33:07,010
而不仅仅是一个电子邮件地址 
into the program instead of just an email address, which

661
00:33:07,010 --> 00:33:08,690
这是你的邮件期望 
is what your mailer expects.

662
00:33:08,690 --> 00:33:10,280
我怎么才能更精确呢？
So how can I be more precise?

663
00:33:10,280 --> 00:33:13,550
好吧 让我提议我们再引入一些符号 
Well, let me propose we introduce a few more symbols as well.

664
00:33:13,550 --> 00:33:17,540
在正则表达式的上下文中 这些模式之一 
It turns out in the context of a regular expression, one of these patterns,

665
00:33:17,540 --> 00:33:21,170
你可以用这个插入符号 这个小三角形标记 
you can use the caret symbol, the little triangular mark,

666
00:33:21,170 --> 00:33:24,080
来表示你想让这个图案
to represent that you want this pattern to match

667
00:33:24,080 --> 00:33:27,110
字符串的开头--不是任何地方
the start of the string specifically-- not anywhere

668
00:33:27,110 --> 00:33:29,330
而是用户字符串的开头 
but the start of the user's string.

669
00:33:29,330 --> 00:33:34,040
相比之下 您可以在正则表达式中使用$符号表示您
By contrast, you can use a $ sign in your regular expression to say that you

670
00:33:34,040 --> 00:33:37,790
我想匹配字符串的结尾 或者技术上来说就在换行符之前
want to match the end of the string, or technically just before the newline

671
00:33:37,790 --> 00:33:38,910
在字符串的末尾 
at the end of the string.

672
00:33:38,910 --> 00:33:41,810
但出于所有意图和目的 请将插入符号视为“开始”的意思
But for all intents and purposes, think of caret as meaning "start

673
00:33:41,810 --> 00:33:45,650
字符串”和$符号表示“字符串结束” “
of the string" and $ sign as meaning "end of the string."

674
00:33:45,650 --> 00:33:49,310
这是一个奇怪的事情 一个是插入符号 一个是$符号 
It is a weird thing that one is a caret and one is $ sign.

675
00:33:49,310 --> 00:33:51,710
这些并不是我认为是对立的东西 
These are not really things that I think of as opposites,

676
00:33:51,710 --> 00:33:53,670
比如括号之类的
like a parentheses or something like that.

677
00:33:53,670 --> 00:33:56,430
但这些是世界多年前选择的象征 
But those are the symbols the world chose many years ago.

678
00:33:56,430 --> 00:33:58,370
现在让我们回到VS Code 
So let me go back to VS Code now.

679
00:33:58,370 --> 00:34:01,460
让我把这个特性添加到我的代码中 
And let me add this feature to my code here.

680
00:34:01,460 --> 00:34:04,790
让我指定 是的 我确实想搜索这个模式 
Let me specify that yes, I do want to search for this pattern,

681
00:34:04,790 --> 00:34:08,480
但我希望用户的输入以这种模式开始
but I want the user's input to start with this pattern

682
00:34:08,480 --> 00:34:09,860
以这种模式结束 
and end with this pattern.

683
00:34:09,860 --> 00:34:12,440
所以即使它开始看起来更加神秘 
So even though it's going to start looking even more cryptic,

684
00:34:12,440 --> 00:34:14,690
我在开头放了一个插入符号 
I put a caret symbol here at the beginning,

685
00:34:14,690 --> 00:34:17,270
我在最后放了个$
and I put a $ sign here at the end.

686
00:34:17,270 --> 00:34:21,199
这并不意味着我希望用户键入插入符号或$符号 
That does not mean I want the user to type a caret symbol or a $ sign.

687
00:34:21,199 --> 00:34:25,130
这是一种特殊的符号系统 表示re.search
This is special symbology that indicates to re.search

688
00:34:25,130 --> 00:34:29,280
它现在应该只寻找与这个模式完全匹配的 
that it should only look for now an exact match against this pattern.

689
00:34:29,280 --> 00:34:31,699
如果我现在回到终端窗口
So if I now go back to my terminal window--

690
00:34:31,699 --> 00:34:33,920
我会把之前的结果留在屏幕上
and I'll leave the previous result on the screen--

691
00:34:33,920 --> 00:34:35,540
让我输入同样的内容
let me type the exact same thing.

692
00:34:35,540 --> 00:34:39,610
“我的电子邮件地址malan@harvard.edu” 输入--
"My email address malan@harvard.edu," Enter--

693
00:34:39,610 --> 00:34:41,000
抱歉 句号 
sorry, period.

694
00:34:41,000 --> 00:34:43,070
现在我要按回车键了
And now I'm going to go ahead and hit Enter.

695
00:34:43,070 --> 00:34:45,770
现在这被认为是无效的 
Now that's considered invalid.

696
00:34:45,770 --> 00:34:47,090
但让我把屏幕清空 
But let me clear the screen.

697
00:34:47,090 --> 00:34:48,923
为了确保我没有弄坏东西 
And just to make sure I didn't break things,

698
00:34:48,923 --> 00:34:53,330
让我只输入我的电子邮件地址 这也是有效的 
let me type in just my email address, and that, too, is valid.

699
00:34:53,330 --> 00:34:58,250
现在关于我的正则表达式的这个版本的任何问题 请注意 
Any questions now on this version of my regular expression, which, note,

700
00:34:58,250 --> 00:35:01,670
更进一步 甚至更精确地指定
goes further to specify even more precisely

701
00:35:01,670 --> 00:35:06,120
我希望它在开始和结束时都是匹配的？
that I want it to match at the start and the end?

702
00:35:06,120 --> 00:35:08,568
对这个有什么问题吗？
Any questions on this one here?

703
00:35:08,568 --> 00:35:09,110
观众：好的 
AUDIENCE: OK.

704
00:35:09,110 --> 00:35:13,160
你有斜杠 .edu 然后是$符号 
You have slash, and .edu, then the $ sign.

705
00:35:13,160 --> 00:35:18,170
但是点是正则表达式中的一个 对吗？
But the dot is one of the regular expression, right?

706
00:35:18,170 --> 00:35:19,460
大卫·马兰：通常是这样的 
DAVID MALAN: It normally is.

707
00:35:19,460 --> 00:35:24,590
但我在这里之前故意加的这个反斜杠
But this backslash that I deliberately put before this period here

708
00:35:24,590 --> 00:35:26,180
是一个逃逸的角色 
is an escape character.

709
00:35:26,180 --> 00:35:30,710
这是一种告诉re.earch我不想要任何字符的方式 
It is a way of telling re.search that I don't want any character there,

710
00:35:30,710 --> 00:35:33,140
我真的想在那里待上一段时间 
I literally want a period there.

711
00:35:33,140 --> 00:35:36,080
这是你区分它们的唯一方法 
And it's the only way you can distinguish one from the other.

712
00:35:36,080 --> 00:35:40,550
如果我去掉那个斜杠 这将意味着电子邮件地址
If I got rid of that slash, this would mean that the email address just

713
00:35:40,550 --> 00:35:43,610
必须以任何字符结尾 然后是E 然后是D 
has to end with any character, then an E, then a D,

714
00:35:43,610 --> 00:35:45,180
而不是U 我不想那样 
than a U. I don't want that.

715
00:35:45,180 --> 00:35:49,730
我想要一个句点 然后是E 然后是D 然后是U 
I want literally a period, then the E, then the D, then the U.

716
00:35:49,730 --> 00:35:53,780
这实际上是一般编程和技术中的常见约定 
This is actually common convention in programming and technology in general.

717
00:35:53,780 --> 00:35:55,820
如果你和我决定一个大会 
If you and I decide on a convention, whereby

718
00:35:55,820 --> 00:35:59,180
我们正在使用键盘上的一些字符来表示一些特殊的东西 
we're using some character on the keyboard to mean something special,

719
00:35:59,180 --> 00:36:02,060
我们总是给自己制造未来的问题
invariably we create a future problem for ourself

720
00:36:02,060 --> 00:36:04,820
当我们想要字面上使用相同的字符 
when we want to literally use that same character.

721
00:36:04,820 --> 00:36:07,190
因此 这个问题的总体解决方案
And so the solution in general to that problem

722
00:36:07,190 --> 00:36:10,790
就是以某种方式逃避角色 这样计算机就能清楚地看到
is to somehow escape the character so that it's clear to the computer

723
00:36:10,790 --> 00:36:14,510
它不是那个特殊的符号 而是它所看到的符号 
that it's not that special symbol, it's literally the symbol it sees.

724
00:36:14,510 --> 00:36:19,700
观众：所以我们甚至不知道--我们不需要在美元之前再进行一次削减
AUDIENCE: So we don't even know the-- we don't need another slash before the $

725
00:36:19,700 --> 00:36:20,930
签字？
sign?

726
00:36:20,930 --> 00:36:22,150
大卫·马兰：没有 
DAVID MALAN: No.

727
00:36:22,150 --> 00:36:25,550
因为在这种情况下 $sign意味着一些特别的东西 
Because in this case, $ sign means something special.

728
00:36:25,550 --> 00:36:30,590
根据这张图表 $符号本身并不意味着美元或货币 
Per this chart here, $ sign by itself does not mean US dollars or currency.

729
00:36:30,590 --> 00:36:33,420
字面意思是“匹配字符串的末尾” 
It literally means "match the end of the string."

730
00:36:33,420 --> 00:36:38,600
但是 如果我想让用户直接在结尾处键入$sign
If, however, I wanted the user to literally type in $ sign at the end

731
00:36:38,600 --> 00:36:40,910
对于他们的投入 解决方案将是相同的 
of their input, the solution would be the same.

732
00:36:40,910 --> 00:36:43,700
我会在$符号前加一个反斜杠 
I would put a backslash before the $ sign,

733
00:36:43,700 --> 00:36:48,242
也就是说 我的电子邮件地址必须是类似maran@atherard.edu的地址
which means my email address would have to be something like malan@harvard.edu

734
00:36:48,242 --> 00:36:50,850
$符号 这显然也是不正确的 
$ sign, which is obviously not correct too.

735
00:36:50,850 --> 00:36:55,280
所以反斜杠只是允许你告诉计算机不要处理
So backslash is just allow you to tell the computer to not treat

736
00:36:55,280 --> 00:36:58,310
特别是那些符号 喜欢表达特殊的意思 
those symbols specially, likes meaning something special,

737
00:36:58,310 --> 00:37:00,950
而是逐字逐句地对待他们 
but to treat them literally instead.

738
00:37:00,950 --> 00:37:04,550
这里还有一个关于正则表达式的问题怎么样？
How about one other question here on regular expressions?

739
00:37:04,550 --> 00:37:09,010
观众：你说过一代表加一 
AUDIENCE: You said one represents to make it one plus,

740
00:37:09,010 --> 00:37:11,095
然后你说一个是让它一无所有 
then you said one was to make it one with nothing.

741
00:37:11,095 --> 00:37:11,845
大卫·马兰：当然 
DAVID MALAN: Sure.

742
00:37:11,845 --> 00:37:13,220
观众：那你为什么要加上加号呢？
AUDIENCE: So why would you add the plus?

743
00:37:13,220 --> 00:37:14,360
大卫·马兰：让我时光倒流 
DAVID MALAN: Let me rewind in time.

744
00:37:14,360 --> 00:37:17,027
我想你指的是我们早期的一个版本
I think what you're referring to was one of our earlier versions

745
00:37:17,027 --> 00:37:20,360
这最初看起来是这样的 这只是意味着零或更多
that initially looked like this, which just meant zero or more

746
00:37:20,360 --> 00:37:24,710
字符 而不是@符号 然后是零个或多个其他字符 
characters, than an @ sign, then zero or more other characters.

747
00:37:24,710 --> 00:37:29,090
然后我们进化成这样 两边都有点加 这
We then evolved to that to be this, dot plus on both sides, which

748
00:37:29,090 --> 00:37:31,340
表示左侧的一个或多个字符 则
means one or more characters on the left, then

749
00:37:31,340 --> 00:37:34,320
@符号 然后是右侧的一个或多个字符 
an @ sign, then one or more characters on the right.

750
00:37:34,320 --> 00:37:36,560
如果我对你的问题的理解正确的话 
And if I'm interpreting your question correctly,

751
00:37:36,560 --> 00:37:40,370
我之前提到的一点是 如果不使用加号或忘记
one of the points I made earlier was that if you didn't use plus or forgot

752
00:37:40,370 --> 00:37:44,510
它的存在 你可以用两个相同的结果
that it exists, you could equivalently achieve the exact same result with two

753
00:37:44,510 --> 00:37:48,380
点和* 因为第一个点表示任何字符--
dots and a *, because the first dot means any character--

754
00:37:48,380 --> 00:37:49,550
它肯定在那里--
it's got to be there--

755
00:37:49,550 --> 00:37:54,170
第二个点*表示零个或多个其他字符 
the second dot * means zero or more other characters,

756
00:37:54,170 --> 00:37:55,380
右边也一样 
and same on the right.

757
00:37:55,380 --> 00:37:57,950
所以这只是表达相同观点的另一种方式 
So it's just another way of expressing the same idea.

758
00:37:57,950 --> 00:38:01,970
“一个或多个”可以这样用点*表示 
"One or more" can be represented like this with dot dot *,

759
00:38:01,970 --> 00:38:06,840
或者 您可以使用更方便的点+语法 它的意思是相同的 
or you can just use the handier syntax of dot +, which means the same thing.

760
00:38:06,840 --> 00:38:07,340
好的 
All right.

761
00:38:07,340 --> 00:38:10,507
所以我敢说 这个正则表达式仍然存在一些问题
So I daresay there's still some problems with the regular expression in this

762
00:38:10,507 --> 00:38:13,790
当前表单 因为即使现在我们开始寻找用户
current form, because even though now we're starting to look for the user

763
00:38:13,790 --> 00:38:16,010
来自用户的字符串开头的名称 
name at the beginning of the string from the user,

764
00:38:16,010 --> 00:38:20,390
我们要从字面上寻找用户字符串末尾的.edu 
and we're looking for the .edu literally at the end of the string from the user,

765
00:38:20,390 --> 00:38:23,780
这些点现在有点太笼统了 
those dots are a little too encompassing right now.

766
00:38:23,780 --> 00:38:26,450
我被允许输入不止一个@符号 
I'm allowed to type in more than the single @ sign.

767
00:38:26,450 --> 00:38:27,020
为什么？
Why?

768
00:38:27,020 --> 00:38:30,720
因为@是一个字符 点表示任何字符 
Because @ is a character, and dot means any character.

769
00:38:30,720 --> 00:38:34,650
所以老实说 我现在可以在这件事上想要多少@符号就有多少 
So honestly, I can have as many @ signs in this thing at the moment as I want.

770
00:38:34,650 --> 00:38:37,280
例如 如果我运行valiate.py的python 
For instance, if I run python of validate.py,

771
00:38:37,280 --> 00:38:40,500
Maran@atherard.edu仍然像预期的那样工作 
malan@harvard.edu, still works as expected.

772
00:38:40,500 --> 00:38:44,270
但是 如果我还运行validate.py的python 并且不正确地这样做
But if I also run python of validate.py and incorrectly do

773
00:38:44,270 --> 00:38:51,030
应该是无效的 但它被认为是有效的 
malan@@@harvard.edu, should be invalid, but it's considered valid instead.

774
00:38:51,030 --> 00:38:55,670
因此 我认为当涉及到那个点时 我们需要更多地限制 
So I think we need to be a little more restrictive when it comes to that dot.

775
00:38:55,670 --> 00:38:59,180
我们不能只说 哦 任何一个老角色都很好 
And we can't just say, oh, any old character there is fine.

776
00:38:59,180 --> 00:39:00,950
我们需要更具体一些 
We need to be more specific.

777
00:39:00,950 --> 00:39:05,390
事实证明 正则表达式也支持这种语法 
Well, it turns out that regular expressions also support this syntax.

778
00:39:05,390 --> 00:39:08,990
您可以在图案内使用方括号 
You can use square brackets inside of your pattern,

779
00:39:08,990 --> 00:39:14,210
在这些方括号内包括一个或多个字符
and inside of those square brackets include one or more characters

780
00:39:14,210 --> 00:39:17,000
你想要特别寻找的东西 
that you want to look for specifically.

781
00:39:17,000 --> 00:39:20,510
或者 您可以在这些方括号内
Alternatively, you can inside of those square brackets

782
00:39:20,510 --> 00:39:23,660
加一个插入符号 不幸的是 在这里 
put a caret symbol, which unfortunately in this context,

783
00:39:23,660 --> 00:39:27,150
意思与“匹配字符串的开头”完全不同 
means something completely different from "match the start of the string."

784
00:39:27,150 --> 00:39:30,870
但这将是方括号内的补码运算符 
But this would be the complement operator inside of the square brackets,

785
00:39:30,870 --> 00:39:34,320
这意味着“你不能匹配这些字符中的任何一个 ”
which means "you cannot match any of these characters."

786
00:39:34,320 --> 00:39:36,980
因此 事情现在看起来更神秘了 
So things are about to look even more cryptic now.

787
00:39:36,980 --> 00:39:41,000
但这就是为什么我们在这里关注正则表达式本身的原因 
But that's why we're focusing on regular expressions on their own here.

788
00:39:41,000 --> 00:39:46,850
如果我不想允许任何字符 这就是点 让我继续
If I don't want to allow any character, which is what a dot is, let me go ahead

789
00:39:46,850 --> 00:39:52,610
我可以说 我只想支持A、B、C或D 
and I could just say, well, I only want to support A, or Bs, or Cs, or Ds,

790
00:39:52,610 --> 00:39:54,200
或者ES 或者F 或者Gs 
or Es, or Fs, or Gs.

791
00:39:54,200 --> 00:39:56,750
我可以在这里输入整个字母表 外加一些数字
I could type in the whole alphabet here plus some numbers

792
00:39:56,750 --> 00:40:00,110
将我想要允许的所有字母都包括在内 
to actually include all of the letters that I do want to allow.

793
00:40:00,110 --> 00:40:02,570
但老实说 这样会更简单一些 
But honestly, a little simpler would be this.

794
00:40:02,570 --> 00:40:09,020
我可以使用^符号 然后使用@符号 这样做的效果是 
I could use a ^ symbol and then an @ sign, which has the effect of saying,

795
00:40:09,020 --> 00:40:14,270
这是一组字符 除了@符号外 其他字符都有 
this is the set of characters that has everything except an @ sign.

796
00:40:14,270 --> 00:40:16,130
我在这里也可以做同样的事情 
And I can do the same thing over here.

797
00:40:16,130 --> 00:40:23,270
我可以做左方括号^ @符号 而不是@符号右边的圆点 
Instead of a dot to the right of the @ sign, I can do open bracket ^, @ sign.

798
00:40:23,270 --> 00:40:26,390
我承认 这里的局势开始迅速升级 
And I admit, things are starting to escalate quickly here,

799
00:40:26,390 --> 00:40:28,940
但让我们从左边开始 再到右边
but let's start from the left and go to the right.

800
00:40:28,940 --> 00:40:33,020
在字符串开头的方括号外 
This ^ outside of the square brackets at the very start of my string,

801
00:40:33,020 --> 00:40:35,810
与前面一样 表示“从字符串的开头匹配” “
as before, means "match from the start of the string."

802
00:40:35,810 --> 00:40:36,890
让我们跳到前面 
And let's jump ahead.

803
00:40:36,890 --> 00:40:40,580
正则表达式末尾的$符号表示“匹配
The $ sign all the way at the end of the regular expression means "match

804
00:40:40,580 --> 00:40:42,180
在字符串的末尾 “
at the end of the string."

805
00:40:42,180 --> 00:40:45,290
所以如果我们能在心里把这些简单明了地勾出来 
So if we can mentally tick those off as straightforward, let's

806
00:40:45,290 --> 00:40:47,630
现在把注意力集中在中间的其他东西上 
now focus on everything else in the middle.

807
00:40:47,630 --> 00:40:50,510
左边是新的语法
Well, to the left here we have new syntax--

808
00:40:50,510 --> 00:40:56,840
一个方括号 另一个^ 一个@符号和一个封闭的方括号 然后
a square bracket, another ^, an @ sign, and a closed square bracket, and then

809
00:40:56,840 --> 00:40:57,560
a +.
a +.

810
00:40:57,560 --> 00:40:59,780
“+”的意思和往常一样 
The + means the same thing as always.

811
00:40:59,780 --> 00:41:03,110
意思是“左边的一个或多个东西 “
It means "one or more of the things to the left."

812
00:41:03,110 --> 00:41:04,830
左边的是什么？
What is the thing to the left?

813
00:41:04,830 --> 00:41:06,650
这是新的语法
Well, this is the new syntax.

814
00:41:06,650 --> 00:41:10,880
在方括号里 我有一个^符号和一个@符号 
Inside of square brackets here, I have a ^ symbol and then an @ sign.

815
00:41:10,880 --> 00:41:14,990
这意味着除了@符号之外的任何字符 
That just means any character except an @ sign.

816
00:41:14,990 --> 00:41:18,890
这是一个奇怪的语法 但这就是我们如何表达这个简单的想法--
It's a weird syntax, but this is how we can express that simple idea--

817
00:41:18,890 --> 00:41:23,022
键盘上除@符号以外的任何字符 
any character on the keyboard except for an @ sign.

818
00:41:23,022 --> 00:41:25,980
而且 即使是那些不在你键盘上的字符
And heck, even other characters that aren't physically on your keyboard

819
00:41:25,980 --> 00:41:28,020
但仍然存在
but that nonetheless exist.

820
00:41:28,020 --> 00:41:32,120
然后我们有一个字面上的@符号 然后我们有另一个同样的东西--
Then we have a literal @ sign, then we have another one of these same things--

821
00:41:32,120 --> 00:41:36,950
方括号 ^@闭括号 表示除@符号以外的任何字符 
square bracket, ^@ closed bracket, which means any character except an @ sign,

822
00:41:36,950 --> 00:41:42,710
然后是其中的一个或多个 后面跟着一个句号edu 
then one or more of those things, followed by literally a period edu.

823
00:41:42,710 --> 00:41:45,960
现在让我再做一次 
So now let me go ahead and do this again.

824
00:41:45,960 --> 00:41:49,280
让我试试validate.py的python并测试我自己的电子邮件地址
Let me rerun python of validate.py and test my own email address

825
00:41:49,280 --> 00:41:51,595
确保我没有把事情搞得更糟
to make sure I've not made things worse.

826
00:41:51,595 --> 00:41:52,220
我们很好 
And we're good.

827
00:41:52,220 --> 00:41:55,250
现在让我继续清理屏幕 运行validate.py的python
Now let me go ahead and clear my screen and run python of validate.py

828
00:41:55,250 --> 00:42:00,750
再次做harvard.edu 这次我交叉手指 
again and do malan@@@harvard.edu, crossing my fingers this time.

829
00:42:00,750 --> 00:42:03,020
最后 这是无效的 
And finally, this now is invalid.

830
00:42:03,020 --> 00:42:03,830
为什么要这样？
Why?

831
00:42:03,830 --> 00:42:08,600
我允许自己在用户输入的中间有一个@符号 
I'm allowing myself to have one @ sign in the middle of the user's input,

832
00:42:08,600 --> 00:42:13,220
但是按照这个新语法 左边的所有东西都不能是@符号 
but everything to the left per this new syntax cannot be an @ sign.

833
00:42:13,220 --> 00:42:15,950
它可以是任何东西 但一次或多次 
It can be anything but one or more times.

834
00:42:15,950 --> 00:42:20,570
符号右边的任何东西都可以不是符号
And everything to the right of the @ sign can be anything but an @ sign one

835
00:42:20,570 --> 00:42:25,430
或者更多次 最后是字面上的.edu 
or more times followed by, lastly, a literal .edu.

836
00:42:25,430 --> 00:42:27,590
所以 新的语法很简单 就是--
So again, the new syntax is quite simply this--

837
00:42:27,590 --> 00:42:31,985
方括号允许您指定一组您按字面意思
square brackets allow you to specify a set of characters that you literally

838
00:42:31,985 --> 00:42:33,110
在键盘上打字--
type out at your keyboard--

839
00:42:33,110 --> 00:42:36,410
A B C D E F 或补语 相反 
A, B, C, D, E, F, or the complement, the opposite,

840
00:42:36,410 --> 00:42:40,550
^符号 意思是“不” 然后一个或多个符号
the ^ symbol, which means "not," and then the one or more symbols you

841
00:42:40,550 --> 00:42:42,520
想要排除 
want to exclude.

842
00:42:42,520 --> 00:42:45,230
这里有关于这个语法的问题吗？
Questions now on this syntax here?

843
00:42:45,230 --> 00:42:49,450
观众：那么 在@sign之后 我们可以用花括号来表示吗
AUDIENCE: So right after @ sign, can we use the curly brackets m one

844
00:42:49,450 --> 00:42:52,770
这样我们就只能重复一次@符号了？
so that we can only have one repetition of the @ symbol?

845
00:42:52,770 --> 00:42:53,770
大卫·马兰：当然 
DAVID MALAN: Absolutely.

846
00:42:53,770 --> 00:42:54,800
所以我们可以这么做 
So we could do this.

847
00:42:54,800 --> 00:42:56,680
让我继续下去 开始VS Code 
Let me go ahead and pull up VS Code.

848
00:42:56,680 --> 00:42:59,680
让我删除正则表达式的当前形式
And let me delete the current form of a regular expression

849
00:42:59,680 --> 00:43:03,580
回到我们开始的地方 那只是点*@和点* 
and go back to where we began, which was just dot * @ and dot *.

850
00:43:03,580 --> 00:43:06,130
我完全可以做这样的事
I could absolutely do something like this

851
00:43:06,130 --> 00:43:10,480
并要求我在这里至少要有一个角色 
and require that I want at least one of any character here.

852
00:43:10,480 --> 00:43:13,760
然后我可以做更多的事情来拥有更多的东西 
And then I could do something more to have any more as well.

853
00:43:13,760 --> 00:43:16,710
我们在前面的幻灯片中看到了花括号的语法
So the curly brace syntax, which we saw on the slide earlier

854
00:43:16,710 --> 00:43:18,460
但还没用过 绝对可以用
but didn't yet use, absolutely can be used

855
00:43:18,460 --> 00:43:21,400
若要指定特定的字符数 请执行以下操作 
to specify a specific number of characters.

856
00:43:21,400 --> 00:43:24,160
但老实说 这比必要的更冗长 
But honestly, this is more verbose than is necessary.

857
00:43:24,160 --> 00:43:27,130
最好的解决方案 可以说 或者至少是最简单的 
The best solution, arguably, or the simplest, at least,

858
00:43:27,130 --> 00:43:29,500
归根结底 就是点+ 
ultimately, is just to say dot +.

859
00:43:29,500 --> 00:43:32,650
但是 还有另一个你可以解决同样问题的例子
But there, too, another example of how you can solve the same problem

860
00:43:32,650 --> 00:43:34,010
多方面的 
multiple ways.

861
00:43:34,010 --> 00:43:36,340
让我们回到刚才正则表达式所在的位置
Let me go back to where the regular expression just was

862
00:43:36,340 --> 00:43:39,170
并回答其他问题 
and take other questions as well.

863
00:43:39,170 --> 00:43:44,790
关于角色集的问题还是补充集的问题？
Questions on the sets of characters or complementing that set?

864
00:43:44,790 --> 00:43:47,370
观众：那么你能用同样的语法吗？
AUDIENCE: So can you use that same syntax

865
00:43:47,370 --> 00:43:51,780
说你不想让某个特定的字符贯穿整个字符串？
to say that you don't want a certain character throughout the whole string?

866
00:43:51,780 --> 00:43:52,740
大卫·马兰：你可以 
DAVID MALAN: You could.

867
00:43:52,740 --> 00:43:54,600
这将会是--
It's going to be--

868
00:43:54,600 --> 00:43:58,530
你完全可以使用相同的字符来排除--
you could absolutely use the same character to exclude--

869
00:43:58,530 --> 00:44:01,830
您完全可以使用此语法来排除某个字符
you could absolutely use this syntax to exclude a certain character

870
00:44:01,830 --> 00:44:03,210
从整个字符串中 
from the entire string.

871
00:44:03,210 --> 00:44:05,130
但现在就有点难了 
But it would be a little harder right now,

872
00:44:05,130 --> 00:44:07,530
因为我们仍然需要.edu结尾 
because we're still requiring .edu the end.

873
00:44:07,530 --> 00:44:10,770
但是 是的 绝对的 
But yes, absolutely.

874
00:44:10,770 --> 00:44:12,220
其他问题？
Other questions?

875
00:44:12,220 --> 00:44:16,620
观众：如果用户在开始时输入.edu会发生什么
AUDIENCE: What happens if the user inputs .edu in the beginning

876
00:44:16,620 --> 00:44:17,632
的字符串？
of the string?

877
00:44:17,632 --> 00:44:18,840
大卫·马兰：问得好 
DAVID MALAN: A good question.

878
00:44:18,840 --> 00:44:22,000
如果用户在字符串的开头输入.edu 会发生什么？
What happens if the user types in .edu at the beginning of the string?

879
00:44:22,000 --> 00:44:23,577
让我们回到VS Code 
Well, let me go back to VS Code here.

880
00:44:23,577 --> 00:44:25,660
让我们试着用两种不同的方法来解决这个问题 
And let's try to solve this in two different ways.

881
00:44:25,660 --> 00:44:27,452
首先 让我们看看正则表达式
First, let's look at the regular expression

882
00:44:27,452 --> 00:44:31,080
看看我们是否能推断出这是否是可以容忍的 
and see if we can infer if that's going to be tolerated.

883
00:44:31,080 --> 00:44:34,950
根据当前的神秘正则表达式 
Well, according to the current cryptic regular expression,

884
00:44:34,950 --> 00:44:38,730
我是说你可以有任何字符除了@符号 
I'm saying that you can have any character except the @ sign.

885
00:44:38,730 --> 00:44:41,910
所以我可以 可能是教育部的点 
So that would work I. Could have the dot for the .edu.

886
00:44:41,910 --> 00:44:44,490
但是我必须有一个@符号 
But then I have to have an @ sign.

887
00:44:44,490 --> 00:44:48,940
所以这是行不通的 因为如果我只是输入.edu 
So that wouldn't really work, because if I'm just typing in .edu,

888
00:44:48,940 --> 00:44:51,010
我们不会越过这个限制 
we're not going to pass that constraint.

889
00:44:51,010 --> 00:44:53,710
现在让我运行这个程序 
So now let me try this by running the program.

890
00:44:53,710 --> 00:44:55,810
让我按字面意思输入. edu 
Let me type in just literally .edu.

891
00:44:55,810 --> 00:44:57,090
这不管用
That doesn't work.

892
00:44:57,090 --> 00:45:02,505
但是 但是 但是我可以这样做 .edu@. edu 
But, but, but I could do this, .edu@.edu.

893
00:45:02,505 --> 00:45:04,140
这也是无效的 
That, too, is invalid.

894
00:45:04,140 --> 00:45:07,581
但让我这样做 . edu@something.edu 
But let me do this, .edu@something.edu.

895
00:45:10,365 --> 00:45:11,490
那就过去了 
That passes.

896
00:45:11,490 --> 00:45:13,470
所以现在开始有点奇怪了 
So it's starting to get a little weird now.

897
00:45:13,470 --> 00:45:15,030
可能有效 也可能无效 
Maybe it's valid, maybe it's not.

898
00:45:15,030 --> 00:45:18,120
但我认为我们最终也会更精确 
But I think we'll eventually be more precise, too.

899
00:45:18,120 --> 00:45:21,570
再问一个关于这个正则表达式的问题怎么样
How about one more question on this regular expression

900
00:45:21,570 --> 00:45:23,310
这些集合的互补呢？
and these complementing of sets?

901
00:45:23,310 --> 00:45:27,765
观众：我们可以用另一个域名 字符串输入吗？
AUDIENCE: Can we use another domain name, the string input?

902
00:45:27,765 --> 00:45:29,640
大卫·马兰：你能用别的域名吗？
DAVID MALAN: Can you use another domain name?

903
00:45:29,640 --> 00:45:30,240
当然了
Absolutely.

904
00:45:30,240 --> 00:45:32,460
我用我自己的只是为了演示 
I'm using my own just for the sake of demonstration.

905
00:45:32,460 --> 00:45:35,970
但你绝对可以使用任何域或顶级域 
But you could absolutely use any domain or top-level domain.

906
00:45:35,970 --> 00:45:38,520
我使用的是.edu 它非常以美国为中心 
And I'm using .edu, which is very US centric.

907
00:45:38,520 --> 00:45:43,330
但这对任何顶级域都是完全一样的 
But this would absolutely work exactly the same for any top-level domain.

908
00:45:43,330 --> 00:45:43,830
好吧
All right.

909
00:45:43,830 --> 00:45:47,700
现在让我继续下去 并建议我们改进这个正则表达式
Let me go ahead now and propose that we improve this regular expression

910
00:45:47,700 --> 00:45:50,880
因为如果我在VS Code中再次调用它 
further, because if I pull it up again in VS Code here,

911
00:45:50,880 --> 00:45:53,790
你会发现我还是有点太宽容了
you'll see that I'm being a little too tolerant still.

912
00:45:53,790 --> 00:45:58,140
原来对某人的用户名是有一定要求的
It turns out that there are certain requirements for someone's username

913
00:45:58,140 --> 00:46:00,240
和电子邮件地址中的域名 
and domain name in an email address.

914
00:46:00,240 --> 00:46:03,840
电子邮件地址可以是什么在世界上有一个官方标准
There is an official standard in the world for what an email address can be

915
00:46:03,840 --> 00:46:05,670
以及里面可以有哪些角色 
and what characters can be in it.

916
00:46:05,670 --> 00:46:09,480
这对所有的角色来说都太过通融了
And this is way too accommodating of all the characters

917
00:46:09,480 --> 00:46:11,710
在这个世界上除了@符号 
in the world except for the @ symbol.

918
00:46:11,710 --> 00:46:14,190
所以让我们来缩小一下定义
So let's actually narrow the definition of what

919
00:46:14,190 --> 00:46:16,110
我们将容忍用户名 
we're going to tolerate in usernames.

920
00:46:16,110 --> 00:46:19,200
像Gmail这样的公司当然也可以做到这一点 
And companies like Gmail could certainly do this as well.

921
00:46:19,200 --> 00:46:22,200
假设不只是我想要排除@sign 
Suppose that it's not just that I want to exclude @ sign.

922
00:46:22,200 --> 00:46:25,470
假设我只想考虑 比方说 
Suppose that I only want to allow for, say,

923
00:46:25,470 --> 00:46:27,600
通常出现在单词中的字符 
characters that normally appear in words,

924
00:46:27,600 --> 00:46:31,500
就像字母表中的字母 从A到Z 无论是大写还是小写 
like letters of the alphabet, A through z, be it uppercase or lowercase,

925
00:46:31,500 --> 00:46:35,520
也许有些数字 见鬼 甚至下划线也可以被允许 
maybe some numbers, and heck, maybe even an underscore could be allowed, too.

926
00:46:35,520 --> 00:46:38,550
我们可以使用相同的方括号语法
Well, we can use this same square bracket syntax

927
00:46:38,550 --> 00:46:41,340
要指定一组字符 请如下所示 
to specify a set of characters as follows.

928
00:46:41,340 --> 00:46:44,860
我可以做abc定义--
I could do abcdefghij--

929
00:46:44,860 --> 00:46:45,360
天哪 
oh, my god.

930
00:46:45,360 --> 00:46:46,290
这将耗费很长时间 
This is going to take forever.

931
00:46:46,290 --> 00:46:49,140
我要把字母表中的26个字母全部打出来 
I'm going to have to type out all 26 letters of the alphabet,

932
00:46:49,140 --> 00:46:50,940
小写和大写都是 
both lowercase and uppercase.

933
00:46:50,940 --> 00:46:52,260
所以让我别再这么做了 
So let me stop doing that.

934
00:46:52,260 --> 00:46:53,700
已经有更好的办法了 
There's a better way already.

935
00:46:53,700 --> 00:46:58,180
如果要在这些方括号中指定字母范围 
If you want to specify within these square brackets a range of letters,

936
00:46:58,180 --> 00:47:00,550
实际上 您可以只使用连字符 
you can actually just do a hyphen.

937
00:47:00,550 --> 00:47:04,920
如果你真的在这些方括号里做a-z 
If you literally do a-z in these square brackets,

938
00:47:04,920 --> 00:47:07,470
计算机会知道你的意思是从a到z 
the computer is going to know you mean a through z.

939
00:47:07,470 --> 00:47:10,620
你不需要打字母表中的26个字母 
You do not need to type 26 letters of the alphabet.

940
00:47:10,620 --> 00:47:14,190
如果您还想包含大写字母 只需执行相同的操作 
If you want to include uppercase letters as well, you just do the same.

941
00:47:14,190 --> 00:47:19,440
没有空格 没有逗号 你只需通过大写Z输入a即可 
No spaces, no commas, you literally just keep typing a through capital Z.

942
00:47:19,440 --> 00:47:23,880
所以我有一个小连字符 小z 大A连字符
So I have little a hyphen little z, big A hyphen

943
00:47:23,880 --> 00:47:26,640
大Z 没有空格 没有逗号 没有分隔符 
big Z. No spaces, no commas, no separators.

944
00:47:26,640 --> 00:47:28,830
您只需不断指定这些范围即可 
You just keep specifying those ranges.

945
00:47:28,830 --> 00:47:32,350
如果我还想要数字 我可以做01234--
If I additionally want numbers, I could do 01234--

946
00:47:32,350 --> 00:47:32,850
没有 
nope.

947
00:47:32,850 --> 00:47:35,070
您不需要输入所有10位十进制数字 
You don't need to type in all 10 decimal digits.

948
00:47:35,070 --> 00:47:39,070
您也可以使用连字符来表示0到9 
You can just say 0 through 9 using a hyphen as well.

949
00:47:39,070 --> 00:47:41,280
如果您现在想要支持下划线
And if you now want to support underscores

950
00:47:41,280 --> 00:47:44,280
同样 这在电子邮件地址的用户名中也很常见 
as well, which is pretty common in usernames for email addresses,

951
00:47:44,280 --> 00:47:48,160
从字面上看 你只需在结尾处输入下划线 
you can literally just type an underscore at the end.

952
00:47:48,160 --> 00:47:51,180
请注意 所有这些字符都在里面
Notice that all of these characters are inside

953
00:47:51,180 --> 00:47:55,860
的方括号 这再次意味着这里是一组字符
of square brackets, which just again, means here is a set of characters

954
00:47:55,860 --> 00:47:57,180
这是我想允许的 
that I want to allow.

955
00:47:57,180 --> 00:48:02,100
我没有在整件事的开头使用^符号 
I have not used a ^ symbol at the beginning of this whole thing,

956
00:48:02,100 --> 00:48:05,370
因为我不想补充它--用E来补充它 
because I don't want to complement it-- complement it with an E,

957
00:48:05,370 --> 00:48:07,230
而不是用我来恭维--
not compliment it with an I--

958
00:48:07,230 --> 00:48:09,940
我不想通过把它变成相反的东西来补充它 
I don't want to complement it by making it the opposite.

959
00:48:09,940 --> 00:48:13,225
我真的只想接受这些角色 
I literally want to accept only these characters.

960
00:48:13,225 --> 00:48:15,600
我将继续在右边做同样的事情 
I'm going to go ahead and do the same thing on the right.

961
00:48:15,600 --> 00:48:19,530
如果我想要求域名类似
If I want to require that the domain name similarly

962
00:48:19,530 --> 00:48:22,800
来自这组人物 诚然有点太窄了 
come from this set of characters, which admittedly is a little too narrow,

963
00:48:22,800 --> 00:48:25,210
但它现在很熟悉 所以我们就简单点 
but it's familiar for now so we'll keep it simple,

964
00:48:25,210 --> 00:48:29,490
我将继续在那里粘贴完全相同的一组字符
I'm going to go ahead and paste that exact same set of characters over there

965
00:48:29,490 --> 00:48:30,490
往右走 
to the right.

966
00:48:30,490 --> 00:48:33,600
因此 现在 它的限制要严格得多 
And so now, it's much more restrictive.

967
00:48:33,600 --> 00:48:36,660
现在 我将继续运行valiate.py的python 
Now I'm going to go ahead and run python of validate.py.

968
00:48:36,660 --> 00:48:39,420
我要测试一下我自己的电子邮件地址 我们还是可以的 
I'm going to test my own email address, and we're still good.

969
00:48:39,420 --> 00:48:42,180
我要清空屏幕 再运行一次 
I'm going to clear my screen and run it once more,

970
00:48:42,180 --> 00:48:44,520
这一次 它试图打破它 
this time trying to break it.

971
00:48:44,520 --> 00:48:51,270
让我继续做一些事情 比如 david_maran@atherard.edu 
Let me go ahead and do something like, how about, david_malan@harvard.edu,

972
00:48:51,270 --> 00:48:54,790
进入 但这也将是有效的 
Enter, but that, too, is going to be valid.

973
00:48:54,790 --> 00:48:57,330
但如果我再做一件完全错误的事 
But if I do something completely wrong again,

974
00:48:57,330 --> 00:49:02,790
就像Malan@atherard.edu一样 这仍然是无效的 
like malan@@@harvard.edu, that's still going to be invalid.

975
00:49:02,790 --> 00:49:03,330
为什么？
Why?

976
00:49:03,330 --> 00:49:06,090
因为我的正则表达式当前只允许
Because my regular expression currently only allows

977
00:49:06,090 --> 00:49:09,480
对于中间的一个@ 因为所有东西都在左边
for a single @ in the middle, because everything to the left

978
00:49:09,480 --> 00:49:11,530
必须是字母数字--
must be alphanumeric--

979
00:49:11,530 --> 00:49:14,420
字母或数字--或下划线 
alphabetical or numeric-- or an underscore,

980
00:49:14,420 --> 00:49:18,301
同样的东西在右边 后面跟着.edu 
the same thing to the right, followed by the .edu.

981
00:49:18,301 --> 00:49:20,770
老实说 这是一个正则表达式
Now honestly, this is a regular expression

982
00:49:20,770 --> 00:49:23,890
你可能养成了在现实世界打字的习惯 
that you might be in the habit of typing in the real world.

983
00:49:23,890 --> 00:49:27,860
尽管这看起来很神秘 但这是正则表达式的世界 
As cryptic as this might look, this is the world of regular expressions.

984
00:49:27,860 --> 00:49:30,560
因此 随着时间的推移 您会越来越熟悉这种语法 
So you'll get more comfortable with this syntax over time.

985
00:49:30,560 --> 00:49:32,890
但值得庆幸的是 其中一些模式是
But thankfully, some of these patterns are

986
00:49:32,890 --> 00:49:36,910
如此常见 以至于有内置的快捷键来表示
so common that there are built-in shortcuts for representing

987
00:49:36,910 --> 00:49:38,680
一些相同的信息 
some of the same information.

988
00:49:38,680 --> 00:49:42,373
这就是说 您不必不断地输入所有的符号
That is to say, you don't have to constantly type out all of the symbols

989
00:49:42,373 --> 00:49:45,040
你想要包括的 因为很有可能是其他程序员
that you want to include, because odds are some other programmer

990
00:49:45,040 --> 00:49:46,280
也遇到了同样的问题 
has had the same problem.

991
00:49:46,280 --> 00:49:49,030
因此内置到正则表达式本身
So built into regular expressions themselves

992
00:49:49,030 --> 00:49:51,250
下面是一些您可以使用的其他模式 
are some additional patterns you can use.

993
00:49:51,250 --> 00:49:56,170
事实上 我可以继续下去 去掉这一整套 从a到z
And in fact, I can go ahead and get rid of this entire set, a through z

994
00:49:56,170 --> 00:49:59,830
小写 A到Z大写 0到9和一个下划线 
lowercase, A through Z uppercase, 0 through 9 and an underscore,

995
00:49:59,830 --> 00:50:03,640
只需将其替换为单个反斜杠w 
and just replace it with a single backslash w.

996
00:50:03,640 --> 00:50:07,210
在这种情况下 反斜杠w表示“单词字符” 
Backslash w in this case represents a "word character,"

997
00:50:07,210 --> 00:50:13,330
通常称为字母数字符号或下划线
which is commonly known as a alphanumeric symbol or the underscore

998
00:50:13,330 --> 00:50:14,052
也是 
as well.

999
00:50:14,052 --> 00:50:15,760
我要在这里做同样的事情 
I'm going to do the same thing over here.

1000
00:50:15,760 --> 00:50:18,310
我将突出显示整组方括号 
I'm going to highlight the entire set of square brackets,

1001
00:50:18,310 --> 00:50:21,430
删除它 并将其替换为一个反斜杠w 
delete it, and replace it with a single backslash w.

1002
00:50:21,430 --> 00:50:23,720
现在我觉得我们正在取得进展 
And now I feel like we're making progress,

1003
00:50:23,720 --> 00:50:25,720
因为即使它是神秘的 而且会
because even though it's cryptic, and would have

1004
00:50:25,720 --> 00:50:29,320
看起来有点神秘--
looked way cryptic a little bit ago--

1005
00:50:29,320 --> 00:50:32,680
尽管现在它看起来会更神秘一点
and even though it would have looked even more cryptic a little bit ago, now

1006
00:50:32,680 --> 00:50:35,470
它至少开始读起来更友好了一点 
it's at least starting to read a little more friendly.

1007
00:50:35,470 --> 00:50:39,160
左边的^表示“从字符串的开头开始匹配” 
This ^ on the left means "start matching at the beginning of the string."

1008
00:50:39,160 --> 00:50:42,100
反斜杠w表示“任何单词字符” 
Backslash w means "any word character."

1009
00:50:42,100 --> 00:50:44,140
+的意思是“一个或多个” 
The + means "one or more."

1010
00:50:44,140 --> 00:50:45,370
@字面上的符号 
@ symbol literally.

1011
00:50:45,370 --> 00:50:49,720
然后是另一个单词字符 一个或多个 然后是字面点 然后是
Then another word character, one or more. then a literal dot, then

1012
00:50:49,720 --> 00:50:54,200
字面意思是edu 然后在字符串的最末端进行匹配 就是这样 
literally edu, and then match at the very end of the string, and that's it.

1013
00:50:54,200 --> 00:50:55,660
因此 还有更多这样的东西 
So there's more of these, too.

1014
00:50:55,660 --> 00:50:57,910
我们不会在这里全部使用它们 但这里是
And we won't use them all here, but here is

1015
00:50:57,910 --> 00:51:02,950
可以在正则表达式中使用的模式的部分列表 
a partial list of the patterns you can use within a regular expression.

1016
00:51:02,950 --> 00:51:07,060
第一 任何十进制数字都有反斜杠d “十进制数字”的意思是
One, you have backslash d for any decimal digit, "decimal digit" meaning

1017
00:51:07,060 --> 00:51:08,590
0到9 
0 through 9.

1018
00:51:08,590 --> 00:51:12,550
在这里 通常也会这样做 如果你想做相反的事情 
Commonly done here, too, is if you want to do the opposite of that,

1019
00:51:12,550 --> 00:51:17,020
补码 可以说 你可以做反斜杠大写D 这是
the complement, so to speak, you can do backslash capital D, which

1020
00:51:17,020 --> 00:51:19,480
不是十进制数字的任何数字 
is anything that's not a decimal digit.

1021
00:51:19,480 --> 00:51:23,990
所以它可能是字母、标点符号 也可能是其他符号 
So it might be letters, and punctuation, and other symbols as well.

1022
00:51:23,990 --> 00:51:27,280
同时 反斜杠S表示空格字符 
Meanwhile, backslash s means whitespace characters,

1023
00:51:27,280 --> 00:51:30,490
比如按一下空格键 或者按键盘上的Tab键 
like a single hit of the space, or maybe hitting Tab on the keyboard.

1024
00:51:30,490 --> 00:51:31,720
那是空格 
That's whitespace.

1025
00:51:31,720 --> 00:51:35,110
反斜杠大写S是反义词或补语
Backslash capital S is the opposite or complement

1026
00:51:35,110 --> 00:51:38,080
任何不是空格的字符 
of that-- anything that's not a whitespace character.

1027
00:51:38,080 --> 00:51:41,680
我们已经看到 反斜杠w是一个单词字符 以及
Backslash w, we've seen, a word character, as well as

1028
00:51:41,680 --> 00:51:43,390
数字和下划线 
numbers and the underscore.

1029
00:51:43,390 --> 00:51:45,970
如果你想要与之互补或相反的 
And if you want the complement or opposite of that,

1030
00:51:45,970 --> 00:51:50,950
您可以使用反斜杠大写W来表示除单词字符以外的所有字符 
you can use backslash capital W to give you everything but a word character.

1031
00:51:50,950 --> 00:51:54,130
再说一次 这些都是常见的模式 想必很多人都是
Again, these are just common patterns that so many people were presumably

1032
00:51:54,130 --> 00:51:58,520
使用在过去 它现在被烘焙到正则表达式语法
using in yesteryear that it's now baked into the regular expression syntax

1033
00:51:58,520 --> 00:52:02,710
这样你就可以更简洁地表达你同样的想法 
so that you can more succinctly express your same ideas.

1034
00:52:02,710 --> 00:52:05,320
那么 对这种方法有什么问题吗 
Any questions, then, on this approach here,

1035
00:52:05,320 --> 00:52:12,340
我们现在用反斜杠w来表示我的单词字符？
where we're now using backslash w to represent my word character?

1036
00:52:12,340 --> 00:52:14,230
观众：所以我想问的是
AUDIENCE: So what I want to ask about was

1037
00:52:14,230 --> 00:52:17,590
这个--实际上是前面的方法 就像方括号的方法 
the-- actually the previous approach, like the square bracket approach.

1038
00:52:17,590 --> 00:52:19,792
我们可以在那里收单子吗？
Could we accept lists in there?

1039
00:52:19,792 --> 00:52:20,500
大卫·马兰：是的 
DAVID MALAN: Yes.

1040
00:52:20,500 --> 00:52:21,730
我们很快就会看到这一点 
We'll see this before long.

1041
00:52:21,730 --> 00:52:27,460
但假设你不仅想容忍.edu 而且还想容忍.edu或.com 
But suppose you wanted to tolerate not just .edu, but maybe .edu, or .com,

1042
00:52:27,460 --> 00:52:28,450
你可以做到的 
you could do this.

1043
00:52:28,450 --> 00:52:32,500
你可以引入圆括号 然后你可以把它们放在一起 
You could introduce parentheses, and then you can or those together.

1044
00:52:32,500 --> 00:52:35,470
我可以说com或edu 
I could say com or edu.

1045
00:52:35,470 --> 00:52:40,180
也可以添加一些东西 如在美国 或政府 或网络 
Could also add in something like in the US, or gov, or net,

1046
00:52:40,180 --> 00:52:42,670
或其他任何东西 或组织 或诸如此类 
or anything else, or org, or the like.

1047
00:52:42,670 --> 00:52:45,190
这里的每一条竖线都意味着一些特别的东西 
And each of the vertical bars here means something special.

1048
00:52:45,190 --> 00:52:46,180
意思是“或”
It means "or."

1049
00:52:46,180 --> 00:52:48,610
而圆括号只是简单地将事物组合在一起 
And the parentheses simply group things together.

1050
00:52:48,610 --> 00:52:50,920
形式上 你在这里有这样的语法--
Formally, you have this syntax here--

1051
00:52:50,920 --> 00:52:56,530
A或B A或竖线B 意思是“A必须匹配或B必须匹配 ”
A or B, A or vertical bar B, means "A has to match or B has to match,"

1052
00:52:56,530 --> 00:52:59,080
其中A和B可以是您想要的任何其他图案 
where A and B can be any other patterns you want.

1053
00:52:59,080 --> 00:53:01,520
在括号中 您可以将这些内容组合在一起 
In parentheses, you can group those things together.

1054
00:53:01,520 --> 00:53:05,710
因此 就像数学一样 你可以把想法组合成一个短语
So just like math, you can combine ideas into one phrase

1055
00:53:05,710 --> 00:53:07,600
做这件事或做那件事 
and do this thing or the other.

1056
00:53:07,600 --> 00:53:09,970
还有其他语法 我们很快就会看到 
And there's other syntax as well that we'll soon see.

1057
00:53:09,970 --> 00:53:14,750
这里还有关于这些正则表达式和此语法的其他问题吗？
Other questions on these regular expressions and this syntax here?

1058
00:53:14,750 --> 00:53:16,990
观众：如果我们在表达式中加入空格呢？
AUDIENCE: What if we put spaces in the expression?

1059
00:53:16,990 --> 00:53:17,740
大卫·马兰：当然 
DAVID MALAN: Sure.

1060
00:53:17,740 --> 00:53:21,910
所以如果你想在里面加空格 你不能只用反斜杠w 
So if you want spaces in there, you can't use backslash w alone,

1061
00:53:21,910 --> 00:53:25,690
因为这只是一个单词字符 它是字母 数字 
because that is only a word character which is alphabetical, numerical,

1062
00:53:25,690 --> 00:53:27,100
或下划线 
or the underscore.

1063
00:53:27,100 --> 00:53:28,580
但你能做到的 
But you could do this.

1064
00:53:28,580 --> 00:53:32,170
您可以回到使用方括号的这种方法 
You could go back to this approach whereby you use square brackets.

1065
00:53:32,170 --> 00:53:37,120
你可以说a到z 或者A到Z 或者0到9 
And you could say a through z, or A through Z, or 0 through 9,

1066
00:53:37,120 --> 00:53:40,693
或者下划线 或者我按空格键 一个空格 
or underscore, or I'm going to hit the space bar, a single space.

1067
00:53:40,693 --> 00:53:43,360
你可以在方括号内放一个空格 
You can put a literal space inside of the square brackets, which

1068
00:53:43,360 --> 00:53:45,700
会让你发现一个空间 
will allow you then to detect a space.

1069
00:53:45,700 --> 00:53:49,420
或者 我仍然可以使用反斜杠w 
Alternatively, I could still use backslash w,

1070
00:53:49,420 --> 00:53:51,280
但我可以把它结合起来 
But I could combine it as follows.

1071
00:53:51,280 --> 00:53:54,700
我可以说 给我一个反斜杠W或反斜杠S 
I could say, give me a backslash w or a backslash s,

1072
00:53:54,700 --> 00:53:57,287
因为回想一下 反斜杠s是空格 
because recall that backslash s is whitespace.

1073
00:53:57,287 --> 00:53:58,870
所以它不仅仅是一个空间 
So it's even more than a single space.

1074
00:53:58,870 --> 00:53:59,770
可能是账单 
It could be a tab.

1075
00:53:59,770 --> 00:54:02,140
但是把这些放在括号里 
But by putting those things in parentheses, now

1076
00:54:02,140 --> 00:54:04,060
你可以把左边的东西
you can match either the thing on the left

1077
00:54:04,060 --> 00:54:07,400
或右边的东西一次或多次 
or the thing on the right one or more times.

1078
00:54:07,400 --> 00:54:12,290
关于这些正则表达式的另一个问题怎么样？
How about one other question on these regular expressions?

1079
00:54:12,290 --> 00:54:13,040
观众：完美 
AUDIENCE: Perfect.

1080
00:54:13,040 --> 00:54:19,070
所以我想问 反斜杠w中是否包含一个点？
So I was going to ask, does the backslash w include a dot?

1081
00:54:19,070 --> 00:54:20,730
因为-不 好吧 
Because-- no, OK.

1082
00:54:20,730 --> 00:54:24,230
大卫·马兰：不 它只包括字母、数字和下划线 
DAVID MALAN: No, it only Includes letters, numbers, and underscore.

1083
00:54:24,230 --> 00:54:25,387
到此为止
That is it.

1084
00:54:25,387 --> 00:54:27,470
观众：我想知道 你举了一个例子 
AUDIENCE: And I was wondering, you gave an example

1085
00:54:27,470 --> 00:54:33,140
开始的时候有空格 比如这是我的邮箱 某某 
at the beginning that had spaces, like this is my email, so-and-so.

1086
00:54:33,140 --> 00:54:35,420
我不认为我们现在的版本
I don't think our current version--

1087
00:54:35,420 --> 00:54:39,110
甚至很久以前就不再接受它了
or even quite a long while ago stopped accepting it.

1088
00:54:39,110 --> 00:54:43,915
这是因为^还是因为别的什么？
Was that because of the ^ or because of something else?

1089
00:54:43,915 --> 00:54:47,960
大卫·马兰：不 我之所以在其他英语单词中处理空格 
DAVID MALAN: No, the reason I was handling spaces in other English words

1090
00:54:47,960 --> 00:54:51,425
当我输入我的电子邮件地址malan@harvard.edu时 
when I typed out my email address as malan@harvard.edu

1091
00:54:51,425 --> 00:54:57,380
是因为我们最初使用的是点 * 或点+ 这是任何字符 
was because we were using initially dot *, or dot +, which is any character.

1092
00:54:57,380 --> 00:55:01,340
即使在那之后 我们也说了除了“标志”之外的任何话 
And even after that, we said anything except the @ sign,

1093
00:55:01,340 --> 00:55:02,870
其中包括空格 
which includes spaces.

1094
00:55:02,870 --> 00:55:08,000
只有一次我开始使用方括号和a到z和
Only once I started using square brackets and a through z and 0

1095
00:55:08,000 --> 00:55:11,210
到9和下划线 我们终于说到重点了吗？
through 9 and underscore did we finally get to the point

1096
00:55:11,210 --> 00:55:13,040
在那里我们会拒绝空白 
where we would reject white space.

1097
00:55:13,040 --> 00:55:14,970
事实上 我可以在这里运行这个 
And in fact, I can run this here.

1098
00:55:14,970 --> 00:55:18,980
让我来看看VS Code中我的代码的当前版本 它再次使用
Let me go into the current version of my code in VS Code, which is using, again,

1099
00:55:18,980 --> 00:55:21,620
反斜杠w代表单词字符 让
the backslash w's for word characters, let

1100
00:55:21,620 --> 00:55:24,860
我运行了valiate.py的python 并错误地键入了一些内容
me run python of validate.py and incorrectly type in something

1101
00:55:24,860 --> 00:55:30,020
就像“我的电子邮件地址是maran@atherard.edu”一样 句号
like "my email address is malan@harvard.edu," period, which

1102
00:55:30,020 --> 00:55:34,250
我的用户名左侧有空格 现在无效 
has spaces to the left of my username, and that is now invalid,

1103
00:55:34,250 --> 00:55:36,590
因为空格不是一个单词字符 
because space is not a word character.

1104
00:55:36,590 --> 00:55:39,860
你也会注意到 从技术上讲 我不允许使用圆点 
You're going to notice, too, that technically I'm not allowing dots.

1105
00:55:39,860 --> 00:55:41,902
你们中的一些人可能会想 等一下 
And some of you might be thinking, wait a minute.

1106
00:55:41,902 --> 00:55:43,880
我的Gmail地址里有一个圆点 
My Gmail address has a dot in it.

1107
00:55:43,880 --> 00:55:46,280
这是我们仍然需要解决的问题 
That's something we're going to still have to fix.

1108
00:55:46,280 --> 00:55:49,160
反斜杠w不是这里的结束 
A backslash w is not the end all here.

1109
00:55:49,160 --> 00:55:52,520
它只是让我们表达我们之前的解决方案
It's just allowing us to express our previous solution

1110
00:55:52,520 --> 00:55:54,020
简明扼要一点 
a little more succinctly.

1111
00:55:54,020 --> 00:55:57,260
现在 有一件事我们还没有处理好
Now, one thing we're still not handling quite properly

1112
00:55:57,260 --> 00:55:59,180
是大写还是小写 
is uppercase versus lowercase.

1113
00:55:59,180 --> 00:56:03,200
从技术上讲 反斜杠w可以处理小写字母和大写字母 
The backslash w technically does handle lowercase letters and uppercase,

1114
00:56:03,200 --> 00:56:06,450
因为它和之前的场景一模一样 
because it's the exact same thing as that set from before,

1115
00:56:06,450 --> 00:56:11,670
从小A到小Z 从大A到大Z 但看这个 
which had little a through little z and big A through big Z. But watch this.

1116
00:56:11,670 --> 00:56:14,960
让我继续以我当前的形式运行valiate.py的python 
Let me go ahead in my current form run python of validate.py,

1117
00:56:14,960 --> 00:56:19,376
就因为我的大写锁钥匙掉了 maran@atherard.edu 
and just because my Caps lock key is down, MALAN@HARVARD.EDU,

1118
00:56:19,376 --> 00:56:21,080
喊着我的电子邮件地址 
shouting my email address.

1119
00:56:21,080 --> 00:56:23,640
就马兰而言 一切都会好起来的 
It's going to be OK in terms of the MALAN.

1120
00:56:23,640 --> 00:56:25,940
就哈佛大学而言 一切都会好起来的 
It's going to be OK in terms of the HARVARD,

1121
00:56:25,940 --> 00:56:28,790
因为这些字符与反斜杠w匹配 
because those are matching the backslash w, which

1122
00:56:28,790 --> 00:56:31,490
不包括小写和大写 
does include lowercase and uppercase.

1123
00:56:31,490 --> 00:56:34,310
但我要看到的是残废 
But I'm about to see invalid.

1124
00:56:34,310 --> 00:56:35,210
为什么？
Why?

1125
00:56:35,210 --> 00:56:41,670
为什么在这里全部大写的时候 maran@greavard.edu是无效的 
Why is MALAN@HARVARD.EDU invalid when it's in all caps here,

1126
00:56:41,670 --> 00:56:44,195
即使我用的是反斜杠w？
even though I'm using backslash w?

1127
00:56:44,195 --> 00:56:44,820
观众：是的 
AUDIENCE: Yeah.

1128
00:56:44,820 --> 00:56:50,010
所以您要求的是小写的domain.edu 
So you are asking for the domain.edu in lowercase,

1129
00:56:50,010 --> 00:56:52,105
而且你是用大写字母打字的 
and you're typing it in uppercase.

1130
00:56:52,105 --> 00:56:52,980
大卫·马兰：没错 
DAVID MALAN: Exactly.

1131
00:56:52,980 --> 00:56:55,980
我用大写字母输入我的电子邮件地址 
I'm typing in my email address in all uppercase,

1132
00:56:55,980 --> 00:56:57,892
但我在找字面上的“.edu”
but I'm looking for literally ".edu."

1133
00:56:57,892 --> 00:57:00,600
当我看到你们戴着AirPods和你们中的许多人戴着耳机 
And as I see you with AirPods and so many of you with headphones,

1134
00:57:00,600 --> 00:57:03,810
我很抱歉刚才对着我的麦克风大喊大叫来表达这一点 
I apologize for yelling into my microphone just now to make this point.

1135
00:57:03,810 --> 00:57:05,770
但让我们看看我们是否能解决这个问题 
But let's see if we can't fix that.

1136
00:57:05,770 --> 00:57:11,925
好吧 如果我在第5行的模式是希望它是小写的 
Well, if my pattern on line 5 is expecting it to be lowercase,

1137
00:57:11,925 --> 00:57:13,800
事实上 我有几种方法可以解决这个问题 
there's actually a few ways I can solve this.

1138
00:57:13,800 --> 00:57:15,840
一种是我们以前见过的东西 
One would be something we've seen before.

1139
00:57:15,840 --> 00:57:19,050
我可以强制用户的输入全部为小写 
I could just force the user's input to all lowercase.

1140
00:57:19,050 --> 00:57:23,610
我可以把我的第一行的末尾 更低 并实际上强制它
And I could put onto the end of my first line .lower and actually force it all

1141
00:57:23,610 --> 00:57:24,480
转换为小写 
to lowercase.

1142
00:57:24,480 --> 00:57:26,880
或者 我可以稍晚一点再这样做 
Alternatively, I could do that a little later.

1143
00:57:26,880 --> 00:57:31,050
我可以不传递电子邮件 而是传递电子邮件的小写版本 
Instead of passing an email, I could pass in the lowercase version of email,

1144
00:57:31,050 --> 00:57:33,810
因为电子邮件地址实际上应该不区分大小写 
because email addresses should, in fact, be case insensitive.

1145
00:57:33,810 --> 00:57:34,980
因此 这也会奏效 
So that would work, too.

1146
00:57:34,980 --> 00:57:37,590
但这里还有另一种机制 值得一看 
But there's another mechanism here, which is worth seeing.

1147
00:57:37,590 --> 00:57:43,890
事实证明 调用re.earch之前的函数支持、调用
It turns out that that function before called re.search supports, recall,

1148
00:57:43,890 --> 00:57:46,800
第三个论点也是 这些所谓的旗帜 
a third argument as well, these so-called flags.

1149
00:57:46,800 --> 00:57:49,170
标志是配置选项 通常
And flags are configuration options, typically

1150
00:57:49,170 --> 00:57:52,290
对于一个函数 这允许您对其进行稍微不同的配置 
to a function, that allow you to configure it a little differently.

1151
00:57:52,290 --> 00:57:55,290
我应该如何开始配置此呼叫
And how might I go about configuring this call

1152
00:57:55,290 --> 00:57:59,910
重新搜索稍微有些不同 因为我目前只通过
to re.search a little bit differently insofar as I'm currently only passing

1153
00:57:59,910 --> 00:58:00,900
在两次争论中？
in two arguments?

1154
00:58:00,900 --> 00:58:04,650
事实证明 您可以传递给此函数的一些标志
Well, it turns out that some of the flags you can pass into this function

1155
00:58:04,650 --> 00:58:05,790
是这些吗 
are these.

1156
00:58:05,790 --> 00:58:10,110
事实证明 Python中的正则表达式库 也就是 
It turns out that the regular expression library in Python, a.k.a.

1157
00:58:10,110 --> 00:58:14,040
Re 带有一些内置变量 可以说 
re, comes with a few built-in variables, so to speak,

1158
00:58:14,040 --> 00:58:16,110
你可以认为是常量的东西 
things that you can think of as constants,

1159
00:58:16,110 --> 00:58:19,920
有意义的东西重新搜索 
that have meaning to re.search.

1160
00:58:19,920 --> 00:58:21,760
他们这样做的方式如下 
And they do so as follows.

1161
00:58:21,760 --> 00:58:26,220
如果作为标志re.IGNORECASE传递 re.earch将执行什么操作
If you pass in as a flag re.IGNORECASE, what re.search is going to do

1162
00:58:26,220 --> 00:58:28,530
忽略用户输入的大小写 
is ignore the case of the user's input.

1163
00:58:28,530 --> 00:58:30,880
它可以是大写、小写、它们的组合 
It can be uppercase, lowercase, a combination thereof,

1164
00:58:30,880 --> 00:58:32,470
这起案件将被忽视 
the case is going to be ignored.

1165
00:58:32,470 --> 00:58:34,327
它将被冷淡地对待 
It will be treated case insensitively.

1166
00:58:34,327 --> 00:58:36,660
你还可以做其他我们在这里做不到的事情 
And you can do other things, too, that we won't do here.

1167
00:58:36,660 --> 00:58:40,650
但是 如果您想要处理可能跨越多行的用户输入--
But if you want to handle the user's input that maybe spans multiple lines--

1168
00:58:40,650 --> 00:58:44,040
也许他们输入的不仅仅是一个电子邮件地址 而是一整段
maybe they didn't just type in an email address but an entire paragraph

1169
00:58:44,040 --> 00:58:46,410
如果你想匹配不同的行 
of text, and you want to match different lines

1170
00:58:46,410 --> 00:58:48,210
有多行的文本 
of that text that is multiple lines.

1171
00:58:48,210 --> 00:58:52,950
另一个标志是re.MULTILINE 或者re.DOTALL 
Another flag is for re.MULTILINE for just that, or re.DOTALL,

1172
00:58:52,950 --> 00:58:57,990
你可以配置这个点 
whereby you can configure the dot to recognize not just

1173
00:58:57,990 --> 00:59:02,830
除了换行符之外的任何字符 但也可以是任何字符加换行符 
any character except newlines but any character plus newlines as well.

1174
00:59:02,830 --> 00:59:05,850
但现在 让我继续 只是利用这第一个 
But for now, let me go ahead and just make use of this first one.

1175
00:59:05,850 --> 00:59:13,170
让我向re.search传递第三个参数 即re. IGNORECASE 
Let me pass in a third argument to re.search, which is re.IGNORECASE.

1176
00:59:13,170 --> 00:59:15,330
现在让我在不清除
Let me now rerun the program without clearing

1177
00:59:15,330 --> 00:59:17,670
我的屏幕 python的validate.py 
my screen, python of validate.py.

1178
00:59:17,670 --> 00:59:20,850
让我再次输入所有大写字母 有效地大喊 
Let me type in again in all caps, effectively shouting,

1179
00:59:20,850 --> 00:59:25,200
MALAN@HARVARD.EDU 输入 现在它被认为是有效的 
MALAN@HARVARD.EDU, Enter, and now it's considered valid,

1180
00:59:25,200 --> 00:59:27,690
因为我特别告诉re.search
because I'm telling re.search specifically

1181
00:59:27,690 --> 00:59:29,460
忽略输入的大小写 
to ignore the case of the input.

1182
00:59:29,460 --> 00:59:30,960
在这里也可以 
And that, too, here is fine.

1183
00:59:30,960 --> 00:59:34,500
为什么我可以使用这种方法而不是调用.lower
And why might I do this approach rather than call .lower in one of those other

1184
00:59:34,500 --> 00:59:35,280
地点？
locations?

1185
00:59:35,280 --> 00:59:39,000
呃 如果我不想改变用户的输入 
Eh, if I don't actually want to change the user's input for whatever reason,

1186
00:59:39,000 --> 00:59:43,290
我仍然可以不加区分地对待它 
I can still treat it case insensitively without actually changing

1187
00:59:43,290 --> 00:59:46,140
这个变量本身的值 
the value of that variable itself.

1188
00:59:46,140 --> 00:59:51,970
好了 关于电子邮件地址的验证 现在还有什么问题吗？
All right, any final questions now on this validation of email addresses?

1189
00:59:51,970 --> 00:59:54,600
观众：所以模式是一个字符串 对吗？
AUDIENCE: So the pattern is a string, right?

1190
00:59:54,600 --> 00:59:55,800
大卫·马兰：嗯 
DAVID MALAN: Mm-hmm.

1191
00:59:55,800 --> 00:59:57,390
观众：我们可以使用fstring吗？
AUDIENCE: Can we use an fstring?

1192
00:59:57,390 --> 00:59:58,440
大卫·马兰：你可以 
DAVID MALAN: You can.

1193
00:59:58,440 --> 01:00:01,780
是的 你可以使用一个fstring 这样你就可以插入 例如 
Yes, you can use an fstring so that you could plug in, for instance,

1194
01:00:01,780 --> 01:00:04,830
变量的值并将其传递给函数 
the value of a variable and pass it into the function.

1195
01:00:04,830 --> 01:00:06,000
其他问题？
Other questions on this?

1196
01:00:06,000 --> 01:00:10,342
观众：反斜杠w字符 我们可以把它作为用户的输入吗？
AUDIENCE: Backslash w character, could we take it as an input from the user?

1197
01:00:10,342 --> 01:00:11,550
David Malan：技术上是的 
DAVID MALAN: Technically yes.

1198
01:00:11,550 --> 01:00:13,440
这不是我们现在要解决的问题
That's not a problem we're trying to solve right now.

1199
01:00:13,440 --> 01:00:16,530
我们希望用户提供文字输入 比如他们的电子邮件地址 
We want the user to provide literal input, like their email address,

1200
01:00:16,530 --> 01:00:18,750
不一定是正则表达式 
not necessarily a regular expression.

1201
01:00:18,750 --> 01:00:22,230
但是你可以想象构建一个软件 
But you could imagine building software that asks the user, especially

1202
01:00:22,230 --> 01:00:25,800
如果他们是更高级的用户 出于某种原因 
if they're more advanced users, to type in a regular expression for some reason

1203
01:00:25,800 --> 01:00:27,722
来验证其他的东西
to validate something else against that.

1204
01:00:27,722 --> 01:00:29,430
事实上 这就是Google正在做的事情 
And in fact, that's what Google is doing.

1205
01:00:29,430 --> 01:00:33,630
如果您尝试使用Google Forms并创建一个带有响应验证的表单
If you play around with Google Forms and create a form with response validation

1206
01:00:33,630 --> 01:00:37,590
并选择正则表达式 谷歌允许你和我输入
and select Regular Expression, Google lets you and I type

1207
01:00:37,590 --> 01:00:41,530
在我们自己的正则表达式中 这将是一个很好的例子 
in our own regular expressions, which would be a perfect example of that.

1208
01:00:41,530 --> 01:00:42,030
好的 
All right.

1209
01:00:42,030 --> 01:00:45,900
好吧 让我提议我们试着解决另一个问题 
Well, let me propose that we try to solve one other problem here,

1210
01:00:45,900 --> 01:00:51,480
因此 如果我进入与之前相同的版本 现在忽略大小写 
whereby if I go into the same version as before, which is now ignoring case,

1211
01:00:51,480 --> 01:00:54,100
但我输入了我的另一个电子邮件地址 
but I type in one of my other email addresses.

1212
01:00:54,100 --> 01:00:56,280
让我继续运行valiate.py的python 
Let me go ahead and run python of validate.py.

1213
01:00:56,280 --> 01:00:59,580
这一次 让我输入的不是maran@atherard.edu 它
And this time, let me type in not malan@harvard.edu, which

1214
01:00:59,580 --> 01:01:01,920
我主要使用的是另一个电子邮件地址
I use primarily, but another email address

1215
01:01:01,920 --> 01:01:06,030
我的 maran@cs50.atherard.edu 它转发到相同的 
of mine, malan@cs50.harvard.edu, which forwards to the same.

1216
01:01:06,030 --> 01:01:07,920
现在让我继续按Enter键 
Let me go ahead and hit Enter now.

1217
01:01:07,920 --> 01:01:11,940
嗯 无效 尽管我很确定
And huh, invalid, even though I'm pretty sure that

1218
01:01:11,940 --> 01:01:13,380
实际上 是我的电子邮件地址 
is, in fact, my email address.

1219
01:01:13,380 --> 01:01:15,920
好吧 让我们来找出原因吧 
Well, let's put our finger on the reason why.

1220
01:01:15,920 --> 01:01:20,400
为什么现在是maran@cs50.atherard.edu
Why at the moment is malan@cs50.harvard.edu

1221
01:01:20,400 --> 01:01:25,890
被认为是无效的 即使我很确定我发送和接收
being considered invalid, even though I'm pretty sure I send and receive

1222
01:01:25,890 --> 01:01:27,330
也是从那个地址发的电子邮件吗？
email from that address, too?

1223
01:01:30,470 --> 01:01:32,000
为什么会这样呢？
Why might that be?

1224
01:01:32,000 --> 01:01:38,475
观众：因为在@符号后面有一个圆点 
AUDIENCE: Because there is a dot that has come after the @ symbol.

1225
01:01:38,475 --> 01:01:39,350
大卫·马兰：没错 
DAVID MALAN: Exactly.

1226
01:01:39,350 --> 01:01:42,230
我的CS50后面有一个圆点 
There's a dot after my cs50.

1227
01:01:42,230 --> 01:01:45,080
我并不期待那里有任何圆点 我只是期待 
And I'm not expecting any dots there, I'm expecting only,

1228
01:01:45,080 --> 01:01:50,240
同样是单词字符 从A到z、0到9和下划线 
again, word characters, which is A through z, 0 through 9, and underscore.

1229
01:01:50,240 --> 01:01:52,130
所以我得在这里重新装备一下 
So I'm going to have to retool here.

1230
01:01:52,130 --> 01:01:54,090
但我怎么能着手做这件事呢？
But how could I go about doing this?

1231
01:01:54,090 --> 01:01:57,613
从理论上讲 可能还有其他电子邮件地址 
Well, it turns out theoretically, there could be other email addresses,

1232
01:01:57,613 --> 01:02:00,530
例如 尽管它们会变得有点过长 
even though they'd be getting a little excessively long, for instance,

1233
01:02:00,530 --> 01:02:05,210
Maran@omething.cs50.atherard.edu 技术上并不存在 
malan@something.cs50.harvard.edu, which does not technically exist,

1234
01:02:05,210 --> 01:02:06,125
但这是可能的 
but it could.

1235
01:02:06,125 --> 01:02:09,950
当然 你可以像我们在这里看到的那样 在一个域名中有多个圆点 
You can have, of course, multiple dots in a domain name like we see here.

1236
01:02:09,950 --> 01:02:12,500
如果我们也能处理好那不是很好吗？
Wouldn't it be nice if we could handle that as well?

1237
01:02:12,500 --> 01:02:16,670
好吧 让我提议如下修改我的正则表达式 
Well, let me propose that we modify my regular expression as follows.

1238
01:02:16,670 --> 01:02:20,240
事实证明 你可以把想法组合在一起 
It turns out that you can group ideas together.

1239
01:02:20,240 --> 01:02:24,050
您不仅可以询问此模式是否匹配
And you can not only ask whether or not this pattern matches

1240
01:02:24,050 --> 01:02:29,780
或者这个使用类似A竖线B的语法 意思是“A或B” 
or this one using syntax like A vertical bar B, which means "either A or B,"

1241
01:02:29,780 --> 01:02:34,280
您还可以将对象组合在一起 然后对其应用其他运算符
you can also group things together and then apply some other operator to them

1242
01:02:34,280 --> 01:02:35,100
也是 
as well.

1243
01:02:35,100 --> 01:02:37,160
事实上 让我回到这里的代码 
In fact, let me go back to the code here.

1244
01:02:37,160 --> 01:02:42,260
让我提议 如果我想容忍像cs50这样的子域 
And let me propose that if I want to tolerate a subdomain, like cs50,

1245
01:02:42,260 --> 01:02:46,700
这可能在那里 也可能不在那里 让我继续进行更改 如下所示 
that may or may not be there, let me go ahead and change it as follows.

1246
01:02:46,700 --> 01:02:48,320
我可以天真地做这件事 
I could naively do this.

1247
01:02:48,320 --> 01:02:51,210
如果我想支持子域 我可以说 好吧 
If I want to support subdomains, I could say, well,

1248
01:02:51,210 --> 01:02:55,640
让我们考虑其他单词字符加号 然后是字面点 
let's allow for other word characters plus, and then a literal dot.

1249
01:02:55,640 --> 01:02:58,970
请注意 我将在这里用蓝色突出显示我刚刚添加的内容 
And notice, I'll highlight in blue here what I've just added.

1250
01:02:58,970 --> 01:03:04,190
其他一切都是一样的 但我现在要为另一个序列添加空间
Everything else is the same, but I'm now adding room for another sequence of one

1251
01:03:04,190 --> 01:03:07,650
或更多单词字符 然后是字面点 
or more word characters and then a literal dot.

1252
01:03:07,650 --> 01:03:12,380
所以现在 我想 如果我重新运行valiate.py的python 
So this now, I think, if I rerun python of validate.py,

1253
01:03:12,380 --> 01:03:16,310
将适用于Malan@cs50.atherard.edu 输入 
will work for malan@cs50.harvard.edu, Enter.

1254
01:03:16,310 --> 01:03:19,610
不幸的是 有没有人知道这是怎么回事？
Unfortunately, does anyone see where this is going?

1255
01:03:19,610 --> 01:03:22,310
让我重新运行valiate.py的python 然后输入
Let me rerun python of validate.py and type

1256
01:03:22,310 --> 01:03:25,010
在我一直在做的事情中 到目前为止 Malan@atherard.edu
in as I keep doing, malan@harvard.edu, which up until now

1257
01:03:25,010 --> 01:03:27,290
尽管我做了这么多改变 我还是继续工作 
has kept working despite all of my changes.

1258
01:03:27,290 --> 01:03:33,110
但现在 呃 我终于破解了我自己的电子邮件地址 
But now, ugh, finally I've broken my own email address.

1259
01:03:33,110 --> 01:03:35,540
那么 从逻辑上讲 这里的解决方案是什么？
So logically what's the solution here?

1260
01:03:35,540 --> 01:03:37,730
好吧 我们有很多办法可以解决这个问题 
Well, there's a bunch of ways we could solve this.

1261
01:03:37,730 --> 01:03:40,430
我也许可以开始使用两个正则表达式
I could maybe start using two regular expressions

1262
01:03:40,430 --> 01:03:46,370
并支持以下形式的电子邮件地址：username@domain.tld 
and support email addresses of the form username@domain.tld,

1263
01:03:46,370 --> 01:03:51,350
或用户名@subdomain.domain.tld 其中TLD只是
or username@subdomain.domain.tld, where TLD just

1264
01:03:51,350 --> 01:03:53,917
指顶级域名 如EDU 
means Top Level Domain, like edu.

1265
01:03:53,917 --> 01:03:56,000
或者我可以修改这个 因为我会
Or I could maybe just modify this one, because I'd

1266
01:03:56,000 --> 01:04:00,920
不希望有两个正则表达式或一个两倍大的正则表达式 
prefer not to have two regular expressions or one that's twice as big.

1267
01:04:00,920 --> 01:04:06,470
为什么我不指定re.earch这个模式的部分是可选的呢？
Why don't I just specify to re.search that part of this pattern is optional?

1268
01:04:06,470 --> 01:04:10,400
我们之前看到的那个符号是什么？
What was the symbol we saw earlier that allows

1269
01:04:10,400 --> 01:04:15,440
你想具体说明之前的事情在技术上是可选的吗？
you to specify that the thing before it is technically optional?

1270
01:04:15,440 --> 01:04:16,610
观众：异性恋吧？
AUDIENCE: The straight bar?

1271
01:04:16,610 --> 01:04:19,790
我们把直杆当做--
We were using the straight bar as an--

1272
01:04:19,790 --> 01:04:22,678
可选 则将参数设置为可选 
optional, make the argument optional.

1273
01:04:22,678 --> 01:04:23,720
大卫·马兰：所以我们可以 
DAVID MALAN: So we could.

1274
01:04:23,720 --> 01:04:26,210
我们可以使用竖线和一些圆括号
We could use a vertical bar and some parentheses

1275
01:04:26,210 --> 01:04:29,480
然后说 “要么这里有东西 要么什么都没有 ”
and say, "either there's something here or there's nothing."

1276
01:04:29,480 --> 01:04:31,010
我们可以在括号中这样做 
We could do that in parentheses.

1277
01:04:31,010 --> 01:04:33,860
但我认为实际上还有一种更简单的方法 
But I think there's actually an even easier way.

1278
01:04:33,860 --> 01:04:36,332
观众：事实上 这是一个问号 
AUDIENCE: Actually, it's a question mark.

1279
01:04:36,332 --> 01:04:37,790
大卫·马兰：的确 这是个问号 
DAVID MALAN: Indeed, question mark.

1280
01:04:37,790 --> 01:04:41,240
回想一下我们第一组符号的总结 
Think back to this summary here of our first set of symbols,

1281
01:04:41,240 --> 01:04:46,130
因此我们不仅有点和*和+ 而且还有一个问号 其中
whereby we had not just dot and * and +, but also a question mark, which

1282
01:04:46,130 --> 01:04:49,370
字面意思是“零或一次重复” 
means literally "zero or one repetitions," which

1283
01:04:49,370 --> 01:04:50,810
实际上意味着可选 
effectively means optional.

1284
01:04:50,810 --> 01:04:54,740
它要么在那里 一个 要么不是 零 
It's either there, one, or it's not, zero.

1285
01:04:54,740 --> 01:04:57,650
现在 我该如何将它翻译成这里的代码呢？
Now, how can I translate that to this code here?

1286
01:04:57,650 --> 01:05:03,150
好 让我继续 用括号将我的模式的这一部分括起来 
Well, let me go ahead and surround this part of my pattern with parentheses,

1287
01:05:03,150 --> 01:05:06,740
这并不意味着我想在用户的输入中使用括号 
which doesn't mean I want literally a parentheses in the user's input,

1288
01:05:06,740 --> 01:05:09,410
我只是想把这些角色组合在一起 
I just want to group these characters together.

1289
01:05:09,410 --> 01:05:11,480
事实上 这一点现在仍然有效 
And in fact, this now will still work.

1290
01:05:11,480 --> 01:05:14,960
我只是在子域的新部分周围添加了圆括号 
I've only added parentheses around the new part for the subdomain.

1291
01:05:14,960 --> 01:05:17,000
让我运行valiate.py的python 
Let me run python of validate.py.

1292
01:05:17,000 --> 01:05:20,060
让我运行maran@cs50.atherard.edu 回车 
Let me run malan@cs50.harvard.edu, Enter.

1293
01:05:20,060 --> 01:05:21,110
这一点仍然有效 
That's still valid.

1294
01:05:21,110 --> 01:05:25,730
但需要明确的是 如果我再次为maran@atherard.edu运行它 它仍然是
But to be clear, if I rerun it again for malan@harvard.edu, that is still

1295
01:05:25,730 --> 01:05:31,310
无效 但如果我进入这里 在括号后面说 这不是无效的
invalid, but not if I go in here and say, after the parentheses, which

1296
01:05:31,310 --> 01:05:36,410
现在是一个逻辑单元 它是一大组想法在一起 
now is one logical unit, it's one big group of ideas together,

1297
01:05:36,410 --> 01:05:38,690
我在那里加了一个问号 
I add a single question mark there.

1298
01:05:38,690 --> 01:05:43,910
现在 这将告诉re.earch 括号中的整个内容
This will now tell re.search that that whole thing in parentheses

1299
01:05:43,910 --> 01:05:49,020
要么只在那里一次 要么根本不在那里 零次 
can either be there once or be there not at all, zero times.

1300
01:05:49,020 --> 01:05:51,530
那么 当我运行它时 这意味着什么？
So what does this translate into when I run it?

1301
01:05:51,530 --> 01:05:56,030
好的 让我继续使用maran@cs50重新运行它 
Well, let me go ahead and rerun it with malan@cs50.harvard.edu

1302
01:05:56,030 --> 01:05:57,770
所以子域就在那里 
so that the subdomain is there.

1303
01:05:57,770 --> 01:05:59,720
这和以前一样管用 
That works as before.

1304
01:05:59,720 --> 01:06:01,860
让我清空屏幕 然后再运行一次 蟒蛇
Let me clear my screen and run it again, python

1305
01:06:01,860 --> 01:06:06,830
用Malan@atherard.edu创建的validate.py 它曾经很有效 但后来崩溃了 
of validate.py with malan@harvard.edu, which used to work then broke.

1306
01:06:06,830 --> 01:06:08,330
我们现在又开业了吗？
Are we back in business now?

1307
01:06:08,330 --> 01:06:09,260
我们是 
We are.

1308
01:06:09,260 --> 01:06:11,810
这现在又是有效的了 
That's now valid again.

1309
01:06:11,810 --> 01:06:14,540
关于这种方法的问题 我们在哪里使用了
Questions now on this approach, where we've used

1310
01:06:14,540 --> 01:06:18,655
不仅是问号 还有括号？
not just the question mark but the parentheses as well?

1311
01:06:18,655 --> 01:06:19,280
观众：是的 
AUDIENCE: Yeah.

1312
01:06:19,280 --> 01:06:22,130
你说过它可以重复0次或1次 
You said it works for zero or one repetitions.

1313
01:06:22,130 --> 01:06:23,912
如果你有更多呢？
What if you have more?

1314
01:06:23,912 --> 01:06:25,370
大卫·马兰：如果你有更多呢？
DAVID MALAN: What if you have more?

1315
01:06:25,370 --> 01:06:26,220
没关系 
That's OK.

1316
01:06:26,220 --> 01:06:28,610
这就是你可以做的* 
That's where you could do *.

1317
01:06:28,610 --> 01:06:33,835
*为零或更多 这为您提供了世界上所有的灵活性 
* is zero or more, which gives you all the flexibility in the world.

1318
01:06:33,835 --> 01:06:34,460
观众：是的 
AUDIENCE: Yeah.

1319
01:06:34,460 --> 01:06:37,050
所以我只是在问--
So I was just asking that--

1320
01:06:37,050 --> 01:06:40,670
使用问号时 只允许重复一次 
with question marks, there's only one repetition allowed.

1321
01:06:40,670 --> 01:06:42,810
大卫·马兰：这意味着零或一次重复 
DAVID MALAN: It means zero or one repetition.

1322
01:06:42,810 --> 01:06:45,630
所以它要么不在那里 要么就在那里 
So it's either not there or it is there.

1323
01:06:45,630 --> 01:06:49,940
这就是为什么现在这个模式 如果我回到我的代码 即使再一次 
And so that's why this pattern now, if I go back to my code, even though again,

1324
01:06:49,940 --> 01:06:54,650
诚然 它看起来很神秘 让我突出显示@符号之后的所有内容
it admittedly looks cryptic, let me highlight everything after the @ sign

1325
01:06:54,650 --> 01:06:56,060
在$符号之前 
and before the $ sign.

1326
01:06:56,060 --> 01:07:01,001
这现在代表了一个域名 如获得者.edu 
This now represents a domain name, like harvard.edu,

1327
01:07:01,001 --> 01:07:03,920
或域名内的子域 
or a subdomain within the domain name.

1328
01:07:03,920 --> 01:07:04,700
为什么？
Why?

1329
01:07:04,700 --> 01:07:07,700
好的 右边的这部分和往常一样 
Well, this part to the right is the same as always.

1330
01:07:07,700 --> 01:07:11,330
反斜杠w+的意思类似于哈佛或耶鲁 
Backslash w + means something like Harvard or Yale.

1331
01:07:11,330 --> 01:07:14,810
反斜杠.edu的字面意思是“.edu” 
Backslash .edu means literally ".edu."

1332
01:07:14,810 --> 01:07:16,430
所以新的部分是这样的 
So the new part is this.

1333
01:07:16,430 --> 01:07:22,370
在圆括号中 我现在有了另一组反斜杠w+反斜杠圆点 
In parentheses, I have another set of backslash w + backslash dot now.

1334
01:07:22,370 --> 01:07:24,080
但这一切都在括号中 
But it's all in parentheses.

1335
01:07:24,080 --> 01:07:26,870
在那之后我现在有一个问号 
I'm now having a question mark right after that,

1336
01:07:26,870 --> 01:07:30,710
这意味着括号中的整个东西也可以在那里 
which means that whole thing in parentheses either can be there,

1337
01:07:30,710 --> 01:07:31,850
或者它不可能在那里 
or it can't be there.

1338
01:07:31,850 --> 01:07:34,010
这两个都是可以接受的 
It's either of those that are acceptable.

1339
01:07:34,010 --> 01:07:37,880
因此 一个问号实际上使一些东西成为可选的 
So a question mark effectively make something optional.

1340
01:07:37,880 --> 01:07:40,670
去掉括号是不正确的 
It would not be correct to remove the parentheses,

1341
01:07:40,670 --> 01:07:42,150
因为这意味着什么？
because what would this mean?

1342
01:07:42,150 --> 01:07:44,690
如果我去掉括号 那就意味着
If I removed the parentheses, that would mean

1343
01:07:44,690 --> 01:07:49,580
只有这个点是可选的 这并不是我们想要表达的 
that only this dot is optional, which isn't really what we want to express.

1344
01:07:49,580 --> 01:07:54,050
我想要子域名 如CS50和附加点
I want the subdomain, like cs50 and the additional dot

1345
01:07:54,050 --> 01:07:56,060
在那里或不在那里的东西 
to be what's there or not there.

1346
01:07:56,060 --> 01:07:59,270
这里还有一个关于正则表达式的问题怎么样？
How about one other question on regexes here?

1347
01:07:59,270 --> 01:08:01,530
观众：我们可以用这个作为用户名吗？
AUDIENCE: Can we use this for the usernames?

1348
01:08:01,530 --> 01:08:02,530
大卫·马兰：当然 
DAVID MALAN: Absolutely.

1349
01:08:02,530 --> 01:08:04,000
我们还有其他问题 
We still have other problems.

1350
01:08:04,000 --> 01:08:06,280
我们目前还没有解决所有的问题 
We're not solving all of the problems today just yet.

1351
01:08:06,280 --> 01:08:07,330
但绝对是这样 
But absolutely.

1352
01:08:07,330 --> 01:08:11,380
目前 我们不允许您的用户名中有句点 
Right now, we are not letting you have a period in your username.

1353
01:08:11,380 --> 01:08:14,088
再一次 你们中的一些人拥有Gmail账户或其他账户 你
And again, some of you with Gmail accounts or other accounts, you

1354
01:08:14,088 --> 01:08:16,463
可能不仅仅是下划线、数字和字母 
probably have not just underscores, numbers, and letters.

1355
01:08:16,463 --> 01:08:17,740
你可能也会来月经 
You might have periods, too.

1356
01:08:17,740 --> 01:08:21,790
嗯 我们可以解决这个问题 而不是在这里使用问号本身 
Well, we could fix that, not using question mark here per se.

1357
01:08:21,790 --> 01:08:25,630
但现在我们有了这些括号 我能做的是
But now that we have these parentheses at our disposal, what I could do

1358
01:08:25,630 --> 01:08:26,350
是这个吗 
is this.

1359
01:08:26,350 --> 01:08:30,399
我可以用圆括号将反斜杠w括起来 
I could use parentheses to surround the backslash w

1360
01:08:30,399 --> 01:08:33,819
说“任何单词字符” 也就是说 就像字母一样 
to say "any word character," which is the same thing, again, as a letter,

1361
01:08:33,819 --> 01:08:35,529
或数字 或下划线 
or a number, or an underscore.

1362
01:08:35,529 --> 01:08:40,120
但我也可以用竖条或其他的东西 
But I could also or in, using a vertical bar, something else,

1363
01:08:40,120 --> 01:08:41,800
就像一个字面点 
like a literal dot.

1364
01:08:41,800 --> 01:08:44,770
现在 需要转义一个文字点 否则它
Now, a literal dot needs to be escaped, otherwise it

1365
01:08:44,770 --> 01:08:47,859
代表任何角色 这将是一种倒退 是一种倒退 
represents any character, which would be a regression, a step back.

1366
01:08:47,859 --> 01:08:49,540
但现在请注意我做了什么 
But now notice what I've done.

1367
01:08:49,540 --> 01:08:54,370
在括号中 我告诉re.earch前几个字符
In parentheses, I'm telling re.search that those first few characters

1368
01:08:54,370 --> 01:08:56,800
在您的电子邮件地址中 这是您的用户名 
in your email address, that is your username,

1369
01:08:56,800 --> 01:09:02,049
必须是单词字符 如A到z、大写或小写或0
has to be a word character, like A through z, uppercase or lowercase, or 0

1370
01:09:02,049 --> 01:09:05,290
到9、下划线或直接点 
through 9, or an underscore, or a literal dot.

1371
01:09:05,290 --> 01:09:06,760
我们也可以用不同的方式来做这件事 
We could do this differently, too.

1372
01:09:06,760 --> 01:09:09,220
我可以去掉括号和
I could get rid of the parentheses and the

1373
01:09:09,220 --> 01:09:12,010
或者 我可以只使用一组字符 
or, and I could just use a set of characters.

1374
01:09:12,010 --> 01:09:17,890
我可以再一次手动说a到z A到Z 0到9 
I could, again, manually say a through z, A through Z, 0 through 9,

1375
01:09:17,890 --> 01:09:22,540
下划线 然后我可以做一个带反斜杠句点的直接点 
underscore, and then I could do a literal dot with a backslash period.

1376
01:09:22,540 --> 01:09:25,029
现在技术上我甚至不需要大写字母 
And now I technically don't even need the uppercase,

1377
01:09:25,029 --> 01:09:27,590
因为我已经告诉电脑忽略这个案子了 
because I'm already telling the computer to ignore case.

1378
01:09:27,590 --> 01:09:29,359
我可以随便挑一个 
I can just pick one or the other.

1379
01:09:29,359 --> 01:09:31,120
哪个更好 真的由你自己决定 
Which one is better is really up to you.

1380
01:09:31,120 --> 01:09:35,600
您认为可读性更好的版本通常是更好的设计 
Whichever one you think is more readable would generally be the better design.

1381
01:09:35,600 --> 01:09:36,100
好的 
All right.

1382
01:09:36,100 --> 01:09:38,979
让我提议我及时倒回这篇文章
Let me propose that I rewind this in time

1383
01:09:38,979 --> 01:09:42,819
回到我们停下来的地方 也就是这里 
to where we left off, which was here.

1384
01:09:42,819 --> 01:09:44,800
让我提议 确实有 
And let me propose that there are, indeed,

1385
01:09:44,800 --> 01:09:48,935
此解决方案仍有局限性 不仅仅是用户名 也不仅仅是
still limitations of this solution, not just with the username, not just

1386
01:09:48,935 --> 01:09:49,810
使用域名 
with the domain name.

1387
01:09:49,810 --> 01:09:51,700
我们还是有点太严格了 
We're still being a little too restrictive.

1388
01:09:51,700 --> 01:09:54,910
那么 您是否希望看到正式的正则表达式
So would you like to see the official regular expression

1389
01:09:54,910 --> 01:09:58,720
至少现在的浏览器在你输入电子邮件地址的时候都在使用
that at least browsers use nowadays whenever you type in an email address

1390
01:09:58,720 --> 01:10:01,450
到Web表单 并且该Web表单、浏览器
to a web form, and the web form, the browser,

1391
01:10:01,450 --> 01:10:05,680
告诉你是或否 你的电子邮件地址在句法上是有效的？
tells you yes or no, your email address is syntactically valid?

1392
01:10:05,680 --> 01:10:06,670
准备好的?
Ready?

1393
01:10:06,670 --> 01:10:07,810
准备好的?
Ready?

1394
01:10:07,810 --> 01:10:12,730
这就是--这甚至不是正式的正则表达式 
Here is-- and this isn't even officially the right regular expression.

1395
01:10:12,730 --> 01:10:15,670
它是浏览器使用的简化版本 因为它
It's a simplified version that browsers use because it

1396
01:10:15,670 --> 01:10:18,100
抓住大多数错误 但不是全部 
catches most mistakes but not all.

1397
01:10:18,100 --> 01:10:19,460
我们开始吧 
Here we go.

1398
01:10:19,460 --> 01:10:23,710
这是有效电子邮件地址的正则表达式 
This is the regular expression for a valid email address,

1399
01:10:23,710 --> 01:10:27,550
至少作为现在的浏览器来实现它们 
at least as browsers nowadays implement them.

1400
01:10:27,550 --> 01:10:30,610
现在乍一看 这件事非常神秘 
Now it's crazy cryptic at first glance.

1401
01:10:30,610 --> 01:10:34,930
但请注意--它包裹在许多行上 但它只是一种模式 
But note-- and it's wrapping on to many lines, but it's just one pattern.

1402
01:10:34,930 --> 01:10:37,930
但只要注意一下现在熟悉的符号就知道了 
But just notice the now-familiar symbols.

1403
01:10:37,930 --> 01:10:40,540
在最上面有^符号 
There is the ^ symbol at the very top.

1404
01:10:40,540 --> 01:10:43,280
在最后有一个$符号 
There is the $ sign at the very end.

1405
01:10:43,280 --> 01:10:45,730
这里有一个方括号 然后还有一些
There is a square bracket over here and then some

1406
01:10:45,730 --> 01:10:47,860
这些范围加上其他字符 
of these ranges plus other characters.

1407
01:10:47,860 --> 01:10:51,280
事实证明 你通常不会在电子邮件地址中看到这些字符 
Turns out you don't normally see these characters in email addresses.

1408
01:10:51,280 --> 01:10:53,770
看起来你是在用某人的用户名咒骂他们 
It looks like you're swearing at someone in their username.

1409
01:10:53,770 --> 01:10:55,450
但他们是合法的角色 
But they're valid characters.

1410
01:10:55,450 --> 01:10:56,680
它们是正式有效的 
They're valid officially.

1411
01:10:56,680 --> 01:11:00,670
这并不意味着Gmail将允许你放置$符号和其他
That doesn't mean that Gmail is going to allow you to put $ signs and other

1412
01:11:00,670 --> 01:11:02,260
用户名中的标点符号 
punctuation in your username.

1413
01:11:02,260 --> 01:11:04,850
但从官方角度来看 一些服务器可能会允许这样做 
But officially, some servers might allow that.

1414
01:11:04,850 --> 01:11:08,080
因此 如果您真的想验证用户的电子邮件地址 
So if you really want to validate a user's email address,

1415
01:11:08,080 --> 01:11:12,250
你实际上会想出或复制粘贴类似这样的东西 
you would actually come up with or copy-paste something like this.

1416
01:11:12,250 --> 01:11:14,680
但老实说 这看起来很神秘 
But honestly, this looks so cryptic.

1417
01:11:14,680 --> 01:11:18,680
如果你手动打字 你很可能会犯错误 
And if you were to type it out manually, you are so likely to make a mistake.

1418
01:11:18,680 --> 01:11:21,040
这里有什么更好的解决方案呢？
What's the better solution here instead?

1419
01:11:21,040 --> 01:11:24,820
在过去的几周里 图书馆就是你的朋友 
This is where, per past weeks, libraries are your friend.

1420
01:11:24,820 --> 01:11:28,360
当然 互联网上的其他人 一个程序员
Surely someone else on the internet, a programmer more

1421
01:11:28,360 --> 01:11:31,360
比你更有经验的人 甚至已经想出了代码
experienced than you, even, has come up with code

1422
01:11:31,360 --> 01:11:35,830
使用这个正则表达式 甚至可以正确验证电子邮件地址
that validates email addresses properly, using this regular expression or even

1423
01:11:35,830 --> 01:11:37,580
比那更复杂的东西 
something more sophisticated than that.

1424
01:11:37,580 --> 01:11:40,030
因此 一般来说 如果手头的问题是验证
So generally, if the problem at hand is to validate

1425
01:11:40,030 --> 01:11:43,060
非常常规的输入--电子邮件地址 
input that is pretty conventional-- an email address,

1426
01:11:43,060 --> 01:11:46,570
URL 其中有官方定义的东西
a URL, something where there's an official definition that's

1427
01:11:46,570 --> 01:11:50,710
独立于你自己--找一个你喜欢的图书馆
independent of you yourself-- find a popular library that you're

1428
01:11:50,710 --> 01:11:55,130
在您的代码中轻松使用并使用它来验证电子邮件地址 
comfortable using and use it in your code to validate email addresses.

1429
01:11:55,130 --> 01:11:58,750
这不一定是你自己应该发明的轮子 
This is not a wheel, necessarily, that you yourself should invent.

1430
01:11:58,750 --> 01:12:01,870
不过 我们已经使用电子邮件地址反复开始
We've used email addresses, though, to iteratively start

1431
01:12:01,870 --> 01:12:05,300
从简单、过于简单的东西开始 并在此基础上建立起来 
from something simple, too simple, and build on top of that.

1432
01:12:05,300 --> 01:12:07,960
因此 您当然可以想象仍然使用正则表达式
So you could certainly imagine using regular expressions still

1433
01:12:07,960 --> 01:12:10,210
要验证不是电子邮件地址但却是
to validate things that aren't email addresses but are

1434
01:12:10,210 --> 01:12:12,230
对您很重要的数据 
data that are important to you.

1435
01:12:12,230 --> 01:12:14,980
所以至少我们现在有了这些积木 
So we at least now have these building blocks.

1436
01:12:14,980 --> 01:12:17,380
现在 除了正则表达式本身 
Now, besides the regular expressions themselves,

1437
01:12:17,380 --> 01:12:20,290
原来 在PythonRe中还有其他函数
it turns out there's other functions in Python's re

1438
01:12:20,290 --> 01:12:22,030
正则表达式的库 
library for regular expressions.

1439
01:12:22,030 --> 01:12:24,280
其中有这样一个函数 re.Match 
Among them is this function here, re.match,

1440
01:12:24,280 --> 01:12:26,980
这实际上与re.earch非常相似 
which is actually very similar to re.search,

1441
01:12:26,980 --> 01:12:29,462
除非您不必指定^符号
except you don't have to specify the ^ symbol

1442
01:12:29,462 --> 01:12:31,420
在您的正则表达式的最开始处 如果您愿意
at the very beginning of your regex if you want

1443
01:12:31,420 --> 01:12:33,400
从字符串的开头开始匹配 
to match from the start of a string.

1444
01:12:33,400 --> 01:12:36,958
按设计重新匹配将自动开始匹配
re.match by design will automatically start matching

1445
01:12:36,958 --> 01:12:38,500
从琴弦的开头给你 
from the start of the string for you.

1446
01:12:38,500 --> 01:12:42,580
在精神上相似的是re.fullMatch 它做同样的事情 但不仅仅是
Similar in spirit is re.fullmatch, which does the same thing but not only

1447
01:12:42,580 --> 01:12:45,730
匹配字符串的开头但字符串的结尾 因此 
matches at the start of the string but the end of the string, so that you,

1448
01:12:45,730 --> 01:12:50,240
同样 也不需要同时输入^符号或$符号 
too, don't need to type in the ^ symbol or the $ sign as well.

1449
01:12:50,240 --> 01:12:53,170
但现在让我们继续转换回一些实际的代码 
But let's go ahead and transition back now to some actual code,

1450
01:12:53,170 --> 01:12:55,420
借此我们在精神上解决一个不同的问题 
whereby we solve a different problem in spirit.

1451
01:12:55,420 --> 01:12:57,920
而不是仅仅验证用户的输入
Rather than just validate the user's input

1452
01:12:57,920 --> 01:13:00,290
并确保它看起来像我们想要的 让我们
and make sure it looks the way we want, let's just

1453
01:13:00,290 --> 01:13:04,020
假设用户不会完全按照我们的要求键入数据 
assume that the users are not going to type in data exactly as we want,

1454
01:13:04,020 --> 01:13:06,290
因此 我们将不得不清理他们的投入 
and so we're going to have to clean up their input.

1455
01:13:06,290 --> 01:13:10,580
当您使用Google Form或Office 365 Form时 这种情况经常发生 
This happens so often when you're using like a Google Form, or Office 365 form,

1456
01:13:10,580 --> 01:13:12,800
或任何其他用于收集用户输入的内容 
or anything else to collect user input.

1457
01:13:12,800 --> 01:13:15,800
无论您的表单问题是什么 您的用户
No matter what your form question says, your users

1458
01:13:15,800 --> 01:13:18,225
不一定要遵循这些方向 
are not necessarily going to follow those directions.

1459
01:13:18,225 --> 01:13:20,600
他们可能会继续输入一些
They might go ahead and type in something that's a little

1460
01:13:20,600 --> 01:13:22,910
格式与您可能喜欢的不同 
differently formatted than you might like.

1461
01:13:22,910 --> 01:13:26,810
现在 你当然可以浏览结果并下载CSV 
Now, you could certainly go through the results and download a CSV,

1462
01:13:26,810 --> 01:13:29,720
或者打开Google电子表格 或类似的Excel 
or open the Google spreadsheet, or equivalent in Excel,

1463
01:13:29,720 --> 01:13:31,980
然后手动清理所有数据
and just clean up all of the data manually.

1464
01:13:31,980 --> 01:13:34,250
但是如果你有很多的意见书--几十个 
But if you've got lots of submissions-- dozens,

1465
01:13:34,250 --> 01:13:37,070
成百上千的数据行--
hundreds, thousands of rows in your data set--

1466
01:13:37,070 --> 01:13:39,170
手动操作可能不是很有趣 
doing things manually might not be very fun.

1467
01:13:39,170 --> 01:13:42,680
写代码可能会更有效 比如Python 
It might be much more effective to write code, as in Python,

1468
01:13:42,680 --> 01:13:47,220
这可以让您清理数据以及任何未来的数据 
that can allow you to clean up that data and any future data as well.

1469
01:13:47,220 --> 01:13:51,620
所以我建议我们继续关闭validate.py 
So let me propose that we go ahead here and close validate.py.

1470
01:13:51,620 --> 01:13:55,460
让我们继续创建一个新的程序 叫做format.py 
And let's go ahead and create a new program altogether called format.py,

1471
01:13:55,460 --> 01:13:59,990
其目标是将用户的输入重新格式化为我们期望的格式 
the goal of which is to reformat the user's input in the format we expect.

1472
01:13:59,990 --> 01:14:03,080
我将继续运行format.py代码 
I'm going to go ahead and run code of format.py.

1473
01:14:03,080 --> 01:14:06,170
假设我们要重新格式化的数据
And let's suppose that the data we're going to reformat

1474
01:14:06,170 --> 01:14:09,703
是用户的名字--所以这次不是电子邮件地址而是名字 
is the user's name-- so not email address but name this time.

1475
01:14:09,703 --> 01:14:11,870
我们希望他们输入自己的名字
And we're going to hope that they type in their name

1476
01:14:11,870 --> 01:14:14,270
像大卫·马兰一样
properly, like David Malan.

1477
01:14:14,270 --> 01:14:16,610
但有些用户可能已经习惯了 
But some users might be in the habit, for whatever

1478
01:14:16,610 --> 01:14:19,020
如果你愿意的话 倒着打他们的名字 
reason, of typing their name backwards, if you will,

1479
01:14:19,020 --> 01:14:23,030
用一个逗号 如马兰逗号大卫代替 
with a comma, such as Malan comma David instead.

1480
01:14:23,030 --> 01:14:27,740
现在 这很好 因为两者对人类来说都是可读的 
Now, it's fine because both are clearly as readable to the human.

1481
01:14:27,740 --> 01:14:30,530
但如果你想标准化这些名字的存储方式
But if you want to standardize how those names are stored

1482
01:14:30,530 --> 01:14:34,250
在您系统中 可能是数据库、CSV文件或其他文件 
in your system, perhaps a database, or CSV file, or something else,

1483
01:14:34,250 --> 01:14:37,970
如果能至少标准化或规范化格式 
it would be nice to at least standardize or canonicalize the format in which

1484
01:14:37,970 --> 01:14:41,060
你在存储你的数据 这样如果你打印出用户的名字 
you're storing your data, so that if you print out the user's name

1485
01:14:41,060 --> 01:14:43,250
都是一样的格式 大卫·马兰
it's always the same format, David Malan,

1486
01:14:43,250 --> 01:14:46,410
没有逗号也没有落后
and there's no commas or backwardness to it.

1487
01:14:46,410 --> 01:14:48,650
让我们继续做一些熟悉的事情 
So let's go ahead and do something familiar.

1488
01:14:48,650 --> 01:14:50,990
让我们给自己一个变量name
Let's go ahead and give myself a variable called name

1489
01:14:50,990 --> 01:14:53,120
并将其设置为等于input的返回值 
and set it equal to the return value of input,

1490
01:14:53,120 --> 01:14:56,300
问用户 就像我们做过很多次的那样 “你叫什么名字 ”
asking the user, as we've done many times, "what's your name,"

1491
01:14:56,300 --> 01:14:57,170
问号
question mark.

1492
01:14:57,170 --> 01:15:00,290
我要继续前进 至少主动清理一些混乱 
I'm going to go ahead and proactively at least clean up some messiness,

1493
01:15:00,290 --> 01:15:03,950
就像我们在这里一直做的那样 去掉所有的前导或尾随空格 
as we keep doing here, by just stripping off any leading or trailing whitespace.

1494
01:15:03,950 --> 01:15:06,470
以防用户不小心按到空格键 
Just in case the user accidentally hits the spacebar,

1495
01:15:06,470 --> 01:15:09,720
我们不希望最终在我们的数据集中出现这种情况 
we don't want that ultimately in our data set.

1496
01:15:09,720 --> 01:15:12,260
现在让我继续 就像我们以前做过的那样 
And now let me go ahead and do this as we've done before.

1497
01:15:12,260 --> 01:15:14,900
让我快速地继续并打印出来 只是为了确保
Let me just go ahead quickly and print out, just to make sure

1498
01:15:14,900 --> 01:15:18,650
我的开头是正确的 “你好 ”然后用花括号命名 
I'm off to the right start, "hello," and then in curly braces name,

1499
01:15:18,650 --> 01:15:22,010
因此 创建一个fstring来格式化“Hello”、“Comma”、“name” 
so making an fstring to format "hello," comma, "name."

1500
01:15:22,010 --> 01:15:25,730
现在 让我继续清理屏幕并运行格式为.py的python 
Now let me go ahead and clear my screen and run python of format.py.

1501
01:15:25,730 --> 01:15:29,510
让我像往常一样输入我的名字 大卫 空格 马兰 
Let me behave and type in my name as I normally would, David, space, Malan,

1502
01:15:29,510 --> 01:15:30,170
进来吧 
Enter.

1503
01:15:30,170 --> 01:15:32,270
我认为产出看起来相当不错 
And I think the output looks pretty good.

1504
01:15:32,270 --> 01:15:34,490
从语法上看 这与预期不谋而合 
It looks as expected grammatically.

1505
01:15:34,490 --> 01:15:37,283
不过 现在让我继续 再玩一次这个游戏 
Let me now go ahead, though, and play this game again.

1506
01:15:37,283 --> 01:15:39,200
但这一次 也许是因为我没在想 
But this time, maybe because I'm not thinking,

1507
01:15:39,200 --> 01:15:41,600
或者我只是习惯了先用姓氏逗号 
or I'm just in the habit of doing last name comma first,

1508
01:15:41,600 --> 01:15:44,700
我执行马兰、逗号、大卫 然后按回车键 
I do Malan, comma, David, and hit Enter.

1509
01:15:44,700 --> 01:15:45,200
好的 
All right.

1510
01:15:45,200 --> 01:15:47,270
好吧 现在这太奇怪了 
Well, this now is weird.

1511
01:15:47,270 --> 01:15:51,020
即使程序只是吐出我输入的内容 
Even though the program is just spitting out exactly what I typed in,

1512
01:15:51,020 --> 01:15:54,020
可以说 这并不接近正确 至少在语法上是这样 
arguably this is not close to correct, at least grammatically.

1513
01:15:54,020 --> 01:15:56,810
它真的应该说“你好 大卫·马兰 ”
It should really say "hello, David Malan."

1514
01:15:56,810 --> 01:15:58,820
现在 也许我可以有一些如果条件
Now, maybe I could have some if conditions

1515
01:15:58,820 --> 01:16:01,910
如果用户输入逗号 我可以拒绝用户的输入
and I could just reject the user's input if they type a comma

1516
01:16:01,910 --> 01:16:03,800
或者以某种方式把他们的名字倒过来 
or get their names backwards somehow.

1517
01:16:03,800 --> 01:16:07,190
但如果用户已经有了 那就太少了 太迟了
But that's going to be too little too late if the user has already

1518
01:16:07,190 --> 01:16:10,580
在网上提交了一份表格 我已经有了数据 
submitted a form online, and I already have the data,

1519
01:16:10,580 --> 01:16:12,600
现在我要进去把它清理干净 
and now I need to go in and clean it up.

1520
01:16:12,600 --> 01:16:14,750
而且手动检查也不会很有趣
And it's not going to be fun to go through manually

1521
01:16:14,750 --> 01:16:17,900
在Google电子表格、Apple Numbers或Microsoft Excel中
in Google Spreadsheets, or Apple Numbers, or Microsoft Excel

1522
01:16:17,900 --> 01:16:21,650
并手动修改许多人的名字以去掉逗号
and manually fix a lot of people's names to get rid of the commas

1523
01:16:21,650 --> 01:16:25,700
按照美国的惯例 把名字移到最后一个名字之前 
and move the first name before the last, as is conventional in the US.

1524
01:16:25,700 --> 01:16:27,080
那就让我们开始吧 
So let's do this.

1525
01:16:27,080 --> 01:16:29,780
它可能有点脆弱 但让我们开始
It could be a little fragile, but let's start

1526
01:16:29,780 --> 01:16:32,990
在这里以编程的方式来表达我们自己 并提出这个问题 
to express ourselves a little programmatically here and ask this.

1527
01:16:32,990 --> 01:16:37,940
如果这个人的名字里有一个逗号 这是毕多德式的--
If there is a comma in the person's name, which is Pythonic--

1528
01:16:37,940 --> 01:16:41,960
我只是在问 这根更短的绳子是不是在这根更长的绳子上？
I'm just asking the question, is this shorter string in this longer string?--

1529
01:16:41,960 --> 01:16:43,650
那就让我继续做这件事 
then let me go ahead and do this.

1530
01:16:43,650 --> 01:16:46,340
让我们继续在变量中获取该名称 
Let me go ahead and grab that name in the variable,

1531
01:16:46,340 --> 01:16:50,840
不仅在逗号上拆分 还在后面的空格上拆分 
split on not just the comma but the space after,

1532
01:16:50,840 --> 01:16:53,480
假设人类在他们的名字后面输入了一个空格 
assuming the human typed in a space after their name.

1533
01:16:53,480 --> 01:16:57,080
让我继续存储拆分Malan、逗号、
And let me go ahead and store the result of that splitting of Malan, comma,

1534
01:16:57,080 --> 01:16:58,860
大卫分为两个变量 
David into two variables.

1535
01:16:58,860 --> 01:17:02,000
让我们最后做一次 逗号 首先 再打开包装
Let's do last, comma, first, again unpacking

1536
01:17:02,000 --> 01:17:04,310
返回的值序列 
the sequence of values that comes back.

1537
01:17:04,310 --> 01:17:07,170
现在让我继续并重新设置名称的格式 
Now let me go ahead and reformat the name.

1538
01:17:07,170 --> 01:17:10,160
因此 我将强制将用户名更改为我所期望的名称 
So I'm going to forcibly change the user's name to be as I expect.

1539
01:17:10,160 --> 01:17:13,580
因此名称实际上将是这样的格式字符串--
So name is actually going to be this format string--

1540
01:17:13,580 --> 01:17:18,830
先是名 然后是姓 两者都用大括号括起来 但格式在一起
first name then last name, both in curly braces but formatted together

1541
01:17:18,830 --> 01:17:22,580
只有一个空格 所以我会覆盖用户的输入
with a single space, so that I'm overwriting the user's input

1542
01:17:22,580 --> 01:17:25,280
并相应地更新我的名字变量 
and updating my name variable accordingly.

1543
01:17:25,280 --> 01:17:27,770
目前 需要明确的是 这个项目是互动的 
For the moment, to be clear, this program is interactive.

1544
01:17:27,770 --> 01:17:31,250
就像 用户 像我一样 在程序中输入他们的名字 
Like, the users, like me, are typing their name into the program.

1545
01:17:31,250 --> 01:17:34,340
但是假设数据已经在CSV文件中 
But imagine the data already is in a CSV file.

1546
01:17:34,340 --> 01:17:37,730
它来自某个过程 比如谷歌表格或其他在线工具 
It came in from some process like a Google Form or something else online.

1547
01:17:37,730 --> 01:17:40,370
您可以想象编写类似于下面这样的代码 
You could imagine writing code similar to this,

1548
01:17:40,370 --> 01:17:43,550
但它可能会先将该文件读入内存 
but that maybe goes and reads that file into memory first.

1549
01:17:43,550 --> 01:17:46,640
也许它是通过CSV阅读器或DictReader的CSV 
Maybe it's a CSV via CSV Reader or DictReader,

1550
01:17:46,640 --> 01:17:48,860
然后对每一个名字进行迭代 
and then iterating over each of those names.

1551
01:17:48,860 --> 01:17:51,630
但我们会保持简单 一次只做一个名字 
But we'll keep it simple and just do one name at a time.

1552
01:17:51,630 --> 01:17:55,070
但现在有趣的是 如果我回到我的终端窗口
But now what's kind of interesting here is if I go back to my terminal window

1553
01:17:55,070 --> 01:17:57,940
并将其清除 然后运行格式为.py的python 
and clear it, and run python of format.py,

1554
01:17:57,940 --> 01:18:01,240
然后按Enter键 我将像以前一样输入David space Malan 
and hit Enter, I'm going to type in David, space, Malan as before.

1555
01:18:01,240 --> 01:18:03,130
我觉得我们还是不错的 
And I think we're still good.

1556
01:18:03,130 --> 01:18:05,290
但我也要继续这样做--
But I'm also going to go ahead and do this--

1557
01:18:05,290 --> 01:18:10,630
格式为.py Malan、逗号、David的巨蟒 中间有空格 
python of format.py Malan, comma, David, with a space in between,

1558
01:18:10,630 --> 01:18:13,960
祈祷我的手指并按回车键 瞧 
crossing my fingers and hit Enter, and voila.

1559
01:18:13,960 --> 01:18:15,640
现在 这一点已经得到解决 
That now has been fixed.

1560
01:18:15,640 --> 01:18:18,400
可以肯定的是 这是一件非常简单的事情 
Such a simple thing to be sure.

1561
01:18:18,400 --> 01:18:22,300
但清理用户输入是如此普遍的必要 
But it is so commonly necessary to clean up users input.

1562
01:18:22,300 --> 01:18:25,870
在这里 我们至少看到了一种非常容易做到这一点的方法 
Here we see at least one way to do so pretty easily.

1563
01:18:25,870 --> 01:18:28,480
现在 公平地说 这里有一些问题 
Now, to be fair, there's some problems here.

1564
01:18:28,480 --> 01:18:32,500
事实上 有人能想象这样一种场景吗？在这种情况下 
And in fact, can someone imagine a scenario in which this code really

1565
01:18:32,500 --> 01:18:34,570
不能修复用户的输入？
doesn't fix the user's input?

1566
01:18:34,570 --> 01:18:39,760
即使在我的代码中修复了这个问题 还会出什么问题？
What could still go wrong even with this fix in my code?

1567
01:18:39,760 --> 01:18:40,810
有什么想法吗？
Any thoughts?

1568
01:18:40,810 --> 01:18:44,322
观众：如果他们输入他们的名字逗号 然后[INAUDIBLE]..
AUDIENCE: If they typed in their name comma and then [INAUDIBLE]..

1569
01:18:44,322 --> 01:18:46,030
大卫·马兰：哦 还有一件事 
DAVID MALAN: Oh, and then something else.

1570
01:18:46,030 --> 01:18:46,530
嗯 
Yeah.

1571
01:18:46,530 --> 01:18:48,730
举个例子 让我试试这个 
So let me try this, for instance.

1572
01:18:48,730 --> 01:18:50,410
让我继续运行一个程序 
Let me go ahead and run a program.

1573
01:18:50,410 --> 01:18:53,350
我是我认识的唯一的大卫·马兰 
And I am the only David Malan that I know.

1574
01:18:53,350 --> 01:18:57,850
但假设我是 比如说 像这样的初级学生 
But suppose I were, let's say, junior like this.

1575
01:18:57,850 --> 01:19:00,850
而且 至少在英语中 有时在那里加一个逗号是很常见的 
And it's common, in English at least, to sometimes put a comma there.

1576
01:19:00,850 --> 01:19:02,350
你不一定需要逗号 但我
You don't necessarily need the comma, but I'm

1577
01:19:02,350 --> 01:19:04,120
那些使用逗号的人中的一个 
one of those people who uses a comma.

1578
01:19:04,120 --> 01:19:06,730
那现在真的 真的坏了 
That's now really, really broken.

1579
01:19:06,730 --> 01:19:08,830
所以我打破了一些假设 
So I've broken some assumption there.

1580
01:19:08,830 --> 01:19:10,970
因此 这在这里肯定会出问题 
And so that could certainly go wrong here.

1581
01:19:10,970 --> 01:19:11,470
还有什么？
What else?

1582
01:19:11,470 --> 01:19:13,178
好吧 让我继续 再运行一次 
Well, let me go ahead and run this again.

1583
01:19:13,178 --> 01:19:15,540
如果我用马兰 逗号 大卫 没有空格 
And if I did Malan, comma, David, no space,

1584
01:19:15,540 --> 01:19:17,290
因为我有点草率 我没有
because I'm being a little sloppy, I'm not

1585
01:19:17,290 --> 01:19:20,500
注意 当你有很多用户时 就会发生这种情况
paying attention, which is going to happen when you have lots of users

1586
01:19:20,500 --> 01:19:22,750
最终 好吧 这件事现在真的坏了 
ultimately, well, this really broke now.

1587
01:19:22,750 --> 01:19:25,870
注意 我有一个ValueError 这是一个实际的异常 
Notice I have a ValueError, an actual exception.

1588
01:19:25,870 --> 01:19:26,410
为什么？
Why?

1589
01:19:26,410 --> 01:19:31,330
因为Split应该将字符串分割成两个字符串
Well, because split is supposed to be splitting the string into two strings

1590
01:19:31,330 --> 01:19:34,000
通过寻找逗号和空格 
by looking for the comma and a space.

1591
01:19:34,000 --> 01:19:37,720
但如果没有逗号和空格 它就不能将其分成两部分 
But if there is no comma and space, it can't split it into two things.

1592
01:19:37,720 --> 01:19:40,900
事实上 左边有两个变量 
And the fact that I have two variables on the left,

1593
01:19:40,900 --> 01:19:44,290
但我只能拿回右边的一样东西 
but I'm only getting back one thing on the right,

1594
01:19:44,290 --> 01:19:47,030
这意味着我不能像这样做这段代码 
means that I can't do this code quite as this.

1595
01:19:47,030 --> 01:19:48,467
因此 可以肯定的是 它是脆弱的 
So it's fragile to be sure.

1596
01:19:48,467 --> 01:19:50,800
但是 如果我们至少能改进它 那不是很好吗？
But wouldn't it be nice if we could at least improve it?

1597
01:19:50,800 --> 01:19:53,710
例如 我们现在知道一些正则表达式语法 
For instance, we now know some regular expressions syntax.

1598
01:19:53,710 --> 01:19:56,920
如果我至少想让这个空间成为可选空间呢？
What if I at least wanted to make this space optional?

1599
01:19:56,920 --> 01:20:00,010
嗯 我可以使用我新发现的正则表达式语法
Well, I could use my newfound regular expression syntax

1600
01:20:00,010 --> 01:20:04,330
然后打个问号 问号的意思是零或一件事
and put a question mark, Question mark means zero or one of the things

1601
01:20:04,330 --> 01:20:05,080
往左走 
to the left.

1602
01:20:05,080 --> 01:20:06,490
左边的是什么？
What's the thing to the left?

1603
01:20:06,490 --> 01:20:07,850
从字面上看 这是一个空间 
It's literally a space.

1604
01:20:07,850 --> 01:20:10,760
如果只有一样东西 我甚至不需要括号 
I don't even need parentheses if there's just one thing there.

1605
01:20:10,760 --> 01:20:15,040
所以这将是一个模式的开始 它说 我必须有一个逗号 
So that would be the start of a pattern that says, I must have a comma,

1606
01:20:15,040 --> 01:20:19,240
然后我可能有一个空格 也可能没有空格 之后是零个空格或一个空格 
and then I may or may not have a space, zero or one spaces thereafter.

1607
01:20:19,240 --> 01:20:25,810
不幸的是 内置到str变量中的Split版本 
Unfortunately, the version of split that's built into the str variable,

1608
01:20:25,810 --> 01:20:28,600
如本例所示 不支持正则表达式 
as in this case, doesn't support regular expressions.

1609
01:20:28,600 --> 01:20:32,120
如果我们想要我们的正则表达式 我们需要在这里使用该库 
If we want our regular expressions, we need to go use that library here.

1610
01:20:32,120 --> 01:20:33,650
所以让我继续做这件事 
So let me go ahead and do this.

1611
01:20:33,650 --> 01:20:37,550
让我进去 让这个代码保持原样 但要放在最上面
Let me go in and leave this code as is but go up to the top

1612
01:20:37,550 --> 01:20:41,650
现在 导入re以导入正则表达式的库 
now and import re to import the library for regular expressions.

1613
01:20:41,650 --> 01:20:46,000
现在让我继续 开始改变我的方法 
And now let me go ahead and start changing my approach here.

1614
01:20:46,000 --> 01:20:47,630
我要继续做这件事 
I'm going to go ahead and do this.

1615
01:20:47,630 --> 01:20:50,890
我将使用名为re.earch的相同函数 
I'm going to use the same function called re.search,

1616
01:20:50,890 --> 01:20:54,370
我要去寻找一种模式
and I'm going to search for a pattern that I

1617
01:20:54,370 --> 01:20:56,650
思考将是最后的 逗号 首先 
think will be last, comma, first.

1618
01:20:56,650 --> 01:20:59,050
因此 让我使用我新发现的正则表达式语法
So let me use my newfound regular expression syntax

1619
01:20:59,050 --> 01:21:04,390
代表一种模式 如马兰、逗号、空格、大卫 
and represent a pattern for something like Malan, comma, space, David.

1620
01:21:04,390 --> 01:21:05,660
我怎么能这样做呢？
How can I do this?

1621
01:21:05,660 --> 01:21:10,570
好吧 在我对re.earch的引用中 我会有一些东西--
Well, inside of my quotes for re.search, I'm going to have something--

1622
01:21:10,570 --> 01:21:11,950
所以点+--
so dot +--

1623
01:21:11,950 --> 01:21:12,610
抱歉的 
sorry.

1624
01:21:12,610 --> 01:21:14,980
我要吃点东西 所以点+ 
I'm going to have something, so dot +.

1625
01:21:14,980 --> 01:21:16,540
然后我会有一个逗号 
Then I'm going to have a comma.

1626
01:21:16,540 --> 01:21:17,890
然后我会有一个空间 
Then I'm going to have a space.

1627
01:21:17,890 --> 01:21:20,440
然后我要点+的东西 
Then I'm going to have something dot +.

1628
01:21:20,440 --> 01:21:23,200
现在 我将先发制人地改进一下这一点 
Now I'm going to preemptively refine this a little bit.

1629
01:21:23,200 --> 01:21:25,288
我想让这整个模式开始匹配
I want this whole pattern to start matching

1630
01:21:25,288 --> 01:21:26,830
在用户输入的开始处 
at the beginning of the user's input.

1631
01:21:26,830 --> 01:21:28,960
所以我现在要把^加起来 
So I'm going to add the ^ right away.

1632
01:21:28,960 --> 01:21:33,070
我还希望用户输入的末尾也匹配 这样我就
And I want the end of the user's input to be matched as well, so that I'm

1633
01:21:33,070 --> 01:21:37,720
从字面上看 任何字符都需要一次或多次 然后是逗号 然后是空格 
literally expecting any character one or more times, then a comma then a space,

1634
01:21:37,720 --> 01:21:40,180
然后是任何其他字符一次或多次 
then any other character one or more times.

1635
01:21:40,180 --> 01:21:42,280
然后就是这样了 
And then that is it.

1636
01:21:42,280 --> 01:21:46,430
我将像以前一样传递name变量 
And I'm going to pass in the name variable as before.

1637
01:21:46,430 --> 01:21:50,300
现在 当我们在过去使用re.earch时 
Now, when we've used re.search in the past,

1638
01:21:50,300 --> 01:21:52,900
我们真的只是用它来回答一个问题 
we really used it just to answer a question.

1639
01:21:52,900 --> 01:21:57,040
用户的输入是否与以下模式匹配 
Does the user's input match the following pattern or not,

1640
01:21:57,040 --> 01:21:59,140
对或错 有效地 
true or false, effectively.

1641
01:21:59,140 --> 01:22:02,600
但re.search实际上比这更强大 
But re.search is actually more powerful than that.

1642
01:22:02,600 --> 01:22:05,110
你实际上可以得到更多的信息 
You can actually get back more information.

1643
01:22:05,110 --> 01:22:06,430
你可以做到这一点 
And you can do this.

1644
01:22:06,430 --> 01:22:10,000
您可以指定一个变量 然后指定一个赋值运算符 
You can specify a variable and then an assignment operator,

1645
01:22:10,000 --> 01:22:15,250
并在搜索时得到关于所发现内容的更准确的答案 
and get back more precise answers to what has been found when searched for.

1646
01:22:15,250 --> 01:22:17,500
但你想要拿回什么呢？
But what is it you want to get back?

1647
01:22:17,500 --> 01:22:21,260
事实证明 正则表达式还有另一个特性
Well, it turns out there's this other feature of regular expressions

1648
01:22:21,260 --> 01:22:25,330
它允许你使用括号 而不仅仅是把东西组合在一起 
which allow you to use parentheses, not just to group things together,

1649
01:22:25,330 --> 01:22:27,070
而是为了抓住他们 
but to capture them.

1650
01:22:27,070 --> 01:22:31,750
结果是 当您在正则表达式中指定括号时
It turns out when you specify parentheses in a regular expression

1651
01:22:31,750 --> 01:22:35,140
到目前为止我们还不知道 括号里的一切
unbeknownst to us up until now, everything in the parentheses

1652
01:22:35,140 --> 01:22:41,350
将作为re.earch函数的返回值返回给您 
will be returned to you as a return value from the re.search function.

1653
01:22:41,350 --> 01:22:45,700
它将允许你提取特定数量的信息
It's going to allow you to extract specific amounts of information

1654
01:22:45,700 --> 01:22:47,530
来自用户自己的输入 
from the user's own input.

1655
01:22:47,530 --> 01:22:51,730
您也可以通过使用非捕获版本来逆转此过程
You can reverse this process, too, by using the non-capturing version

1656
01:22:51,730 --> 01:22:52,340
也是 
as well.

1657
01:22:52,340 --> 01:22:55,507
你可以使用圆括号 然后是一个问号和一个冒号 
You can use parentheses, and then literally a question mark, and a colon,

1658
01:22:55,507 --> 01:22:56,590
然后还有一些其他的东西 
and then some other stuff.

1659
01:22:56,590 --> 01:22:58,400
也就是说 不要捕捉到这一点 
And that will say, don't either capturing this.

1660
01:22:58,400 --> 01:22:59,567
我只是想把东西组合起来 
I just want to group things.

1661
01:22:59,567 --> 01:23:02,850
但现在 我们将只使用括号本身 
But for now, we're going to use just the parentheses themselves.

1662
01:23:02,850 --> 01:23:04,200
那么我该怎么做呢？
So how am I going to do this?

1663
01:23:04,200 --> 01:23:08,780
好吧 如果我想拿回用户的姓和名 
Well, if I want to get back the user's last name and first name,

1664
01:23:08,780 --> 01:23:16,190
我想我要捕捉的是这里的点+和这里的点+ 
I think what I want to capture is the dot + here and the dot + here.

1665
01:23:16,190 --> 01:23:19,190
所以我特意用括号括起来
So I've deliberately surrounded in parentheses

1666
01:23:19,190 --> 01:23:22,160
逗号左右两边的点+ 
the dot + both to the left and the right of the comma,

1667
01:23:22,160 --> 01:23:24,660
不是因为我把它们归类在一起--
not because I'm grouping them together per se--

1668
01:23:24,660 --> 01:23:28,190
我没有加问号 我没有加另一个+或*--
I'm not adding a question mark, I'm not adding up another + or a *--

1669
01:23:28,190 --> 01:23:32,420
我现在使用圆括号来进行捕获 
I'm using parentheses now for capturing purposes.

1670
01:23:32,420 --> 01:23:33,200
为什么？
Why?

1671
01:23:33,200 --> 01:23:34,820
好的 接下来我要做这个 
Well, I'm going to do this next.

1672
01:23:34,820 --> 01:23:38,690
我仍然会问一个布尔问题 比如 “如果有匹配的话 
I'm going to still ask a Boolean question like, "if there are matches,

1673
01:23:38,690 --> 01:23:40,320
那就这样做吧 
then do this."

1674
01:23:40,320 --> 01:23:44,360
因此 如果匹配不是有效的假 就像没有匹配 
So if matches is not effectively false, like none,

1675
01:23:44,360 --> 01:23:47,720
我希望我能拿回几根火柴 
I do expect I've gotten back some matches.

1676
01:23:47,720 --> 01:23:49,400
看看我现在能做什么 
And watch what I can do now.

1677
01:23:49,400 --> 01:23:54,170
我可以做最后一个 逗号 第一个等于
I can do last, comma, first equals whatever matches in

1678
01:23:54,170 --> 01:23:56,930
并取回所有的火柴组 
and get back all of the groups of matches.

1679
01:23:56,930 --> 01:24:00,020
然后继续使用格式字符串更新名称 就像前面一样
Then go ahead and update name just like before with a format string

1680
01:24:00,020 --> 01:24:03,770
先做 然后用大括号做最后一次
and do first and then last in curly braces

1681
01:24:03,770 --> 01:24:06,770
同样 然后在最底部 就像以前一样 打印出来 
as well, and then at the very bottom, just like before, print out,

1682
01:24:06,770 --> 01:24:09,830
例如 “你好”、“逗号”、“名字” 
for instance, "hello," comma, "name."

1683
01:24:09,830 --> 01:24:13,970
因此 新代码现在是这里突出显示的所有内容 
So the new code now is everything highlighted here.

1684
01:24:13,970 --> 01:24:19,700
我使用re.earch来搜索用户是否输入了他们的名字
I'm using re.search to search for whether the user typed their name

1685
01:24:19,700 --> 01:24:21,620
最后 逗号 第一种格式 
in last, comma, first format.

1686
01:24:21,620 --> 01:24:27,440
但我更强大的是使用re.earch来捕获用户的一些输入 
But I am more powerfully using re.search to capture some of the user's input.

1687
01:24:27,440 --> 01:24:28,850
什么会被抓获？
What's going to get captured?

1688
01:24:28,850 --> 01:24:31,400
我用括号括起来的任何东西都会
Anything I surrounded in parentheses will

1689
01:24:31,400 --> 01:24:34,250
作为返回值返回给我 
be returned to me as return values.

1690
01:24:34,250 --> 01:24:36,650
如何获得这些返回值？
How do you get at those return values?

1691
01:24:36,650 --> 01:24:40,490
你问你为所有组赋值的变量 
You ask the variable to which you assign them for all of the groups,

1692
01:24:40,490 --> 01:24:44,250
捕获的所有括号组 
all of the groups of parentheses that were captured.

1693
01:24:44,250 --> 01:24:46,020
所以让我继续做这件事 
So let me go ahead and do this.

1694
01:24:46,020 --> 01:24:49,970
现在让我继续运行格式为.py的python 回车 
Let me go ahead now and run python of format.py, Enter.

1695
01:24:49,970 --> 01:24:51,950
我要像往常一样输入我的名字 
And I'm going to type my name as usual.

1696
01:24:51,950 --> 01:24:56,900
在本例中 此If条件不会发生任何事情 
In this case, nothing happens with this if condition.

1697
01:24:56,900 --> 01:24:57,500
为什么？
Why?

1698
01:24:57,500 --> 01:25:03,270
因为我没有键入逗号 所以此搜索没有找到逗号 
Because I did not type a comma, and so this search does not find a comma,

1699
01:25:03,270 --> 01:25:04,632
所以没有火柴 
so there are no matches.

1700
01:25:04,632 --> 01:25:06,590
所以我们立刻打印出“你好 名字” 
So we immediately just print out "hello, name."

1701
01:25:06,590 --> 01:25:08,370
那里没有什么有趣或新鲜的东西 
Nothing interesting or new there.

1702
01:25:08,370 --> 01:25:12,920
但如果我现在继续 并清除屏幕 并运行格式为.py的python 
But if I now go ahead, and clear my screen, and run python of format.py,

1703
01:25:12,920 --> 01:25:18,740
然后做马兰语 逗号 空格 大卫 回车 我们重新格式化了我的名字 
and do Malan, comma, space, David, Enter, we've reformatted my name.

1704
01:25:18,740 --> 01:25:19,940
好吧 这是怎么回事？
Well, how did this work?

1705
01:25:19,940 --> 01:25:22,100
现在让我说得更清楚一些 
Let me be a little more explicit now.

1706
01:25:22,100 --> 01:25:24,560
事实证明 我不需要只说匹配 团体 
It turns out I don't have to just say matches.groups.

1707
01:25:24,560 --> 01:25:28,020
我可以让我想要的特定群体回来 
I can get specific groups back that I want.

1708
01:25:28,020 --> 01:25:30,290
所以让我稍微修改一下我的代码 
So let me change my code a little bit more.

1709
01:25:30,290 --> 01:25:33,470
让我现在继续 只说这一点 
Let me go ahead now and just say this.

1710
01:25:33,470 --> 01:25:36,620
让我们将名字更新为--
Let's update name to--

1711
01:25:36,620 --> 01:25:37,980
实际上 让我们开始吧 
actually, let's do this.

1712
01:25:37,980 --> 01:25:42,530
假设最后一个名字将出现在比赛中
Let's say that the last name is going to be in the matches

1713
01:25:42,530 --> 01:25:44,330
但具体来说是第一组 
but specifically group 1.

1714
01:25:44,330 --> 01:25:48,020
第一个名字将出现在比赛中 但特别是第二组 
The first name is going to be in the matches but specifically group 2.

1715
01:25:48,020 --> 01:25:49,100
为什么是1和2？
Why 1 and 2?

1716
01:25:49,100 --> 01:25:52,490
因为这是逗号左边的第一组括号 
Because this is the first set of parentheses to the left of the comma.

1717
01:25:52,490 --> 01:25:55,520
这是逗号右侧的第二组括号 
This is the second set of parentheses to the right of the comma.

1718
01:25:55,520 --> 01:25:58,700
根据输入 这将是用户的姓氏
And based on the input, this would be the user's last name

1719
01:25:58,700 --> 01:26:00,140
在这种情况下 马兰 
in this scenario, Malan.

1720
01:26:00,140 --> 01:26:03,560
在此场景中 这将是用户的名字David 
This would be the user's first name, David, in this scenario.

1721
01:26:03,560 --> 01:26:07,340
这就是我使用组1作为姓氏的原因
That's why I'm using group 1 for the last name

1722
01:26:07,340 --> 01:26:09,720
名为组2 
and group 2 for the first name.

1723
01:26:09,720 --> 01:26:16,100
现在我要继续说名字等于fstring 再一次 首先
And now I'm going to go ahead and say name equals fstring, again, first

1724
01:26:16,100 --> 01:26:18,980
然后 最后 完成 
and then last, done.

1725
01:26:18,980 --> 01:26:23,340
在我们回答问题之前 让我来完善这最后一步 
And let me refine this one last step before we take questions.

1726
01:26:23,340 --> 01:26:26,090
如果我立即使用这些变量 我实际上并不需要它们 
I don't really need these variables if I'm immediately using them.

1727
01:26:26,090 --> 01:26:28,423
让我们继续前进 进一步加强这一点 就像我们已经
Let's just go ahead and tighten this up further as we've

1728
01:26:28,423 --> 01:26:29,990
过去是为了设计而做的 
done in the past for design's sake.

1729
01:26:29,990 --> 01:26:32,722
如果我想要将该名称作为串联
If I want to make the name the concatenation

1730
01:26:32,722 --> 01:26:34,430
这个人的名字和姓氏 
of the person's first name and last name,

1731
01:26:34,430 --> 01:26:37,970
我们就这么做吧 匹配 首先是第2组 
let's just do this. matches.group 2 first,

1732
01:26:37,970 --> 01:26:43,400
加一个空格 加火柴 第一组 
plus a space, plus matches.group 1.

1733
01:26:43,400 --> 01:26:46,910
所以从左到右由我决定 这是第一组 
So it's just up to me from left to right, this is group 1,

1734
01:26:46,910 --> 01:26:47,630
这是第二组 
this is group 2.

1735
01:26:47,630 --> 01:26:51,000
所以第一组是最后 第二组是第一 
So group 1 is last, group 2 is first.

1736
01:26:51,000 --> 01:26:54,860
因此 如果我想反转它们并更新名称的值 
So if I want to flip them around and update the value of name,

1737
01:26:54,860 --> 01:27:00,290
我可以首先显式地获取组2 使用+、单个空格
I can explicitly get group 2 first, concatenate using +, a single space,

1738
01:27:00,290 --> 01:27:03,540
然后在组1上串连 
and then concatenate on group 1.

1739
01:27:03,540 --> 01:27:04,170
好的 
All right.

1740
01:27:04,170 --> 01:27:05,280
那真是太多了 
That was a lot.

1741
01:27:05,280 --> 01:27:07,620
让我暂停一下 看看是否有问题 
Let me pause to see if there are questions.

1742
01:27:07,620 --> 01:27:11,670
这里的关键不同之处在于 我们仍然使用完全相同的re.search 
The key difference here is we're still using re.search the exact same way,

1743
01:27:11,670 --> 01:27:15,090
但现在我使用它的返回值 而不仅仅是回答
but now I'm using its return value, not just to answer

1744
01:27:15,090 --> 01:27:17,400
一个问题是对还是错 但实际上
a question true or false, but to actually

1745
01:27:17,400 --> 01:27:21,750
找回我捕捉到的任何匹配的东西 可以这么说 
get back specific matches anything I captured, so to speak,

1746
01:27:21,750 --> 01:27:23,190
加上圆括号 
with parentheses.

1747
01:27:23,190 --> 01:27:26,270
观众：为什么我们用的是1和2而不是0和1
AUDIENCE: Why is it here we're using 1 and 2 instead of 0 and 1

1748
01:27:26,270 --> 01:27:27,270
因为抓到了第一个？
for capturing the first?

1749
01:27:27,270 --> 01:27:29,010
大卫·马兰：这个问题问得很好 
DAVID MALAN: Really good question.

1750
01:27:29,010 --> 01:27:30,060
观察得很好 
A good observation.

1751
01:27:30,060 --> 01:27:32,070
在几乎所有其他背景下 我们已经开始
In almost every other context, we've started

1752
01:27:32,070 --> 01:27:35,250
数到0和1 而不是1和2 
counting at 0 and 1 instead of 1 and 2.

1753
01:27:35,250 --> 01:27:38,190
原来在0号位置还有其他东西
It turns out there's something else in location 0

1754
01:27:38,190 --> 01:27:41,530
当它从re.earch返回时 它与字符串本身相关 
when it comes back from re.search related to the string itself.

1755
01:27:41,530 --> 01:27:45,000
因此 仅根据此函数的文档 
So according to the documentation of this function only,

1756
01:27:45,000 --> 01:27:49,110
1是第一组括号 2是第二组括号 
1 is the first set of parentheses, and 2 is the second set,

1757
01:27:49,110 --> 01:27:50,460
从那以后 
and onward from there.

1758
01:27:50,460 --> 01:27:52,540
只是这里有一个不同的会议 
Just a different convention here.

1759
01:27:52,540 --> 01:27:53,580
还有其他问题吗？
Other questions?

1760
01:27:53,580 --> 01:27:59,820
观众：如果我们什么都不写呢 比如空格、逗号、空格？
AUDIENCE: What if we write nothing, like whitespace, comma, whitespace?

1761
01:27:59,820 --> 01:28:03,317
我们如何检查条件的真实性？
How do we check truth of condition?

1762
01:28:03,317 --> 01:28:05,400
David Malan：在我直接回答之前 让我
DAVID MALAN: Before I answer directly, let me just

1763
01:28:05,400 --> 01:28:07,733
运行这个 并确保我没有进一步打破任何东西 
run this and make sure I've not broken anything further.

1764
01:28:07,733 --> 01:28:09,360
让我运行格式为.py的python 
Let me run python of format.py.

1765
01:28:09,360 --> 01:28:12,060
让我以正确的方式输入大卫、空格、马兰 
Let me type in David, space, Malan, the right way.

1766
01:28:12,060 --> 01:28:13,200
让我再运行一次 
Let me run it once more.

1767
01:28:13,200 --> 01:28:16,650
让我输入Malan 逗号 David 这是我们正在修复的错误方式 
Let me type in Malan, comma, David, the wrong way that we're fixing.

1768
01:28:16,650 --> 01:28:17,850
我们还是很棒的 
And we're still good.

1769
01:28:17,850 --> 01:28:19,410
但我认为它还是会破裂的 
But I think it will still break.

1770
01:28:19,410 --> 01:28:23,610
让我用马兰 逗号 大卫第三次运行它 没有空格 
Let me run it a third time with Malan, comma, David with no space.

1771
01:28:23,610 --> 01:28:26,190
现在它还是坏了 
And now it's still broken.

1772
01:28:26,190 --> 01:28:26,790
为什么？
Why?

1773
01:28:26,790 --> 01:28:30,930
因为我还在找逗号空格 
Because I'm still looking for comma space.

1774
01:28:30,930 --> 01:28:32,220
现在 我怎么才能解决这个问题呢？
Now, how can I fix that?

1775
01:28:32,220 --> 01:28:35,070
我可以这样做的一种方法是在这里加一个问号 这又一次 
One way I could do that is to add a question mark here, which again,

1776
01:28:35,070 --> 01:28:37,510
是零个或多个以前的东西 
is zero or more of the thing before.

1777
01:28:37,510 --> 01:28:40,950
所以如果我有一个空格 然后是一个问号 不需要任何
So if I have a space and then a question mark literally, no need for any

1778
01:28:40,950 --> 01:28:46,290
括号 那么我完全可以容忍马兰语、逗号、空格、
parentheses, then I can literally tolerate both Malan, comma, space,

1779
01:28:46,290 --> 01:28:48,610
大卫或马兰 逗号 大卫 
David or Malan, comma, David.

1780
01:28:48,610 --> 01:28:49,680
所以让我们再试一次 
So let's try again.

1781
01:28:49,680 --> 01:28:51,120
以前 这是行不通的 
Before, this did not work.

1782
01:28:51,120 --> 01:28:53,310
让我们做马兰 逗号 大卫 没有空格 
Let's do Malan, comma, David with no space.

1783
01:28:53,310 --> 01:28:55,990
现在它确实起作用了 
Now it does actually work.

1784
01:28:55,990 --> 01:28:58,740
所以我们可以容忍不同数量的空格
So we can tolerate different amounts of whitespace

1785
01:28:58,740 --> 01:29:01,890
如果我用我的公式更精确一点的话 
if I am a little more precise with my formula.

1786
01:29:01,890 --> 01:29:03,420
让我继续 再试一次 
Let me go ahead and try once more.

1787
01:29:03,420 --> 01:29:07,260
让我很奇怪 但可能会按空格键太多次
Let me very weirdly but possibly hit the space bar a few too many times

1788
01:29:07,260 --> 01:29:08,850
所以现在他们真的分开了 
so now they're really separated.

1789
01:29:08,850 --> 01:29:13,020
这又一次不会有很好的效果 因为它
This, again, is not going to work quite right, because it's going

1790
01:29:13,020 --> 01:29:15,160
来消耗所有的空格 
to consume all of that whitespace.

1791
01:29:15,160 --> 01:29:18,420
所以现在我可能想要脱光衣服 左右 任何
So now I might want to strip, left and right, any

1792
01:29:18,420 --> 01:29:21,720
结果上的前导空格 或者我能在这里做些什么
of the leading white space on the result. Or what I could do here

1793
01:29:21,720 --> 01:29:22,930
就是这么说 
is say this.

1794
01:29:22,930 --> 01:29:29,670
我可以在这里使用* 所以空格* 而不是0或1 
Instead of zero or one, I could use a * here, so space *.

1795
01:29:29,670 --> 01:29:33,000
现在如果我用马兰、逗号、空格再运行一次 
And now if I run this once more with Malan, comma, space, space, space,

1796
01:29:33,000 --> 01:29:35,920
大卫 进来 现在我们已经把东西收拾得更干净了 
David, Enter, now we've cleaned up things further.

1797
01:29:35,920 --> 01:29:39,510
所以你可以想象 取决于你的数据有多混乱
So you can imagine, depending on how messy the data is that you're

1798
01:29:39,510 --> 01:29:41,550
清理后 您的正则表达式可能需要
cleaning up, your regular expressions might need

1799
01:29:41,550 --> 01:29:43,500
变得越来越复杂 
to get more and more sophisticated.

1800
01:29:43,500 --> 01:29:46,830
这真的取决于我们想一次解决多少问题 
It really depends on just how many problems we want to solve at once.

1801
01:29:46,830 --> 01:29:51,900
好吧 请允许我提议我们继续前进 只是为了把这件事清理干净
Well, allow me to propose that we forge ahead further just to clean this up

1802
01:29:51,900 --> 01:29:53,940
更重要的是 使用一种实际上
even more so, using a feature that's actually

1803
01:29:53,940 --> 01:29:56,430
对Python本身来说是相对较新的 
relatively new to Python itself.

1804
01:29:56,430 --> 01:29:59,220
这在使用正则表达式时非常常见
It is very common when using regular expressions

1805
01:29:59,220 --> 01:30:03,210
来做我在这里所做的事情--调用一个像re.earch这样的函数
to do exactly what I've done here-- to call a function like re.search

1806
01:30:03,210 --> 01:30:07,300
在里面捕获圆括号 这样您就可以返回一个
with capturing parentheses inside, such that you get back a return

1807
01:30:07,300 --> 01:30:10,050
我称之为匹配的价值--你可以叫它其他的东西 
value that I'm calling matches-- you could call it something else,

1808
01:30:10,050 --> 01:30:12,090
但我默认将其称为匹配 
but I'm calling it by default matches.

1809
01:30:12,090 --> 01:30:15,690
然后注意下一行 我说的是“如果匹配” 
And then notice on the next line, I'm saying "if matches."

1810
01:30:15,690 --> 01:30:19,080
如果我能把事情做得更紧一些 做这些不是很好吗？
Wouldn't it be nice if I could just tighten things up further and do these

1811
01:30:19,080 --> 01:30:20,700
都在同一条线上？
all on the same line?

1812
01:30:20,700 --> 01:30:23,070
嗯 你可以这么说 
Well, you can sort of.

1813
01:30:23,070 --> 01:30:24,850
让我继续做这件事 
Let me go ahead and do this.

1814
01:30:24,850 --> 01:30:26,340
让我把这个If处理掉 
Let me get rid of this if.

1815
01:30:26,340 --> 01:30:28,500
让我试着说这样的话 
And let me just try to say something like this.

1816
01:30:28,500 --> 01:30:32,370
如果匹配等于re.earch 然后是冒号--
If matches equals re.search and then colon--

1817
01:30:32,370 --> 01:30:39,090
因此 将我的if条件合并到一行中 而不是这两行 
so combining my if condition into just one line instead of those two.

1818
01:30:39,090 --> 01:30:43,455
在C、C++或Java中 您实际上会这样做 
In C, or C++, or Java, you would actually do something like this,

1819
01:30:43,455 --> 01:30:45,330
把整件事用括号括起来 
surrounding the whole thing with parentheses,

1820
01:30:45,330 --> 01:30:47,550
有时设置双倍以抑制任何警告 
sometimes double sets to suppress any warnings,

1821
01:30:47,550 --> 01:30:49,980
如果你想同时做两件事 
if you want to do two things at once.

1822
01:30:49,980 --> 01:30:55,530
如果您不仅希望将re.earch的返回值
If you want to not only assign the return value of re.search

1823
01:30:55,530 --> 01:30:58,080
设置为名为Matches的变量 但您希望
to a variable called matches, but you want

1824
01:30:58,080 --> 01:31:03,408
接下来要问一个布尔问题 这实际上是对的还是错的 
to subsequently ask a Boolean question, is this effectively true or false.

1825
01:31:03,408 --> 01:31:04,950
这就是我刚才正在做的 
That's what I was doing a moment ago.

1826
01:31:04,950 --> 01:31:06,060
让我来解开这一切 
Let me undo this.

1827
01:31:06,060 --> 01:31:08,430
刚才 我正在取回返回值
A moment ago, I was getting back the return value

1828
01:31:08,430 --> 01:31:12,090
然后把它分配给火柴 然后我就问了这个问题 
and assigning it to matches, and then I was asking the question.

1829
01:31:12,090 --> 01:31:16,530
好的 结果是这两行代码可能需要擦除
Well, it turns out this need to have two lines of code presumably rubbed

1830
01:31:16,530 --> 01:31:18,840
人们在Python中犯错误的时间太长了 
people wrong for too long in Python.

1831
01:31:18,840 --> 01:31:22,170
所以你现在可以把这两种线结合成一条线 
And so you can now combine these two kinds of lines into one.

1832
01:31:22,170 --> 01:31:24,450
但你需要一个新的接线员 
But you need a new operator.

1833
01:31:24,450 --> 01:31:27,720
你不能只说 “如果匹配等于re.earch”
You cannot just say, "if matches equals re.search"

1834
01:31:27,720 --> 01:31:29,580
然后放在结尾处的冒号里 
and then in a colon at the end.

1835
01:31:29,580 --> 01:31:32,170
相反 您需要这样做 
You instead need to do this.

1836
01:31:32,170 --> 01:31:38,130
如果且仅当您想要赋值某项时 才需要执行冒号等于
You need to do colon equals if and only if you want to assign something

1837
01:31:38,130 --> 01:31:42,390
从右到左 你想问一个if或elif
from right to left and you want to ask an if or an elif

1838
01:31:42,390 --> 01:31:44,820
问题在同一条线上 
question on the same line.

1839
01:31:44,820 --> 01:31:48,870
正如这里所看到的 这被亲切地称为海象操作员 
This is affectionately known, as can see here, as the walrus operator.

1840
01:31:48,870 --> 01:31:51,480
而且这是近几年来对Python来说的新事物 
And it's new to Python in recent years.

1841
01:31:51,480 --> 01:31:56,280
它既允许您像我从右到左所做的那样赋值 
And it both allows you to assign a value as I'm doing from right to left,

1842
01:31:56,280 --> 01:32:00,180
问一个布尔式的问题 就像我
and ask a Boolean question about it, like I'm

1843
01:32:00,180 --> 01:32:02,960
用If或等效的Elif做什么 
doing with the if or equivalently elif.

1844
01:32:02,960 --> 01:32:06,650
有人知道为什么这个叫海象操作员吗？
Does anyone know why this is called the walrus operator?

1845
01:32:06,650 --> 01:32:09,920
如果你这样看它 也许 
If you kind of look at it like this, perhaps,

1846
01:32:09,920 --> 01:32:14,040
如果你熟悉海象 它看起来有点像海象 
if you're familiar with walruses, it kind of sort of looks like a walrus.

1847
01:32:14,040 --> 01:32:17,720
因此 这是一个次要的细节 但相对较新的功能 说实话 您将
So a minor detail but a relatively new feature of Python that honestly, you'll

1848
01:32:17,720 --> 01:32:21,170
可能会继续在网上、源代码和教科书中看到 
probably continue to see online, and in source code, and in textbooks,

1849
01:32:21,170 --> 01:32:24,300
以此类推 现在它确实存在了 越来越多地如此 
and so forth, increasingly so now that it does exist.

1850
01:32:24,300 --> 01:32:25,910
这根本不会改变逻辑 
It does not change the logic at all.

1851
01:32:25,910 --> 01:32:29,660
如果我运行格式为.py的python并输入Malan、逗号、空格、David 
If I run python of format.py and type Malan, comma, space, David,

1852
01:32:29,660 --> 01:32:33,750
它仍然可以修复一些问题 但它只是稍微加强了我的代码 
it still fixes things, but it's tightened up my code just a bit more.

1853
01:32:33,750 --> 01:32:34,250
好的 
All right.

1854
01:32:34,250 --> 01:32:37,010
让我们继续看最后一个问题
Let's go ahead and look at one final problem

1855
01:32:37,010 --> 01:32:40,470
要解决的问题是 现在也要提取信息 
to solve, that of extracting information now as well.

1856
01:32:40,470 --> 01:32:43,460
现在 我们已经验证了用户的输入
So at this point, we've now validated the user's input

1857
01:32:43,460 --> 01:32:46,160
通过检查它是否符合特定的模式 
by checking whether or not it meets a certain pattern.

1858
01:32:46,160 --> 01:32:49,100
我们已经通过检查清理了用户的输入
We've cleaned up the user's input by checking

1859
01:32:49,100 --> 01:32:51,470
根据一个模式 无论它是否匹配 如果它
against a pattern, whether it matches or not, and if it

1860
01:32:51,470 --> 01:32:54,350
确实匹配 我们可以重新组织一些用户的信息
does match, we kind of reorganize some of the user's information

1861
01:32:54,350 --> 01:32:57,800
这样我们就可以清理他们的输入 并标准化我们
so we can clean up their input and standardize the format in which we're

1862
01:32:57,800 --> 01:32:59,540
在这种情况下 存储或打印它 
storing or printing it, in this case.

1863
01:32:59,540 --> 01:33:03,350
让我们来做最后一个例子 其中我们非常明确地提取
Let's do one final example where we're very specifically extracting

1864
01:33:03,350 --> 01:33:06,440
信息 以回答一些问题 
information in order to answer some question.

1865
01:33:06,440 --> 01:33:07,830
因此 让我提出这一点 
So let me propose this.

1866
01:33:07,830 --> 01:33:12,650
让我们继续关闭Format.py并创建一个名为twitter.py的新文件 
Let me go ahead and close format.py and create a new file called twitter.py,

1867
01:33:12,650 --> 01:33:17,690
它的目标是提示用户输入他们的Twitter个人资料的URL
the goal of which is to prompt users for the URL of their Twitter profile

1868
01:33:17,690 --> 01:33:23,562
并从中提取 从该URL推断出用户的用户名 
and extract from it, infer from that URL, what is the user's username.

1869
01:33:23,562 --> 01:33:25,020
现在 你为什么要这么做呢？
Now, why might you want to do this?

1870
01:33:25,020 --> 01:33:28,228
首先 您可能希望用户能够非常轻松地复制和粘贴
Well, one, you might want users to be able to just very easily copy and paste

1871
01:33:28,228 --> 01:33:32,330
从他们自己的Twitter个人资料到您的表单、到您的应用程序的URL 
the URL from their own Twitter profile into your form, into your app,

1872
01:33:32,330 --> 01:33:36,140
这样你就可以知道他们的用户名是什么 
so that you can figure out what their username is.

1873
01:33:36,140 --> 01:33:40,430
或者你可能有一个表单 要求用户输入他们的Twitter用户名 
Or you might have a form that asks the user for their Twitter username,

1874
01:33:40,430 --> 01:33:43,400
因为人们不一定会非常密切地关注 
and because people aren't necessarily paying very close attention,

1875
01:33:43,400 --> 01:33:45,530
有些人会输入他们的用户名 
some people type their username.

1876
01:33:45,530 --> 01:33:49,340
有些人会打出他们的整个URL或其他东西 
Some people type their whole URL or something else altogether.

1877
01:33:49,340 --> 01:33:51,350
现在你是一名程序员 那就太好了
It would be nice now that you're a programmer

1878
01:33:51,350 --> 01:33:53,780
只是更能容忍不同类型的输入
to just be more tolerant of different types of input

1879
01:33:53,780 --> 01:33:58,100
承担起规范化、标准化数据的重担 
and just take on the burden of canonicalizing, standardizing the data,

1880
01:33:58,100 --> 01:34:00,140
而是灵活地对待用户 
but being flexible with the users.

1881
01:34:00,140 --> 01:34:03,500
如果你只是让我复制粘贴 它可以说是更好的用户体验
It's arguably a better user experience if you just let me copy-paste

1882
01:34:03,500 --> 01:34:05,660
或者输入我想要的东西 你就把它清理干净 
or type in what I want, you clean it up.

1883
01:34:05,660 --> 01:34:07,550
你是程序员 不是我 
You're the programmer not me.

1884
01:34:07,550 --> 01:34:09,920
可能会带来更好的体验 
Lends for a better experience, perhaps.

1885
01:34:09,920 --> 01:34:12,620
那么 让我继续使用twitter.py来做这件事 
Well, let me go ahead and do this with twitter.py.

1886
01:34:12,620 --> 01:34:17,120
让我首先在这里提示用户输入变量的值
Let me first go ahead and prompt the user here for a value for a variable

1887
01:34:17,120 --> 01:34:21,702
我会调用url 让他们输入他们Twitter个人资料的URL 
that I'll call url, and just ask them to input the URL of their Twitter profile.

1888
01:34:21,702 --> 01:34:23,660
我要脱掉所有的主角
I'm going to go ahead and strip off any leading

1889
01:34:23,660 --> 01:34:26,810
或尾随空格 以防用户不小心按下空格键 
or trailing whitespace, just in case users accidentally hit the spacebar.

1890
01:34:26,810 --> 01:34:29,940
从字面上说 这是我能很容易做到的最低限度 
That's literally the least I can do quite easily.

1891
01:34:29,940 --> 01:34:32,100
但现在让我们继续做这件事 
But now let's go ahead and do this.

1892
01:34:32,100 --> 01:34:37,185
假设用户的地址如下 
Suppose that the user's address is the following.

1893
01:34:37,185 --> 01:34:38,810
让我把他们输入的内容打印出来 
Let me print out what did they type in.

1894
01:34:38,810 --> 01:34:41,190
让我清空屏幕并运行twitter.py的python 
And let me clear my screen and run python of twitter.py.

1895
01:34:41,190 --> 01:34:43,190
例如 我将继续输入 
I'm going to go ahead and type in, for instance,

1896
01:34:43,190 --> 01:34:50,240
Https://twitter.com/davidjmalan  恰好是我自己的推特用户名 
https://twitter.com/davidjmalan, which happens to be my own Twitter username.

1897
01:34:50,240 --> 01:34:53,090
现在 我们只需将其打印回屏幕
For now, we're just going to print it back onto the screen just

1898
01:34:53,090 --> 01:34:54,640
以确保我还没有搞砸 
to make sure I've not messed up yet.

1899
01:34:54,640 --> 01:34:55,140
好的 
OK.

1900
01:34:55,140 --> 01:34:57,260
所以我打印回了完全相同的URL 
So I've printed back out the exact same URL.

1901
01:34:57,260 --> 01:35:01,310
但手头的目标是只提取用户名 
But the goal at hand is to extract the username only.

1902
01:35:01,310 --> 01:35:05,060
现在 让我问一个直截了当的问题 
Now, let me just ask, perhaps, a straightforward question.

1903
01:35:05,060 --> 01:35:09,830
从逻辑上讲 我需要做什么才能获得用户的用户名？
Logically, what do I need to do to get at the user's username?

1904
01:35:09,830 --> 01:35:13,880
观众：嗯 我们只是忽略用户名之前的内容
AUDIENCE: Well, we just ignore what's before the username

1905
01:35:13,880 --> 01:35:16,065
然后直接提取用户名？
and then just extract the username?

1906
01:35:16,065 --> 01:35:16,940
大卫·马兰：太好了 
DAVID MALAN: Perfect.

1907
01:35:16,940 --> 01:35:18,380
是的 我是说 就这么简单 
Yeah, I mean, it is as simple as that.

1908
01:35:18,380 --> 01:35:20,720
如果您知道用户名在末尾 那么让我们
If you know the username is at the end, well, let's just

1909
01:35:20,720 --> 01:35:22,920
不知何故 从一开始就忽略了一切 
somehow ignore everything to the beginning.

1910
01:35:22,920 --> 01:35:24,170
那么 开头是什么？
Well, what's at the beginning?

1911
01:35:24,170 --> 01:35:25,130
嗯 这是个网址 
Well, it's a URL.

1912
01:35:25,130 --> 01:35:30,890
所以我们可能需要忽略HTTPS a：// twitter.com 
So we're probably going to need to ignore an HTTPS, a ://, a twitter.com,

1913
01:35:30,890 --> 01:35:31,910
和a/ 
and a /.

1914
01:35:31,910 --> 01:35:33,840
所以我们只想把这一切都扔掉 
So we just want to throw all of that away.

1915
01:35:33,840 --> 01:35:34,340
为什么？
Why?

1916
01:35:34,340 --> 01:35:37,400
因为如果它是一个URL 我们可以通过Twitter的工作原理来了解
Because if it's an URL, we know by how Twitter works

1917
01:35:37,400 --> 01:35:39,240
用户名位于末尾 
that the username comes at the end.

1918
01:35:39,240 --> 01:35:43,418
因此 让我们使用这个非常简单的想法来获取我们想要的信息 
So let's use that very simple idea to get at the information we want.

1919
01:35:43,418 --> 01:35:45,210
我将尝试几种不同的方法 
I'm going to try this a few different ways.

1920
01:35:45,210 --> 01:35:46,620
让我在这里回到我的程序 
Let me go back into my program here.

1921
01:35:46,620 --> 01:35:49,820
而不是仅仅打印出来 这只是为了看看发生了什么 
And instead of just printing it out, which was just to see what's going on,

1922
01:35:49,820 --> 01:35:50,880
让我来做吧 
let me do this.

1923
01:35:50,880 --> 01:35:53,180
让我创建一个名为UserName的新变量 
Let me create a new variable called username.

1924
01:35:53,180 --> 01:35:56,810
让我打电话给url.place 
And let me call url.replace.

1925
01:35:56,810 --> 01:36:01,340
结果是 如果URL是一个字符串或在Python中是一个字符串 
It turns out that if URL is a string or a str in Python,

1926
01:36:01,340 --> 01:36:05,840
它又一次提供了多种方法 如剥离和分割 
it, again, comes with multiple methods, like strip, and split,

1927
01:36:05,840 --> 01:36:08,750
还有其他的 其中一个被称为Replace 
and others as well, one of which is called replace.

1928
01:36:08,750 --> 01:36:10,400
而Replace将会做到这一点 
And replace will do just that.

1929
01:36:10,400 --> 01:36:14,360
您向它传递两个参数 第一个参数是 您想要替换什么？
You pass it two arguments, the first of which is, what do you want to replace?

1930
01:36:14,360 --> 01:36:17,640
第二个论点是 你想用什么来取代它？
The second argument is, what do you want to replace it with?

1931
01:36:17,640 --> 01:36:19,940
所以如果我想摆脱 就像我提议的那样 
So if I want to get rid of, as I've proposed,

1932
01:36:19,940 --> 01:36:21,740
实际上就是用户名之前的所有内容 
really just everything before the username,

1933
01:36:21,740 --> 01:36:26,090
也就是说 Twitter URL或其开头 让我们这样说吧 
that is, the Twitter URL or the beginning thereof, let's just say this.

1934
01:36:26,090 --> 01:36:31,520
继续并替换“https://twitter.com/” “
Go ahead and replace "https://twitter.com/",

1935
01:36:31,520 --> 01:36:34,340
结束引用 这就是我想要取代的 
close quote, that's what I want to replace.

1936
01:36:34,340 --> 01:36:37,160
逗号 第二个参数 你想用什么来代替它？
And comma, second argument, what do you want to replace it with?

1937
01:36:37,160 --> 01:36:37,880
没什么 
Nothing.

1938
01:36:37,880 --> 01:36:40,100
所以我真的要用双引号引用
So I'm literally going to pass in quote unquote

1939
01:36:40,100 --> 01:36:42,190
以有效地进行查找和替换 
to effectively do a find and replace.

1940
01:36:42,190 --> 01:36:44,690
这就是Replace方法所做的 就像您可以做的那样
That's what the replace method does, just like you can do it

1941
01:36:44,690 --> 01:36:46,100
在Microsoft Word或Google Docs中 
in Microsoft Word or Google Docs.

1942
01:36:46,100 --> 01:36:49,280
这是程序员执行查找和替换的方式 
This is the programmer's way of doing find and replace.

1943
01:36:49,280 --> 01:36:52,940
现在 让我继续并打印出用户名 
Now let me go ahead and print out just the username.

1944
01:36:52,940 --> 01:36:54,780
因此 我将使用这样的fstring 
So I'll use an fstring like this.

1945
01:36:54,780 --> 01:36:57,590
我会说用户名、冒号 然后用大括号括起来 
I'll say username, colon, and then in curly braces,

1946
01:36:57,590 --> 01:36:59,700
用户名 只是为了更好地格式化它 
username, just to format it nicely.

1947
01:36:59,700 --> 01:37:00,200
好的 
All right.

1948
01:37:00,200 --> 01:37:04,410
让我继续清理我的屏幕并运行twitter.py Enter URL的python 
Let me go ahead and clear my screen and run python of twitter.py, Enter, URL.

1949
01:37:04,410 --> 01:37:12,580
我们开始吧 Https://twitter.com/davidjmalan Enter 
Here we go. https://twitter.com/davidjmalan, Enter.

1950
01:37:12,580 --> 01:37:13,300
好的 
OK.

1951
01:37:13,300 --> 01:37:15,040
现在我们已经取得了一些进展 
Now we've made some progress.

1952
01:37:15,040 --> 01:37:17,360
今天结束了 对吧？
Done for the day, right?

1953
01:37:17,360 --> 01:37:19,580
那么 这有什么不是最优的呢？
Well, what is suboptimal about this?

1954
01:37:19,580 --> 01:37:24,150
有人可以批评我的程序或对我的程序吹毛求疵吗？
Can anyone critique or find fault with my program?

1955
01:37:24,150 --> 01:37:27,950
它现在起作用了 但它有点脆弱 
It is working now, but it's a little fragile.

1956
01:37:27,950 --> 01:37:31,880
我敢打赌 我们可以设计一些我认为它有效但它不起作用的场景 
I bet we could contrive some scenarios where I think it works but it doesn't.

1957
01:37:31,880 --> 01:37:33,890
观众：事实上 我有几个想法 
AUDIENCE: Well, I have a few ideas, actually.

1958
01:37:33,890 --> 01:37:39,980
那么 首先 如果我们不指定HTTPS 它就会被破坏 
Well, first of all, if we don't specify HTTPS, it will be broken.

1959
01:37:39,980 --> 01:37:44,760
其次 如果我们在最后有一个斜杠 它也会被打破 
Secondly, if we have a slash at the end, it also will be broken.

1960
01:37:44,760 --> 01:37:48,320
如果我们在问号之后有一个问号或别的什么 
If we have a question mark or something after question mark,

1961
01:37:48,320 --> 01:37:49,590
它也不会起作用 
it also won't work.

1962
01:37:49,590 --> 01:37:51,160
所以实际上有很多场景 
So a lot of scenarios, actually.

1963
01:37:51,160 --> 01:37:52,160
大卫·马兰：哦 我的天 
DAVID MALAN: Oh, my god.

1964
01:37:52,160 --> 01:37:52,993
我是说 我们来了 
I mean, here we are.

1965
01:37:52,993 --> 01:37:54,650
我假装以为我完蛋了 
I was pretending to think I was done.

1966
01:37:54,650 --> 01:37:57,920
但天哪 亚历克斯给了我们一大堆问题 
But my god, like, Alex gave us a whole laundry list of problems.

1967
01:37:57,920 --> 01:38:01,700
简单地说 如果它不是HTTPS 而是HTTP呢？
And just to recap, then, what if it's not HTTPS, it's HTTP?

1968
01:38:01,700 --> 01:38:03,590
稍微不那么安全 但我还是应该
Slightly less secure, but I should still be

1969
01:38:03,590 --> 01:38:05,713
能够以编程方式容忍这一点 
able to tolerate that programmatically.

1970
01:38:05,713 --> 01:38:07,130
如果协议不在那里怎么办？
What if the protocol is not there?

1971
01:38:07,130 --> 01:38:09,740
如果用户只需输入twitter.com/davidjmaran怎么办？
What if the user just typed twitter.com/davidjmalan?

1972
01:38:09,740 --> 01:38:12,680
如果能容忍这一点而不是表现出错误 那就好了
It would be nice to tolerate that rather than show an error

1973
01:38:12,680 --> 01:38:14,150
让我输入协议 
and make me type in the protocol.

1974
01:38:14,150 --> 01:38:14,660
为什么？
Why?

1975
01:38:14,660 --> 01:38:16,050
它的用户体验并不好 
It's not good user experience.

1976
01:38:16,050 --> 01:38:20,030
如果它在用户名的末尾有一个斜杠或一个问号怎么办？
What if it had a slash at the end of the username, or a question mark?

1977
01:38:20,030 --> 01:38:22,500
如果你想一想你在网上看到的URL 
If you think about URLs you've seen on the web,

1978
01:38:22,500 --> 01:38:24,920
通常会有更多的信息 特别是
there's very commonly more information, especially

1979
01:38:24,920 --> 01:38:26,540
如果它被分享在社交媒体上 
if it's been shared on social media.

1980
01:38:26,540 --> 01:38:28,640
可能有一个HTTP参数 可以这么说 
There might be a HTTP parameters, so to speak,

1981
01:38:28,640 --> 01:38:30,230
只是我们不想要的东西 
just stuff there that we don't want.

1982
01:38:30,230 --> 01:38:34,880
可能会有一个www.twitter.com 我也没有预料到 但确实是这样
There could be a www.twitter.com, which I'm also not expecting but does

1983
01:38:34,880 --> 01:38:37,360
如果您也转到该URL 就可以了 
work if you go to that URL, too.

1984
01:38:37,360 --> 01:38:39,540
因此 有太多事情可能会出错 
So there's just so many things that can go wrong.

1985
01:38:39,540 --> 01:38:43,010
即使我回到前面那个假想的例子 
And even if I come back to my contrived example as earlier,

1986
01:38:43,010 --> 01:38:45,350
如果我运行这个程序 然后说--
what if I run this program and say this--

1987
01:38:45,350 --> 01:38:52,610
“我的用户名是https://twitter.com/davidjmalan ”
"my username is https://twitter.com/davidjmalan,"

1988
01:38:52,610 --> 01:38:53,540
进来吧 
Enter.

1989
01:38:53,540 --> 01:38:58,570
嗯 这也不是真的起作用--它消除了--实际上--
Well, that too just didn't really work-- it got rid of the-- actually--

1990
01:38:58,570 --> 01:39:01,730
[笑]好的 实际上这种方法奏效了 
[LAUGHS] OK, actually that kind of worked.

1991
01:39:01,730 --> 01:39:05,390
但这里的目标是实际获取用户的用户名 
But the goal here is to actually get the user's username,

1992
01:39:05,390 --> 01:39:08,210
不是描述用户用户名的英文句子 
not an English sentence describing the user's username.

1993
01:39:08,210 --> 01:39:11,150
所以我会争辩说 即使我只是意外地创造了
So I would argue that even though I just accidentally created

1994
01:39:11,150 --> 01:39:13,670
完全正确的英语语法 我没有
perfectly correct English grammar, I did not

1995
01:39:13,670 --> 01:39:15,860
正确提取Twitter用户名 
extract the Twitter username correctly.

1996
01:39:15,860 --> 01:39:19,890
我不希望像“我的用户名是”这样的词作为我输入的一部分 
I don't want words like "my username is" as part of my input.

1997
01:39:19,890 --> 01:39:22,940
那么 我们如何着手改善这一点 或许还能逐步减少
So how can we go about improving this, and maybe chipping away

1998
01:39:22,940 --> 01:39:24,530
在这些问题中一个接一个地解决？
at some of those problems one by one?

1999
01:39:24,530 --> 01:39:26,280
好吧 让我把我的屏幕清理一下 
Well, let me clear my screen here.

2000
01:39:26,280 --> 01:39:27,780
让我回到我的准则上来 
Let me come back up to my code.

2001
01:39:27,780 --> 01:39:31,640
让我不只是替换它 而是让我做一些其他的事情 
And let me not just replace it, but let me do something else instead.

2002
01:39:31,640 --> 01:39:34,040
我将继续 而不是使用替换 
I'm going to go ahead, and instead of using replace,

2003
01:39:34,040 --> 01:39:36,950
我将使用另一个名为emovePrefix的函数 
I'm going to use another function called removeprefix.

2004
01:39:36,950 --> 01:39:42,060
前缀是一个字符串或子字符串 位于另一个字符串的开头 
A prefix is a string or a substring that comes at the start of another.

2005
01:39:42,060 --> 01:39:45,320
所以如果我删除前缀 这个函数就不需要第二个参数了 
So if I remove prefix, I don't need a second argument for this function.

2006
01:39:45,320 --> 01:39:46,220
我只需要一个 
I just need one.

2007
01:39:46,220 --> 01:39:48,540
您要删除什么前缀？
What prefix do you want to remove?

2008
01:39:48,540 --> 01:39:51,680
所以这至少现在可以解决这个问题了
So this will at least now fix the problem I just

2009
01:39:51,680 --> 01:39:54,860
描述了像输入一个完整的句子一样 URL在那里 
described of typing in like a whole sentence, where the URL is there,

2010
01:39:54,860 --> 01:39:57,600
但这并不是在开始 只是在结束 
but it's not at the beginning, it's only at the end.

2011
01:39:57,600 --> 01:39:59,930
所以在这里 这仍然是不正确的 
So here, this still is not correct.

2012
01:39:59,930 --> 01:40:04,100
但是我们不会创建这个看起来很奇怪的输出 只删除URL部分
But we don't create this weird-looking output that just removes the URL part

2013
01:40:04,100 --> 01:40:05,360
输入的--
of the input--

2014
01:40:05,360 --> 01:40:11,330
“我的用户名是https://twitter.com/davidjmalan.”
"my username is https://twitter.com/davidjmalan."

2015
01:40:11,330 --> 01:40:16,700
不久前 它确实删除了URL 只留下了davidjmaran 
A moment ago, it did remove the URL and left only the davidjmalan.

2016
01:40:16,700 --> 01:40:17,990
这仍然不是完美的 
This is not perfect still.

2017
01:40:17,990 --> 01:40:21,830
但至少现在 它没有奇怪地删除URL
But at least now, it does not weirdly remove the URL

2018
01:40:21,830 --> 01:40:23,030
然后离开英国人 
and then leave the English.

2019
01:40:23,030 --> 01:40:24,420
它只是让它自生自灭 
It's just leaving it alone.

2020
01:40:24,420 --> 01:40:26,600
所以也许我能更好地处理这件事 但至少
So maybe I could handle this better, but at least

2021
01:40:26,600 --> 01:40:30,710
它把它从我可能预料到的那部分绳子上去掉了 
it's removing it from the part of the string I might anticipate.

2022
01:40:30,710 --> 01:40:32,550
那我们在这里还能做什么呢？
Well, what else could we do here?

2023
01:40:32,550 --> 01:40:35,180
事实证明 正则表达式只是
Well, it turns out that regular expressions just

2024
01:40:35,180 --> 01:40:37,940
让我们更准确地表达模式 
let us express patterns much more precisely.

2025
01:40:37,940 --> 01:40:41,180
我们可以花一整天的时间使用一大堆不同的Python函数
We could spend all day using a whole bunch of different Python functions

2026
01:40:41,180 --> 01:40:44,810
比如RemvePrefix 或Remove and strial 以及其他 还有一些
like removeprefix, or remove, and strip, and others, and kind of

2027
01:40:44,810 --> 01:40:47,240
让我们找到正确的解决方案 
make our way to the right solution.

2028
01:40:47,240 --> 01:40:50,310
但正则表达式只是允许您更简洁地 
But a regular expression just allows you to more succinctly,

2029
01:40:50,310 --> 01:40:55,040
诚然 更隐晦地表达这些模式和目标 
if admittedly more cryptically, express these kinds of patterns and goals.

2030
01:40:55,040 --> 01:40:57,260
我们已经从括号中看到 它可以
And we've seen from parentheses, which can

2031
01:40:57,260 --> 01:41:00,170
不仅用于将符号组合在一起作为集合
be used not just to group symbols together as sets

2032
01:41:00,170 --> 01:41:05,180
但为了捕捉信息 我们现在有一个非常强大的工具
but to capture information as well, we have a very powerful tool now

2033
01:41:05,180 --> 01:41:06,630
在我们的工具包里 
in our toolkit.

2034
01:41:06,630 --> 01:41:07,800
那就让我来做吧 
So let me do this.

2035
01:41:07,800 --> 01:41:12,530
让我继续在这里重新开始 并导入Re库
Let me go ahead and start fresh here and import the re library

2036
01:41:12,530 --> 01:41:14,450
就像以前一样 在我节目的顶端 
as before at the very top of my program.

2037
01:41:14,450 --> 01:41:17,900
我仍然将通过相同的代码行获取用户的URL 
I'm still going to get the user's URL via the same line of code.

2038
01:41:17,900 --> 01:41:20,970
但我现在还将使用另一个函数 
But I'm now going to use another function as well.

2039
01:41:20,970 --> 01:41:24,950
事实证明 不只是re.earch或re.Match 
It turns out that there's not just re.search, or re.match,

2040
01:41:24,950 --> 01:41:26,060
或者重新进行完全匹配 
or re.fullmatch.

2041
01:41:26,060 --> 01:41:30,860
正则表达式库中也有re.sub. 这里的“sub.”
There's also re.sub in the regular expression library, where "sub" here

2042
01:41:30,860 --> 01:41:32,000
意思是“替身”
means "substitute."

2043
01:41:32,000 --> 01:41:35,220
这需要更多的论点 但它们相当直截了当 
And it takes more arguments, but they're fairly straightforward.

2044
01:41:35,220 --> 01:41:38,990
Re.Sub的第一个参数是模式 即正则表达式
The first argument to re.sub is the pattern, the regular expression

2045
01:41:38,990 --> 01:41:40,280
你想要找的东西 
that you want to look for.

2046
01:41:40,280 --> 01:41:43,160
然后你有一个替换的字符串--你要做什么
Then you have a replacement string-- what do

2047
01:41:43,160 --> 01:41:45,470
你想把那个图案换成吗？
you want to replace that pattern with?

2048
01:41:45,470 --> 01:41:47,390
你想在哪里做这一切？
And where do you want to do all that?

2049
01:41:47,390 --> 01:41:51,265
好的 您传入要对其进行替换的字符串 
Well, you pass in the string that you want to do the substitution on.

2050
01:41:51,265 --> 01:41:54,140
然后还有一些其他的论点 我现在会对此挥手致意 
Then there's some other arguments that I'll wave my hands at for now.

2051
01:41:54,140 --> 01:41:56,240
其中有同样的旗帜和一位伯爵 
Among them are those same flags and also a count,

2052
01:41:56,240 --> 01:41:58,970
比如 你想做多少次查找和替换？
like how many times do you want to do find and replace?

2053
01:41:58,970 --> 01:42:01,670
你想让它做所有的事吗？你想只做一件吗 
Do you want it to do all, do you want to do just one,

2054
01:42:01,670 --> 01:42:04,070
诸如此类 你也可以在那里有更多的控制权 
or so forth you can have further control there, too,

2055
01:42:04,070 --> 01:42:06,770
就像你在谷歌文档或Microsoft Word中所做的那样 
just like you would in Google Docs or Microsoft Word.

2056
01:42:06,770 --> 01:42:10,160
好吧 让我回到我的代码 让我来做这件事 
Well, let me go back to my code here, and let me do this.

2057
01:42:10,160 --> 01:42:15,020
我将继续下去 不是搜索 而是re.sub.替换 
I'm going to go ahead and call re not search but re.sub for substitute.

2058
01:42:15,020 --> 01:42:18,320
我将传递以下正则表达式 
I'm going to pass in the following regular expression,

2059
01:42:18,320 --> 01:42:25,610
Https://twitter.com/“ 然后我将结束我的引述 
"https://twitter.com/" and then I'm going to close my quote.

2060
01:42:25,610 --> 01:42:27,860
现在我想用什么来取代它呢？
And now what do I want to replace that with?

2061
01:42:27,860 --> 01:42:31,460
嗯 就像前面使用简单的字符串替换函数一样 
Well, like before with the simple str replace function,

2062
01:42:31,460 --> 01:42:34,380
我想用什么都不用来取代它 只是干脆把它去掉 
I want to replace it with nothing, just get rid of it altogether.

2063
01:42:34,380 --> 01:42:37,730
但我想传入什么字符串才能完成此操作呢？
But what string do I want to pass in to do this to?

2064
01:42:37,730 --> 01:42:39,810
来自用户的URL 
The URL from the user.

2065
01:42:39,810 --> 01:42:44,360
现在 让我继续赋值reo的返回值
And now let me go ahead and assign the return value of re.sub

2066
01:42:44,360 --> 01:42:46,100
设置为一个名为UserName的变量 
to a variable called username.

2067
01:42:46,100 --> 01:42:49,460
因此 Resub.的人生目标 再一次 是用
So re.sub's purpose in life is, again, to substitute

2068
01:42:49,460 --> 01:42:52,490
某个正则表达式的一些值的一些次数 
some value for some regular expression some number of times.

2069
01:42:52,490 --> 01:42:56,360
它本质上是使用正则表达式查找和替换 
It essentially is find and replace using regular expressions.

2070
01:42:56,360 --> 01:42:59,090
并将结果字符串返回给您
And it returns to you the resulting string

2071
01:42:59,090 --> 01:43:01,400
一旦你完成了所有这些替换 
once you've done all those substitutions.

2072
01:43:01,400 --> 01:43:04,850
所以现在我的代码的最后一行可以和以前一样 打印--
So now the very last line of my code can be the same as before, print--

2073
01:43:04,850 --> 01:43:08,960
我将使用fstring、用户名、冒号 然后用大括号括起来 
and I'll use an fstring, username, colon, and then in curly braces,

2074
01:43:08,960 --> 01:43:09,590
用户名 
username.

2075
01:43:09,590 --> 01:43:12,300
这样我就可以打印出来了 
So I can print out literally just that.

2076
01:43:12,300 --> 01:43:12,800
好的 
All right.

2077
01:43:12,800 --> 01:43:14,300
让我们试一试 看看会发生什么 
Let's try this and see what happens.

2078
01:43:14,300 --> 01:43:17,390
我将清除我的终端窗口 运行twitter.py的python 
I'll clear my terminal window, run python of twitter.py.

2079
01:43:17,390 --> 01:43:23,690
我们来了 https://twitter.com/davidjmalan.
And here we go, https://twitter.com/davidjmalan.

2080
01:43:23,690 --> 01:43:25,940
祈祷我的手指 然后按回车键 
Cross my fingers and hit Enter.

2081
01:43:25,940 --> 01:43:28,580
好了 现在我们开业了 
OK, now we're in business.

2082
01:43:28,580 --> 01:43:30,560
但它仍然有点脆弱 
But it is still a little fragile.

2083
01:43:30,560 --> 01:43:34,730
所以让我问问大家 我现在应该有什么问题
And so let me ask the group, what problem should I now

2084
01:43:34,730 --> 01:43:36,125
更进一步的打击？
further chip away at?

2085
01:43:36,125 --> 01:43:38,000
以前也有人这么说过 但让我们明确一点 
They've been said before, but let's be clear.

2086
01:43:38,000 --> 01:43:40,460
还有什么一个或多个问题仍然存在？
What's one or more problems that still remain?

2087
01:43:40,460 --> 01:43:44,690
观众：协议和域名前缀[INAUDIBLE]..
AUDIENCE: The protocols and the domain prefix [INAUDIBLE]..

2088
01:43:44,690 --> 01:43:45,440
大卫·马兰：很好 
DAVID MALAN: Good.

2089
01:43:45,440 --> 01:43:48,020
协议 所以HTTP与HTTPS 
The protocols, so HTTP versus HTTPS.

2090
01:43:48,020 --> 01:43:51,980
也许子域名 www 它应该在那里还是不在那里？
Maybe the subdomain, www, should it be there or not?

2091
01:43:51,980 --> 01:43:54,200
这里还有其他几个错误 
And there's a few other mistakes here, too.

2092
01:43:54,200 --> 01:43:55,770
让我真的留在这个团体里 
Let me actually stay with the group.

2093
01:43:55,770 --> 01:43:59,600
目前的解决方案还有哪些其他缺点？
What are some other shortcomings of this current solution?

2094
01:43:59,600 --> 01:44:03,590
听众：如果我们像你以前那样使用一句话 
AUDIENCE: If we use a phrase like you do before,

2095
01:44:03,590 --> 01:44:07,940
我们将面临同样的问题 因为它没有考虑到
we are going to have the same problem, because it's not taking account

2096
01:44:07,940 --> 01:44:11,150
在文本示例的第一部分中 
in the first part of the text example.

2097
01:44:11,150 --> 01:44:11,900
大卫·马兰：很好 
DAVID MALAN: Good.

2098
01:44:11,900 --> 01:44:16,220
我可能仍然允许URL左边的一些单词 一些英语
I might still allow for some words, some English to the left of the URL

2099
01:44:16,220 --> 01:44:17,810
因为我没有用我的^符号 
because I didn't use my ^ symbol.

2100
01:44:17,810 --> 01:44:18,770
所以我会解决这个问题的 
So I'll fix that.

2101
01:44:18,770 --> 01:44:22,450
对这里的不足之处有什么最后的看法吗？
And any final observations on shortcomings here?

2102
01:44:22,450 --> 01:44:26,993
观众：嗯 它可能是一个HTTP 也可能有不到两个斜杠 
AUDIENCE: Well, it could be an HTTP, or there could be less than two slashes.

2103
01:44:26,993 --> 01:44:27,660
大卫·马兰：好的 
DAVID MALAN: OK.

2104
01:44:27,660 --> 01:44:28,493
所以它可能是HTTP 
So it could be HTTP.

2105
01:44:28,493 --> 01:44:30,910
我认为在礼仪方面也提到了这一点 
And I think that was mentioned, too, in terms of protocol.

2106
01:44:30,910 --> 01:44:32,570
削减幅度可能不到两次 
There could be fewer than two slashes.

2107
01:44:32,570 --> 01:44:34,550
我不会担心的 
That I'm not going to worry about.

2108
01:44:34,550 --> 01:44:38,720
如果用户给了我 而不是两个 那就是用户的错误 
If the user gives me instead of two, that's really user error.

2109
01:44:38,720 --> 01:44:41,420
我可以容忍 但你知道吗 在这一点上
And I could be tolerant of it, but you know what, at that point

2110
01:44:41,420 --> 01:44:45,570
我可以用一条错误消息对他们大喊大叫 说：请修改您的输入 
I'm OK yelling at them with an error message saying, please fix your input.

2111
01:44:45,570 --> 01:44:48,890
否则 我们可能会整天呆在这里 试图处理所有可能的打字错误 
Otherwise, we could be here all day long trying to handle all possible typos.

2112
01:44:48,890 --> 01:44:51,740
目前 我认为从可用性的角度来看 
For now, I think in the interests of usability,

2113
01:44:51,740 --> 01:44:54,560
或用户体验 UX 至少让我们
or user experience, UX, let's at least be

2114
01:44:54,560 --> 01:44:59,130
容忍所有可能的有效输入或合理输入(如果您愿意) 
tolerant of all possible valid inputs or reasonable INPUTS if you will.

2115
01:44:59,130 --> 01:45:01,940
所以让我说到这里 让我开始在这里慢慢地分析这些东西 
So let me go here, and let me start chipping away at these here.

2116
01:45:01,940 --> 01:45:03,530
我们可以解决哪些问题？
What are some problems we can solve?

2117
01:45:03,530 --> 01:45:08,735
好吧 让我提议我们首先解决匹配的问题
Well, let me propose that we first address the issue of matching

2118
01:45:08,735 --> 01:45:10,110
从字符串的开头开始 
from the beginning of the string.

2119
01:45:10,110 --> 01:45:11,900
所以让我在开头加上^ 
So let me add the ^ to the beginning.

2120
01:45:11,900 --> 01:45:15,362
不过 让我在结尾处不加$符号 对吗？
And let me add not a $ sign at the end, though, right?

2121
01:45:15,362 --> 01:45:17,570
因为我不想一直匹配到最后 
Because I don't want to match all the way to the end,

2122
01:45:17,570 --> 01:45:19,950
因为我想容忍那里的用户名 
because I want to tolerate a username there.

2123
01:45:19,950 --> 01:45:23,210
所以我想我们只需要那里有^符号 
So I think we just want the ^ symbol there.

2124
01:45:23,210 --> 01:45:26,000
有一个微妙的漏洞 但还没有人提到 
There's a subtle bug that no one yet mentioned.

2125
01:45:26,000 --> 01:45:30,860
让我来强调一下 看看你现在会不会想到它 
And let me just kind of highlight it and see if it jumps out at you now.

2126
01:45:30,860 --> 01:45:32,730
在我的屏幕上有一点微妙 
It's a little subtle here on my screen.

2127
01:45:32,730 --> 01:45:37,610
我在这里用蓝色突出显示了最后一个错误--
I've highlighted in blue a final bug here--

2128
01:45:37,610 --> 01:45:39,860
也许屏幕上会有一些微笑 对吧？
maybe some smiles on the screen, yeah?

2129
01:45:39,860 --> 01:45:41,400
我们能在这里牵一只手吗？
Can we take one hand here?

2130
01:45:41,400 --> 01:45:46,730
为什么我要在twitter.com上突出显示这个点 尽管它肯定是
Why am I highlighting the dot in twitter.com, even though it definitely

2131
01:45:46,730 --> 01:45:47,900
应该在那里吗？
should be there?

2132
01:45:47,900 --> 01:45:52,610
观众：不带反斜杠的圆点表示除换行符以外的任何字符 
AUDIENCE: So the dot without a backslash means any character except a newline.

2133
01:45:52,610 --> 01:45:53,990
大卫·马兰：是的 确实如此 
DAVID MALAN: Yeah, exactly.

2134
01:45:53,990 --> 01:45:55,500
它指的是任何角色 
It means any character.

2135
01:45:55,500 --> 01:46:01,555
所以我可以输入类似推特的东西 或者推特上的任何东西 
So I could type in something like twitter?com, or twitter anything com,

2136
01:46:01,555 --> 01:46:03,660
而这实际上是可以容忍的 
and that would actually be tolerated.

2137
01:46:03,660 --> 01:46:07,230
这并不是很糟糕 因为用户为什么要这样做？
It's not really that bad, because why would the user do that?

2138
01:46:07,230 --> 01:46:09,410
但如果我想要正确 我想要正确
But if I want to be correct, and I want to be

2139
01:46:09,410 --> 01:46:13,280
能够正确地测试我自己的代码 我真的应该正确地完成这个细节 
able to test my own code properly, I should really get this detail right.

2140
01:46:13,280 --> 01:46:16,040
所以这也是一个很容易解决的问题 但这是一个常见的错误 
So that's an easy fix, too, but it's a common mistake.

2141
01:46:16,040 --> 01:46:19,190
任何时候 当您编写的正则表达式恰好涉及
Anytime you're writing regular expressions that happen to involve

2142
01:46:19,190 --> 01:46:23,210
特殊符号 如URL或域名中的圆点 
special symbols, like dots in a URL or domain name,

2143
01:46:23,210 --> 01:46:27,230
在涉及货币的东西中有一个$符号 记住你可能 确实 
a $ sign in something involving currency, remember you might, indeed,

2144
01:46:27,230 --> 01:46:30,390
需要用这里这样的反斜杠来转义 
need to escape it with a backslash like this here.

2145
01:46:30,390 --> 01:46:30,890
好的 
All right.

2146
01:46:30,890 --> 01:46:34,040
让我具体问一下小组关于协议的问题 
Let me ask the group about the protocol specifically.

2147
01:46:34,040 --> 01:46:36,690
因此 HTTPS在世界上是一件好事 
So HTTPS is a good thing in the world.

2148
01:46:36,690 --> 01:46:37,860
意思是安全 
It means secure.

2149
01:46:37,860 --> 01:46:39,360
正在使用加密 
There is encryption being used.

2150
01:46:39,360 --> 01:46:41,840
因此 一般而言 您喜欢看到HTTPS 
So generally, you like to see HTTPS.

2151
01:46:41,840 --> 01:46:46,370
但你仍然可以看到人们打字或复制粘贴HTTP 
But you still see people typing or copy-pasting HTTP.

2152
01:46:46,370 --> 01:46:50,960
最简单的解决办法是什么 就像已经提出的那样 
What would be the simplest fix here to tolerate, as has been proposed,

2153
01:46:50,960 --> 01:46:54,380
是否同时使用HTTP和HTTPS？
both HTTP and HTTPS?

2154
01:46:54,380 --> 01:46:56,600
我要提议我能做到这一点 
I'm going to propose that I could do this.

2155
01:46:56,600 --> 01:47:02,630
我可以使用HTTP垂直条形图或HTTPS 也就是A或B 
I could do HTTP vertical bar or HTTPS, which, again, means A or B.

2156
01:47:02,630 --> 01:47:04,490
但我想我可以比这更聪明 
But I think I can be smarter than that.

2157
01:47:04,490 --> 01:47:06,770
我可以让我的代码更简洁一些 
I can keep my code a little more succinct.

2158
01:47:06,770 --> 01:47:13,400
这里有什么关于容忍HTTP或HTTPS的建议吗？
Any recommendations here for tolerating HTTP or HTTPS?

2159
01:47:13,400 --> 01:47:16,845
观众：我们可以试着在S后面加个问号 
AUDIENCE: We could try to put in question mark behind the S.

2160
01:47:16,845 --> 01:47:17,720
大卫·马兰：太好了 
DAVID MALAN: Perfect.

2161
01:47:17,720 --> 01:47:19,340
只需使用问号即可 
Just use a question mark.

2162
01:47:19,340 --> 01:47:21,110
这两个都是可行的解决方案 
Both of those would be viable solutions.

2163
01:47:21,110 --> 01:47:23,330
如果你想在你的代码中表现得非常明确 那没问题 
If you want to be super explicit in your code, fine.

2164
01:47:23,330 --> 01:47:28,730
使用括号 并使用HTTP或HTTPS 这样您 读者 您的老板 
Use parentheses and say HTTP or HTTPS, so that you, the reader, your boss,

2165
01:47:28,730 --> 01:47:31,410
你的老师完全知道你在做什么 
your teacher just know exactly what you're doing.

2166
01:47:31,410 --> 01:47:35,090
但如果你一直采取更冗长的方法 
But if you keep taking the more verbose approach all the time,

2167
01:47:35,090 --> 01:47:37,760
当然 它实际上可能会变得不那么可读性
it might actually become less readable, certainly

2168
01:47:37,760 --> 01:47:40,580
一旦您的正则表达式变得这么大 而不是这么大 
once your regular expressions get this big instead of this big.

2169
01:47:40,580 --> 01:47:42,290
所以 让我们尽我们所能节省空间 
So let's save space where we can.

2170
01:47:42,290 --> 01:47:45,030
我认为这是非常合理的 所以
And I would argue that this is pretty reasonable, so

2171
01:47:45,030 --> 01:47:47,640
只要您有阅读正则表达式的习惯
long as you're in the habit of reading regular expressions

2172
01:47:47,640 --> 01:47:50,390
并知道问号并不意味着字面上的问号 
and know that question mark does not mean a literal question mark,

2173
01:47:50,390 --> 01:47:52,970
但它的意思是零或之前的一件事 
but it means zero or one of the thing before.

2174
01:47:52,970 --> 01:47:56,510
我认为我们实际上已经将S设置为可选的 
I think we've effectively made the S optional here.

2175
01:47:56,510 --> 01:47:58,410
现在 我还能做什么？
Now, what else can I do?

2176
01:47:58,410 --> 01:48:03,860
好吧 假设我们想要容忍WWW点 它可能存在也可能不存在 
Well, suppose we want to tolerate the www dot, which may or may not be there,

2177
01:48:03,860 --> 01:48:06,050
但如果你打开浏览器 它就会起作用 
but it will work if you go to a browser.

2178
01:48:06,050 --> 01:48:07,220
我可以做到这一点
I could do this--

2179
01:48:07,220 --> 01:48:11,720
WWW点--等等 我想要一个反斜杠 这样我就不会
www dot-- wait, I want a backslash there so I don't

2180
01:48:11,720 --> 01:48:13,310
重复和以前一样的错误 
repeat the same mistake as before.

2181
01:48:13,310 --> 01:48:19,220
但这也不好 因为我想忍受在那里或不在
But this is no good either, because I want to tolerate being there or not

2182
01:48:19,220 --> 01:48:19,760
在那里 
being there.

2183
01:48:19,760 --> 01:48:21,890
现在我只是要求它在那里 
And now I've just required that it be there.

2184
01:48:21,890 --> 01:48:24,290
但我认为我可以采取同样的方法 
But I think I can take the same approach.

2185
01:48:24,290 --> 01:48:25,550
有什么建议吗？
Any recommendations?

2186
01:48:25,550 --> 01:48:27,200
我怎么做才能让WWW 
How do I make the www.

2187
01:48:27,200 --> 01:48:30,230
可有可无 就为了敲打这个家？
optional, just to hammer this home?

2188
01:48:30,230 --> 01:48:32,480
观众：我们可以分组--
AUDIENCE: We can group--

2189
01:48:32,480 --> 01:48:35,835
画一个正方形和一个问号 
make a square and a question mark.

2190
01:48:35,835 --> 01:48:36,710
大卫·马兰：太好了 
DAVID MALAN: Perfect.

2191
01:48:36,710 --> 01:48:38,825
因此 问号又是一个简短的答案 
So question mark is the short answer again.

2192
01:48:38,825 --> 01:48:40,700
但这一次我们必须更聪明一点 
But we have to be a little smarter this time.

2193
01:48:40,700 --> 01:48:43,130
正如玛丽亚所指出的 我们现在需要括号 
As Maria has noted, we need parentheses now.

2194
01:48:43,130 --> 01:48:46,160
因为如果我在圆点后面加一个问号 
Because if I just put a question mark after the dot,

2195
01:48:46,160 --> 01:48:48,147
这只意味着点是可选的 
that just means the dot is optional.

2196
01:48:48,147 --> 01:48:50,480
这是错误的 因为我们不希望用户输入
And that's wrong, because we don't want the user to type

2197
01:48:50,480 --> 01:48:56,690
在W-T-W-I-T-T-E-R 我们希望圆点在那里 或者根本不存在
in W-W-W-T-W-I-T-T-E-R. We want the dot to be there or just not at all with no

2198
01:48:56,690 --> 01:48:57,490
www.w.
www.

2199
01:48:57,490 --> 01:49:00,080
所以我们需要把这整件事归类在一起 
So we need to group this whole thing together,

2200
01:49:00,080 --> 01:49:04,160
在那里放一个括号 然后放一个括号 而不是在第三个W之后 
put a parenthesis there, and then a parenthesis, not after the third W,

2201
01:49:04,160 --> 01:49:09,920
在点之后 所以整个东西要么在那里 要么不在那里 
after the dot, so that that whole thing is either there or it's not there.

2202
01:49:09,920 --> 01:49:12,338
我们还能在这里做些什么呢？
And what else could we still do here?

2203
01:49:12,338 --> 01:49:14,630
还有一件事是我们应该容忍的 
There's going to be one other thing we should tolerate.

2204
01:49:14,630 --> 01:49:16,922
以前已经说过了 我会把这一条摘掉 
And it's been said before, and I'll pluck this one off.

2205
01:49:16,922 --> 01:49:18,260
协议是怎么回事？
What about the protocol?

2206
01:49:18,260 --> 01:49:23,805
例如 如果用户只是不键入或不复制粘贴http：//
Like, what if the user just doesn't type or doesn't copy-paste the http://

2207
01:49:23,805 --> 01:49:26,660
或https://？
or an https://?

2208
01:49:26,660 --> 01:49:28,460
老实说 你和我都没有这个习惯 
Honestly, you and I are not in the habit,

2209
01:49:28,460 --> 01:49:31,730
总体而言 现在甚至不再打字了 
generally, of even typing the protocol anymore nowadays.

2210
01:49:31,730 --> 01:49:34,010
你只要让浏览器帮你找出来 
You just let the browser figure it out for you,

2211
01:49:34,010 --> 01:49:36,590
并自动添加它 
and automatically add it instead.

2212
01:49:36,590 --> 01:49:38,900
所以这张看起来更像一张嘴 
So this one's going to look like more of a mouthful.

2213
01:49:38,900 --> 01:49:43,520
但如果我想让蓝色的这整件事是可选的 
But if I want this whole thing here in blue to be optional,

2214
01:49:43,520 --> 01:49:46,880
这实际上与玛丽亚刚才提出的解决方案相同 
it's actually the same solution as Maria offered a moment ago.

2215
01:49:46,880 --> 01:49:49,550
接下来我要在这里加上一个括号 
I'm going to go ahead and put a parenthesis over here,

2216
01:49:49,550 --> 01:49:53,960
在两个斜杠后面加上一个括号 然后是一个问题
and a parenthesis after the two slashes, and then a question

2217
01:49:53,960 --> 01:49:57,120
标记 以使整个操作也成为可选的 
mark so as to make that whole thing optional as well.

2218
01:49:57,120 --> 01:49:58,320
这样就可以了 
And this is OK.

2219
01:49:58,320 --> 01:50:00,920
把这整件事做成这件事完全没问题
It's totally fine to make this whole thing

2220
01:50:00,920 --> 01:50:06,480
可选的 或者说里面 这个小东西 就是S的可选的 
optional, or inside of it, this little thing, just the S optional as well.

2221
01:50:06,480 --> 01:50:09,350
只要我一次又一次地应用同样的原则 
So long as I'm applying the same principles again and again,

2222
01:50:09,350 --> 01:50:11,390
无论是小规模的还是大规模的 
either on a small scale or a bigger scale,

2223
01:50:11,390 --> 01:50:16,680
将其中一个嵌套在另一个中是完全没有问题的 
it's totally fine to nest one of these inside of the other.

2224
01:50:16,680 --> 01:50:20,730
现在对这些改进中的任何一个提出问题
Questions now on any of these refinements

2225
01:50:20,730 --> 01:50:23,730
对于这个解析 这个对推特的分析？
to this parsing, this analyzing of Twitter?

2226
01:50:23,730 --> 01:50:29,850
观众：如果我们在这个WWW点旁边加一个竖线 会怎么样？
AUDIENCE: What if we put a vertical bar besides this www dot?

2227
01:50:29,850 --> 01:50:31,930
大卫·马兰：如果我们在那里用竖条呢？
DAVID MALAN: What if we use a vertical bar there?

2228
01:50:31,930 --> 01:50:34,110
所以我们也可以做类似的事情 
So we could do something like that, too.

2229
01:50:34,110 --> 01:50:36,690
我们可以做这样的事情 
We could do something like this.

2230
01:50:36,690 --> 01:50:41,370
我可以用www.来代替问号 或者什么都不做
Instead of the question mark, I could do www dot or nothing

2231
01:50:41,370 --> 01:50:43,680
只留下那个和圆括号 
and just leave that and the parentheses.

2232
01:50:43,680 --> 01:50:45,160
这也很好 
That, too, would be fine.

2233
01:50:45,160 --> 01:50:47,743
我个人倾向于不喜欢它 因为它稍微少了一点
I personally tend not to like that, because it's a little less

2234
01:50:47,743 --> 01:50:49,035
对我来说很明显--等一下 
obvious to me-- wait, a minute.

2235
01:50:49,035 --> 01:50:52,260
这是故意的吗 还是我忘了把我的想法
Is that deliberate, or did I forget to finish my thought by putting something

2236
01:50:52,260 --> 01:50:53,460
在垂直横杆之后？
after the vertical bar?

2237
01:50:53,460 --> 01:50:57,630
但这也是允许的 如果你是这个意思的话 
But that, too, would be allowed there as well, if that's what you mean.

2238
01:50:57,630 --> 01:50:59,790
关于我们把东西放在哪里的其他问题 
Other questions on where we left things here,

2239
01:50:59,790 --> 01:51:03,090
我们把协议也设为可选的吗？
where we made the protocol optional, too?

2240
01:51:03,090 --> 01:51:07,260
观众：如果我们有括号 会怎么样？
AUDIENCE: What happens if we have parenthesis,

2241
01:51:07,260 --> 01:51:10,173
在里面我们有另一个括号 还有另一个括号？
and inside we have another parenthesis, and another parenthesis?

2242
01:51:10,173 --> 01:51:11,590
会不会互相干扰？
Will it interfere with each other?

2243
01:51:11,590 --> 01:51:14,298
大卫·马兰：如果你把括号放在括号里 
DAVID MALAN: If you have parentheses inside of parentheses, that,

2244
01:51:14,298 --> 01:51:15,660
太好了 完全没问题 
too, is totally fine.

2245
01:51:15,660 --> 01:51:19,680
事实上 这应该是今天令人放心的教训之一 
And indeed, that should be one of the reassuring lessons today.

2246
01:51:19,680 --> 01:51:23,670
诚然 这些正则表达式中的每一个都很复杂 
As complicated as each of these regular expressions has admittedly gotten,

2247
01:51:23,670 --> 01:51:27,570
我只是应用了完全相同的原则和语法
I'm just applying the exact same principles and the exact same syntax

2248
01:51:27,570 --> 01:51:29,110
再三 
again and again.

2249
01:51:29,110 --> 01:51:31,988
所以把括号放在括号里是完全可以的
So it's totally fine to have parentheses inside of parentheses

2250
01:51:31,988 --> 01:51:33,780
如果他们各自解决不同的问题 
if they're each solving different problems.

2251
01:51:33,780 --> 01:51:37,200
事实上 我今天最强调的一课
And in fact, the lesson I would really emphasize the most today

2252
01:51:37,200 --> 01:51:41,250
如果你试着写出来你不会高兴的
is that you will not be happy if you try to write out

2253
01:51:41,250 --> 01:51:44,820
一次完成整个复杂的正则表达式 
a whole complicated regular expression all at once.

2254
01:51:44,820 --> 01:51:47,310
如果你像我一样 你会失败的 
Like, if you're anything like me, you will fail,

2255
01:51:47,310 --> 01:51:49,428
你将很难找到这个错误 
and you will have trouble finding the mistake.

2256
01:51:49,428 --> 01:51:50,970
因为我的天 看看这些东西 
Because my god, look at these things.

2257
01:51:50,970 --> 01:51:53,880
即使在这么多年后的我看来 它们也是神秘的 
They are, even to me all these years later, cryptic.

2258
01:51:53,880 --> 01:51:57,240
我认为 更好的方法是 无论你是编程新手
The better way, I would argue, whether you're new to programming

2259
01:51:57,240 --> 01:52:01,110
或者像我这样老了 就是带着这些孩子
or is old to it as I am, is to just take these baby

2260
01:52:01,110 --> 01:52:03,750
步骤 这些渐进的步骤 你可以做一些简单的事情 
steps, these incremental steps where you do something simple,

2261
01:52:03,750 --> 01:52:04,710
你要确保它起作用 
you make sure it works.

2262
01:52:04,710 --> 01:52:07,080
你再增加一项功能 确保它能正常工作 
You add one more feature, make sure it works.

2263
01:52:07,080 --> 01:52:09,120
再添加一项功能 确保其正常工作 
Add one more feature, make sure it works.

2264
01:52:09,120 --> 01:52:12,360
希望到最后 因为你已经完成了其中的每一步
And hopefully, by the end, because you've done each of those steps one

2265
01:52:12,360 --> 01:52:15,490
在某个时候 整件事对你来说都会有意义的 
at a time, the whole thing will make sense to you.

2266
01:52:15,490 --> 01:52:20,310
但你也会在每一次转弯时都正确地完成每一步 
But you'll also have gotten each of those steps correct at each turn.

2267
01:52:20,310 --> 01:52:23,970
所以 请务必避免尝试的倾向
So please, do avoid the inclination to try

2268
01:52:23,970 --> 01:52:26,550
想出又长又复杂的正则表达式
to come up with long, sophisticated regular expressions

2269
01:52:26,550 --> 01:52:29,580
一下子 因为这不是很好地利用时间
all at once, because it's just not a good use of a time

2270
01:52:29,580 --> 01:52:32,100
如果你盯着它 试图找到你认为的错误
if you then stare at it trying to find a mistake that you

2271
01:52:32,100 --> 01:52:35,230
如果你做的事情更循序渐进 你可能会发现 
could have caught if you did things more incrementally instead.

2272
01:52:35,230 --> 01:52:35,730
好的 
All right.

2273
01:52:35,730 --> 01:52:38,160
可以说 仍然存在至少一个问题
There still remains, arguably, at least one problem

2274
01:52:38,160 --> 01:52:40,050
有了这个解决方案 即使我是
with this solution in that even though I'm

2275
01:52:40,050 --> 01:52:44,040
调用re.Sub以不使用任何内容替换URL 
calling re.sub to substitute the URL with nothing,

2276
01:52:44,040 --> 01:52:47,410
引用 不引用 然后在我的最后一行代码中 第6行 
quote, unquote, I then in my final line of code, line 6,

2277
01:52:47,410 --> 01:52:49,590
我只是盲目地假设这一切都奏效了 
am just blindly assuming that it all worked,

2278
01:52:49,590 --> 01:52:52,200
接下来 我将打印出用户名 
and I'm going to go ahead and print out the username.

2279
01:52:52,200 --> 01:52:53,520
但如果用户--
But what if the user--

2280
01:52:53,520 --> 01:52:56,310
如果我在这里清空屏幕并运行twitter.py的python--
if I clear my screen here and run python of twitter.py--

2281
01:52:56,310 --> 01:52:58,110
甚至连Twitter URL都不输入？
doesn't even type a Twitter URL?

2282
01:52:58,110 --> 01:53:02,805
如果他们做了像https://google.com/ 这样的事情怎么办
What if they do something like https://google.com/,

2283
01:53:02,805 --> 01:53:06,090
就像完全无关 不管是什么原因 
like completely unrelated, for whatever reason,

2284
01:53:06,090 --> 01:53:08,970
输入 这不是他们的Twitter用户名 
Enter, that is not their Twitter username.

2285
01:53:08,970 --> 01:53:12,300
所以我们需要一些条件逻辑 我认为 
So we need to have some conditional logic, I would argue,

2286
01:53:12,300 --> 01:53:15,690
所以为了这个程序 我们只打印出
so that for this program's sake, we're only printing out

2287
01:53:15,690 --> 01:53:19,920
或者 在后端系统中 我们只保存到数据库或CSV中
or, in a back end system, we're only saving into our database or a CSV

2288
01:53:19,920 --> 01:53:24,090
如果我们确实匹配了正确的模式 请将用户名归档 
file the username if we actually matched the proper pattern.

2289
01:53:24,090 --> 01:53:29,010
因此 与其使用对清理数据有用的re.sub. 
So rather than use re.sub, which is useful for cleaning up data,

2290
01:53:29,010 --> 01:53:32,340
就像我们在这里做的那样 处理掉我们不想要的东西 
as we've done here to get rid of something we don't want there,

2291
01:53:32,340 --> 01:53:37,080
为什么我们不回到我们今天开始的地方去重新搜索 
why don't we go back to re.search, where we began today,

2292
01:53:37,080 --> 01:53:41,100
并用它来解决同样的问题 但以一种有条件的方式 
and use it to solve this same problem but in a way that's conditional,

2293
01:53:41,100 --> 01:53:44,490
因此我可以自信地说 是或不是 在我的节目结束时 
whereby I can confidently say, yes or no, at the end of my program,

2294
01:53:44,490 --> 01:53:47,260
这里是用户名 还是这里不是？
here's the username, or here it is not?

2295
01:53:47,260 --> 01:53:48,300
所以现在让我继续下去 
So let me go ahead now.

2296
01:53:48,300 --> 01:53:50,340
我会在这里清理我的终端窗口 
And I'll clear my terminal window here.

2297
01:53:50,340 --> 01:53:52,560
我要保留大部分--
I'm going to keep most of--

2298
01:53:52,560 --> 01:53:55,800
我将保持前两行 与我导入Re的位置相同 
I'm going to keep the first two lines the, same where I import re,

2299
01:53:55,800 --> 01:53:57,520
然后我从用户那里获得URL 
and I get the URL from the user.

2300
01:53:57,520 --> 01:53:59,010
但这一次 让我们开始吧 
But this time, let's do this.

2301
01:53:59,010 --> 01:54:03,630
这一次让我们搜索 使用re.earch而不是re.sub.
Let's this time search for, using re.search instead of re.sub,

2302
01:54:03,630 --> 01:54:04,470
以下是 
the following.

2303
01:54:04,470 --> 01:54:09,510
我将从字符串的开头开始匹配 
I'm going to start matching at the beginning of the string, https,

2304
01:54:09,510 --> 01:54:13,380
问号使S成为可选的 冒号 斜杠 斜杠 
question mark to make the S optional, colon, slash, slash,

2305
01:54:13,380 --> 01:54:19,710
我将把我的www设置为可选 在那里打上问号 
I'm going to make my www optional by putting that in question marks there,

2306
01:54:19,710 --> 01:54:24,000
然后是一个带有文字圆点的twitter.com 这样我就可以在这个问题上保持领先 
then a twitter.com with a literal dot there so I stay ahead of that issue,

2307
01:54:24,000 --> 01:54:26,640
也是 然后是一条斜线 
too, then a slash.

2308
01:54:26,640 --> 01:54:30,330
然后 这就是Davidjmaran应该去的地方 
And then well, this is where davidjmalan is supposed to go.

2309
01:54:30,330 --> 01:54:31,710
我如何检测到这一点？
How do I detect this?

2310
01:54:31,710 --> 01:54:35,580
好吧 我想我可以容忍URL末尾的任何内容 
Well, I think I'll just tolerate anything at the end of the URL here.

2311
01:54:35,580 --> 01:54:38,532
好的 最后的$符号 结束引号 
All right, $ sign at the very end, close quote.

2312
01:54:38,532 --> 01:54:40,740
目前 我要规定我们不能
For the moment, I'm going to stipulate that we're not

2313
01:54:40,740 --> 01:54:43,830
我会担心结尾处的问号或散列 
going to worry about question marks at the end or hashes,

2314
01:54:43,830 --> 01:54:45,600
就像URL中的片段ID一样 
like for fragment IDs in URLs.

2315
01:54:45,600 --> 01:54:48,630
为了简单起见 我们现在假设URL只是
We're going to assume for simplicity now that the URL just

2316
01:54:48,630 --> 01:54:50,610
仅以用户名结尾 
ends with the username alone.

2317
01:54:50,610 --> 01:54:52,110
现在我该怎么办呢？
Now what am I going to do?

2318
01:54:52,110 --> 01:54:54,330
嗯 我想特别搜索这个URL 
Well, I want to search for this URL specifically,

2319
01:54:54,330 --> 01:54:58,230
我要忽略凯斯 所以请再说一遍 
and I'm going to ignore case, so re.IGNORECASE,

2320
01:54:58,230 --> 01:55:00,840
应用从以前学到的同样的教训 
applying that same lesson learned from before.

2321
01:55:00,840 --> 01:55:05,717
Re.search、recall将向您返回您捕获的匹配项 
re.search, recall, will return to you the matches you've captured.

2322
01:55:05,717 --> 01:55:07,050
那么 我想捕捉什么呢？
Well, what do I want to capture?

2323
01:55:07,050 --> 01:55:12,420
好的 我想在这里捕获twitter.com URL右侧的所有内容 
Well, I want to capture everything to the right of the twitter.com URL here.

2324
01:55:12,420 --> 01:55:17,560
因此 让我用括号将应该是用户用户名的内容括起来 
So let me surround what should be the user's username with parentheses,

2325
01:55:17,560 --> 01:55:21,580
不是为了让它们成为可选的 而是说 “捕捉这组字符 ”
not for making them optional but to say, "capture this set of characters."

2326
01:55:21,580 --> 01:55:24,730
现在 re.earch recall 返回一个答案 
Now, re.search, recall, returns an answer.

2327
01:55:24,730 --> 01:55:28,600
Matches将再次成为我的变量名 但我可以随心所欲地命名它 
matches will be my variable name again, but I could call it anything I want.

2328
01:55:28,600 --> 01:55:29,950
然后我就能做到这一点 
And then I can do this.

2329
01:55:29,950 --> 01:55:33,680
如果匹配 现在我知道我能做到 
If matches, now I know I can do this.

2330
01:55:33,680 --> 01:55:36,370
让我们打印出格式字符串用户名冒号 
Let's print out the format string, username colon.

2331
01:55:36,370 --> 01:55:40,190
然后我想打印出什么呢？
And then what do I want to print out?

2332
01:55:40,190 --> 01:55:44,440
嗯 我想我想把比赛打印出来 第一组是我的比赛
Well, I think I want to print out matches.group 1 for my matched

2333
01:55:44,440 --> 01:55:45,700
用户名 
username.

2334
01:55:45,700 --> 01:55:46,210
好的 
All right.

2335
01:55:46,210 --> 01:55:47,980
那么 我在做什么 只是为了回顾一下？
So what am I doing just to recap?

2336
01:55:47,980 --> 01:55:49,960
第1行 我正在导入库 
Line 1, I'm importing the library.

2337
01:55:49,960 --> 01:55:52,280
第2行 我从用户那里获取URL 
Line 2, I'm getting the URL from the user.

2338
01:55:52,280 --> 01:55:53,230
因此 这并不是什么新鲜事 
So nothing new there.

2339
01:55:53,230 --> 01:55:59,740
第5行 我正在搜索用户的URL 如这里的第二个参数所示 
Line 5, I'm searching the user's URL, as indicated here as the second argument,

2340
01:55:59,740 --> 01:56:03,220
对于此正则表达式 此模式 
for this regular expression, this pattern.

2341
01:56:03,220 --> 01:56:07,720
我用圆括号将圆点+括起来 
I have surrounded the dot + with parentheses

2342
01:56:07,720 --> 01:56:11,380
所以他们最终会被捕获 所以我可以提取 
so that they are captured ultimately, so I can extract,

2343
01:56:11,380 --> 01:56:14,320
在最后一个场景中 是指用户的用户名 
in this final scenario, the user's username.

2344
01:56:14,320 --> 01:56:18,580
如果我真的找到了匹配项 而匹配项不是零 
If I indeed got a match, and matches is non-none,

2345
01:56:18,580 --> 01:56:23,470
它实际上包含一些匹配项 然后且仅在那时 打印出用户名 
it is actually containing some match, then and only then, print out username.

2346
01:56:23,470 --> 01:56:25,420
这样的话 现在让我试试这个 
In this way, let me try this now.

2347
01:56:25,420 --> 01:56:31,110
如果我运行twitter.py的PYTHON并输入https://www.google.com/ 
If I run python of twitter.py and type in https://www.google.com/,

2348
01:56:31,110 --> 01:56:33,370
现在什么都不打印了 
now nothing gets printed.

2349
01:56:33,370 --> 01:56:36,010
所以我至少解决了我们刚才看到的错误 
So I've at least solved the mistake we just saw,

2350
01:56:36,010 --> 01:56:38,050
我只是假设我的代码起作用了 
where I was just assuming that my code worked.

2351
01:56:38,050 --> 01:56:44,000
现在 我正在确保我已经搜索并找到了Twitter URL前缀 
Now I'm making sure that I have searched for and found the Twitter URL prefix.

2352
01:56:44,000 --> 01:56:44,500
好的 
All right.

2353
01:56:44,500 --> 01:56:45,917
好了 现在让我们来真的来吧 
Well, let's run this for real now.

2354
01:56:45,917 --> 01:56:51,730
Twitter.py https://twitter.com/davidjmalan.的巨蟒
Python of twitter.py https://twitter.com/davidjmalan.

2355
01:56:51,730 --> 01:56:55,420
但请注意 我可以使用HTTP 我可以使用WWW 
But note, I could use HTTP, I could use www.

2356
01:56:55,420 --> 01:56:58,430
我只需要在这里继续 然后按Enter键 
I'm just going to go ahead here and hit Enter.

2357
01:56:58,430 --> 01:57:01,730
呃 没有 
Huh, none.

2358
01:57:01,730 --> 01:57:05,480
到底出了什么问题？
What has gone wrong?

2359
01:57:05,480 --> 01:57:08,060
这个更微妙一些 
This one's a bit more subtle.

2360
01:57:08,060 --> 01:57:13,027
但是为什么Matchs.Group 1什么都不包含呢？
But why does matches.group 1 contain nothing?

2361
01:57:13,027 --> 01:57:13,610
等一下 
Wait a minute.

2362
01:57:13,610 --> 01:57:15,450
让我--也许我做错了 
Let me-- maybe I did this wrong.

2363
01:57:15,450 --> 01:57:17,707
也许--也许我们需要万维网？
Maybe-- maybe do we need the www?

2364
01:57:17,707 --> 01:57:18,540
让我再运行一次 
Let me run it again.

2365
01:57:18,540 --> 01:57:24,740
我们开始吧https：// 让我们添加一个www.twitter.com/davidjmalan 
So here we go. https://, let's add a www.twitter.com/davidjmalan.

2366
01:57:24,740 --> 01:57:25,500
好吧
All right.

2367
01:57:25,500 --> 01:57:26,470
输入.
Enter.

2368
01:57:26,470 --> 01:57:28,550
吼 吼 吼 
Ho, ho, ho.

2369
01:57:28,550 --> 01:57:31,170
怎么回事？
What is going on?

2370
01:57:31,170 --> 01:57:32,720
观众：你必须说第二组 
AUDIENCE: You have to say group 2.

2371
01:57:32,720 --> 01:57:34,520
大卫·马兰：我不得不说第二组？
DAVID MALAN: I have to say group 2?

2372
01:57:34,520 --> 01:57:39,140
好吧 等等--哦 对了 因为我们的子域是可选的 
Well, wait-- oh, right, because we had the subdomain was optional.

2373
01:57:39,140 --> 01:57:42,560
为了使它成为可选的 我需要在这里使用括号 
And to make it optional, I needed to use parentheses here.

2374
01:57:42,560 --> 01:57:44,070
所以我说零或上 
And so I then said zero or on.

2375
01:57:44,070 --> 01:57:44,570
好的.
OK.

2376
01:57:44,570 --> 01:57:49,910
所以这意味着实际上 我是无意的 但通过设计
So that means that actually, I'm unintentionally but by design

2377
01:57:49,910 --> 01:57:54,710
捕获www点 或者如果它之前不存在 
capturing the www dot, or none of it if it wasn't there before,

2378
01:57:54,710 --> 01:57:56,645
但我这里还有第二个匹配因为我
but I have a second match over here because I

2379
01:57:56,645 --> 01:57:58,020
还有第二个括号
have a second set of parentheses.

2380
01:57:58,020 --> 01:58:00,350
所以我想 是的 让我改变matches.group 1
So I think, yep, let me change matches.group 1

2381
01:58:00,350 --> 01:58:02,300
到matches.group 2 让我们运行这个 
to matches.group 2, and let's run this.

2382
01:58:02,300 --> 01:58:07,460
Python of twitter.py https://www.twitter--
Python of twitter.py https://www.twitter--

2383
01:58:07,460 --> 01:58:13,070
让我们这样做 twitter.com/davidjmalan 输入 
let's do this, twitter.com/davidjmalan, Enter,

2384
01:58:13,070 --> 01:58:15,920
现在我们拿到了用户名
and now we've got access to the username.

2385
01:58:15,920 --> 01:58:19,040
让我再把它收紧一点 
Let me go ahead and tighten it up a little bit further.

2386
01:58:19,040 --> 01:58:21,513
如果你喜欢我们的新朋友
If you like our new friend--

2387
01:58:21,513 --> 01:58:22,430
很难不喜欢 
it's hard not to like.

2388
01:58:22,430 --> 01:58:26,060
如果我们喜欢我们的老朋友海象操作员 让我们继续
If we like our old friend the walrus operator, let's go ahead

2389
01:58:26,060 --> 01:58:27,740
再加上这个让事情更紧密
and add this just to tighten things up.

2390
01:58:27,740 --> 01:58:31,460
让我们回到VS代码 让我们去掉不必要的条件
Let me go back to VS Code here, and let me get rid of the unnecessary condition

2391
01:58:31,460 --> 01:58:34,580
然后在这里合并 如果匹配等于这个的话
there and combine it up here, if matches equals that.

2392
01:58:34,580 --> 01:58:38,090
但是让我们将单个赋值运算符改为海象运算符 
But let's change the single assignment operator to the walrus operator.

2393
01:58:38,090 --> 01:58:40,040
现在我把事情弄得更紧了 
Now I've tightened things up further.

2394
01:58:40,040 --> 01:58:43,940
但我敢打赌 这里可能有另一个解决方案 
But I bet, I bet, I bet there might be another solution here.

2395
01:58:43,940 --> 01:58:50,630
事实上 我们可以回到这最后一组语法 
And indeed, it turns out that we can come back to this final set of syntax.

2396
01:58:50,630 --> 01:58:52,940
回想一下 当我们引入这些括号时 
Recall that when we introduce these parentheses,

2397
01:58:52,940 --> 01:58:56,720
我们这样做是为了我们可以做A或B 比如 用竖条 
we did it so that we could do A or B, for instance, with the vertical bar.

2398
01:58:56,720 --> 01:58:59,060
然后你甚至可以组合不止一个酒吧 
Then you can even combine more than just one bar.

2399
01:58:59,060 --> 01:59:02,900
我们使用组来组合想法 如 www.
We use the group to combine ideas like the, www dot.

2400
01:59:02,900 --> 01:59:07,760
然后在底部这里有一个公认的奇怪语法 直到现在
And then there's this admittedly weird syntax at the bottom here, up until now

2401
01:59:07,760 --> 01:59:08,690
未使用 
not used.

2402
01:59:08,690 --> 01:59:12,230
有一个非捕获版本的圆括号
There is a non-capturing version of parentheses

2403
01:59:12,230 --> 01:59:15,050
如果你想逻辑地使用圆括号 
if you want to use parentheses logically because you need to,

2404
01:59:15,050 --> 01:59:18,080
但你不想费心去捕捉结果 
but you don't want to bother capturing the result.

2405
01:59:18,080 --> 01:59:20,450
这可能是一个更好的解决方案
And this would arguably be a better solution

2406
01:59:20,450 --> 01:59:23,630
因为 是的 如果我回到VS Code 
here, because, yes, if I go back to VS Code, I do

2407
01:59:23,630 --> 01:59:27,560
至少需要用括号将www点括起来
need to surround the www dot with parentheses, at least

2408
01:59:27,560 --> 01:59:30,170
就像我在这里写正则表达式一样 因为我想
as I've written my regex here, because I wanted

2409
01:59:30,170 --> 01:59:31,910
在后面加上问号
to put the question mark after it.

2410
01:59:31,910 --> 01:59:35,120
但我不需要那个www点回来 
But I don't need the www dot coming back.

2411
01:59:35,120 --> 01:59:37,580
实际上 我们只提取我们关心的数据 
In fact, let's only extract the data we care about,

2412
01:59:37,580 --> 01:59:40,280
这样我以后就不会有困惑了
just so there's no confusion down the road, for me,

2413
01:59:40,280 --> 01:59:42,120
或者我的同事 或者我的老师
or my colleagues, or my teachers.

2414
01:59:42,120 --> 01:59:43,860
我能怎么办？
So what could I do?

2415
01:59:43,860 --> 01:59:48,800
这张幻灯片的语法是使用问号和冒号
Well, the syntax per this slide is to use a question mark and a colon

2416
01:59:48,800 --> 01:59:51,410
紧接着左括号 
immediately after the open parentheses.

2417
01:59:51,410 --> 01:59:52,910
不可否认 它看起来很奇怪 
It looks weird admittedly.

2418
01:59:52,910 --> 01:59:55,040
如果你们有编程经验
Those of you who have prior programming experience

2419
01:59:55,040 --> 01:59:59,300
我可能会从三元运算符中识别语法 执行if else all in one
might recognize the syntax from ternary operators, doing an if else all in one

2420
01:59:59,300 --> 01:59:59,960
线
line.

2421
01:59:59,960 --> 02:00:04,190
在插入语的开头加上一个问号冒号
A question mark colon at the beginning of that parenthetical

2422
02:00:04,190 --> 02:00:08,160
意思是 我用括号把这些东西组合在一起 
means, yes, I'm using parentheses to group these things together,

2423
02:00:08,160 --> 02:00:11,640
但不 你不需要去捕捉它们
but no, you do not need to capture them instead.

2424
02:00:11,640 --> 02:00:15,500
所以我现在可以把代码改回matches.group 1.
So I can change my code back now to matches.group 1.

2425
02:00:15,500 --> 02:00:18,260
我会在这里清空屏幕 运行twitter.py的python 
I'll clear my screen here, run python of twitter.py.

2426
02:00:18,260 --> 02:00:24,350
我将再次运行https://twitter.com/davidjmalan
I'll again run here https://twitter.com/davidjmalan

2427
02:00:24,350 --> 02:00:26,480
不管有没有www
with or without the www.

2428
02:00:26,480 --> 02:00:30,590
现在 我真的找回了那个用户名 
And now, I indeed get back that username.

2429
02:00:30,590 --> 02:00:37,280
对这些最后的技巧有什么问题吗？
Any questions, then, on these final techniques?

2430
02:00:37,280 --> 02:00:40,940
观众：首先 我们能不能把
AUDIENCE: So first of all, could we move the ^ right

2431
02:00:40,940 --> 02:00:44,270
在Twitter的开头 然后从那里开始阅读 
at the beginning of Twitter, and then just start reading from there,

2432
02:00:44,270 --> 02:00:49,700
然后在此之前摆脱所有其他的东西 
and then get rid of everything else before that, the kind of www issues

2433
02:00:49,700 --> 02:00:50,930
我们拥有的
that we had?

2434
02:00:50,930 --> 02:00:56,240
然后我的第二个问题是 我想 
And then my second question is, how would we use kind of, I guess,

2435
02:00:56,240 --> 02:01:01,640
一个列表或者一个字典来对.com之类的东西进行排序 
either a list or a dictionary to sort the .com kind of thing,

2436
02:01:01,640 --> 02:01:05,120
因为我们有. co.uk 和类似的东西 
because we have .co.uk, and that kind of stuff.

2437
02:01:05,120 --> 02:01:08,330
我们如何将其带入re函数？
How would we bring that into the re function?

2438
02:01:08,330 --> 02:01:09,830
大卫·马兰：一个很好的问题 但不是 
DAVID MALAN: A good question but no.

2439
02:01:09,830 --> 02:01:15,560
如果我把^移到twitter.com之前 并扔掉协议和www 
If I move the ^ before twitter.com and throw away the protocol and the www,

2440
02:01:15,560 --> 02:01:20,960
那么用户将不得不按字面意思键入twitter.com/username 
then the user is going to have to type in literally twitter.com/username.

2441
02:01:20,960 --> 02:01:23,040
他们甚至不能输入其他东西 
They can't even type in that other stuff.

2442
02:01:23,040 --> 02:01:25,170
因此 这将是一种倒退 是一种倒退 
So that would be a regression, a step back.

2443
02:01:25,170 --> 02:01:29,120
至于.com、.org和.edu等等 
As for the .com, the .org, and .edu, and so forth,

2444
02:01:29,120 --> 02:01:31,970
简短的答案是 这里有许多不同的解决方案 
the short answer is there's many different solutions here.

2445
02:01:31,970 --> 02:01:37,190
如果我想严格对待.com--假设Twitter可能拥有
If I wanted to be stringent about .com-- and suppose that Twitter probably owns

2446
02:01:37,190 --> 02:01:40,620
多个域名 尽管他们倾向于只使用这个域名 
multiple domain names, even though they tend to use just this one.

2447
02:01:40,620 --> 02:01:43,800
假设他们也有像.org这样的网站 
Suppose they have something like .org as well.

2448
02:01:43,800 --> 02:01:47,810
您可以在这里使用更多的括号 并执行类似这样的操作--com或org 
You could use more parentheses here and do something like this-- com or org.

2449
02:01:47,810 --> 02:01:50,270
我可能想进去加一个问号
I'd probably want to go in and add a question mark

2450
02:01:50,270 --> 02:01:53,060
冒号将其设置为非捕获 因为我不在乎
colon to make it non-capturing, because I don't care which

2451
02:01:53,060 --> 02:01:55,100
是的 我只想容忍这两种情况 
it is, I just want to tolerate both.

2452
02:01:55,100 --> 02:01:58,220
或者 我们可以抓住这一点 
Alternatively, we could capture that.

2453
02:01:58,220 --> 02:02:01,850
我们可以做这样的事情 我们做点+ 所以
We could do something like this, where we do dot + so as

2454
02:02:01,850 --> 02:02:03,410
才能真正捕捉到这一点 
to actually capture that.

2455
02:02:03,410 --> 02:02:05,570
然后我们可以做这样的事情 
And then we could do something like this.

2456
02:02:05,570 --> 02:02:13,640
如果matches.group 1现在等于com 那么我们可以支持这一点 
If matches.group 1 now equals equals com, then we could support this.

2457
02:02:13,640 --> 02:02:18,020
因此 您可以想象仅通过提取顶层
So you could imagine factoring out the logic just by extracting the Top-Level

2458
02:02:18,020 --> 02:02:21,410
域 或TLD 然后只需使用Python代码 也许是列表 也许
Domain, or TLD, and then just using Python code, maybe a list, maybe

2459
02:02:21,410 --> 02:02:24,860
一本词典 在正则表达式之外的其他地方进行验证 
a dictionary, to validate elsewhere, outside of the regex,

2460
02:02:24,860 --> 02:02:26,780
如果这真的是你所期待的 
if it's, in fact, what you expect.

2461
02:02:26,780 --> 02:02:28,700
不过 就目前而言 我们让事情变得简单 
For now, though, we kept things simple.

2462
02:02:28,700 --> 02:02:31,860
在这种情况下 我们只关注.com 
We focused only on the .com in this case.

2463
02:02:31,860 --> 02:02:33,767
让我们对这个程序做最后一次更改
Let's make one final change to this program

2464
02:02:33,767 --> 02:02:36,350
所以我们的定义更具体一点
so that we're being a little more specific with the definition

2465
02:02:36,350 --> 02:02:37,640
推特用户名的 
of a Twitter username.

2466
02:02:37,640 --> 02:02:41,000
事实证明 我们在这里有点太慷慨了 因此我们
It turns out that we're being a little too generous over here, whereby we're

2467
02:02:41,000 --> 02:02:43,280
接受一个或多个任何字符 
accepting one or more of any character.

2468
02:02:43,280 --> 02:02:45,050
我查看了Twitter的文档 
I checked the documentation for Twitter.

2469
02:02:45,050 --> 02:02:48,890
推特只支持字母表中的字母a到Z 
And Twitter only supports letters of the alphabet, a through Z,

2470
02:02:48,890 --> 02:02:53,370
数字0到9 或下划线 所以不只是点 
numbers 0 through 9, or underscores, so not just dot,

2471
02:02:53,370 --> 02:02:55,020
从字面上看 它是任何东西 
which is literally anything.

2472
02:02:55,020 --> 02:02:57,230
所以让我继续下去 在这里更准确地说 
So let me go ahead and be more precise here.

2473
02:02:57,230 --> 02:02:59,870
在我最后 让我继续说 
At the end of my string, let me go ahead and say,

2474
02:02:59,870 --> 02:03:03,510
方括号中的这组符号 
this set of symbols in square brackets.

2475
02:03:03,510 --> 02:03:08,058
接下来我会说a到Z 0到9 还有一个下划线 
I'm going to go ahead and say a through Z, 0 through 9, and an underscore.

2476
02:03:08,058 --> 02:03:10,100
因为 再说一次 这些是唯一有效的符号 
Because, again, those are the only valid symbols.

2477
02:03:10,100 --> 02:03:12,740
我不需要麻烦大写的A或小写的z 
I don't need to bother with an uppercase A or a lowercase z,

2478
02:03:12,740 --> 02:03:16,140
因为我们这里用的是RE.IGNORECASE 
because we're using re.IGNORECASE over here.

2479
02:03:16,140 --> 02:03:19,760
但我想确保我现在不仅能容忍一个或多个
But I want to make sure now that I tolerate not only one or more

2480
02:03:19,760 --> 02:03:24,260
这些符号在这里 但也可能是URL末尾的一些其他东西 
of these symbols here but also maybe some other stuff at the end of the URL.

2481
02:03:24,260 --> 02:03:27,710
我现在不介意有一个斜杠或一个问号 
I'm now going to be OK with there being a slash, or a question mark,

2482
02:03:27,710 --> 02:03:31,730
或URL结尾处的散列 所有这些都是URL中的有效符号 
or a hash at the end of the URL, all of which are valid symbols in a URL,

2483
02:03:31,730 --> 02:03:34,130
但我从推特的文件中得知 
but I know from the Twitter's documentation,

2484
02:03:34,130 --> 02:03:36,390
不是用户名的一部分 
are not part of the username.

2485
02:03:36,390 --> 02:03:36,890
好的 
All right.

2486
02:03:36,890 --> 02:03:39,770
现在 我将继续运行twitter.py one的蟒蛇
Now I'm going to go ahead and run python of twitter.py one

2487
02:03:39,770 --> 02:03:46,610
最后一次 也许输入https://twitter.com/davidjmalan 
final time, typing in https://twitter.com/davidjmalan, maybe

2488
02:03:46,610 --> 02:03:48,320
有 也许没有尾部的斜杠 
with, maybe without a trailing slash.

2489
02:03:48,320 --> 02:03:52,070
但希望 在我最大的手指交叉在这里 我现在要继续
But hopefully, with my biggest fingers crossed here, I'm going to go ahead now

2490
02:03:52,070 --> 02:03:56,630
然后按回车键 谢天谢地 我的用户名确实是davidjmaran 
and hit Enter, and thankfully my username is, indeed, davidjmalan.

2491
02:03:56,630 --> 02:03:59,300
那么 在正则表达式的世界里还有什么呢
So what more is there in the world of regular expressions

2492
02:03:59,300 --> 02:04:00,320
那这个自己的图书馆呢？
and this own library?

2493
02:04:00,320 --> 02:04:04,340
不只是re.earch和re.sub. 还有其他功能 
Not just re.search and also re.sub, there's other functions, too.

2494
02:04:04,340 --> 02:04:07,850
有re.plit 你可以通过它来拆分字符串 而不是
There's re.split, via which you can split a string, not

2495
02:04:07,850 --> 02:04:11,480
使用一个或多个特定字符 如逗号和空格 
using a specific character or characters like a comma and a space,

2496
02:04:11,480 --> 02:04:14,010
但也有多个角色 
but multiple characters as well.

2497
02:04:14,010 --> 02:04:16,550
甚至还有像re.findall这样的功能 
And there's even functions like re.findall,

2498
02:04:16,550 --> 02:04:20,540
它可以让您搜索同一图案的多个副本
which can allow you to search for multiple copies of the same pattern

2499
02:04:20,540 --> 02:04:23,120
在字符串中的不同位置 这样您可能可以
in different places in a string so that you can perhaps

2500
02:04:23,120 --> 02:04:25,200
操控不止一个人 
manipulate more than just one.

2501
02:04:25,200 --> 02:04:28,820
所以在一天结束的时候 你真的学会了一门完全不同的语言 
So at the end of the day now, you've really learned a whole other language,

2502
02:04:28,820 --> 02:04:31,700
就像正则表达式一样 我们已经在Python中使用了它们 
like that of regular expressions, and we've used them in Python.

2503
02:04:31,700 --> 02:04:35,670
但这些正则表达式实际上也存在于许多语言中 
But these regular expressions actually exist in so many languages, too,

2504
02:04:35,670 --> 02:04:38,930
其中包括Java、Java和Ruby等等 
among them JavaScript, and Java, and Ruby, and more.

2505
02:04:38,930 --> 02:04:42,300
所以有了这种新的语言 尽管它确实是神秘的
So with this new language, even though it's admittedly cryptic

2506
02:04:42,300 --> 02:04:45,050
当你第一次使用它时 你就拥有了这种新发现的能力
when you use it for the first time, you have this newfound ability

2507
02:04:45,050 --> 02:04:48,800
为了表达这些模式 同样 您可以使用它们来验证数据 
to express these patterns that, again, you can use to validate data,

2508
02:04:48,800 --> 02:04:53,310
清理数据 甚至从任何数据集中提取数据
to clean up data, or even extract data, and from any data set

2509
02:04:53,310 --> 02:04:54,470
你可能已经想好了 
you might have in mind.

2510
02:04:54,470 --> 02:04:55,830
本周就到这里吧 
That's it for this week.

2511
02:04:55,830 --> 02:04:58,570
我们下次再见 
We will see you next time.

