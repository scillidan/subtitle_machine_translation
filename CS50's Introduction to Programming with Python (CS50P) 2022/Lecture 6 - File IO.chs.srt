1
00:00:00,000 --> 00:00:00,998
[人群骚动]

2
00:00:00,998 --> 00:00:03,992
[音乐播放]

3
00:00:24,980 --> 00:00:27,710
大卫·马兰：好的 这是CS50的介绍

4
00:00:27,710 --> 00:00:29,030
用Python编程

5
00:00:29,030 --> 00:00:33,500
我的名字是David Malan 这是我们关于文件I/O、输入和输出的一周

6
00:00:33,500 --> 00:00:34,100
的文件 

7
00:00:34,100 --> 00:00:37,020
到目前为止 我们写的大多数程序

8
00:00:37,020 --> 00:00:39,800
将收集到的所有信息存储在内存中--

9
00:00:39,800 --> 00:00:43,910
也就是说 在变量或程序本身内部 

10
00:00:43,910 --> 00:00:46,520
一旦程序退出 你输入的任何东西

11
00:00:46,520 --> 00:00:49,220
你用那个程序做的一切都将丢失

12
00:00:49,220 --> 00:00:53,240
现在 当然 有了文件 在你的Mac或PC上 你可以保留信息

13
00:00:53,240 --> 00:00:53,960
长期.

14
00:00:53,960 --> 00:00:56,180
以及编程环境中的文件I/O

15
00:00:56,180 --> 00:01:00,170
都是关于编写可以读取的代码 即加载信息

16
00:01:00,170 --> 00:01:04,709
从或写入 也就是将信息保存到文件本身 

17
00:01:04,709 --> 00:01:06,980
所以让我们看看我们是否能从只有

18
00:01:06,980 --> 00:01:10,130
使用内存和变量等来实际写入

19
00:01:10,130 --> 00:01:14,150
代码 为我们保存一些文件 因此 数据持久 

20
00:01:14,150 --> 00:01:18,050
为了做到这一点 我建议我们首先考虑一个熟悉的数据 

21
00:01:18,050 --> 00:01:21,830
结构 一种我们以前见过的熟悉的变量类型 即列表 

22
00:01:21,830 --> 00:01:24,890
使用列表 我们可以存储多个片段

23
00:01:24,890 --> 00:01:26,180
过去的信息 

24
00:01:26,180 --> 00:01:28,620
使用一个变量 我们通常存储一个值 

25
00:01:28,620 --> 00:01:31,950
但是如果这个变量是一个列表 我们可以存储多个值 

26
00:01:31,950 --> 00:01:34,890
不幸的是 列表存储在计算机的内存中 

27
00:01:34,890 --> 00:01:38,390
所以一旦你的程序退出 甚至那些内容也会消失 

28
00:01:38,390 --> 00:01:40,920
但我们至少要给自己一个起点 

29
00:01:40,920 --> 00:01:42,440
所以我在VS Code这里 

30
00:01:42,440 --> 00:01:45,020
接下来我将创建一个简单的程序

31
00:01:45,020 --> 00:01:49,790
names.py的代码 一个只收集人名的程序 

32
00:01:49,790 --> 00:01:51,230
学生的名字 如果你愿意 

33
00:01:51,230 --> 00:01:53,330
一开始我会非常简单地

34
00:01:53,330 --> 00:01:56,390
以一种与我们过去所做的一致的方式来获取用户输入

35
00:01:56,390 --> 00:01:57,560
再打印出来

36
00:01:57,560 --> 00:02:01,910
我要说的是 名字等于输入 引号/不引号 

37
00:02:01,910 --> 00:02:03,170
你叫什么名字？

38
00:02:03,170 --> 00:02:06,350
从而将存储在一个名为name的变量中

39
00:02:06,350 --> 00:02:08,690
输入的返回值 一如既往 

40
00:02:08,690 --> 00:02:11,060
像往常一样 我将继续非常简单地

41
00:02:11,060 --> 00:02:14,090
打印出一个漂亮的f字符串 它说 你好 逗号 

42
00:02:14,090 --> 00:02:17,720
然后 用大括号把名字打印出来你好 大卫 你好 世界 

43
00:02:17,720 --> 00:02:20,060
不管是谁碰巧在使用这个程序 

44
00:02:20,060 --> 00:02:23,060
让我继续运行这篇文章 只是为了提醒自己应该期待什么 

45
00:02:23,060 --> 00:02:26,750
如果我运行名为names.py的python并按Enter键 像David一样输入我的名字 

46
00:02:26,750 --> 00:02:29,520
当然 我现在看到的是你好 逗号 大卫 

47
00:02:29,520 --> 00:02:32,720
但是 假设我们想要添加对一个名称的支持 

48
00:02:32,720 --> 00:02:35,870
但有多个名字--为了便于讨论 可能有三个名字

49
00:02:35,870 --> 00:02:39,740
这样我们就可以开始积累一些信息

50
00:02:39,740 --> 00:02:42,080
在这个项目中 所以它真的是

51
00:02:42,080 --> 00:02:46,190
一旦程序退出 如果我们继续扔掉它 那将是一个不利的方面 

52
00:02:46,190 --> 00:02:49,430
好吧 让我再说一遍名字 最上面的那个 

53
00:02:49,430 --> 00:02:52,820
让我主动地给自己一个变量 这一次叫做名字 

54
00:02:52,820 --> 00:02:53,510
复数 

55
00:02:53,510 --> 00:02:55,570
并将其设置为等于空列表 

56
00:02:55,570 --> 00:02:58,820
回想一下方括号符号 特别是如果里面什么都没有的话 

57
00:02:58,820 --> 00:03:03,140
我的意思是 给我一张空的清单 我们可以随着时间的推移添加一些东西 

58
00:03:03,140 --> 00:03:04,790
那么 我们还想补充些什么呢？

59
00:03:04,790 --> 00:03:07,130
好吧 让我们添加三个名字 每个名字都来自用户 

60
00:03:07,130 --> 00:03:11,930
让我这样说 为了在3的范围内下划线 

61
00:03:11,930 --> 00:03:16,160
让我继续并使用输入功能提示用户

62
00:03:16,160 --> 00:03:18,050
并将他们的名字放在这个变量中 

63
00:03:18,050 --> 00:03:25,400
然后使用列表语法 我可以说 姓名 将姓名添加到该列表中 

64
00:03:25,400 --> 00:03:28,370
现在 在这个名单上 我有了这个名字--

65
00:03:28,370 --> 00:03:30,200
1个、2个、3个 

66
00:03:30,200 --> 00:03:32,780
另外需要注意的是 我可以在这里使用一个变量 

67
00:03:32,780 --> 00:03:34,280
像我一样 这是传统的 

68
00:03:34,280 --> 00:03:37,640
但如果我实际上没有在任何后续行中显式使用i 

69
00:03:37,640 --> 00:03:40,730
我不妨使用下划线 这是一种毕多德式的惯例 

70
00:03:40,730 --> 00:03:43,790
实际上 如果我现在想把这个整理一下 

71
00:03:43,790 --> 00:03:46,610
注意我的name变量

72
00:03:46,610 --> 00:03:48,830
因为我给它赋值

73
00:03:48,830 --> 00:03:50,360
然后立即添加它 

74
00:03:50,360 --> 00:03:54,440
我可以通过去掉这个变量来进一步简化

75
00:03:54,440 --> 00:03:59,300
并立即追加input的返回值 

76
00:03:59,300 --> 00:04:01,888
我认为我们可以在设计方面走两条路 

77
00:04:01,888 --> 00:04:04,430
一方面 这是一个相当短的行 它的可读性 

78
00:04:04,430 --> 00:04:06,950
另一方面 如果我最终要改变这个短语 

79
00:04:06,950 --> 00:04:08,950
不是你的名字而是更长的

80
00:04:08,950 --> 00:04:11,390
我们可能想把它再分成两行 

81
00:04:11,390 --> 00:04:13,310
但现在 我认为它是相当可读的 

82
00:04:13,310 --> 00:04:17,180
在程序的后面 让我们把这些名字打印出来 

83
00:04:17,180 --> 00:04:20,540
但我们先把它们按字母顺序排序

84
00:04:20,540 --> 00:04:24,510
把它们收集起来 然后分类 打印出来 

85
00:04:24,510 --> 00:04:25,580
那我怎么做

86
00:04:25,580 --> 00:04:28,490
在Python中 在循环中对列表进行排序的最简单方法

87
00:04:28,490 --> 00:04:30,170
就是做这样的事

88
00:04:30,170 --> 00:04:32,780
因为名字中的名字

89
00:04:32,780 --> 00:04:33,410
肯等待

90
00:04:33,410 --> 00:04:34,910
我们先把名字排序 

91
00:04:34,910 --> 00:04:36,920
回想一下 有一个函数叫做sorted

92
00:04:36,920 --> 00:04:40,050
这将返回该列表的排序版本 

93
00:04:40,050 --> 00:04:44,960
现在让我们继续 打印出一个f字符串 再次 你好 

94
00:04:44,960 --> 00:04:47,623
方括号、名称、右引号 

95
00:04:47,623 --> 00:04:49,290
好吧 让我继续运行这个 

96
00:04:49,290 --> 00:04:52,910
所以names.py的Python 让我继续

97
00:04:52,910 --> 00:04:54,590
这次输入几个名字

98
00:04:54,590 --> 00:04:56,090
赫敏怎么样？

99
00:04:56,090 --> 00:04:57,680
哈利怎么样？

100
00:04:57,680 --> 00:04:58,940
罗恩呢

101
00:04:58,940 --> 00:05:02,190
注意它们不是按字母顺序排列的 

102
00:05:02,190 --> 00:05:04,910
但当我按下回车键 循环开始时 

103
00:05:04,910 --> 00:05:07,520
它会打印出来 你好 哈利 你好 赫敏 你好 

104
00:05:07,520 --> 00:05:10,310
罗恩 按顺序排列 

105
00:05:10,310 --> 00:05:13,730
当然 如果我再运行一次这个程序 

106
00:05:13,730 --> 00:05:14,420
迷路了是

107
00:05:14,420 --> 00:05:16,235
如果这是一个比这更大的项目 

108
00:05:16,235 --> 00:05:18,110
可能会很痛苦

109
00:05:18,110 --> 00:05:21,090
一次又一次地重复输入相同的信息 

110
00:05:21,090 --> 00:05:23,780
这不是很好吗 就像今天的大多数节目一样

111
00:05:23,780 --> 00:05:26,240
在手机、笔记本电脑、台式机或云上

112
00:05:26,240 --> 00:05:30,330
才能以某种方式保存这些信息？

113
00:05:30,330 --> 00:05:32,360
这就是文件I/O的用武之地 

114
00:05:32,360 --> 00:05:33,890
这就是文件的用武之地 

115
00:05:33,890 --> 00:05:37,910
它们是一种在你自己的手机或Mac上持久存储信息的方式 

116
00:05:37,910 --> 00:05:42,020
或者PC 或者某个云服务器的磁盘 这样当您

117
00:05:42,020 --> 00:05:44,010
请回来再次运行该程序 

118
00:05:44,010 --> 00:05:50,030
那么我们如何才能将这三个名字都保存在一个文件中 而不是

119
00:05:50,030 --> 00:05:52,627
不得不一次又一次地打字？

120
00:05:52,627 --> 00:05:54,710
让我继续简化这个文件 再一次 

121
00:05:54,710 --> 00:05:57,050
只给我自己一个名为name的变量 

122
00:05:57,050 --> 00:06:01,890
并将输入的返回值设置为等于该变量 

123
00:06:01,890 --> 00:06:04,550
那么你的名字是什么 和以前一样 引用/不引用 

124
00:06:04,550 --> 00:06:08,540
现在让我继续 让我用这个值做一些更多的事情 

125
00:06:08,540 --> 00:06:11,750
而不是简单地将其添加到列表或立即打印出来 

126
00:06:11,750 --> 00:06:14,030
让我们保存人名的值

127
00:06:14,030 --> 00:06:15,950
刚刚被输入到一个文件中 

128
00:06:15,950 --> 00:06:17,600
那么 我们该怎么做呢？

129
00:06:17,600 --> 00:06:20,600
在Python中 有一个名为OPEN的函数 它的用途是

130
00:06:20,600 --> 00:06:25,320
就是这样做 打开一个文件 但要以编程的方式打开它

131
00:06:25,320 --> 00:06:28,580
这样 作为程序员 您就可以真正从其中读取信息

132
00:06:28,580 --> 00:06:30,440
或向其写入信息 

133
00:06:30,440 --> 00:06:33,560
所以打开就像程序员的双击

134
00:06:33,560 --> 00:06:35,480
在Mac或PC上的图标上 

135
00:06:35,480 --> 00:06:37,580
但它是程序员的技术 因为它是

136
00:06:37,580 --> 00:06:40,070
允许您准确地指定您想要的内容

137
00:06:40,070 --> 00:06:42,980
从该文件读取或写入该文件 

138
00:06:42,980 --> 00:06:45,440
正式地说 它的文档在这里 您将

139
00:06:45,440 --> 00:06:48,037
注意它的用法相对简单明了 

140
00:06:48,037 --> 00:06:50,870
它最低限度只需要我们要打开的文件的名称

141
00:06:50,870 --> 00:06:53,700
以及我们希望如何打开它(可选) 

142
00:06:53,700 --> 00:06:57,650
所以让我回到VS代码这里 现在让我提议我这样做 

143
00:06:57,650 --> 00:07:01,190
我将继续调用这个名为Open 传递的函数

144
00:07:01,190 --> 00:07:05,150
在names.txt的参数中 这是我想要的文件名

145
00:07:05,150 --> 00:07:07,400
我想把所有这些名字都存储在 

146
00:07:07,400 --> 00:07:08,750
我可以随心所欲地叫它 

147
00:07:08,750 --> 00:07:10,670
但因为它将只是文本 所以

148
00:07:10,670 --> 00:07:13,280
按惯例称它为某物.txt 

149
00:07:13,280 --> 00:07:15,590
但我也要告诉Open函数

150
00:07:15,590 --> 00:07:18,150
我打算写进这份文件 

151
00:07:18,150 --> 00:07:21,530
作为第二个开场论点 我将从字面上说 引用/不引用 

152
00:07:21,530 --> 00:07:25,160
W 用于写入 这将告诉Open to Open

153
00:07:25,160 --> 00:07:28,070
该文件的方式将允许我更改内容 

154
00:07:28,070 --> 00:07:29,960
更好的是 如果它还不存在 

155
00:07:29,960 --> 00:07:32,030
它将为我创建文件 

156
00:07:32,030 --> 00:07:35,540
现在 OPEN返回所谓的文件句柄 

157
00:07:35,540 --> 00:07:39,020
一个允许我随后访问该文件的特定值 

158
00:07:39,020 --> 00:07:42,560
所以我将继续 将它标记为等于一个变量 如FILE 

159
00:07:42,560 --> 00:07:45,020
现在我要继续 非常简单地 

160
00:07:45,020 --> 00:07:47,640
把这个人的名字写到那个文件里 

161
00:07:47,640 --> 00:07:52,790
所以我将按字面意思输入FILE 这是链接到它的变量

162
00:07:52,790 --> 00:07:57,230
文件.WRITE 这是一个函数 也称为

163
00:07:57,230 --> 00:08:00,920
打开的文件允许我将该名称写入文件 

164
00:08:00,920 --> 00:08:03,500
最后 我将非常简单地

165
00:08:03,500 --> 00:08:07,310
继续并说 文件.关闭 这将关闭并有效地保存

166
00:08:07,310 --> 00:08:08,092
那份文件 

167
00:08:08,092 --> 00:08:11,300
所以这里的这三行代码基本上是程序员的等价物

168
00:08:11,300 --> 00:08:13,820
要在Mac或PC上双击图标 

169
00:08:13,820 --> 00:08:16,760
在Microsoft Word或其他程序中进行一些更改 

170
00:08:16,760 --> 00:08:18,020
然后依次转到文件、保存 

171
00:08:18,020 --> 00:08:21,560
我们只用这三行代码来实现这一点 

172
00:08:21,560 --> 00:08:24,210
现在 让我们来看看这是如何运作的 

173
00:08:24,210 --> 00:08:30,440
现在让我继续运行名为.py的python并按Enter键 

174
00:08:30,440 --> 00:08:31,740
让我们输入一个名字 

175
00:08:31,740 --> 00:08:34,789
我会输入赫敏 回车 

176
00:08:34,789 --> 00:08:37,370
好吧 她最后去了哪里？

177
00:08:37,370 --> 00:08:41,630
好了 现在让我继续输入names.txt的代码 

178
00:08:41,630 --> 00:08:43,850
这是一个现在恰好存在的文件

179
00:08:43,850 --> 00:08:45,950
因为我是在写入模式下打开的 

180
00:08:45,950 --> 00:08:49,700
如果我在标签里打开这个 我们会看到赫敏 

181
00:08:49,700 --> 00:08:52,520
好了 让我们再运行一次names.py 

182
00:08:52,520 --> 00:08:57,290
我将继续运行names.py的python 回车 这一次 

183
00:08:57,290 --> 00:08:58,760
我来打哈里 

184
00:08:58,760 --> 00:09:00,590
让我再运行一次 

185
00:09:00,590 --> 00:09:02,480
这一次 我将输入罗恩 

186
00:09:02,480 --> 00:09:07,010
现在让我转到names.txt 希望我能在那里看到所有三个

187
00:09:07,010 --> 00:09:08,570
他们在这里 

188
00:09:08,570 --> 00:09:09,650
但是没有 

189
00:09:09,650 --> 00:09:12,350
我刚真的看到了罗恩 

190
00:09:12,350 --> 00:09:16,250
怎么解释赫敏和哈利的遭遇 

191
00:09:16,250 --> 00:09:19,040
即使我很确定我已经运行了三次程序 

192
00:09:19,040 --> 00:09:24,170
我确实写了把他们的名字写到那个文件里的代码？

193
00:09:24,170 --> 00:09:26,425
你觉得这是怎么回事？

194
00:09:26,425 --> 00:09:28,550
观众：我想是因为我们没有附加它们 

195
00:09:28,550 --> 00:09:30,650
我们应该把名字加上去 

196
00:09:30,650 --> 00:09:34,430
因为我们是直接写的 它是在删除旧的内容 

197
00:09:34,430 --> 00:09:40,605
它将替换为我们提到的最后一组字符 

198
00:09:40,605 --> 00:09:41,480
大卫·马兰：没错 

199
00:09:41,480 --> 00:09:44,240
不幸的是 引号/不引号w有点危险 

200
00:09:44,240 --> 00:09:46,160
它不仅会为您创建文件 

201
00:09:46,160 --> 00:09:49,250
它还将为您重新创建文件 每次您

202
00:09:49,250 --> 00:09:50,610
在该模式下打开文件 

203
00:09:50,610 --> 00:09:52,940
所以如果你打开一次文件并写给赫敏 

204
00:09:52,940 --> 00:09:54,478
正如我们所看到的 这一切运行得很好 

205
00:09:54,478 --> 00:09:57,020
但如果你再为哈利做一次 如果你再为罗恩做一次 

206
00:09:57,020 --> 00:09:58,100
代码起作用了 

207
00:09:58,100 --> 00:10:02,240
但每一次 它都会打开文件并用全新的内容重新创建 

208
00:10:02,240 --> 00:10:04,940
所以我们有赫敏的一个版本 和哈利的一个版本 

209
00:10:04,940 --> 00:10:06,650
和罗恩的最后一个版本 

210
00:10:06,650 --> 00:10:09,500
但在理想情况下 我认为我们可能想要追加 

211
00:10:09,500 --> 00:10:11,960
正如维沙尔所说 这些名字中的每一个都被记录在文件中 

212
00:10:11,960 --> 00:10:15,630
不仅仅是重写--也就是说 每次都覆盖文件 

213
00:10:15,630 --> 00:10:16,520
那么我该怎么做呢？

214
00:10:16,520 --> 00:10:18,500
实际上 这是一个相对容易解决的问题 

215
00:10:18,500 --> 00:10:20,610
让我继续按如下方式执行此操作 

216
00:10:20,610 --> 00:10:23,630
我将首先删除旧版本的names.txt 

217
00:10:23,630 --> 00:10:26,550
现在我要更改我的代码来执行此操作 

218
00:10:26,550 --> 00:10:29,840
我要将w 引用/非引用更改为一个 

219
00:10:29,840 --> 00:10:32,990
引用/不引用--a表示追加 意思是添加到底部 

220
00:10:32,990 --> 00:10:34,940
到底部 到底部 一次又一次 

221
00:10:34,940 --> 00:10:39,320
现在 让我继续并重新运行名为names.py的python 回车 

222
00:10:39,320 --> 00:10:41,990
我将再次和赫敏从头开始

223
00:10:41,990 --> 00:10:44,090
因为我正在创建新的文件 

224
00:10:44,090 --> 00:10:49,700
请注意 如果我现在执行names.txt代码 回车 我们将执行

225
00:10:49,700 --> 00:10:51,170
去看看赫敏回来了 

226
00:10:51,170 --> 00:10:54,590
所以在删除文件后 它确实被重新创建了 

227
00:10:54,590 --> 00:10:56,670
尽管我使用的是Append 这很好 

228
00:10:56,670 --> 00:11:00,380
但现在让我们看看当我回到我的终端时会发生什么 

229
00:11:00,380 --> 00:11:03,260
这一次 我再次运行了名为.py的蟒蛇--

230
00:11:03,260 --> 00:11:04,850
这一次 输入哈里 

231
00:11:04,850 --> 00:11:06,720
让我再运行一次--

232
00:11:06,720 --> 00:11:08,120
这一次 输入罗恩 

233
00:11:08,120 --> 00:11:10,850
所以希望这一次 在第二个选项卡中 names.txt 

234
00:11:10,850 --> 00:11:13,670
我现在应该看到他们三个人 

235
00:11:13,670 --> 00:11:17,030
但是 但是这看起来并不理想 

236
00:11:17,030 --> 00:11:21,213
我到底做错了什么？

237
00:11:21,213 --> 00:11:23,630
我有种感觉 尽管三个名字都在那里 

238
00:11:23,630 --> 00:11:26,180
除非你能把它们读回来 否则读起来不会很容易

239
00:11:26,180 --> 00:11:29,300
知道每个名字的结尾和开头 

240
00:11:29,300 --> 00:11:33,200
观众：英文格式不正确 

241
00:11:33,200 --> 00:11:35,510
英文格式不正确 

242
00:11:35,510 --> 00:11:36,620
这是不正确的 

243
00:11:36,620 --> 00:11:38,540
它将它们连接在一起 

244
00:11:38,540 --> 00:11:40,910
大卫·马兰：是的 

245
00:11:40,910 --> 00:11:43,070
嗯 它似乎是串联在一起的 

246
00:11:43,070 --> 00:11:46,280
但从技术上讲 它只是添加到文件中--

247
00:11:46,280 --> 00:11:48,710
先是赫敏 然后是哈里 然后是罗恩 

248
00:11:48,710 --> 00:11:50,840
它的效果是将它们背靠背地结合在一起 

249
00:11:50,840 --> 00:11:52,298
但就本质而言 它不是串联的 

250
00:11:52,298 --> 00:11:53,690
这真的只是一种附加 

251
00:11:53,690 --> 00:11:55,370
让我们转到另一只手 

252
00:11:55,370 --> 00:11:58,100
我到底做错了什么？

253
00:11:58,100 --> 00:12:01,010
或者说 我该如何修复呢？

254
00:12:01,010 --> 00:12:05,000
如果每个名字之间都有一些空隙就好了 

255
00:12:05,000 --> 00:12:07,460
这样我们就能读得更清楚了 

256
00:12:07,460 --> 00:12:08,210
观众：你好 

257
00:12:08,210 --> 00:12:13,160
在写新名字之前 我们应该加一行 

258
00:12:13,160 --> 00:12:13,910
大卫·马兰：很好 

259
00:12:13,910 --> 00:12:15,470
我们想自己增加一条新线路 

260
00:12:15,470 --> 00:12:19,430
因此 尽管默认打印、调用、总是自动输出 

261
00:12:19,430 --> 00:12:20,990
以反斜杠n结尾的一行 

262
00:12:20,990 --> 00:12:24,410
除非我们用名为end的命名参数覆盖它 

263
00:12:24,410 --> 00:12:25,640
WRITE不能做到这一点 

264
00:12:25,640 --> 00:12:26,810
WRITE从字面上理解你 

265
00:12:26,810 --> 00:12:29,120
如果你说写给赫敏 那就完了 

266
00:12:29,120 --> 00:12:30,680
你得到的是通过e的H 

267
00:12:30,680 --> 00:12:33,740
如果你说 写哈里 你得到的H通过y 

268
00:12:33,740 --> 00:12:36,810
您不会自动获得任何额外的新行 

269
00:12:36,810 --> 00:12:40,760
所以如果你想在每个名字的末尾加上一行 

270
00:12:40,760 --> 00:12:42,150
我们必须手动完成 

271
00:12:42,150 --> 00:12:46,350
因此 让我再次关闭names.txt 并删除当前文件 

272
00:12:46,350 --> 00:12:48,200
让我回到我的代码上来 

273
00:12:48,200 --> 00:12:49,920
我可以用很多方法来解决这个问题 

274
00:12:49,920 --> 00:12:51,712
但我要继续做这件事 

275
00:12:51,712 --> 00:12:55,700
我要写出一个包含名称和反斜杠的f字符串

276
00:12:55,700 --> 00:12:56,522
N在末尾 

277
00:12:56,522 --> 00:12:57,980
我们可以用不同的方式来做这件事 

278
00:12:57,980 --> 00:13:00,952
我们可以手动打印新行或其他一些技术 

279
00:13:00,952 --> 00:13:04,160
但我会继续使用我的f弦 就像我习惯做的那样 

280
00:13:04,160 --> 00:13:07,290
只需同时打印名称和新行即可 

281
00:13:07,290 --> 00:13:11,150
现在 我将继续向下移动到我的终端窗口 运行names.py的python

282
00:13:11,150 --> 00:13:12,230
再次输入 

283
00:13:12,230 --> 00:13:13,790
我们将输入赫敏 

284
00:13:13,790 --> 00:13:15,890
我要再运行一次 输入Harry 

285
00:13:15,890 --> 00:13:18,500
我要再打一次 这次是罗恩 

286
00:13:18,500 --> 00:13:22,430
现在 我将运行names.txt代码并打开该文件 

287
00:13:22,430 --> 00:13:25,730
现在 文件看起来更干净了 

288
00:13:25,730 --> 00:13:28,130
事实上 我把每一个名字都写在自己的行上

289
00:13:28,130 --> 00:13:32,810
以及一个行尾 这确保了我们可以分开一个

290
00:13:32,810 --> 00:13:33,750
从另一个方面 

291
00:13:33,750 --> 00:13:38,030
现在 如果我在编写代码 我打赌我可以解析 也就是读取

292
00:13:38,030 --> 00:13:39,950
通过查看差异来查看前一个文件

293
00:13:39,950 --> 00:13:41,727
在小写字母和大写字母之间 

294
00:13:41,727 --> 00:13:43,310
但这很快就会变得一团糟 

295
00:13:43,310 --> 00:13:46,640
一般来说 当数据长期存储在文件中时 

296
00:13:46,640 --> 00:13:50,750
你可能应该以某种方式干净利落地做这件事 就像一次做一个名字 

297
00:13:50,750 --> 00:13:52,662
好吧 我们现在回去吧 我会向你求婚

298
00:13:52,662 --> 00:13:54,620
这段代码现在工作正常 但我们

299
00:13:54,620 --> 00:13:56,300
可以把它设计得更好一点 

300
00:13:56,300 --> 00:14:00,410
事实证明 在编写代码时 有时很容易忘记

301
00:14:00,410 --> 00:14:01,460
关闭文件 

302
00:14:01,460 --> 00:14:03,770
有时 这不一定是什么大事 

303
00:14:03,770 --> 00:14:05,450
但有时 它也会带来问题 

304
00:14:05,450 --> 00:14:08,210
文件可能被破坏或意外删除等 

305
00:14:08,210 --> 00:14:09,990
这取决于代码中发生的情况 

306
00:14:09,990 --> 00:14:14,660
因此 严格来说 您并不需要亲自调用Close来关闭文件

307
00:14:14,660 --> 00:14:16,550
如果你采取另一种方法 

308
00:14:16,550 --> 00:14:21,950
当操纵文件时 更像是在做这件事 

309
00:14:21,950 --> 00:14:25,370
要介绍另一个关键词 非常简单 

310
00:14:25,370 --> 00:14:29,220
允许您在此上下文中指定 

311
00:14:29,220 --> 00:14:33,030
我要你打开并自动关闭一些文件 

312
00:14:33,030 --> 00:14:34,520
那么 我们如何使用呢？

313
00:14:34,520 --> 00:14:35,970
它看起来就像这样 

314
00:14:35,970 --> 00:14:37,430
让我在这里回到我的代码 

315
00:14:37,430 --> 00:14:39,320
我已经摆脱了封闭线 

316
00:14:39,320 --> 00:14:41,360
现在我只想这么说 

317
00:14:41,360 --> 00:14:44,240
我不会说 档案等于打开 而是

318
00:14:44,240 --> 00:14:48,290
要说 开放 然后像以前一样的论点 

319
00:14:48,290 --> 00:14:51,860
有点奇怪的是 我要把变量放在代码行的末尾 

320
00:14:51,860 --> 00:14:52,400
为什么？

321
00:14:52,400 --> 00:14:54,080
这就是做这件事的方式 

322
00:14:54,080 --> 00:14:56,840
你说 用 你调用有问题的函数 

323
00:14:56,840 --> 00:15:00,320
然后输入As并指定变量的名称

324
00:15:00,320 --> 00:15:03,110
赋值为OPEN的返回值 

325
00:15:03,110 --> 00:15:05,870
然后我将继续并缩进下面的线 

326
00:15:05,870 --> 00:15:08,330
写这个名字的那行代码

327
00:15:08,330 --> 00:15:12,770
现在是在这个With语句的上下文中 它只是确保 

328
00:15:12,770 --> 00:15:15,560
自动地 如果我在这个文件中有更多的代码

329
00:15:15,560 --> 00:15:19,970
向下不再缩进 文件将自动关闭

330
00:15:19,970 --> 00:15:22,130
执行完第4行后立即执行 

331
00:15:22,130 --> 00:15:24,050
所以它不会改变刚刚发生的事情 

332
00:15:24,050 --> 00:15:26,900
但它确实自动化了至少为我们关闭东西的过程

333
00:15:26,900 --> 00:15:31,490
只是为了确保我不会忘记 这样就不会出什么差错 

334
00:15:31,490 --> 00:15:35,630
但是现在 假设我想要从文件中读取这些名字 

335
00:15:35,630 --> 00:15:38,580
到目前为止 我所做的只是编写将名称写入文件的代码 

336
00:15:38,580 --> 00:15:41,720
但现在 让我们假设我们在文件中有所有这些名字 

337
00:15:41,720 --> 00:15:43,880
见鬼 让我们继续 再加一个 

338
00:15:43,880 --> 00:15:47,270
接下来让我再运行一次--python of names.py 

339
00:15:47,270 --> 00:15:49,680
让我们把德拉科加入到这个组合中 

340
00:15:49,680 --> 00:15:52,100
所以现在我们有了这四个名字 

341
00:15:52,100 --> 00:15:54,650
我们可能想要怎么把它们读回来？

342
00:15:54,650 --> 00:15:57,203
好吧 让我提议我们现在进入name.py 

343
00:15:57,203 --> 00:15:59,120
或者我们可以完全创建另一个项目 

344
00:15:59,120 --> 00:16:02,660
但我会继续重复使用同一个名字 只是为了让我们专注于这个问题 

345
00:16:02,660 --> 00:16:07,850
现在 我将编写代码 用Hermione读取现有文件 

346
00:16:07,850 --> 00:16:10,550
哈利、罗恩和德拉科在一起 

347
00:16:10,550 --> 00:16:11,802
我该怎么做呢？

348
00:16:11,802 --> 00:16:13,010
嗯 它在精神上是相似的 

349
00:16:13,010 --> 00:16:15,605
这一次 我将从Open开始 

350
00:16:15,605 --> 00:16:18,230
然后第一个参数将是文件的名称

351
00:16:18,230 --> 00:16:19,910
我想打开它 就像以前一样 

352
00:16:19,910 --> 00:16:23,780
我将打开它 这一次 在读模式下--引用/不引用 r 

353
00:16:23,780 --> 00:16:27,360
而读取文件只意味着加载它 而不是保存它 

354
00:16:27,360 --> 00:16:30,462
我将为返回值文件命名 

355
00:16:30,462 --> 00:16:31,670
现在我要这么做了 

356
00:16:31,670 --> 00:16:33,462
我有很多方法可以做到这一点 

357
00:16:33,462 --> 00:16:37,100
但是 一次从文件中读取所有行的一种方法是这样的 

358
00:16:37,100 --> 00:16:39,230
让我声明一个名为LINES的变量 

359
00:16:39,230 --> 00:16:42,680
让我访问该文件并调用一个函数或方法

360
00:16:42,680 --> 00:16:44,730
它附带了一种叫做Readline的东西 

361
00:16:44,730 --> 00:16:47,720
因此 如果您阅读了有关文件I/O的文档 

362
00:16:47,720 --> 00:16:51,740
你会看到打开文件有一种特殊的方法 它在生活中的目的是

363
00:16:51,740 --> 00:16:56,550
就是读取文件中的所有行并将它们作为列表返回给我 

364
00:16:56,550 --> 00:16:59,750
这行2所做的就是读取所有行

365
00:16:59,750 --> 00:17:03,230
将它们存储在一个名为LINES的变量中 

366
00:17:03,230 --> 00:17:05,839
现在 假设我想遍历所有这些行

367
00:17:05,839 --> 00:17:07,760
并打印出每一个名字 

368
00:17:07,760 --> 00:17:12,349
对于每行中的行 这只是Python中循环的标准 

369
00:17:12,349 --> 00:17:13,880
作为一个列表的行 

370
00:17:13,880 --> 00:17:16,760
Line是将自动设置的变量

371
00:17:16,760 --> 00:17:17,930
每一条线路 

372
00:17:17,930 --> 00:17:22,609
让我继续打印出来 哦 你好 逗号 

373
00:17:22,609 --> 00:17:25,750
然后我会把这行打印出来 

374
00:17:25,750 --> 00:17:30,790
好的 现在让我打开终端窗口 运行names.py的python--

375
00:17:30,790 --> 00:17:34,360
我没有删除names.txt 所以它仍然包含所有四个

376
00:17:34,360 --> 00:17:38,590
然后按回车键 这还不错 

377
00:17:38,590 --> 00:17:41,290
但这里有点难看

378
00:17:41,290 --> 00:17:42,430
怎么回事？

379
00:17:42,430 --> 00:17:45,940
当我运行names.py时 它在说你好 赫敏 哈利 罗恩 

380
00:17:45,940 --> 00:17:46,540
德拉科 

381
00:17:46,540 --> 00:17:50,640
但现在这两条线之间有了差距 

382
00:17:50,640 --> 00:17:53,100
怎么解释这种症状？

383
00:17:53,100 --> 00:17:55,230
如果没有别的 它只是看起来很丑 

384
00:17:55,230 --> 00:17:57,360
观众：这是因为在文本文件中 

385
00:17:57,360 --> 00:18:01,620
在这些名字之间有了新的线符号

386
00:18:01,620 --> 00:18:05,850
打印总是在末尾添加另一个新行 

387
00:18:05,850 --> 00:18:08,695
所以你用同样的符号两次 

388
00:18:08,695 --> 00:18:09,570
大卫·马兰：完美 

389
00:18:09,570 --> 00:18:12,460
这是一个很好的bug的例子 一个程序中的错误 

390
00:18:12,460 --> 00:18:14,760
但如果你想想这些基本原则 

391
00:18:14,760 --> 00:18:18,103
比如我使用的每一行代码是如何工作的

392
00:18:18,103 --> 00:18:21,270
你应该能够推理 就像里帕尔说的那样 好吧 

393
00:18:21,270 --> 00:18:24,450
那么 这些新行中的一行来自每个名称后面的文件 

394
00:18:24,450 --> 00:18:26,760
然后 当然 印刷 所有这些周后 

395
00:18:26,760 --> 00:18:29,370
还在免费给我们额外的新产品

396
00:18:29,370 --> 00:18:31,530
所以有几个可能的解决方案 

397
00:18:31,530 --> 00:18:34,110
我当然可以做到这一点 我们过去已经做到了 

398
00:18:34,110 --> 00:18:38,040
并传入一个命名参数来打印 比如end="" 

399
00:18:38,040 --> 00:18:39,330
这也没什么

400
00:18:39,330 --> 00:18:41,730
我会说得更好一点

401
00:18:41,730 --> 00:18:46,530
要做到这一点 剥离线的末端 

402
00:18:46,530 --> 00:18:50,370
所以打印机处理打印的一切 人的

403
00:18:50,370 --> 00:18:52,050
新的名字 新的路线 

404
00:18:52,050 --> 00:18:55,500
但你只是剥离了真正的实现 

405
00:18:55,500 --> 00:18:56,700
文件中的细节 

406
00:18:56,700 --> 00:19:01,420
我们选择在我的文本文件中使用新的行来将一个名称与另一个名称分开 

407
00:19:01,420 --> 00:19:05,040
所以可以说 它在设计上应该更干净一点

408
00:19:05,040 --> 00:19:07,740
把它剥下来然后让打印机打印出来

409
00:19:07,740 --> 00:19:09,283
什么才是真正的名字

410
00:19:09,283 --> 00:19:10,950
但这最终是一个设计决定 

411
00:19:10,950 --> 00:19:14,340
效果将是完全相同的 

412
00:19:14,340 --> 00:19:18,540
好的 如果我要打开这个文件并阅读所有行

413
00:19:18,540 --> 00:19:21,870
然后遍历所有这些行并将其打印出来 

414
00:19:21,870 --> 00:19:23,910
我可以把这些合并成一件事

415
00:19:23,910 --> 00:19:26,130
因为 现在 我做的工作是原来的两倍 

416
00:19:26,130 --> 00:19:30,300
我读了所有的行 然后迭代了所有的行

417
00:19:30,300 --> 00:19:32,140
把它们都打印出来 

418
00:19:32,140 --> 00:19:34,770
在Python中 使用文件 您实际上可以做到这一点 

419
00:19:34,770 --> 00:19:37,060
我要抹去几乎所有这些线条

420
00:19:37,060 --> 00:19:39,960
现在 只在顶部保持声明 

421
00:19:39,960 --> 00:19:45,960
在这个With语句的内部 我要说的是 在文件中的行 

422
00:19:45,960 --> 00:19:50,872
继续打印 引号/非引号 Hello 逗号 然后line e.rstri.

423
00:19:50,872 --> 00:19:53,830
所以我要采取的方法是剥离这条线的末端 

424
00:19:53,830 --> 00:19:57,130
但请注意 可以说 这是多么优雅 

425
00:19:57,130 --> 00:19:59,320
我已经打开了第1行中的文件 

426
00:19:59,320 --> 00:20:01,860
如果我想遍历文件中的每一行 

427
00:20:01,860 --> 00:20:05,280
我不需要非常明确地读完所有的台词 

428
00:20:05,280 --> 00:20:06,900
然后迭代所有行 

429
00:20:06,900 --> 00:20:08,440
我可以把这些整合成一个想法 

430
00:20:08,440 --> 00:20:11,407
在Python中 您可以简单地说 对于文件中的行 

431
00:20:11,407 --> 00:20:14,490
这将产生如下效果：给出一个迭代的for循环

432
00:20:14,490 --> 00:20:18,240
在文件中的每一行上 一次一行 在每次迭代中 

433
00:20:18,240 --> 00:20:22,110
将该变量行的值更新为Hermione 

434
00:20:22,110 --> 00:20:24,990
然后是哈利 然后是罗恩 然后是德拉科 

435
00:20:24,990 --> 00:20:28,080
因此 这也是Python吸引人的方面之一

436
00:20:28,080 --> 00:20:32,140
它读起来很像英语--对于文件中的行 打印这个 

437
00:20:32,140 --> 00:20:35,190
这样写的话会更紧凑一些 

438
00:20:35,190 --> 00:20:38,580
好吧 但是 如果我不想要这种行为呢？

439
00:20:38,580 --> 00:20:42,450
因为现在请注意 如果我运行names.py的python 它是正确的 

440
00:20:42,450 --> 00:20:45,060
我看到了每个人的名字和每个人的问候 

441
00:20:45,060 --> 00:20:47,320
而且中间没有额外的空间 

442
00:20:47,320 --> 00:20:52,440
不过 说起来有点难度 我真的希望我们能把这些问候整理好 

443
00:20:52,440 --> 00:20:56,610
真的 我想先见见德拉科 然后是哈利 然后是赫敏 然后是罗恩 

444
00:20:56,610 --> 00:20:58,890
无论它们在文件中的出现顺序如何 

445
00:20:58,890 --> 00:21:02,127
当然 我可以进入文件并手动更改文件 

446
00:21:02,127 --> 00:21:03,960
但如果该文件随着时间的推移而变化

447
00:21:03,960 --> 00:21:06,203
关于谁在程序中输入他们的名字 

448
00:21:06,203 --> 00:21:07,620
这真的不是一个好的解决方案 

449
00:21:07,620 --> 00:21:10,412
在代码中 我应该能够加载文件 无论它看起来是什么样子

450
00:21:10,412 --> 00:21:12,930
就像 然后一下子把它们分类好 

451
00:21:12,930 --> 00:21:17,100
现在 这里有一个不做我刚刚做的事情的理由 

452
00:21:17,100 --> 00:21:21,510
我无法遍历文件中的每一行并将其打印出来

453
00:21:21,510 --> 00:21:23,550
但要提前把所有东西都分类好 

454
00:21:23,550 --> 00:21:27,750
从逻辑上讲 如果我一次查看一行并打印出来 

455
00:21:27,750 --> 00:21:29,310
现在分类已经太晚了 

456
00:21:29,310 --> 00:21:32,970
我真的需要先阅读所有行 而不是打印它们 

457
00:21:32,970 --> 00:21:34,990
对它们进行分类 然后打印出来 

458
00:21:34,990 --> 00:21:38,110
因此 我们必须后退一步 现在才能添加这一新功能 

459
00:21:38,110 --> 00:21:39,340
那么我该怎么做呢？

460
00:21:39,340 --> 00:21:42,030
好吧 让我把以前的一些想法结合起来 

461
00:21:42,030 --> 00:21:44,310
让我继续下去 重新开始吧 

462
00:21:44,310 --> 00:21:48,330
让我给自己一个名为名字的列表 并给它分配一个空列表 

463
00:21:48,330 --> 00:21:52,140
这样我就有了一个变量 用来累加所有这些行 

464
00:21:52,140 --> 00:21:56,550
现在让我打开文件 打开文件 引用/取消引用 名称.txt 

465
00:21:56,550 --> 00:21:58,840
事实证明 我可以把这个收紧一点 

466
00:21:58,840 --> 00:22:00,960
事实证明 如果你打开一个文件来阅读它 

467
00:22:00,960 --> 00:22:03,420
您不需要指定、引用/取消引用、r 

468
00:22:03,420 --> 00:22:05,130
这就是隐含的默认情况 

469
00:22:05,130 --> 00:22:08,160
因此 您只需说一句 打开names.txt 就可以让事情变得更紧密 

470
00:22:08,160 --> 00:22:10,680
您将能够读取该文件 但不能写入它 

471
00:22:10,680 --> 00:22:13,590
和前面一样 我将给自己一个名为FILE的变量 

472
00:22:13,590 --> 00:22:17,730
对于文件中的行 我将以相同的方式迭代文件 

473
00:22:17,730 --> 00:22:21,450
但我不是打印每一行 而是这样做 

474
00:22:21,450 --> 00:22:25,170
我要把我的名单附加到名单上 

475
00:22:25,170 --> 00:22:27,930
这是附加到内存中的列表中的 

476
00:22:27,930 --> 00:22:30,617
而不是附加到文件本身 

477
00:22:30,617 --> 00:22:32,700
我将继续添加当前行 

478
00:22:32,700 --> 00:22:35,400
不过 最后我要把新台词去掉 

479
00:22:35,400 --> 00:22:39,600
所以我要加到这张名单上的只有每个学生的名字 

480
00:22:39,600 --> 00:22:42,660
现在我可以使用以前熟悉的技术了 

481
00:22:42,660 --> 00:22:46,740
让我跳过这个WITH语句 因为现在我已经阅读了整个文件 

482
00:22:46,740 --> 00:22:47,310
大概是吧 

483
00:22:47,310 --> 00:22:50,238
所以当我读完第4行和第5行时 

484
00:22:50,238 --> 00:22:52,530
一次又一次地 对于文件中的每一行 

485
00:22:52,530 --> 00:22:53,610
我已经看完文件了 

486
00:22:53,610 --> 00:22:54,390
它可以关闭 

487
00:22:54,390 --> 00:22:57,870
我现在将所有学生的名字都放在这个list变量中 

488
00:22:57,870 --> 00:22:58,890
让我来做吧 

489
00:22:58,890 --> 00:23:04,110
对于输入的名称 不仅是名称 而且是已排序的名称 

490
00:23:04,110 --> 00:23:08,250
使用我们的Python函数排序 它就是这样做的 并打印出来 

491
00:23:08,250 --> 00:23:10,950
引号/非引号 带有f字符串 您好 逗号 

492
00:23:10,950 --> 00:23:13,780
现在我要输入括号名称 

493
00:23:13,780 --> 00:23:15,700
那么现在 我做了什么？

494
00:23:15,700 --> 00:23:18,060
我从一开始就创建了一个列表 只是

495
00:23:18,060 --> 00:23:20,010
所以我有一个地方来收集我的数据 

496
00:23:20,010 --> 00:23:23,910
然后 在第3行到第5行 从上到下迭代文件 

497
00:23:23,910 --> 00:23:27,000
逐行阅读 一次读一行 去掉新行

498
00:23:27,000 --> 00:23:29,200
只把这名学生的名字加到这个名单上 

499
00:23:29,200 --> 00:23:32,280
我这么做的原因是为了在7号线上 

500
00:23:32,280 --> 00:23:35,850
我可以对所有这些名字进行排序 因为它们都在内存中 

501
00:23:35,850 --> 00:23:37,450
并按顺序打印出来 

502
00:23:37,450 --> 00:23:40,720
我需要将它们全部加载到内存中 然后才能对它们进行排序 

503
00:23:40,720 --> 00:23:42,720
否则 我会过早地把它们打印出来 

504
00:23:42,720 --> 00:23:45,240
德拉科最终会成为最后一名 而不是第一名 

505
00:23:45,240 --> 00:23:48,720
因此 让我继续在我的终端窗口中运行names.py

506
00:23:48,720 --> 00:23:50,280
现在 然后按Enter键 

507
00:23:50,280 --> 00:23:51,360
这就对了 

508
00:23:51,360 --> 00:23:54,900
相同的四个问候列表 但现在它们被排序了 

509
00:23:54,900 --> 00:23:56,460
这是一种非常常见的技术 

510
00:23:56,460 --> 00:23:58,710
在处理文件和信息时更多

511
00:23:58,710 --> 00:24:03,300
通常 如果您想以某种方式更改数据 例如对其进行排序 

512
00:24:03,300 --> 00:24:06,690
在程序的顶部创建某种变量 比如列表 

513
00:24:06,690 --> 00:24:10,620
在其中添加或附加信息只是为了在一个地方收集信息 

514
00:24:10,620 --> 00:24:14,070
然后用这些收藏和清单做一些有趣的事情 

515
00:24:14,070 --> 00:24:16,140
正是我在这里所做的 

516
00:24:16,140 --> 00:24:18,840
现在 我应该注意到 如果我们只想对文件进行排序 

517
00:24:18,840 --> 00:24:21,960
实际上 我们可以在Python中更简单地实现这一点 尤其是

518
00:24:21,960 --> 00:24:25,980
通过不麻烦这个名字列表 也不是第二个for循环 

519
00:24:25,980 --> 00:24:28,690
让我继续下去 取而代之的是 更简单地做这个 

520
00:24:28,690 --> 00:24:31,020
让我继续并告诉Python我们需要该文件

521
00:24:31,020 --> 00:24:34,050
使用相同排序函数对其自身进行排序 

522
00:24:34,050 --> 00:24:36,015
但这一次是在文件本身 

523
00:24:36,015 --> 00:24:38,640
然后在for循环中 让我们继续打印

524
00:24:38,640 --> 00:24:42,300
我们马上打招呼 逗号 后面跟着行本身 

525
00:24:42,300 --> 00:24:46,110
但仍然去掉了它的末端的任何空白 

526
00:24:46,110 --> 00:24:48,330
如果我们现在继续运行同样的程序

527
00:24:48,330 --> 00:24:51,660
使用名为.py的python并按Enter键 我们会得到相同的结果 

528
00:24:51,660 --> 00:24:53,550
但当然 它要紧凑得多 

529
00:24:53,550 --> 00:24:55,950
但为了便于讨论 我们假设

530
00:24:55,950 --> 00:24:59,850
我们确实希望潜在地对数据进行一些更改

531
00:24:59,850 --> 00:25:00,870
当我们迭代它的时候 

532
00:25:00,870 --> 00:25:03,210
因此 让我撤销这些更改 让事情保持原样 

533
00:25:03,210 --> 00:25:06,240
现在 我们将首先继续积累所有的名字

534
00:25:06,240 --> 00:25:08,910
变成一份清单 也许会对他们做些什么 也许会强迫他们

535
00:25:08,910 --> 00:25:13,365
大写或小写等 然后分类并打印出每一项 

536
00:25:13,365 --> 00:25:15,240
让我暂停一下 看看有没有什么问题

537
00:25:15,240 --> 00:25:21,180
现在关于文件I/O读取或写入 或者现在累加所有这些值

538
00:25:21,180 --> 00:25:22,138
在某个名单上 

539
00:25:22,138 --> 00:25:22,680
观众：嗨 

540
00:25:22,680 --> 00:25:25,920
有没有办法对文件进行分类--

541
00:25:25,920 --> 00:25:29,490
相反 如果你想按字母从A到Z的顺序排列 

542
00:25:29,490 --> 00:25:32,490
有没有办法把它从Z变为A呢？

543
00:25:32,490 --> 00:25:35,460
有没有一个小的扩展 你可以添加到结尾来做到这一点？

544
00:25:35,460 --> 00:25:37,680
或者 您需要创建一个新函数吗？

545
00:25:37,680 --> 00:25:40,560
David Malan：如果您想要反转文件的内容？

546
00:25:40,560 --> 00:25:43,920
观众：是的 所以如果你不是从A到Z对它们进行排序

547
00:25:43,920 --> 00:25:47,640
按升序排列 如果你想要它们按降序排列 

548
00:25:47,640 --> 00:25:49,470
有延期吗？

549
00:25:49,470 --> 00:25:50,790
大卫·马兰：确实有 

550
00:25:50,790 --> 00:25:53,313
一如既往 文档是您的朋友 

551
00:25:53,313 --> 00:25:55,980
因此 如果目标是对它们进行排序 而不是按字母顺序 那么

552
00:25:55,980 --> 00:25:58,410
是默认的 但可能会颠倒字母顺序 

553
00:25:58,410 --> 00:26:01,660
例如 您可以在那里查看正式的Python文档 

554
00:26:01,660 --> 00:26:03,540
你将看到的是这个总结 

555
00:26:03,540 --> 00:26:06,870
您将看到排序后的函数通常接受第一个参数

556
00:26:06,870 --> 00:26:08,160
称为可迭代数 

557
00:26:08,160 --> 00:26:11,100
而一些可迭代的东西意味着你可以迭代它 

558
00:26:11,100 --> 00:26:13,620
这就是说 你可以一次循环做一件事 

559
00:26:13,620 --> 00:26:17,520
此行的其余部分意思是您可以指定一个密钥 例如 

560
00:26:17,520 --> 00:26:19,600
您希望如何对其进行排序 但稍后会详细介绍 

561
00:26:19,600 --> 00:26:22,200
但这里最后命名的参数是相反的 

562
00:26:22,200 --> 00:26:25,140
默认情况下 根据文档 它是错误的 

563
00:26:25,140 --> 00:26:28,560
默认情况下 它不会被撤销 但如果我们把它变成真的 

564
00:26:28,560 --> 00:26:29,650
我打赌我们能做到 

565
00:26:29,650 --> 00:26:32,350
因此 让我回到VS代码 并执行该操作 

566
00:26:32,350 --> 00:26:34,590
让我继续并传递第二个参数

567
00:26:34,590 --> 00:26:38,970
要排序除了这个迭代 这是我的名字列表--

568
00:26:38,970 --> 00:26:42,120
同样 在循环的意义上 它是可迭代的 

569
00:26:42,120 --> 00:26:47,740
并让我反向传递=True 从而覆盖默认的False 

570
00:26:47,740 --> 00:26:49,830
现在让我运行名为.py的python 

571
00:26:49,830 --> 00:26:53,410
现在罗恩在顶端 德拉科在底端 

572
00:26:53,410 --> 00:26:56,490
所以 在那里 无论何时你有这样的问题 

573
00:26:56,490 --> 00:26:58,650
考虑一下 文档是怎么说的？

574
00:26:58,650 --> 00:27:01,290
看看是否有一个萌芽的想法 因为 可能性很大 

575
00:27:01,290 --> 00:27:03,480
如果你有什么问题 很可能是某个程序员

576
00:27:03,480 --> 00:27:05,910
之前你也有过同样的问题 

577
00:27:05,910 --> 00:27:07,320
还有其他想法吗？

578
00:27:07,320 --> 00:27:11,130
观众：我们能限制名字的数量吗？

579
00:27:11,130 --> 00:27:15,812
第二个问题 我们能在名单中找到一个具体的名字吗？

580
00:27:15,812 --> 00:27:17,520
大卫·马兰：这个问题问得很好 我们可以吗？

581
00:27:17,520 --> 00:27:19,270
是否限制文件中的名称数量？

582
00:27:19,270 --> 00:27:20,730
我们能找到一个具体的吗？

583
00:27:20,730 --> 00:27:22,380
我们绝对可以 

584
00:27:22,380 --> 00:27:25,500
如果我们要写代码 我们可以 例如 

585
00:27:25,500 --> 00:27:29,580
首先打开文件 数一数已经有多少行 

586
00:27:29,580 --> 00:27:32,250
如果已经有太多了 我们可以

587
00:27:32,250 --> 00:27:35,760
退出 并显示sys.exit或其他向用户指示的消息

588
00:27:35,760 --> 00:27:37,290
那个 对不起 班上已经满了 

589
00:27:37,290 --> 00:27:40,500
至于具体地、绝对地找到一个人 

590
00:27:40,500 --> 00:27:44,490
您可以想象打开文件 使用for循环迭代它

591
00:27:44,490 --> 00:27:46,620
一遍又一遍 然后添加一个条件 

592
00:27:46,620 --> 00:27:51,397
比如 如果当前行等于Harry 那么我们就找到了所选的行号 

593
00:27:51,397 --> 00:27:52,980
你可以打印一些类似的东西 

594
00:27:52,980 --> 00:27:55,590
所以你完全可以把这些想法和以前的想法结合起来 

595
00:27:55,590 --> 00:27:58,470
就像条件句一样 问同样的问题 

596
00:27:58,470 --> 00:28:02,160
关于文件I/O的另一个问题如何？

597
00:28:02,160 --> 00:28:08,670
观众：所以我就想到了这个功能 比如读完所有的台词 

598
00:28:08,670 --> 00:28:14,280
看起来像是把所有的线都分开了

599
00:28:14,280 --> 00:28:17,520
这个特殊的字符 反斜杠 

600
00:28:17,520 --> 00:28:24,480
但看起来我们不需要它的角色 我们总是剥离它 

601
00:28:24,480 --> 00:28:28,920
它看起来像是一些糟糕的设计或功能 

602
00:28:28,920 --> 00:28:33,910
为什么我们不在这个函数中去掉它呢？

603
00:28:33,910 --> 00:28:35,410
大卫·马兰：这是一个非常好的问题 

604
00:28:35,410 --> 00:28:40,140
因此 在我到目前为止的示例中 我们使用的是rstrain

605
00:28:40,140 --> 00:28:43,290
去掉行尾的所有空白处 

606
00:28:43,290 --> 00:28:45,000
你可能不想这么做 

607
00:28:45,000 --> 00:28:49,560
在本例中 我将去掉它 因为我知道每一行

608
00:28:49,560 --> 00:28:51,000
不是什么普通的文本行 

609
00:28:51,000 --> 00:28:55,050
每一行实际上代表了我自己在那里放的一个名字 

610
00:28:55,050 --> 00:28:58,320
我使用新行只是为了将一个值与另一个值分开 

611
00:28:58,320 --> 00:29:00,600
在其他情况下 您可能非常希望

612
00:29:00,600 --> 00:29:03,990
为了保持这一行的结尾 因为它是一系列非常长的文本 

613
00:29:03,990 --> 00:29:06,240
或一段 或类似的东西 在你想要的地方

614
00:29:06,240 --> 00:29:07,740
以保持它与其他动物的区别 

615
00:29:07,740 --> 00:29:09,150
但这只是一次会议 

616
00:29:09,150 --> 00:29:13,950
我们必须使用某种东西 大概是用来分隔一段文本

617
00:29:13,950 --> 00:29:14,700
从另一个人那里 

618
00:29:14,700 --> 00:29:18,870
实际上 在Python中还有其他函数可以处理删除操作

619
00:29:18,870 --> 00:29:20,490
为你保留那片空白的空间 

620
00:29:20,490 --> 00:29:22,590
不过 Readline确实做到了这一点 

621
00:29:22,590 --> 00:29:25,110
它按原样读取所有行 

622
00:29:25,110 --> 00:29:28,780
好吧 请允许我把我们的注意力转回到我们在这里停止的地方 

623
00:29:28,780 --> 00:29:33,450
这只是名字来建议 有了names.txt 我们有能力 

624
00:29:33,450 --> 00:29:36,690
似乎 将这些名字中的每一个都存储得相当简单 

625
00:29:36,690 --> 00:29:39,750
但是 如果我们还想跟踪其他信息 该怎么办？

626
00:29:39,750 --> 00:29:42,700
假设我们想要存储信息 

627
00:29:42,700 --> 00:29:47,550
包括一名学生的名字和他们在霍格沃茨的房子 

628
00:29:47,550 --> 00:29:50,230
不管是格兰芬多 还是斯莱特林 还是别的什么 

629
00:29:50,230 --> 00:29:52,770
那么 我们应该把它放在哪里呢？

630
00:29:52,770 --> 00:29:55,020
赫敏住在格兰芬多 所以我们可以做点什么

631
00:29:55,020 --> 00:29:56,520
在我们的文本文件中是这样的 

632
00:29:56,520 --> 00:29:58,980
哈里住在格兰芬多 所以我们可以去 

633
00:29:58,980 --> 00:30:01,170
罗恩住在格兰芬多 所以我们可以去 

634
00:30:01,170 --> 00:30:03,900
德拉科住在斯莱特林 所以我们可以这么做 

635
00:30:03,900 --> 00:30:06,600
但我担心的是--

636
00:30:06,600 --> 00:30:09,990
但我现在担心的是 可以说 我们是在混合苹果和橙子 

637
00:30:09,990 --> 00:30:11,220
有些行是名字 

638
00:30:11,220 --> 00:30:12,610
有些线就是房子 

639
00:30:12,610 --> 00:30:15,870
所以这可能不是最好的设计 如果只是因为它令人困惑 

640
00:30:15,870 --> 00:30:17,010
或者它是模棱两可的 

641
00:30:17,010 --> 00:30:19,470
因此 也许我们可以做的是通过一项公约 

642
00:30:19,470 --> 00:30:22,140
事实上 这是许多程序员都在做的事情 

643
00:30:22,140 --> 00:30:26,190
他们不将此文件更改为names.txt 而是让

644
00:30:26,190 --> 00:30:28,860
我创建了一个名为names.csv的新文件 

645
00:30:28,860 --> 00:30:31,650
CSV代表逗号分隔值 

646
00:30:31,650 --> 00:30:35,490
存储多条信息是一种非常常见的约定

647
00:30:35,490 --> 00:30:37,860
它们在同一文件中相关 

648
00:30:37,860 --> 00:30:41,250
因此 为了做到这一点 我将分离这些类型的数据 

649
00:30:41,250 --> 00:30:44,400
不是用新的一行 而是简单地用逗号 

650
00:30:44,400 --> 00:30:46,860
我会让每个学生保持在他们自己的线路上 

651
00:30:46,860 --> 00:30:49,980
但我将使用以下工具来分离每个学生的信息

652
00:30:49,980 --> 00:30:51,340
用逗号代替 

653
00:30:51,340 --> 00:30:54,600
所以现在我们有了一个二维文件 如果你愿意的话 

654
00:30:54,600 --> 00:30:56,830
一排接一排 我们有学生 

655
00:30:56,830 --> 00:30:59,510
但如果你认为这些逗号代表一列 

656
00:30:59,510 --> 00:31:02,760
尽管由于这些名字的长度 它不是完全笔直的 

657
00:31:02,760 --> 00:31:05,310
它有点参差不齐 

658
00:31:05,310 --> 00:31:07,950
您可以将这些逗号视为代表一列 

659
00:31:07,950 --> 00:31:11,190
事实证明 这些CSV文件非常常见

660
00:31:11,190 --> 00:31:14,700
当您使用Microsoft Excel、Apple Numbers、

661
00:31:14,700 --> 00:31:17,550
或Google电子表格 而您想要将数据导出以共享

662
00:31:17,550 --> 00:31:20,160
与其他人作为CSV文件 

663
00:31:20,160 --> 00:31:23,460
或者相反 如果要导入CSV

664
00:31:23,460 --> 00:31:25,860
文件保存到您首选的电子表格软件中 

665
00:31:25,860 --> 00:31:29,590
像Excel、数字或谷歌电子表格一样 你也可以做到这一点 

666
00:31:29,590 --> 00:31:33,150
CSV是一种非常常见、非常简单的文本格式

667
00:31:33,150 --> 00:31:37,290
这只是用逗号和不同类型的值来分隔值 

668
00:31:37,290 --> 00:31:39,280
最终 也会有新的线路 

669
00:31:39,280 --> 00:31:42,210
让我继续运行Students.csv的代码

670
00:31:42,210 --> 00:31:44,520
创建一个最初为空的全新文件 

671
00:31:44,520 --> 00:31:48,820
我们将添加这些相同的名称 但也会添加一些其他信息 

672
00:31:48,820 --> 00:31:52,860
因此 如果我现在有这个新文件 Students.csv 其中

673
00:31:52,860 --> 00:31:56,370
可以说是一列名字和一列房子 

674
00:31:56,370 --> 00:32:00,540
我如何更改我的代码 使其不仅读取这些名称 还读取

675
00:32:00,540 --> 00:32:03,240
那些名字和房子 这样它们就不会都在一行上了--

676
00:32:03,240 --> 00:32:06,970
我们以某种方式可以分别获得这两种类型的价值？

677
00:32:06,970 --> 00:32:11,340
好的 让我们继续在这里创建一个名为Students.py的新程序 

678
00:32:11,340 --> 00:32:13,950
在这个节目中 让我们开始阅读 

679
00:32:13,950 --> 00:32:17,610
不是文本文件本身 而是特定类型的文本文件 CSV 

680
00:32:17,610 --> 00:32:19,800
逗号分隔值文件 

681
00:32:19,800 --> 00:32:22,200
要做到这一点 我将使用与前面类似的代码 

682
00:32:22,200 --> 00:32:26,897
我将用开放的 引用/不引用的方式说 Students.csv 

683
00:32:26,897 --> 00:32:28,980
我不会费心具体说明 引用/不引用 

684
00:32:28,980 --> 00:32:30,670
因为 同样 这是默认的 

685
00:32:30,670 --> 00:32:33,390
但我将为自己指定一个变量名为FILE 

686
00:32:33,390 --> 00:32:36,150
然后在这个文件中 我将继续执行此操作 

687
00:32:36,150 --> 00:32:41,220
对于文件中的行 就像以前一样 现在我必须在这里有点聪明了 

688
00:32:41,220 --> 00:32:45,180
让我回到Students.csv 看看这份文件 

689
00:32:45,180 --> 00:32:47,940
似乎在我每次迭代的循环中 

690
00:32:47,940 --> 00:32:51,000
我要访问整行文本 

691
00:32:51,000 --> 00:32:52,920
我不会自动获得访问权限

692
00:32:52,920 --> 00:32:55,170
只给赫敏或格兰芬多 

693
00:32:55,170 --> 00:32:58,960
回想一下 循环将为我提供每一整行文本 

694
00:32:58,960 --> 00:33:01,590
所以从逻辑上讲 你会建议我们

695
00:33:01,590 --> 00:33:05,520
在一次读取一整行文本的for循环中执行 

696
00:33:05,520 --> 00:33:08,490
但我们现在想要接触到个人价值 

697
00:33:08,490 --> 00:33:11,670
就像赫敏和格兰芬多 哈利和格兰芬多？

698
00:33:11,670 --> 00:33:14,160
我们该如何处理一行文本呢

699
00:33:14,160 --> 00:33:16,740
并获得这些个人价值观 你认为呢？

700
00:33:16,740 --> 00:33:20,040
只是本能地 即使您不确定函数的名称

701
00:33:20,040 --> 00:33:20,820
那就是 

702
00:33:20,820 --> 00:33:24,810
听众：你可以像使用词典一样访问它 

703
00:33:24,810 --> 00:33:26,195
就像使用键和值一样 

704
00:33:26,195 --> 00:33:29,070
David Malan：所以 理想情况下 我们会使用键和值来访问它 

705
00:33:29,070 --> 00:33:32,100
但在故事的这一点上 我们所拥有的只有这个循环 

706
00:33:32,100 --> 00:33:35,580
这个循环给了我一行文字 那就是时间 

707
00:33:35,580 --> 00:33:36,570
我现在是程序员了 

708
00:33:36,570 --> 00:33:37,470
我必须解决这个问题 

709
00:33:37,470 --> 00:33:39,480
目前还没有一本有问题的词典 

710
00:33:39,480 --> 00:33:41,760
这里的另一个建议如何？

711
00:33:41,760 --> 00:33:45,818
听众：所以你可以根据逗号把这两个词分开？

712
00:33:45,818 --> 00:33:47,610
大卫·马兰：是的 即使你不是很

713
00:33:47,610 --> 00:33:49,940
直观地说 哪个函数可以做到这一点 

714
00:33:49,940 --> 00:33:51,690
你想把这整行文字--

715
00:33:51,690 --> 00:33:55,320
赫敏、逗号、格兰芬多、哈利、逗号、格兰芬多等等--

716
00:33:55,320 --> 00:33:58,253
如果你愿意的话 把这条线分成两部分 

717
00:33:58,253 --> 00:34:00,420
事实证明 我们将使用的函数

718
00:34:00,420 --> 00:34:03,780
实际上称为拆分 可以对任何字符进行拆分 

719
00:34:03,780 --> 00:34:06,100
但您可以告诉它使用什么字符 

720
00:34:06,100 --> 00:34:09,633
所以我将返回到Students.py 在这个循环中 

721
00:34:09,633 --> 00:34:11,050
我要继续做这件事 

722
00:34:11,050 --> 00:34:12,540
我要坐现在这条线 

723
00:34:12,540 --> 00:34:17,159
我将一如既往地删除结尾处的空格 在这里使用rstrain 

724
00:34:17,159 --> 00:34:19,260
不管结果如何 我都会

725
00:34:19,260 --> 00:34:23,250
现在 我们将调用Split 并引用/不引用逗号 

726
00:34:23,250 --> 00:34:27,330
因此 Split函数或方法附带字符串 

727
00:34:27,330 --> 00:34:31,570
Python中的STR--任何字符串都内置了这个方法 

728
00:34:31,570 --> 00:34:36,659
如果您传入一个参数 如逗号 则此拆分函数将执行什么操作

729
00:34:36,659 --> 00:34:41,880
通过查找将当前字符串分割成1、2、3 也许更多片段

730
00:34:41,880 --> 00:34:46,530
一次又一次地为那个角色 

731
00:34:46,530 --> 00:34:48,540
最终 斯普利特会回到我们身边

732
00:34:48,540 --> 00:34:51,570
左侧所有单独部件的列表

733
00:34:51,570 --> 00:34:53,260
在这些逗号的右侧 

734
00:34:53,260 --> 00:34:55,949
所以我可以在这里给自己一个名为row的变量 

735
00:34:55,949 --> 00:34:57,360
这是一个常见的范例 

736
00:34:57,360 --> 00:35:01,390
当您知道您正在迭代一个文件 特别是CSV时 

737
00:35:01,390 --> 00:35:04,500
通常认为它的每一行都是

738
00:35:04,500 --> 00:35:09,790
一行和其中的每个值以逗号分隔为列 

739
00:35:09,790 --> 00:35:10,570
可以这么说 

740
00:35:10,570 --> 00:35:13,170
所以我将故意将我的变量行命名为

741
00:35:13,170 --> 00:35:14,880
以符合这一惯例 

742
00:35:14,880 --> 00:35:17,430
现在我要打印什么呢？

743
00:35:17,430 --> 00:35:19,140
好吧 我要说的就是这个 

744
00:35:19,140 --> 00:35:26,250
打印一个以大括号开头的f字符串 怎么样？

745
00:35:26,250 --> 00:35:29,610
那我怎么才能接触到那一排的第一件东西呢？

746
00:35:29,610 --> 00:35:31,590
好的 这一排有几个部分？

747
00:35:31,590 --> 00:35:35,580
第二 因为如果我用逗号拆分 每行有一个逗号 

748
00:35:35,580 --> 00:35:37,980
这会给我一个左边的部分和一个右边的部分 

749
00:35:37,980 --> 00:35:41,100
就像赫敏和格兰芬多 哈利和格兰芬多 

750
00:35:41,100 --> 00:35:45,820
当我有一个像ROW这样的列表时 我如何访问各个值？

751
00:35:45,820 --> 00:35:47,320
好吧 我能做到的 

752
00:35:47,320 --> 00:35:50,310
我可以说 排 括号 0 

753
00:35:50,310 --> 00:35:52,920
这将进入列表的第一个元素 即

754
00:35:52,920 --> 00:35:54,720
希望应该是这个学生的名字 

755
00:35:54,720 --> 00:35:57,240
然后 我要说的是 在那之后 

756
00:35:57,240 --> 00:36:01,830
我要在这里再加一个花括号 放在第一排的括号里 

757
00:36:01,830 --> 00:36:03,705
然后我将结束我的整个引用 

758
00:36:03,705 --> 00:36:05,580
因此 乍一看 它看起来有点神秘 

759
00:36:05,580 --> 00:36:09,660
但其中大部分只是f字符串语法 用大括号插入值 

760
00:36:09,660 --> 00:36:11,430
我在灌输什么价值观？

761
00:36:11,430 --> 00:36:15,210
好吧 ROW 同样是一个列表 它有两个元素 大概是--

762
00:36:15,210 --> 00:36:19,030
赫敏在一个 格兰芬多在另一个 以此类推 

763
00:36:19,030 --> 00:36:22,440
因此 括号0是第一个元素 因为 记住 

764
00:36:22,440 --> 00:36:25,050
在Python语言中 我们从0开始索引 

765
00:36:25,050 --> 00:36:27,520
而1将是第二个元素 

766
00:36:27,520 --> 00:36:30,330
所以现在让我继续运行 看看会发生什么--

767
00:36:30,330 --> 00:36:35,880
Python of Students.py 请输入 

768
00:36:35,880 --> 00:36:37,993
我们看到赫敏在格兰芬多 

769
00:36:37,993 --> 00:36:38,910
哈利在格兰芬多 

770
00:36:38,910 --> 00:36:39,960
罗恩在格兰芬多 

771
00:36:39,960 --> 00:36:41,970
德拉科在斯莱特林 

772
00:36:41,970 --> 00:36:48,180
因此 我们现在已经从头开始实现了我们自己的代码 它实际上可以解析

773
00:36:48,180 --> 00:36:53,010
也就是说 最终在这里读取和解释CSV文件 

774
00:36:53,010 --> 00:36:55,390
现在 让我暂停一下 看看有没有什么问题 

775
00:36:55,390 --> 00:36:59,080
但我们稍后会让这篇文章更容易阅读 

776
00:36:59,080 --> 00:37:03,090
对我们刚才用逗号分隔所做的工作有什么问题吗？

777
00:37:03,090 --> 00:37:08,610
观众：所以我的问题是 我们可以随时编辑任何代码行吗？

778
00:37:08,610 --> 00:37:13,620
或者我们唯一的选择就是添加这些行？

779
00:37:13,620 --> 00:37:18,780
或者比方说 我们想 比方说 改变哈利的房子

780
00:37:18,780 --> 00:37:22,500
去斯莱特林或其他房子 

781
00:37:22,500 --> 00:37:24,250
大卫·马兰：是的 这是一个非常好的问题 

782
00:37:24,250 --> 00:37:28,740
如果您想要在Python语言中更改文件中的一行 而不仅仅是

783
00:37:28,740 --> 00:37:30,130
追加到末尾吗？

784
00:37:30,130 --> 00:37:32,290
你必须自己实现这一逻辑 

785
00:37:32,290 --> 00:37:35,880
例如 您可以想象现在打开文件

786
00:37:35,880 --> 00:37:39,660
然后阅读其中的所有内容 然后可能迭代

787
00:37:39,660 --> 00:37:40,650
每一行都是 

788
00:37:40,650 --> 00:37:43,830
一旦你看到现在的名字等于哈利 

789
00:37:43,830 --> 00:37:47,100
你也许可以把他的房子换成斯莱特林 

790
00:37:47,100 --> 00:37:51,030
然而 接下来要由您来编写所有这些更改

791
00:37:51,030 --> 00:37:52,060
回到文件上来 

792
00:37:52,060 --> 00:37:54,360
因此 在这种情况下 您可能想要 以最简单的形式 

793
00:37:54,360 --> 00:37:56,610
阅读文件一次 然后让它关闭 

794
00:37:56,610 --> 00:38:00,300
然后再次打开它 但要打开以进行写入 并更改整个文件 

795
00:38:00,300 --> 00:38:04,770
进入并只更改文件的一部分并不是真正可能或容易的 

796
00:38:04,770 --> 00:38:05,760
虽然你能做到 

797
00:38:05,760 --> 00:38:09,630
更容易实际读取整个文件 在内存中进行更改 

798
00:38:09,630 --> 00:38:11,100
然后把整个文件写出来 

799
00:38:11,100 --> 00:38:13,920
但对于较大的文件 其速度可能会相当慢 

800
00:38:13,920 --> 00:38:16,200
你可以比这更聪明 

801
00:38:16,200 --> 00:38:19,980
好吧 现在让我提议我们稍微清理一下 因为我实际上

802
00:38:19,980 --> 00:38:23,370
我觉得这读起来有点神秘--行 括号 0 行 括号 

803
00:38:23,370 --> 00:38:27,090
1--我想说 目前这本书写得不是很好 

804
00:38:27,090 --> 00:38:32,050
但事实证明 当你有一个像ROW这样的列表的变量时 

805
00:38:32,050 --> 00:38:35,250
您不必将所有这些变量都放到一个列表中 

806
00:38:35,250 --> 00:38:38,580
实际上 你可以一次解开整个序列 

807
00:38:38,580 --> 00:38:42,630
也就是说 如果您知道像Split这样的函数返回一个列表 

808
00:38:42,630 --> 00:38:45,090
但你事先知道它会回来的

809
00:38:45,090 --> 00:38:48,330
列表中的两个值 第一个和第二个 

810
00:38:48,330 --> 00:38:51,750
您不必将它们全部放入本身就是一个列表的变量中 

811
00:38:51,750 --> 00:38:55,840
你实际上可以同时把它们分解成两个变量 

812
00:38:55,840 --> 00:38:57,630
做名字 逗号 房子 

813
00:38:57,630 --> 00:39:01,680
因此 这是一种很好的Python技术 不仅可以创建 还可以分配

814
00:39:01,680 --> 00:39:05,580
自动地 同时并行地 两个变量 

815
00:39:05,580 --> 00:39:06,880
而不是只有一个 

816
00:39:06,880 --> 00:39:10,230
所以这将产生把名字放在左边的效果 赫敏 

817
00:39:10,230 --> 00:39:12,360
它的效果就是把格兰芬多

818
00:39:12,360 --> 00:39:14,040
房子在右边的变数里 

819
00:39:14,040 --> 00:39:15,643
我们现在不再有争吵了 

820
00:39:15,643 --> 00:39:18,810
我们现在可以让我们的代码更具可读性 字面意思是

821
00:39:18,810 --> 00:39:22,020
名字在这里 例如 房子在这里 

822
00:39:22,020 --> 00:39:25,020
所以只是可读性更好一点 尽管从功能上讲 代码

823
00:39:25,020 --> 00:39:28,430
现在的情况完全一样 

824
00:39:28,430 --> 00:39:30,470
好了 现在这招起作用了 

825
00:39:30,470 --> 00:39:34,070
我将通过再次运行它来确认这一点--python of Students.py 

826
00:39:34,070 --> 00:39:34,580
进来吧 

827
00:39:34,580 --> 00:39:37,340
我们看到 文本符合预期 

828
00:39:37,340 --> 00:39:39,590
但为了便于讨论 假设我

829
00:39:39,590 --> 00:39:42,650
我想对这份输出列表进行排序 

830
00:39:42,650 --> 00:39:46,310
我想再次向德拉科打个招呼 然后向哈里打招呼 

831
00:39:46,310 --> 00:39:47,960
然后是赫敏 然后是罗恩 

832
00:39:47,960 --> 00:39:49,770
我该如何着手做这件事呢？

833
00:39:49,770 --> 00:39:52,520
好的 让我们从前面的例子中获得一些启发 其中

834
00:39:52,520 --> 00:39:57,680
我们只处理名字 而不是用这些完整的短语 

835
00:39:57,680 --> 00:39:59,480
在公司内部也是如此 

836
00:39:59,480 --> 00:40:01,080
好吧 让我继续做这件事 

837
00:40:01,080 --> 00:40:05,660
我将继续从头开始 给自己列一份名为学生的名单 

838
00:40:05,660 --> 00:40:07,370
最初等于一个空列表 

839
00:40:07,370 --> 00:40:14,060
然后以开放的Students.csv为文件 我将继续这样说--

840
00:40:14,060 --> 00:40:16,405
用于文件中的行 

841
00:40:16,405 --> 00:40:19,280
然后在这个下面 我将一如既往地做--名字 逗号 

842
00:40:19,280 --> 00:40:23,240
House等于当前行 去掉了结尾处的空白 

843
00:40:23,240 --> 00:40:24,840
用逗号把它分开--

844
00:40:24,840 --> 00:40:26,670
所以这和以前完全一样 

845
00:40:26,670 --> 00:40:32,180
但这一次 在我开始打印句子之前 

846
00:40:32,180 --> 00:40:34,370
我要把它暂时存储在一个列表中

847
00:40:34,370 --> 00:40:38,010
这样我就可以积累所有这些句子 然后在以后对它们进行分类 

848
00:40:38,010 --> 00:40:39,380
所以让我继续做这件事 

849
00:40:39,380 --> 00:40:42,770
学生们 这是我的名单 追加--

850
00:40:42,770 --> 00:40:45,320
让我附上我想要显示的实际句子

851
00:40:45,320 --> 00:40:46,820
在屏幕上--也就是另一个f弦 

852
00:40:46,820 --> 00:40:50,640
所以 名字就在家里 就像以前一样 

853
00:40:50,640 --> 00:40:52,520
但请注意 我不会打印这句话 

854
00:40:52,520 --> 00:40:56,600
我将它添加到我的列表中--不是一个文件 而是我的列表 

855
00:40:56,600 --> 00:40:58,050
我为什么要这么做？

856
00:40:58,050 --> 00:41:00,140
嗯 只是因为 像以前一样 我想这么做 

857
00:41:00,140 --> 00:41:04,070
对于排序后的学生 我希望

858
00:41:04,070 --> 00:41:07,590
把学生打印出来 就像这样 

859
00:41:07,590 --> 00:41:11,900
那么 让我继续运行python of Students.py 然后现在按Enter键 

860
00:41:11,900 --> 00:41:14,713
我想我们会看到 的确 德拉科现在是第一个 

861
00:41:14,713 --> 00:41:15,380
哈里是第二名 

862
00:41:15,380 --> 00:41:16,310
赫敏排名第三 

863
00:41:16,310 --> 00:41:18,380
罗恩是第四名 

864
00:41:18,380 --> 00:41:21,980
但这可以说是有点草率 对吗？

865
00:41:21,980 --> 00:41:25,490
我正在构造这些句子 这似乎有点老土 

866
00:41:25,490 --> 00:41:29,150
尽管从技术上讲我想按名字排序 

867
00:41:29,150 --> 00:41:32,490
从技术上讲 我是按这些完整的英语句子排序的 

868
00:41:32,490 --> 00:41:33,530
所以这不是错的 

869
00:41:33,530 --> 00:41:36,590
它达到了预期的效果 但并不是真的

870
00:41:36,590 --> 00:41:39,480
设计得很好 因为我很幸运 我的英语

871
00:41:39,480 --> 00:41:40,730
就是从左到右阅读 

872
00:41:40,730 --> 00:41:43,700
因此 当我打印出来时 它是正确排序的 

873
00:41:43,700 --> 00:41:46,760
真的 想出一种分类的技术会更好

874
00:41:46,760 --> 00:41:50,600
通过学生的名字 而不是通过一些英语句子

875
00:41:50,600 --> 00:41:53,360
我在第6行构建的 

876
00:41:53,360 --> 00:41:57,200
所以为了达到这个目的 我需要让我的生活变得更复杂

877
00:41:57,200 --> 00:41:57,980
了一会儿.

878
00:41:57,980 --> 00:42:02,330
我需要收集每个学生的信息

879
00:42:02,330 --> 00:42:04,950
我才能把这句话说出来

880
00:42:04,950 --> 00:42:06,750
所以我建议我们这样做 

881
00:42:06,750 --> 00:42:09,960
让我继续撤消最后几行代码

882
00:42:09,960 --> 00:42:14,480
所以我们现在有两个变量name和house 每个变量

883
00:42:14,480 --> 00:42:16,560
分别有名字和学生的家 

884
00:42:16,560 --> 00:42:19,130
我们还有全局变量 学生 

885
00:42:19,130 --> 00:42:20,360
但让我来吧 

886
00:42:20,360 --> 00:42:22,610
回想一下Python支持字典 

887
00:42:22,610 --> 00:42:25,770
字典只是键和值的集合 

888
00:42:25,770 --> 00:42:28,160
所以你可以把一件事和另一件事联系起来 

889
00:42:28,160 --> 00:42:32,000
比如赫敏的名字格兰芬多的房子

890
00:42:32,000 --> 00:42:33,660
这真的是一本字典 

891
00:42:33,660 --> 00:42:34,610
所以让我来吧 

892
00:42:34,610 --> 00:42:39,950
让我临时创建一个字典来存储这个名称关联

893
00:42:39,950 --> 00:42:40,950
关于House

894
00:42:40,950 --> 00:42:42,240
让我继续做这个 

895
00:42:42,240 --> 00:42:45,950
我要说的是 这里的学生将首先代表

896
00:42:45,950 --> 00:42:46,908
一本空字典

897
00:42:46,908 --> 00:42:49,575
就像你可以用方括号创建一个空列表一样 

898
00:42:49,575 --> 00:42:51,990
你可以用花括号创建一个空字典 

899
00:42:51,990 --> 00:42:57,050
所以给我一本空字典 它很快就会有两个关键词 名字和房子 

900
00:42:57,050 --> 00:42:58,140
我该怎么做？

901
00:42:58,140 --> 00:43:01,070
我可以这样做学生式开放括号

902
00:43:01,070 --> 00:43:05,870
name等于我们从行中得到的学生的名字 

903
00:43:05,870 --> 00:43:10,490
学生 括号 房子等于我们从线上得到的房子 

904
00:43:10,490 --> 00:43:14,450
现在我将添加到学生列表中--

905
00:43:14,450 --> 00:43:17,660
复数那个学生

906
00:43:17,660 --> 00:43:18,920
我为什么要这么做？

907
00:43:18,920 --> 00:43:21,060
我承认我的代码变得更复杂了 

908
00:43:21,060 --> 00:43:23,870
这是更多的代码行 但我现在已经收集了

909
00:43:23,870 --> 00:43:27,560
所有我掌握的学生信息

910
00:43:27,560 --> 00:43:29,960
什么是名字什么是房子

911
00:43:29,960 --> 00:43:34,100
同时 名单上有所有学生的名字和房子 

912
00:43:34,100 --> 00:43:35,630
我为什么要这么做？

913
00:43:35,630 --> 00:43:38,150
好吧 让我 暂时 做点简单的事 

914
00:43:38,150 --> 00:43:43,220
让我为学生们做一件事 现在让我非常简单地说 打印

915
00:43:43,220 --> 00:43:48,980
下面的f字符串 当前同名的学生

916
00:43:48,980 --> 00:43:53,390
就在这个在校学生的房子里 

917
00:43:53,390 --> 00:43:55,460
现在请注意一个细节 

918
00:43:55,460 --> 00:43:59,390
在这个f字符串中 我一如既往地使用我的花括号 

919
00:43:59,390 --> 00:44:03,590
我一如既往地在花括号内使用变量的名称 

920
00:44:03,590 --> 00:44:07,970
但我用的不是方括号0或1 因为它们现在都是字典了 

921
00:44:07,970 --> 00:44:08,840
不是名单 

922
00:44:08,840 --> 00:44:16,090
但是为什么我要用单引号把House和名字括起来呢？

923
00:44:16,090 --> 00:44:25,850
为什么要在这个f字符串中使用单引号来访问这些键呢？

924
00:44:25,850 --> 00:44:30,960
观众：是的 因为你在第12行有双引号 

925
00:44:30,960 --> 00:44:34,222
因此 您必须告诉Python要有所区别 

926
00:44:34,222 --> 00:44:35,930
大卫·马兰：没错 因为我已经

927
00:44:35,930 --> 00:44:39,620
在f字符串之外使用双引号 如果我想要加引号

928
00:44:39,620 --> 00:44:41,750
绕过内部的任何弦 我确实是这样做的

929
00:44:41,750 --> 00:44:44,810
需要处理字典 因为 回想一下 当您索引时

930
00:44:44,810 --> 00:44:47,570
在词典中 你不会像列表一样使用数字--

931
00:44:47,570 --> 00:44:49,100
0 1 2 向前--

932
00:44:49,100 --> 00:44:51,760
相反 您使用的是字符串 需要用引号将其引起来 

933
00:44:51,760 --> 00:44:53,510
但如果你已经在用双引号了 

934
00:44:53,510 --> 00:44:55,820
最简单的做法是在内侧使用单引号 

935
00:44:55,820 --> 00:44:59,360
因此 Python不会混淆什么与什么的关系 

936
00:44:59,360 --> 00:45:02,120
所以现在 当我运行这个程序时 

937
00:45:02,120 --> 00:45:04,130
它将打印出这些问候 

938
00:45:04,130 --> 00:45:05,990
但它们还没有被分类 

939
00:45:05,990 --> 00:45:10,340
事实上 我现在拥有的是一份词典清单 

940
00:45:10,340 --> 00:45:12,110
而且目前还没有任何事情得到解决 

941
00:45:12,110 --> 00:45:14,540
但让我也收紧代码以指出它

942
00:45:14,540 --> 00:45:16,340
不需要那么冗长 

943
00:45:16,340 --> 00:45:20,210
如果您习惯于创建一本空词典 如第6行所示 

944
00:45:20,210 --> 00:45:23,480
然后立即输入两把钥匙 名字和房子 

945
00:45:23,480 --> 00:45:26,315
每个值都有两个值 分别是name和house 您

946
00:45:26,315 --> 00:45:27,690
实际上可以一次完成这一切 

947
00:45:27,690 --> 00:45:29,870
因此 让我向您展示一个稍微不同的语法 

948
00:45:29,870 --> 00:45:30,920
我能做这些 

949
00:45:30,920 --> 00:45:34,550
给我一个名为Student的变量 让我使用花括号

950
00:45:34,550 --> 00:45:35,760
在这里的右边 

951
00:45:35,760 --> 00:45:38,780
但是 让我们只定义这些键 而不是将它们留空

952
00:45:38,780 --> 00:45:40,070
以及现在的那些价值观 

953
00:45:40,070 --> 00:45:45,620
引用/未引用的名称将是名称 引用/未引用的房子将是房子 

954
00:45:45,620 --> 00:45:49,850
这在一行中实现了完全相同的效果 而不是三行 

955
00:45:49,850 --> 00:45:53,692
它创建一个包含名称键的新的非空词典 

956
00:45:53,692 --> 00:45:55,400
它的值是学生的名字 

957
00:45:55,400 --> 00:45:58,610
和一把房子的钥匙 它的价值是学生的房子 

958
00:45:58,610 --> 00:45:59,870
其他任何事情都不需要改变 

959
00:45:59,870 --> 00:46:03,955
这仍然是有效的 所以如果我再次运行python of Students.py 

960
00:46:03,955 --> 00:46:06,080
我还能看到那些问候语 但它们仍然

961
00:46:06,080 --> 00:46:08,960
实际上并没有完全分类 

962
00:46:08,960 --> 00:46:12,290
那么 我应该在这里做些什么才能--

963
00:46:12,290 --> 00:46:15,410
我能做些什么来进一步改进这一点呢？

964
00:46:15,410 --> 00:46:19,850
嗯 我们现在需要一些机制来对这些学生进行分类 

965
00:46:19,850 --> 00:46:22,820
但不幸的是 你不能这么做 

966
00:46:22,820 --> 00:46:28,413
我们现在不能对所有学生进行排序 因为这些学生不是名字

967
00:46:28,413 --> 00:46:29,330
就像以前一样 

968
00:46:29,330 --> 00:46:31,310
它们不再是以前的句子了 

969
00:46:31,310 --> 00:46:34,400
每个学生都是一本词典 这并不明显

970
00:46:34,400 --> 00:46:37,830
如何在列表中对词典进行排序 

971
00:46:37,830 --> 00:46:40,280
所以在理想情况下 我们想要做什么？

972
00:46:40,280 --> 00:46:45,440
如果在我们到达第9行的那一刻 我们有所有这些学生的名单 

973
00:46:45,440 --> 00:46:48,620
在这份名单中 每个学生都有一本词典 

974
00:46:48,620 --> 00:46:52,040
每本词典都有两个关键字 名字和房子 

975
00:46:52,040 --> 00:46:57,050
如果在代码中有方法告诉Python 对这个列表进行排序 那不是很好吗

976
00:46:57,050 --> 00:46:59,960
通过在每本词典中查看这个关键字？

977
00:46:59,960 --> 00:47:03,830
因为这将使我们能够按名称甚至按名称进行排序

978
00:47:03,830 --> 00:47:07,800
按房屋 甚至按我们添加到该文件的任何其他字段 

979
00:47:07,800 --> 00:47:09,980
所以事实证明 我们可以做到这一点 

980
00:47:09,980 --> 00:47:14,000
我们可以告诉排序函数 不仅仅是反转还是不反转 

981
00:47:14,000 --> 00:47:16,250
它采取了另一种位置--

982
00:47:16,250 --> 00:47:19,520
它接受另一个名为key的命名参数 

983
00:47:19,520 --> 00:47:23,990
其中 您可以指定应该使用哪个键来进行排序

984
00:47:23,990 --> 00:47:25,370
一些词典的清单 

985
00:47:25,370 --> 00:47:27,410
我将提议我们这样做 

986
00:47:27,410 --> 00:47:31,940
我将首先定义一个名为get_name的函数--暂时是这样 

987
00:47:31,940 --> 00:47:35,090
而这个功能在生活中的目的是 给一个学生 

988
00:47:35,090 --> 00:47:38,480
很简单 就是返回学生的名字

989
00:47:38,480 --> 00:47:40,500
从那本特定的词典里 

990
00:47:40,500 --> 00:47:43,910
因此 如果学生是一本词典 它将按字面意思返回

991
00:47:43,910 --> 00:47:45,470
学生的名字 仅此而已 

992
00:47:45,470 --> 00:47:48,530
这就是这个功能在生活中的唯一目的 

993
00:47:48,530 --> 00:47:50,120
我现在想做什么？

994
00:47:50,120 --> 00:47:52,670
现在我有了一个函数 给定一个学生 

995
00:47:52,670 --> 00:47:56,130
会把学生的名字还给我 我能做到 

996
00:47:56,130 --> 00:47:59,630
我可以改成说 使用一把钥匙

997
00:47:59,630 --> 00:48:03,350
等于GET_NAME的返回值 

998
00:48:03,350 --> 00:48:05,810
这现在是Python的一项功能 

999
00:48:05,810 --> 00:48:12,300
Python允许您将函数作为参数传递给其他函数 

1000
00:48:12,300 --> 00:48:14,180
所以GET_NAME是一个函数 

1001
00:48:14,180 --> 00:48:15,710
排序是一个函数 

1002
00:48:15,710 --> 00:48:22,610
我将GET_NAME作为该键参数的值传递给Sorted 

1003
00:48:22,610 --> 00:48:24,540
现在 我为什么要这么做？

1004
00:48:24,540 --> 00:48:26,600
好的 如果您想到get_name函数 

1005
00:48:26,600 --> 00:48:30,080
这只是一段代码 它将获得一个学生的名字 

1006
00:48:30,080 --> 00:48:33,410
这很方便 因为这是对需求进行分类的功能 

1007
00:48:33,410 --> 00:48:36,470
当给出一份学生名单时 每个学生都是一本词典 

1008
00:48:36,470 --> 00:48:38,990
分类需要知道的是 我怎么才能得到学生的名字？

1009
00:48:38,990 --> 00:48:40,882
以便按字母顺序为您排序 

1010
00:48:40,882 --> 00:48:42,590
Python的作者并不知道我们

1011
00:48:42,590 --> 00:48:44,880
我们将在这个班级里创造学生 

1012
00:48:44,880 --> 00:48:47,540
所以他们不可能预料到提前编写代码

1013
00:48:47,540 --> 00:48:51,770
它专门对一个名为Student的字段进行排序 更不用说名称了 

1014
00:48:51,770 --> 00:48:53,150
更别提房子了 

1015
00:48:53,150 --> 00:48:54,950
那么他们做了什么呢？

1016
00:48:54,950 --> 00:48:57,590
相反 它们内置于排序函数中

1017
00:48:57,590 --> 00:49:01,490
这个命名的参数键允许我们 这么多年后 

1018
00:49:01,490 --> 00:49:06,060
为了说明他们的功能 如何对这一系列词典进行排序 

1019
00:49:06,060 --> 00:49:07,910
所以 现在看看会发生什么 

1020
00:49:07,910 --> 00:49:11,540
如果我运行PYTHON of Students.py并按Enter 

1021
00:49:11,540 --> 00:49:14,150
我现在有了一个经过排序的输出列表 

1022
00:49:14,150 --> 00:49:14,810
为什么？

1023
00:49:14,810 --> 00:49:17,750
因为现在这份词典列表里有

1024
00:49:17,750 --> 00:49:20,570
已经按照学生的名字进行了分类 

1025
00:49:20,570 --> 00:49:22,020
我可以进一步做到这一点 

1026
00:49:22,020 --> 00:49:24,840
如果像以前一样 我们想要通过说Reverse来逆转整个事情

1027
00:49:24,840 --> 00:49:26,740
这是真的 我们也可以这么做 

1028
00:49:26,740 --> 00:49:28,980
让我重新运行PYTHON of Students.py 然后按Enter键 

1029
00:49:28,980 --> 00:49:29,880
现在情况发生了逆转 

1030
00:49:29,880 --> 00:49:32,610
现在是罗恩 然后是赫敏、哈利和德拉科 

1031
00:49:32,610 --> 00:49:34,590
但我们也可以做一些不同的事情 

1032
00:49:34,590 --> 00:49:39,150
例如 如果我想要按颠倒的房屋名称进行排序 该怎么办？

1033
00:49:39,150 --> 00:49:40,230
我能做到的 

1034
00:49:40,230 --> 00:49:43,110
我可以将此函数从get_name更改为get_house 

1035
00:49:43,110 --> 00:49:46,320
我可以将这里的实现更改为Get_House 

1036
00:49:46,320 --> 00:49:49,660
我可以退还的不是学生的名字 而是学生的房子 

1037
00:49:49,660 --> 00:49:56,250
现在请注意 如果我运行学生.py的python 请输入 现在请注意

1038
00:49:56,250 --> 00:49:59,730
它以相反的顺序按房屋排序 

1039
00:49:59,730 --> 00:50:02,400
斯莱特林是第一名 然后是格兰芬多 

1040
00:50:02,400 --> 00:50:07,110
如果我取消反向操作 但保留Get_house并重新运行此程序 

1041
00:50:07,110 --> 00:50:09,390
现在它是按房子分类的 

1042
00:50:09,390 --> 00:50:11,970
格兰芬多是第一个 斯莱特林是最后一个 

1043
00:50:11,970 --> 00:50:15,990
现在好的方面是 因为我用的是这一系列词典

1044
00:50:15,990 --> 00:50:19,620
并将学生数据保存在一起 直到最后一刻

1045
00:50:19,620 --> 00:50:21,780
当我终于开始印刷的时候 我现在

1046
00:50:21,780 --> 00:50:25,800
对信息本身有完全的控制权 我可以按这个或那个排序 

1047
00:50:25,800 --> 00:50:29,100
我不需要事先构思那些句子 就像我

1048
00:50:29,100 --> 00:50:31,587
第一次这样做是相当粗鲁的 

1049
00:50:31,587 --> 00:50:32,670
好吧 那可真够多的 

1050
00:50:32,670 --> 00:50:36,000
让我在这里暂停一下 看看是否有问题 

1051
00:50:36,000 --> 00:50:40,050
观众：所以当我们对文件进行分类时 每次

1052
00:50:40,050 --> 00:50:48,090
我们应该使用循环、文本词典或任何类型的列表吗？

1053
00:50:48,090 --> 00:50:55,440
我们可以只按排序 而不是循环或任何类型的东西进行排序吗？

1054
00:50:55,440 --> 00:50:58,890
David Malan：这是一个很好的问题 也是对Python的简短回答

1055
00:50:58,890 --> 00:51:00,630
独自一人 你是程序员 

1056
00:51:00,630 --> 00:51:01,890
你需要进行分类 

1057
00:51:01,890 --> 00:51:05,160
绝对可以使用库和其他技术 

1058
00:51:05,160 --> 00:51:08,100
你可以自动完成更多的工作 因为其他人

1059
00:51:08,100 --> 00:51:09,180
已经编写了这段代码 

1060
00:51:09,180 --> 00:51:12,420
我们目前所做的一切都是自己从头开始做 

1061
00:51:12,420 --> 00:51:15,045
但绝对可以使用其他函数或库 其中一些

1062
00:51:15,045 --> 00:51:18,120
可以变得更容易做到 

1063
00:51:18,120 --> 00:51:20,590
这其中的一些事情可以变得更容易 

1064
00:51:20,590 --> 00:51:23,400
这里还有关于这项技术的其他问题吗？

1065
00:51:23,400 --> 00:51:28,050
受众：如果等于函数的返回值 

1066
00:51:28,050 --> 00:51:36,152
它能否仅等于一个变量或一个值？

1067
00:51:36,152 --> 00:51:37,110
大卫·马兰：嗯 是的 

1068
00:51:37,110 --> 00:51:39,240
它应该等于一个值 

1069
00:51:39,240 --> 00:51:42,630
事实上 我应该澄清一下 因为这并不明显 

1070
00:51:42,630 --> 00:51:46,950
因此 当您传入一个像get_name或get_house这样的函数时

1071
00:51:46,950 --> 00:51:49,620
将排序后的函数作为key的值 

1072
00:51:49,620 --> 00:51:55,830
排序后的函数会自动调用该函数

1073
00:51:55,830 --> 00:51:58,740
在列表中的每一本词典上 

1074
00:51:58,740 --> 00:52:02,250
并使用GET_NAME或GET_HOUSE的返回值

1075
00:52:02,250 --> 00:52:07,080
决定实际使用哪些字符串进行比较 以便决定

1076
00:52:07,080 --> 00:52:09,150
按字母顺序排列是正确的 

1077
00:52:09,150 --> 00:52:12,120
因此 这个仅按名称传递的函数 您

1078
00:52:12,120 --> 00:52:14,790
不要在末尾加上圆括号 是

1079
00:52:14,790 --> 00:52:18,690
由排序函数调用 以便为您计算

1080
00:52:18,690 --> 00:52:21,790
如何比较这些相同的值 

1081
00:52:21,790 --> 00:52:25,230
听众：我们怎样才能使用嵌套词典？

1082
00:52:25,230 --> 00:52:28,920
我读过关于嵌套词典的文章 

1083
00:52:28,920 --> 00:52:31,500
嵌套词典之间有什么不同

1084
00:52:31,500 --> 00:52:34,380
清单里的字典呢？

1085
00:52:34,380 --> 00:52:35,460
我想就是这个原因 

1086
00:52:35,460 --> 00:52:36,930
大卫·马兰：当然 

1087
00:52:36,930 --> 00:52:39,280
因此 我们使用了一系列词典 

1088
00:52:39,280 --> 00:52:39,780
为什么？

1089
00:52:39,780 --> 00:52:42,450
因为每一本词典都代表一个学生 

1090
00:52:42,450 --> 00:52:45,270
一个学生有一个名字和一所房子 我们想 我说 

1091
00:52:45,270 --> 00:52:46,782
保持这种联系 

1092
00:52:46,782 --> 00:52:49,740
这是一个学生名单 因为我们有多个学生--四个 

1093
00:52:49,740 --> 00:52:50,580
在这种情况下 

1094
00:52:50,580 --> 00:52:54,570
您可以创建一个结构 它是词典的词典 

1095
00:52:54,570 --> 00:52:56,700
但我会争辩说 这根本解决不了问题 

1096
00:52:56,700 --> 00:52:58,367
我不需要一本词典 

1097
00:52:58,367 --> 00:53:00,660
我现在需要一份键-值对的列表 

1098
00:53:00,660 --> 00:53:01,800
就这样 

1099
00:53:01,800 --> 00:53:05,460
所以让我提议 如果我们回到Students.py这里 

1100
00:53:05,460 --> 00:53:10,140
我们又回到了将get_name作为函数的方法中 

1101
00:53:10,140 --> 00:53:14,700
都在这里使用和定义 并且该函数返回学生的名字 

1102
00:53:14,700 --> 00:53:19,920
可以肯定的是 排序后的函数将使用

1103
00:53:19,920 --> 00:53:22,020
密钥的--在本例中为get_name--

1104
00:53:22,020 --> 00:53:25,890
在列表中的每个词典上调用该函数

1105
00:53:25,890 --> 00:53:27,540
它应该是分类的 

1106
00:53:27,540 --> 00:53:30,930
该函数GET_NAME返回字符串

1107
00:53:30,930 --> 00:53:33,600
它实际上将被用来决定事物是否

1108
00:53:33,600 --> 00:53:36,630
按这个顺序走 从左到右 或者按这个顺序 从右到左 

1109
00:53:36,630 --> 00:53:39,790
它根据返回值对这些内容进行字母排序 

1110
00:53:39,790 --> 00:53:43,020
因此请注意 我在这里并没有调用函数get_name

1111
00:53:43,020 --> 00:53:43,920
加上圆括号 

1112
00:53:43,920 --> 00:53:47,340
我只按其名称传递它 以便排序后的函数

1113
00:53:47,340 --> 00:53:50,520
可以为我调用那个获取名称函数 

1114
00:53:50,520 --> 00:53:53,940
现在 事实证明 一如既往地 如果你在定义某事 

1115
00:53:53,940 --> 00:53:57,750
可以是一个变量 或者在本例中是一个函数 然后立即使用

1116
00:53:57,750 --> 00:54:01,530
但它再也不需要该函数的名称了 

1117
00:54:01,530 --> 00:54:04,950
例如 get_name 我们实际上可以进一步加强这段代码 

1118
00:54:04,950 --> 00:54:06,300
我真的能做到 

1119
00:54:06,300 --> 00:54:09,180
我可以一起去掉get_name函数 

1120
00:54:09,180 --> 00:54:12,750
就像我可以去掉一个严格来说不是必需的变量一样 

1121
00:54:12,750 --> 00:54:16,350
而不是传递密钥 即函数的名称 

1122
00:54:16,350 --> 00:54:19,680
我实际上可以传递密钥 也就是所谓的lambda

1123
00:54:19,680 --> 00:54:22,410
函数 这是一个匿名函数 该函数

1124
00:54:22,410 --> 00:54:23,460
只是没有名字 

1125
00:54:23,460 --> 00:54:24,000
为什么？

1126
00:54:24,000 --> 00:54:27,150
因为你不需要给它一个名字 如果你只在一个地方叫它的话

1127
00:54:27,150 --> 00:54:27,690
地点 

1128
00:54:27,690 --> 00:54:30,220
而在Python中实现这一点的语法有点奇怪 

1129
00:54:30,220 --> 00:54:35,100
但如果Key从字面上等于lambda 那么有些东西

1130
00:54:35,100 --> 00:54:37,560
如Student 它是参数的名称

1131
00:54:37,560 --> 00:54:41,550
我希望这个函数会起作用 然后我甚至不会键入回车键 

1132
00:54:41,550 --> 00:54:45,150
相反 我只是说 学生 括号 名字 

1133
00:54:45,150 --> 00:54:47,620
那么我带着我的代码在这里做什么呢？

1134
00:54:47,620 --> 00:54:52,560
我突出显示的这段代码相当于get_name函数

1135
00:54:52,560 --> 00:54:54,270
我刚才实施了 

1136
00:54:54,270 --> 00:54:56,320
无可否认 语法略有不同 

1137
00:54:56,320 --> 00:54:57,330
我不用def 

1138
00:54:57,330 --> 00:54:59,580
I didn't even give it a name, like get_name.

1139
00:54:59,580 --> 00:55:03,850
I, instead, am using this other keyword in Python called lambda, which says,

1140
00:55:03,850 --> 00:55:06,660
hey, Python, here comes a function, but it has no name.

1141
00:55:06,660 --> 00:55:07,650
It's anonymous.

1142
00:55:07,650 --> 00:55:10,050
That function takes a parameter.

1143
00:55:10,050 --> 00:55:11,520
I could call it anything I want.

1144
00:55:11,520 --> 00:55:12,580
I'm calling it student.

1145
00:55:12,580 --> 00:55:13,080
Why?

1146
00:55:13,080 --> 00:55:16,230
Because this function that's passed in as key

1147
00:55:16,230 --> 00:55:20,010
is called on every one of the students in that list,

1148
00:55:20,010 --> 00:55:22,200
every one of the dictionaries in that list.

1149
00:55:22,200 --> 00:55:24,990
What do I want this anonymous function to return?

1150
00:55:24,990 --> 00:55:28,560
Well given a student, I want to index into that dictionary

1151
00:55:28,560 --> 00:55:32,910
and access their name so that the string Hermione, and Harry, and Ron,

1152
00:55:32,910 --> 00:55:34,900
and Draco is ultimately returned.

1153
00:55:34,900 --> 00:55:37,680
And that's what the sorted function uses to decide

1154
00:55:37,680 --> 00:55:42,450
how to sort these bigger dictionaries that have other keys, like house,

1155
00:55:42,450 --> 00:55:43,600
as well.

1156
00:55:43,600 --> 00:55:47,640
So if I now go back to my terminal window and run python of students.py,

1157
00:55:47,640 --> 00:55:52,140
it still seems to work the same, but it's arguably a little better design

1158
00:55:52,140 --> 00:55:55,110
because I didn't waste lines of code by defining some other function,

1159
00:55:55,110 --> 00:55:57,180
calling it in one and only one place.

1160
00:55:57,180 --> 00:56:00,948
I've done it all sort of in one breath, if you will.

1161
00:56:00,948 --> 00:56:03,990
All right, let me pause here to see if there's any questions specifically

1162
00:56:03,990 --> 00:56:10,470
about lambda, or anonymous functions, and this tightening up of the code.

1163
00:56:10,470 --> 00:56:14,850
AUDIENCE: I have a question, like whether we could define lambda twice.

1164
00:56:14,850 --> 00:56:17,040
DAVID MALAN: You can use lambda twice.

1165
00:56:17,040 --> 00:56:19,890
You can create as many anonymous functions as you'd like.

1166
00:56:19,890 --> 00:56:22,710
And you generally use them in contexts like this,

1167
00:56:22,710 --> 00:56:25,390
where you want to pass to some other function

1168
00:56:25,390 --> 00:56:27,960
a function that itself does not need a name.

1169
00:56:27,960 --> 00:56:30,570
So you can absolutely use it in more than one place.

1170
00:56:30,570 --> 00:56:32,460
I just have only one use case for it.

1171
00:56:32,460 --> 00:56:36,390
How about one other question on lambda or anonymous functions specifically?

1172
00:56:36,390 --> 00:56:43,900
AUDIENCE: What if our lambda would take more than one line, for example?

1173
00:56:43,900 --> 00:56:45,900
DAVID MALAN: Sure, if your lambda function takes

1174
00:56:45,900 --> 00:56:48,070
多个参数 这很好 

1175
00:56:48,070 --> 00:56:52,350
您可以简单地指定逗号 后跟这些参数的名称 

1176
00:56:52,350 --> 00:56:55,960
也许是x和y等等 在学生这个名字之后 

1177
00:56:55,960 --> 00:56:58,080
所以在这里 lambda看起来也有点不同

1178
00:56:58,080 --> 00:57:00,255
从def开始 因为你没有括号 

1179
00:57:00,255 --> 00:57:02,880
您没有关键字def 也没有函数名 

1180
00:57:02,880 --> 00:57:05,080
但最终 它们会达到同样的效果 

1181
00:57:05,080 --> 00:57:08,940
它们以匿名方式创建一个函数 并允许您传递该函数 

1182
00:57:08,940 --> 00:57:11,020
例如 作为这里的一些价值 

1183
00:57:11,020 --> 00:57:14,040
现在 让我们将Students.csv更改为包含

1184
00:57:14,040 --> 00:57:17,700
不是霍格沃茨的学生家 而是他们长大的家 

1185
00:57:17,700 --> 00:57:21,120
以德拉科为例 他在马尔福庄园长大 

1186
00:57:21,120 --> 00:57:24,090
罗恩在洞穴里长大 

1187
00:57:24,090 --> 00:57:29,640
哈里在女贞路4号长大 

1188
00:57:29,640 --> 00:57:33,117
根据互联网上的说法 没有人知道赫敏在哪里长大 

1189
00:57:33,117 --> 00:57:35,950
显然 这些电影对她成长的地方采取了一定的自由 

1190
00:57:35,950 --> 00:57:37,658
因此 为了这个目的 我们实际上要

1191
00:57:37,658 --> 00:57:40,900
将赫敏带走 因为她的确切出生地尚不清楚 

1192
00:57:40,900 --> 00:57:43,030
所以我们还有三个学生 

1193
00:57:43,030 --> 00:57:47,550
但如果有人现在就能发现潜在的问题 

1194
00:57:47,550 --> 00:57:49,738
这怎么可能是一件坏事呢？

1195
00:57:49,738 --> 00:57:51,780
好了 让我们来尝试在这里运行我们自己的代码 

1196
00:57:51,780 --> 00:57:53,940
让我回到Students.Py这里 

1197
00:57:53,940 --> 00:57:56,340
让我提议我只是改变我的语义

1198
00:57:56,340 --> 00:57:59,640
因为我现在想的不是霍格沃茨的房子 而是学生们的

1199
00:57:59,640 --> 00:58:00,158
拥有自己的家 

1200
00:58:00,158 --> 00:58:01,950
所以我只需要改变一些变量 

1201
00:58:01,950 --> 00:58:06,000
我要把这个房子变成一个家 把这个房子变成一个家 

1202
00:58:06,000 --> 00:58:07,500
就像这里的这个一样 

1203
00:58:07,500 --> 00:58:09,720
我仍然会按学生的名字进行排序 

1204
00:58:09,720 --> 00:58:13,950
但我要说的是 他们不是在一所房子里 而是来自一个家庭 

1205
00:58:13,950 --> 00:58:17,460
所以我刚刚用英语更改了变量的名称和语法

1206
00:58:17,460 --> 00:58:20,400
在这里 最终 打印出来 例如 哈里

1207
00:58:20,400 --> 00:58:23,860
是从女贞路4号来的 等等 

1208
00:58:23,860 --> 00:58:25,800
但让我们看看当我跑的时候会发生什么

1209
00:58:25,800 --> 00:58:30,930
此版本的Students.py的Python 已经更改了Students.csv

1210
00:58:30,930 --> 00:58:33,360
来控制那些房屋而不是房屋 

1211
00:58:33,360 --> 00:58:34,854
进来吧 

1212
00:58:34,854 --> 00:58:40,770
嗯 我们的第一个值错误 就像程序就是不工作 

1213
00:58:40,770 --> 00:58:43,340
如何解释这个值错误？

1214
00:58:43,340 --> 00:58:45,920
对此的解释相当隐晦

1215
00:58:45,920 --> 00:58:48,410
是 太多的价值无法拆开 

1216
00:58:48,410 --> 00:58:52,520
而有问题的是这条涉及Split的线 

1217
00:58:52,520 --> 00:58:57,230
怎么突然之间 在这个项目成功运行了这么多年之后 

1218
00:58:57,230 --> 00:59:00,260
5号线现在突然断了吗？

1219
00:59:00,260 --> 00:59:04,100
观众：在Students.csv中的这一行中 您有三个值 

1220
00:59:04,100 --> 00:59:07,842
有一句话说 你有三种价值观 在学生身上 

1221
00:59:07,842 --> 00:59:09,800
大卫·马兰：是的 我花了很多时间尝试

1222
00:59:09,800 --> 00:59:12,800
找出每个学生应该来自哪里 这样我们就可以

1223
00:59:12,800 --> 00:59:14,540
可能会给我们带来这个问题 

1224
00:59:14,540 --> 00:59:16,940
奇妙的是 就像这本书的第一句话

1225
00:59:16,940 --> 00:59:19,070
是女贞路四号 

1226
00:59:19,070 --> 00:59:23,160
因此 地址中有逗号这一事实是有问题的 

1227
00:59:23,160 --> 00:59:23,660
为什么？

1228
00:59:23,660 --> 00:59:27,200
因为你和我在一段时间前决定将逗号标准化--

1229
00:59:27,200 --> 00:59:33,530
CSV 逗号分隔值--表示--

1230
00:59:33,530 --> 00:59:37,800
我们对逗号进行了标准化 以便将一个值与另一个值分开 

1231
00:59:37,800 --> 00:59:41,720
如果我们在学生家里用逗号 

1232
00:59:41,720 --> 00:59:44,750
我们显然把它混淆为这个特殊的符号 

1233
00:59:44,750 --> 00:59:47,690
分裂函数现在是 仅对哈里而言 

1234
00:59:47,690 --> 00:59:50,870
试图把它分成三个值 而不仅仅是两个值 

1235
00:59:50,870 --> 00:59:53,660
这就是为什么有太多的价值需要拆解

1236
00:59:53,660 --> 00:59:57,920
因为我们只想给两个变量赋值 名字和房子 

1237
00:59:57,920 --> 00:59:59,460
现在 我们在这里能做些什么呢？

1238
00:59:59,460 --> 01:00:02,120
嗯 例如 我们可以改变我们的方法 

1239
01:00:02,120 --> 01:00:08,540
一种并不罕见的范例是使用一些不太常见的东西 

1240
01:00:08,540 --> 01:00:10,130
就像一根竖条 

1241
01:00:10,130 --> 01:00:13,550
这样我就可以把我所有的逗号改成竖线了 

1242
01:00:13,550 --> 01:00:15,710
它最终也可能回来咬我们 

1243
01:00:15,710 --> 01:00:18,410
因为如果我的文件最终在某处有竖线 

1244
01:00:18,410 --> 01:00:19,520
它仍然有可能坏掉 

1245
01:00:19,520 --> 01:00:21,530
因此 这可能不是最好的方法 

1246
01:00:21,530 --> 01:00:23,370
我也许可以做这样的事 

1247
01:00:23,370 --> 01:00:25,880
我可以逃避这些数据 就像我过去所做的那样 

1248
01:00:25,880 --> 01:00:30,230
也许我可以在任何英文字符串两边加引号

1249
01:00:30,230 --> 01:00:32,300
它本身包含一个逗号 

1250
01:00:32,300 --> 01:00:33,230
这很好 

1251
01:00:33,230 --> 01:00:36,350
我可以这么做 但是我的代码 Students.py 

1252
01:00:36,350 --> 01:00:40,250
也必须改变 因为我不能天真地分裂

1253
01:00:40,250 --> 01:00:41,240
现在是逗号 

1254
01:00:41,240 --> 01:00:43,760
在这件事上我得变得更聪明一些 

1255
01:00:43,760 --> 01:00:45,710
我将不得不考虑到斯普利特

1256
01:00:45,710 --> 01:00:48,800
仅限于不在引号内的逗号 

1257
01:00:48,800 --> 01:00:51,260
哦 事情变得越来越复杂了 

1258
01:00:51,260 --> 01:00:53,810
在这一点上 你需要退一步考虑 

1259
01:00:53,810 --> 01:00:57,320
你知道吗 如果我们有这样的问题 很有可能 其他很多人

1260
01:00:57,320 --> 01:00:59,420
在我们之前也有过同样的问题 

1261
01:00:59,420 --> 01:01:02,750
将数据存储在文件中是非常常见的 

1262
01:01:02,750 --> 01:01:06,420
专门使用CSV文件是非常常见的 

1263
01:01:06,420 --> 01:01:07,740
所以你知道吗 

1264
01:01:07,740 --> 01:01:10,760
为什么我们不看看在Python语言中是否有一个库

1265
01:01:10,760 --> 01:01:14,690
是否存在读取和/或写入CSV文件的功能？

1266
01:01:14,690 --> 01:01:16,910
与其重新发明轮子 可以说 

1267
01:01:16,910 --> 01:01:20,540
让我们看看我们是否可以通过站在其他人的肩膀上来编写更好的代码

1268
01:01:20,540 --> 01:01:22,610
在我们之前--程序员们过去了--

1269
01:01:22,610 --> 01:01:26,090
并实际使用他们的代码来读取和写入CSV 

1270
01:01:26,090 --> 01:01:30,210
这样我们就可以专注于你我关心的那部分问题了 

1271
01:01:30,210 --> 01:01:32,930
因此 让我们建议我们回到这里的代码

1272
01:01:32,930 --> 01:01:35,960
看看我们可以如何使用CSV库 

1273
01:01:35,960 --> 01:01:40,370
事实上 在Python中 有一个名为CSV的模块 

1274
01:01:40,370 --> 01:01:43,010
有关它的文档位于此处的URL

1275
01:01:43,010 --> 01:01:44,720
在Python的官方文档中 

1276
01:01:44,720 --> 01:01:49,040
但有几个功能是很容易访问的 如果我们只是

1277
01:01:49,040 --> 01:01:49,940
一头扎进去 

1278
01:01:49,940 --> 01:01:52,050
让我提议我们这样做 

1279
01:01:52,050 --> 01:01:53,840
让我在这里回到我的代码 

1280
01:01:53,840 --> 01:01:58,370
而不是重新发明这个轮子 逐行阅读文件 

1281
01:01:58,370 --> 01:02:02,390
和逗号拆分 现在处理引号和女贞驱动器 

1282
01:02:02,390 --> 01:02:04,640
以此类推 让我们改为这样做 

1283
01:02:04,640 --> 01:02:10,010
在我的程序开始时 让我启动并导入CSV模块 

1284
01:02:10,010 --> 01:02:12,530
让我们使用别人拥有的这个库

1285
01:02:12,530 --> 01:02:16,130
如果你愿意的话 写的是处理所有这些角落案件的书 

1286
01:02:16,130 --> 01:02:18,980
我还是会给自己列一张清单 一开始是空的 

1287
01:02:18,980 --> 01:02:20,630
用来存放所有这些学生的地方 

1288
01:02:20,630 --> 01:02:23,930
但我现在要稍微改变一下我的方法 

1289
01:02:23,930 --> 01:02:28,220
当我用打开这个文件时 让我进入这里

1290
01:02:28,220 --> 01:02:30,080
对此稍加改动 

1291
01:02:30,080 --> 01:02:33,620
我现在要进去说这句话 

1292
01:02:33,620 --> 01:02:38,630
Reader等于csv.ader 将文件作为输入传入 

1293
01:02:38,630 --> 01:02:42,230
事实证明 如果您阅读CSV模块的文档 

1294
01:02:42,230 --> 01:02:45,650
它附带一个名为Reader的功能 该功能的目的是

1295
01:02:45,650 --> 01:02:50,450
是为您读取CSV文件并找出逗号在哪里、在哪里

1296
01:02:50,450 --> 01:02:53,450
是引语 所有可能的转折点都在哪里 

1297
01:02:53,450 --> 01:02:55,380
只为你处理这些问题 

1298
01:02:55,380 --> 01:02:57,860
您可以覆盖某些默认设置或假设 以防

1299
01:02:57,860 --> 01:03:00,260
您使用的不是逗号 而是竖线或其他什么 

1300
01:03:00,260 --> 01:03:02,910
但在默认情况下 我认为它只是会奏效 

1301
01:03:02,910 --> 01:03:07,070
现在 我如何通过读取器而不是原始文件本身进行集成？

1302
01:03:07,070 --> 01:03:08,060
这几乎是一样的 

1303
01:03:08,060 --> 01:03:10,220
该库仍允许您执行此操作 

1304
01:03:10,220 --> 01:03:13,220
对于阅读器中的每一行-

1305
01:03:13,220 --> 01:03:15,890
所以您现在不是直接迭代文件 

1306
01:03:15,890 --> 01:03:18,020
你是在重复读者 也就是 

1307
01:03:18,020 --> 01:03:22,130
将处理所有逗号和换行符的解析 等等 

1308
01:03:22,130 --> 01:03:25,070
对于阅读器中的每一行 我要做什么？

1309
01:03:25,070 --> 01:03:27,080
好吧 现在 我要这么做了 

1310
01:03:27,080 --> 01:03:32,060
我要在我的学生名单上附上下面的词典 一本词典

1311
01:03:32,060 --> 01:03:36,680
其名称的值是当前行的第一列 

1312
01:03:36,680 --> 01:03:41,240
谁的房子 或者更确切地说 现在是这排的第二个家 

1313
01:03:41,240 --> 01:03:41,870
纵队 

1314
01:03:41,870 --> 01:03:45,890
现在 值得注意的是 文件中每一行的阅读器 

1315
01:03:45,890 --> 01:03:47,480
的确 还给我排了一排 

1316
01:03:47,480 --> 01:03:50,210
但它向我返回一行 这是一个列表 

1317
01:03:50,210 --> 01:03:52,310
就是说这个列表的第一个元素

1318
01:03:52,310 --> 01:03:54,560
将是学生的名字 就像以前一样 

1319
01:03:54,560 --> 01:03:59,030
列表中的第二个元素将是学生的家 就像现在一样

1320
01:03:59,030 --> 01:03:59,810
在此之前 

1321
01:03:59,810 --> 01:04:02,430
但如果我想访问这些元素中的每一个 

1322
01:04:02,430 --> 01:04:04,310
请记住 列表是0索引的 

1323
01:04:04,310 --> 01:04:07,490
我们从0开始计数 然后是1 而不是1 然后是2 

1324
01:04:07,490 --> 01:04:10,380
所以如果我想知道学生的名字 我会用行 括号 0 

1325
01:04:10,380 --> 01:04:13,130
如果我想去学生家 我会用ROW WARKET 1 

1326
01:04:13,130 --> 01:04:17,060
但在我的for循环中 我们可以像以前一样进行解包 

1327
01:04:17,060 --> 01:04:21,030
如果我知道CSV只有两列 

1328
01:04:21,030 --> 01:04:25,280
我甚至可以这样做--以名字命名 在Reader中回家 

1329
01:04:25,280 --> 01:04:27,710
现在我不需要使用列表表示法了 

1330
01:04:27,710 --> 01:04:32,360
我可以一下子打开所有的东西 然后说 名字在这里 家在这里 

1331
01:04:32,360 --> 01:04:35,270
我的其余代码可以完全保持不变 因为 

1332
01:04:35,270 --> 01:04:36,890
我现在在8号线上做什么？

1333
01:04:36,890 --> 01:04:39,770
我仍然在构建和以前一样的词典 

1334
01:04:39,770 --> 01:04:42,050
尽管是为了房子而不是房子 

1335
01:04:42,050 --> 01:04:45,200
我现在正在获取这些值 而不是从文件本身

1336
01:04:45,200 --> 01:04:47,062
以及我对Split的使用 但读者 

1337
01:04:47,062 --> 01:04:48,770
再说一次 读者要做的是

1338
01:04:48,770 --> 01:04:51,320
找出那些逗号在哪里 引号在哪里？

1339
01:04:51,320 --> 01:04:53,700
为你解决这个问题 

1340
01:04:53,700 --> 01:04:57,560
现在让我转到我的终端窗口 运行python of Students.py 

1341
01:04:57,560 --> 01:04:58,400
然后按Enter键 

1342
01:04:58,400 --> 01:05:04,040
现在 我们成功地看到 德拉科来自马尔福庄园 

1343
01:05:04,040 --> 01:05:07,250
哈里来自女贞路4号 逗号 

1344
01:05:07,250 --> 01:05:09,950
而罗恩是从地穴来的 

1345
01:05:09,950 --> 01:05:17,420
现在关于从CSV模块使用CSV读取器技术的问题 

1346
01:05:17,420 --> 01:05:20,990
又一次 让我们摆脱了自己阅读每一行文字的麻烦

1347
01:05:20,990 --> 01:05:23,330
然后阅读每一个逗号并拆分？

1348
01:05:23,330 --> 01:05:27,500
观众：所以我的问题跟过去的事情有关 

1349
01:05:27,500 --> 01:05:31,670
我知道你每次都在看文件--

1350
01:05:31,670 --> 01:05:39,080
在本例中 我们假设已经有了CSV文件 

1351
01:05:39,080 --> 01:05:44,540
是否有可能使文件可读可写？

1352
01:05:44,540 --> 01:05:50,960
因此 在这种情况下 您可以将这些内容写入文件 

1353
01:05:50,960 --> 01:05:53,510
但同时 你也可以

1354
01:05:53,510 --> 01:05:57,590
另一个读取文件并对其进行更改的函数

1355
01:05:57,590 --> 01:05:58,257
当你继续前进的时候？

1356
01:05:58,257 --> 01:05:59,757
大卫·马兰：这是一个非常好的问题 

1357
01:05:59,757 --> 01:06:01,070
简短的回答是 是的 

1358
01:06:01,070 --> 01:06:05,000
然而 从历史上看 文件的心理模型是盒式磁带 

1359
01:06:05,000 --> 01:06:08,300
几年前 已经不再使用了 但盒式磁带

1360
01:06:08,300 --> 01:06:10,830
是连续的 因此它们从开始处开始 

1361
01:06:10,830 --> 01:06:12,747
如果你想读到最后 你就有点

1362
01:06:12,747 --> 01:06:14,690
必须把带子倒出来才能做到这一点 

1363
01:06:14,690 --> 01:06:18,307
如今最接近的类比将是Netflix或任何流媒体

1364
01:06:18,307 --> 01:06:21,140
服务 那里有一个洗涤器 你必须从左到右 

1365
01:06:21,140 --> 01:06:22,910
你不能跳到那里或者跳到那里 

1366
01:06:22,910 --> 01:06:24,450
你没有随机访问权限 

1367
01:06:24,450 --> 01:06:27,290
所以文件的问题是 如果你想读写它们 

1368
01:06:27,290 --> 01:06:31,010
您或某个库需要跟踪您在文件中的位置

1369
01:06:31,010 --> 01:06:34,200
因此 如果你从顶部阅读 然后在底部写作 

1370
01:06:34,200 --> 01:06:37,170
当你想重新开始阅读时 你需要回到开始的地方 

1371
01:06:37,170 --> 01:06:39,045
所以这不是我们在课堂上要做的事情 

1372
01:06:39,045 --> 01:06:41,360
它的涉及面更广 但绝对可行 

1373
01:06:41,360 --> 01:06:44,402
出于我们的目的 我们通常建议您阅读该文件 

1374
01:06:44,402 --> 01:06:46,610
然后 如果你想改变它 把它写回来 

1375
01:06:46,610 --> 01:06:49,880
而不是试图做出更多零碎的改变 这是好的

1376
01:06:49,880 --> 01:06:53,480
但是 如果文件很大 而且会非常昂贵

1377
01:06:53,480 --> 01:06:55,680
改变这整件事是明智的 

1378
01:06:55,680 --> 01:06:59,690
关于这个CSV阅读器还有其他问题吗？

1379
01:06:59,690 --> 01:07:05,170
听众：可以在那个文件里写一段话吗？

1380
01:07:05,170 --> 01:07:06,170
大卫·马兰：当然 

1381
01:07:06,170 --> 01:07:09,590
现在 我正在写很小的字符串 只写名字或房子 

1382
01:07:09,590 --> 01:07:10,460
就像我以前做的那样 

1383
01:07:10,460 --> 01:07:15,730
但事实上 你完全可以想写多少文本就写多少文本 

1384
01:07:15,730 --> 01:07:18,040
关于CSV阅读器的其他问题？

1385
01:07:18,040 --> 01:07:22,780
观众：用户可以自己选择一把钥匙吗？

1386
01:07:22,780 --> 01:07:26,920
例如 输入键将是一个名称或代码 

1387
01:07:26,920 --> 01:07:29,950
大卫·马兰：答案很简单 是的 我们完全可以

1388
01:07:29,950 --> 01:07:32,680
编写一个提示用户输入名称的程序

1389
01:07:32,680 --> 01:07:34,240
还有一个家 一个名字和一个家 

1390
01:07:34,240 --> 01:07:35,740
我们可以写出这些值 

1391
01:07:35,740 --> 01:07:38,770
稍后 我们将了解如何写入CSV文件 

1392
01:07:38,770 --> 01:07:44,530
现在 我假设 作为创建Students.csv的程序员 我

1393
01:07:44,530 --> 01:07:46,270
知道栏目会是什么 

1394
01:07:46,270 --> 01:07:48,770
因此 我相应地给我的变量命名 

1395
01:07:48,770 --> 01:07:53,470
然而 这是阅读CSV的最后一个特性的一个很好的片段 它

1396
01:07:53,470 --> 01:07:57,520
就是您不必依赖于以列表形式获得行

1397
01:07:57,520 --> 01:08:00,520
并且使用方括号0或方括号1 并且 您没有

1398
01:08:00,520 --> 01:08:02,500
以这种方式手动拆包 

1399
01:08:02,500 --> 01:08:05,260
我们实际上可以变得更聪明 开始储存

1400
01:08:05,260 --> 01:08:08,500
CSV文件本身中这些列的名称 

1401
01:08:08,500 --> 01:08:12,310
事实上 如果你们中的任何人以前打开过电子表格文件 

1402
01:08:12,310 --> 01:08:16,210
在Excel、Apple数字、谷歌电子表格或类似的东西中 可能性是 

1403
01:08:16,210 --> 01:08:20,149
您已经注意到 第一行经常会有一些不同 

1404
01:08:20,149 --> 01:08:22,270
它实际上有时是黑体 或者实际上

1405
01:08:22,270 --> 01:08:26,710
包含这些列的名称 下面是这些属性的名称 

1406
01:08:26,710 --> 01:08:27,939
我们可以在这里做到这一点 

1407
01:08:27,939 --> 01:08:30,580
在Students.csv中 我不必只保持

1408
01:08:30,580 --> 01:08:32,830
假设学生的名字放在第一位

1409
01:08:32,830 --> 01:08:34,840
学生的家排在第二位 

1410
01:08:34,840 --> 01:08:39,010
我可以显式地将该信息烘焙到文件中

1411
01:08:39,010 --> 01:08:41,950
以减少未来出错的可能性 

1412
01:08:41,950 --> 01:08:46,810
从字面上看 我可以使用这个文件的第一行 然后说 名字 逗号 家 

1413
01:08:46,810 --> 01:08:50,622
所以请注意 名字并不是字面上的某人的名字 

1414
01:08:50,622 --> 01:08:52,330
家并不是一个人的家 

1415
01:08:52,330 --> 01:08:57,050
它的字面意思是单词、名字和家 用逗号分隔 

1416
01:08:57,050 --> 01:09:01,630
如果我现在返回到Students.py 并且不使用CSV阅读器 

1417
01:09:01,630 --> 01:09:04,540
但我用的是词典阅读器 我

1418
01:09:04,540 --> 01:09:09,290
我实际上可以更灵活地处理我的CSV文件 不仅仅是为了这个 

1419
01:09:09,290 --> 01:09:10,630
但对于其他例子也是如此 

1420
01:09:10,630 --> 01:09:11,740
让我来做吧 

1421
01:09:11,740 --> 01:09:14,380
与其使用CSV阅读器 不如让我使用

1422
01:09:14,380 --> 01:09:19,870
CSV字典阅读器 现在将从上到下迭代文件 

1423
01:09:19,870 --> 01:09:24,250
加载到每行文本中 而不是作为列的列表

1424
01:09:24,250 --> 01:09:26,712
而是作为一本栏目词典 

1425
01:09:26,712 --> 01:09:28,420
这件事的好处是它正在进行

1426
01:09:28,420 --> 01:09:32,200
让我现在可以自动访问这些栏目的名称 

1427
01:09:32,200 --> 01:09:35,470
我将回到刚才说的 在读者中排 

1428
01:09:35,470 --> 01:09:38,319
现在我要附加一个名字和一个家 

1429
01:09:38,319 --> 01:09:41,890
但是我如何才能访问当前行的

1430
01:09:41,890 --> 01:09:44,740
名字和当前这一排的家？

1431
01:09:44,740 --> 01:09:48,790
好的 前面我用括号0表示第一个 用括号1表示第二个

1432
01:09:48,790 --> 01:09:50,800
当我在使用阅读器的时候 

1433
01:09:50,800 --> 01:09:52,569
阅读器返回列表 

1434
01:09:52,569 --> 01:09:57,920
词典阅读器或词典阅读器一次返回一个词典 

1435
01:09:57,920 --> 01:10:01,210
因此 如果我想访问当前行的名称 

1436
01:10:01,210 --> 01:10:03,400
我可以说 行 引号/不引号 名字 

1437
01:10:03,400 --> 01:10:06,790
我可以在这里说家 行 引用/不引用 家 

1438
01:10:06,790 --> 01:10:09,220
我现在可以接触到这些相同的价值观 

1439
01:10:09,220 --> 01:10:12,130
明确地说 我需要做的唯一更改是在我的CSV文件中 

1440
01:10:12,130 --> 01:10:16,060
我不得不在第一行加上一些小提示

1441
01:10:16,060 --> 01:10:17,830
这些栏目是什么 

1442
01:10:17,830 --> 01:10:21,220
如果我现在运行这段代码 我认为它应该表现得相当好

1443
01:10:21,220 --> 01:10:23,080
相同的--Students.py的蟒蛇 

1444
01:10:23,080 --> 01:10:25,000
事实上 我们得到的是同样的句子 

1445
01:10:25,000 --> 01:10:29,950
但现在 我的代码对此数据的更改更加健壮 

1446
01:10:29,950 --> 01:10:34,270
如果我在Excel、Google电子表格或Apple中打开CSV文件

1447
01:10:34,270 --> 01:10:37,272
数字 无论出于什么原因 都会改变周围的列 

1448
01:10:37,272 --> 01:10:39,730
也许这是您与其他人共享的文件 

1449
01:10:39,730 --> 01:10:42,850
仅仅因为 他们决定以不同的方式对事物进行分类

1450
01:10:42,850 --> 01:10:46,390
向右移动列 以前 我的代码

1451
01:10:46,390 --> 01:10:50,020
因为我以为名字总是排在第一位 

1452
01:10:50,020 --> 01:10:51,940
家永远是第二位的 

1453
01:10:51,940 --> 01:10:53,800
但如果我这么做了

1454
01:10:53,800 --> 01:10:57,490
无论是在其中一个程序中手动设置 还是在这里--Home、逗号、姓名、

1455
01:10:57,490 --> 01:10:59,530
假设 我扭转了这一切 

1456
01:10:59,530 --> 01:11:04,600
家是第一位的 紧随其后的是哈里 地穴 然后是罗恩 

1457
01:11:04,600 --> 01:11:08,020
最后是马尔福庄园 然后是德拉科

1458
01:11:08,020 --> 01:11:10,285
请注意 我的文件现在完全翻转了 

1459
01:11:10,285 --> 01:11:12,910
第一列现在是第二列 第二列是第一列 

1460
01:11:12,910 --> 01:11:17,950
但我小心地更新了该文件的头 即第一行 

1461
01:11:17,950 --> 01:11:21,070
请注意我的Python代码 我根本不会去碰它 

1462
01:11:21,070 --> 01:11:24,940
我将重新运行python of Students.py 然后按Enter键 

1463
01:11:24,940 --> 01:11:26,830
而且它仍然很管用 

1464
01:11:26,830 --> 01:11:29,890
这也是防御性编码的一个例子 

1465
01:11:29,890 --> 01:11:32,530
如果有人更改了您的CSV文件、数据文件 该怎么办？

1466
01:11:32,530 --> 01:11:33,830
理想情况下 这种情况不会发生 

1467
01:11:33,830 --> 01:11:37,840
但即使现在是这样 因为我使用的是一个词典阅读器

1468
01:11:37,840 --> 01:11:42,490
我将从第一行中推断出这些列的名称 

1469
01:11:42,490 --> 01:11:44,350
我的代码一直在工作 

1470
01:11:44,350 --> 01:11:47,990
因此 如果你愿意的话 它会变得越来越好 

1471
01:11:47,990 --> 01:11:50,920
现在对这种方法有什么问题吗？

1472
01:11:50,920 --> 01:11:54,008
观众：是的 CSV文件中新行的重要性是什么？

1473
01:11:54,008 --> 01:11:56,800
David Malan：CSV文件中新行的重要性是什么？

1474
01:11:56,800 --> 01:11:58,270
这在一定程度上是一种惯例 

1475
01:11:58,270 --> 01:12:00,670
在文本文件的世界里 我们人类只有

1476
01:12:00,670 --> 01:12:04,810
几十年来 我一直保持着逐行存储数据的习惯 

1477
01:12:04,810 --> 01:12:06,370
它在视觉上很方便 

1478
01:12:06,370 --> 01:12:09,400
它很容易从文件中提取 因为您只需

1479
01:12:09,400 --> 01:12:10,450
寻找新的台词 

1480
01:12:10,450 --> 01:12:14,800
因此 新的行只是将一些数据与其他一些数据分开 

1481
01:12:14,800 --> 01:12:17,710
我们可以在键盘上使用任何其他符号 

1482
01:12:17,710 --> 01:12:21,250
但按Enter键只是为了将数据移到下一行 这是很常见的 

1483
01:12:21,250 --> 01:12:22,810
这只是个会议 

1484
01:12:22,810 --> 01:12:23,710
还有其他问题吗？

1485
01:12:23,710 --> 01:12:28,010
观众：如果你只有名字和家庭 它似乎运行得很好 

1486
01:12:28,010 --> 01:12:32,155
我在想 如果你想输入更多的数据 会发生什么 

1487
01:12:34,750 --> 01:12:40,115
比方说 你想在名字和房子的基础上加一栋房子 

1488
01:12:40,115 --> 01:12:43,240
大卫·马兰：当然可以 如果你想把房子加回去--所以如果我进去

1489
01:12:43,240 --> 01:12:47,980
最后加上豪斯 我在这里说 格兰芬多代表哈利 

1490
01:12:47,980 --> 01:12:53,890
格兰芬多代表罗恩 斯莱特林代表德拉科 现在我有三个专栏 

1491
01:12:53,890 --> 01:12:57,010
实际上 如果你愿意的话--家在左边 名字在中间 

1492
01:12:57,010 --> 01:13:00,640
右边的房子 每个房子都用逗号分隔 上面有奇怪的东西 

1493
01:13:00,640 --> 01:13:03,610
像第四个一样 逗号 女贞路仍然被引用 

1494
01:13:03,610 --> 01:13:07,540
请注意 如果我返回到Students.py 并且我根本不更改代码

1495
01:13:07,540 --> 01:13:11,230
并运行python of Students.py 它仍然可以正常工作 

1496
01:13:11,230 --> 01:13:14,140
这就是字典阅读器的强大之处 

1497
01:13:14,140 --> 01:13:15,730
它可以随着时间的推移而改变 

1498
01:13:15,730 --> 01:13:17,620
它可以有越来越多的列 

1499
01:13:17,620 --> 01:13:20,290
您现有的代码不会崩溃 

1500
01:13:20,290 --> 01:13:23,500
可以说 你的密码会被破解 会变得更加脆弱 

1501
01:13:23,500 --> 01:13:26,860
如果你做这样的假设 第一栏总是名字 

1502
01:13:26,860 --> 01:13:28,810
第二列永远是豪斯 

1503
01:13:28,810 --> 01:13:32,590
如果这些假设被打破 事情将很快破裂--

1504
01:13:32,590 --> 01:13:34,750
所以在这种情况下不是问题 

1505
01:13:34,750 --> 01:13:37,720
好吧 让我提议 除了阅读CSV 

1506
01:13:37,720 --> 01:13:40,960
至少让我们来看看我们可能会如何编写一个CSV 

1507
01:13:40,960 --> 01:13:44,410
如果您正在编写一个程序 其中不仅要存储学生的名字 

1508
01:13:44,410 --> 01:13:48,920
但也许他们的家也在一个文件中 我们怎么能不断地添加到这个文件中呢？

1509
01:13:48,920 --> 01:13:52,460
让我继续删除Students.csv的内容

1510
01:13:52,460 --> 01:13:56,300
只需重新添加一个简单的行、名称、逗号、主页、

1511
01:13:56,300 --> 01:14:00,530
以便预期在此文件中插入更多的姓名和住所 

1512
01:14:00,530 --> 01:14:03,780
然后让我转到Students.py 让我重新开始

1513
01:14:03,780 --> 01:14:05,600
以便这次写出数据 

1514
01:14:05,600 --> 01:14:07,730
我仍然要继续并导入CSV 

1515
01:14:07,730 --> 01:14:11,870
我现在将继续并提示用户输入他们的名字--所以

1516
01:14:11,870 --> 01:14:15,410
输入 引用/不引用 你叫什么名字？

1517
01:14:15,410 --> 01:14:18,170
接下来 我会提示用户他们的家--

1518
01:14:18,170 --> 01:14:23,780
所以家等于输入 引号/不引号 你的家在哪里？

1519
01:14:23,780 --> 01:14:26,000
现在我要继续打开文件 

1520
01:14:26,000 --> 01:14:29,090
但这一次是写作而不是阅读 如下所示--

1521
01:14:29,090 --> 01:14:32,900
带有开放的、引用/不引用的Students.csv 

1522
01:14:32,900 --> 01:14:35,210
我要在追加模式下打开它 这样我

1523
01:14:35,210 --> 01:14:38,210
不断增加越来越多的学生和家庭到文件中 

1524
01:14:38,210 --> 01:14:40,820
而不是仅仅覆盖整个文件本身 

1525
01:14:40,820 --> 01:14:43,250
我将使用变量名FILE 

1526
01:14:43,250 --> 01:14:46,460
然后 我将继续为自己设置一个名为Writer的变量 

1527
01:14:46,460 --> 01:14:49,790
我要将它设置为等于另一个函数的返回值

1528
01:14:49,790 --> 01:14:53,060
在名为csv.Writer的CSV模块中 

1529
01:14:53,060 --> 01:14:59,600
而编写器函数将那里的文件变量作为其唯一参数 

1530
01:14:59,600 --> 01:15:01,460
现在我要继续做这件事 

1531
01:15:01,460 --> 01:15:04,220
我要说 编剧 编剧 我是

1532
01:15:04,220 --> 01:15:09,020
要将我要写入文件的行传递给Writerow

1533
01:15:09,020 --> 01:15:10,470
具体地说 就是一份清单 

1534
01:15:10,470 --> 01:15:13,890
所以我要给这张名单写上名字 逗号 家 

1535
01:15:13,890 --> 01:15:16,140
当然 这就是这些变量的内容 

1536
01:15:16,140 --> 01:15:18,170
现在 我将继续并保存文件 

1537
01:15:18,170 --> 01:15:22,220
我将继续运行python of Students.py 然后按Enter键 

1538
01:15:22,220 --> 01:15:23,270
你叫什么名字？

1539
01:15:23,270 --> 01:15:28,870
好吧 让我继续输入哈里作为我的名字和数字4 

1540
01:15:28,870 --> 01:15:31,690
逗号 女贞路 回车 

1541
01:15:31,690 --> 01:15:34,750
现在请注意 输入本身确实有一个逗号 

1542
01:15:34,750 --> 01:15:37,450
因此 如果我现在打开我的CSV文件 请注意

1543
01:15:37,450 --> 01:15:40,090
它被自动引用给我 所以

1544
01:15:40,090 --> 01:15:41,860
从该文件的后续读取不会

1545
01:15:41,860 --> 01:15:46,007
把这个逗号和哈里和他家之间的实际逗号搞混了 

1546
01:15:46,007 --> 01:15:48,340
好吧 让我继续运行它几次 

1547
01:15:48,340 --> 01:15:51,340
让我继续并重新运行python of Students.py 

1548
01:15:51,340 --> 01:15:55,300
让我继续输入 这一次罗恩和他的家是洞穴 

1549
01:15:55,300 --> 01:15:58,210
让我们回到Students.csv看看它是什么样子 

1550
01:15:58,210 --> 01:16:02,140
现在我们看到Ron 逗号 Burrow已经被自动添加到文件中 

1551
01:16:02,140 --> 01:16:03,520
让我们再来一次--

1552
01:16:03,520 --> 01:16:06,190
Python of Students.py 请输入 

1553
01:16:06,190 --> 01:16:10,900
让我们继续给出德拉科的名字和他的家 那将是马尔福庄园 

1554
01:16:10,900 --> 01:16:11,590
进来吧 

1555
01:16:11,590 --> 01:16:14,200
如果我们回到Students.csv 现在 我们

1556
01:16:14,200 --> 01:16:15,940
确保Draco在文件本身中 

1557
01:16:15,940 --> 01:16:19,060
而且图书馆不仅负责写每一行 

1558
01:16:19,060 --> 01:16:20,140
根据函数的名称 

1559
01:16:20,140 --> 01:16:23,710
它还处理可以说是任何字符串的转义

1560
01:16:23,710 --> 01:16:27,018
它们包含一个逗号 就像哈利自己的家一样 

1561
01:16:27,018 --> 01:16:28,810
好吧 事实证明 还有另一种方法

1562
01:16:28,810 --> 01:16:32,920
我们可以实施同样的计划 而不必担心

1563
01:16:32,920 --> 01:16:35,650
一次又一次地传递一个列表 

1564
01:16:35,650 --> 01:16:39,580
结果是 如果我们记录下名字和家 

1565
01:16:39,580 --> 01:16:42,100
我们可以用字典之类的东西

1566
01:16:42,100 --> 01:16:43,580
那些键和那些值

1567
01:16:43,580 --> 01:16:46,720
所以让我继续并备份并从文件中删除这些学生 

1568
01:16:46,720 --> 01:16:49,660
再次只留下标题行-- name、逗号、home 

1569
01:16:49,660 --> 01:16:51,550
让我转到students.py 

1570
01:16:51,550 --> 01:16:54,130
这一次 我们没有使用CSV writer 

1571
01:16:54,130 --> 01:16:57,010
我将继续使用csv.DictWriter 

1572
01:16:57,010 --> 01:16:58,900
也就是一个词典编纂者

1573
01:16:58,900 --> 01:17:00,890
以同样的方式打开文件 

1574
01:17:00,890 --> 01:17:04,840
但是 与其写一行作为这个名称列表 

1575
01:17:04,840 --> 01:17:08,050
逗号 家 我现在要做的是 

1576
01:17:08,050 --> 01:17:11,950
我将首先输出一个实际的字典 

1577
01:17:11,950 --> 01:17:14,550
第一个键是name、冒号 然后

1578
01:17:14,550 --> 01:17:17,050
其值将是输入的名称 

1579
01:17:17,050 --> 01:17:19,468
我将传入一个家的钥匙 引用/不引用 

1580
01:17:19,468 --> 01:17:22,010
当然 它的值就是输入的房子

1581
01:17:22,010 --> 01:17:24,520
但对于DictWriter 我确实需要给它

1582
01:17:24,520 --> 01:17:29,440
一个关于这些列在写出来时的顺序的提示 

1583
01:17:29,440 --> 01:17:33,530
即使顺序改变了 它们也可以被读取 

1584
01:17:33,530 --> 01:17:36,070
让我继续传递字段名 

1585
01:17:36,070 --> 01:17:39,460
是DictWriter的第二个参数 等于 然后

1586
01:17:39,460 --> 01:17:41,890
我所知道的实际列的列表

1587
01:17:41,890 --> 01:17:45,340
在这个文件中 当然 是名字 逗号 家 

1588
01:17:45,340 --> 01:17:47,410
那些时候 在引号里 因为这是 确实 

1589
01:17:47,410 --> 01:17:50,200
列的字符串名称 可以这么说 

1590
01:17:50,200 --> 01:17:52,390
我打算写在那个文件里 

1591
01:17:52,390 --> 01:17:55,340
好吧 现在让我继续 去我的终端窗口 

1592
01:17:55,340 --> 01:17:57,190
运行students.py的python 

1593
01:17:57,190 --> 01:17:59,860
这一次 我将再次输入哈利的名字 

1594
01:17:59,860 --> 01:18:05,170
我再输入四号逗号女贞路回车

1595
01:18:05,170 --> 01:18:07,360
现在让我们回到students. csv 

1596
01:18:07,360 --> 01:18:11,380
瞧 哈利又回到了文件中 它被正确地转义或引用了 

1597
01:18:11,380 --> 01:18:14,830
我敢肯定如果我们再和罗恩和陋居合作

1598
01:18:14,830 --> 01:18:20,320
让我们继续第三次与德拉科和马尔福庄园合作 

1599
01:18:20,320 --> 01:18:21,100
进来吧 

1600
01:18:21,100 --> 01:18:22,810
让我们回到Students.csv 

1601
01:18:22,810 --> 01:18:26,200
通过这位词典编写者 我们现在拥有了这三个

1602
01:18:26,200 --> 01:18:27,530
这些学生也是如此 

1603
01:18:27,530 --> 01:18:31,480
因此 对于CSV编写器 责任在我们身上

1604
01:18:31,480 --> 01:18:34,270
传递我们的所有值的列表

1605
01:18:34,270 --> 01:18:37,870
我想从左到右 和一个词典编写者 从技术上讲 

1606
01:18:37,870 --> 01:18:39,760
它们可以在词典中以任何顺序出现 

1607
01:18:39,760 --> 01:18:43,120
事实上 我本可以正确地这么做的 

1608
01:18:43,120 --> 01:18:45,640
在回家的路上 后面跟着名字 

1609
01:18:45,640 --> 01:18:46,720
但这是一本词典 

1610
01:18:46,720 --> 01:18:50,322
因此 只要密钥在那里 这种情况下的排序就不重要了

1611
01:18:50,322 --> 01:18:51,280
它的价值就在那里 

1612
01:18:51,280 --> 01:18:55,660
由于我已将字段名作为第二个参数传递给DictWriter 

1613
01:18:55,660 --> 01:18:59,410
它确保库准确地知道哪一列

1614
01:18:59,410 --> 01:19:02,920
分别包含名称或主页 

1615
01:19:02,920 --> 01:19:07,300
现在有没有什么关于词典阅读 词典写作 

1616
01:19:07,300 --> 01:19:10,480
或者更笼统地说是CSV？

1617
01:19:10,480 --> 01:19:14,200
观众：对我来说 在任何特定情况下

1618
01:19:14,200 --> 01:19:17,110
使用单引号还是双引号？

1619
01:19:17,110 --> 01:19:20,980
因为在打印之后 我们使用单引号

1620
01:19:20,980 --> 01:19:24,220
来表示词典的关键字 

1621
01:19:24,220 --> 01:19:30,363
但在阅读或写作后 我们使用双引号 

1622
01:19:30,363 --> 01:19:31,780
大卫·马兰：这是个好问题 

1623
01:19:31,780 --> 01:19:36,340
在Python中 您通常可以使用双引号 也可以使用单引号 

1624
01:19:36,340 --> 01:19:37,430
这都无关紧要 

1625
01:19:37,430 --> 01:19:40,660
你应该保持自我一致 这样你的代码才能在风格上

1626
01:19:40,660 --> 01:19:42,340
从头到尾看起来都是一样的 

1627
01:19:42,340 --> 01:19:45,610
然而 有时交替是必要的 

1628
01:19:45,610 --> 01:19:49,870
如果您已经在使用双引号 就像我之前使用长f字符串一样 

1629
01:19:49,870 --> 01:19:52,780
但在那根f弦里面 我是在插补

1630
01:19:52,780 --> 01:19:55,240
一些变量的值使用大括号 

1631
01:19:55,240 --> 01:19:57,760
这些变量都是字典 

1632
01:19:57,760 --> 01:20:02,230
为了在词典中建立索引 您可以使用方括号

1633
01:20:02,230 --> 01:20:03,370
然后引用 

1634
01:20:03,370 --> 01:20:05,690
但如果你已经在这里用双引号了 

1635
01:20:05,690 --> 01:20:09,250
你通常应该在这里使用单引号 反之亦然 

1636
01:20:09,250 --> 01:20:12,683
但除此之外 我习惯于在任何地方使用双引号 

1637
01:20:12,683 --> 01:20:15,100
其他人则养成了到处使用单引号的习惯 

1638
01:20:15,100 --> 01:20:20,676
只有当一个人可能被混淆为另一个人时 这才是重要的 

1639
01:20:20,676 --> 01:20:24,200
关于词典写作或阅读的其他问题？

1640
01:20:24,200 --> 01:20:30,790
观众：是的 我的问题是 我们可以在任何程序中使用多个CSV文件吗？

1641
01:20:30,790 --> 01:20:31,790
大卫·马兰：当然 

1642
01:20:31,790 --> 01:20:33,830
您可以使用任意数量的CSV文件 

1643
01:20:33,830 --> 01:20:37,190
这只是您可以用来保存数据的一种格式 

1644
01:20:37,190 --> 01:20:40,910
关于CSV或文件I/O的其他问题？

1645
01:20:40,910 --> 01:20:43,110
观众：谢谢你回答我的问题 

1646
01:20:43,110 --> 01:20:49,580
所以 当你把文件作为词典阅读时 

1647
01:20:49,580 --> 01:20:52,910
你叫人给田地打了电话 

1648
01:20:52,910 --> 01:20:55,280
当你在看书的时候 你就不能先把它排好吗？

1649
01:20:55,280 --> 01:21:03,830
以前版本的Students.py文件 当您读取每行时 

1650
01:21:03,830 --> 01:21:07,490
你是按名字划分字段的 

1651
01:21:10,370 --> 01:21:13,310
是啊 所以当你加入学生名单的时候 

1652
01:21:13,310 --> 01:21:20,200
你就不能叫一下行和读者吗 学生们 追加行 

1653
01:21:20,200 --> 01:21:22,340
而不是给每个油田命名？

1654
01:21:22,340 --> 01:21:23,690
大卫·马兰：哦 非常聪明 

1655
01:21:23,690 --> 01:21:28,880
简而言之 是的 只要DictReader返回

1656
01:21:28,880 --> 01:21:32,480
一次一本词典 当你循环它的时候 

1657
01:21:32,480 --> 01:21:34,550
ROW已经将成为一本词典 

1658
01:21:34,550 --> 01:21:38,060
所以 是的 你真的可以逃脱惩罚 

1659
01:21:38,060 --> 01:21:41,510
在这种情况下 效果真的是一样的 

1660
01:21:41,510 --> 01:21:42,620
观察得很好 

1661
01:21:42,620 --> 01:21:46,100
再问一个关于CSV的问题如何？

1662
01:21:46,100 --> 01:21:51,260
观众：是的 当我阅读我过去处理数据的CSV时 

1663
01:21:51,260 --> 01:21:53,550
很多事情都可能出错 

1664
01:21:53,550 --> 01:21:57,170
我不知道这是不是一个你能用几句话就能回答的问题 

1665
01:21:57,170 --> 01:22:04,472
但是 有没有什么最佳实践来仔细检查没有出现错误呢？

1666
01:22:04,472 --> 01:22:06,180
大卫·马兰：这是一个非常好的问题 

1667
01:22:06,180 --> 01:22:10,730
我会说 一般来说 如果您使用代码来生成CSV

1668
01:22:10,730 --> 01:22:14,330
为了阅读CSV 而且你使用的是一个很好的图书馆 

1669
01:22:14,330 --> 01:22:16,080
从理论上讲 应该不会出什么差错 

1670
01:22:16,080 --> 01:22:20,960
如果库是100%正确的 那么它应该是100%正确的 

1671
01:22:20,960 --> 01:22:22,850
你和我往往是问题所在 

1672
01:22:22,850 --> 01:22:27,110
当你让人触摸CSV时 或者当Excel或Apple数字时 

1673
01:22:27,110 --> 01:22:29,030
或其他一些可能不涉及的工具

1674
01:22:29,030 --> 01:22:30,980
与代码的预期保持一致 

1675
01:22:30,980 --> 01:22:33,500
那么 是的 事情可能会破裂 

1676
01:22:33,500 --> 01:22:37,100
目标是--有时候 说实话 解决方案是手动修复 

1677
01:22:37,100 --> 01:22:40,610
您可以进入并修复CSV 或者需要进行大量错误检查 

1678
01:22:40,610 --> 01:22:44,450
或者你有很多尝试 只是为了容忍数据中的错误 

1679
01:22:44,450 --> 01:22:47,900
但总的来说 我想说的是 如果您使用CSV或任何文件格式

1680
01:22:47,900 --> 01:22:50,990
在程序内部读取和写入它 

1681
01:22:50,990 --> 01:22:52,580
你不应该担心这一点 

1682
01:22:52,580 --> 01:22:55,190
你和我 人类 通常都是问题所在

1683
01:22:55,190 --> 01:22:59,000
说话--不是程序员 而是那些文件的用户 

1684
01:22:59,000 --> 01:23:02,930
好吧 请允许我提议我们把CSV抛在脑后

1685
01:23:02,930 --> 01:23:04,850
它们不是您唯一的文件格式

1686
01:23:04,850 --> 01:23:07,310
可以用来读写数据 

1687
01:23:07,310 --> 01:23:10,760
事实上 它们是一种流行的格式 就像原始文本文件一样--

1688
01:23:10,760 --> 01:23:11,690
.txt文件 

1689
01:23:11,690 --> 01:23:14,210
但你可以存储数据 真的 以任何你想要的方式 

1690
01:23:14,210 --> 01:23:16,730
我们之所以选择CSV 是因为它具有代表性

1691
01:23:16,730 --> 01:23:18,800
您可以如何从文件读取和写入

1692
01:23:18,800 --> 01:23:22,910
并以一种结构化的方式进行操作 其中您可以以某种方式拥有多个密钥 

1693
01:23:22,910 --> 01:23:26,930
多个值都在同一个文件中 而不必求助于

1694
01:23:26,930 --> 01:23:29,160
也称为二进制文件 

1695
01:23:29,160 --> 01:23:32,750
所以二进制文件实际上就是一个只有0和1的文件 

1696
01:23:32,750 --> 01:23:36,890
它们可以按照您想要的任何图案进行布局 尤其是

1697
01:23:36,890 --> 01:23:39,080
如果您想存储非文本信息 

1698
01:23:39,080 --> 01:23:43,200
但也可能是图形、音频或视频信息 

1699
01:23:43,200 --> 01:23:45,560
所以事实证明 Python真的很好

1700
01:23:45,560 --> 01:23:48,320
当谈到拥有所有的库时 真的 什么都有 

1701
01:23:48,320 --> 01:23:50,660
事实上 有一个很受欢迎的图书馆叫

1702
01:23:50,660 --> 01:23:55,340
枕头 让您也可以浏览图像文件

1703
01:23:55,340 --> 01:23:57,980
以及对图像文件执行操作 

1704
01:23:57,980 --> 01:24:00,230
你可以应用滤镜 就像Instagram一样 

1705
01:24:00,230 --> 01:24:02,670
您也可以设置它们的动画 

1706
01:24:02,670 --> 01:24:05,900
所以我想我们现在要做的就是留下文本文件

1707
01:24:05,900 --> 01:24:08,150
再处理一次演示 这次 

1708
01:24:08,150 --> 01:24:13,290
而是专注于这个特定的库和图像文件 

1709
01:24:13,290 --> 01:24:16,250
所以让我提议我们到这里来VS Code

1710
01:24:16,250 --> 01:24:19,910
并创建一个程序 最终创建一个动画GIF 

1711
01:24:19,910 --> 01:24:23,225
如今 这些东西以迷因和动画的形式无处不在 

1712
01:24:23,225 --> 01:24:24,350
还有贴纸之类的 

1713
01:24:24,350 --> 01:24:27,380
而一个动画GIF实际上只是一个图像文件

1714
01:24:27,380 --> 01:24:29,840
里面有多个图像 

1715
01:24:29,840 --> 01:24:34,790
你的电脑或手机会一个接一个地向你展示这些图像 

1716
01:24:34,790 --> 01:24:37,820
有时是无休止的循环 一次又一次 

1717
01:24:37,820 --> 01:24:41,480
只要有足够的图像 它就会创造出动画的错觉

1718
01:24:41,480 --> 01:24:44,600
因为你和我的大脑在视觉上填补了空白

1719
01:24:44,600 --> 01:24:47,630
并假设如果有什么东西在移动 即使你只是

1720
01:24:47,630 --> 01:24:51,230
看到每秒一帧或其某个序列 

1721
01:24:51,230 --> 01:24:52,730
它看起来像一部动画 

1722
01:24:52,730 --> 01:24:55,700
这就像是视频文件的简单化版本 

1723
01:24:55,700 --> 01:25:00,710
好吧 让我提议我们从几件戏服开始

1724
01:25:00,710 --> 01:25:02,600
来自另一种流行的编程语言 

1725
01:25:02,600 --> 01:25:05,780
让我继续在这里打开我的第一件戏服 1号 

1726
01:25:05,780 --> 01:25:09,260
假设这是一件服装 或者 真的 只是一张静态图像

1727
01:25:09,260 --> 01:25:11,150
在这里 starume1.gif 

1728
01:25:11,150 --> 01:25:14,600
这只是一只猫的静态照片 一点动作都没有 

1729
01:25:14,600 --> 01:25:18,770
现在让我们继续 打开第二个 starume2.gif 

1730
01:25:18,770 --> 01:25:20,910
这看起来有点不同 

1731
01:25:20,910 --> 01:25:23,510
注意--我会来回检查--这只猫的腿

1732
01:25:23,510 --> 01:25:27,530
有一点不同 所以这是版本1 

1733
01:25:27,530 --> 01:25:29,570
这是第二版 

1734
01:25:29,570 --> 01:25:32,150
现在 这些猫来自麻省理工学院的一种编程语言

1735
01:25:32,150 --> 01:25:34,490
称为Scratch 它允许你 非常形象地 

1736
01:25:34,490 --> 01:25:36,410
让这一切变得生动起来 甚至更多 

1737
01:25:36,410 --> 01:25:41,600
但是我们将只使用这两个静态图像 分别是arcume1和stagume2

1738
01:25:41,600 --> 01:25:44,660
创建我们自己的动画GIF 在此之后 您

1739
01:25:44,660 --> 01:25:48,800
可以给朋友发短信或给他们发消息 就像任何在线表情包一样 

1740
01:25:48,800 --> 01:25:52,270
好吧 让我建议我们创建这个动画GIF 而不是

1741
01:25:52,270 --> 01:25:54,770
只要使用我们下载的一些现成的程序 

1742
01:25:54,770 --> 01:25:56,450
而是通过编写我们自己的代码 

1743
01:25:56,450 --> 01:25:59,630
让我继续运行starumes.py的代码

1744
01:25:59,630 --> 01:26:02,090
并创建我们自己的项目 这将需要

1745
01:26:02,090 --> 01:26:07,460
作为输入 两个甚至更多的图像文件 然后生成一个动画GIF

1746
01:26:07,460 --> 01:26:12,230
通过来回切换来创建这个动画GIF

1747
01:26:12,230 --> 01:26:14,627
在这两个图像之间没完没了地 

1748
01:26:14,627 --> 01:26:15,960
那么 我该怎么做呢？

1749
01:26:15,960 --> 01:26:19,520
好吧 让我们假设这将是一个名为staumes.py的程序 

1750
01:26:19,520 --> 01:26:22,280
需要两个命令行参数 即名称

1751
01:26:22,280 --> 01:26:26,490
在这些文件中 我们要来回设置动画的个别服装 

1752
01:26:26,490 --> 01:26:29,060
要做到这一点 我将导入系统 以便我们最终

1753
01:26:29,060 --> 01:26:31,190
有权访问sys.argv 

1754
01:26:31,190 --> 01:26:35,090
然后 我将从这个枕头库导入对图像的支持

1755
01:26:35,090 --> 01:26:35,750
具体地说 

1756
01:26:35,750 --> 01:26:41,520
因此 根据图书馆的文档 从PIL导入图像--大写I 

1757
01:26:41,520 --> 01:26:44,270
现在我要给自己列出一个名为图像的空列表 

1758
01:26:44,270 --> 01:26:48,230
这样我就有了一个列表 可以在其中存储一张、两张或多张这样的图像 

1759
01:26:48,230 --> 01:26:50,150
现在让我做这件事 

1760
01:26:50,150 --> 01:26:56,540
对于sys.argv中的每个参数 我将继续创建一个新的映像

1761
01:26:56,540 --> 01:27:03,650
变量 将其设置为等于此Image.Open函数 传入arg 

1762
01:27:03,650 --> 01:27:05,030
现在 这是在做什么？

1763
01:27:05,030 --> 01:27:07,400
我建议 最终 我想成为

1764
01:27:07,400 --> 01:27:10,190
能够运行starumes.py的python 然后

1765
01:27:10,190 --> 01:27:14,330
作为命令行参数 指定starume1.gif space starume2.gif 

1766
01:27:14,330 --> 01:27:18,740
所以我想把命令行中的那些文件名作为参数 

1767
01:27:18,740 --> 01:27:20,370
那我在这里做什么？

1768
01:27:20,370 --> 01:27:25,670
我正在对sys.argv迭代我的命令行参数中的所有单词 

1769
01:27:25,670 --> 01:27:27,620
我正在创建一个名为IMAGE的变量 我

1770
01:27:27,620 --> 01:27:30,200
从枕头传递给此函数Image.Open

1771
01:27:30,200 --> 01:27:32,330
库 这个特定的参数 

1772
01:27:32,330 --> 01:27:35,810
从本质上讲 该库将打开该图像

1773
01:27:35,810 --> 01:27:38,960
在某种程度上 它给了我很多操纵它的功能 

1774
01:27:38,960 --> 01:27:40,040
就像动画一样 

1775
01:27:40,040 --> 01:27:48,180
现在 我将继续并将该特定图像追加到我的图像列表中 

1776
01:27:48,180 --> 01:27:48,840
就是这样 

1777
01:27:48,840 --> 01:27:51,890
所以这个循环的目的就是在命令行上迭代

1778
01:27:51,890 --> 01:27:55,310
参数 并使用该库打开这些图像 

1779
01:27:55,310 --> 01:27:57,783
最后一行非常简单 

1780
01:27:57,783 --> 01:27:58,700
我要说的是 

1781
01:27:58,700 --> 01:28:02,120
我将获取其中的第一张图片 它将出现在我的列表中

1782
01:28:02,120 --> 01:28:05,870
在位置0 我要将其保存到磁盘 

1783
01:28:05,870 --> 01:28:08,060
也就是说 我要保存这个文件 

1784
01:28:08,060 --> 01:28:10,730
在过去 当我们使用CSV或文本文件时 

1785
01:28:10,730 --> 01:28:12,590
我必须打开文件 

1786
01:28:12,590 --> 01:28:15,340
我不得不写文件 甚至可能是结案 

1787
01:28:15,340 --> 01:28:17,090
我不需要用这个图书馆做到这一点 

1788
01:28:17,090 --> 01:28:20,750
枕头库负责打开、关闭和保存

1789
01:28:20,750 --> 01:28:23,000
给我打个电话就行了 

1790
01:28:23,000 --> 01:28:24,780
我将调用此保存函数 

1791
01:28:24,780 --> 01:28:27,740
留个空白点 因为我有很多论点要讲 

1792
01:28:27,740 --> 01:28:29,780
我要换到另一条线 这样才合身 

1793
01:28:29,780 --> 01:28:33,290
我将传入要创建的文件的名称 

1794
01:28:33,290 --> 01:28:34,730
Costumes.gif--

1795
01:28:34,730 --> 01:28:37,310
这将是我的动画GIF的名字 

1796
01:28:37,310 --> 01:28:41,510
我要告诉这个图书馆保存所有的相框

1797
01:28:41,510 --> 01:28:44,870
所以第一套服装 第二套服装 甚至

1798
01:28:44,870 --> 01:28:46,190
如果我给他们更多 

1799
01:28:46,190 --> 01:28:49,220
然后 我将在第一张图片上添加--

1800
01:28:49,220 --> 01:28:55,310
图像0--下面的图像等于该图像列表 

1801
01:28:55,310 --> 01:28:57,650
这有点聪明 但我还是要这么做 

1802
01:28:57,650 --> 01:29:01,640
我想在那里添加下一个图像 图像[1] 

1803
01:29:01,640 --> 01:29:05,180
现在我想将持续时间指定为200毫秒

1804
01:29:05,180 --> 01:29:08,730
对于这些帧中的每一帧 我希望它永远循环 

1805
01:29:08,730 --> 01:29:12,170
如果您指定loop=0 也就是时间0 

1806
01:29:12,170 --> 01:29:15,620
这意味着它不会循环有限次 

1807
01:29:15,620 --> 01:29:18,080
而是无数次 

1808
01:29:18,080 --> 01:29:20,210
我还需要做另外一件事 

1809
01:29:20,210 --> 01:29:24,740
回想一下 sys.argv不仅包含单词i

1810
01:29:24,740 --> 01:29:29,960
在我的程序名之后输入 但sys.argv还包含什么？

1811
01:29:29,960 --> 01:29:33,710
如果您回想一下我们对命令行参数的讨论 

1812
01:29:33,710 --> 01:29:38,240
除了我要输入的单词 还有什么是sys.argv 

1813
01:29:38,240 --> 01:29:41,510
就像starume1.gif和starume2一样？

1814
01:29:41,510 --> 01:29:45,530
观众：是的 所以我们实际上会得到节目的原名

1815
01:29:45,530 --> 01:29:48,053
我们想要运行 那就是engumes.py 

1816
01:29:48,053 --> 01:29:50,720
大卫·马兰：事实上 我们会得到这个项目的原始名称 

1817
01:29:50,720 --> 01:29:53,270
在本例中 这显然不是GIF 

1818
01:29:53,270 --> 01:29:57,230
所以请记住 在Python中使用切片 我们可以做到这一点 

1819
01:29:57,230 --> 01:30:01,670
如果sys.argv是一个列表 并且我们想要从该列表中分一杯羹 那么所有

1820
01:30:01,670 --> 01:30:05,330
在第一个元素之后 我们可以做1 冒号 这表示 

1821
01:30:05,330 --> 01:30:10,220
从位置1开始 而不是0 然后一直取一片到最后 

1822
01:30:10,220 --> 01:30:12,620
所以给我所有的东西 除了第一件事

1823
01:30:12,620 --> 01:30:16,700
在这份清单中 麦肯齐认为 这就是该项目的名称 

1824
01:30:16,700 --> 01:30:19,980
现在 如果我没有犯任何错误 让我们看看会发生什么 

1825
01:30:19,980 --> 01:30:22,880
我将运行bothon of starumes.py 现在我正在

1826
01:30:22,880 --> 01:30:25,400
我将具体说明我想要制作动画的两个图像--

1827
01:30:25,400 --> 01:30:30,290
因此 starume1.gif和starume2.gif 

1828
01:30:30,290 --> 01:30:32,240
代码现在要做什么？

1829
01:30:32,240 --> 01:30:34,520
简单地说 我们使用的是sys库

1830
01:30:34,520 --> 01:30:36,380
来访问这些命令行参数 

1831
01:30:36,380 --> 01:30:39,140
我们正在使用枕头库来处理这些文件

1832
01:30:39,140 --> 01:30:42,680
作为图像 并具有该库附带的所有功能 

1833
01:30:42,680 --> 01:30:46,490
我使用这个图像列表只是为了积累所有这些图像 一个

1834
01:30:46,490 --> 01:30:48,110
一次从命令行执行 

1835
01:30:48,110 --> 01:30:52,520
在第7行到第9行中 我只是使用一个循环来迭代所有它们

1836
01:30:52,520 --> 01:30:56,750
在图书馆打开它们后 只需将它们添加到这个列表中 

1837
01:30:56,750 --> 01:31:00,170
最后一步 实际上只是一行代码被分成三行 所以

1838
01:31:00,170 --> 01:31:02,990
这一切都符合 我要保存第一张图像 

1839
01:31:02,990 --> 01:31:07,340
但我要求图书馆在上面附加另一张图片

1840
01:31:07,340 --> 01:31:09,550
也一样--不是括号0 而是括号1 

1841
01:31:09,550 --> 01:31:12,010
如果我有更多 我也可以表达出来 

1842
01:31:12,010 --> 01:31:14,260
我想将所有这些文件保存在一起 

1843
01:31:14,260 --> 01:31:17,680
我想暂停200毫秒--五分之一秒

1844
01:31:17,680 --> 01:31:18,940
在每一帧之间 

1845
01:31:18,940 --> 01:31:21,860
我想让它无限循环很多次 

1846
01:31:21,860 --> 01:31:27,520
所以现在如果我像往常一样祈祷 按回车键 

1847
01:31:27,520 --> 01:31:30,710
没有发生什么坏事 这几乎总是一件好事 

1848
01:31:30,710 --> 01:31:38,480
现在让我运行starumes.gif的代码 在VS代码中打开最终的图像 

1849
01:31:38,480 --> 01:31:42,610
我认为我应该看到的是一只非常快乐的猫？

1850
01:31:42,610 --> 01:31:43,510
确实如此 

1851
01:31:43,510 --> 01:31:47,320
所以现在我们已经看到 我们不仅可以读写文件 无论是文本文件 

1852
01:31:47,320 --> 01:31:51,405
我们现在可以读取和写入二进制0和1的文件 

1853
01:31:51,405 --> 01:31:52,780
我们只是触及了皮毛 

1854
01:31:52,780 --> 01:31:54,790
这是在使用名为Pillow的图书馆 

1855
01:31:54,790 --> 01:31:58,120
但最终 这将使我们能够读写文件

1856
01:31:58,120 --> 01:31:59,240
随心所欲 

1857
01:31:59,240 --> 01:32:03,340
我们现在已经看到 通过文件I/O 我们不仅可以操作文本文件 

1858
01:32:03,340 --> 01:32:06,790
无论是TXT文件 还是CSV 甚至二进制文件也是如此 

1859
01:32:06,790 --> 01:32:08,840
在这种情况下 它们恰好是图像 

1860
01:32:08,840 --> 01:32:11,950
但如果我们潜水更深 我们可以探索音频和视频 

1861
01:32:11,950 --> 01:32:15,400
通过这些简单的原语 这种能力 

1862
01:32:15,400 --> 01:32:18,250
以某种方式读写文件 

1863
01:32:18,250 --> 01:32:19,460
这就是目前的情况 

1864
01:32:19,460 --> 01:32:21,840
我们下次再见 

